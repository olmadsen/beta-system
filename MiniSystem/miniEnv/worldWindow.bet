ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE '~beta/guienv/utils/prompts';
INCLUDE 'tableview';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'sequencediagram';
INCLUDE 'log';
INCLUDE 'newAttributeBox';
INCLUDE 'prompt';
INCLUDE '../miniCompiler/generator';
INCLUDE '../miniCompiler/betaVM';
INCLUDE '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/utils/guienvadds';

-- lib: attribute --

IntStack:
  (# push:
       (# value: @integer;
       enter value
       do (if top = storage.range then
              storage.range -> storage.extend;
          if);
          top + 1 -> top;
          value -> storage[top];
       #);
     pop:
       (# value: @integer;
       do (if top > 0 then
              storage[top] -> value;
              top - 1 -> top;
          if);
       exit value
       #);
     peek:
       (# value: @integer;
       do (if top > 0 then
              storage[top] -> value;
          if);
       exit value
       #);
     size:
       (# value: @integer;
       do top -> value;
       exit value
       #);
     empty:
       (# result: @boolean;
       do (top = 0) -> result;
       exit result
       #);
     scan:
       (# current: @integer;
       do (for inx: top repeat
               storage[inx] -> current;
               INNER;
          for);
       #);
     print:
       (#
       do '[ ' -> putText;
          scan
          (#
          do current -> putInt;
             ' ' -> putText;
          #);
          ']' -> putline;;
       #);
     storage: [1] @integer;
     top: @integer;
  #);

---guienvlib:attributes---

World:
  (#
     EMBEDDED: (# exit true #);
     
     UserYes: (# exit 1 #);
     UserNo: (# exit 2 #);
     UserCancel: (# exit 3 #);
     promptUser:
       (# dialog: @PromptDialog
            (# onYes::
                 (#
                 do UserYes -> result;
                    dialog.close;
                 #);
               onNo::
                 (#
                 do UserNo -> result;
                    dialog.close;
                 #);
               onCancel::
                 (#
                 do UserCancel -> result;
                    dialog.close;
                 #);
            #);
          left, top: @integer;
          mainWidth, mainHeight: @integer;
          dialogWidth, dialogHeight: @integer;
          
          message: ^Text;
          title: ^Text;
          result: @integer;
          parent: ^Window;
       enter (parent[], title[], message[])
       do dialog.open;
          parent.position -> (left, top);
          parent.size -> (mainWidth, mainHeight);
          dialog.size -> (dialogWidth, dialogHeight);
          (left + (mainWidth - dialogWidth) div 2, top + 60) -> dialog.position;
          message[] -> dialog.changeLabel;
          title[] -> dialog.title;
          dialog.showModal;
       exit result
       #);
     defaults: @
       (# headH: (# exit 20 #);
          worldWindowW: (# exit 1420 #);
          worldWindowH: (# exit 860 #);
          componentW: (# exit 480 #);
          componentH: (# exit 800 #);
          mainBrowserW: (# exit 380 #);
          mainBrowserH: (# exit 120 #);
          browserW: (# exit 92 #);
          browserH: (# exit 120 - 11 #); (* - 2 * borderWidth *)
          textEditW: (# exit 201 #);
          textEditH: (# exit 650 - 11 #);
       #);
     
     execution: ^Window.SequenceWindow;
     theSystemEnv: ^SystemEnv;
     objContRoot: ^objCont.handle;

     scan:
       (# current: ^WorldWindow.ComponentWindow;
       do theWorldWindow.components.scan
          (#
          do current[] -> THIS(Scan).current[];
             INNER scan;
          #);
       #);
     selectDesc:
       (# obj: ^objDesc.template;
          path: ^intList;
          descNo: @integer;
          desc: ^generator.ObjectDesc;
          lsc: @integer;
          objC: ^objCont.handle;
       enter (obj[], descNo, path[], desc[], lsc)
       do path.up;
          L: scan
            (#
            do (if ((obj[], descNo, path[]) -> current.selectCode -> objC[]) <> none then
                   (path[], 2, desc[], lsc) -> current.selectDesc;
                   leave L;
               if);
            #);
       exit objC[]
       #);
     selectCode:
       (# obj: ^objDesc.template; 
          path: ^intList; 
          descNo, beginPos, endPos: @integer;
          objC: ^objCont.handle;
       enter (obj[], descNo, path[], beginPos, endPos)
       do path.up;
          L: scan
            (#
            do (if ((obj[], descNo, path[]) -> current.selectCode -> objC[]) <> none then
                   (path[], 2, beginPos, endPos) -> current.select;
                   leave L;
               if);
            #);
       exit objC[]
       #);
     popUp: @menu
       (# iNew: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# newWorldWindow: ^WorldWindow;
                      do &WorldWindow[] -> newWorldWindow[];
                         newWorldWindow.open;
                      #);
                 #);
               open:: (# do 'New Browser' -> name; iNew[] -> append; #);
            #);
          iSave: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do 'SaveAll' -> putline;
                         THIS(World).scan 
                         (# 
                         do current.saveEditBuffers 
                         #);
                         objContRoot.saveModuleToFile
                 #)#);
               open:: (# do 'Save All' -> name; iSave[] -> append; #);
            #);
          iQuit: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do terminate 
                      #)
                 #);
               open:: (# do 'Quit' -> name; iQuit[] -> append #);
            #);
          open::
            (#
            do iNew.open;
               iSave.open;
               iQuit.open
            #);
       #);
     
     createExecution:
       (# browser: ^WorldWindow.ComponentWindow;
       enter browser[]
       do &theWorldWindow.SequenceWindow[] -> execution[];
          execution.open;
          browser.navi[] -> execution.navi[];
          (if EMBEDDED then
              theWorldWindow.placeholder[] -> theWorldWindow.mainLayout.remove;
          if);
          execution.layout[] -> theWorldWindow.mainLayout.add;
          480 -> theWorldWindow.leftLayout.width;
          theWorldWindow.mainLayout.layout;                                  
          compile[] -> execution.setCompiler;
          L[] -> execution.setLog;
          &|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM;
          execution.show;
       #);
     
     TopLevelWindow: Window
       (# full: @boolean;
          layoutflag: @boolean;
          mainLayout: @HorizontalLayoutManager
            (# changed::
                 (#
                 do true -> layoutFlag;
                 #);
            #);
          updater: @Timer
            (# action::
                 (#
                 do (if layoutFlag then
                        false -> layoutFlag;
                        mainLayout.layout;
                    if);
                 #);
            #);
          
          menuBarType::
            (# theFileMenu: @menu
                 (# iNew: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# newWorldWindow: ^WorldWindow;
                                do &WorldWindow[] -> newWorldWindow[];
                                   newWorldWindow.open;
                                #);
                           #);
                         open:: (# do 'New Browser' -> name; iNew[] -> append; #);
                      #);
                    iSave: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do 'SaveAll' -> putline;
                                   THIS(World).scan 
                                   (# 
                                   do current.saveEditBuffers 
                                   #);
                                   objContRoot.saveModuleToFile
                           #)#);
                         open:: (# do 'Save All' -> name; iSave[] -> append; #);
                      #);
                    iQuit: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do terminate 
                                #)
                           #);
                         open:: (# do 'Quit' -> name; iQuit[] -> append #);
                      #);
                    open::
                      (#
                      do 'File' -> name;
                         iNew.open;
                         iSave.open;
                         iQuit.open
                      #);
                 #);
               open::
                 (#
                 do theFileMenu.open;
                    theFileMenu[] -> append;
                 #);
            #);
          
          open::<
            (# frame: @Rectangle;
               width, height: @integer;
              
            enter full
            do (if full then
                   screenRectangle -> frame;
                   frame.size -> (width, height);
                   (width - 20, height - 35 - 50) -> size;
                else
                   (800, 600) -> size;
               if);
               
               
               (10,35) -> position;
               mainLayout.init;
               THIS(Window).size -> mainLayout.size;
              
               100 -> updater.start;
               INNER;
            #);
          close::<
            (#
            do updater.stop;
               INNER;
            #);
          eventHandler::
            (# onMouseDown::
                 (# P: @point
                 do (if buttonState = 3 then
                        localPosition -> P;
                        popUp.enable;
                        (1,(P.H,P.V), contents) -> popUp.popUp;
                    if);
                 #);
            #);
       #);
     
     StandaloneWindow: TopLevelWindow
       (# 
          StandaloneSequenceWindow: SequenceWindow
            (# 
               eventHandler::
                 (#
                    onFatherFrameChanged::
                      (#
                      do THIS(StandaloneWindow).size -> mainLayout.size;
                         mainLayout.layout;
                      #);
                 #);
            #);
         
       #);
     
     createStandaloneExecution: Navigator
       (# browser: ^WorldWindow.ComponentWindow;
          standalone: @StandaloneWindow;
          showCode::
            (#
            do caller[] -> VM.selectCode;
            #);
          showDescriptor::
            (#
            do desc[] -> browser.selectDescriptor;
            #);
          showNode::
            (#
            do node[] -> browser.selectNode;
            #);
          onClose::
            (#
            do standalone.close;
            #);
       enter browser[]
       do standalone.open;
          &standalone.StandaloneSequenceWindow[] -> execution[];
          execution.open;
          execution.layout[] -> standalone.mainLayout.add;
          compile[] -> execution.setCompiler;
          L[] -> execution.setLog;
          &|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM;
          standalone.mainLayout.layout;
          THIS(Navigator)[] -> execution.navi[];
          execution.show;
       #);
     
     
     
     WorldWindow: TopLevelWindow
       (# 
          open:: 
            (# 
            do 'BETAworld' -> title;
               leftLayout.init;
               leftLayout[] -> mainLayout.add;
               (if full then
                   placeholder[] -> mainLayout.add;
                else
                   mainLayout.layout;
               if);
               
               combine;
               (if not full then
                   mainLayout.layout;
               if);
            #);
          
          
          
         
          leftLayout: @VerticalLayoutManager;
          
          
          components: @Sequence
            (# element:: ComponentWindow;
            #);
          
          addByIndex:
            (# inx: @integer;
               objC: ^objCont.Handle;
               name: ^Text;
               width, height: @integer;
               component: ^ComponentWindow;
               root: @boolean;
            enter inx
            do (if inx = 0 then
                   'BETA world' -> name[];
                   true -> root;
                   1 -> inx;
                   objContRoot[] -> objC[];
                else
                   objContRoot.dclNames[inx][] -> name[];
                   false -> root;
                   inx -> objContRoot.elm -> objC[];
               if);
               &ComponentWindow[] -> component[];
               (NONE, name[], root, inx, objC[]) -> component.open;
               component.size -> (width, height);
               (width, height / 5) -> component.size;
               component.layout[] -> leftLayout.add;
               component[] -> components.append;
            exit component[]
            #);
          closeAll:
            (#
            do components.scan
               (#
               do current.layout[] -> leftLayout.remove;
                  current.close;
               #);
               components.clear;
            #);
          initialLayout:
            (#
            do THIS(Window).size -> leftLayout.size;
               480 -> leftLayout.width;
               leftLayout.layout;
            #);
          combine:
            (#
            do closeAll;
               0 -> addByIndex -> mainBrowser[];;
               initialLayout;
            #);
          split:
            (#
            do closeAll;
               (for inx: objContRoot.dclNames.range repeat
                    inx -> addByIndex;
               for);
               initialLayout;
            #);
          newBrowser:
            (# component: ^ComponentWindow;
            do 0 -> addByIndex -> component[];
               component.layout[] -> leftLayout.layout;
            #);
          
          
          
          

          
          displayWindow:
            (* Super pattern for static item in ComponentWindow, Items and TextEditor  *)
            (# enclosingObjCont: ^objCont.handle;
               left,right: ^displayWindow;
               setUpBrowser:< (# do inner #);
               position:< (# pos: @point do inner exit pos #);
               size:< (# width,height: @integer do inner exit(width,height) #);
               reDisplay:< (# do inner #);
               hasEditChanges:< BooleanValue (# do inner #);
               select:< (# do inner #);
               showErrors:< (# errors: ^stream enter errors[] do inner #);
               hideErrors:< (# do INNER #);
               close:< (# do inner #);
               closeEditor:< (# do inner #);
               save:< (# errors: ^text do inner exit errors[] #);
               print:< (# T: @text do inner exit T[] #);
               description:<
                 (# value: ^Text;
                 do 'UNK' -> value[];
                    INNER;
                 exit value[]
                 #);
            #);
          
          
          
          mainBrowser: ^ComponentWindow;
          
          ComponentWindow:  Subwindow
            (# navigation:: (# do true -> value #);
               fixed: ^TextStyle;
               root: @boolean;
               back: ^NavigationRecord;
               
               onBack::
                 (#
                 do navigateBack;
                 #);
               selectNode:
                 (# node: ^generator.Node;
                    md: ^generator.Module;
                    record: ^PathRecord;
                 enter node[]
                 do getPath -> record[];
                    back[] -> record.back[];
                    record[] -> back[];
                    node.theModule -> md[];
                    (if md[] <> NONE then
                        md[] -> selectModule;
                        (if rightEditor[] <> NONE then
                            (node.beginPos, node.beginPos) -> rightEditor.setSelection;
                            rightEditor.contents[] -> target;
                        if);
                    if);
                 #);
               selectDescriptor:
                 (# desc: ^ObjDesc;
                    OD: ^generator.ObjectDesc;
                    md: ^generator.Module;
                 enter desc[]
                 do desc.descInx -> THIS(World).compile.newDesc.getOD -> OD[];
                    OD[] -> selectNode;
                 #);
               navi: @Navigator
                 (# showCode::
                      (#
                      do caller[] -> VM.selectCode;
                      #);
                    showDescriptor::
                      (# 
                      do desc[] -> selectDescriptor;
                      #);
                    showNode::
                      (#
                      do node[] -> selectNode;
                      #);
                    onClose::
                      (#
                      do execution.layout[] -> mainLayout.remove;
                         execution.close;
                         NONE -> execution[];
                         (if full then
                             placeholder[] -> mainLayout.add;
                         if);
                      #);
                 #);
               NavigationRecord:
                 (# back: ^NavigationRecord;
                    navigate:<
                      (#
                      do INNER;
                      #);
                 #);
               FocusRecord: NavigationRecord
                 (# navigate::
                      (#
                      do (index, content[], name[]) -> changeContent;
                      #);
                    content: ^objCont.Handle;
                    index: @integer;
                    name: ^Text;
                 #);
               
               maximum: @integer;
               onExpand::
                 (# width, height: @integer;
                 do THIS(SubWindow).size -> (width, height);
                    (width, maximum) -> THIS(SubWindow).size;
                    grow.show;
                 #);
               onCollapse::
                 (# width, height: @integer;
                 do THIS(SubWindow).size -> (width, height);
                    (width, 20 + 2 * theBorderWidth) -> THIS(SubWindow).size;
                    height -> maximum;
                    grow.hide;
                 #);
               
               open::
                 (# index: @integer;
                    objC: ^ObjCont.handle;
                    width, height: @integer;
                    
                 enter (root, index, objC[])
                 do 'icons\\error.png' -> loadImage -> errorIcon[];
                    'icons\\package.png' -> loadImage -> packageIcon[];
                    'icons\\publicpackage.png' -> loadImage -> publicpackageIcon[];
                    'icons\\privatepackage.png' -> loadImage -> privatepackageIcon[];
                    'icons\\pattern.png' -> loadImage -> patternIcon[];
                    'icons\\virtual.png' -> loadImage -> virtualIcon[];
                    'icons\\reference.png' -> loadImage -> referenceIcon[];
                    'icons\\lightref.png' -> loadImage -> lightrefIcon[];
                    'icons\\simple.png' -> loadImage -> simpleIcon[];
                    'icons\\array.png' -> loadImage -> arrayIcon[];
                    'icons\\cog.png' -> loadImage -> cogwheel[];
                    
                    &TextStyle[] -> fixed[];
                    'Courier' -> fixed.name;
                    8 -> fixed.size;
                    textFaces.plain -> fixed.face;
                    
                    (0, 0) -> position;
                    scroller.open;
                    scroller[] -> browser.open;
                    (theBorderWidth, defaults.headH + theBorderWidth)
                      -> scroller.position;
                    (480, defaults.browserH) -> browser.size;
                    browser.size -> scroller.size;
                    
                    true -> flexible;
                    (index, objC[], lab[]) -> setContent;
                    scroller.layout;
                    false -> flexible;
                    
                    THIS(Window).size -> (width, height);
                    (defaults.componentW, height) -> size;
                    fitToContents;
                 #);
               
               
               navigateTo:
                 (# index: @integer;
                    objC: ^objCont.Handle;
                 enter (index, objC[])
                 do (# record: ^FocusRecord;
                       name: ^Text;
                    do &FocusRecord[] -> record[];
                       thisIndex -> record.index;
                       head.label -> record.name[];
                       asDW.enclosingObjCont[] -> record.content[];
                       back[] -> record.back[];
                       record[] -> back[];
                       (if objC.theName[] <> NONE then
                           objC.theName.copy -> name[];
                        else
                           '' -> name[];
                       if);
                       (index, objC[], name[]) -> changeContent;
                    #);
                 #);
               navigateBack:
                 (# 
                 do (if back[] <> NONE then
                        back.navigate;
                        back.back[] -> back[];
                    if);
                 #);
               changeContent:
                 (# index: @integer;
                    objC: ^objCont.Handle;
                    name: ^Text;
                 enter (index, objC[], name[])
                 do theItems.closeRight;
                    theItems.close;
                    NONE -> theItems[];
                    (index, objC[], name[]) -> setContent;
                 #);
               setContent:
                 (# index: @integer;
                    objC: ^objCont.Handle;
                    name: ^Text;
                 enter (index, objC[], name[])
                 do index -> thisIndex;
                    objC[] -> asDW.enclosingObjCont[];
                    (NONE, 1, asDW.enclosingObjCont[])
                      -> (&BrowserItems[] -> theItems[]).setUpBrowser;
                    name[] -> head.label;
                    head.update;
                 #);
               asDW: @ displayWindow
                 (# size:: (# do this(componentWindow).size -> (width,height) #);
                    position:: (# do this(componentWindow).position -> pos #);
                    reDisplay:: (#do 'componentWindow.asDW:reDisplay:shouldNotHappen' -> putline #);
                    hasEditChanges:: (# do 'componentWindow.asDW:hasEditChanges:shouldNotHappen' -> putline #);
                    save:: (# do 'componentWindow.asDW:save:shouldNotHappen' -> putline #);

                 #);
               onOpenClose::
                 (# w, h: @integer
                 do (if true then
                        true -> THIS(ComponentWindow).sizeToFit;
                     else
                        (if miniSize then
                            'OpenClose:Grow'->putline;
                            (fullW,fullH) -> this(componentWindow).size
                         else
                            'OpenClose:Reduce' -> putline;
                            this(componentWindow).size -> (fullW,fullH);
                            head.size -> (w,h);
                            (50,h)
                              -> this(componentWindow).size;
                            w-> putint; ' ' -> put; h -> putint; newline
                        if);
                        not miniSize -> miniSize;
                    if)
                 #);

               miniSize: @ boolean;
               fullW,fullH: @integer;
               selectCode: 
                 (# obj: ^objDesc.template; descNo: @integer; path: ^intList; objC: ^objCont.handle
                 enter(obj[],descNo,path[])
                 do (obj[],descNo,path[]) -> asDW.enclosingObjCont.selectCode -> objC[]
                 exit objC[]
                 #);
               selectDesc:
                 (# path: ^intList; inx: @integer;
                    desc: ^generator.ObjectDesc;
                    lsc: @integer;
                    beginPos, endPos: @integer;
                    result: ^TextEdit;
                 enter(path[],inx, desc[], lsc)
                 do (path[],inx, 0, 0) -> theItems.select -> result[];
                    true -> desc.doPT; (* OBS! true is needed to update charPos in desc *)
                    lsc 
                      -> desc.acp.mapBCposToCharRange 
                      -> (beginPos,endPos);
                    (beginPos, endPos) -> result.select;
                 #);
               select:
                 (# path: ^intList; inx,beginPos,endPos: @integer;
                    result: ^TextEdit;
                 enter(path[],inx,beginPos,endPos)
                 do '-- items select' -> putline;
                    (path[],inx, 0, 0) -> theItems.select -> result[];
                    (beginPos, endPos) -> result.select;
                 #);
               selectPath:
                 (# path: ^IntStack;
                 enter path[]
                 do path[] -> theItems.selectPath;
                 #);
               selectModule:
                 (# theModule: ^generator.Module;
                    theHandle: ^objCont.Handle;
                    path: ^IntStack;
                    flip:
                      (# in: ^IntStack;
                         out: ^IntStack;
                      enter in[]
                      do &IntStack[] -> out[];
                         loop:
                           (if not in.empty then
                               in.pop -> out.push;
                               restart loop;
                           if);
                      exit out[]
                      #);
                    findHandle:
                      (# theModule: ^generator.Module;
                         theHandle: ^objCont.Handle;
                         path: ^IntStack;
                      enter (theModule[], path[])
                      do (if theModule[] = objContRoot.theEntry[] then
                             objContRoot[] -> theHandle[];
                          else
                             (# enclosing: ^objCont.Handle;
                                current: ^objCont.Handle;
                             do (theModule.origin.theModule, path[]) -> findHandle -> enclosing[];
                                (for inx: enclosing.handles.range repeat
                                     inx -> enclosing.elm -> current[];
                                     (if current.theModule[] = theModule[] then
                                         inx -> path.push;
                                         current[] -> theHandle[];
                                     if);
                                for);
                             #);
                         if);
                      exit theHandle[]
                      #);
                 enter theModule[]
                 do &IntStack[] -> path[];
                    (theModule[], path[]) -> findHandle -> theHandle[];
                    path[] -> flip -> path[];
                    path[] -> selectPath;
                 #);
               getPath:
                 (# path: ^IntStack;
                    collect:
                      (# from: ^BrowserItems;
                      enter from[]
                      do (if from.right[] <> NONE then
                             from.right[] -> collect;
                         if);
                         (if from.selection.first > 0 then
                             from.selection.first -> path.push;
                         if);
                      #);
                    begin, end: @integer;
                    record: ^PathRecord;
                 do &IntStack[] -> path[];
                    theItems[] -> collect;
                    (if rightEditor[] <> NONE then
                        rightEditor.contents.selection.get -> (begin, end);
                    if);
                    &PathRecord[] -> record[];
                    path[] -> record.path[];
                    begin -> record.begin;
                    end -> record.end;
                 exit record[]
                 #);
               
               PathRecord: NavigationRecord
                 (# path: ^IntStack;
                    begin: @integer;
                    end: @integer;
                    navigate::
                      (#
                      do path[] -> selectPath;
                         (if rightEditor[] <> NONE then
                             rightEditor.contents[] -> target;
                             (begin, end) -> rightEditor.setSelection;
                         if);
                      #);
                 #);
               
               Heading::<
                 (# open::
                      (#
                      do headingPopUp.open
                      #);
                    eventHandler::<
                      (# onMouseUp::
                           (# P: @point
                           do (if buttonState = 3 then
                                  localPosition -> P;
                                  (1,(P.h,P.v),this(Heading)[]) -> headingPopUp.popUp
                              if)
                           #);                       
                         onMouseEnter:: (# #);
                      #);
                    headingPopUp: @menu
                      (# iSplit: @menuItem
                           (# eventHandler::
                                (# onSelect::
                                     (#
                                     do (if root then
                                            split;
                                         else
                                            combine;
                                        if);
                                     #)
                                #);
                              open:: 
                                (# 
                                do (if root then
                                       'Split' -> name;
                                    else
                                       'Assemble' -> name;
                                   if);
                                   iSplit[] -> append;
                                #)
                           #);
                         iNew: @menuItem
                           (# open::
                                (#
                                do 'New Browser' -> name;
                                   iNew[] -> append;
                                #);
                              eventHandler::
                                (# onSelect::
                                     (#
                                     do newBrowser;
                                     #);
                                #);
                           #);
                         iBack: @menuItem
                           (# open::
                                (#
                                do 'Back' -> name;
                                   iBack[] -> append;
                                #);
                              eventHandler::
                                (#
                                   onSelect::
                                     (#
                                     do navigateBack;
                                     #);
                                #);
                           #);
                         iClose: @MenuItem
                           (# eventHandler::
                                (# onSelect::
                                     (#
                                     do layout[] -> leftLayout.remove;
                                        THIS(ComponentWindow).close;
                                        THIS(ComponentWindow)[] -> components.delete;
                                        leftLayout.layout;
                                     #)
                                #);
                              open:: 
                                (# 
                                do 'Close' -> name; 
                                   iClose[] -> append;
                                #);
                           #);
                         open::
                           (#
                           do iSplit.open;
                              iNew.open;
                              iBack.open;
                              iClose.open;
                           #)
                      #);
                 #);
               eventHandler::
                 (# count: @integer;
                    onFatherFrameChanged::
                      (#
                      do THIS(WorldWindow).size -> mainLayout.size;
                         mainLayout.layout;
                         
                      #);
                    onMouseDown::
                      (# 
                      do trackMouse
                         (# mouseMove:: 
                              (#
                              do (h, v) -> move;
                                 true -> this(SubWindow).update
                              #)
                         #)
                      #);
                 #);
               scroller: @Canvas
                 (# count: @integer;
                    visible: @boolean;
                    theScrollBar: @ScrollBar
                      (# count: @integer;
                         eventHandler::
                           (# onValueChanged::
                                (#
                                do theScrollBar.value -> scroll;
                                #);
                           #);
                      #);
                    scroll:
                      (# value: @integer;
                         x, y: @integer;
                      enter value
                      do browser.position -> (x, y);
                         (-value, y) -> browser.position;
                      #);
                    getScroll:
                      (# x, y: @integer;
                      do browser.position -> (x, y);
                      exit -x
                      #);
                    
                    layout:
                      (# width, height: @integer;
                         w, h: @integer;
                         x, y: @integer;
                      do position -> (x, y);
                         THIS(SubWindow)[] -> theScrollBar.open;
                         size -> (width, height);
                         theScrollBar.size -> (w, h);
                         (width, h) -> theScrollBar.size;
                         (0, y + height - h) -> theScrollBar.position;
                         true -> theScrollBar.bindRight;
                         theScrollBar.hide;
                         true -> browser.bindBottom;
                      #);
                    checking: @boolean;
                    checkScrollValues:
                      (# page: @integer;
                         port: @integer;
                         excess: @integer;
                         h1: @integer;
                         h2: @integer;
                         h, w: @integer;
                         value: @integer;
                         checkit: @boolean;
                      do (if NOT checking then
                             true -> checking;
                             browser.size -> (page, h1);
                             scroller.size -> (port, h2);
                             theScrollBar.size -> (w, h);
                             (if page <= port then
                                 (if visible then
                                     theScrollBar.hide;
                                     false -> visible;
                                 if);
                                 (port, defaults.browserH) -> scroller.size;
                                 0 -> scroll;
                              else
                                 page - port -> excess;
                                 (if not visible then
                                     theScrollBar.show;
                                     true -> visible;
                                 if);
                                 (port, defaults.browserH - h) -> scroller.size;
                                 excess -> theScrollBar.maxValue;
                                 (if true then
                                     excess -> theScrollBar.value;
                                  else
                                     (if theScrollBar.value > excess then
                                         excess -> theScrollBar.value;
                                     if);
                                 if);
                                 getScroll -> value;
                                 (if value <> theScrollBar.value then
                                     theScrollBar.value -> scroll;
                                 if);
                                 browser.scrollIntoView;
                             if);
                             false -> checking;
                         if);
                      #);
                    eventHandler::
                      (# onFrameChanged::
                           (#
                           do checkScrollValues;
                              (if false then
                                  (if rightEditor[] <> NONE then
                                      rightEditor.adjustLineWidth;
                                  if);
                              if);
                           #);
                      #);
                 #);
               browser: @Canvas
                 (# sizeToFit:
                      (# current: ^BrowserItems;
                         x, y: @integer;
                         w, h: @integer;	
                         minimum: @integer;
                         width, height: @integer;
                      do (if theItems[] <> NONE then
                             theItems[] -> current[];
                             loop:
                               (if current.right[] <> NONE then
                                   current.right[] -> current[];
                                   restart loop;
                               if);
                             current.position -> (x, y);
                             current.size -> (w, h);
                             size -> (width, height);
                             x + w + 1 -> width;
                             (width, height) -> size;
                         if);
                      #);
                    scrollIntoView:
                      (# current: ^BrowserItems;
                      do theItems[] -> current[];
                         loop:
                           (if current[] <> NONE then
                               current.scrollIntoView;
                               current.right[] -> current[];
                               restart loop;
                           if);
                      #);
                 #);
               theItems: ^BrowserItems; (* top Items of this(ComponentWindow) *)
               currentSelection: ^DisplayWindow; (* Current selection *)
               
               saveEditBuffers: (# do theItems.saveEditBuffers #);
               
               sizeToFit:
                 (# current: ^BrowserItems;
                    x, y: @integer;
                    w, h: @integer;
                    minimum: @integer;
                    width, height: @integer;
                    resize: @boolean;
                 enter resize
                 do browser.sizeToFit;
                    browser.size -> (w, h);
                    (w, h) -> scroller.size;
                    false -> scroller.bindRight;
                    size -> (width, height);
                    w + theBorderwidth*2 -> minimum;
                    (if (minimum > width) and resize then
                        (minimum, height) -> size;
                     else
                        (width - theBorderwidth*2, h) -> scroller.size;
                    if);
                    true -> scroller.bindRight;
                    scroller.checkScrollValues;
                 #);
               
               BrowserItems: TableView
                 (# open::
                      (# v: @point; h: @integer;
                         lWidth,lHeight: @integer;
                         
                      do (if asDW.left[] <> none then
                             asDW.left.position -> v;
                             asDW.left.size -> (lWidth,lHeight);
                             v.h + lWidth -> h
                          else 
                             1 -> h;
                             defaults.browserW -> lWidth;
                             defaults.browserH -> lHeight
                         if);
                         
                         (h, 1) -> position;
                         (if scroller.visible then
                             (defaults.browserW, defaults.browserH - 16) -> size;
                          else
                             (defaults.browserW, defaults.browserH) -> size;
                         if);
                         fixed[] -> style;
                         true -> bindLeft;
                         itemPopUp.open; 
                         
                      #);
                    asDW: @DisplayWindow
                      (* objC is an entry of the form
                       *    E = (X1,X2,... Xn)
                       * where X1, X2, ..., Xn
                       * are displayed in the item-list
                       *)
                      (# size:: (# do this(BrowserItems).size -> (width,height) #);
                         position:: (# do this(BrowserItems).position -> pos #);
                         thisInx: @integer;
                         thisObjCont:
                           (# objC: ^objCont.Handle
                           do (if thisInx > 0 then
                                  thisInx -> enclosingObjCont.elm -> objC[];
                              if);
                           exit objC[]
                           #);
                         reDisplay:: (# do (thisInx,0,0,true) -> display#);
                         hasEditChanges:: 
                           (# do (rightEditor[]<> none) and rightEditor.wasChanged -> value #);
                         closeEditor:: (# do none -> rightEditor[] #);
                         showErrors:: (# do errors[] -> this(browserItems).showErrors #);
                         hideErrors:: (# do THIS(BrowserItems).hideErrors; #);
                         save::
                           (# right: ^BrowserItems
                           do (if hasEditChanges then
                                  'Must save: ' -> puttext; 
                                  ((thisObjCont).enclosingModuleObj).theName[] -> putline;
                                  print -> putline;
                                  saveEditBuffers -> errors[];
                                  
                                  'errors: "' -> puttext;
                                  errors[] -> puttext;
                                  '"' -> putline;
                                  
                                  ((thisObjCont).enclosingModuleObj).saveModuleToFile;
                                  (* closeRight;  --- if called from TextEdit::onTab, we
                                   * should not close the textEditor
                                   * Some redundancy with display below
                                   *)
                                  
                                  &BrowserItems[] -> right[];
                                  right.asDW[] -> asDW.right[];
                                  right[] -> THIS(BrowserItems).right[];
                                  (asDW[],thisInx,thisObjCont) -> right.setUpBrowser;
                              if)                      
                           #);
                         print::
                           (# 
                           do (if thisInx > 0 then
                                  (thisObjCont).entityPathFromModule -> T.puttext
                               else
                                  'No selection' -> T.puttext
                              if);
                           #);
                         description::
                           (#
                           do '[' -> value[];
                              enclosingObjCont.theName[] -> value.puttext;
                              ']' -> value.puttext;
                           #);
                      #);
                    
                    process:
                      (# event: ^EventHandler.MouseEvent;
                         P: @point;
                         
                      enter event[]
                      do (if selection.first > 0 then
                             (if event.doubleClick then 
                                 (* selection.first -> gettext -> putline;
                                  * 'Edit field' -> putline;
                                  *)
                                 selection.first -> editField;
                                 event.LocalPosition -> P;
                                 (* 'mouse.V: ' -> puttext; P.V -> putint; 
                                  * ' mouse.H: ' -> puttext; P.H -> putint; newline;
                                  *)
                              else                             
                                 (if event.buttonState
                                  // 1 then 
                                     (selection.first,0,0,true) -> display
                                  // 3 then
                                     (selection.first,0,0,true) -> display;
                                     (if ((selection.first 
                                           -> asDW.thisInx 
                                           -> asDW.enclosingObjCont.elm).theEntry.kind)
                                         = '/' then
                                         itemPopUp.saveHandler[] -> itemPopUp.iSave.attach;
                                         (* Perhaps also insist on a do-part for iExe?*)
                                         itemPopUp.exeHandler[] -> itemPopUp.iExe.attach
                                     if);
                                     (if clipboard.hasText then
                                         itemPopUp.textPasteHandler[] -> itemPopUp.iPaste.attach;
                                         itemPopUp.textPasteModuleHandler[] -> itemPopUp.iPasteAsModule.attach;
                                     if);
                                     (1,event.localposition,this(BrowserItems)[]) -> itemPopUp.popUp;
                                 if);
                             if);
                          else
                             closeRight;
                             &textEdit[] -> rightEditor[];
                             (asDW[], asDW.enclosingObjCont[],0,0) -> rightEditor.setUpEditor;
                             (if event.buttonState = 3 then
                                 (if clipboard.hasText then
                                     itemPopUp.textPasteHandler[] -> itemPopUp.iPaste.attach;
                                     itemPopUp.textPasteModuleHandler[] -> itemPopUp.iPasteAsModule.attach;
                                 if);
                                 (1,event.localposition,this(BrowserItems)[]) -> itemPopUp.popUp;
                             if);
                         if);
                      #);
                    onMouseDown::
                      (#
                      do event[] -> process;
                      #);
                    eventHandler::
                      (# onMouseUp::
                           (#
                           do THIS(MouseEvent)[] -> process;
                           #)
                      #);
                    editField:
                      (# no: @integer; 
                         oldCont,oldName,newName: ^text; 
                         oldKind,newKind: @char;
                         P: @point; R: @rectangle;
                         TE: @editText
                           (# open::
                                (# 
                                do this(BrowserItems).style -> style;
                                   borderStyles.simple -> border.style;
                                   false -> border.visible;
                                   (P.H + 1,P.V + R.top + 2) -> position;
                                   (R.right-R.left+5,R.bottom-R.top+5) -> size; 
                                   (* must add 5 to height for text cursor to be visible *)
                                   no -> gettext -> oldCont[] -> contents;
                                #);
                              eventHandler::<
                                (# onKeyDown:: 
                                     (# error: @boolean
                                     do (* 'Key down: ' -> puttext; ch -> put; 
                                         ch -> putint; newline; ascii.nl -> putint; newline;
                                         *)
                                        (if ch = 13 (* nl on Windows?*) then
                                            (if not (contents -> oldCont.equal) then
                                                (oldCont[],contents) -> asDW.enclosingObjCont.changeAttName -> error;
                                                (if error then
                                                    'Syntax error in browser item: '-> puttext;
                                                    contents -> putline
                                                 else
                                                    (no,contents) -> setText;
                                                if)
                                            if);
                                            close
                                        if)
                                     #)
                                #)
                           #)
                      enter no
                      do no -> getItemRectangle -> R;
                         this(BrowserItems).position -> P;
                         browser[] -> TE.open
                      #);
                    display:
                      (* for asDW where E = (X1,X2, ..., Xn)
                       * Xinx has been selected2
                       *)
                      (# inx,beginPos,endPos: @integer; 
                         mkTxtEditor: @boolean;
                         result: ^TextEdit;
                      enter (inx, beginPos, endPos, mkTxtEditor)
                      do L:
                           (# objCx: ^ObjCont.handle;
                           do (if currentSelection[] <> none then
                                  (if currentSelection.save <> none then
                                      (* syntax errors in edit buffer og currentSelection *)
                                      leave L
                                  if)
                              if);
                              closeRight;
                              asDW[] -> currentSelection[];
                              inx -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objCx[];
                              
                              (if objCx[] <> none then (* should never be none ! *)
                                  (if pred[] <> none then (* why? *) pred.closeEditor if);
                                  &BrowserItems[] -> right[];
                                  right.asDW[] -> asDW.right[];
                                  (asDW[],index,objCx[]) -> right.setUpBrowser;
                                  flexible -> THIS(ComponentWindow).sizeToFit;
                                  (if mkTxtEditor then
                                      &textEdit[] -> rightEditor[];
                                      (asDW[],objCx[],beginPos,endPos) -> rightEditor.setUpEditor;
                                      rightEditor[] -> result[];
                                  if);
                               else
                                  'objCx is NONE' -> putline;
                              if);
                           #);
                      exit result[]
                      #);
                    hideErrors:
                      (# width, height: @integer;
                      do (if errorView[] <> NONE then
                             errorView.close;
                             NONE -> errorView[];
                             (if rightEditor[] <> NONE then
                                 rightEditor.size -> (width, height);
                                 (width, height + 320) -> rightEditor.size;
                             if);
                         if);
                      #);
                    showErrors:
                      (# x, y: @integer;
                         width, height: @integer;
                         errors: ^Stream;
                      enter errors[]
                      do '-----' -> putline;
                         errors.reset;
                         errors[] -> putline;
                         '-----' -> putline;
                         (if rightEditor[] <> NONE then
                             rightEditor.size -> (width, height);
                             rightEditor.position -> (x, y);
                             (width, height - 320) -> rightEditor.size;
                             &ErrorList[] -> errorView[];
                             errorView.open;
                             (x, y + (height - 320)) -> errorView.position;
                             (width, 320) -> errorView.size;
                             true -> errorView.bindRight;
                             true -> errorView.bindBottom;
                             errors[] -> errorView.display;
                             errors[] -> rightEditor.handleErrors;
                         if);
                      #);
                    itemPopUp: @menu
                      (# iAdd: @menuItem
                           (# open:: (#do 'Add' -> name; iAdd[] -> append #);
                              eventHandler::
                                (# onSelect::
                                     (# x: @newAttributeBox;
                                     do x.open;
                                        (if not x.isCanceled then 
                                            (if X.name.length = 0 then
                                                '*** Missing name!'-> putline
                                             else
                                                (if selection.first > 0 then
                                                    (selection.first, x.name[], x.kind) -> addItem;
                                                 else
                                                    (numberOfItems + 1,  x.name[], x.kind) -> addItem;
                                                if);
                                            if);
                                        if)
                                     #);
                                #);
                              addItem:
                                (# inx,kind: @integer; N,att: ^text; before: @boolean; 
                                   objCx: ^ObjCont.handle
                                enter(inx,N[],kind)
                                do (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                                   
                                   '*** AddItem: "' -> puttext; N[] -> puttext; ' ' ->put; kind -> put;
                                   ' "*** OBS! Missing check of syntax and double declaration' -> putline;

                                   ('selection',inx) -> L.TIn;
                                   (inx,N[],kind)  -> asDW.enclosingObjCont.addItem -> att[];
                                   
                                   (inx,att[]) -> configure;
                                   (inx,false) -> selection.select;
                                   closeRight;
                                   (if false then
                                       inx -> asDW.enclosingObjCont.elm -> objCx[];
                                       ('addItem:ObjX',objCx.theName[]) -> L.TTn;
                                   if);
                                   ('addItem:enclosingObjCont',asDW.enclosingObjCont.theName[]) 
                                     -> L.TTn;
                                   (inx, 0,0,true) -> display
                                #);
                           #);
                         iMove: @menuItem
                           (# eventHandler:: 
                                (# onSelect:: (* never called - has submenu *)
                                     (# 
                                     do 'Move' -> putline;
                                        (1,(0,0),this(BrowserItems)[]) -> UD.popUp
                                #)#);
                              open:: 
                                (# 
                                do 'Move' -> name; iMove[] -> append;
                                   UD.open; 
                                   UD[] -> subMenu
                                #);
                              UD: @menu
                                (# iUp: @menuItem
                                     (# eventHandler::
                                          (# onSelect:: 
                                               (# inx: @integer; T: ^text
                                               do 'Up' -> putline; 
                                                  (if 1 < (selection.first -> inx) then
                                                      inx -> gettext -> T[];
                                                      (inx, inx - 1 -> gettext) -> setText;
                                                      (inx - 1, T[]) -> setText;
                                                      (T[],inx) -> asDW.enclosingObjCont.moveUp;
                                                  if)
                                          #)#);
                                        open:: 
                                          (# 
                                          do 'Up' -> name; 
                                             iUp[] -> append; 
                                          #);
                                     #);
                                   iDown: @menuItem
                                     (# eventHandler::
                                          (# onSelect:: 
                                               (# inx: @integer; T: ^text
                                               do 'Down' -> putline; 
                                                  (if (selection.first ->inx) < numberOfItems then
                                                      inx -> gettext -> T[];
                                                      (inx, inx + 1 -> gettext) -> setText;
                                                      (inx + 1 , T[]) -> setText;
                                                      (T[],inx + 1) -> asDW.enclosingObjCont.moveUp;
                                                  if)
                                          #)#);
                                        open:: 
                                          (# 
                                          do 'Down' -> name; 
                                             iDown[] -> append; 
                                          #);
                                     #);
                                   open:: (# do iUp.open; iDown.open #)
                                #)
                           #);      
                         iCopy: @menuItem
                           (# eventHandler::
                                (# onselect::
                                     (# inx: @integer;
                                        T: ^text
                                     do (if (selection.first ->inx) <= numberOfItems then
                                            (if true then
                                                (# dcl: ^generator.Node;
                                                   obj: ^objCont.Handle;
                                                do inx -> asDW.enclosingObjCont.elm -> obj[];
                                                   (if obj.isModule then
                                                       (# source: @File;
                                                       do obj.getModulePath -> source.name;
                                                          source.openRead;
                                                          &Text[] -> T[];
                                                          loop:
                                                            (if not source.eos then
                                                                source.getLine -> T.putline;
                                                                restart loop;
                                                            if);
                                                          source.close;
                                                       #);
                                                    else
                                                       asDW.enclosingObjCont.DCLs[inx][] -> dcl[];
                                                       dcl.doPt -> T[];
                                                   if);
                                                #);
                                             else
                                                (selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm ).gettext -> T.append;
                                            if);
                                            T[] -> clipBoard.textContents;
                                        if)
                                     #)
                                #);
                              open::(#do 'Copy' -> name; iCopy[] -> append #)
                           #);
                         iPaste: @dynamicMenuItem
                           (# open:: (# do 'Paste'-> name; iPaste[] -> append #)
                           #);
                         
                         textPasteHandler: @menuAction
                           (# onSelect::
                                (# inx: @integer;
                                   att: ^Text;
                                do (if selection.first = 0 then
                                       numberOfItems + 1 -> inx;
                                    else
                                       selection.first -> inx;
                                   if);
                                   (inx, clipBoard.textContents)  
                                     -> asDW.enclosingObjCont.addDecl 
                                     -> att[];
                                   (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                                   (inx,att[]) -> configure;
                                   (inx,false) -> selection.select;
                                   closeRight;
                                   (inx, 0,0,true) -> display
                                #);
                           #);
                         iPasteAsModule: @dynamicMenuItem
                           (# open:: (# do 'Paste as Module'-> name; iPasteAsModule[] -> append #)
                           #);
                         textPasteModuleHandler: @menuAction
                           (# onSelect::
                                (# inx: @integer;
                                   att: ^Text;
                                do 'paste-module: ' -> puttext;
                                   clipBoard.textContents -> putline;
                                   (if selection.first = 0 then
                                       numberOfItems + 1 -> inx;
                                    else
                                       selection.first -> inx;
                                   if);
                                   (inx, clipBoard.textContents)  
                                     -> asDW.enclosingObjCont.addModule
                                     -> att[];
                                   (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                                   (inx,att[]) -> configure;
                                   (inx,false) -> selection.select;
                                   closeRight;
                                   (inx, 0,0,true) -> display
                                #);
                           #);
                         iDelete: @menuItem  
                           (# eventHandler::
                                (# onSelect:: 
                                     (# inx: @integer;
                                        ok: @boolean;
                                        message: ^Text;
                                        result: @integer;
                                     do 'iDelete: ' -> puttext;
                                        selection.first -> inx;
                                        false -> OK;
                                        'Delete item"' -> message[];
                                        asDW.enclosingObjCont.dclNames[inx][] -> message.puttext;
                                        '"?\n' -> message.puttext;
                                        
                                        (THIS(Window)[], '', message[]) -> promptUser -> result;
                                        (if result = UserYes then
                                            asDW.enclosingObjCont.dclNames[inx][] -> putline;
                                            (asDW.enclosingObjCont.dclNames[inx][],selection.first)
                                              -> asDW.enclosingObjCont.delete;
                                            (inx,1) -> this(TableView).delete;
                                            (if inx > this(TableView).numberOfItems then inx - 1 -> inx if);
                                            (inx,false) -> selection.select;
                                            (selection.first,0,0,true) -> display;
                                        if);
                                #)#); 
                              open:: 
                                (# do 'Delete' -> name; iDelete[] -> append; #);
                           #);
                         iSave: @dynamicMenuItem
                           (# open:: (# do 'Save'-> name; iSave[] -> append #);
                           #);
                         saveHandler:  @menuAction
                           (# onSelect:: (# do asDW.save #);
                           #);
                         
                         iFocus: @MenuItem
                           (#
                              open::
                                (#
                                do 'Focus On' -> name;
                                   iFocus[] -> append;
                                #);
                              eventHandler::
                                (#
                                   onSelect::
                                     (# index: @integer;
                                        content: ^objCont.Handle;
                                     do 
                                        (if selection.first = 0 then
                                            'focus on: ' -> puttext;
                                            asDW.enclosingObjCont.theName[] -> putline;
                                         else
                                            'focus on: ' -> puttext;
                                            (selection.first -> asDW.enclosingObjCont.elm).theName[] -> putline;
                                            selection.first -> index;
                                            index -> asDW.enclosingObjCont.elm -> content[];
                                            (index, content[]) -> navigateTo;
                                        if);
                                     #);
                                #);
                           #);
                         iDisguise: @MenuItem
                           (# open::
                                (#
                                do 'Disguise' -> name;
                                   iDisguise[] -> append;
                                #);
                              eventHandler::
                                (# onSelect::
                                     (# index: @integer;
                                     do (if (selection.first -> index) <= numberOfItems then
                                            (# dcl: ^generator.Node;
                                               obj: ^Object;
                                               item: ^generator.ModuleItem;
                                               desc: ^generator.ObjectDesc;
                                            do asDW.enclosingObjCont.DCLs[index][] -> dcl[];
                                               dcl.sort -> obj[];
                                               (if obj[] <> NONE then
                                                   (if obj## = compile.ModuleItem## then
                                                       obj[] -> item[];
                                                       item.desc -> desc[];
                                                       (if desc.props[] <> NONE then
                                                           (if desc.props.OSDvisibility <> 0 then
                                                               0 -> desc.props.OSDvisibility;
                                                            else
                                                               2 -> desc.props.OSDvisibility;
                                                           if);
                                                           reload;
                                                           (index, false) -> selection.select;
                                                       if);
                                                   if);
                                               if);
                                            #);
                                        if);
                                     #);
                                #);
                           #);
                         iExe: @dynamicMenuItem
                           (# open:: (# do 'Execute' -> name; iExe[] -> append #);
                           #);
                         exeHandler: @menuAction
                           (# doCompile:
                                (# objC: ^ObjectContent.handle; FN: ^text; 
                                   main: ^generator.module; errors: ^stream
                                enter objC[]
                                do '******* MiniENV: compile: ' -> puttext;
                                   objC.modulePath -> FN[];
                                   objC.theModule.name.lexemSy -> FN.append;
                                   '.bet' -> FN.append;
                                   objC.theModule.name.lexemSy -> putline;
                                   (L[],true,objC.theModule[],FN[]) -> compile -> (main[],errors[]);
                                exit(compile.Main[],errors[])
                                #);
                              onSelect:: 
                                (# objX: ^ObjCont.handle;
                                   comp: ^generator.Module;
                                   x, y: @integer;
                                   errors: ^stream;
                                   path: ^PathRecord;
                                do (if (asDW.save -> errors[]) <> none then
                                       (* Save checks for syntax errors only
                                        * Semantic errors are not captured by Save
                                        *)
                                       '\n\n***** Syntax errors in module' -> putline;
                                       errors[] -> showErrors;
                                    else
                                       getPath -> path[];
                                       ('Do execute',index) -> L.TI;
                                       (asDW.enclosingObjCont.theName[], selection.first) -> L.TI;
                                       selection.first 
                                         -> asDW.enclosingObjCont.elm 
                                         -> objX[] 
                                         -> doCompile 
                                         -> (comp[],errors[]);
                                       hideErrors;
                                       path.navigate;
                                       (if errors[] <> none then
                                           (* syntax errors have already been checked by Save
                                            * semantic errors are caught here
                                            *)
                                           '\n\n***** Errors in module' -> putline;
                                           errors[] -> putline;
                                           errors[] -> rightEditor.handleErrors;
                                           errors[] -> showErrors;
                                        else
                                           (if EMBEDDED then
                                               THIS(ComponentWindow)[] -> createExecution;
                                            else
                                               THIS(ComponentWindow)[] -> createStandaloneExecution;
                                           if);
                                           objX[] -> execution.execute;
                                           
                                           (# item: ^generator.Item;
                                              desc: ^generator.ObjectDesc;
                                              begin: @integer;
                                           do objX.theEntry[] -> item[];
                                              item.desc -> desc[];
                                              (if desc[] <> NONE then
                                                  (if desc.acp.imps[] <> NONE then
                                                      desc.acp.imps.beginPos -> begin;
                                                      rightEditor.contents[] -> target;
                                                      (begin, begin) -> rightEditor.setSelection;
                                                  if);
                                              if);
                                           #);
                                       if);
                                   if)
                                #)
                           #);
                         open::
                           (#
                           do iAdd.open;
                              iCopy.open;
                              iPaste.open;
                              iPasteAsModule.open;
                              iMove.open;
                              iDelete.open;
                              iFocus.open;
                              iDisguise.open;
                              iExe.open;
                              iSave.open;
                           #);
                      #);
                    saveEditBuffers: 
                      (* Check the use of this one
                       * When called from display:currentSelection.save, 
                       * only the current buffer needs to be saved;
                       * there are no rightmost buffers that need to be saved
                       * Check othher calls - perhaps only the call above is needed 
                       * since we then always save the edit buffer
                       * Also update comments in textEditor about wasChanged,
                       * we never reselect a buffer with changed elements
                       *)
                      (# errors: ^text
                      do ('SaveEditBuffers',asDW.print) -> L.TTn;
                         (if rightEditor[] <> none then 
                             (if rightEditor.wasChanged then
                                 true -> rightEditor.asDW.enclosingObjCont.wasChanged;
                                 ('SaveEditBuffer',rightEditor.contents.contents) -> L.TTn;
                                 rightEditor.contents.contents 
                                   -> rightEditor.asDW.enclosingObjCont.saveBuffer
                                   -> rightEditor.handleErrors
                                   -> errors[]
                             if);
                             (if not rightEditor.asDW.enclosingObjCont.wasChanged then
                                 (* may be true from a previous selection *)
                                 ('SaveEditBuffer:not changed',rightEditor.contents.contents) ->  L.TTn
                             if)
                          else 
                             (if asDW.right[] <> none then 
                                 right.saveEditBuffers (* never bound ...?*)
                         if)if)
                      exit errors[]
                      #);
                    closeErrors:
                      (#
                      do 
                      #);
                    closeRight: 
                      (* close all Item-panes to the right and rightEditor *)
                      (# 
                      do ('CloseRight',asDW.print) -> L.TTn;
                         (if asDW.right[] <> none then 
                             right.closeRight;
                             right.close ;
                             none -> right[]; 
                             none -> asDW.right[]
                         if);
                         (if rightEditor[] <> none then
                             rightEditor.close
                         if);
                         (if errorView[] <> NONE then
                             errorView.close;
                             NONE -> errorView[];
                         if);
                         none -> rightEditor[]
                      #);
                    pinx: @integer; 
                    
                    configure:
                      (# index: @integer;
                         str: ^Text;
                         visibility: @integer;
                      enter (index, str[])
                      do (# dcl: ^generator.Node;
                            obj: ^Object;
                            item: ^generator.ModuleItem;
                            desc: ^generator.ObjectDesc;
                            
                         do asDW.enclosingObjCont.DCLs[index][] -> dcl[];
                            dcl.sort -> obj[];
                            (if obj[] <> NONE then
                                (if obj## = compile.ModuleItem## then
                                    obj[] -> item[];
                                    item.desc -> desc[];
                                    (if desc.props[] <> NONE then
                                        desc.props.OSDvisibility -> visibility;
                                    if);
                                if);
                            if);
                         #);
                         
                         (# colon: @integer;
                            name: ^Text;
                            kind: @char;
                         do str.reset;
                            search: ':' -> str.find 
                            (#
                            do inx -> colon;
                               leave search;
                            #);
                            (1, colon - 1) -> str.sub -> name[];
                            (index, name[]) -> setText;
                            
                            str.length -> str.inxGet -> kind;
                            (if 'Action*' -> str.equal then
                                (index, cogwheel[]) -> setImage;
                             else
                                (if kind
                                 //'/'
                                 //'#' then
                                    (if visibility
                                     //0 then
                                        (index, publicpackageIcon[]) -> setImage;
                                     //1 then
                                        (index, packageIcon[]) -> setImage;
                                     //2 then
                                        (index, privatepackageIcon[]) -> setImage;
                                    if);
                                 //' ' then
                                    (index, patternIcon[]) -> setImage;
                                 //':'//'<' then
                                    (index, virtualIcon[]) -> setImage;
                                 //'^' then
                                    (index, lightrefIcon[]) -> setImage;
                                 //'@' then
                                    (index, referenceIcon[]) -> setImage;
                                 //'=' then
                                    (index, simpleIcon[]) -> setImage;
                                 //']' then
                                    (index, arrayIcon[]) -> setImage;
                                 else
                                    name[] -> puttext;
                                    ' kind: ' -> puttext;
                                    kind -> put;
                                    newline;
                                    ' name: "' -> puttext;
                                    str[] -> puttext;
                                    '"' -> putline;
                                if);
                            if);
                         #);
                      #);
                    reload:
                      (# width: @integer;
                         height: @integer;
                         
                      do clear;
                         asDW.enclosingObjCont.length -> append;
                         size -> (width, height);
                         asDW.enclosingObjCont.scan
                         (# w: @integer;
                         do current[] -> fixed.widthOfText -> w;
                            w + 16 + 16 -> w;
                            (inx,current[]) -> configure;
                            (if w > width then
                                w -> width;
                            if);
                         #);
                         (width, height) -> size;
                      #);
                    setUpBrowser:
                      (# p: @point; 
                      enter(pred[],pinx,asDW.enclosingObjCont[])
                      do pred[] -> asDW.left[];
                         pinx + 1 -> index;
                         browser[] -> open;
                         reload;
                         true -> bindBottom;
                         (if execution[] = NONE then
                             true -> THIS(ComponentWindow).sizeToFit;
                          else
                             flexible -> THIS(ComponentWindow).sizeToFit;
                         if);
                      #);
                    selectPath:
                      (# path: ^IntStack;
                      enter path[]
                      do (# inx: @integer;
                         do path.pop -> inx;
                            (inx, false) -> selection.select;
                            (selection.first, 0, 0, path.empty) -> display;
                            scrollIntoView;
                            (if not path.empty then
                                path[] -> right.selectPath;
                            if);
                         #);
                      #);
                    select:
                      (# path: ^intList; inx,beginPos,endPos: @integer;
                         result: ^TextEdit;
                      enter(path[],inx,beginPos,endPos)
                      do (if false then
                             'Select: ' -> puttext; inx -> putint; '['->put; 
                             path.scan(# do current -> putint; ' ' -> put #);
                             ']' -> put; ' ' -> put;
                         if);
                         (if (inx -> path.inRange) then
                             (if false then
                                 inx -> path.get -> gettext -> puttext;
                                 ' ' -> put; inx -> path.get -> putint; ' ' -> put;
                             if);
                             (inx -> path.get,false) -> selection.select;
                             (inx -> path.get,beginPos,endPos,false) -> display;
                             (if (asDW.right[] <> none) and (inx + 1 -> path.inRange) then
                                 (inx -> path.get,beginPos,endPos,false) -> display;
                                 (path[],inx + 1,beginPos,endPos) -> right.select -> result[];
                              else
                                 (inx -> path.get,beginPos,endPos,true) -> display -> result[];
                             if)
                         if);
                      exit result[]
                      #);
                    pred: ^displayWindow;
                    right: ^Browseritems;
                    index: @integer;
                 #);
               rightEditor: ^textEdit;
               errorView: ^ErrorList;
               TextEdit: TextEditor
                 (# aTextStyle: ^textStyle;
                    open::
                      (# compW,compH,width,height: @integer;
                         
                      do this(componentWindow).size -> (compW,compH);
                         this(componentWindow).height - 20 - defaults.browserH - theBorderwidth*2 -> height;
                         this(componentWindow).width - theBorderwidth*2 -> width; 
                         (theBorderwidth, defaults.browserH + 20 + theBorderwidth) -> position;
                         (width, height) -> size;
                         &textStyle[] -> aTextStyle[]; 
                         'Courier' -> aTextStyle.name;
                         8 -> aTextStyle.size;
                         textFaces.plain -> aTextStyle.face;
                         aTextStyle[] -> contents.defaultstyle;
                         (if false then
                             'Linewidth: pixels: ' -> puttext; width -> putint;
                             ' maxChWidth: ' -> puttext; aTextStyle.maxChWidth -> putint; 
                             ' chars: ' -> puttext; width div aTextStyle.maxChWidth - 3 -> putint; newline;
                         if);
                         adjustLineWidth;
                         true -> bindBottom;
                         true -> bindRight;
                         editMenu.open
                      #);
                    select:
                      (# beginPos,endPos: @integer; 
                      enter (beginPos, endPos)
                      do (beginPos, endPos) -> contents.selection.set; 
                         contents[] -> THIS(Window).target; (* needed to high-light selection *)
                         contents.selection.scrollIntoView;
                      #);
                    adjustLineWidth:
                      (# width, height: @integer;
                      do size -> (width, height);
                         width - 15 -> width;
                         width div aTextStyle.maxChWidth - 3 -> compile.lineWidth;
                         (if compile.lineWidth > 70 then
                             70 -> compile.lineWidth;
                         if);
                      #);
                    asDW: @ displayWindow
                      (# size:: (# do this(textEdit).size -> (width,height) #);
                         position:: (# do this(textEdit).position -> pos #);
                         hasEditChanges:: (# do wasChanged -> value #);
                      #);

                    init:< 
                      (# Tx: ^text; t: @styledText
                      enter Tx[]
                      do 
                         Tx -> T;
                         false -> realChange;
                         T[] -> contents.contents;
                         true -> realChange;
                      #);                
                    setUpEditor:
                      (# left: ^displayWindow; (*items;*)
                         width,height,beginPos,endPos: @integer; 
                         P: @point;
                      enter(left[],asDW.enclosingObjCont[],beginPos,endPos)
                      do left[] -> asDW.left[];
                         asDW.left.position -> P; 
                         asDW.left.size -> (width,height);
                         open;
                         asDW.enclosingObjCont.getText -> init;
                         (* 'setUpEditor: ' -> puttext;
                          * beginPos -> putint; ' ' -> put; endPos -> putint; newline;*)
                         
                         (if (beginPos <> 0) and (endPos <> 0) then
                             (beginPos, endPos) -> select;
                         if);
                         
                         grow.bringToFront;
                      #);
                    
                    getText:
                      (# buffer: ^Text;
                      do &Text[] -> buffer[];
                         contents.all -> contents.scanText
                         (#
                         do ch -> buffer.put;
                         #);
                      exit buffer[]
                      #);
                    setSelection:
                      (# begin, end: @integer;
                      enter (begin, end)
                      do (begin, end) -> contents.selection.set;
                         contents.selection.scrollIntoView;
                      #);
                    indent:
                      (# mark: @integer;
                         
                         buffer: ^Text;
                         
                         SIMPLE_BLOCK: (# exit 0 #);
                         STD_BLOCK: (# exit 1 #);
                         IF_BLOCK: (# exit 2 #);
                         FOR_BLOCK: (# exit 3 #);
                         
                         Array:
                           (# storage: [0] ^Text;
                              init:
                                (# size: @integer;
                                enter size
                                do size -> storage.new;
                                #);
                              length:
                                (# value: @integer;
                                do storage.range -> value;
                                exit value
                                #);
                              at:
                                (# inx: @integer;
                                   value: ^Text;
                                enter inx
                                do storage[inx][] -> value[];
                                exit value[]
                                #);
                              atPut:
                                (# inx: @integer;
                                   value: ^Text;
                                enter (inx, value[])
                                do value[] -> storage[inx][];
                                #);
                           #);
                         
                         starts: @Array;
                         ends: @Array;
                         actionkeys: @Array;
                         ifKeys: @Array;
                         
                         prepare:
                           (# 
                           do 3 -> starts.init;
                              3 -> ends.init;
                              (STD_BLOCK, '(#') -> starts.atPut; 
                                              (STD_BLOCK, '#)') -> ends.atPut;
                              (IF_BLOCK, '(if') -> starts.atPut;
                                              (IF_BLOCK, 'if)') -> ends.atPut;
                              (FOR_BLOCK, '(for') -> starts.atPut;
                                                (FOR_BLOCK, 'for)') -> ends.atPut;
                              
                              7 -> actionkeys.init;
                              (1, 'enter') -> actionkeys.atPut;
                              (2, 'do') -> actionkeys.atPut;
                              (3, 'exit') -> actionkeys.atPut;
                              (4, '(#') -> actionkeys.atPut;
                                      (5, '#)') -> actionkeys.atPut;
                              (6, '(*') -> actionkeys.atPut;
                                    (7, '*)') -> actionkeys.atPut;
                              
                              3 -> ifKeys.init;
                              (1, '//') -> ifKeys.atPut;
                              (2, 'else') -> ifKeys.atPut;
                              (3, 'then') -> ifKeys.atPut;
                              
                              contents.selection.start -> mark;
                              getText -> buffer[];
                           #);
                         balanceBlock:
                           (# end: @integer;
                              begin: @integer;
                           enter end
                           do (# cnt: @integer;
                                 ch: @char;
                                 lines: @integer;
                              do end -> begin;
                                 0 -> cnt;
                                 loop:
                                   (if cnt >= 0 then
                                       begin -> buffer.inxGet -> ch;
                                       (if ch = ')' then
                                           cnt + 1 -> cnt;
                                       if);
                                       (if ch = '(' then
                                           cnt - 1 -> cnt;
                                       if);
                                       begin - 1 -> begin;
                                       (if begin > 0 then
                                           restart loop;
                                       if);
                                   if);
                              #);
                           exit begin
                           #);
                         getCurrentBlock:
                           (# cnt: @integer;
                              ch: @char;
                              lines: @integer;
                              begin: @integer;
                              end: @integer;
                           do (if mark > 0 then
                                  mark -> beginningOfLine -> endOfConstruct -> end;
                                  end -> begin;
                                  0 -> cnt;
                                  loop:
                                    (if cnt >= 0 then
                                        begin -> buffer.inxGet -> ch;
                                        (if ch = ')' then
                                            cnt + 1 -> cnt;
                                        if);
                                        (if ch = '(' then
                                            cnt - 1 -> cnt;
                                        if);
                                        (if ch = 10 then
                                            lines + 1 -> lines;
                                        if);
                                        begin - 1 -> begin;
                                        (if begin > 0 then
                                            restart loop;
                                        if);
                                     else
                                        (if lines = 0 then
                                            0 -> cnt;
                                            restart loop;
                                        if);
                                    if);
                                  mark -> endOfLine -> end;
                              if);
                           exit (begin, end)
                           #);
                         matchWord:
                           (# begin: @integer;
                              word: ^Text;
                              result: @boolean;
                           enter (begin, word[])
                           do true -> result;
                              check:
                                (for inx: word.length repeat
                                     (# ch1, ch2: @char;
                                     do begin + inx -> buffer.inxGet -> ch1;
                                        inx -> word.inxGet -> ch2;
                                        (if ch1 <> ch2 then
                                            false -> result;
                                            leave check;
                                        if);
                                     #);
                                for);
                           exit result
                           #);
                         matchWords:
                           (# begin: @integer;
                              words: ^Array;
                              result: @integer;
                           enter (begin, words[])
                           do search:
                                (for inx: words.length repeat
                                     (if (begin, inx -> words.at) -> matchWord then
                                         inx -> result;
                                         leave search;
                                     if);
                                for);
                           exit result
                           #);
                         getColumn:
                           (# begin: @integer;
                              result: @integer;
                              ch: @integer;
                           enter begin
                           do (if begin > 0 then
                                  begin -> buffer.inxGet -> ch;
                                  loop:
                                    (if ch <> 10 then
                                        begin - 1 -> begin;
                                        result + 1 -> result;
                                        (if begin > 0 then
                                            begin -> buffer.inxGet -> ch;
                                            restart loop;
                                        if);
                                    if);
                              if);
                           exit result
                           #);
                         
                         beginningOfLine:
                           (# current: @integer;
                              begin: @integer;
                           enter current
                           do (# ch: @char;
                              do current -> begin;
                                 (if begin > 0 then
                                     begin -> buffer.inxGet -> ch;
                                     loop:
                                       (if ch <> 10 then
                                           begin - 1 -> begin;
                                           (if begin > 0 then
                                               begin -> buffer.inxGet -> ch;
                                               restart loop;
                                           if);
                                       if);
                                     
                                 if);
                              #);
                           exit begin
                           #);
                         endOfConstruct:
                           (# begin: @integer;
                              end: @integer;
                           enter begin
                           do (# ch: @char;
                                 candidate: @boolean;
                                 marker: @integer;
                              do begin + 1 -> end;
                                 (if end <= buffer.length then
                                     end -> buffer.inxGet -> ch;
                                     loop:
                                       (if ch <> 10 then
                                           (if ch = ')' then
                                               true -> candidate;
                                               end -> marker;
                                           if);
                                           end + 1 -> end;
                                           (if end <= buffer.length then
                                               end -> buffer.inxGet -> ch;
                                               restart loop;
                                           if);
                                       if);
                                     (if candidate then
                                         marker -> end;
                                     if);
                                 if);
                                 end - 1 -> end;
                              #);
                           exit end
                           #);
                         endOfLine:
                           (# current: @integer;
                              end: @integer;
                           enter current
                           do (# ch: @char;
                              do current + 1 -> end;
                                 (if end <= buffer.length then
                                     end -> buffer.inxGet -> ch;
                                     loop:
                                       (if ch <> 10 then
                                           end + 1 -> end;
                                           (if end <= buffer.length then
                                               end -> buffer.inxGet -> ch;
                                               restart loop;
                                           if);
                                       if);
                                     
                                 if);
                                 end - 1 -> end;
                              #);
                           exit end
                           #);
                         startOfText:
                           (# begin: @integer;
                              end: @integer;
                              ch: @char;
                           enter begin
                           do begin + 1 -> end;
                              (if end <= buffer.length then
                                  end -> buffer.inxGet -> ch;
                                  loop:
                                    (if ch = 32 then
                                        end + 1 -> end;
                                        (if end <= buffer.length then
                                            end -> buffer.inxGet -> ch;
                                            restart loop;
                                        if);
                                    if);
                              if);
                              end - 1 -> end;
                           exit end
                           #);
                         indentLine:
                           (# begin: @integer;
                              end: @integer;
                              ilevel: @integer;
                           enter (begin, end, ilevel)
                           do (# clevel: @integer;
                                 delta: @integer;
                                 txt: ^Text;
                                 a, b: @integer;
                              do end - begin -> clevel;
                                 ilevel - clevel -> delta;
                                 contents.selection.get -> (a, b);
                                 (if begin <= a then
                                     a + delta -> a;
                                     b + delta -> b;
                                 if);
                                 
                                 (if delta > 0 then
                                     (begin, begin) -> contents.selection.set;
                                     &Text[] -> txt[];
                                     (for delta repeat
                                          ' ' -> txt.put;
                                     for);
                                     txt[] -> contents.insert;
                                  else
                                     (begin, begin - delta) -> contents.selection.set;
                                     contents.delete;
                                 if);
                                 (a, b) -> contents.selection.set;
                              #);
                           #);
                         processBlock:
                           (# begin, end: @integer;
                           enter (begin, end)
                           do (# result: @integer;
                                 line0: @integer;
                                 line1: @integer;
                                 ilevel: @integer;
                                 block: @boolean;
                              do end -> beginningOfLine -> line0;
                                 line0 -> startOfText -> line1;
                                 begin -> getColumn -> ilevel;
                                 (begin, starts[]) -> matchWords -> result;
                                 (if result
                                  //SIMPLE_BLOCK then
                                     ilevel + 1 -> ilevel;
                                  //STD_BLOCK then
                                     (# k: @integer;
                                     do (line1, actionkeys[]) -> matchWords -> k;
                                        (if k > 0 then
                                            (if k = 4 then
                                                ilevel + 3 -> iLevel;
                                             else
                                                (if k = 6 then
                                                    ilevel + 3 -> iLevel;
                                                 else
                                                    true -> block;
                                                if);
                                            if);
                                         else
                                            ilevel + 3 -> ilevel;
                                        if);
                                     #);
                                  //IF_BLOCK then
                                     (# k: @integer
                                     do (line1, ends[]) -> matchWords -> k;
                                        (if k = 0 then
                                            (if ((line1, ifKeys[]) -> matchWords) <> 0 then
                                                ilevel + 1 -> ilevel;
                                             else
                                                ilevel + 4 -> ilevel;
                                            if);
                                        if);
                                     #);
                                  //FOR_BLOCK then
                                     ilevel + 5 -> ilevel;
                                 if);
                                 (if not block then
                                     (if (line1, '->') -> matchWord then
                                         iLevel + 2 -> iLevel;
                                      else
                                         (# previous: @integer;
                                         do (line1, blanks[]) -> skipBackwards -> previous;
                                            (if (previous -> buffer.inxGet) = ')' then
                                                previous - 1 -> previous;
                                                previous -> balanceBlock -> previous;
                                            if);
                                            (previous, blanks[]) -> skipBackwards -> previous;
                                            (previous, identifier[]) -> skipBackwards -> previous;
                                            (previous, blanks[]) -> skipBackwards -> previous;
                                            (previous, specifier[]) -> skipBackwards -> previous;
                                            (previous, blanks[]) -> skipBackwards -> previous;
                                            (if (previous -> buffer.inxGet) = '<' then
                                                previous - 1 -> previous;
                                            if);
                                            (if (previous -> buffer.inxGet) = ':' then
                                                ilevel + 2 -> ilevel;
                                            if);
                                         #);
                                     if);
                                 if);
                                 (line0, line1, ilevel) -> indentLine;
                              #);
                           #);
                         getCurrenLine:
                           (# begin, end: @integer;
                           do mark -> beginningOfLine -> begin;
                              mark -> endOfLine -> end;
                           exit (begin, end)
                           #);
                         getCurrentConstruct:
                           (# begin, end: @integer
                           do mark -> beginningOfLine -> begin;
                              begin -> endOfConstruct -> end;
                           exit (begin, end)
                           #);
                         CharacterClass:
                           (# match:<
                                (# ch: @char;
                                   result: @boolean;
                                enter ch
                                do INNER;
                                exit result
                                #);
                           #);
                         blanks: @CharacterClass
                           (# match::
                                (#
                                do (ch = ' ') or (ch = 10) -> result;
                                #);
                           #);
                         identifier: @CharacterClass
                           (# match::
                                (#
                                do (if ch -> ascii.isLetter then
                                       true -> result;
                                    else
                                       (if ch -> ascii.isDigit then
                                           true -> result;
                                        else
                                           (if ch = '_' then
                                               true -> result;
                                           if);
                                       if);
                                   if);
                                #);
                           #);
                         specifier: @CharacterClass
                           (# match::
                                (#
                                do (ch = '@') or (ch = '^') -> result;
                                #);
                           #);
                         skipBackwards:
                           (# begin: @integer;
                              end: @integer;
                              chars: ^CharacterClass;
                              ch: @integer;
                           enter (begin, chars[])
                           do begin -> end;
                              end -> buffer.inxGet -> ch;
                              loop:
                                (if ch -> chars.match then
                                    end - 1 -> end;
                                    (if end > 0 then
                                        end -> buffer.inxGet -> ch;
                                        restart loop;
                                    if);
                                if);
                           exit end
                           #);
                      do prepare;
                         getCurrentBlock -> processBlock;
                      #);
                    
                    realChange,wasChanged: @ Boolean; 
                    contentsType:: textField
                      (# eventHandler::<
                           (# 
                              compileAndIndent:
                                (# errors: ^text;
                                   i, j: @integer;
                                   startAdjusted, endAdjusted: @integer;
                                do asDW.left.hideErrors;
                                   (if (currentSelection.save -> errors[]) <> none then
                                       'OnTab: syntax errors'->putline;
                                       errors[] -> putline;
                                       (if true then
                                           errors[] -> asDW.left.showErrors
                                        else
                                           errors[] -> handleErrors
                                       if)
                                    else
                                       selection.get -> (i, j);
                                       loop: all -> scanText
                                       (# inx: @integer;
                                          count: @integer;
                                       do inx + 1 -> inx;
                                          (if ch > 32 then
                                              count + 1 -> count;
                                          if);
                                          (if inx = i then
                                              count - 1 -> startAdjusted;
                                          if);
                                          (if inx = j then
                                              count - 1 -> endAdjusted;
                                          if);
                                       #);
                                       asDW.enclosingObjCont.getText -> init;
                                       loop: all -> scanText
                                       (# inx: @integer;
                                          count: @integer;
                                       do inx + 1 -> inx;
                                          (if ch > 32 then
                                              count + 1 -> count;
                                          if);
                                          (if count = startAdjusted then
                                              inx + 1 -> i;
                                          if);
                                          (if count = endAdjusted then
                                              inx + 1 -> j;
                                          if);
                                       #);
                                       (i, j) -> selection.set;
                                       selection.scrollIntoView;
                                   if);
                                   false -> wasChanged;
                                #);
                              
                              onTab::
                                (#
                                do indent;
                                #);
                              indentation: @boolean;
                              onKeyDown::
                                (#
                                do (if ch = 13 then
                                       true -> indentation;
                                   if);
                                #);
                              onTextChanged:: 
                                (# 
                                do (if indentation then
                                       false -> indentation;
                                       indent;
                                   if);
                                   (if realChange then true -> wasChanged if)
                                #);
                              onMouseDown:: 
                                (# p: @point;
                                do (if buttonState = 3 then
                                       localPosition -> p;
                                       (1,p,THIS(InterfaceObject)[]) -> editMenu.popUp
                                   if)
                                #)
                           #);
                      #);
                    editMenu: @menu
                      (# iCompile: @menuItem
                           (# eventHandler::
                                (# onSelect::
                                     (#
                                     do 'Compile and doPT ' -> putline;
                                        currentSelection.save;
                                        asDW.enclosingObjCont.getText -> init
                                     #)
                                #);
                              open::
                                (# 
                                do 'Compile' -> name;
                                   iCompile[] -> append;
                                #);
                           #);
                         iSetBreak: @menuItem
                           (# eventHandler::
                                (# onSelect:: 
                                     (# 
                                     do (* 'SetBreak' -> putline ;*)
                                        contents.selection.start 
                                          -> asDW.enclosingObjCont.setBreak
                                          -> breaks.add
                                     #)
                                #);
                              open::
                                (# 
                                do 'Set break' -> name; 
                                   iSetBreak[] -> append;
                                #)
                           #);
                         iFollow: @MenuItem
                           (# 
                              eventHandler::
                                (#
                                   followLink:
                                     (# apl: ^generator.NameApl;
                                        dcl: ^generator.NameDecl;
                                        
                                        
                                        
                                        
                                     enter apl[]
                                     do apl.dcl[] -> dcl[];
                                        (if dcl[] <> NONE then
                                            (# begin: @integer;
                                               end: @integer;
                                               from, to: ^generator.Module;
                                               decl: ^generator.Decl;
                                               item: ^generator.ModuleItem;
                                               record: ^PathRecord;
                                            do apl.theModule -> from[];
                                               dcl.theModule -> to[]; 
                                               dcl.father.father[] -> decl[];
                                               (if decl.sort <> NONE then
                                                   (if decl.IT## <= compile.ModuleItem## then
                                                       decl.IT[] -> item[];
                                                       item.md[] -> to[];
                                                       NONE -> dcl[];
                                                   if);
                                               if);
                                               
                                               getPath -> record[];
                                               record.path.print;
                                               
                                               back[] -> record.back[];
                                               record[] -> back[];
                                               
                                               (if from[] = to[] then
                                                   dcl.beginPos -> begin;
                                                   dcl.endPos -> end;
                                                   (begin, end) -> setSelection;
                                                else
                                                   
                                                   to[] -> mainBrowser.selectModule;
                                                   (if dcl[] <> NONE then
                                                       dcl.beginPos -> begin;
                                                       dcl.endPos -> end;
                                                       mainBrowser.rightEditor.contents[] -> target;
                                                       (begin, end) -> mainBrowser.rightEditor.setSelection;
                                                   if);
                                               if);
                                            #);
                                        if);
                                     #);
                                   onSelect::
                                     (# node: ^generator.Node;
                                     do contents.selection.start
                                          -> asDW.enclosingObjCont.findNode
                                          -> node[];
                                        (if node[] <> NONE then
                                            'follow: ' -> puttext;
                                            node[] -> getPatternName -> putline;
                                            
                                            (if node## <= compile.lexem## then
                                                (if node.father## <= compile.NameApl## then
                                                    node.father[] -> followLink;
                                                if);
                                            if);
                                        if);
                                     #);
                                #);
                              open::
                                (#
                                do 'Follow Link' -> name;
                                   iFollow[] -> append;
                                #);
                           #);
                         open:: 
		           (# 
                           do iCompile.open; 
                              iSetBreak.open; 
                              iFollow.open;
                           #);
                      #);                              
                    
                    handleErrors:
                      (# S: ^stream; start,end: @integer
                      enter S[]
                      do (if S[] <> none then 
                             S[] -> putline;
                             S.reset;    
                             S.getint - 1 -> start; S.getint -> end;
                             (start,end) -> contents.selection.set;
                             contents[] -> THIS(Window).target; (* needed to high-light selection *)
                         if)
                      exit S[]
                      #);
                 #);
               ErrorList0: TableView
                 (# display:
                      (# errors: ^Stream;
                      enter errors[]
                      do 1 -> append;
                         (1, 'Hello, World') -> setText;
                      #);
                 #);
               errorIcon: ^RichPixmap;
               patternIcon: ^RichPixmap;
               virtualIcon: ^RichPixmap;
               packageIcon: ^RichPixmap;
               publicpackageIcon: ^RichPixmap;
               privatepackageIcon: ^RichPixmap;
               simpleIcon: ^RichPixmap;
               arrayIcon: ^RichPixmap;
               referenceIcon: ^RichPixmap;
               lightrefIcon: ^RichPixmap;
               cogwheel: ^RichPixmap;
               
               ErrorList: TableView
                 (# items: @Sequence
                      (# Element:: ErrorItem;
                      #);
                    
                    open::
                      (#
                      do items.init;
                      #);
                    
                    ErrorItem:
                      (# start: @integer;
                         end: @integer;
                         what: ^Text;
                         
                         description:
                           (# value: ^Text;
                           do what.copy -> value[];
                              ' (' -> value.puttext;
                              start -> value.putint;
                              ' to ' -> value.puttext;
                              end -> value.putint;
                              ')' -> value.puttext;
                           exit value[]
                           #);
                         range:
                           (#
                           exit (start, end)
                           #);
                      #);
                    display:
                      (# errors: ^Stream;
                         start, end: @integer;
                         what: ^Text;
                         counter: @integer;
                         item: ^ErrorItem;
                      enter errors[]
                      do (if errors[] <> NONE then
                             errors.reset;
                             loop:
                               (if NOT errors.eos then
                                   counter + 1 -> counter;
                                   errors.getint - 1 -> start; errors.getint -> end;
                                   errors.getline -> what[];
                                   &ErrorItem[] -> item[];
                                   start -> item.start;
                                   end -> item.end;
                                   what[] -> item.what[];
                                   1 -> append;
                                   (counter, item.description) -> setText;
                                   (counter, errorIcon[]) -> setImage;
                                   item[] -> items.append;
                                   restart loop;
                               if);
                         if);
                      #);
                    
                    displayError:
                      (# item: @integer;
                      enter item
                      do (# selected: ^ErrorItem;
                         do item -> items.get -> selected[];
                            selected.range -> rightEditor.contents.selection.set;
                            rightEditor.contents[] -> target;
                         #);
                      #);
                    
                    onMouseDown::
                      (#
                      do selection.first -> displayError;
                      #);
                 #);
               thisIndex: @integer
            #);
          
          placeholder: @SpaceLayout;
       #);
     ObjCont: @ObjectContent;
     theWorldWindow: @WorldWindow;
     compile: @generator;
     FN: ^text;
     VM: ^ | WorldVM;
     
     WorldVM: theSystemEnv.BetaVM
       (# selectCode:
            (# caller: ^ObjDesc.Template; 
               trace: (# exit false #);
            enter caller[]
            do (# desc: ^generator.ObjectDesc;
                  descNo, lsc,beginPos,endPos: @integer;
               do (if trace then
                      'Select code:' -> puttext;  caller.myName -> puttext;
                      ','->put; caller.myDescInx -> putint; 
                      ' lsc: '->puttext; 
                      (if caller.lscTop > 0 then caller.myLsc -> putint else '?'->put; if)
                  if);
                  
                  (if caller.lscTop > 0 then (* preliminary hack *)
                      (if caller.myDescInx = compile.mainDescNo then (* do we need this *)
                          caller.myDescInx -> descNo;
                          caller.myLsc -> lsc
                       else 
                          caller.topReturn -> (descNo,lsc)
                      if);
                      (if trace then
                          ' return: ' -> puttext; descNo -> putint; ' ' -> put; lsc -> putint; 
                      if);
                      descNo -> compile.newDesc.getOD -> desc[];
                      true -> desc.doPT; (* OBS! true is needed to update charPos in desc *)
                      lsc 
                        -> desc.acp.mapBCposToCharRange 
                        -> (beginPos,endPos);
                      (if caller.myDescInx = compile.mainDescNo then 
                          caller.myDescInx -> descNo 
                       else 
                          (desc[],beginPos,endPos)
                            -> desc.father.adjustForSingularImp
                            -> (desc[],beginPos,endPos);
                          desc.descNo -> descNo
                      if);
                      (if trace then
                          ' Pos: ' -> puttext; beginpos -> putint; '-'->put; endPos -> putint; newline;
                      if);
                      (if trace then
                          ' new:descNo: ' -> puttext; descNo -> putint;
                          ' pos: ' -> puttext;
                          beginPos -> putint; ','->put; endPos -> putint;  
                          newline
                      if);
                      (caller[], descNo,&intList[], desc[], lsc) -> THIS(World).selectDesc;
                  if);
               #);
            #);
          putCh:: (# do ch -> execution.put #);
          getCh:: (# do execution.get -> ch #);
          startEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onStart then
                   doPause;
               if);
            #);
          allocEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, isObj, isIndexed) -> execution.onAlloc then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, preemptive) -> execution.onDo then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doExitEvent::
            (#
            do 
            #);
          rtnEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onReturn then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          
          breakEvent::
            (# path: ^intList;
               beginPos,endPos: @integer
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onBreak then
                   bcPos -> breaks.astPos -> (beginPos,endPos);
                   &intList[] -> path[];
                   (thisObj[],thisObj.myDescInx,path[],beginPos,endPos) -> THIS(World).selectCode;
                   doPause;
               if);
            #);
          display:
            (# event: ^text;
               push,popRstack: @boolean;
               from,to: ^ObjDesc.template; off: @integer; attNM: ^text; 
               isIndexed: @boolean; inx: @integer;
               offIsZero:< (# do inner #);
               field:
                 (# 
                 do ' field: "' -> puttext; attNM[] -> puttext; 
                    (if isIndexed then
                        '[' -> put; inx -> putint; ']' -> put
                    if);
                    '"' -> put;
                    ' off: ' -> puttext; off -> putint;
                 #);
               
            enter(event[],push,from[],popRstack,to[],off,attNM[],isIndexed,inx)
            do event[] -> puttext; 
               (if push then
                   'From: "' -> puttext; from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   (if off = 0 then
                       offIsZero
                    else
                       field
                   if);
                   inner;                       
                   ' push on: "' -> puttext; to.myName -> puttext; '"' -> put;
                else
                   'Pop from: "' -> puttext;  from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   inner;
                   ' store at: "' -> puttext; to.myName -> puttext; '"' -> put;
                   (if off = 0 then
                       offIsZero
                    else
                       field
               if)if);
               newline
            #);
          vDisplay: display
            (# offIsZero::(# do ' const:' -> puttext #);
               value: @integer;               
            enter value
            do ' value: ' -> puttext; value -> putint; 
            #);
          rDisplay: display
            (# offisZero:: (# do ' this:' -> puttext #);
               refValue: ^ObjDesc.template
            enter refValue[]
            do ' ref: ' -> puttext; refValue.myName -> puttext
            #);
          getAttName:
            (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
               OD: ^generator.ObjectDesc
            enter(off,obj[],isRef,isIndexed)
            do 'xxx'-> nm[];
               obj.myDescInx -> compile.newDesc.getOD -> OD[];
               find:
                 OD.scanAllDecls
                 (# origin:: 
                      (#
                      do (if isRef and (off = this(getAttName).off) then
                             'origin' -> NM[];
                             leave find
                      if)#)
                 do (if off = currentND.off then
                        (if true
                         // not isRef and not isIndexed and currentDcl.IT.isSimple then 
                            currentND.lexemSy -> NM[];
                            leave find
                         // isRef and not isIndexed and not currentDcl.IT.isSimple then
                            currentND.lexemSy -> NM[];
                            leave find
                         // not isRef and isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                     else
                        (if isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                 if)#)
            exit NM[]
            #);
          vPushEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> execution.onVPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          vStoreEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> execution.onVStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rPushEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> execution.onRPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rStoreEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> execution.onRStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          suspendEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, preemptive) -> execution.onSuspend then
                   caller[] -> selectCode;
                   doPause;
               if); 
            #);
          resumeEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, preemptive) -> execution.onResume then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          binOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onBinOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          unOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onUnOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          jmpGTevent::
            (#
            do (if (operator[], value, to[]) -> execution.onJmpGT then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          popEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onPop then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          errorEvent::
            (# mb: @MessageBox
            do '\nWorldWindow:errorEvent'->putline;
               thisObj[] -> selectCode;
               msg[] -> execution.onError;
               (if true then
                   msg.scanAll(# do ch -> execution.put #)
                else
                   msg[] -> mb.init;
               if);
               suspend
            #)
       #);
     breaks: @
       (# IMPs: [4] ^generator.imperative; top: @integer;
          clear: (# do 0 -> top #);
          add:
            (# imp: ^generator.imperative
            enter imp[]
            do (if (top + 1 -> top) > IMPs.range then
                   IMPs.range -> IMPS.extend
               if);
               imp[] -> IMPS[top][]
            #);
          astPos:
            (# bcPos,beginPos,endPos: @integer
            enter bcPos
            do L: (for i: top repeat
                       (if bcPos = IMPs[i].beginBCP then
                           IMPS[i].beginPos -> beginPos;
                           IMPS[i].endPos -> endPos;
                           (if false then
                               'found astPos: ' -> puttext; beginPos -> putint;
                               ',' -> put; endPos -> putint; newline;
                           if);
                           leave L
                  if)for)
            exit(beginPos,endPos)
            #);                      
       #);
     L: @log;
     
     init:
       (#
       enter theSystemEnv[]
       do 'BETA MiniEnv - SVN version' -> putline;
          &|WorldVM[] -> VM[];
          ('minienv..log',false) -> L.open;
          (compile[],VM[],L[]) -> ObjCont.init;
	  'BETAworld.bet' -> prependPathToBetaWorld -> FN[];
          (*** 'BETAworld.bet' -> FN.append -> FN[]; ***)
          (L[],true,none,FN[]) -> compile;
	       
	  (compile.rootModule.name.lexemSy,compile.rootModule[],none,none)
                 -> ObjCont.handle
            -> objContRoot[];
          popUp.open;
          EMBEDDED -> theWorldWindow.open;
       #);
  #);
