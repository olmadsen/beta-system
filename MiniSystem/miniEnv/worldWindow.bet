ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE '~beta/guienv/utils/prompts';
INCLUDE 'tableview';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'sequencediagram';
INCLUDE 'log';
INCLUDE 'newAttributeBox';
INCLUDE 'prompt';
INCLUDE '../miniCompiler/generator';
INCLUDE '../miniCompiler/betaVM'
INCLUDE '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/utils/guienvadds';

---guienvlib:attributes---
worldWindow: window 
  (# counter: @integer;
     UserYes: (# exit 1 #);
     UserNo: (# exit 2 #);
     UserCancel: (# exit 3 #);
     promptUser:
       (# dialog: @PromptDialog
            (# onYes::
                 (#
                 do UserYes -> result;
                    dialog.close;
                 #);
               onNo::
                 (#
                 do UserNo -> result;
                    dialog.close;
                 #);
               onCancel::
                 (#
                 do UserCancel -> result;
                    dialog.close;
                 #);
            #);
          left, top: @integer;
          mainWidth, mainHeight: @integer;
          dialogWidth, dialogHeight: @integer;
          
          message: ^Text;
          title: ^Text;
          result: @integer;
       enter (title[], message[])
       do true -> lockout;
          dialog.open;
          THIS(Window).position -> (left, top);
          THIS(Window).size -> (mainWidth, mainHeight);
          dialog.size -> (dialogWidth, dialogHeight);
          (left + (mainWidth - dialogWidth) div 2, top + 60) -> dialog.position;
          message[] -> dialog.changeLabel;
          title[] -> dialog.title;
          dialog.showModal;
          false -> lockout;
       exit result
       #);
     
     lockout: @boolean;
     layoutFlag: @boolean;
     updater: @Timer
       (# action::
            (#
            do (if layoutFlag then
                   false -> layoutFlag;
                   mainLayout.layout;
               if);
            #);
       #);
     defaults: @
       (# headH: (# exit 20 #);
          worldWindowW: (# exit 1420 #);
          worldWindowH: (# exit 860 #);
          componentW: (# exit 480 #);
          componentH: (# exit 800 #);
          mainBrowserW: (# exit 380 #);
          mainBrowserH: (# exit 120 #);
          browserW: (# exit 92 #); 
          browserH: (# exit 120 - 11 #); (* - 2 * borderWidth *)
          textEditW: (# exit 201 #);
          textEditH: (# exit 650 - 11 #);   
       #);
     open:: 
       (# frame: @Rectangle;
          width, height: @integer;
       do ('minienv..log',false) -> L.open; (* we may move this to main program *)
          (compile[],VM[],L[]) -> ObjCont.init;
          
          screenRectangle -> frame;
          frame.size -> (width, height);
          
          (width - 20, height - 35 - 50) -> size;
          (10,35) -> position;
          popUp.open;
          'BETAworld' -> title;
          
          'BETAworld.bet' -> prependPathToBetaWorld -> FN[];
          'BETAworld.bet' -> FN.append -> FN[];
          (L[],true,none,FN[]) -> compile;

          (if false then
              'Setup: ' -> puttext; FN[] -> putline;
              'Root: ' -> puttext; compile.rootModule.name.lexemSy -> putline;
          if);
          
          theBETAworld.setup;
          100 -> updater.start;
       #);
     
     objContRoot: ^objCont.handle;
     eventHandler::
       (# onAboutToClose:: (# do terminate #);
          onMouseDown::
            (# P: @point
            do (if buttonState = 3 then
                   localPosition -> P;                  
                   popUp.enable;
                   (1,(P.H,P.V), contents) -> popUp.popUp
               if);
            #);
       #);     
     mainLayout: @HorizontalLayoutManager
       (# changed::
            (#
            do true -> layoutFlag;
            #);
       #);
     leftLayout: @VerticalLayoutManager;
     
     
     components: @Sequence
       (# element:: ComponentWindow;
       #);
     
     addByIndex:
       (# inx: @integer;
          objC: ^objCont.Handle;
          name: ^Text;
          width, height: @integer;
          component: ^ComponentWindow;
          root: @boolean;
       enter inx
       do (if inx = 0 then
              'BETA world' -> name[];
              true -> root;
              1 -> inx;
              objContRoot[] -> objC[];
           else
              objContRoot.dclNames[inx][] -> name[];
              false -> root;
              inx -> objContRoot.elm -> objC[];
          if);
          &ComponentWindow[] -> component[];
          (NONE, name[], root, inx, objC[]) -> component.open;
          component.size -> (width, height);
          (width, height / 5) -> component.size;
          component.layout[] -> leftLayout.add;
          component[] -> components.append;
       exit component[]
       #);
     closeAll:
       (#
       do components.scan
          (#
          do current.layout[] -> leftLayout.remove;
             current.close;
          #);
          components.clear;
       #);
     initialLayout:
       (#
       do THIS(Window).size -> leftLayout.size;
          480 -> leftLayout.width;
          leftLayout.layout;
       #);
     combine:
       (#
       do closeAll;
          0 -> addByIndex;
          initialLayout;
       #);
     split:
       (#
       do closeAll;
          (for inx: objContRoot.dclNames.range repeat
               inx -> addByIndex;
          for);
          initialLayout;
       #);
     newBrowser:
       (# component: ^ComponentWindow;
       do 0 -> addByIndex -> component[];
          component.layout[] -> leftLayout.layout;
       #);
     
     theBETAworld: @
       (# setUp:
            (# 
            do mainLayout.init;
               THIS(Window).size -> mainLayout.size;
               leftLayout.init;
               leftLayout[] -> mainLayout.add;
               placeholder[] -> mainLayout.add;
               (compile.rootModule.name.lexemSy,compile.rootModule[],none,none)
                 -> ObjCont.handle
                 -> objContRoot[];
               combine;
            #);
          scan: 
            (# current: ^ComponentWindow; inx: @integer
            do components.scan
               (#
               do current[] -> THIS(Scan).current[];
                  inx + 1 -> inx;
                  INNER scan;
               #);
            #);
          selectDesc:
            (# obj: ^objDesc.template; 
               path: ^intList; 
               descNo: @integer;
               desc: ^generator.ObjectDesc;
               lsc: @integer;
               objC: ^objCont.handle;
            enter (obj[], descNo, path[], desc[], lsc)
            do path.up;
               L: scan
                 (#
                 do (if ((obj[], descNo, path[]) -> current.selectCode -> objC[]) <> none then
                        (path[], 2, desc[], lsc) -> current.selectDesc;
                        leave L;
                    if);
                 #);
            exit objC[]
            #);
          selectCode:
            (# obj: ^objDesc.template; 
               path: ^intList; 
               descNo, beginPos, endPos: @integer;
               objC: ^objCont.handle;
            enter (obj[], descNo, path[], beginPos, endPos)
            do path.up;
               L: scan
                 (#
                 do (if ((obj[], descNo, path[]) -> current.selectCode -> objC[]) <> none then
                        (path[], 2, beginPos, endPos) -> current.select;
                        leave L;
                    if);
                 #);
            exit objC[]
            #);
       #);

     popUp: @menu
       (# iSave: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do 'SaveAll' -> putline;
                         theBETAworld.scan(# do current.saveEditBuffers #);
                         objContRoot.saveModuleToFile
                 #)#);
               open:: (# do 'Save All' -> name; iSave[] -> append; #);
            #);
          iQuit: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do terminate 
                      #)
                 #);
               open:: (# do 'Quit' -> name; iQuit[] -> append #);
            #);
          open::
            (#
            do iSave.open;
               iQuit.open
            #);
       #);
     displayWindow:
       (* Super pattern for static item in ComponentWindow, Items and TextEditor  *)
       (# enclosingObjCont: ^objCont.handle;
          left,right: ^displayWindow;
          setUpBrowser:< (# do inner #);
          position:< (# pos: @point do inner exit pos #);
          size:< (# width,height: @integer do inner exit(width,height) #);
          reDisplay:< (# do inner #);
          hasEditChanges:< BooleanValue (# do inner #);
          select:< (# do inner #);
          showErrors:< (# errors: ^stream enter errors[] do inner #);
          hideErrors:< (# do INNER #);
          close:< (# do inner #);
          closeEditor:< (# do inner #);
          save:< (# errors: ^text do inner exit errors[] #);
          print:< (# T: @text do inner exit T[] #);
          description:<
            (# value: ^Text;
            do 'UNK' -> value[];
               INNER;
            exit value[]
            #);
       #);
     
     NavigationRecord:
       (# back: ^NavigationRecord;
          content: ^objCont.Handle;
          index: @integer;
          name: ^Text;
       #);

     componentWindow:  subwindow
       (# fixed: ^TextStyle;
          root: @boolean;
          back: ^NavigationRecord;
          
          maximum: @integer;
          onExpand::
            (# width, height: @integer;
            do THIS(SubWindow).size -> (width, height);
               (width, maximum) -> THIS(SubWindow).size;
               grow.show;
            #);
          onCollapse::
            (# width, height: @integer;
            do THIS(SubWindow).size -> (width, height);
               (width, 20 + 2 * theBorderWidth) -> THIS(SubWindow).size;
               height -> maximum;
               grow.hide;
            #);
          
          open::
            (# index: @integer;
               objC: ^ObjCont.handle;
               width, height: @integer;
               
            enter (root, index, objC[])
            do 'icons\\error.png' -> loadImage -> errorIcon[];
               'icons\\package.png' -> loadImage -> packageIcon[];
               'icons\\publicpackage.png' -> loadImage -> publicpackageIcon[];
               'icons\\privatepackage.png' -> loadImage -> privatepackageIcon[];
               'icons\\pattern.png' -> loadImage -> patternIcon[];
               'icons\\virtual.png' -> loadImage -> virtualIcon[];
               'icons\\reference.png' -> loadImage -> referenceIcon[];
               'icons\\lightref.png' -> loadImage -> lightrefIcon[];
               'icons\\simple.png' -> loadImage -> simpleIcon[];
               'icons\\array.png' -> loadImage -> arrayIcon[];
               'icons\\cog.png' -> loadImage -> cogwheel[];
               
               &TextStyle[] -> fixed[];
               'Courier' -> fixed.name;
               8 -> fixed.size;
               textFaces.plain -> fixed.face;
               
               (0, 0) -> position;
               scroller.open;
               scroller[] -> browser.open;
               (theBorderWidth, defaults.headH + theBorderWidth)
                 -> scroller.position;
               (480, defaults.browserH) -> browser.size;
               browser.size -> scroller.size;
               
               true -> flexible;
               (index, objC[], lab[]) -> setContent;
               scroller.layout;
               false -> flexible;
               
               THIS(Window).size -> (width, height);
               (defaults.componentW, height) -> size;
               fitToContents;
            #);
          
          
          navigateTo:
            (# index: @integer;
               objC: ^objCont.Handle;
            enter (index, objC[])
            do (# record: ^NavigationRecord;
                  name: ^Text;
               do &NavigationRecord[] -> record[];
                  thisIndex -> record.index;
                  head.label -> record.name[];
                  asDW.enclosingObjCont[] -> record.content[];
                  back[] -> record.back[];
                  record[] -> back[];
                  (if objC.theName[] <> NONE then
                      objC.theName.copy -> name[];
                   else
                      '' -> name[];
                  if);
                  (index, objC[], name[]) -> changeContent;
               #);
            #);
          navigateBack:
            (# 
            do (if back[] <> NONE then
                   (back.index, back.content[], back.name[]) -> changeContent;
                   back.back[] -> back[];
               if);
            #);
          changeContent:
            (# index: @integer;
               objC: ^objCont.Handle;
               name: ^Text;
            enter (index, objC[], name[])
            do theItems.closeRight;
               theItems.close;
               NONE -> theItems[];
               (index, objC[], name[]) -> setContent;
            #);
          setContent:
            (# index: @integer;
               objC: ^objCont.Handle;
               name: ^Text;
            enter (index, objC[], name[])
            do index -> thisIndex;
               objC[] -> asDW.enclosingObjCont[];
               (NONE, 1, asDW.enclosingObjCont[])
                 -> (&BrowserItems[] -> theItems[]).setUpBrowser;
               name[] -> head.label;
               head.update;
            #);
          asDW: @ displayWindow
            (# size:: (# do this(componentWindow).size -> (width,height) #);
               position:: (# do this(componentWindow).position -> pos #);
               reDisplay:: (#do 'componentWindow.asDW:reDisplay:shouldNotHappen' -> putline #);
               hasEditChanges:: (# do 'componentWindow.asDW:hasEditChanges:shouldNotHappen' -> putline #);
               save:: (# do 'componentWindow.asDW:save:shouldNotHappen' -> putline #);

            #);
          onOpenClose::
            (# w, h: @integer
            do (if true then
                   true -> THIS(ComponentWindow).sizeToFit;
                else
                   (if miniSize then
                       'OpenClose:Grow'->putline;
                       (fullW,fullH) -> this(componentWindow).size
                    else
                       'OpenClose:Reduce' -> putline;
                       this(componentWindow).size -> (fullW,fullH);
                       head.size -> (w,h);
                       (50,h)
                         -> this(componentWindow).size;
                       w-> putint; ' ' -> put; h -> putint; newline
                   if);
                   not miniSize -> miniSize;
               if)
            #);

          miniSize: @ boolean;
          fullW,fullH: @integer;
          selectCode: 
            (# obj: ^objDesc.template; descNo: @integer; path: ^intList; objC: ^objCont.handle
            enter(obj[],descNo,path[])
            do (obj[],descNo,path[]) -> asDW.enclosingObjCont.selectCode -> objC[]
            exit objC[]
            #);
          selectDesc:
            (# path: ^intList; inx: @integer;
               desc: ^generator.ObjectDesc;
               lsc: @integer;
               beginPos, endPos: @integer;
               result: ^TextEdit;
            enter(path[],inx, desc[], lsc)
            do (path[],inx, 0, 0) -> theItems.select -> result[];
               true -> desc.doPT; (* OBS! true is needed to update charPos in desc *)
               lsc 
                 -> desc.acp.mapBCposToCharRange 
                 -> (beginPos,endPos);
               (beginPos, endPos) -> result.select;
            #);
          select:
            (# path: ^intList; inx,beginPos,endPos: @integer;
               result: ^TextEdit;
            enter(path[],inx,beginPos,endPos)
            do '-- items select' -> putline;
               (path[],inx, 0, 0) -> theItems.select -> result[];
               (beginPos, endPos) -> result.select;
            #);
          Heading::<
            (# open::
                 (#
                 do headingPopUp.open
                 #);
               eventHandler::<
                 (# onMouseUp::
                      (# P: @point
                      do (if buttonState = 3 then
                             localPosition -> P;
                             (1,(P.h,P.v),this(Heading)[]) -> headingPopUp.popUp
                         if)
                      #);                       
                    onMouseEnter:: (# #);
                 #);
               headingPopUp: @menu
                 (# iSplit: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do (if root then
                                       split;
                                    else
                                       combine;
                                   if);
                                #)
                           #);
                         open:: 
                           (# 
                           do (if root then
                                  'Split' -> name;
                               else
                                  'Assemble' -> name;
                              if);
                              iSplit[] -> append;
                           #)
                      #);
                    iNew: @menuItem
                      (# open::
                           (#
                           do 'New Browser' -> name;
                              iNew[] -> append;
                           #);
                         eventHandler::
                           (# onSelect::
                                (#
                                do newBrowser;
                                #);
                           #);
                      #);
                    iBack: @menuItem
                      (# open::
                           (#
                           do 'Back' -> name;
                              iBack[] -> append;
                           #);
                         eventHandler::
                           (#
                              onSelect::
                                (#
                                do navigateBack;
                                #);
                           #);
                      #);
                    iClose: @MenuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do layout[] -> leftLayout.remove;
                                   THIS(ComponentWindow).close;
                                   THIS(ComponentWindow)[] -> components.delete;
                                   leftLayout.layout;
                                #)
                           #);
                         open:: 
                           (# 
                           do 'Close' -> name; 
                              iClose[] -> append;
                           #);
                      #);
                    open::
                      (#
                      do iSplit.open;
                         iNew.open;
                         iBack.open;
                         iClose.open;
                      #)
                 #);
            #);
          eventHandler::
            (# count: @integer;
               onFatherFrameChanged::
                 (#
                 do THIS(WorldWindow).size -> mainLayout.size;
                    mainLayout.layout;
                    
                 #);
               onMouseDown::
                 (# 
                 do trackMouse
                    (# mouseMove:: 
                         (#
                         do (h, v) -> move;
                            true -> this(SubWindow).update
                         #)
                    #)
                 #);
            #);
          scroller: @Canvas
            (# count: @integer;
               visible: @boolean;
               theScrollBar: @ScrollBar
                 (# count: @integer;
                    eventHandler::
                      (# onValueChanged::
                           (#
                           do theScrollBar.value -> scroll;
                           #);
                      #);
                 #);
               scroll:
                 (# value: @integer;
                    x, y: @integer;
                 enter value
                 do browser.position -> (x, y);
                    (-value, y) -> browser.position;
                 #);
               getScroll:
                 (# x, y: @integer;
                 do browser.position -> (x, y);
                 exit -x
                 #);
               
               layout:
                 (# width, height: @integer;
                    w, h: @integer;
                    x, y: @integer;
                 do position -> (x, y);
                    THIS(SubWindow)[] -> theScrollBar.open;
                    size -> (width, height);
                    theScrollBar.size -> (w, h);
                    (width, h) -> theScrollBar.size;
                    (0, y + height - h) -> theScrollBar.position;
                    true -> theScrollBar.bindRight;
                    theScrollBar.hide;
                    true -> browser.bindBottom;
                 #);
               checking: @boolean;
               checkScrollValues:
                 (# page: @integer;
                    port: @integer;
                    excess: @integer;
                    h1: @integer;
                    h2: @integer;
                    h, w: @integer;
                    value: @integer;
                    checkit: @boolean;
                 do (if NOT checking then
                        true -> checking;
                        browser.size -> (page, h1);
                        scroller.size -> (port, h2);
                        theScrollBar.size -> (w, h);
                        (if page <= port then
                            (if visible then
                                theScrollBar.hide;
                                false -> visible;
                            if);
                            (port, defaults.browserH) -> scroller.size;
                            0 -> scroll;
                         else
                            page - port -> excess;
                            (if not visible then
                                theScrollBar.show;
                                true -> visible;
                            if);
                            (port, defaults.browserH - h) -> scroller.size;
                            excess -> theScrollBar.maxValue;
                            (if true then
                                excess -> theScrollBar.value;
                             else
                                (if theScrollBar.value > excess then
                                    excess -> theScrollBar.value;
                                if);
                            if);
                            getScroll -> value;
                            (if value <> theScrollBar.value then
                                theScrollBar.value -> scroll;
                            if);
                            browser.scrollIntoView;
                        if);
                        false -> checking;
                    if);
                 #);
               eventHandler::
                 (# onFrameChanged::
                      (#
                      do checkScrollValues;
                         (if false then
                             (if rightEditor[] <> NONE then
                                 rightEditor.adjustLineWidth;
                             if);
                         if);
                      #);
                 #);
            #);
          browser: @Canvas
            (# sizeToFit:
                 (# current: ^BrowserItems;
                    x, y: @integer;
                    w, h: @integer;	
                    minimum: @integer;
                    width, height: @integer;
                 do (if theItems[] <> NONE then
                        theItems[] -> current[];
                        loop:
                          (if current.right[] <> NONE then
                              current.right[] -> current[];
                              restart loop;
                          if);
                        current.position -> (x, y);
                        current.size -> (w, h);
                        size -> (width, height);
                        x + w + 1 -> width;
                        (width, height) -> size;
                    if);
                 #);
               scrollIntoView:
                 (# current: ^BrowserItems;
                 do theItems[] -> current[];
                    loop:
                      (if current[] <> NONE then
                          current.scrollIntoView;
                          current.right[] -> current[];
                          restart loop;
                      if);
                 #);
            #);
          theItems: ^BrowserItems; (* top Items of this(ComponentWindow) *)
          currentSelection: ^DisplayWindow; (* Current selection *)
          
          saveEditBuffers: (# do theItems.saveEditBuffers #);
          
          sizeToFit:
            (# current: ^BrowserItems;
               x, y: @integer;
               w, h: @integer;
               minimum: @integer;
               width, height: @integer;
               resize: @boolean;
            enter resize
            do browser.sizeToFit;
               browser.size -> (w, h);
               (w, h) -> scroller.size;
               false -> scroller.bindRight;
               size -> (width, height);
               w + theBorderwidth*2 -> minimum;
               (if (minimum > width) and resize then
                   (minimum, height) -> size;
                else
                   (width - theBorderwidth*2, h) -> scroller.size;
               if);
               true -> scroller.bindRight;
               scroller.checkScrollValues;
            #);
          
          BrowserItems: TableView
            (# open::
                 (# v: @point; h: @integer;
                    lWidth,lHeight: @integer;
                      
                 do (if asDW.left[] <> none then
                        asDW.left.position -> v;
                        asDW.left.size -> (lWidth,lHeight);
                        v.h + lWidth -> h
                     else 
                        1 -> h;
                        defaults.browserW -> lWidth;
                        defaults.browserH -> lHeight
                    if);
                    
                    (h, 1) -> position;
                    (if scroller.visible then
                        (defaults.browserW, defaults.browserH - 16) -> size;
                     else
                        (defaults.browserW, defaults.browserH) -> size;
                    if);
                    fixed[] -> style;
                    true -> bindLeft;
                    itemPopUp.open; 
                    
                 #);
               asDW: @DisplayWindow
                 (* objC is an entry of the form
                  *    E = (X1,X2,... Xn)
                  * where X1, X2, ..., Xn
                  * are displayed in the item-list
                  *)
                 (# size:: (# do this(BrowserItems).size -> (width,height) #);
                    position:: (# do this(BrowserItems).position -> pos #);
                    thisInx: @integer;
                    thisObjCont:
                      (# objC: ^objCont.Handle
                      do (if thisInx > 0 then
                             thisInx -> enclosingObjCont.elm -> objC[];
                         if);
                      exit objC[]
                      #);
                    reDisplay:: (# do (thisInx,0,0,true) -> display#);
                    hasEditChanges:: 
                      (# do (rightEditor[]<> none) and rightEditor.wasChanged -> value #);
                    closeEditor:: (# do none -> rightEditor[] #);
                    showErrors:: (# do errors[] -> this(browserItems).showErrors #);
                    hideErrors:: (# do THIS(BrowserItems).hideErrors; #);
                    save::
                      (# right: ^BrowserItems
                      do (if hasEditChanges then
                             'Must save: ' -> puttext; 
                             ((thisObjCont).enclosingModuleObj).theName[] -> putline;
                             print -> putline;
                             saveEditBuffers -> errors[];
                             
                             'errors: "' -> puttext;
                             errors[] -> puttext;
                             '"' -> putline;
                             
                             ((thisObjCont).enclosingModuleObj).saveModuleToFile;
                             (* closeRight;  --- if called from TextEdit::onTab, we
                              * should not close the textEditor
                              * Some redundancy with display below
                              *)
                            
                             &BrowserItems[] -> right[];
                             right.asDW[] -> asDW.right[];
                             right[] -> THIS(BrowserItems).right[];
                             (asDW[],thisInx,thisObjCont) -> right.setUpBrowser;
                         if)                      
                      #);
                    print::
                      (# 
                      do (if thisInx > 0 then
                             (thisObjCont).entityPathFromModule -> T.puttext
                          else
                             'No selection' -> T.puttext
                         if);
                      #);
                    description::
                      (#
                      do '[' -> value[];
                         enclosingObjCont.theName[] -> value.puttext;
                         ']' -> value.puttext;
                      #);
                 #);
               
               process:
                 (# event: ^EventHandler.MouseEvent;
                    P: @point;
                    
                 enter event[]
                 do (if selection.first > 0 then
                        (if event.doubleClick then 
                            (* selection.first -> gettext -> putline;
                             * 'Edit field' -> putline;
                             *)
                            selection.first -> editField;
                            event.LocalPosition -> P;
                            (* 'mouse.V: ' -> puttext; P.V -> putint; 
                             * ' mouse.H: ' -> puttext; P.H -> putint; newline;
                             *)
                         else                             
                            (if event.buttonState
                             // 1 then 
                                (selection.first,0,0,true) -> display
                             // 3 then
                                (selection.first,0,0,true) -> display;
                                (if ((selection.first 
                                      -> asDW.thisInx 
                                      -> asDW.enclosingObjCont.elm).theEntry.kind)
                                    = '/' then
                                    itemPopUp.saveHandler[] -> itemPopUp.iSave.attach;
                                    (* Perhaps also insist on a do-part for iExe?*)
                                    itemPopUp.exeHandler[] -> itemPopUp.iExe.attach
                                if);
                                (if clipboard.hasText then
                                    itemPopUp.textPasteHandler[] -> itemPopUp.iPaste.attach;
                                    itemPopUp.textPasteModuleHandler[] -> itemPopUp.iPasteAsModule.attach;
                                if);
                                (1,event.localposition,this(BrowserItems)[]) -> itemPopUp.popUp;
                            if);
                        if);
                     else
                        closeRight;
                        &textEdit[] -> rightEditor[];
                        (asDW[], asDW.enclosingObjCont[],0,0) -> rightEditor.setUpEditor;
                        (if event.buttonState = 3 then
                             (if clipboard.hasText then
                                 itemPopUp.textPasteHandler[] -> itemPopUp.iPaste.attach;
                                 itemPopUp.textPasteModuleHandler[] -> itemPopUp.iPasteAsModule.attach;
                             if);
                            (1,event.localposition,this(BrowserItems)[]) -> itemPopUp.popUp;
                        if);
                    if);
                 #);
               onMouseDown::
                 (#
                 do event[] -> process;
                 #);
               eventHandler::
                 (# onMouseUp::
                      (#
                      do THIS(MouseEvent)[] -> process;
                      #)
                 #);
               editField:
                 (# no: @integer; 
                    oldCont,oldName,newName: ^text; 
                    oldKind,newKind: @char;
                    P: @point; R: @rectangle;
                    TE: @editText
                      (# open::
                           (# 
                           do this(BrowserItems).style -> style;
                              borderStyles.simple -> border.style;
                              false -> border.visible;
                              (P.H + 1,P.V + R.top + 2) -> position;
                              (R.right-R.left+5,R.bottom-R.top+5) -> size; 
                              (* must add 5 to height for text cursor to be visible *)
                              no -> gettext -> oldCont[] -> contents;
                           #);
                         eventHandler::<
                           (# onKeyDown:: 
                                (# error: @boolean
                                do (* 'Key down: ' -> puttext; ch -> put; 
                                    ch -> putint; newline; ascii.nl -> putint; newline;
                                    *)
                                   (if ch = 13 (* nl on Windows?*) then
                                       (if not (contents -> oldCont.equal) then
                                           (oldCont[],contents) -> asDW.enclosingObjCont.changeAttName -> error;
                                           (if error then
                                               'Syntax error in browser item: '-> puttext;
                                               contents -> putline
                                            else
                                               (no,contents) -> setText;
                                           if)
                                       if);
                                       close
                                   if)
                                #)
                           #)
                      #)
                 enter no
                 do no -> getItemRectangle -> R;
                    this(BrowserItems).position -> P;
                    browser[] -> TE.open
                 #);
               display:
                 (* for asDW where E = (X1,X2, ..., Xn)
                  * Xinx has been selected2
                  *)
                 (# inx,beginPos,endPos: @integer; 
                    mkTxtEditor: @boolean;
                    result: ^TextEdit;
                 enter (inx, beginPos, endPos, mkTxtEditor)
                 do L:
                      (# objCx: ^ObjCont.handle;
                      do (if currentSelection[] <> none then
                             (if currentSelection.save <> none then
                                 (* syntax errors in edit buffer og currentSelection *)
                                 leave L
                             if)
                         if);
                         closeRight;
                         asDW[] -> currentSelection[];
                         inx -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objCx[];
                         
                         (if objCx[] <> none then (* should never be none ! *)
                             (if pred[] <> none then (* why? *) pred.closeEditor if);
                             &BrowserItems[] -> right[];
                             right.asDW[] -> asDW.right[];
                             (asDW[],index,objCx[]) -> right.setUpBrowser;
                             flexible -> THIS(ComponentWindow).sizeToFit;
                             (if mkTxtEditor then
                                 &textEdit[] -> rightEditor[];
                                 (asDW[],objCx[],beginPos,endPos) -> rightEditor.setUpEditor;
                                 rightEditor[] -> result[];
                             if);
                          else
                             'objCx is NONE' -> putline;
                         if);
                      #);
                 exit result[]
                 #);
               hideErrors:
                 (# width, height: @integer;
                 do (if errorView[] <> NONE then
                        errorView.close;
                        NONE -> errorView[];
                        (if rightEditor[] <> NONE then
                            rightEditor.size -> (width, height);
                            (width, height + 320) -> rightEditor.size;
                        if);
                    if);
                 #);
               showErrors:
                 (# x, y: @integer;
                    width, height: @integer;
                    errors: ^Stream;
                 enter errors[]
                 do '-----' -> putline;
                    errors.reset;
                    errors[] -> putline;
                    '-----' -> putline;
                    (if rightEditor[] <> NONE then
                        rightEditor.size -> (width, height);
                        rightEditor.position -> (x, y);
                        (width, height - 320) -> rightEditor.size;
                        &ErrorList[] -> errorView[];
                        errorView.open;
                        (x, y + (height - 320)) -> errorView.position;
                        (width, 320) -> errorView.size;
                        true -> errorView.bindRight;
                        true -> errorView.bindBottom;
                        errors[] -> errorView.display;
                        errors[] -> rightEditor.handleErrors;
                    if);
                 #);
               itemPopUp: @menu
                 (# iAdd: @menuItem
                      (# open:: (#do 'Add' -> name; iAdd[] -> append #);
                         eventHandler::
                           (# onSelect::
                                (# x: @newAttributeBox;
                                do x.open;
                                   (if not x.isCanceled then 
                                       (if X.name.length = 0 then
                                           '*** Missing name!'-> putline
                                        else
                                           (if selection.first > 0 then
                                               (selection.first, x.name[], x.kind) -> addItem;
                                            else
                                               (numberOfItems + 1,  x.name[], x.kind) -> addItem;
                                           if);
                                       if);
                                   if)
                                #);
                           #);
                         addItem:
                           (# inx,kind: @integer; N,att: ^text; before: @boolean; 
                              objCx: ^ObjCont.handle
                           enter(inx,N[],kind)
                           do (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                              
                              '*** AddItem: "' -> puttext; N[] -> puttext; ' ' ->put; kind -> put;
                              ' "*** OBS! Missing check of syntax and double declaration' -> putline;

                              ('selection',inx) -> L.TIn;
                              (inx,N[],kind)  -> asDW.enclosingObjCont.addItem -> att[];
                              
                              (inx,att[]) -> configure;
                              (inx,false) -> selection.select;
                              closeRight;
                              (if false then
                                  inx -> asDW.enclosingObjCont.elm -> objCx[];
                                  ('addItem:ObjX',objCx.theName[]) -> L.TTn;
                              if);
                              ('addItem:enclosingObjCont',asDW.enclosingObjCont.theName[]) 
                                -> L.TTn;
                              (inx, 0,0,true) -> display
                           #);
                      #);
                    iMove: @menuItem
                      (# eventHandler:: 
                           (# onSelect:: (* never called - has submenu *)
                                (# 
                                do 'Move' -> putline;
                                   (1,(0,0),this(BrowserItems)[]) -> UD.popUp
                           #)#);
                         open:: 
                           (# 
                           do 'Move' -> name; iMove[] -> append;
                              UD.open; 
                              UD[] -> subMenu
                           #);
                         UD: @menu
                           (# iUp: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Up' -> putline; 
                                             (if 1 < (selection.first -> inx) then
                                                 inx -> gettext -> T[];
                                                 (inx, inx - 1 -> gettext) -> setText;
                                                 (inx - 1, T[]) -> setText;
                                                 (T[],inx) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Up' -> name; 
                                        iUp[] -> append; 
                                     #);
                                #);
                              iDown: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Down' -> putline; 
                                             (if (selection.first ->inx) < numberOfItems then
                                                 inx -> gettext -> T[];
                                                 (inx, inx + 1 -> gettext) -> setText;
                                                 (inx + 1 , T[]) -> setText;
                                                 (T[],inx + 1) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Down' -> name; 
                                        iDown[] -> append; 
                                     #);
                                #);
                              open:: (# do iUp.open; iDown.open #)
                           #)
                      #);      
                    iCopy: @menuItem
                      (# eventHandler::
                           (# onselect::
                                (# inx: @integer;
                                   T: ^text
                                do (if (selection.first ->inx) <= numberOfItems then
                                       (if true then
                                           (# dcl: ^generator.Node;
                                              obj: ^objCont.Handle;
                                           do inx -> asDW.enclosingObjCont.elm -> obj[];
                                              (if obj.isModule then
                                                  (# source: @File;
                                                  do obj.getModulePath -> source.name;
                                                     source.openRead;
                                                     &Text[] -> T[];
                                                     loop:
                                                       (if not source.eos then
                                                           source.getLine -> T.putline;
                                                           restart loop;
                                                       if);
                                                     source.close;
                                                  #);
                                               else
                                                  asDW.enclosingObjCont.DCLs[inx][] -> dcl[];
                                                  dcl.doPt -> T[];
                                              if);
                                           #);
                                        else
                                           (selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm ).gettext -> T.append;
                                       if);
                                       T[] -> clipBoard.textContents;
                                   if)
                                #)
                           #);
                         open::(#do 'Copy' -> name; iCopy[] -> append #)
                      #);
                    iPaste: @dynamicMenuItem
                      (# open:: (# do 'Paste'-> name; iPaste[] -> append #)
                      #);
                    
                    textPasteHandler: @menuAction
                      (# onSelect::
                           (# inx: @integer;
                              att: ^Text;
                           do (if selection.first = 0 then
                                  numberOfItems + 1 -> inx;
                               else
                                  selection.first -> inx;
                              if);
                              (inx, clipBoard.textContents)  
                                -> asDW.enclosingObjCont.addDecl 
                                -> att[];
                              (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                              (inx,att[]) -> configure;
                              (inx,false) -> selection.select;
                              closeRight;
                              (inx, 0,0,true) -> display
                           #);
                      #);
                    iPasteAsModule: @dynamicMenuItem
                      (# open:: (# do 'Paste as Module'-> name; iPasteAsModule[] -> append #)
                      #);
                    textPasteModuleHandler: @menuAction
                      (# onSelect::
                           (# inx: @integer;
                              att: ^Text;
                           do 'paste-module: ' -> puttext;
                              clipBoard.textContents -> putline;
                               (if selection.first = 0 then
                                  numberOfItems + 1 -> inx;
                               else
                                  selection.first -> inx;
                               if);
                              (inx, clipBoard.textContents)  
                                -> asDW.enclosingObjCont.addModule
                                -> att[];
                              (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                              (inx,att[]) -> configure;
                              (inx,false) -> selection.select;
                              closeRight;
                              (inx, 0,0,true) -> display
                           #);
                      #);
                    iDelete: @menuItem  
                      (# eventHandler::
                           (# onSelect:: 
                                (# inx: @integer;
                                   ok: @boolean;
                                   message: ^Text;
                                   result: @integer;
                                do 'iDelete: ' -> puttext;
                                   selection.first -> inx;
                                   false -> OK;
                                   'Delete item"' -> message[];
                                   asDW.enclosingObjCont.dclNames[inx][] -> message.puttext;
                                   '"?\n' -> message.puttext;
                                   
                                   ('', message[]) -> promptUser -> result;
                                   (if result = UserYes then
                                       asDW.enclosingObjCont.dclNames[inx][] -> putline;
                                       (asDW.enclosingObjCont.dclNames[inx][],selection.first)
                                         -> asDW.enclosingObjCont.delete;
                                       (inx,1) -> this(TableView).delete;
                                       (if inx > this(TableView).numberOfItems then inx - 1 -> inx if);
                                       (inx,false) -> selection.select;
                                       (selection.first,0,0,true) -> display;
                                   if);
                           #)#); 
                         open:: 
                           (# do 'Delete' -> name; iDelete[] -> append; #);
                      #);
                    iSave: @dynamicMenuItem
                      (# open:: (# do 'Save'-> name; iSave[] -> append #);
                      #);
                    saveHandler:  @menuAction
                      (# onSelect:: (# do asDW.save #);
                      #);
                    
                    iFocus: @MenuItem
                      (#
                         open::
                           (#
                           do 'Focus On' -> name;
                              iFocus[] -> append;
                           #);
                         eventHandler::
                           (#
                              onSelect::
                                (# index: @integer;
                                   content: ^objCont.Handle;
                                do 
                                   (if selection.first = 0 then
                                       'focus on: ' -> puttext;
                                       asDW.enclosingObjCont.theName[] -> putline;
                                    else
                                       'focus on: ' -> puttext;
                                       (selection.first -> asDW.enclosingObjCont.elm).theName[] -> putline;
                                       selection.first -> index;
                                       index -> asDW.enclosingObjCont.elm -> content[];
                                       (index, content[]) -> navigateTo;
                                   if);
                                #);
                           #);
                      #);
                    
                    iExe: @dynamicMenuItem
                      (# open:: (# do 'Execute' -> name; iExe[] -> append #);
                      #);
                    exeHandler: @menuAction
                      (# doCompile:
                           (# objC: ^ObjectContent.handle; FN: ^text; 
                              main: ^generator.module; errors: ^stream
                           enter objC[]
                           do '******* MiniENV: compile: ' -> puttext;
                              objC.modulePath -> FN[];
                              objC.theModule.name.lexemSy -> FN.append;
                              '.bet' -> FN.append;
                              objC.theModule.name.lexemSy -> putline;
                              (L[],true,objC.theModule[],FN[]) -> compile -> (main[],errors[]);
                           exit(compile.Main[],errors[])
                           #);
                         onSelect:: 
                           (# objX: ^ObjCont.handle;
                              comp: ^generator.Module;
                              x, y: @integer;
                              errors: ^stream
                           do (if (asDW.save -> errors[]) <> none then
                                  (* Save checks for syntax errors only
                                   * Semantic errors are not captured by Save
                                   *)
                                  '\n\n***** Syntax errors in module' -> putline;
                                  errors[] -> showErrors;
                               else
                                  ('Do execute',index) -> L.TI;
                                  (asDW.enclosingObjCont.theName[], selection.first) -> L.TI;
                                  selection.first 
                                    -> asDW.enclosingObjCont.elm 
                                    -> objX[] 
                                    -> doCompile 
                                    -> (comp[],errors[]);
                                  hideErrors;
                                  (if errors[] <> none then
                                      (* syntax errors have already been checked by Save
                                       * semantic errors are caught here
                                       *)
                                      '\n\n***** Errors in module' -> putline;
                                      errors[] -> putline;
                                      errors[] -> rightEditor.handleErrors;
                                      errors[] -> showErrors;
                                   else
                                      &WorldSequenceWindow[] -> execution[];
                                      execution.open;
                                      THIS(ComponentWindow)[] -> execution.browser[];
                                      placeholder[] -> mainLayout.remove;
                                      execution.layout[] -> mainLayout.add;
                                      480 -> leftLayout.width;
                                      mainLayout.layout;                                  
                                      compile[] -> execution.setCompiler;
                                      L[] -> execution.setLog;
                                      &|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM;
                                      execution.show;
                                      objX[] -> execution.execute;
                                  if);
                              if)
                           #)
                      #);
                    open::
                      (#
                      do iAdd.open;
                         iCopy.open;
                         iPaste.open;
                         iPasteAsModule.open;
                         iMove.open;
                         iDelete.open;
                         iFocus.open;
                         iExe.open;
                         iSave.open;
                      #);
                 #);
               saveEditBuffers: 
                 (* Check the use of this one
                  * When called from display:currentSelection.save, 
                  * only the current buffer needs to be saved;
                  * there are no rightmost buffers that need to be saved
                  * Check othher calls - perhaps only the call above is needed 
                  * since we then always save the edit buffer
                  * Also update comments in textEditor about wasChanged,
                  * we never reselect a buffer with changed elements
                  *)
                 (# errors: ^text
                 do ('SaveEditBuffers',asDW.print) -> L.TTn;
                    (if rightEditor[] <> none then 
                        (if rightEditor.wasChanged then
                            true -> rightEditor.asDW.enclosingObjCont.wasChanged;
                            ('SaveEditBuffer',rightEditor.contents.contents) -> L.TTn;
                            rightEditor.contents.contents 
                              -> rightEditor.asDW.enclosingObjCont.saveBuffer
                              -> rightEditor.handleErrors
                              -> errors[]
                        if);
                        (if not rightEditor.asDW.enclosingObjCont.wasChanged then
                            (* may be true from a previous selection *)
                            ('SaveEditBuffer:not changed',rightEditor.contents.contents) ->  L.TTn
                        if)
                     else 
                        (if asDW.right[] <> none then 
                            right.saveEditBuffers (* never bound ...?*)
                    if)if)
                 exit errors[]
                 #);
               closeErrors:
                 (#
                 do 
                 #);
               closeRight: 
                 (* close all Item-panes to the right and rightEditor *)
                 (# 
                 do ('CloseRight',asDW.print) -> L.TTn;
                    (if asDW.right[] <> none then 
                        right.closeRight;
                        right.close ;
                        none -> right[]; 
                        none -> asDW.right[]
                    if);
                    (if rightEditor[] <> none then
                        rightEditor.close
                    if);
                    (if errorView[] <> NONE then
                        errorView.close;
                        NONE -> errorView[];
                    if);
                    none -> rightEditor[]
                 #);
               pinx: @integer; 
               
               configure:
                 (# index: @integer;
                    str: ^Text;
                    visibility: @integer;
                 enter (index, str[])
                 do (# dcl: ^generator.Node;
                       obj: ^Object;
                       item: ^generator.ModuleItem;
                       desc: ^generator.ObjectDesc;
                       
                    do asDW.enclosingObjCont.DCLs[index][] -> dcl[];
                       dcl.sort -> obj[];
                       (if obj[] <> NONE then
                           (if obj## = compile.ModuleItem## then
                               obj[] -> item[];
                               item.desc -> desc[];
                               (if desc.props[] <> NONE then
                                   desc.props.OSDvisibility -> visibility;
                               if);
                           if);
                       if);
                    #);
                    
                    (# colon: @integer;
                       name: ^Text;
                       kind: @char;
                    do str.reset;
                       search: ':' -> str.find 
                       (#
                       do inx -> colon;
                          leave search;
                       #);
                       (1, colon - 1) -> str.sub -> name[];
                       (index, name[]) -> setText;
                       
                       str.length -> str.inxGet -> kind;
                       (if 'Action*' -> str.equal then
                           (index, cogwheel[]) -> setImage;
                        else
                           (if kind
                            //'/'
                            //'#' then
                               (if visibility
                                //0 then
                                   (index, publicpackageIcon[]) -> setImage;
                                //1 then
                                   (index, packageIcon[]) -> setImage;
                                //2 then
                                   (index, privatepackageIcon[]) -> setImage;
                               if);
                            //' ' then
                               (index, patternIcon[]) -> setImage;
                            //':'//'<' then
                               (index, virtualIcon[]) -> setImage;
                            //'^' then
                               (index, lightrefIcon[]) -> setImage;
                            //'@' then
                               (index, referenceIcon[]) -> setImage;
                            //'=' then
                               (index, simpleIcon[]) -> setImage;
                            //']' then
                               (index, arrayIcon[]) -> setImage;
                            else
                               name[] -> puttext;
                               ' kind: ' -> puttext;
                               kind -> put;
                               newline;
                               ' name: "' -> puttext;
                               str[] -> puttext;
                               '"' -> putline;
                           if);
                       if);
                    #);
                 #);
               reload:
                 (# width: @integer;
                    height: @integer;
                    
                 do clear;
                    asDW.enclosingObjCont.length -> append;
                    size -> (width, height);
                    asDW.enclosingObjCont.scan
                    (# w: @integer;
                    do current[] -> fixed.widthOfText -> w;
                       w + 16 + 16 -> w;
                       (inx,current[]) -> configure;
                       (if w > width then
                           w -> width;
                       if);
                    #);
                    (width, height) -> size;
                 #);
               setUpBrowser:
                 (# p: @point; 
                 enter(pred[],pinx,asDW.enclosingObjCont[])
                 do pred[] -> asDW.left[];
                    pinx + 1 -> index;
                    browser[] -> open;
                    reload;
                    true -> bindBottom;
                    (if execution[] = NONE then
                        true -> THIS(ComponentWindow).sizeToFit;
                     else
                        flexible -> THIS(ComponentWindow).sizeToFit;
                    if);
                 #);
               
               select:
                 (# path: ^intList; inx,beginPos,endPos: @integer;
                    result: ^TextEdit;
                 enter(path[],inx,beginPos,endPos)
                 do (if false then
                        'Select: ' -> puttext; inx -> putint; '['->put; 
                        path.scan(# do current -> putint; ' ' -> put #);
                        ']' -> put; ' ' -> put;
                    if);
                    (if (inx -> path.inRange) then
                        (if false then
                            inx -> path.get -> gettext -> puttext;
                            ' ' -> put; inx -> path.get -> putint; ' ' -> put;
                        if);
                        (inx -> path.get,false) -> selection.select;
                        (inx -> path.get,beginPos,endPos,false) -> display;
                        (if (asDW.right[] <> none) and (inx + 1 -> path.inRange) then
                            (inx -> path.get,beginPos,endPos,false) -> display;
                            (path[],inx + 1,beginPos,endPos) -> right.select -> result[];
                         else
                            (inx -> path.get,beginPos,endPos,true) -> display -> result[];
                        if)
                    if);
                 exit result[]
                 #);
               pred: ^displayWindow;
               right: ^Browseritems;
               index: @integer;
            #);
          rightEditor: ^textEdit;
          errorView: ^ErrorList;
          TextEdit: TextEditor
            (# aTextStyle: ^textStyle;
               open::
                 (# compW,compH,width,height: @integer;
                    
                 do this(componentWindow).size -> (compW,compH);
                    this(componentWindow).height - 20 - defaults.browserH - theBorderwidth*2 -> height;
                    this(componentWindow).width - theBorderwidth*2 -> width; 
                    (theBorderwidth, defaults.browserH + 20 + theBorderwidth) -> position;
                    (width, height) -> size;
                    &textStyle[] -> aTextStyle[]; 
                    'Courier' -> aTextStyle.name;
                    8 -> aTextStyle.size;
                    textFaces.plain -> aTextStyle.face;
                    aTextStyle[] -> contents.defaultstyle;
                    (if false then
                        'Linewidth: pixels: ' -> puttext; width -> putint;
                        ' maxChWidth: ' -> puttext; aTextStyle.maxChWidth -> putint; 
                        ' chars: ' -> puttext; width div aTextStyle.maxChWidth - 3 -> putint; newline;
                    if);
                    adjustLineWidth;
                    true -> bindBottom;
                    true -> bindRight;
                    editMenu.open
                 #);
               select:
                 (# beginPos,endPos: @integer; 
                 enter (beginPos, endPos)
                 do (beginPos, endPos) -> contents.selection.set; 
                    contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    contents.selection.scrollIntoView;
                 #);
               adjustLineWidth:
                 (# width, height: @integer;
                 do size -> (width, height);
                    width - 15 -> width;
                    width div aTextStyle.maxChWidth - 3 -> compile.lineWidth;
                    (if compile.lineWidth > 70 then
                        70 -> compile.lineWidth;
                    if);
                 #);
               asDW: @ displayWindow
                 (# size:: (# do this(textEdit).size -> (width,height) #);
                    position:: (# do this(textEdit).position -> pos #);
                    hasEditChanges:: (# do wasChanged -> value #);
                 #);

               init:< 
                 (# Tx: ^text; t: @styledText
                 enter Tx[]
                 do 
                    Tx -> T;
                    false -> realChange;
                    T[] -> contents.contents;
                    true -> realChange;
                 #);                
               setUpEditor:
                 (# left: ^displayWindow; (*items;*)
                    width,height,beginPos,endPos: @integer; 
                    P: @point;
                 enter(left[],asDW.enclosingObjCont[],beginPos,endPos)
                 do left[] -> asDW.left[];
                    asDW.left.position -> P; 
                    asDW.left.size -> (width,height);
                    open;
                    asDW.enclosingObjCont.getText -> init;
                    (* 'setUpEditor: ' -> puttext;
                     * beginPos -> putint; ' ' -> put; endPos -> putint; newline;*)
                    
                    (if (beginPos <> 0) and (endPos <> 0) then
                        (beginPos, endPos) -> select;
                    if);
                   
                    grow.bringToFront;
                 #);
               
               indent:
                 (# mark: @integer;
                    
                    buffer: ^Text;
                    
                    SIMPLE_BLOCK: (# exit 0 #);
                    STD_BLOCK: (# exit 1 #);
                    IF_BLOCK: (# exit 2 #);
                    FOR_BLOCK: (# exit 3 #);
                    
                    Array:
                      (# storage: [0] ^Text;
                         init:
                           (# size: @integer;
                           enter size
                           do size -> storage.new;
                           #);
                         length:
                           (# value: @integer;
                           do storage.range -> value;
                           exit value
                           #);
                         at:
                           (# inx: @integer;
                              value: ^Text;
                           enter inx
                           do storage[inx][] -> value[];
                           exit value[]
                           #);
                         atPut:
                           (# inx: @integer;
                              value: ^Text;
                           enter (inx, value[])
                           do value[] -> storage[inx][];
                           #);
                      #);
                    
                    starts: @Array;
                    ends: @Array;
                    actionkeys: @Array;
                    
                    prepare:
                      (# 
                      do 3 -> starts.init;
                         3 -> ends.init;
                         '(#' -> starts.storage[STD_BLOCK][]; 
                         '#)' -> ends.storage[STD_BLOCK][];
                         '(if' -> starts.storage[IF_BLOCK][];
                         'if)' -> ends.storage[IF_BLOCK][];
                         '(for' -> starts.storage[FOR_BLOCK][];
                         'for)' -> ends.storage[FOR_BLOCK][];
                         
                         3 -> actionkeys.init;
                         (1, 'enter') -> actionkeys.atPut;
                         (2, 'do') -> actionkeys.atPut;
                         (3, 'exit') -> actionkeys.atPut;
                         
                         contents.selection.start -> mark;
                         &Text[] -> buffer[];
                         contents.all -> contents.scanText
                         (#
                         do ch -> buffer.put;
                         #);
                      #);
                    find:
                      (# inx: @integer;
                         cnt: @integer;
                         ch: @char;
                         lines: @integer;
                      do (if mark > 0 then
                             mark -> inx;
                             inx -> buffer.inxGet -> ch;
                             loop:
                               (if ch <> 10 then
                                   (if ch = ')' then
                                       inx -> mark;
                                   if);
                                   inx + 1 -> inx;
                                   (if inx <= buffer.length then
                                       inx -> buffer.inxGet -> ch;
                                       restart loop;
                                   if);
                               if);
                             mark -> inx;
                             inx -> buffer.inxGet -> ch;
                             (if ch = ')' then
                                 inx - 1 -> inx;
                             if);
                             0 -> cnt;
                             loop:
                               (if cnt >= 0 then
                                   inx -> buffer.inxGet -> ch;
                                   (if ch = ')' then
                                       cnt + 1 -> cnt;
                                   if);
                                   (if ch = '(' then
                                       cnt - 1 -> cnt;
                                   if);
                                   (if ch = 10 then
                                       lines + 1 -> lines;
                                   if);
                                   inx - 1 -> inx;
                                   (if inx > 0 then
                                       restart loop;
                                   if);
                                else
                                   (if lines = 0 then
                                       0 -> cnt;
                                       restart loop;
                                   if);
                               if);
                         if);
                      exit (inx, mark)
                      #);
                    matchWord:
                      (# begin: @integer;
                         word: ^Text;
                         result: @boolean;
                      enter (begin, word[])
                      do true -> result;
                         check:
                           (for inx: word.length repeat
                                (# ch1, ch2: @char;
                                do begin + inx -> buffer.inxGet -> ch1;
                                   inx -> word.inxGet -> ch2;
                                   (if ch1 <> ch2 then
                                       false -> result;
                                       leave check;
                                   if);
                                #);
                           for);
                      exit result
                      #);
                    matchWords:
                      (# begin: @integer;
                         words: ^Array;
                         result: @integer;
                      enter (begin, words[])
                      do search:
                           (for inx: words.length repeat
                                (if (begin, words.storage[inx][]) -> matchWord then
                                    inx -> result;
                                    leave search;
                                if);
                           for);
                      exit result
                      #);
                    getColumn:
                      (# begin: @integer;
                         result: @integer;
                         ch: @integer;
                      enter begin
                      do (if begin > 0 then
                             begin -> buffer.inxGet -> ch;
                             loop:
                               (if ch <> 10 then
                                   begin - 1 -> begin;
                                   result + 1 -> result;
                                   (if begin > 0 then
                                       begin -> buffer.inxGet -> ch;
                                       restart loop;
                                   if);
                               if);
                         if);
                      exit result
                      #);
                    
                    beginningOfLine:
                      (# current: @integer;
                         begin: @integer;
                      enter current
                      do (# ch: @char;
                         do current -> begin;
                            (if begin > 0 then
                                begin -> buffer.inxGet -> ch;
                                loop:
                                  (if ch <> 10 then
                                      begin - 1 -> begin;
                                      (if begin > 0 then
                                          begin -> buffer.inxGet -> ch;
                                          restart loop;
                                      if);
                                  if);
                               
                            if);
                            begin + 1 -> begin;
                         #);
                      exit begin
                      #);
                    startOfText:
                      (# begin: @integer;
                         end: @integer;
                         ch: @char;
                      enter begin
                      do begin -> end;
                         (if end <= buffer.length then
                             end -> buffer.inxGet -> ch;
                             loop:
                               (if ch = 32 then
                                   end + 1 -> end;
                                   (if end <= buffer.length then
                                       end -> buffer.inxGet -> ch;
                                       restart loop;
                                   if);
                               if);
                         if);
                      exit end
                      #);
                    indentLine:
                      (# begin: @integer;
                         end: @integer;
                         ilevel: @integer;
                      enter (begin, end, ilevel)
                      do (# clevel: @integer;
                            delta: @integer;
                            txt: ^Text;
                            a, b: @integer;
                         do end - begin -> clevel;
                            ilevel - clevel -> delta;
                            begin - 1 -> begin;
                            contents.selection.get -> (a, b);
                            (if begin <= a then
                                a + delta -> a;
                                b + delta -> b;
                            if);
                            
                            (if delta > 0 then
                                (begin, begin) -> contents.selection.set;
                                &Text[] -> txt[];
                                (for delta repeat
                                     ' ' -> txt.put;
                                for);
                                txt[] -> contents.insert;
                             else
                                (begin, begin - delta) -> contents.selection.set;
                                contents.delete;
                            if);
                            (a, b) -> contents.selection.set;
                         #);
                      #);
                    process:
                      (# begin, end: @integer;
                         line0, line1: @integer;
                         ilevel: @integer;
                         result: @integer;
                      enter (begin, end)
                      do (begin, starts[]) -> matchWords -> result;
                         begin -> getColumn -> ilevel;
                         end -> beginningOfLine -> line0;
                         line0 -> startOfText -> line1;
                         (if result
                          //SIMPLE_BLOCK then
                             ilevel + 1 -> ilevel;
                          //STD_BLOCK then
                             (if ((line1 - 1, actionkeys[]) -> matchWords) = 0 then
                                 ilevel + 3 -> ilevel;
                             if);
                          //IF_BLOCK then
                             ilevel + 4 -> ilevel;
                          //FOR_BLOCK then
                             ilevel + 5 -> ilevel;
                         if);
                         (line0, line1, ilevel) -> indentLine;
                      #);
                 do prepare;
                    find -> process;
                 #);
               
               realChange,wasChanged: @ Boolean; 
               contentsType:: textField
                 (# eventHandler::<
                      (# onTab::
                           (# errors: ^text;
                              i, j: @integer;
                              startAdjusted, endAdjusted: @integer;
                           do asDW.left.hideErrors;
                              (if (currentSelection.save -> errors[]) <> none then
                                  'OnTab: syntax errors'->putline;
                                  errors[] -> putline;
                                  (if true then
                                      errors[] -> asDW.left.showErrors
                                   else
                                      errors[] -> handleErrors
                                  if)
                               else
                                  selection.get -> (i, j);
                                  loop: all -> scanText
                                  (# inx: @integer;
                                     count: @integer;
                                  do inx + 1 -> inx;
                                     (if ch > 32 then
                                         count + 1 -> count;
                                     if);
                                     (if inx = i then
                                         count - 1 -> startAdjusted;
                                     if);
                                     (if inx = j then
                                         count - 1 -> endAdjusted;
                                     if);
                                  #);
                                  asDW.enclosingObjCont.getText -> init;
                                  loop: all -> scanText
                                  (# inx: @integer;
                                     count: @integer;
                                  do inx + 1 -> inx;
                                     (if ch > 32 then
                                         count + 1 -> count;
                                     if);
                                     (if count = startAdjusted then
                                         inx + 1 -> i;
                                     if);
                                     (if count = endAdjusted then
                                         inx + 1 -> j;
                                     if);
                                  #);
                                  (i, j) -> selection.set;
                                  selection.scrollIntoView;
                              if);
                              false -> wasChanged;
                           #);
                         onTextChanged:: 
                           (# 
                           do (if realChange then true -> wasChanged if)
                           #);
                         onMouseDown:: 
                           (# p: @point;
                           do (if buttonState = 3 then
                                  localPosition -> p;
                                  (1,p,THIS(InterfaceObject)[]) -> editMenu.popUp
                              if)
                           #)
                      #);
                 #);
               editMenu: @menu
                 (# iCompile: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do 'Compile and doPT ' -> putline;
                                   currentSelection.save;
                                   asDW.enclosingObjCont.getText -> init
                                #)
                           #);
                         open::
                           (# 
                           do 'Compile' -> name;
                              iCompile[] -> append;
                           #);
                      #);
                    iSetBreak: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do (* 'SetBreak' -> putline ;*)
                                   contents.selection.start 
                                     -> asDW.enclosingObjCont.setBreak -> breaks.add
                                #)
                           #);
                         open::
                           (# 
                           do 'Set break' -> name; 
                              iSetBreak[] -> append;
                           #)
                      #);
                    iIndent: @MenuItem
                      (# 
                         eventHandler::
                           (#
                              onSelect::
                                (#
                                do indent;
                                #);
                           #);
                         open::
                           (#
                           do 'Indent' -> name;
                              iIndent[] -> append;
                           #);
                      #);
                    open:: (# do iCompile.open; iSetBreak.open; iIndent.open;  #);
                 #);                              
               
               handleErrors:
                 (# S: ^stream; start,end: @integer
                 enter S[]
                 do (if S[] <> none then 
                        S[] -> putline;
                        S.reset;    
                        S.getint - 1 -> start; S.getint -> end;
                        (start,end) -> contents.selection.set;
                        contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    if)
                 exit S[]
                 #);
            #);
          ErrorList0: TableView
            (# display:
                 (# errors: ^Stream;
                 enter errors[]
                 do 1 -> append;
                    (1, 'Hello, World') -> setText;
                 #);
            #);
          errorIcon: ^RichPixmap;
          patternIcon: ^RichPixmap;
          virtualIcon: ^RichPixmap;
          packageIcon: ^RichPixmap;
          publicpackageIcon: ^RichPixmap;
          privatepackageIcon: ^RichPixmap;
          simpleIcon: ^RichPixmap;
          arrayIcon: ^RichPixmap;
          referenceIcon: ^RichPixmap;
          lightrefIcon: ^RichPixmap;
          cogwheel: ^RichPixmap;
          
          ErrorList: TableView
            (# items: @Sequence
                 (# Element:: ErrorItem;
                 #);
               
               open::
                 (#
                 do items.init;
                 #);
               
               ErrorItem:
                 (# start: @integer;
                    end: @integer;
                    what: ^Text;
                    
                    description:
                      (# value: ^Text;
                      do what.copy -> value[];
                         ' (' -> value.puttext;
                         start -> value.putint;
                         ' to ' -> value.puttext;
                         end -> value.putint;
                         ')' -> value.puttext;
                      exit value[]
                      #);
                    range:
                      (#
                      exit (start, end)
                      #);
                 #);
               display:
                 (# errors: ^Stream;
                    start, end: @integer;
                    what: ^Text;
                    counter: @integer;
                    item: ^ErrorItem;
                 enter errors[]
                 do (if errors[] <> NONE then
                        errors.reset;
                        loop:
                          (if NOT errors.eos then
                              counter + 1 -> counter;
                              errors.getint - 1 -> start; errors.getint -> end;
                              errors.getline -> what[];
                              &ErrorItem[] -> item[];
                              start -> item.start;
                              end -> item.end;
                              what[] -> item.what[];
                              1 -> append;
                              (counter, item.description) -> setText;
                              (counter, errorIcon[]) -> setImage;
                              item[] -> items.append;
                              restart loop;
                          if);
                    if);
                 #);
               
               displayError:
                 (# item: @integer;
                 enter item
                 do (# selected: ^ErrorItem;
                    do item -> items.get -> selected[];
                       selected.range -> rightEditor.contents.selection.set;
                       rightEditor.contents[] -> target;
                    #);
                 #);
               
               onMouseDown::
                 (#
                 do selection.first -> displayError;
                 #);
               
               (***
               eventHandler::
                 (# onSelect::
                      (#
                      do item -> displayError;
                      #);
                #);
               ***)
            #);
          thisIndex: @integer
       #);
     
     execution: ^WorldSequenceWindow;
     placeholder: @SpaceLayout;
     
     WorldSequenceWindow: SequenceWindow
       (# showCode::
            (#
            do 'show code world' -> putline;
               caller[] -> VM.selectCode;
            #);
          browser: ^ComponentWindow;
          onClose::
            (#
            do execution.layout[] -> mainLayout.remove;
               execution.close;
               NONE -> execution[];
               placeholder[] -> mainLayout.add;
            #);
       #);
     
     theSystemEnv: ^systemenv;
     
     worldVM: theSystemEnv.betaVM
       (# 
          
          
          selectCode:
            (# caller: ^ObjDesc.Template; 
               trace: (# exit false #);
            enter caller[]
            do (# desc: ^generator.ObjectDesc;
                  descNo, lsc,beginPos,endPos: @integer;
               do (if trace then
                      'Select code:' -> puttext;  caller.myName -> puttext;
                      ','->put; caller.myDescInx -> putint; 
                      ' lsc: '->puttext; 
                      (if caller.lscTop > 0 then caller.myLsc -> putint else '?'->put; if)
                  if);
                  
                  (if caller.lscTop > 0 then (* preliminary hack *)
                      (if caller.myDescInx = compile.mainDescNo then (* do we need this *)
                          caller.myDescInx -> descNo;
                          caller.myLsc -> lsc
                       else 
                          caller.topReturn -> (descNo,lsc)
                      if);
                      (if trace then
                          ' return: ' -> puttext; descNo -> putint; ' ' -> put; lsc -> putint; 
                      if);
                      descNo -> compile.newDesc.getOD -> desc[];
                      true -> desc.doPT; (* OBS! true is needed to update charPos in desc *)
                      lsc 
                        -> desc.acp.mapBCposToCharRange 
                        -> (beginPos,endPos);
                      (if caller.myDescInx = compile.mainDescNo then 
                          caller.myDescInx -> descNo 
                       else 
                          (desc[],beginPos,endPos)
                            -> desc.father.adjustForSingularImp
                            -> (desc[],beginPos,endPos);
                          desc.descNo -> descNo
                      if);
                      (if trace then
                          ' Pos: ' -> puttext; beginpos -> putint; '-'->put; endPos -> putint; newline;
                      if);
                      (if trace then
                          ' new:descNo: ' -> puttext; descNo -> putint;
                          ' pos: ' -> puttext;
                          beginPos -> putint; ','->put; endPos -> putint;  
                          newline
                      if);
                      (caller[], descNo,&intList[], desc[], lsc) -> theBETAworld.selectDesc;
                  if);
               #);
            #);
          putCh:: (# do ch -> execution.put #);
          getCh:: (# do execution.get -> ch #);
          startEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onStart then
	           doPause;
               if);
            #);
          allocEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, isObj, isIndexed) -> execution.onAlloc then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onDo then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doExitEvent::
            (#
            do 
            #);
          rtnEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onReturn then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          
          breakEvent::
            (# path: ^intList;
               beginPos,endPos: @integer
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onBreak then
                   bcPos -> breaks.astPos -> (beginPos,endPos);
                   &intList[] -> path[];
                   (thisObj[],thisObj.myDescInx,path[],beginPos,endPos) -> theBETAworld.selectCode;
                   doPause;
               if);
            #);
          display:
            (# event: ^text;
               push,popRstack: @boolean;
               from,to: ^ObjDesc.template; off: @integer; attNM: ^text; 
               isIndexed: @boolean; inx: @integer;
               offIsZero:< (# do inner #);
               field:
                 (# 
                 do ' field: "' -> puttext; attNM[] -> puttext; 
                    (if isIndexed then
                        '[' -> put; inx -> putint; ']' -> put
                    if);
                    '"' -> put;
                    ' off: ' -> puttext; off -> putint;
                 #);
               
            enter(event[],push,from[],popRstack,to[],off,attNM[],isIndexed,inx)
            do event[] -> puttext; 
               (if push then
                   'From: "' -> puttext; from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   (if off = 0 then
                       offIsZero
                    else
                       field
                   if);
                   inner;                       
                   ' push on: "' -> puttext; to.myName -> puttext; '"' -> put;
                else
                   'Pop from: "' -> puttext;  from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   inner;
                   ' store at: "' -> puttext; to.myName -> puttext; '"' -> put;
                   (if off = 0 then
                       offIsZero
                    else
                       field
               if)if);
               newline
            #);
          vDisplay: display
            (# offIsZero::(# do ' const:' -> puttext #);
               value: @integer;               
            enter value
            do ' value: ' -> puttext; value -> putint; 
            #);
          rDisplay: display
            (# offisZero:: (# do ' this:' -> puttext #);
               refValue: ^ObjDesc.template
            enter refValue[]
            do ' ref: ' -> puttext; refValue.myName -> puttext
            #);
          getAttName:
            (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
               OD: ^generator.ObjectDesc
            enter(off,obj[],isRef,isIndexed)
            do 'xxx'-> nm[];
               obj.myDescInx -> compile.newDesc.getOD -> OD[];
               find:
                 OD.scanAllDecls
                 (# origin:: 
                      (#
                      do (if isRef and (off = this(getAttName).off) then
                             'origin' -> NM[];
                             leave find
                      if)#)
                 do (if off = currentND.off then
                        (if true
                         // not isRef and not isIndexed and currentDcl.IT.isSimple then 
                            currentND.lexemSy -> NM[];
                            leave find
                         // isRef and not isIndexed and not currentDcl.IT.isSimple then
                            currentND.lexemSy -> NM[];
                            leave find
                         // not isRef and isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                     else
                        (if isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                 if)#)
            exit NM[]
            #);
          vPushEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> execution.onVPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          vStoreEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> execution.onVStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rPushEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> execution.onRPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rStoreEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> execution.onRStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
	  suspendEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, preemptive) -> execution.onSuspend then
                   caller[] -> selectCode;
                   doPause;
               if); 
            #);
          resumeEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onResume then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          binOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onBinOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          unOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onUnOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          jmpGTevent::
            (#
            do (if (operator[], value, to[]) -> execution.onJmpGT then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          popEvent::
	    (#
            do (if (operator[], value, to[]) -> execution.onPop then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          errorEvent::
            (# mb: @MessageBox
            do '\nWorldWindow:errorEvent'->putline;
               thisObj[] -> selectCode;
               msg[] -> execution.onError;
               (if true then
                   msg.scanAll(# do ch -> execution.put #)
                else
                   msg[] -> mb.init;
               if);
               suspend
            #)
       #);
     
     breaks: @
       (# IMPs: [4] ^generator.imperative; top: @integer;
          clear: (# do 0 -> top #);
          add:
            (# imp: ^generator.imperative
            enter imp[]
            do (if (top + 1 -> top) > IMPs.range then
                   IMPs.range -> IMPS.extend
               if);
               imp[] -> IMPS[top][]
            #);
          astPos:
            (# bcPos,beginPos,endPos: @integer
            enter bcPos
            do L: (for i: top repeat
                       (if bcPos = IMPs[i].beginBCP then
                           IMPS[i].beginPos -> beginPos;
                           IMPS[i].endPos -> endPos;
                           (if false then
                               'found astPos: ' -> puttext; beginPos -> putint;
                               ',' -> put; endPos -> putint; newline;
                           if);
                           leave L
                  if)for)
            exit(beginPos,endPos)
            #);                      
       #);
     
     
     ObjCont: @ObjectContent;
     compile: ^generator;
     VM: ^ | worldVM;
     L: ^Log;
     stepCalls,callOver: @boolean;
     FN: ^text
  #);        
