ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'objectWindow';
INCLUDE 'executionPane';
INCLUDE 'sequencediagram';
INCLUDE 'log';
INCLUDE 'newAttributeBox';
INCLUDE '../miniCompiler/generator';
INCLUDE '../miniCompiler/betaVM'
INCLUDE '~beta/guienv/guienvsystemenv';
---guienvlib:attributes---
worldWindow: window 
  (# isNew: (# exit true #);
     
     defaults: @
       (# headH: (# exit 18 #);
          worldWindowW: (# exit 1420 #);
          worldWindowH: (# exit 860 #);
          componentW: (# exit 400 #);
          componentH: (# exit 800 #);
          mainBrowserW: (# exit 380 #);
          mainBrowserH: (# exit 120 #);
          browserW: (# exit 92 #); 
          browserH: (# exit 120 - 11 #); (* - 2 * borderWidth *)
          textEditW: (# exit 201 #);
          textEditH: (# exit 650 - 11 #);   
       #);
     open:: 
       (# frame: @Rectangle;
          width, height: @integer;
       do ('minienv..log',false) -> L.open; (* we may move this to main program *)
          (compile[],VM[],L[]) -> ObjCont.init;
          (compile[],ObjCont[]) -> objWs.init;
          
          screenRectangle -> frame;
          frame.size -> (width, height);
          
          (width - 20, height - 35 - 50) -> size;
          (10,35) -> position;
          popUp.open;
          (*runP.open;
          runP.hide;´*)
          'BETAworld' -> title;
          
          (if true then
              (if true then
                  'BETAworld.bet' -> prependPathToBetaWorld -> FN[];
               else
                 (* pathToWorld -> FN[];*)
                  'BETAworld.bet' -> FN.append -> FN[];
              if);
              (L[],true,none,FN[]) -> compile;
           else
              2 -> arguments -> fixExtension_bet -> FN[] -> putline;
              (* Fix the setup code to be more elegant *)
              (L[],false,none,FN[]) -> compile;
          if);
          (if false then
              'Setup: ' -> puttext; FN[] -> putline;
              'Root: ' -> puttext; compile.rootModule.name.lexemSy -> putline;
          if);
          
          theBETAworld.setup;

          (if false then
              compile.parseStdBeta -> theBETAworld.setUpBetaenv; 
              (* sets objContRoot, which is used when 
               * saving buffers. In addition BETAworld
               * is also scanned when saving
               *)
          if)
       #);
     
     objContRoot: ^objCont.handle;
     eventHandler::
       (# onAboutToClose:: (# do terminate #);
          onMouseDown::
            (# P: @point
            do (if buttonState = 3 then
                   mouse.globalPosition -> P;                  
                   popUp.enable;
                   (1,(P.H-8,P.V-30), contents) -> popUp.popUp (* HML: and why (-8,-30)? 
                                                                * the popUp should pop-up at the position of the mouse
                                                                *)
               if)
            #)
       #);     

     theBETAworld: @
       (# setUp:
            (# oneCW: (# exit true #); 
            do (compile.rootModule.name.lexemSy,compile.rootModule[],none,none)
                 -> ObjCont.handle 
                 -> objContRoot[];
               (if oneCW then        (* note index = 0 siganls the outer level *)
                   ('BETA world',1,0,objContRoot[]) -> 
                   (&ComponentWindow[] -> CWs[top+1->top][]).init
                else
                   objContRoot.scan
                   (#
                   do (if (top + 1 -> top) > CWs.range then 
                          CWs.range -> CWs.extend
                      if);
                      (current[],inx,inx,objContRoot[]) 
                        -> (&ComponentWindow[] -> CWs[top][]).init
                   #)
               if)
            #);
          setUpBetaEnv:
            (# betaLib: ^generator.node
            enter betaLib[]
            do 'Setup BETALIB' -> putline;
               ('StdBETA',betaLIB[],none,none)
                 -> ObjCont.handle 
                 -> objContRoot[];
               ('Standard BETA',2,0,objContRoot[]) -> (* note index = 0: outer level *)
               (&ComponentWindow[] -> CWs[top+1->top][]).init
            #);
          scan: 
            (# current: ^ComponentWindow; inx: @integer
            do (for i: top repeat inx + 1 -> inx; CWs[i][] -> current[]; inner for)
            #);
          selectCode:
            (# obj: ^objDesc.template; path: ^intList; 
               beginPos,endPos: @integer; objC: ^objCont.handle
            enter(obj[],path[],beginPos,endPos)
            do(* 'selectCode:'->puttext;*)
               path.up;
               L:
                 scan
                 (#
                 do 
                    (if ((obj[],path[]) -> current.selectCode -> objC[]) <> none then
                        inx -> path.add;
                        (* 'Found: ' -> puttext; inx -> putint; 
                         * ' path: ' -> puttext;
                         * path.scan(#do current -> putint; ' ' -> put #);
                         * newline;
                         *)
                        (path[],1,beginPos,endPos) -> select;
                        leave L
                    if)
                 #);
            exit objC[]
            #);
          select:
            (* select the items along path *)
            (# path: ^intList; inx,beginPos,endPos: @integer
            enter(path[],inx,beginPos,endPos)
            do (path[],inx + 1,beginPos,endPos) -> CWs[inx->path.get].select
            #);
          CWs: [3]^ComponentWindow; top: @integer
       #);

     popUp: @menu
       (# iSave: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do 'SaveAll' -> putline;
                         theBETAworld.scan(# do current.saveEditBuffers #);
                         objContRoot.saveModuleToFile
                 #)#);
               open:: (# do 'SaveAll' -> name; iSave[] -> append; #);
            #);
          iQuit: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do terminate 
                      #)
                 #);
               open:: (# do 'Quit' -> name; iQuit[] -> append #);
            #);
          open::
            (#
            do iSave.open;
               iQuit.open
            #);
       #);
     displayWindow:
       (* Super pattern for static item in ComponentWindow, Items and TextEditor  *)
       (# enclosingObjCont: ^objCont.handle;
          left,right: ^displayWindow;
          setUpBrowser:< (# do inner #);
          position:< (# pos: @point do inner exit pos #);
          size:< (# width,height: @integer do inner exit(width,height) #);
          reDisplay:< (# do inner #);
          hasEditChanges:< BooleanValue (# do inner #);
          select:< (# do inner #);
          close:< (# do inner #);
          closeEditor:< (# do inner #);
          save:< (# errors: ^text do inner exit errors[] #);
          print:< (# T: @text do inner exit T[] #)
       #);
     
     componentWindow:  subwindow
       (# init::
            (# pos,index: @integer; objC: ^ObjCont.handle
            enter(pos,index,objC[])
            do (if index = 0 then (* currently never index = 0 *)
                   1 -> thisIndex;
                   objC[] -> asDW.enclosingObjCont[];
                else
                   (* move this imp to theBETAworld.setUp
                    * and perhaps also where we say split
                    * to handle 1 or more CWs
                    *)
                   index 
                     -> thisIndex 
                     -> objC.elm 
                     -> asDW.enclosingObjCont[];
               if);
               (none,1,asDW.enclosingObjCont[]) 
                 -> (&items[] 
                 -> theItems[]).setUpBrowser;
               (5,5 + (pos-1)* 50) -> position;
            #);
          asDW: @ displayWindow
            (# size:: (# do this(componentWindow).size -> (width,height) #);
               position:: (# do this(componentWindow).position -> pos #);
               reDisplay:: (#do 'componentWindow.asDW:reDisplay:shouldNotHappen' -> putline #);
               hasEditChanges:: (# do 'componentWindow.asDW:hasEditChanges:shouldNotHappen' -> putline #);
               save:: (# do 'componentWindow.asDW:save:shouldNotHappen' -> putline #)
            #);
          open:: 
            (#
            do (defaults.componentW,defaults.componentH) -> size;
               fitToContents (* does not work *)
            #);
          openCloseButton::<
            (# eventHandler::<
                 (# onMouseUp::<
                      (# w,h: @integer
                      do (if miniSize then
                             'OpenClose:Grow'->putline;
                             (fullW,fullH) -> this(componentWindow).size
                          else
                             'OpenClose:Reduce' -> putline;
                             this(componentWindow).size -> (fullW,fullH);
                             head.size -> (w,h);
                             (50,h + this(componentWindow).borderWidth)
                               -> this(componentWindow).size;
                             w-> putint; ' ' -> put; h -> putint; newline
                         if);
                         not miniSize -> miniSize
                      #);
            #)#);

          miniSize: @ boolean;
          fullW,fullH: @integer;
          selectCode: 
            (# obj: ^objDesc.template; path: ^intList; objC: ^objCont.handle
            enter(obj[],path[])
            do (obj[],path[]) -> asDW.enclosingObjCont.selectCode -> objC[]
            exit objC[]
            #);
          select:
            (# path: ^intList; inx,beginPos,endPos: @integer
            enter(path[],inx,beginPos,endPos)
            do (path[],inx,beginPos,endPos) -> theItems.select
            #);
          Heading::<
            (# open::
                 (#
                 do headingPopUp.open
                 #);
               eventHandler::<
                 (# onMouseUp::
                      (# P: @point
                      do (if buttonState = 3 then
                             localPosition -> P;
                             (1,(P.h,P.v),this(Heading)[]) -> headingPopUp.popUp
                         if)
                      #);                       
                    onMouseEnter:: (# #);
                 #);
               headingPopUp: @menu
                 (# iSplit: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do theItems.closeRight;
                                   theItems.close;
                                   'white' -> CT.lookup 
                                     -> this(componentWindow).backgroundColor;
                                   this(componentWindow)[] -> theFather[];
                                   (600,550) -> this(ComponentWindow).size;
                                   asDW.enclosingObjCont.scan
                                   (# CW: ^ComponentWindow
                                   do &ComponentWindow[] -> CW[];
                                      this(ComponentWindow)[] -> CW.theFather[];
                                      current[] -> putline;
                                      (current[],inx,inx,asDW.enclosingObjCont[]) 
                                        -> CW.init
                                   #);
                                   this(componentWindow).setSize
                                #)
                           #);
                         open:: (# do 'Split' -> name; iSplit[] -> append #)
                      #);
                    iExe: @menuItem  (* not in use *)
                      (# eventHandler::
                           (# onSelect::
                                (# 
                                do SaveAll;
                                   &WorldExecutionPane[] -> runP[];
                                   runP.open;
                                   asDW.enclosingObjCont[] -> runP.doCompile;
                                   asDW.enclosingObjCont[] -> runP.execute (* not in use *)
                                #)
                           #);
                         open:: (# do 'xExecute' -> name; iExe[] -> append #)
                      #);
                    open::
                      (#
                      do iSplit.open;
                         (if false then (* not in use *)
                             iExe.open (* disable if not module with do-part *)
                         if)
                      #)
                 #);
            #);
          eventHandler::
            (# onMouseDown::
                 (# 
                 do trackMouse
                    (# mouseMove:: 
                         (#
                         do (h,v)-> move;
                            true -> this(SubWindow).update
                         #)
                    #)
                 #);
            #);
          S: @Scroller
            (# open::
                 (#
                 do (defaults.mainBrowserW,defaults.mainBrowserH) -> size;
                   (5,5 + (thisIndex-1)*(defaults.componentH+5)) ->  position;
                 #)
            #);
          
          theItems: ^Items; (* top Items of this(ComponentWindow) *)
          currentSelection: ^DisplayWindow; (* Current selection *)
          
          saveEditBuffers: (# do theItems.saveEditBuffers #);
          
          Items: textScrollList
            (# open::
                 (# v: @point; h: @integer;
                    aTextStyle: ^textStyle;
                    lWidth,lHeight: @integer
                 do (if asDW.left[] <> none then
                        asDW.left.position -> v;
                        v.h + 100 -> h;
                        asDW.left.size -> (lWidth,lHeight);
                        v.h + lWidth -> h
                     else 
                        borderwidth + 1 -> h;
                        defaults.browserW -> lWidth;
                        defaults.browserH -> lHeight
                    if);
                    (h,defaults.headH+borderwidth+1) -> position;  
                    (if (lWidth *pinx >  this(componentWindow).width) (* extend *)
                        or ((lWidth *pinx < this(componentWindow).width) 
                        and
                        ( lWidth *pinx > defaults.componentW)) (* shrink *) 
                        then
                        (lWidth *pinx + 30,this(componentWindow).height)
                          -> this(componentWindow).size;
                        this(componentWindow).setSize;
                        
                    if);
                    (lWidth,lHeight) -> size;
                    (* &textStyle[] -> aTextStyle[]; -- does not seem to work
                     'Courier' -> aTextStyle.name;
                     8 -> aTextStyle.size;
                     textFaces.plain -> aTextStyle.face;
                     aTextStyle[] -> style;*)
                    (* true -> bindBottom;*)
                    true -> bindLeft;
                    itemPopUp.open; 
                    asDW.enclosingObjCont.length -> append;
                 #);
               asDW: @ displayWindow
                 (* objC is an entry of the form
                  *    E = (X1,X2,... Xn)
                  * where X1, X2, ..., Xn
                  * are displayed in the item-list
                  *)
                 (# size:: (# do this(items).size -> (width,height) #);
                    position:: (# do this(items).position -> pos #);
                    thisInx: @integer;
                    thisObjCont:
                      (# objC: ^objCont.Handle
                      do thisInx -> enclosingObjCont.elm -> objC[]
                      exit objC[]
                      #);
                    reDisplay:: (# do (thisInx,0,0,true) -> display#);
                    hasEditChanges:: (# do (rightEditor[]<> none) and rightEditor.wasChanged -> value #);
                    closeEditor:: (# do none -> rightEditor[] #);
                    save::
                      (# 
                      do (if hasEditChanges then
                             'Must save: ' -> puttext; print -> putline;
                             saveEditBuffers -> errors[];
                             ((thisObjCont).enclosingModuleObj).saveModuleToFile;
                         if)                      
                      #);
                    print::
                      (# 
                      do (if thisInx > 0 then
                             (thisObjCont).entityPathFromModule -> T.puttext
                          else
                             'No selection' -> T.puttext
                         if);
                      #)
                 #);
               eventHandler::
                 (# onMouseUp::
                      (# P: @point
                      do (if selection.first > 0 then (* =0, outside numberOfItems *)
                             (if doubleClick then 
                                 (* selection.first -> gettext -> putline;
                                  * 'Edit field' -> putline;
                                  *)
                                 selection.first -> editField;
                                 LocalPosition -> P;
                                 (* 'mouse.V: ' -> puttext; P.V -> putint; 
                                  * ' mouse.H: ' -> puttext; P.H -> putint; newline;
                                  *)
                              else                             
                                 (if buttonState
                                  // 1 then 
                                     (selection.first,0,0,true) -> display
                                  // 3 then
                                     (if ((selection.first 
                                           -> asDW.thisInx 
                                           -> asDW.enclosingObjCont.elm).theEntry.kind)
                                         = '/' then
                                         itemPopUp.saveHandler[] -> itemPopUp.iSave.attach;
                                         (* Perhaps also insist on a do-part for iExe?*)
                                         itemPopUp.exeHandler[] -> itemPopUp.iExe.attach
                                     if);
                                     (if clipboard.hasText then
                                         (* And selection must be of the form
                                          * X: * P(# ... #)
                                          * where '*' may be define at pattern, part-object or module
                                          *)
                                         (if (selection.first 
                                               -> asDW.thisInx 
                                               -> asDW.enclosingObjCont.elm).theEntry.hasAttributes then
                                             itemPopUp.pasteHandler[] -> itemPopUp.iPaste.attach
                                         if)
                                     if);
                                     (1,(0,0),this(items)[]) -> itemPopUp.popUp;
                         if)if)if)
                      #)
                 #);
               editField:
                 (# no: @integer; 
                    oldCont,oldName,newName: ^text; 
                    oldKind,newKind: @char;
                    P: @point; R: @rectangle;
                    TE: @editText
                      (# open::
                           (# 
                           do this(items).style -> style;
                              borderStyles.simple -> border.style;
                              false -> border.visible;
                              (P.H + 1,P.V + R.top + 2) -> position;
                              (R.right-R.left+5,R.bottom-R.top+5) -> size; 
                              (* must add 5 to height for text cursor to be visible *)
                              no -> gettext -> oldCont[] -> contents;
                           #);
                         eventHandler::<
                           (# onKeyDown:: 
                                (# error: @boolean
                                do (* 'Key down: ' -> puttext; ch -> put; 
                                    ch -> putint; newline; ascii.nl -> putint; newline;
                                    *)
                                   (if ch = 13 (* nl on Windows?*) then
                                       (if not (contents -> oldCont.equal) then
                                           (oldCont[],contents) -> asDW.enclosingObjCont.changeAttName -> error;
                                           (if error then
                                               'Syntax error in browser item: '-> puttext;
                                               contents -> putline
                                            else
                                               (no,contents) -> setText;
                                           if)
                                       if);
                                       close
                                   if)
                                #)
                           #)
                      #)
                 enter no
                 do no - 1 -> getItemRectangle -> R;
                    this(items).position -> P;
                    TE.open
                 #);
               display:
                 (* for asDW where E = (X1,X2, ..., Xn)
                  * Xinx has been selected2
                  *)
                 (# inx,beginPos,endPos: @integer; 
                    mkTxtEditor: @boolean
                 enter(inx,beginPos,endPos,mkTxtEditor)
                 do L:
                      (# objCx: ^ObjCont.handle;
                      do (if currentSelection[] <> none then
                             (*'CurrentSelection: ' -> puttext; currentSelection.print;*)
                             (if currentSelection.save <> none then
                                 (* syntax errors in edit buffer og currentSelection *)
                                 leave L
                             if)
                         if);
                         closeRight;
                         asDW[] -> currentSelection[];
                         inx -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objCx[];
                         
                         (if objCx[] <> none then (* should never be none ! *)
                             (if pred[] <> none then (* why? *)  pred.closeEditor if);
                             &Items[] -> right[]; 
                             right.asDW[] -> asDW.right[];
                             (asDW[],index,objCx[]) -> right.setUpBrowser;
                             (if mkTxtEditor then 
                                 &textEdit[] -> rightEditor[];
                                 (asDW[],objCx[],beginPos,endPos) -> rightEditor.setUpEditor 
                         if)if)
                      #)
                 #);
               itemPopUp: @menu
                 (# iAdd: @menuItem
                      (# open:: (#do 'Add' -> name; iAdd[] -> append #);
                         eventHandler::
                           (# onSelect::
                                (# x: @newAttributeBox
                                do x.open;
                                   (if not x.isCanceled then 
                                       (if X.name.length = 0 then
                                           '*** Missing name!'-> putline
                                        else
                                           (selection.first,x.name[],x.kind,x.before) -> addItem
                                   if)if)
                                #);
                           #);
                         addItem:
                           (# inx: @integer; N,att: ^text; before: @boolean; 
                              objCx: ^ObjCont.handle
                           enter(inx,N[],kind,before)
                           do (if not before then inx + 1 -> inx if);
                              (inx,1) -> this(items).insert; (* insert before inx *)
                              
                              '*** AddItem: "' -> puttext; N[] -> puttext; ' ' ->put; kind -> put;
                              ' "*** OBS! Missing check of syntax and double declaration' -> putline;

                              ('selection',inx) -> L.TIn;
                              (inx,N[],kind)  -> asDW.enclosingObjCont.addItem -> att[];
                              (inx,att[]) -> this(items).settext;
                              (inx,false) -> selection.select;
                              closeRight;
                              inx -> asDW.enclosingObjCont.elm -> objCx[];
                              ('addItem:ObjX',objCx.theName[]) -> L.TTn;
                              ('addItem:enclosingObjCont',asDW.enclosingObjCont.theName[]) -> L.TTn;
                              &textEdit[] -> rightEditor[];
                              (asDW[],objCx[],0,0) -> rightEditor.setUpEditor;
                           #);
                      #);
                    iMove: @menuItem
                      (# eventHandler:: 
                           (# onSelect:: (* never called - has submenu *)
                                (# 
                                do 'Move' -> putline;
                                   (1,(0,0),this(items)[]) -> UD.popUp
                           #)#);
                         open:: 
                           (# 
                           do 'Move' -> name; iMove[] -> append;
                              UD.open; 
                              UD[] -> subMenu
                           #);
                         UD: @menu
                           (# iUp: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Up' -> putline; 
                                             (if 1 < (selection.first -> inx) then
                                                 inx -> gettext -> T[];
                                                 (inx, inx - 1 -> gettext) -> setText;
                                                 (inx - 1, T[]) -> setText;
                                                 (T[],inx) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Up' -> name; 
                                        iUp[] -> append; 
                                     #);
                                #);
                              iDown: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Down' -> putline; 
                                             (if (selection.first ->inx) < numberOfItems then
                                                 inx -> gettext -> T[];
                                                 (inx, inx + 1 -> gettext) -> setText;
                                                 (inx + 1 , T[]) -> setText;
                                                 (T[],inx + 1) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Down' -> name; 
                                        iDown[] -> append; 
                                     #);
                                #);
                              open:: (# do iUp.open; iDown.open #)
                           #)
                      #);      
                    iCopy: @menuItem
                      (# eventHandler::
                           (# onselect::
                                (# inx: @integer;
                                   T: ^text
                                do (if (selection.first ->inx) <= numberOfItems then
                                       'Copy: ' -> puttext;
                                       inx -> gettext -> T[]; ' '-> T.put;
                                       (selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm ).gettext -> T.append;
                                       T[] -> clipBoard.textContents
                                   if)
                                #)
                           #);
                         open::(#do 'Copy' -> name; iCopy[] -> append #)
                      #);
                    iPaste: @dynamicMenuItem
                      (# open:: (# do 'Paste'-> name; iPaste[] -> append #)
                      #);
                    pasteHandler: @menuAction
                      (# onSelect::
                           (# inx: @integer; N,T,att: ^text; K: @kind; 
                              IT: ^generator.Item; objX: ^objCont.handle;
                              dcl: ^generator.Decl
                           do 'Paste: at:' -> puttext; selection.first -> inx -> gettext -> putline;
                              clipboard.textcontents -> putline;
                              clipboard.textcontents -> compile.pDecl 
                              (# syntaxerror::(# do 'syntax error in paste buffer'-> putline #)
                              #) -> (N[],kind,IT[],dcl[]);
                              'Paste: ' -> puttext; N[] -> puttext; ' ' -> put; kind -> put; newline;
                              (if IT[] <> none then 'a'->put;
                                  IT.doPT -> T[]; 0 -> t.setpos;
                                  (if T.get = ' ' then 'b'->put;
                                      (if T.get = '@' then 'c'->put;
                                          (1,2) -> T.delete;
                                      if);
                                      '"' -> put; T[] -> putline; '"' -> put;
                                   else 'd'->put;
                                      (1,1) -> T.delete; T[] -> putline
                                  if)
                               else 'e' -> put;
                                  (if dcl[] <> none then
                                      dcl.doPT -> T[]
                                   else
                                      'pasteHandler: IT and dcl are none'->putline
                                  if)
                              if); 'f'->put;
                              selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objX[];
                              (1,N[],kind) -> objX.addItem -> att[];
                              1 -> objX.elm -> objX[];
                              T[]  -> objX.saveBuffer;
                           #)
                      #);
                    iDelete: @menuItem  
                      (# eventHandler::
                           (# onSelect:: 
                                (# inx: @integer
                                do 'Delete: ' -> puttext;
                                   selection.first -> inx;
                                   inx -> gettext -> putline;
                                   (inx -> gettext,selection.first)
                                     -> asDW.enclosingObjCont.delete;
                                   (inx,1) -> this(scrollList).delete;
                                   (if inx > 1 then inx - 1 -> inx if);
                                   (inx,false) -> selection.select;
                                   (selection.first,0,0,true) -> display
                           #)#); 
                         open:: 
                           (# do 'Delete' -> name; iDelete[] -> append; #);
                      #);
                    iSave: @dynamicMenuItem
                      (# open:: (# do 'Save' -> name; iSave[] -> append; #);
                      #);
                    saveHandler:  @menuAction
                      (# onSelect:: 
                           (# objC: ^objCont.handle; 
                           do 'saveHandler:' -> putline;
                              selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objC[];
                              saveEditBuffers;
                              objC.theName[] -> putline;
                              objC.saveModuleToFile
                           #);
                      #);
                    iExe: @dynamicMenuItem
                      (# open:: (#do 'Execute' -> name; iExe[] -> append #);
                      #);
                     exeHandler: @menuAction
                      (# onSelect:: 
                           (# objX,objX2: ^ObjCont.handle;
                              comp: ^generator.Module;
                              inx: @integer;
                              FN: ^text;
                           do SaveAll;
                              ('Do execute',index) -> L.tI;
                              
                              (asDW.enclosingObjCont.theName[], selection.first) -> L.tI;
                              selection.first -> inx -> asDW.enclosingObjCont.elm -> objX[];
                              
                              'DoExe: mainDescNo: '->puttext; compile.mainDescNo -> putint;
                              ' aMod:descNo: ' -> puttext;                               
                              objX.aMod.descNo -> putint; newline;
                              objX.modulePath -> putline;
                              ('',objX.theName[]) -> L.tTn;
                              
                              (if isNew  then
                                  &SequenceWindow[] -> sequence[];
                                  sequence.open;
                                  (410, 5) -> sequence.position;
                                  
                                  compile[] -> sequence.setCompiler;
                                  VM[] -> sequence.setVM;
                                  L[] -> sequence.setLog;
                                  objX[] -> sequence.compile -> comp[];
                                  sequence.show;
                               else
                                  &WorldExecutionPane[] -> runP[];
                                  runP.open;
                                  objX[] -> runP.doCompile -> comp[];
                                  runP.show;
                              if);
                              
                              (if comp[] <> none then
                                  (selection.first,comp[]) 
                                    -> asDW.enclosingObjCont.replace 
                                    -> objX[];
                                  (if false then
                                      'DoExe:AfterReplace: MainDescNo: '->puttext; 
                                      compile.mainDescNo -> putint; ' aMod.descNo: ' -> puttext;
                                      objX.aMod.descNo -> putint;
                                  if);
                                  inx -> asDW.enclosingObjCont.elm -> objX2[];
                                  (if false then
                                      'replacedItemA: ' -> puttext; objX2.aMod.descNo -> putint; 
                                  if);
                                  (* objX[] -> asDW.enclosingObjCont[]; *)
                                  (if asDW.left[] <> none then 
                                      asDW.left.reDisplay
                                   else
                                      '**** Cannot redisplay! ' -> putline
                                  if);
                                  inx -> asDW.enclosingObjCont.elm -> objX2[];
                                  (if false then
                                      ' replacedItemB: ' -> puttext; 
                                      objX2.aMod.descNo -> putint; newline;
                                  if);
                                  (if isNew then
                                      objX[] -> sequence.execute;
                                   else
                                      objX[] -> runP.execute;
                                  if);
                               else
                                  runP.hide
                              if)
                           #)
                      #);
                    open::
                      (#
                      do iAdd.open;
                         iCopy.open;
                         iPaste.open;
                         iMove.open;
                         iDelete.open;
                         iExe.open;
                         iSave.open;
                      #);
                 #);
               saveEditBuffers: 
                 (* Check the use of this one
                  * When called from display:currentSelection.save, 
                  * only the current buffer needs to be saved;
                  * there are no rightmost buffers that need to be saved
                  * Check othher calls - perhaps only the call above is needed 
                  * since we then always save the edit buffer
                  * Also update comments in textEditor about wasChanged,
                  * we never reselect a buffer with changed elements
                  *)
                 (# errors: ^text
                 do ('SaveEditBuffers',asDW.print) -> L.TTn;
                    (if rightEditor[] <> none then 
                        (if rightEditor.wasChanged then
                            true -> rightEditor.asDW.enclosingObjCont.wasChanged;
                            ('SaveEditBuffer',rightEditor.contents.contents) -> L.TTn;
                            rightEditor.contents.contents 
                              -> rightEditor.asDW.enclosingObjCont.saveBuffer
                              -> rightEditor.handleSyntaxErrors
                              -> errors[]
                        if);
                        (if not rightEditor.asDW.enclosingObjCont.wasChanged then
                            (* may be true from a previous selection *)
                            ('SaveEditBuffer:not changed',rightEditor.contents.contents) ->  L.TTn
                        if)
                     else 
                        (if asDW.right[] <> none then 
                            right.saveEditBuffers (* never bound ...?*)
                         else
                            (if false then
                                'No editor has been opened' -> putline;
                                asDW.enclosingObjCont.scan (# do current[] -> puttext; ' ' -> put #)
                        if)if)
                    if)
                 exit errors[]
                 #);
               closeRight: 
                 (* close all Item-panes to the right and rightEditor *)
                 (# 
                 do ('CloseRight',asDW.print) -> L.TTn;
                    (if asDW.right[] <> none then 
                        right.closeRight;
                        right.close ;
                        none -> right[]; none -> asDW.right[]
                    if);
                    (if rightEditor[] <> none then
                        (if false then
                            (if rightEditor.wasChanged 
                                  -> rightEditor.asDW.enclosingObjCont.wasChanged then
                                ('closeRight:wasChanged',rightEditor.contents.contents->tHead) -> L.TTn;
                                rightEditor.contents.contents
                                  -> rightEditor.asDW.enclosingObjCont.saveBuffer
                             else
                                ('closeRight:notChanged',rightEditor.contents.contents->tHead) -> L.TTn
                        if)if);
                        rightEditor.close
                    if);
                    none -> rightEditor[]
                 #);
               pinx: @integer; 
               setUpBrowser:
                 (# p: @point; 
                 enter(pred[],pinx,asDW.enclosingObjCont[])
                 do pred[] -> asDW.left[];
                    pinx + 1 -> index;                    
                    (*S[] -> *) open;
                    asDW.enclosingObjCont.scan(# do (inx,current[]) -> setText #);;
                    this(componentWindow).fitToContents; (* Does not seem to work? *)
                 #);
               select:
                 (# path: ^intList; inx,beginPos,endPos: @integer
                 enter(path[],inx,beginPos,endPos)
                 do (if false then
                        'Select: ' -> puttext; inx -> putint; '['->put; 
                        path.scan(# do current -> putint; ' ' -> put #);
                        ']' -> put; ' ' -> put;
                    if);
                    (if (inx -> path.inRange) then
                        (if false then
                            inx -> path.get -> gettext -> puttext;
                            ' ' -> put; inx -> path.get -> putint; ' ' -> put;
                        if);
                        (inx -> path.get,false) -> selection.select;
                        (inx -> path.get,beginPos,endPos,false) -> display;
                        (if (asDW.right[] <> none) and (inx + 1 -> path.inRange) then
                            (inx -> path.get,beginPos,endPos,false) -> display;
                            (path[],inx + 1,beginPos,endPos) -> right.select
                         else
                            (inx -> path.get,beginPos,endPos,true) -> display
                        if)
                    if);
                 #);
               pred: ^displayWindow;
               right: ^items;
               rightEditor: ^textEdit;
               index: @integer;
            #);
          
          textEdit: textEditor
            (# open::
                 (# compW,compH,width,height: @integer;
                    aTextStyle: ^textStyle
                 do this(componentWindow).size -> (compW,compH);
                    this(componentWindow).height - borderWidth * 2 - 18 - defaults.browserH -> height;
                    this(componentWindow).width - borderWidth * 2 -> width; 
                    (* 18 = width of scrollbar?*)
                    
                    (borderWidth,defaults.browserH + borderWidth + 1 + 18) -> position;
                    (width, height) -> size;
                    
                    &textStyle[] -> aTextStyle[]; 
                    'Courier' -> aTextStyle.name;
                    8 -> aTextStyle.size;
                    textFaces.plain -> aTextStyle.face;
                    aTextStyle[] -> contents.defaultstyle;
                    (if false then
                        'Linewidth: pixels: ' -> puttext; width -> putint;
                        ' maxChWidth: ' -> puttext; aTextStyle.maxChWidth -> putint; 
                        ' chars: ' -> puttext; width div aTextStyle.maxChWidth - 3 -> putint; newline;
                    if);
                    
                    width div aTextStyle.maxChWidth - 3 -> compile.lineWidth;

                    true -> bindBottom;
                    (*true -> bindLeft;*)
                    true -> bindRight;
                    editMenu.open
                 #);
               asDW: @ displayWindow
                 (# size:: (# do this(textEdit).size -> (width,height) #);
                    position:: (# do this(textEdit).position -> pos #);
                    hasEditChanges:: (# do wasChanged -> value #);
                 #);

               init:< 
                 (# Tx: ^text; t: @styledText
                 enter Tx[]
                 do open;
                    Tx -> T;
                    false -> realChange;
                    T[] -> contents.contents;
                    true -> realChange;
                 #);
               realChange,wasChanged: @ Boolean; (* if buffer is changed, then saved, another elm is selected
                                                  * and then this elm is reselected,
                                                  * then wasModified is no longer true - default is false
                                                  *)
               contentsType:: textField
                 (# eventHandler::<
                      (# onTextChanged:: 
                           (# 
                           do (if realChange then true -> wasChanged if);
                           #);
                         onMouseDown:: 
                           (# p: @point;
                           do (if buttonState = 3 then
                                  localPosition -> p;
                                  (1,p,THIS(InterfaceObject)[]) -> editMenu.popUp
                              if)
                           #)
                      #);
                 #);
               editMenu: @menu
                 (# iSetBreak: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do (* 'SetBreak' -> putline ;*)
                                   contents.selection.start 
                                     -> asDW.enclosingObjCont.setBreak -> breaks.add
                                #)
                           #);
                         open:: (# do 'Set break' -> name; iSetBreak[] -> append #)
                      #);
                    open:: (# do iSetBreak.open #);
                 #);                              
               P: @point;
               setUpEditor:
                 (# left: ^displayWindow; (*items;*)
                    width,height,beginPos,endPos: @integer; 
                 enter(left[],asDW.enclosingObjCont[],beginPos,endPos)
                 do left[] -> asDW.left[];
                    asDW.left.position -> P; 
                    asDW.left.size -> (width,height);
                    asDW.enclosingObjCont.getText -> init;
                    (* 'setUpEditor: ' -> puttext;
                     * beginPos -> putint; ' ' -> put; endPos -> putint; newline;*)
                    
                    (if (beginPos <> 0) and (endPos <> 0) then
                        (beginPos,endPos) -> contents.selection.set; 
                        contents.update; (* perhaps not needed *)
                        contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    if);
                    contents.selection.scrollIntoView;
                   (* contents.selection.contents -> putline*)
                 #);
               handleSyntaxErrors:
                 (# S: ^stream; start,end: @integer
                 enter S[]
                 do (if S[] <> none then
                        S.getint - 1 -> start; S.getint -> end;
                        (start,end) -> contents.selection.set;
                        contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    if)
                 exit S[]
                 #);
            #);
          thisIndex: @integer
       #);
     SaveAll:
       (# 
       do theBETAworld.scan(# do current.saveEditBuffers #);
          objContRoot.saveModuleToFile
       #);
     
     runP: ^WorldExecutionPane;
     sequence: ^SequenceWindow;
     WorldExecutionPane: executionPane
       (# open::<
            (#
            do hide;
               (410,5) -> position;
            #);
          callPushButton::
            (# eventHandler::
                 (# onMouseUp::
                      (#
                      do VM.reActivate;
                         (if not VM.execute.isRunning then
                             terminate
                         if)                              
                      #)
            #)#);
          callOverPushButton::<
            (# eventHandler::< 
                 (# onMouseUp:: 
                      (# 
                      do objWs.callOvers.mark;
                         false -> stepCalls;
                         true -> callOver;
                         VM.reActivate;
                         (if not VM.execute.isRunning then
                             terminate
                         if)
                      #)
            #)#);
          stepPushButton::<
            (# eventHandler::<
                 (# onMouseUp::
                      (# thisObj,caller: ^objDesc.template;
                         objC: ^objCont.handle;
                         imp: ^generator.imperative;
                         currentPos: @integer
                      do '------------------\nStep: ' -> puttext;
                         OBJWs.calls.lastCall.objW.thisObj[] -> thisObj[];
                         thisObj.myName -> puttext; 
                         ' descNo: ' -> puttext; thisObj.myDescInx -> putint; 
                         OBJWs.calls.lastCall.objW.currentPos -> currentPos; 
                         (if currentPos
                          // OBJws.positions.alloc  
                          // OBJws.positions.doPos
                          // OBJws.positions.org  then 
                             ' Pos=Alloc,doPos,org: ' -> puttext;
                             (thisObj[],&intList[],0,0) -> theBETAworld.selectCode -> objC[];
                             OBJWs.calls.currentBCpos -> objC.breakAtNextImp -> imp[];
                             (if imp[] <> none then
                                 'Next break: ' -> puttext; imp.beginBCP -> putint; newline;
                                 (thisObj.myDescInx,imp.beginBCP) -> VM.execute.break;
                                 imp[] -> breaks.add
                              else
                                 'imp is none ' -> putline;
                             if)
                          // OBJws.positions.rtnAlloc
                          // OBJws.positions.rtn  then 
                             ' Pos=rtnAlloc,rtn: ' -> puttext;
                             'caller: ' -> puttext;
                             thisObj.myDyn -> caller[];
                             (if caller[] <> none then
                                 caller.myName -> puttext; ' ' -> put;
                                 (caller[],&intList[],0,0) -> theBETAworld.selectCode -> objC[];
                                 OBJWs.calls.currentBCpos -> objC.breakAtNextImp -> imp[];
                                 (if imp[] <> none then
                                     'Next break: ' -> puttext; imp.beginBCP -> putint; newline;
                                     (caller.myDescInx,imp.beginBCP) -> VM.execute.break;
                                     imp[] -> breaks.add                                     
                                  else
                                     'No luck with caller' -> putline
                                 if)
                             if)                             
                         if);

                         true -> stepCalls;
                         false -> callOver;
                         VM.reActivate;
                         (if not VM.execute.isRunning then
                             terminate
                         if)
                      #)
                 #)
            #);
          stepOverPushButton::<
            (# eventHandler::<
                 (# onMouseUp::
                      (#
                      do 'StepOver' -> putline
                      #)
                 #)
            #);          
          skipInternalPushButton::<
            (# eventHandler::< 
                 (# onMouseUp:: 
                      (# 
                      do objWs.currentObjW.thisObj[]
                           -> objWs.skipInternals.add
                      #)
            #)#); 
          clearStacksPushButton::<
            (# eventHandler::< 
                 (# onMouseUp:: 
                      (# 
                      do 
                         objWs.calls.hideRTNs;
                         sequence.clearHistory;
                      #)
            #)#);
          continuePushButton::<
            (# eventHandler::<
                 (# onMouseUp::<
                      (#
                      do false -> stepCalls;
                         VM.reActivate;
                         (if not VM.execute.isRunning then
                             terminate;
                         if);
                      #)
                 #);
            #);
          lifelinesButton::<
            (# eventHandler::<
                 (# onMouseUp::<
                      (#
                      do 'Lifelines:'->putline;
                         objws.lifelines.show
                      #)
                 #)
               
            #);
          closePushButton::<
            (# eventHandler::< 
                 (# onMouseUp::< 
                      (# 
                      do runP.hide;
                      #)
                 #)
            #);
          terminate:
            (#
            do callButton.hide;
               callOverButton.hide;
               skipInternalButton.hide;
               stepButton.hide;
               stepOverButton.hide;
               continueButton.hide;
               keepStacksBox.hide;
               (*clearStacksButton.hide;*)
               lifelines.hide;
               RTT.close;
               (if VM.execute.isRunning then
                   VM.execute.terminate; (* set terminate boolean *)
                   VM.reActivate (* resume to terminated state *)
               if)
            #);
          init::
            (#
            do (* show; *)
            #);
          doCompile:
            (# objC: ^objCont.handle
            enter objC[]
            do init;
               '****************' -> putline;
               'MiniENV: compile' -> putline;
               objC.aMod.name.lexemSy -> putline;
               (if true then
                   (L[],true,objC.dir[],objC.aMod.inFile.name) -> compile;
                else
                   (L[],false,none,objC.aMod.inFile.name) -> compile;
               if);
               (if compile.hasErrors then none -> compile.rootModule[] if)
            exit objC.aMod[]
            #);
          execute:
            (# objC: ^objCont.handle; 
            enter objC[]
            do (objC.aMod.inFile.name,'..run') -> mkAuxName -> RTT.name;
               RTT.openWrite;               
               L[] -> OBJWs.LG[];
               '****************' -> putline; 
               'MiniENV: execute' -> putline;
               '****************' -> putline; 
               objWs.clear;
               
               S.contents.SDP[] -> objWs.seqFather[];
               true -> stepCalls;
               (if not VM.execute.isRunning then
                   (if false then
                       (compile.descs[],compile.mainDescNo,RTT[]) -> VM.execute.init;
                       VM.execute[] -> theSystemEnv.fork
                    else
                       VM.init; (* why two inits?*)
                       'Exe:aMod.descNo: ' -> puttext; objC.aMod.descNo -> putint;
                       ' mainDescNo: ' -> puttext; compile.mainDescNo -> putint; newline;
                       (if false then
                           (compile.descs[],objC.aMod.descNo,RTT[]) -> VM.execute.init;
                        else
                           (compile.descs[],compile.mainDescNo,RTT[]) -> VM.execute.init;
                       if);
                       (*(compile.descs[],compile.mainDescNo,RTT[]) -> *) VM.execute;
                   if);                   
                   (* If stepCalls is initial true, we return here from VM.execute
                    * after the first event, which is starteEvent.
                    * Execution may be resumed pushing step or continue
                    *)
                else
                   'VM is not terminated' -> putline
               if);                       
            #);
          RTT: @File
       #);
     
     theSystemEnv: ^systemenv;
     
     worldVM: theSystemEnv.betaVM
       (# selectCode:
            (# caller: ^ObjDesc.Template;
            enter caller[]
            do (# desc: ^generator.ObjectDesc;
                  beginPos, endPos: @integer;
                  path: ^IntList;
               do &IntList[] -> path[];
                  caller.myDescInx -> compile.newDesc.getOD -> desc[];
                  true -> desc.doPT;
                  (*'Select code:' -> puttext;  caller.myName -> puttext; *)
                  (if caller.lscTop > 0 then (* preliminary hack *)
                      caller.myLsc 
                        -> desc.acp.mapBCposToCharRange 
                        -> (beginPos,endPos);
                      (* ' pos: ' -> puttext;
                       beginPos -> putint; ','->put; endPos -> putint; *)
                      (caller[], path[], beginPos, endPos) -> theBETAworld.selectCode;
                   else
                      (*' lscTop=0' -> puttext;*)
               if)#);
               (*newline*)
            #);
          startEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onStart then
                   doPause;
               if);
            #);
          allocEvent::
            (#
            do (if isIndexed then
                   'AllocIndexed: ' -> puttext; thisObj.myName -> putline
               if);
               (if (caller[], thisObj[], org[], bcpos, isObj, isIndexed) -> sequence.onAlloc then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onDo then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doExitEvent::
            (#
            do 'doExit: from: ' -> puttext; caller.myName -> puttext;
               ' newStack: ' -> puttext; thisObj.myName -> puttext;
               ' newOrigin: ' -> puttext; org.myName -> puttext; (* not relevant?*)
               newline;
               caller[] -> selectCode;
               (* doPause *)
            #);
          rtnEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onReturn then
                   'rtnEvent: caller: ' -> puttext; caller.myName -> puttext;
                   ' this: ' -> puttext; thisObj.myName -> putline;
                   caller[] -> selectCode; 
                   doPause;
               if);
            #);
          
          breakEvent::
            (# path: ^intList;
               beginPos,endPos: @integer
            do  'Break: ' -> puttext; thisObj.myName -> puttext; 
               ' at: ' -> puttext; bcPos -> putint;
               ' caller: ' -> puttext;
               (if caller[] <> none then caller.myName -> puttext else 'none' -> puttext if);
               ' org: ' -> puttext;
               (if org[] <> none then org.myName -> puttext else 'none' -> puttext if);
               
               bcPos -> breaks.astPos -> (beginPos,endPos);
               ' charPos: ' -> puttext; beginPos -> putint; '-'->put; endPos -> putint; newline;
               &intList[] -> path[];
               (thisObj[],path[],beginPos,endPos) -> theBETAworld.selectCode;
               doPause
            #);
          display:
            (# event: ^text;
               push,popRstack: @boolean;
               from,to: ^ObjDesc.template; off: @integer; attNM: ^text; 
               isIndexed: @boolean; inx: @integer;
               offIsZero:< (# do inner #);
               field:
                 (# 
                 do ' field: "' -> puttext; attNM[] -> puttext; 
                    (if isIndexed then
                        '[' -> put; inx -> putint; ']' -> put
                    if);
                    '"' -> put;
                    ' off: ' -> puttext; off -> putint;
                 #);
                    
            enter(event[],push,from[],popRstack,to[],off,attNM[],isIndexed,inx)
            do event[] -> puttext; 
               (if push then
                   'From: "' -> puttext; from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   (if off = 0 then
                       offIsZero
                    else
                       field
                   if);
                   inner;                       
                   ' push on: "' -> puttext; to.myName -> puttext; '"' -> put;
                else
                   'Pop from: "' -> puttext;  from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   inner;
                   ' store at: "' -> puttext; to.myName -> puttext; '"' -> put;
                   (if off = 0 then
                       offIsZero
                    else
                       field
               if)if);
               newline
            #);
          vDisplay: display
            (# offIsZero::(# do ' const:' -> puttext #);
               value: @integer;               
            enter value
            do ' value: ' -> puttext; value -> putint; 
            #);
          rDisplay: display
            (# offisZero:: (# do ' this:' -> puttext #);
               refValue: ^ObjDesc.template
            enter refValue[]
            do ' ref: ' -> puttext; refValue.myName -> puttext
            #);
          getAttName:
            (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
               OD: ^generator.ObjectDesc
            enter(off,obj[],isRef,isIndexed)
            do 'xxx'-> nm[];
               obj.myDescInx -> compile.newDesc.getOD -> OD[];
               find:
                 OD.scanAllDecls
                 (# origin:: 
                      (#
                      do (if isRef and (off = this(getAttName).off) then
                             'origin' -> NM[];
                             leave find
                      if)#)
                 do (if off = currentND.off then
                        (if true
                         // not isRef and not isIndexed and currentDcl.IT.isSimple then 
                            currentND.lexemSy -> NM[];
                            leave find
                         // isRef and not isIndexed and not currentDcl.IT.isSimple then
                            currentND.lexemSy -> NM[];
                            leave find
                         // not isRef and isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                     else
                        (if isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                 if)#)
            exit NM[]
            #);
          vPushEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          vStoreEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rPushEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> sequence.onRPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rStoreEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> sequence.onRStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
	  suspendEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onSuspend then
                   caller[] -> selectCode;
                   doPause;
               if); 
            #);
          resumeEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onResume then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          binOpEvent::
            (#
            do (if (operator[], value, to[]) -> sequence.onBinOp then
                   suspend;
               if);
            #);
          unOpEvent::
            (#
            do 'unOpEvent ' -> puttext;
               operator[] -> putline;
               (if (operator[], value, to[]) -> sequence.onUnOp then
                   suspend;
               if);
            #);
          jmpGTevent::
            (#
            do (if (operator[], value, to[]) -> sequence.onJmpGT then
                   suspend;
               if);
            #);
          
       #);
     
     worldVMgui:  thesystemenv.betaVM
       (# startEvent::
            (#
            do ('START',thisObj.myName) -> L.tT;
               (if stepCalls then
                   (thisObj[],bcPos) -> objWs.showStart;
                   doPause 
               if)
            #);
          allocEvent::
            (# internal: @boolean;
               objW: ^objWs.objectWindow;
               beginPos,endPos: @integer
            do ('ALLOC',thisObj.myName) -> L.tT;
               (*'ALLOC:' -> puttext; thisObj.myName -> putline;*)
               (if org[]<> none then 
                   ('org',org.myId) -> L.TTn
                else
                   ('org','none') -> L.TTn
               if);
               (if stepCalls (*and isObj *) then
                   (* we should not show an Activation when it is allocated
                    * if we skip creating objW, we later get a ref is none
                    *)
                   runP.callOverButton.show;

                   true -> (caller.myDescInx -> compile.newDesc.getOD).doPT;
                   caller.myLsc 
                     -> (caller.myDescInx 
                     -> compile.newDesc.getOD).mapBCposToCharRange 
                     -> (beginPos,endPos);
                   (caller[],&intList[],beginPos,endPos) 
                     -> theBETAworld.selectCode;
                   (caller[],thisObj[],org[],bcPos,isObj) 
                     -> objWs.showAlloc 
                     -> (internal,objW[]);
                   (if isObj and not internal then 
                       doPause 
                    else 
                       ('alloc:internal',thisObj.myName) -> L.tT
                   if);
                   runP.callOverButton.hide
               if)
            #);
          doEvent::
            (# internal: @boolean; path: ^intList;
               beginPos,endPos: @integer
            do ('DO',thisObj.myName) -> L.TT;
               (*'DO:' -> puttext; thisObj.myName -> putline;*)
               (if stepCalls then 
                   runP.callOverButton.show;
                   &intList[] -> path[];
                   ('caller',caller.myId) -> L.TT;
                   ('caller:lsc',caller.myLsc) -> L.TIn;
                   true -> (caller.myDescInx -> compile.newDesc.getOD).doPT;
                   caller.myLsc 
                     -> (caller.myDescInx -> compile.newDesc.getOD).acp.mapBCposToCharRange 
                     -> (beginPos,endPos);
                   (caller[],path[],beginPos,endPos) -> theBETAworld.selectCode;
                   (caller[],thisObj[],org[],bcPos) -> objWs.showDo -> internal;
                   (if not internal then 
                       doPause
                    else 
                       ('do:internal',thisObj.myName) -> L.TT
                   if); 
                   runP.callOverButton.hide
               if)
            #);
          rtnEvent::
            (# keepStack,internal: @boolean
            do ('RTN',thisObj.myName) -> L.tT;
               (if stepCalls or callOver  then 
                   runP.keepStacksBox.state -> keepStack;
                   (if callOver then
                       (if thisObj[] -> objWs.callOvers.in then
                           true -> stepCalls;
                           false -> callOver;
                   if)if);
                   (if caller[] <> thisObj[] then
                       (if stepCalls then
                           (caller[],thisObj[],org[],bcPos) 
                             -> objWs.showRtn 
                             -> internal
                       if);
                       (if stepCalls and not internal then 
                           (if false then
                               doPause 
                           if)
                        else
                           ('rtn:intern ',thisObj.myName) -> L.tT
                       if);
                       (if not keepStack then
                           ('keepStack','false') -> L.TTn;
                           (if false then
                               objWs.calls.hideRTNs
                            else
                               (if caller[] = thisObj[] then
                                   'return to this'->putline
                                else
                                   thisObj[] -> objWs.rtnHide; 
                                   doPause
                   if)if)if)if)
               if)
            #);
          resumeEvent::
            (#
            do (caller[],thisObj[],org[],bcPos) -> objWs.showResume;
            #);
          suspendEvent::
            (#
            do (caller[],thisObj[],org[],bcPos) -> objWs.showSuspend;
               doPause
            #);
          breakEvent::
            (# path: ^intList;
               beginPos,endPos: @integer
            do 'Break: ' -> puttext; thisObj.myName -> puttext; 
               ' at: ' -> puttext; bcPos -> putint;
               ' caller: ' -> puttext;
               (if caller[] <> none then caller.myName -> puttext else 'none' -> puttext if);
               ' org: ' -> puttext;
               (if org[] <> none then org.myName -> puttext else 'none' -> puttext if);
               
               bcPos -> breaks.astPos -> (beginPos,endPos);
               ' charPos: ' -> puttext; beginPos -> putint; '-'->put; endPos -> putint; newline;
               &intList[] -> path[];
               (thisObj[],path[],beginPos,endPos) -> theBETAworld.selectCode;
               (caller[],thisObj[],org[],bcPos) -> objWs.showBreak;
               doPause
            #);
          vStoreEvent::
            (#
            do (* 'vStore: ' -> puttext; from.myName -> puttext;
               ' at: ' -> puttext; to.myName -> puttext;
               ' off : ' -> puttext; off  -> putint; newline*)
            #);
       #);

     objWs: @ objectWindowHandler
       (# showCode::
            (# path: ^intList
            do 'ShowCode: ' -> puttext; obj.myName -> puttext;
               ' ' -> put; obj.myDescInx -> putint;
               ' ' -> put; (obj.myObjDesc).descInx -> putint; newline;
               &intList[] -> path[];
               (obj[],path[],0,0) -> theBETAworld.selectCode;
               'Path: ' -> puttext;
               path.scan(#do current -> putint; ' ' -> put #);
               newline
            #)
       #);
     breaks: @
       (# IMPs: [4] ^generator.imperative; top: @integer;
          clear: (# do 0 -> top #);
          add:
            (# imp: ^generator.imperative
            enter imp[]
            do (if (top + 1 -> top) > IMPs.range then
                   IMPs.range -> IMPS.extend
               if);
               imp[] -> IMPS[top][]
            #);
          astPos:
            (# bcPos,beginPos,endPos: @integer
            enter bcPos
            do L: (for i: top repeat
                       (if bcPos = IMPs[i].beginBCP then
                           IMPS[i].beginPos -> beginPos;
                           IMPS[i].endPos -> endPos;
                           (if false then
                               'found astPos: ' -> puttext; beginPos -> putint;
                               ',' -> put; endPos -> putint; newline;
                           if);
                           leave L
                  if)for)
            exit(beginPos,endPos)
            #);                      
       #);
     
       
     ObjCont: @ObjectContent;
     compile: ^generator;
     VM: ^ | systemenv.betaVM;
     L: ^Log;
     stepCalls,callOver: @boolean;
     FN: ^text
  #);        
