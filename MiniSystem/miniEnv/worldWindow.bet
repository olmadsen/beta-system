ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'sequencediagram';
INCLUDE 'log';
INCLUDE 'newAttributeBox';
INCLUDE '../miniCompiler/generator';
INCLUDE '../miniCompiler/betaVM'
INCLUDE '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/utils/guienvadds';

---guienvlib:attributes---
worldWindow: window 
  (# defaults: @
       (# headH: (# exit 18 #);
          worldWindowW: (# exit 1420 #);
          worldWindowH: (# exit 860 #);
          componentW: (# exit 400 #);
          componentH: (# exit 800 #);
          mainBrowserW: (# exit 380 #);
          mainBrowserH: (# exit 120 #);
          browserW: (# exit 92 #); 
          browserH: (# exit 120 - 11 #); (* - 2 * borderWidth *)
          textEditW: (# exit 201 #);
          textEditH: (# exit 650 - 11 #);   
       #);
     open:: 
       (# frame: @Rectangle;
          width, height: @integer;
       do ('minienv..log',false) -> L.open; (* we may move this to main program *)
          (compile[],VM[],L[]) -> ObjCont.init;
          
          screenRectangle -> frame;
          frame.size -> (width, height);
          
          (width - 20, height - 35 - 50) -> size;
          (10,35) -> position;
          popUp.open;
          'BETAworld' -> title;
          
          'BETAworld.bet' -> prependPathToBetaWorld -> FN[];
          'BETAworld.bet' -> FN.append -> FN[];
          (L[],true,none,FN[]) -> compile;

          (if false then
              'Setup: ' -> puttext; FN[] -> putline;
              'Root: ' -> puttext; compile.rootModule.name.lexemSy -> putline;
          if);
          
          theBETAworld.setup;

          (if false then
              compile.parseStdBeta -> theBETAworld.setUpBetaenv; 
              (* sets objContRoot, which is used when 
               * saving buffers. In addition BETAworld
               * is also scanned when saving
               *)
          if)
       #);
     
     objContRoot: ^objCont.handle;
     eventHandler::
       (# onAboutToClose:: (# do terminate #);
          onMouseDown::
            (# P: @point
            do (if buttonState = 3 then
                   localPosition -> P;                  
                   popUp.enable;
                   (1,(P.H,P.V), contents) -> popUp.popUp
               if)
            #)
       #);     

     theBETAworld: @
       (# setUp:
            (# oneCW: (# exit true #); 
            do (compile.rootModule.name.lexemSy,compile.rootModule[],none,none)
                 -> ObjCont.handle 
                 -> objContRoot[];
               (if oneCW then        (* note index = 0 siganls the outer level *)
                   ('BETA world',1,0,objContRoot[]) -> 
                   (&ComponentWindow[] -> CWs[top+1->top][]).init
                else
                   objContRoot.scan
                   (#
                   do (if (top + 1 -> top) > CWs.range then 
                          CWs.range -> CWs.extend
                      if);
                      (current[],inx,inx,objContRoot[]) 
                        -> (&ComponentWindow[] -> CWs[top][]).init
                   #)
               if)
            #);
          setUpBetaEnv:
            (# betaLib: ^generator.node
            enter betaLib[]
            do 'Setup BETALIB' -> putline;
               ('StdBETA',betaLIB[],none,none)
                 -> ObjCont.handle 
                 -> objContRoot[];
               ('Standard BETA',2,0,objContRoot[]) -> (* note index = 0: outer level *)
               (&ComponentWindow[] -> CWs[top+1->top][]).init
            #);
          scan: 
            (# current: ^ComponentWindow; inx: @integer
            do (for i: top repeat inx + 1 -> inx; CWs[i][] -> current[]; inner for)
            #);
          selectCode:
            (# obj: ^objDesc.template; path: ^intList; 
               descNo,beginPos,endPos: @integer; objC: ^objCont.handle;
               trace: (#exit false #);
            enter(obj[],descNo,path[],beginPos,endPos)
            do (if trace then 'selectCode:'->puttext if);
               path.up;
               L:
                 scan
                 (#
                 do 
                    (if ((obj[],descNo,path[]) -> current.selectCode -> objC[]) <> none then
                        inx -> path.add;
                        (if trace then
                            'Found: ' -> puttext; inx -> putint; 
                            ' path: ' -> puttext;
                            path.scan(#do current -> putint; ' ' -> put #);
                            newline;
                        if);
                        (path[],1,beginPos,endPos) -> select;
                        leave L
                    if)
                 #);
            exit objC[]
            #);
          select:
            (* select the items along path *)
            (# path: ^intList; inx,beginPos,endPos: @integer
            enter(path[],inx,beginPos,endPos)
            do (path[],inx + 1,beginPos,endPos) -> CWs[inx->path.get].select
            #);
          CWs: [3]^ComponentWindow; top: @integer
       #);

     popUp: @menu
       (# iSave: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do 'SaveAll' -> putline;
                         theBETAworld.scan(# do current.saveEditBuffers #);
                         objContRoot.saveModuleToFile
                 #)#);
               open:: (# do 'SaveAll' -> name; iSave[] -> append; #);
            #);
          iQuit: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do terminate 
                      #)
                 #);
               open:: (# do 'Quit' -> name; iQuit[] -> append #);
            #);
          open::
            (#
            do iSave.open;
               iQuit.open
            #);
       #);
     displayWindow:
       (* Super pattern for static item in ComponentWindow, Items and TextEditor  *)
       (# enclosingObjCont: ^objCont.handle;
          left,right: ^displayWindow;
          setUpBrowser:< (# do inner #);
          position:< (# pos: @point do inner exit pos #);
          size:< (# width,height: @integer do inner exit(width,height) #);
          reDisplay:< (# do inner #);
          hasEditChanges:< BooleanValue (# do inner #);
          select:< (# do inner #);
          close:< (# do inner #);
          closeEditor:< (# do inner #);
          save:< (# errors: ^text do inner exit errors[] #);
          print:< (# T: @text do inner exit T[] #)
       #);
     
     componentWindow:  subwindow
       (# fixed: ^TextStyle;
          init::
            (# pos,index: @integer; objC: ^ObjCont.handle
            enter(pos,index,objC[])
            do &TextStyle[] -> fixed[];
               'Courier' -> fixed.name;
               8 -> fixed.size;
               textFaces.plain -> fixed.face;
               (if index = 0 then (* currently never index = 0 *)
                   1 -> thisIndex;
                   objC[] -> asDW.enclosingObjCont[];
                else
                   (* move this imp to theBETAworld.setUp
                    * and perhaps also where we say split
                    * to handle 1 or more CWs
                    *)
                   index 
                     -> thisIndex 
                     -> objC.elm 
                     -> asDW.enclosingObjCont[];
               if);
               scroller.open;
               scroller[] -> browser.open;
               (0, defaults.headH)
                 -> scroller.position;
               (300, defaults.browserH) -> browser.size;
               browser.size -> scroller.size;
               (NONE, 1, asDW.enclosingObjCont[])
                 -> (&items[] -> theItems[]).setUpBrowser;
               (0, 0) -> position;
               scroller.layout;
            #);
          asDW: @ displayWindow
            (# size:: (# do this(componentWindow).size -> (width,height) #);
               position:: (# do this(componentWindow).position -> pos #);
               reDisplay:: (#do 'componentWindow.asDW:reDisplay:shouldNotHappen' -> putline #);
               hasEditChanges:: (# do 'componentWindow.asDW:hasEditChanges:shouldNotHappen' -> putline #);
               save:: (# do 'componentWindow.asDW:save:shouldNotHappen' -> putline #)
            #);
          open:: 
            (# width, height: @integer;
            do THIS(Window).size -> (width, height);
               (defaults.componentW, height) -> size;
               fitToContents;
            #);
          openCloseButton::<
            (# eventHandler::<
                 (# onMouseUp::<
                      (# w,h: @integer
                      do (if miniSize then
                             'OpenClose:Grow'->putline;
                             (fullW,fullH) -> this(componentWindow).size
                          else
                             'OpenClose:Reduce' -> putline;
                             this(componentWindow).size -> (fullW,fullH);
                             head.size -> (w,h);
                             (50,h)
                               -> this(componentWindow).size;
                             w-> putint; ' ' -> put; h -> putint; newline
                         if);
                         not miniSize -> miniSize
                      #);
            #)#);

          miniSize: @ boolean;
          fullW,fullH: @integer;
          selectCode: 
            (# obj: ^objDesc.template; descNo: @integer; path: ^intList; objC: ^objCont.handle
            enter(obj[],descNo,path[])
            do (obj[],descNo,path[]) -> asDW.enclosingObjCont.selectCode -> objC[]
            exit objC[]
            #);
          select:
            (# path: ^intList; inx,beginPos,endPos: @integer
            enter(path[],inx,beginPos,endPos)
            do (path[],inx,beginPos,endPos) -> theItems.select
            #);
          Heading::<
            (# open::
                 (#
                 do headingPopUp.open
                 #);
               eventHandler::<
                 (# onMouseUp::
                      (# P: @point
                      do (if buttonState = 3 then
                             localPosition -> P;
                             (1,(P.h,P.v),this(Heading)[]) -> headingPopUp.popUp
                         if)
                      #);                       
                    onMouseEnter:: (# #);
                 #);
               headingPopUp: @menu
                 (# iSplit: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do theItems.closeRight;
                                   theItems.close;
                                   'white' -> CT.lookup 
                                     -> this(componentWindow).backgroundColor;
                                   this(componentWindow)[] -> theFather[];
                                   (600,550) -> this(ComponentWindow).size;
                                   asDW.enclosingObjCont.scan
                                   (# CW: ^ComponentWindow
                                   do &ComponentWindow[] -> CW[];
                                      this(ComponentWindow)[] -> CW.theFather[];
                                      current[] -> putline;
                                      (current[],inx,inx,asDW.enclosingObjCont[]) 
                                        -> CW.init
                                   #);
                                   this(componentWindow).setSize
                                #)
                           #);
                         open:: (# do 'Split' -> name; iSplit[] -> append #)
                      #);
                    open::
                      (#
                      do iSplit.open;
                      #)
                 #);
            #);
          eventHandler::
            (# onMouseDown::
                 (# 
                 do trackMouse
                    (# mouseMove:: 
                         (#
                         do (h,v)-> move;
                            true -> this(SubWindow).update
                         #)
                    #)
                 #);
            #);
          scroller: @Canvas
            (# count: @integer;
               visible: @boolean;
               theScrollBar: @ScrollBar
                 (# count: @integer;
                    eventHandler::
                      (# onValueChanged::
                           (#
                           do theScrollBar.value -> scroll;
                           #);
                      #);
                 #);
               scroll:
                 (# value: @integer;
                    x, y: @integer;
                 enter value
                 do browser.position -> (x, y);
                    (-value, y) -> browser.position;
                 #);
               getScroll:
                 (# x, y: @integer;
                 do browser.position -> (x, y);
                 exit -x
                 #);
               
               layout:
                 (# width, height: @integer;
                    w, h: @integer;
                    x, y: @integer;
                 do position -> (x, y);
                    THIS(SubWindow)[] -> theScrollBar.open;
                    size -> (width, height);
                    theScrollBar.size -> (w, h);
                    (width, h) -> theScrollBar.size;
                    (0, y + height - h) -> theScrollBar.position;
                    true -> theScrollBar.bindRight;
                    theScrollBar.hide;
                    true -> browser.bindBottom;
                 #);
               checkScrollValues:
                 (# page: @integer;
                    port: @integer;
                    excess: @integer;
                    h1: @integer;
                    h2: @integer;
                    h, w: @integer;
                    value: @integer;
                 do browser.size -> (page, h1);
                    scroller.size -> (port, h2);
                    theScrollBar.size -> (w, h);
                    (if page <= port then
                        (if visible then
                            theScrollBar.hide;
                            false -> visible;
                            (port, h2 + h) -> scroller.size;
                        if);
                        0 -> scroll;
                     else
                        page - port -> excess;
                        (if not visible then
                            theScrollBar.show;
                            true -> visible;
                            (port, h2 - h) -> scroller.size;
                        if);
                        excess -> theScrollBar.maxValue;
                        getScroll -> value;
                        (if value > excess then
                            excess -> scroll;
                        if);
                    if);
                 #);
               eventHandler::
                 (# onFrameChanged::
                      (#
                      do checkScrollValues;
                      #);
                 #);
            #);
          browser: @Canvas
            (# sizeToFit:
                 (# current: ^Items;
                    x, y: @integer;
                    w, h: @integer;	
                    minimum: @integer;
                    width, height: @integer;
                 do (if theItems[] <> NONE then
                        theItems[] -> current[];
                        loop:
                          (if current.right[] <> NONE then
                              current.right[] -> current[];
                              restart loop;
                          if);
                        current.position -> (x, y);
                        current.size -> (w, h);
                        size -> (width, height);
                        x + w + 1 -> width;
                        (width, height) -> size;
                    if);
                 #);
            #);
          theItems: ^Items; (* top Items of this(ComponentWindow) *)
          currentSelection: ^DisplayWindow; (* Current selection *)
          
          saveEditBuffers: (# do theItems.saveEditBuffers #);
          
          sizeToFit:
            (# current: ^Items;
               x, y: @integer;
               w, h: @integer;
               minimum: @integer;
               width, height: @integer;
            do 
               browser.sizeToFit;
               browser.size -> (w, h);
               (w, h) -> scroller.size;
               false -> scroller.bindRight;
               size -> (width, height);
               w + theBorderwidth*2 -> minimum;
               (if minimum > width then
                   (minimum, height) -> size;
                   setSize;
                else
                   (width - theBorderwidth*2, h) -> scroller.size;
               if);
               true -> scroller.bindRight;
               scroller.checkScrollValues;
            #);
          
          Items: TextScrollList
            (# open::
                 (# v: @point; h: @integer;
                    lWidth,lHeight: @integer
                 do (if asDW.left[] <> none then
                        asDW.left.position -> v;
                        asDW.left.size -> (lWidth,lHeight);
                        v.h + lWidth -> h
                     else 
                        1 -> h;
                        defaults.browserW -> lWidth;
                        defaults.browserH -> lHeight
                    if);
                    (h, 1) -> position;
                    (defaults.browserW, defaults.browserH) -> size;
                    fixed[] -> style;
                    true -> bindLeft;
                    itemPopUp.open; 
                    asDW.enclosingObjCont.length -> append;
                 #);
               asDW: @DisplayWindow
                 (* objC is an entry of the form
                  *    E = (X1,X2,... Xn)
                  * where X1, X2, ..., Xn
                  * are displayed in the item-list
                  *)
                 (# size:: (# do this(items).size -> (width,height) #);
                    position:: (# do this(items).position -> pos #);
                    thisInx: @integer;
                    thisObjCont:
                      (# objC: ^objCont.Handle
                      do thisInx -> enclosingObjCont.elm -> objC[]
                      exit objC[]
                      #);
                    reDisplay:: (# do (thisInx,0,0,true) -> display#);
                    hasEditChanges:: (# do (rightEditor[]<> none) and rightEditor.wasChanged -> value #);
                    closeEditor:: (# do none -> rightEditor[] #);
                    save::
                      (# 
                      do (if hasEditChanges then
                             'Must save: ' -> puttext; print -> putline;
                             saveEditBuffers -> errors[];
                             ((thisObjCont).enclosingModuleObj).saveModuleToFile;
                         if)                      
                      #);
                    print::
                      (# 
                      do (if thisInx > 0 then
                             (thisObjCont).entityPathFromModule -> T.puttext
                          else
                             'No selection' -> T.puttext
                         if);
                      #)
                 #);
               eventHandler::
                 (# onMouseUp::
                      (# P: @point
                      do (if selection.first > 0 then (* =0, outside numberOfItems *)
                             (if doubleClick then 
                                 (* selection.first -> gettext -> putline;
                                  * 'Edit field' -> putline;
                                  *)
                                 selection.first -> editField;
                                 LocalPosition -> P;
                                 (* 'mouse.V: ' -> puttext; P.V -> putint; 
                                  * ' mouse.H: ' -> puttext; P.H -> putint; newline;
                                  *)
                              else                             
                                 (if buttonState
                                  // 1 then 
                                     (selection.first,0,0,true) -> display
                                  // 3 then
                                     (if ((selection.first 
                                           -> asDW.thisInx 
                                           -> asDW.enclosingObjCont.elm).theEntry.kind)
                                         = '/' then
                                         itemPopUp.saveHandler[] -> itemPopUp.iSave.attach;
                                         (* Perhaps also insist on a do-part for iExe?*)
                                         itemPopUp.exeHandler[] -> itemPopUp.iExe.attach
                                     if);
                                     (if clipboard.hasText then
                                         (* And selection must be of the form
                                          * X: * P(# ... #)
                                          * where '*' may be define at pattern, part-object or module
                                          *)
                                         (if (selection.first 
                                               -> asDW.thisInx 
                                               -> asDW.enclosingObjCont.elm).theEntry.hasAttributes then
                                             itemPopUp.pasteHandler[] -> itemPopUp.iPaste.attach
                                         if)
                                     if);
                                     (1,(0,0),this(items)[]) -> itemPopUp.popUp;
                         if)if)if)
                      #)
                 #);
               editField:
                 (# no: @integer; 
                    oldCont,oldName,newName: ^text; 
                    oldKind,newKind: @char;
                    P: @point; R: @rectangle;
                    TE: @editText
                      (# open::
                           (# 
                           do this(items).style -> style;
                              borderStyles.simple -> border.style;
                              false -> border.visible;
                              (P.H + 1,P.V + R.top + 2) -> position;
                              (R.right-R.left+5,R.bottom-R.top+5) -> size; 
                              (* must add 5 to height for text cursor to be visible *)
                              no -> gettext -> oldCont[] -> contents;
                           #);
                         eventHandler::<
                           (# onKeyDown:: 
                                (# error: @boolean
                                do (* 'Key down: ' -> puttext; ch -> put; 
                                    ch -> putint; newline; ascii.nl -> putint; newline;
                                    *)
                                   (if ch = 13 (* nl on Windows?*) then
                                       (if not (contents -> oldCont.equal) then
                                           (oldCont[],contents) -> asDW.enclosingObjCont.changeAttName -> error;
                                           (if error then
                                               'Syntax error in browser item: '-> puttext;
                                               contents -> putline
                                            else
                                               (no,contents) -> setText;
                                           if)
                                       if);
                                       close
                                   if)
                                #)
                           #)
                      #)
                 enter no
                 do no - 1 -> getItemRectangle -> R;
                    this(items).position -> P;
                    browser[] -> TE.open
                 #);
               display:
                 (* for asDW where E = (X1,X2, ..., Xn)
                  * Xinx has been selected2
                  *)
                 (# inx,beginPos,endPos: @integer; 
                    mkTxtEditor: @boolean
                 enter(inx,beginPos,endPos,mkTxtEditor)
                 do L:
                      (# objCx: ^ObjCont.handle;
                      do (if currentSelection[] <> none then
                             (*'CurrentSelection: ' -> puttext; currentSelection.print;*)
                             (if currentSelection.save <> none then
                                 (* syntax errors in edit buffer og currentSelection *)
                                 leave L
                             if)
                         if);
                         closeRight;
                         asDW[] -> currentSelection[];
                         inx -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objCx[];
                         
                         (if objCx[] <> none then (* should never be none ! *)
                             (if pred[] <> none then (* why? *) pred.closeEditor if);
                             (*** items-create ***)
                             &Items[] -> right[];
                             right.asDW[] -> asDW.right[];
                             (asDW[],index,objCx[]) -> right.setUpBrowser;
                             (if mkTxtEditor then
                                 &textEdit[] -> rightEditor[];
                                 (asDW[],objCx[],beginPos,endPos) -> rightEditor.setUpEditor 
                             if);
                         if);
                      #)
                 #);
               itemPopUp: @menu
                 (# iAdd: @menuItem
                      (# open:: (#do 'Add' -> name; iAdd[] -> append #);
                         eventHandler::
                           (# onSelect::
                                (# x: @newAttributeBox
                                do x.open;
                                   (if not x.isCanceled then 
                                       (if X.name.length = 0 then
                                           '*** Missing name!'-> putline
                                        else
                                           (selection.first,x.name[],x.kind,x.before) -> addItem
                                   if)if)
                                #);
                           #);
                         addItem:
                           (# inx,kind: @integer; N,att: ^text; before: @boolean; 
                              objCx: ^ObjCont.handle
                           enter(inx,N[],kind,before)
                           do (if not before then inx + 1 -> inx if);
                              (inx,1) -> this(items).insert; (* insert before inx *)
                              
                              '*** AddItem: "' -> puttext; N[] -> puttext; ' ' ->put; kind -> put;
                              ' "*** OBS! Missing check of syntax and double declaration' -> putline;

                              ('selection',inx) -> L.TIn;
                              (inx,N[],kind)  -> asDW.enclosingObjCont.addItem -> att[];
                              (inx,att[]) -> this(items).settext;
                              (inx,false) -> selection.select;
                              closeRight;
                              (if false then
                                  inx -> asDW.enclosingObjCont.elm -> objCx[];
                                  ('addItem:ObjX',objCx.theName[]) -> L.TTn;
                              if);
                              ('addItem:enclosingObjCont',asDW.enclosingObjCont.theName[]) 
                                -> L.TTn;
                              (if true then
                                  (inx, 0,0,true) -> display
                               else
                                  &textEdit[] -> rightEditor[];
                                  (asDW[],objCx[],0,0) -> rightEditor.setUpEditor;
                              if)
                           #);
                      #);
                    iMove: @menuItem
                      (# eventHandler:: 
                           (# onSelect:: (* never called - has submenu *)
                                (# 
                                do 'Move' -> putline;
                                   (1,(0,0),this(items)[]) -> UD.popUp
                           #)#);
                         open:: 
                           (# 
                           do 'Move' -> name; iMove[] -> append;
                              UD.open; 
                              UD[] -> subMenu
                           #);
                         UD: @menu
                           (# iUp: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Up' -> putline; 
                                             (if 1 < (selection.first -> inx) then
                                                 inx -> gettext -> T[];
                                                 (inx, inx - 1 -> gettext) -> setText;
                                                 (inx - 1, T[]) -> setText;
                                                 (T[],inx) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Up' -> name; 
                                        iUp[] -> append; 
                                     #);
                                #);
                              iDown: @menuItem
                                (# eventHandler::
                                     (# onSelect:: 
                                          (# inx: @integer; T: ^text
                                          do 'Down' -> putline; 
                                             (if (selection.first ->inx) < numberOfItems then
                                                 inx -> gettext -> T[];
                                                 (inx, inx + 1 -> gettext) -> setText;
                                                 (inx + 1 , T[]) -> setText;
                                                 (T[],inx + 1) -> asDW.enclosingObjCont.moveUp;
                                             if)
                                     #)#);
                                   open:: 
                                     (# 
                                     do 'Down' -> name; 
                                        iDown[] -> append; 
                                     #);
                                #);
                              open:: (# do iUp.open; iDown.open #)
                           #)
                      #);      
                    iCopy: @menuItem
                      (# eventHandler::
                           (# onselect::
                                (# inx: @integer;
                                   T: ^text
                                do (if (selection.first ->inx) <= numberOfItems then
                                       'Copy: ' -> puttext;
                                       inx -> gettext -> T[]; ' '-> T.put;
                                       (selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm ).gettext -> T.append;
                                       T[] -> clipBoard.textContents;
                                       T[] -> putline
                                   if)
                                #)
                           #);
                         open::(#do 'Copy' -> name; iCopy[] -> append #)
                      #);
                    iPaste: @dynamicMenuItem
                      (# open:: (# do 'Paste'-> name; iPaste[] -> append #)
                      #);
                    pasteHandler: @menuAction
                      (# onSelect::
                           (# inx: @integer; N,T,att: ^text; kind: @integer;
                              IT: ^generator.Item; objX: ^objCont.handle;
                              dcl: ^generator.Decl
                           do 'Paste: at:' -> puttext; selection.first -> inx -> gettext -> putline;
                              clipboard.textcontents -> putline;
                              clipboard.textcontents 
                                -> compile.pDecl 
                              (# syntaxerror::(# do 'syntax error in paste buffer'-> putline #)
                              #) -> (N[],kind,IT[],dcl[]);
                              'Paste: ' -> puttext; N[] -> puttext; ' ' -> put; kind -> put; newline;
                              (if IT[] <> none then 'a'->put;
                                  IT.doPT -> T[]; 0 -> t.setpos;
                                  (if T.get = ' ' then 'b'->put;
                                      (if T.get = '@' then 'c'->put;
                                          (1,2) -> T.delete;
                                      if);
                                      '"' -> put; T[] -> putline; '"' -> put;
                                   else 'd'->put;
                                      (1,1) -> T.delete; T[] -> putline
                                  if)
                               else 'e' -> put;
                                  (if dcl[] <> none then
                                      dcl.doPT -> T[]
                                   else
                                      'pasteHandler: IT and dcl are none'->putline
                                  if)
                              if); 'f'->put;
                              selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objX[];
                              (1,N[],kind) -> objX.addItem -> att[];
                              1 -> objX.elm -> objX[];
                              T[]  -> objX.saveBuffer;
                           #)
                      #);
                    iDelete: @menuItem  
                      (# eventHandler::
                           (# onSelect:: 
                                (# inx: @integer
                                do 'iDelete: ' -> puttext;
                                   selection.first -> inx;
                                   inx -> gettext -> putline;
                                   (inx -> gettext,selection.first)
                                     -> asDW.enclosingObjCont.delete;
                                   (inx,1) -> this(scrollList).delete;
                                   (if inx > 1 then inx - 1 -> inx if);
                                   (inx,false) -> selection.select;
                                   (selection.first,0,0,true) -> display
                           #)#); 
                         open:: 
                           (# do 'Delete' -> name; iDelete[] -> append; #);
                      #);
                    iSave: @dynamicMenuItem
                      (# open:: (# do 'Save' -> name; iSave[] -> append; #);
                      #);
                    saveHandler:  @menuAction
                      (# onSelect:: 
                           (# objC: ^objCont.handle; 
                           do 'saveHandler:' -> putline;
                              selection.first -> asDW.thisInx -> asDW.enclosingObjCont.elm -> objC[];
                              saveEditBuffers;
                              objC.theName[] -> putline;
                              objC.saveModuleToFile
                           #);
                      #);
                    iExe: @dynamicMenuItem
                      (# open:: (#do 'Execute' -> name; iExe[] -> append #);
                      #);
                    exeHandler: @menuAction
                      (# onSelect:: 
                           (# objX,objX2: ^ObjCont.handle;
                              comp: ^generator.Module;
                              inx: @integer;
                              FN: ^text;
                           do SaveAll;
                              ('Do execute',index) -> L.tI;
                              
                              (asDW.enclosingObjCont.theName[], selection.first) -> L.TI;
                              selection.first -> inx -> asDW.enclosingObjCont.elm -> objX[];
                              
                              'DoExe: mainDescNo: ' -> puttext; compile.mainDescNo -> putint;
                              ' theModule: ' -> puttext; objX.theModule.name.lexemSy -> puttext;
                              ' descNo: ' -> puttext;                               
                              objX.theModule.descNo -> putint; newline;
                              objX.modulePath -> putline;
                              ('',objX.theName[]) -> L.tTn;
                              
                              &WorldSequenceWindow[] -> sequence[];
                              sequence.open;
                              (410, 5) -> sequence.position;
                              
                              compile[] -> sequence.setCompiler;
                              &|worldVM[] -> VM[] -> objCont.VM[] -> sequence.setVM;
                              L[] -> sequence.setLog;
                              objX[] -> sequence.compile -> comp[];
                              sequence.show;
                              
                              
                              (if comp[] <> none then
                                  (if false then
                                      'WW:'->putline;
                                      comp.doPT -> putline;
                                      
                                      (selection.first,comp[]) 
                                        -> asDW.enclosingObjCont.replace 
                                        -> objX[];
                                  if);
                                  (if false then
                                      'DoExe:AfterReplace: MainDescNo: '->puttext; 
                                      compile.mainDescNo -> putint; 
                                      ' theModule: ' -> puttext; objX.theModule.name.lexemSy->puttext;
                                      ' descNo: ' -> puttext;
                                      objX.theModule.descNo -> putint;
                                  if);
                                  inx -> asDW.enclosingObjCont.elm -> objX2[];
                                  (if false then
                                      'replacedItemA: ' -> puttext; objX2.theModule.descNo -> putint; 
                                  if);
                                  (* objX[] -> asDW.enclosingObjCont[]; *)
                                  (if false then
                                      (if asDW.left[] <> none then 
                                          asDW.left.reDisplay
                                       else
                                          '**** Cannot redisplay! ' -> putline
                                  if)if);
                                  (if false then
                                      inx -> asDW.enclosingObjCont.elm -> objX2[];
                                  if);
                                  (if false then
                                      ' replacedItemB: ' -> puttext; 
                                      objX2.theModule.descNo -> putint; newline;
                                  if);
                                  objX[] -> sequence.execute;
                              if)
                           #)
                      #);
                    open::
                      (#
                      do iAdd.open;
                         iCopy.open;
                         iPaste.open;
                         iMove.open;
                         iDelete.open;
                         iExe.open;
                         iSave.open;
                      #);
                 #);
               saveEditBuffers: 
                 (* Check the use of this one
                  * When called from display:currentSelection.save, 
                  * only the current buffer needs to be saved;
                  * there are no rightmost buffers that need to be saved
                  * Check othher calls - perhaps only the call above is needed 
                  * since we then always save the edit buffer
                  * Also update comments in textEditor about wasChanged,
                  * we never reselect a buffer with changed elements
                  *)
                 (# errors: ^text
                 do ('SaveEditBuffers',asDW.print) -> L.TTn;
                    (if rightEditor[] <> none then 
                        (if rightEditor.wasChanged then
                            true -> rightEditor.asDW.enclosingObjCont.wasChanged;
                            ('SaveEditBuffer',rightEditor.contents.contents) -> L.TTn;
                            rightEditor.contents.contents 
                              -> rightEditor.asDW.enclosingObjCont.saveBuffer
                              -> rightEditor.handleSyntaxErrors
                              -> errors[]
                        if);
                        (if not rightEditor.asDW.enclosingObjCont.wasChanged then
                            (* may be true from a previous selection *)
                            ('SaveEditBuffer:not changed',rightEditor.contents.contents) ->  L.TTn
                        if)
                     else 
                        (if asDW.right[] <> none then 
                            right.saveEditBuffers (* never bound ...?*)
                         else
                            (if false then
                                'No editor has been opened' -> putline;
                                asDW.enclosingObjCont.scan (# do current[] -> puttext; ' ' -> put #)
                        if)if)
                    if)
                 exit errors[]
                 #);
               closeRight: 
                 (* close all Item-panes to the right and rightEditor *)
                 (# 
                 do ('CloseRight',asDW.print) -> L.TTn;
                    (if asDW.right[] <> none then 
                        right.closeRight;
                        right.close ;
                        none -> right[]; none -> asDW.right[]
                    if);
                    (if rightEditor[] <> none then
                        (if false then
                            (if rightEditor.wasChanged 
                                  -> rightEditor.asDW.enclosingObjCont.wasChanged then
                                ('closeRight:wasChanged',rightEditor.contents.contents->tHead) -> L.TTn;
                                rightEditor.contents.contents
                                  -> rightEditor.asDW.enclosingObjCont.saveBuffer
                             else
                                ('closeRight:notChanged',rightEditor.contents.contents->tHead) -> L.TTn
                        if)if);
                        rightEditor.close
                    if);
                    none -> rightEditor[]
                 #);
               pinx: @integer; 
               setUpBrowser:
                 (# p: @point; 
                    width: @integer;
                    height: @integer;
                 enter(pred[],pinx,asDW.enclosingObjCont[])
                 do pred[] -> asDW.left[];
                    pinx + 1 -> index;
                    browser[] -> open;
                    size -> (width, height);
                    asDW.enclosingObjCont.scan
                    (# w: @integer;
                    do current[] -> fixed.widthOfText -> w;
                       w + 16 + 16 -> w;
                       (inx,current[]) -> setText;
                       (if w > width then
                           w -> width;
                       if);
                    #);
                    (width, height) -> size;
                    THIS(ComponentWindow).sizeToFit;
                    true -> bindBottom;
                 #);
               select:
                 (# path: ^intList; inx,beginPos,endPos: @integer
                 enter(path[],inx,beginPos,endPos)
                 do (if false then
                        'Select: ' -> puttext; inx -> putint; '['->put; 
                        path.scan(# do current -> putint; ' ' -> put #);
                        ']' -> put; ' ' -> put;
                    if);
                    (if (inx -> path.inRange) then
                        (if false then
                            inx -> path.get -> gettext -> puttext;
                            ' ' -> put; inx -> path.get -> putint; ' ' -> put;
                        if);
                        (inx -> path.get,false) -> selection.select;
                        (inx -> path.get,beginPos,endPos,false) -> display;
                        (if (asDW.right[] <> none) and (inx + 1 -> path.inRange) then
                            (inx -> path.get,beginPos,endPos,false) -> display;
                            (path[],inx + 1,beginPos,endPos) -> right.select
                         else
                            (inx -> path.get,beginPos,endPos,true) -> display
                        if)
                    if);
                 #);
               pred: ^displayWindow;
               right: ^items;
               rightEditor: ^textEdit;
               index: @integer;
            #);
          
          TextEdit: TextEditor
            (# open::
                 (# compW,compH,width,height: @integer;
                    aTextStyle: ^textStyle
                 do this(componentWindow).size -> (compW,compH);
                    this(componentWindow).height - 18 - defaults.browserH - theBorderwidth*2 -> height;
                    this(componentWindow).width - theBorderwidth*2 -> width; 
                    (0, defaults.browserH + 18) -> position;
                    (width, height) -> size;
                    &textStyle[] -> aTextStyle[]; 
                    'Courier' -> aTextStyle.name;
                    8 -> aTextStyle.size;
                    textFaces.plain -> aTextStyle.face;
                    aTextStyle[] -> contents.defaultstyle;
                    (if false then
                        'Linewidth: pixels: ' -> puttext; width -> putint;
                        ' maxChWidth: ' -> puttext; aTextStyle.maxChWidth -> putint; 
                        ' chars: ' -> puttext; width div aTextStyle.maxChWidth - 3 -> putint; newline;
                    if);
                    width div aTextStyle.maxChWidth - 3 -> compile.lineWidth;
                    true -> bindBottom;
                    true -> bindRight;
                    editMenu.open
                 #);
               asDW: @ displayWindow
                 (# size:: (# do this(textEdit).size -> (width,height) #);
                    position:: (# do this(textEdit).position -> pos #);
                    hasEditChanges:: (# do wasChanged -> value #);
                 #);

               init:< 
                 (# Tx: ^text; t: @styledText
                 enter Tx[]
                 do 
                    Tx -> T;
                    false -> realChange;
                    T[] -> contents.contents;
                    true -> realChange;
                 #);                
               setUpEditor:
                 (# left: ^displayWindow; (*items;*)
                    width,height,beginPos,endPos: @integer; 
                    P: @point;
                 enter(left[],asDW.enclosingObjCont[],beginPos,endPos)
                 do left[] -> asDW.left[];
                    asDW.left.position -> P; 
                    asDW.left.size -> (width,height);
                    open;
                    asDW.enclosingObjCont.getText -> init;
                    (* 'setUpEditor: ' -> puttext;
                     * beginPos -> putint; ' ' -> put; endPos -> putint; newline;*)
                    
                    (if (beginPos <> 0) and (endPos <> 0) then
                        (beginPos,endPos) -> contents.selection.set; 
                        contents.update; (* perhaps not needed *)
                        contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    if);
                    contents.selection.scrollIntoView;
                 #);           
               realChange,wasChanged: @ Boolean; (* if buffer is changed, then saved, another elm is selected
                                                  * and then this elm is reselected,
                                                  * then wasModified is no longer true - default is false
                                                  *)
               contentsType:: textField
                 (# eventHandler::<
                      (# onTab::
                           (#
                           do 'ON-TAB' -> putline;
                              currentSelection.save;
                              asDW.enclosingObjCont.getText -> init
                           #);
                         onTextChanged:: 
                           (# 
                           do (if realChange then 
                                  true -> wasChanged;
                              if);
                           #);
                         onMouseDown:: 
                           (# p: @point;
                           do (if buttonState = 3 then
                                  localPosition -> p;
                                  (1,p,THIS(InterfaceObject)[]) -> editMenu.popUp
                              if)
                           #)
                      #);
                 #);
               editMenu: @menu
                 (# iCompile: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do 'Compile and doPT ' -> putline;
                                   currentSelection.save;
                                   asDW.enclosingObjCont.getText -> init
                                #)
                           #);
                         open::
                           (# 
                           do 'Compile' -> name;
                              iCompile[] -> append;
                           #);
                      #);
                    iSetBreak: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do (* 'SetBreak' -> putline ;*)
                                   contents.selection.start 
                                     -> asDW.enclosingObjCont.setBreak -> breaks.add
                                #)
                           #);
                         open::
                           (# 
                           do 'Set break' -> name; 
                              iSetBreak[] -> append;
                           #)
                      #);
                    open:: (# do iCompile.open; iSetBreak.open #);
                 #);                              
               
               handleSyntaxErrors:
                 (# S: ^stream; start,end: @integer
                 enter S[]
                 do 'handleSyntaxErrors: '->puttext;
                    (if S[] <> none then S[] -> putline;
                        S.getint - 1 -> start; S.getint -> end;
                        (start,end) -> contents.selection.set;
                        contents[] -> THIS(Window).target; (* needed to high-light selection *)
                    if)
                 exit S[]
                 #);
            #);
          thisIndex: @integer
       #);
     SaveAll:
       (# 
       do theBETAworld.scan(# do current.saveEditBuffers #);
          objContRoot.saveModuleToFile
       #);
     
     sequence: ^SequenceWindow;
     WorldSequenceWindow: SequenceWindow
       (# onClose::
            (#
            do sequence.close;
               NONE -> sequence[];
            #);
       #);
     
     theSystemEnv: ^systemenv;
     
     worldVM: theSystemEnv.betaVM
       (# selectCode:
            (# caller: ^ObjDesc.Template; 
               descNo: @integer;
               trace: (# exit false #);
            enter caller[]
            do (# desc: ^generator.ObjectDesc;
                  beginPos, endPos: @integer;
                  path: ^IntList;
               do &IntList[] -> path[];                                   
                  (if trace then
                      'Select code:' -> puttext;  caller.myName -> puttext;
                      ','->put; caller.myDescInx -> putint; 
                      ' lsc: '->puttext; caller.myLsc -> putint;
                  if);
                  (if caller.lscTop > 0 then (* preliminary hack *)
                      caller.myDescInx -> compile.newDesc.getOD -> desc[];
                      true -> desc.doPT ; (* OBS! true is needed to update charPos in desc *)
                      caller.myLsc 
                        -> desc.acp.mapBCposToCharRange 
                        -> (beginPos,endPos);
                      (if caller.myDescInx = compile.mainDescNo then 
                          caller.myDescInx -> descNo 
                       else 
                          (desc[],beginPos,endPos)
                            -> desc.father.adjustForSingularImp
                            -> (desc[],beginPos,endPos);
                          desc.descNo -> descNo
                      if);
                      (if trace then
                          ' new:descNo: ' -> puttext; descNo -> putint;
                          ' pos: ' -> puttext;
                          beginPos -> putint; ','->put; endPos -> putint;  
                          newline
                      if);
                      (caller[], descNo,path[], beginPos, endPos) -> theBETAworld.selectCode;
               if)#);
            #);
          startEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onStart then
                   doPause;
               if);
            #);
          allocEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, isObj, isIndexed) -> sequence.onAlloc then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onDo then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          doExitEvent::
            (#
            do 
            #);
          rtnEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onReturn then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          
          breakEvent::
            (# path: ^intList;
               beginPos,endPos: @integer
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onBreak then
                   bcPos -> breaks.astPos -> (beginPos,endPos);
                   &intList[] -> path[];
                   (thisObj[],thisObj.myDescInx,path[],beginPos,endPos) -> theBETAworld.selectCode;
                   doPause;
               if);
            #);
          display:
            (# event: ^text;
               push,popRstack: @boolean;
               from,to: ^ObjDesc.template; off: @integer; attNM: ^text; 
               isIndexed: @boolean; inx: @integer;
               offIsZero:< (# do inner #);
               field:
                 (# 
                 do ' field: "' -> puttext; attNM[] -> puttext; 
                    (if isIndexed then
                        '[' -> put; inx -> putint; ']' -> put
                    if);
                    '"' -> put;
                    ' off: ' -> puttext; off -> putint;
                 #);
               
            enter(event[],push,from[],popRstack,to[],off,attNM[],isIndexed,inx)
            do event[] -> puttext; 
               (if push then
                   'From: "' -> puttext; from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   (if off = 0 then
                       offIsZero
                    else
                       field
                   if);
                   inner;                       
                   ' push on: "' -> puttext; to.myName -> puttext; '"' -> put;
                else
                   'Pop from: "' -> puttext;  from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   inner;
                   ' store at: "' -> puttext; to.myName -> puttext; '"' -> put;
                   (if off = 0 then
                       offIsZero
                    else
                       field
               if)if);
               newline
            #);
          vDisplay: display
            (# offIsZero::(# do ' const:' -> puttext #);
               value: @integer;               
            enter value
            do ' value: ' -> puttext; value -> putint; 
            #);
          rDisplay: display
            (# offisZero:: (# do ' this:' -> puttext #);
               refValue: ^ObjDesc.template
            enter refValue[]
            do ' ref: ' -> puttext; refValue.myName -> puttext
            #);
          getAttName:
            (# obj: ^ObjDesc.template; off: @integer; isRef,isIndexed: @boolean; NM: ^text;
               OD: ^generator.ObjectDesc
            enter(off,obj[],isRef,isIndexed)
            do 'xxx'-> nm[];
               obj.myDescInx -> compile.newDesc.getOD -> OD[];
               find:
                 OD.scanAllDecls
                 (# origin:: 
                      (#
                      do (if isRef and (off = this(getAttName).off) then
                             'origin' -> NM[];
                             leave find
                      if)#)
                 do (if off = currentND.off then
                        (if true
                         // not isRef and not isIndexed and currentDcl.IT.isSimple then 
                            currentND.lexemSy -> NM[];
                            leave find
                         // isRef and not isIndexed and not currentDcl.IT.isSimple then
                            currentND.lexemSy -> NM[];
                            leave find
                         // not isRef and isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                     else
                        (if isIndexed and currentDcl.IT.isIndexed then
                            currentND.lexemSy -> NM[];
                            leave find
                        if)
                 if)#)
            exit NM[]
            #);
          vPushEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          vStoreEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) -> sequence.onVStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rPushEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> sequence.onRPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rStoreEvent::
            (#
            do (if (from[], popRstack, to[], off, refValue[]) -> sequence.onRStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
	  suspendEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onSuspend then
                   caller[] -> selectCode;
                   doPause;
               if); 
            #);
          resumeEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos) -> sequence.onResume then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          binOpEvent::
            (#
            do (if (operator[], value, to[]) -> sequence.onBinOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          unOpEvent::
            (#
            do (if (operator[], value, to[]) -> sequence.onUnOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          jmpGTevent::
            (#
            do (if (operator[], value, to[]) -> sequence.onJmpGT then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          popEvent::
	    (#
            do (if (operator[], value, to[]) -> sequence.onPop then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
       #);
     
     breaks: @
       (# IMPs: [4] ^generator.imperative; top: @integer;
          clear: (# do 0 -> top #);
          add:
            (# imp: ^generator.imperative
            enter imp[]
            do (if (top + 1 -> top) > IMPs.range then
                   IMPs.range -> IMPS.extend
               if);
               imp[] -> IMPS[top][]
            #);
          astPos:
            (# bcPos,beginPos,endPos: @integer
            enter bcPos
            do L: (for i: top repeat
                       (if bcPos = IMPs[i].beginBCP then
                           IMPS[i].beginPos -> beginPos;
                           IMPS[i].endPos -> endPos;
                           (if false then
                               'found astPos: ' -> puttext; beginPos -> putint;
                               ',' -> put; endPos -> putint; newline;
                           if);
                           leave L
                  if)for)
            exit(beginPos,endPos)
            #);                      
       #);
     
     
     ObjCont: @ObjectContent;
     compile: ^generator;
     VM: ^ | systemenv.betaVM;
     L: ^Log;
     stepCalls,callOver: @boolean;
     FN: ^text
  #);        
