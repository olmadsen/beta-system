ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';
INCLUDE '~beta/guienv/utils/prompts';
INCLUDE 'tableview';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'sequencediagram';
INCLUDE 'newAttributeBox';
INCLUDE 'prompt';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE '../VM/betaVM';
INCLUDE '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/utils/guienvadds';
INCLUDE 'auxiliary';
INCLUDE 'superWorld';
---guienvlib:attributes---
(* Structure of World
   World: SuperWorld
      popUp: @menu -- in Window: New Browser, Save all, Quit
      
      TopLevelWindow: Window
         MenuBarType:: -- in menu bar 
         ...
      StandaloneWindow: TopLevelWindow ...
      WorldWindow: TopLevelWindow ...
         displayWindow:
            ...
         ComponentWindow: SubWindow
            ...
            setContent: ...
            selectCode: ...
            selectDesc: ...
            select: ...
            asDW: @displayWindow ...
                ...
            browser: @Canvas ...
            theItems: ^BrowserItems;
            currentSelection: ^DisplayWindow;
            browserItems: TableView ...
               asDW: @displayWindow ...
               setUpBrowser: ...
            rightEditor: ^textEdit;
            TextEdit: TextEditor ...
         mainBrowser: ^ComponentWindow
    breaks: @ ...     
    createExecution:< ...
    createStandAloneExecution:< ...
 *)
World: SuperWorld
  (# 
     scan:
       (# current: ^WorldWindow.ComponentWindow;
       do theWorldWindow.components.scan
          (#
          do current[] -> THIS(Scan).current[];
             INNER scan;
          #);
       #);
     selectDesc:
       (# trace: (#exit false #);
          obj: ^objDesc.RunTimeObject;
          path: ^intList;
          descNo: @integer;
          desc: ^Tree.TopNode; 
          lsc: @integer;
          objC: ^objCont.handle;
       enter (obj[], descNo, path[], desc[], lsc)
       do (if trace then
              '\n**** World:SelectDesc:' -> puttext; descNo -> putint;  
              ' lsc:' -> puttext; lsc-> putint; newline;
          if);
          path.up;
          L: scan
            (#
            do (if ((obj[], descNo, path[]) -> current.selectCode -> objC[]) 
                   <> none then
                   (if trace then
                       '**** Found objC\npath:' -> puttext;
                       path.print;
                   if);
                   (path[], 2, desc[],lsc) -> current.selectDesc; (* not this(selectDesc) *)
                   leave L;
               if);
            #);
          (*newline*)
       exit objC[]
       #);
     selectCode:
       (# obj: ^objDesc.RunTimeObject; 
          path: ^intList; 
          descNo, beginPos, endPos: @integer;
          objC: ^objCont.handle;
       enter (obj[], descNo, path[], beginPos, endPos)
       do (if false then
              '\n**** World:selectCode: ' -> puttext; descNo -> putint; newline;
          if);
          path.up;
          L: scan
            (#
            do obj.myName -> putline;
               (if ((obj[], descNo, path[]) -> current.selectCode -> objC[]) 
                   <> none then
                   (path[], 2, beginPos, endPos) -> current.select;
                   leave L;
               if);
            #);
       exit objC[]
       #);
     popUp: @menu
       (# iNew: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# newWorldWindow: ^WorldWindow;
                      do &WorldWindow[] -> newWorldWindow[];
                         newWorldWindow.open;
                      #);
                 #);
               open:: (# do 'New Browser' -> name; iNew[] -> append; #);
            #);
          iSave: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do 'SAVE ALL' -> putline;
                         THIS(World).scan 
                         (# 
                         do current.saveEditBuffers 
                         #);
                         objContRoot.saveModuleToFile
                 #)#);
               open:: (# do 'Save All' -> name; iSave[] -> append; #);
            #);
          iQuit: @menuItem
            (# eventHandler::
                 (# onSelect:: 
                      (# 
                      do terminate 
                      #)
                 #);
               open:: (# do 'Quit' -> name; iQuit[] -> append #);
            #);
          open::
            (#
            do iNew.open;
               iSave.open;
               iQuit.open
            #);
       #);
     
     TopLevelWindow: Window
       (# full: @boolean;
          layoutflag: @boolean;
          mainLayout: @HorizontalLayoutManager
            (# changed::
                 (#
                 do true -> layoutFlag;
                 #);
            #);
          updater: @Timer
            (# action::
                 (#
                 do (if layoutFlag then
                        false -> layoutFlag;
                        mainLayout.layout;
                    if);
                 #);
            #);
          onTest:< (# do INNER #);          
          menuBarType::
            (# theFileMenu: @menu
                 (# iNew: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# newWorldWindow: ^WorldWindow;
                                do &WorldWindow[] -> newWorldWindow[];
                                   newWorldWindow.open;
                                #);
                           #);
                         open:: (#do 'New Browser' -> name; iNew[] -> append #);
                      #);
                    iSave: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do 'SaveAll' -> putline;
                                   THIS(World).scan 
                                   (# 
                                   do current.saveEditBuffers 
                                   #);
                                   objContRoot.saveModuleToFile
                           #)#);
                         open:: (# do 'Save All' -> name; iSave[] -> append; #);
                      #);
                    iView: @menuItem
                      (* Toggle if browser and debugger is in same
                       * or seperate windows *)
                      (# eventHandler::
                           (# onStatus::
                                (#
                                do '**** iView:onStatus:' -> puttext;
                                   embedded -> putBoolean; newline;
                                   embedded -> checked; (* true:set checkmark *)
                                   (execution[] = NONE) -> value; (* enabled? *)
                                #);
                              onSelect::
                                (#
                                do not embedded -> embedded;
                                   embedded -> theWorldWindow.changeFull;
                                #);
                           #);
                         open::
                           (#
                           do 'Unified View' -> name;
                              iView[] -> append;
                           #);
                      #);
                    iTest: @menuItem
                      (# eventHandler::
                           (# onSelect::
                                (#
                                do onTest;
                                #);
                           #);
                         open::
                           (#
                           do 'Test' -> name;
                              iTest[] -> append;
                           #);
                      #);
                    iQuit: @menuItem
                      (# eventHandler::
                           (# onSelect:: 
                                (# 
                                do terminate 
                                #)
                           #);
                         open:: (# do 'Quit' -> name; iQuit[] -> append #);
                      #);
                    open::
                      (#
                      do 'File' -> name;
                         iNew.open;
                         iSave.open;
                         iView.open;
                         iTest.open;
                         iQuit.open
                      #);
                 #);
               open::
                 (#
                 do theFileMenu.open;
                    theFileMenu[] -> append;
                 #);
            #);          
          open::<
            (# frame: @Rectangle;
               width, height: @integer;
              
            enter full
            do '**** topLevelWindow:full: ' -> puttext; full -> putBoolean; 
               newline;
               (if full then
                   screenRectangle -> frame;
                   frame.size -> (width, height);
                   (width - 20, height - 35 - 50) -> size;
                else
                   (800, 600) -> size;
               if);               
               
               (10,35) -> position;
               mainLayout.init;
               THIS(Window).size -> mainLayout.size;
              
               100 -> updater.start;
               INNER;
            #);
          close::<
            (#
            do updater.stop;
               INNER;
            #);
          eventHandler::
            (# onMouseDown::
                 (# P: @point
                 do (if buttonState = 3 then
                        localPosition -> P;
                        popUp.enable;
                        (1,(P.H,P.V), contents) -> popUp.popUp;
                    if);
                 #);
            #);
       #);
     
     StandaloneWindow: TopLevelWindow
       (# StandaloneSequenceWindow: SequenceWindow
            (# eventHandler::
                 (# onFatherFrameChanged::
                      (#
                      do THIS(StandaloneWindow).size -> mainLayout.size;
                         mainLayout.layout;
                      #);
                 #);
            #)         
       #);
     WorldWindow: TopLevelWindow
       (# (* What does 'full' stand for and what does changeFull actually do?
           * The call from selection of Unified view below (iView):
           *    embedded -> theWorldWindow.changeFull
           * indicate that full = embedded !?
           * See alos comment at open below
           *)
          changeFull:
            (# value: @boolean;
            enter value
            do (if value <> full then
                   value -> full;
                   (if full then
                       (# width, height: @integer;
                          frame: @Rectangle;
                       do placeholder[] -> mainLayout.add;
                          screenRectangle -> frame;
                          frame.size -> (width, height);
                          (10,35) -> position;
                          (width - 20, height - 35 - 50) -> size;
                          480 -> leftLayout.width;
                       #);
                    else
                       (# width, height: @integer;
                       do THIS(Window).size -> (width, height);
                          leftLayout.width -> width;
                          (width, height) -> THIS(Window).size;
                          placeholder[] -> mainLayout.remove;
                       #);
                   if);
                   mainLayout.layout;
               if);
            #);
          open:: 
            (# inx: @integer
            enter inx
            do (* Next  two booleans control experiment with browser *)
               true -> splitToSeparateWindows;
               true -> objCont.onlyModulesAndPatterns; (*more general solution needed*)
               'BETAworld' -> title;
               leftLayout.init;
               leftLayout[] -> mainLayout.add;
               (if full then
                   (* We come here when initial WorldWindow is created
                    * Full is an enter arg of open - intial call in worldVM
                    * where embedded = true
                    *     (embedded,0) -> theWorldWindow.open;
                    *)
                   placeholder[] -> mainLayout.add;
                else
                   (* We come here when 'split' is selected - 
                    * i.e. a WorldWindow is made for each first-level item *)
                   mainLayout.layout;
               if);
               
               inx -> combine; (* Create a browser for entry no. 'inx' *)
               (if not full then
                   mainLayout.layout;
               if);
            #);
          
          leftLayout: @VerticalLayoutManager;
          components: @Sequence
            (# element:: ComponentWindow;
            #);
          
          addByIndex:
            (# inx: @integer;
               objC: ^objCont.Handle;
               name: ^Text;
               width, height: @integer;
               component: ^ComponentWindow;
               root: @boolean;
               trace: (# exit false #);
            enter inx
            do (if inx = 0 then
                   'BETA world' -> name[];
                   true -> root;
                   1 -> inx;
                   objContRoot[] -> objC[];
                else
                   objContRoot.dclNames[inx][] -> name[];
                   false -> root;
                   inx -> objContRoot.elm -> objC[];
               if);
               (if trace then
                   '\*** split:'->puttext; inx -> putint; newline;
               if);
               &ComponentWindow[] -> component[];
               (NONE, name[], root, inx, objC[]) -> component.open;
               component.size -> (width, height);
               (width, height / 5) -> component.size;
               component.layout[] -> leftLayout.add;
               component[] -> components.append;
            exit component[]
            #);
          closeAll:
            (#
            do components.scan
               (#
               do current.layout[] -> leftLayout.remove;
                  current.close;
               #);
               components.clear;
            #);
          initialLayout:
            (#
            do THIS(Window).size -> leftLayout.size;
               480 -> leftLayout.width;
               leftLayout.layout;
            #);
          combine:
            (# inx: @integer
            enter inx
            do closeAll;
               inx -> addByIndex -> mainBrowser[];
               initialLayout;
            #);
          split:
            (# W: ^WorldWindow
            do closeAll;
               (for inx: objContRoot.dclNames.range repeat
                    &WorldWindow[] -> W[];
                    (false,inx) -> W.open;
                    (*inx -> addByIndex;*)
               for);
               initialLayout;
            #);
          newBrowser:
            (# component: ^ComponentWindow;
            do 0 -> addByIndex -> component[];
               component.layout[] -> leftLayout.layout;
            #);
          
          displayWindow:
            (* Super pattern for static item in ComponentWindow, 
             * Items and TextEditor  *)
            (# enclosingObjCont: ^objCont.handle;
               left,right: ^displayWindow;
               setUpBrowser:< (* not used? *)(# do inner #);
               position:< (# pos: @point do inner exit pos #);
               size:< (# width,height: @integer do inner exit(width,height) #);
               reDisplay:< (# do inner #);
               hasEditChanges:< BooleanValue (# do inner #);
               select:< (# do inner #);
               showErrors:< 
                 (# errors: ^stream enter errors[] 
                 do 'SE:' -> putline; errors[] -> putline; inner 
                 #);
               hideErrors:< (# do INNER #);
               close:< (# do inner #);
               closeEditor:< (# do inner #);
               save:<
                 (# editing: @boolean;
                    errors: ^text;
                 enter editing
                 do INNER;
                 exit errors[]
                 #);
               print:< (# T: @text do inner exit T[] #);
               description:<
                 (# value: ^Text;
                 do 'UNK' -> value[];
                    INNER;
                 exit value[]
                 #);
            #);
        
          onTest::
            (#
            do mainBrowser.browser.print;
            #);
          
          ComponentWindow:  Subwindow
            (# navigation:: (# do true -> value #);
               fixed: ^TextStyle;
               root: @boolean;
               back: ^NavigationRecord;
               
               onBack::
                 (#
                 do navigateBack;
                 #);
               selectNode:
                 (# node: ^Tree.TopNode;
                    md: ^Tree.iModule;
                    record: ^PathRecord;
                 enter node[]
                 do getPath -> record[];
                    back[] -> record.back[];
                    record[] -> back[];
                    node.theiModule -> md[];
                    (if md[] <> NONE then
                        md[] -> selectModule;
                        (if rightEditor[] <> NONE then
                            (node.beginPos, node.beginPos)
                              -> rightEditor.setSelection;
                            rightEditor.contents[] -> target;
                        if);
                    if);
                 #);
               selectDescriptor:
                 (# desc: ^ObjDesc;
                    OD: ^Tree.TopNode;
                 enter desc[]
                 do desc.descInx -> THIS(World).compile.getObjectDesc -> OD[];
                    OD[] -> selectNode;
                 #);
               navi: @Navigator
                 (# showCode::
                      (#
                      do caller[] -> VM.selectCode;
                      #);
                    showDescriptor::
                      (# 
                      do desc[] -> selectDescriptor;
                      #);
                    showNode::
                      (#
                      do node[] -> selectNode;
                      #);
                    onClose::
                      (#
                      do execution.layout[] -> mainLayout.remove;
                         execution.close;
                         'CLOSING' -> putline;
                         NONE -> execution[];
                         (if full then
                             placeholder[] -> mainLayout.add;
                         if);
                      #);
                 #);
               NavigationRecord:
                 (# back: ^NavigationRecord;
                    navigate:<
                      (#
                      do INNER;
                      #);
                 #);
               FocusRecord: NavigationRecord
                 (# navigate::
                      (#
                      do (index, content[], name[]) -> changeContent;
                      #);
                    content: ^objCont.Handle;
                    index: @integer;
                    name: ^Text;
                 #);
               
               maximum: @integer;
               onExpand::
                 (# width, height: @integer;
                 do '** ComponentWindow:onExpand:'->putline;
                    THIS(SubWindow).size -> (width, height);
                    (width, maximum) -> THIS(SubWindow).size;
                    grow.show; (* show growbox in lower right corner *)
                 #);
               onCollapse::
                 (# width, height: @integer;
                 do '** ComponentWindow:onCollapse:'->putline;
                    THIS(SubWindow).size -> (width, height);
                    (width, 20 + 2 * theBorderWidth) -> THIS(SubWindow).size;
                    (* Changing size does not seem to have an effect! *)
                    height -> maximum;
                    '**   ' -> puttext; width -> putint;
                    ' ' -> put; height -> putint;
                    ' ' -> put; 20 + 2 * theBorderWidth -> putint; newline;
                    grow.hide; (* hide growbox in lower right corner *)
                 #);
               
               open::
                 (# index: @integer;
                    objC: ^ObjCont.handle;
                    width, height: @integer;
                    
                 enter (root, index, objC[])
                 do 'icons\\error.png' -> loadImage -> errorIcon[];
                    'icons\\package.png' -> loadImage -> packageIcon[];
                    'icons\\publicpackage.png' 
                      -> loadImage -> publicpackageIcon[];
                    'icons\\privatepackage.png' -> loadImage
                      -> privatepackageIcon[];
                    'icons\\pattern.png' -> loadImage -> patternIcon[];
                    'icons\\virtual.png' -> loadImage -> virtualIcon[];
                    'icons\\reference.png' -> loadImage -> referenceIcon[];
                    'icons\\lightref.png' -> loadImage -> lightrefIcon[];
                    'icons\\simple.png' -> loadImage -> simpleIcon[];
                    'icons\\array.png' -> loadImage -> arrayIcon[];
                    'icons\\cog.png' -> loadImage -> cogwheel[];
                    
                    &TextStyle[] -> fixed[];
                    'Courier' -> fixed.name;
                    8 -> fixed.size;
                    textFaces.plain -> fixed.face;
                    
                    (0, 0) -> position;
                    scroller.open;
                    scroller[] -> browser.open;
                    (theBorderWidth, defaults.headH + theBorderWidth)
                      -> scroller.position;
                    (480, defaults.browserH) -> browser.size;
                    browser.size -> scroller.size;
                    
                    true -> flexible;
                    (index, objC[], lab[]) -> setContent;
                    scroller.layout;
                    false -> flexible;
                    
                    THIS(Window).size -> (width, height);
                    (defaults.componentW, height) -> size;
                    fitToContents;
                 #);
                              
               navigateTo:
                 (# index: @integer;
                    objC: ^objCont.Handle;
                 enter (index, objC[])
                 do (# record: ^FocusRecord;
                       name: ^Text;
                    do &FocusRecord[] -> record[];
                       thisIndex -> record.index;
                       head.label -> record.name[];
                       asDW.enclosingObjCont[] -> record.content[];
                       back[] -> record.back[];
                       record[] -> back[];
                       (if objC.theName[] <> NONE then
                           objC.theName.copy -> name[];
                        else
                           '' -> name[];
                       if);
                       (index, objC[], name[]) -> changeContent;
                    #);
                 #);
               navigateBack:
                 (# 
                 do (if back[] <> NONE then
                        back.navigate;
                        back.back[] -> back[];
                    if);
                 #);
               changeContent:
                 (# index: @integer;
                    objC: ^objCont.Handle;
                    name: ^Text;
                 enter (index, objC[], name[])
                 do theItems.closeRight;
                    theItems.close;
                    NONE -> theItems[];
                    (index, objC[], name[]) -> setContent;
                 #);
               setContent:
                 (# index: @integer;
                    objC: ^objCont.Handle;
                    name: ^Text;
                 enter (index, objC[], name[])
                 do (if true then
                        '**** setContent:objC.theEntry:'->putline;
                        objC.theEntry.doPT -> putline;
                    if);
                    index -> thisIndex;
                    objC[] -> asDW.enclosingObjCont[];
                    (NONE, 1, asDW.enclosingObjCont[])
                      -> (&BrowserItems[] -> theItems[]).setUpBrowser;
                    name[] -> head.label;
                    head.update;
                 #);
               asDW: @ displayWindow
                 (# size:: 
                      (# do this(componentWindow).size -> (width,height) #);
                    position:: (# do this(componentWindow).position -> pos #);
                    reDisplay::
                      (#
                      do 'componentWindow.asDW:reDisplay:shouldNotHappen' 
                           -> putline 
                      #);
                    hasEditChanges:: 
                      (# 
                      do 'componentWindow.asDW:hasEditChanges:shouldNotHappen' 
                           -> putline 
                      #);
                    save:: 
                      (# 
                      do 'componentWindow.asDW:save:shouldNotHappen' -> putline 
                      #);
                 #);
               onOpenClose::
                 (# w, h: @integer
                 do (if false then
                        true -> THIS(ComponentWindow).sizeToFit;
                     else
                        (if miniSize then
                            'OpenClose:Grow'->putline;
                            (fullW,fullH) -> this(componentWindow).size
                         else
                            'OpenClose:Reduce' -> putline;
                            this(componentWindow).size -> (fullW,fullH);
                            head.size -> (w,h);
                            (50,h)
                              -> this(componentWindow).size;
                            w-> putint; ' ' -> put; h -> putint; newline
                        if);
                        not miniSize -> miniSize;
                    if)
                 #);

               miniSize: @ boolean;
               fullW,fullH: @integer;
               selectCode: 
                 (# obj: ^objDesc.RunTimeObject; descNo: @integer; 
                    path: ^intList; objC: ^objCont.handle
                 enter(obj[],descNo,path[])
                 do (if false then
                        '\n**** ComponentWindow:selectCod: ' -> puttext; 
                        descNo -> putint; newline;
                    if);
                    (obj[],descNo,path[]) -> asDW.enclosingObjCont.selectCode
                      -> objC[]
                 exit objC[]
                 #);
               selectDesc:
                 (# trace: (# exit false #);
                    path: ^intList; inx: @integer;
                    desc: ^Tree.TopNode;
                    lsc: @integer;
                    beginPos, endPos: @integer;
                    result: ^TextEdit;
                 enter(path[],inx, desc[], lsc)
                 do (if trace then
                        '\n**** Worldwindow:SelectDesc:inx:' -> puttext; 
                        inx->putint;
                        '\npath:'->puttext; path.print; '\ndesc:'->putline;
                        desc.doPt -> putline;
                    if);
                    (path[],inx, 0, 0) -> theItems.select -> result[];
                    true -> desc.doPT; (* True updates charPos in desc *)
                    (if result[] = none then
                        '\n**** Worldwindow:SelectDesc:result = none!'
                          -> putline
                     else
                        lsc 
                          -> desc.doMapBCposToCharRange 
                          -> (beginPos,endPos);
                        (beginPos, endPos) -> result.select;
                        (*beginPos -> putint; ' ' -> put; endPos -> putint; 
                         * newline*)
                    if)
                 #);
               select:
                 (# path: ^intList; inx,beginPos,endPos: @integer;
                    result: ^TextEdit;
                 enter(path[],inx,beginPos,endPos)
                 do (path[],inx, 0, 0) -> theItems.select -> result[];
                    (beginPos, endPos) -> result.select;
                 #);
               selectPath:
                 (# path: ^IntStack;
                 enter path[]
                 do '**   selectPath:' -> putline;
                    path[] -> theItems.selectPath;
                 #);
               selectModule:
                 (# the_iModule: ^Tree.iModule;
                    theHandle: ^objCont.Handle;
                    path: ^IntStack;
                    flip:
                      (# in: ^IntStack;
                         out: ^IntStack;
                      enter in[]
                      do &IntStack[] -> out[];
                         loop:
                           (if not in.empty then
                               in.pop -> out.push;
                               restart loop;
                           if);
                      exit out[]
                      #);
                    findHandle:
                      (# theModule: ^Tree.iModule;
                         theHandle: ^objCont.Handle;
                         path: ^IntStack;
                      enter (theModule[], path[])
                      do (*'FindHandle:'->putline;
                         theModule.M.doPT -> putline;
                         objContRoot.theEntry.doPT->putline;*)
                         (if theModule.M[] = objContRoot.theEntry[] then
                             (*'Match'->putline;*)
                             objContRoot[] -> theHandle[];
                          else
                             (# enclosing: ^objCont.Handle;
                                current: ^objCont.Handle;
                             do (theModule.origin, path[]) 
                                  -> findHandle -> enclosing[];
                                (* 'Enclosing:'->putline;
                                 enclosing.theEntry.doPT->putline;*)
                                (for inx: enclosing.handles.range repeat
                                     inx -> enclosing.elm -> current[];
                                     (* current.theEntry.doPT -> putline;*)
                                     (if current.theModule[] -> theModule.eq 
                                         then 
                                         inx -> path.push;
                                         current[] -> theHandle[];
                                     if);
                                for);
                             #);
                         if);
                      exit theHandle[]
                      #);
                 enter the_iModule[]
                 do &IntStack[] -> path[];
                    (the_iModule[], path[]) -> findHandle -> theHandle[];
                    path[] -> flip -> path[];
                    path[] -> selectPath;
                 #);
               getPath:
                 (# path: ^IntStack;
                    collect:
                      (# from: ^BrowserItems;
                      enter from[]
                      do (if from.right[] <> NONE then
                             from.right[] -> collect;
                         if);
                         (if from.selection.first > 0 then
                             from.selection.first -> path.push;
                         if);
                      #);
                    begin, end: @integer;
                    record: ^PathRecord;
                 do &IntStack[] -> path[];
                    theItems[] -> collect;
                    (if rightEditor[] <> NONE then
                        rightEditor.contents.selection.get -> (begin, end);
                    if);
                    &PathRecord[] -> record[];
                    path[] -> record.path[];
                    begin -> record.begin;
                    end -> record.end;
                 exit record[]
                 #);
               
               PathRecord: NavigationRecord
                 (# path: ^IntStack;
                    begin: @integer;
                    end: @integer;
                    navigate::
                      (#
                      do '**   PathRecord:navigate:' -> puttext;
                         begin ->putint; ' ' -> put; end -> putint; newline;
                         path[] -> selectPath;
                         (if rightEditor[] <> NONE then
                             rightEditor.contents[] -> target;
                             (begin, end) -> rightEditor.setSelection;
                         if);
                      #);
                 #);
               
               Heading::<
                 (# open::
                      (#
                      do headingPopUp.open
                      #);
                    eventHandler::<
                      (# onMouseUp::
                           (# P: @point
                           do (if buttonState = 3 then
                                  localPosition -> P;
                                  (1,(P.h,P.v),this(Heading)[]) 
                                    -> headingPopUp.popUp
                              if)
                           #);                       
                         onMouseEnter:: (# #);
                      #);
                    headingPopUp: @menu
                      (# iSplit: @menuItem
                           (# eventHandler::
                                (# onSelect::
                                     (#
                                     do (if root then
                                            split;
                                         else
                                            combine;
                                        if);
                                     #)
                                #);
                              open:: 
                                (# 
                                do (if root then
                                       'Split' -> name;
                                    else
                                       'Assemble' -> name;
                                   if);
                                   iSplit[] -> append;
                                #)
                           #);
                         iNew: @menuItem
                           (# open::
                                (#
                                do 'New Browser' -> name;
                                   iNew[] -> append;
                                #);
                              eventHandler::
                                (# onSelect::
                                     (#
                                     do newBrowser;
                                     #);
                                #);
                           #);
                         iBack: @menuItem
                           (# open::
                                (#
                                do 'Back' -> name;
                                   iBack[] -> append;
                                #);
                              eventHandler::
                                (#
                                   onSelect::
                                     (#
                                     do navigateBack;
                                     #);
                                #);
                           #);
                         iClose: @MenuItem
                           (# eventHandler::
                                (# onSelect::
                                     (#
                                     do layout[] -> leftLayout.remove;
                                        THIS(ComponentWindow).close;
                                        THIS(ComponentWindow)[] 
                                          -> components.delete;
                                        leftLayout.layout;
                                     #)
                                #);
                              open:: 
                                (# 
                                do 'Close' -> name; 
                                   iClose[] -> append;
                                #);
                           #);
                         open::
                           (#
                           do iSplit.open;
                              iNew.open;
                              iBack.open;
                              iClose.open;
                           #)
                      #);
                 #);
               eventHandler::
                 (# count: @integer;
                    onFatherFrameChanged::
                      (#
                      do THIS(WorldWindow).size -> mainLayout.size;
                         mainLayout.layout;
                      #);
                    onMouseDown::
                      (# 
                      do trackMouse
                         (# mouseMove:: 
                              (#
                              do (h, v) -> move;
                                 true -> this(SubWindow).update
                              #)
                         #)
                      #);
                 #);
               scroller: @Canvas
                 (# count: @integer;
                    visible: @boolean;
                    theScrollBar: @ScrollBar
                      (# count: @integer;
                         eventHandler::
                           (# onValueChanged::
                                (#
                                do theScrollBar.value -> scroll;
                                #);
                           #);
                      #);
                    scroll:
                      (# value: @integer;
                         x, y: @integer;
                      enter value
                      do browser.position -> (x, y);
                         (-value, y) -> browser.position;
                      #);
                    getScroll:
                      (# x, y: @integer;
                      do browser.position -> (x, y);
                      exit -x
                      #);
                    
                    layout:
                      (# width, height: @integer;
                         w, h: @integer;
                         x, y: @integer;
                      do position -> (x, y);
                         THIS(SubWindow)[] -> theScrollBar.open;
                         size -> (width, height);
                         theScrollBar.size -> (w, h);
                         (width, h) -> theScrollBar.size;
                         (0, y + height - h) -> theScrollBar.position;
                         true -> theScrollBar.bindRight;
                         theScrollBar.hide;
                         true -> browser.bindBottom;
                      #);
                    checking: @boolean;
                    checkScrollValues:
                      (# page: @integer;
                         port: @integer;
                         excess: @integer;
                         h1: @integer;
                         h2: @integer;
                         h, w: @integer;
                         value: @integer;
                         checkit: @boolean;
                      do (if NOT checking then
                             true -> checking;
                             browser.size -> (page, h1);
                             scroller.size -> (port, h2);
                             theScrollBar.size -> (w, h);
                             (if page <= port then
                                 (if visible then
                                     theScrollBar.hide;
                                     false -> visible;
                                 if);
                                 (port, defaults.browserH) -> scroller.size;
                                 0 -> scroll;
                              else
                                 page - port -> excess;
                                 (if not visible then
                                     theScrollBar.show;
                                     true -> visible;
                                 if);
                                 (port, defaults.browserH - h) -> scroller.size;
                                 excess -> theScrollBar.maxValue;
                                 (if true then
                                     excess -> theScrollBar.value;
                                  else
                                     (if theScrollBar.value > excess then
                                         excess -> theScrollBar.value;
                                     if);
                                 if);
                                 getScroll -> value;
                                 (if value <> theScrollBar.value then
                                     theScrollBar.value -> scroll;
                                 if);
                                 browser.scrollIntoView;
                             if);
                             false -> checking;
                         if);
                      #);
                    eventHandler::
                      (# onFrameChanged::
                           (#
                           do checkScrollValues;
                              (if false then
                                  (if rightEditor[] <> NONE then
                                      rightEditor.adjustLineWidth;
                                  if);
                              if);
                           #);
                      #);
                 #);
               browser: @Canvas
                 (# print:
                      (#
                      do '-- browsers --' -> putline;
                         scan
                         (#
                         do current[] -> getPatternName -> putline;
                         #);
                      #);
		    sizeToFit:
                      (# current: ^BrowserItems;
                         x, y: @integer;
                         w, h: @integer;	
                         minimum: @integer;
                         width, height: @integer;
                      do (if theItems[] <> NONE then
                             theItems[] -> current[];
                             loop:
                               (if current.right[] <> NONE then
                                   current.right[] -> current[];
                                   restart loop;
                               if);
                             current.position -> (x, y);
                             current.size -> (w, h);
                             size -> (width, height);
                             x + w + 1 -> width;
                             (width, height) -> size;
                         if);
                      #);
                    scrollIntoView:
                      (# current: ^BrowserItems;
                      do theItems[] -> current[];
                         loop:
                           (if current[] <> NONE then
                               current.scrollIntoView;
                               current.right[] -> current[];
                               restart loop;
                           if);
                      #);
                 #);
        
               saveEditBuffers: (# do theItems.saveEditBuffers #);
               
               sizeToFit:
                 (# current: ^BrowserItems;
                    x, y: @integer;
                    w, h: @integer;
                    minimum: @integer;
                    width, height: @integer;
                    resize: @boolean;
                 enter resize
                 do browser.sizeToFit;
                    browser.size -> (w, h);
                    (w, h) -> scroller.size;
                    false -> scroller.bindRight;
                    size -> (width, height);
                    w + theBorderwidth*2 -> minimum;
                    (if (minimum > width) and resize then
                        (minimum, height) -> size;
                     else
                        (width - theBorderwidth*2, h) -> scroller.size;
                    if);
                    true -> scroller.bindRight;
                    scroller.checkScrollValues;
                 #);
               
               BrowserItems: TableView
                 (# open::
                      (# v: @point; h: @integer;
                         lWidth,lHeight: @integer;
                      do (if true then
                             '**** BrowserItems:open: ' -> putline
                         if);
                         (if asDW.left[] <> none then
                             asDW.left.position -> v;
                             asDW.left.size -> (lWidth,lHeight);
                             v.h + lWidth -> h
                          else 
                             1 -> h;
                             defaults.browserW -> lWidth;
                             defaults.browserH -> lHeight
                         if);
                         (h, 1) -> position;
                         (if scroller.visible then
                             (defaults.browserW,defaults.browserH - 16) -> size;
                          else
                             (defaults.browserW,defaults.browserH) -> size;
                         if);
                         fixed[] -> style;
                         true -> bindLeft;
                         itemPopUp.open;
                      #);
                    asDW: @DisplayWindow
                      (* objC is an entry of the form
                       *    E = (X1,X2,... Xn)
                       * where X1, X2, ..., Xn
                       * are displayed in the item-list
                       *)
                      (# size:: 
                           (# do this(BrowserItems).size -> (width,height) #);
                         position:: (# do this(BrowserItems).position -> pos #);
                         thisInx: @integer;
                         thisObjCont:
                           (# objC: ^objCont.Handle
                           do (if thisInx > 0 then
                                  thisInx -> enclosingObjCont.elm -> objC[];
                              if);
                           exit objC[]
                           #);
                         reDisplay:: (# do (thisInx,0,0,true) -> display#);
                         hasEditChanges:: 
                           (# 
                           do (rightEditor[]<> none) and rightEditor.wasChanged 
                                -> value 
                           #);
                         closeEditor:: (# do none -> rightEditor[] #);
                         showErrors:: 
                           (# 
                           do errors[] -> this(browserItems).showErrors 
                           #);
                         hideErrors:: (# do THIS(BrowserItems).hideErrors; #);
                         save::
                           (# right: ^BrowserItems
                           do (if hasEditChanges then
                                  '=== Must save: ' -> puttext; 
                                  ((thisObjCont).enclosingModuleObj).theName[] 
                                    -> puttext;
                                  ' | ' -> puttext;
                                  print -> puttext;
                                  ' ===' -> putline;
                                  saveEditBuffers -> errors[];
                                  'errors: "' -> puttext;
                                  errors[] -> puttext;
                                  '"' -> putline;
                                  (* closeRight;  
                                   * --- if called from TextEdit::onTab,
                                   * we should not close the textEditor
                                   * Some redundancy with display below
                                   *)
                                  (if errors[] = NONE then
                                      editing -> closeRight;
                                      &BrowserItems[] -> right[];
                                      right.asDW[] -> asDW.right[];
                                      right[] -> THIS(BrowserItems).right[];
                                      (asDW[],thisInx,thisObjCont) 
                                        -> right.setUpBrowser;
                                   else
                                      hideErrors;
                                      errors[] -> showErrors;
                                  if);
                              if)                      
                           #);
                         print::
                           (# 
                           do (if thisInx > 0 then
                                  (thisObjCont).entityPathFromModule 
                                    -> T.puttext
                               else
                                  'No selection' -> T.puttext
                              if);
                           #);
                         description::
                           (#
                           do '[' -> value[];
                              enclosingObjCont.theName[] -> value.puttext;
                              ']' -> value.puttext;
                           #);
                      #);
                    
                    handleMouseEvent:
                      (# event: ^EventHandler.MouseEvent;
                         P: @point;
                      enter event[]
                      do (if selection.first > 0 then
                             (if event.doubleClick then 
                                 (* selection.first -> gettext -> putline;
                                  * 'Edit field' -> putline;
                                  *)
                                 selection.first -> editField;
                                 event.LocalPosition -> P;
                                 (* 'mouse.V: ' -> puttext; P.V -> putint; 
                                  * ' mouse.H: ' -> puttext; P.H -> putint; 
                                  * newline;
                                  *)
                              else
                                 (# p: @Point; adjInx: @integer
                                 do (event.localposition, THIS(BrowserItems)[]
                                    , THIS(Window).contents)
                                      -> translate
                                      -> p;
                                    selection.first -> adjInx;
                                    (if event.buttonState
                                     // 1 then 
                                        (adjInx,0,0,true) -> display
                                     // 3 then
                                        (adjInx,0,0,true) -> display;
                                        (if ((adjInx
                                              -> asDW.thisInx 
                                              -> asDW.enclosingObjCont.elm)
                                            .theEntry.kind)
                                            = '/' then
                                            itemPopUp.saveHandler[]
                                              -> itemPopUp.iSave.attach;
                                            (* Perhaps also insist on a 
                                             * do-part for iExe?*)
                                            itemPopUp.exeHandler[] 
                                              -> itemPopUp.iExe.attach
                                        if);
                                        (if clipboard.hasText then
                                            itemPopUp.textPasteHandler[] 
                                              -> itemPopUp.iPaste.attach;
                                            itemPopUp.textPasteModuleHandler[] 
                                              -> itemPopUp.iPasteAsModule.attach;
                                        if);
                                        (1,p,THIS(Window).contents)
                                          -> itemPopUp.popUp;
                                    if);
                                 #);
                             if);
                          else
                             closeRight;
                             &textEdit[] -> rightEditor[];
                             (asDW[], asDW.enclosingObjCont[],0,0) 
                               -> rightEditor.setUpEditor;
                             (if event.buttonState = 3 then
                                 (if clipboard.hasText then
                                     itemPopUp.textPasteHandler[] 
                                       -> itemPopUp.iPaste.attach;
                                     itemPopUp.textPasteModuleHandler[] 
                                       -> itemPopUp.iPasteAsModule.attach;
                                 if);
                                 (1,event.localposition,this(BrowserItems)[]) 
                                   -> itemPopUp.popUp;
                             if);
                         if);
                      #);
                    onMouseDown:: (#do event[] -> handleMouseEvent #);
                    eventHandler::
                      (# onMouseUp:: 
                           (#do THIS(MouseEvent)[] -> handleMouseEvent #)
                      #);
                    editField:
                      (# no: @integer; 
                         oldCont,oldName,newName: ^text; 
                         oldKind,newKind: @char;
                         P: @point; R: @rectangle;
                         TE: @editText
                           (# open::
                                (# 
                                do this(BrowserItems).style -> style;
                                   borderStyles.simple -> border.style;
                                   false -> border.visible;
                                   (P.H + 1,P.V + R.top + 2) -> position;
                                   (R.right-R.left+5,R.bottom-R.top+5) -> size; 
                                   (* must add 5 to height for text cursor 
                                    * to be visible *)
                                   no -> gettext -> oldCont[] -> contents;
                                #);
                              eventHandler::<
                                (# onKeyDown:: 
                                     (# error: @boolean
                                     do (* 'Key down: ' -> puttext; ch -> put; 
                                         * ch -> putint; newline; 
                                         * ascii.nl -> putint; newline;
                                         *)
                                        (if ch = 13 (* nl on Windows?*) then
                                            (if not (contents -> oldCont.equal) 
                                                then
                                                (oldCont[],contents) 
                                                  -> asDW.enclosingObjCont.changeAttName 
                                                  -> error;
                                                (if error then
                                                    'Syntax error in browser item: '
                                                      -> puttext;
                                                    contents -> putline
                                                 else
                                                    (no,contents) -> setText;
                                                if)
                                            if);
                                            close
                                        if)
                                     #)
                                #)
                           #)
                      enter no
                      do no -> getItemRectangle -> R;
                         this(BrowserItems).position -> P;
                         browser[] -> TE.open
                      #);
                    display:
                      (* for asDW where E = (X1,X2, ..., Xn)
                       * Xinx has been selected2
                       * 
                       * MARK 2
                       *)
                      (# inx,beginPos,endPos: @integer; 
                         mkTxtEditor: @boolean;
                         result: ^TextEdit;
                      enter (inx, beginPos, endPos, mkTxtEditor)
                      do L:
                           (# objCx: ^ObjCont.handle;
                           do (if currentSelection[] <> none then
                                  (if currentSelection.save <> none then
                                      (* syntax errors in edit buffer 
                                       * of currentSelection *)
                                      (currentIndex, false) -> selection.select;
                                      leave L
                                  if)
                              if);
                              closeRight;
                              asDW[] -> currentSelection[];
                              inx 
                                -> asDW.thisInx 
                                -> asDW.enclosingObjCont.elm 
                                -> objCx[];
                              
                              (if objCx[] <> none then 
                                  (* should never be none ! *)
                                  (if pred[] <> none then 
                                      (* why? *) pred.closeEditor if);
                                  &BrowserItems[] -> right[];
                                  right.asDW[] -> asDW.right[];
                                  (asDW[],index,objCx[]) -> right.setUpBrowser;
                                  flexible -> THIS(ComponentWindow).sizeToFit;
                                  (if mkTxtEditor then
                                      &textEdit[] -> rightEditor[];
                                      (asDW[],objCx[],beginPos,endPos) 
                                        -> rightEditor.setUpEditor;
                                      rightEditor[] -> result[];
                                  if);
                               else
                                  'objCx is NONE' -> putline;
                              if);
                              inx -> currentIndex;
                           #);
                      exit result[]
                      #);
                    hideErrors:
                      (# width, height: @integer;
                      do (if errorView[] <> NONE then
                             errorView.close;
                             NONE -> errorView[];
                             (if rightEditor[] <> NONE then
                                 rightEditor.size -> (width, height);
                                 (width, height + 320) -> rightEditor.size;
                             if);
                         if);
                      #);
                    showErrors:
                      (# x, y: @integer;
                         width, height: @integer;
                         errors: ^Stream;
                      enter errors[]
                      do 'showErrors: ' -> putline;
                         errors[] -> putline;
                         '-----' -> putline;
                         errors.reset;
                         (if rightEditor[] <> NONE then
                             rightEditor.size -> (width, height);
                             rightEditor.position -> (x, y);
                             (width, height - 320) -> rightEditor.size;
                             &ErrorList[] -> errorView[];
                             errorView.open;
                             (x, y + (height - 320)) -> errorView.position;
                             (width, 320) -> errorView.size;
                             true -> errorView.bindRight;
                             true -> errorView.bindBottom;
                             errors[] -> errorView.display;
                             errors[] -> rightEditor.handleErrors;
                         if);
                      #);
                    itemPopUp: @menu
                      (# iAdd: @menuItem
                           (# open:: (#do 'Add' -> name; iAdd[] -> append #);
                              eventHandler::
                                (# onSelect::
                                     (# x: @newAttributeBox;
                                     do x.open;
                                        (if not x.isCanceled then 
                                            (if X.name.length = 0 then
                                                '**** Missing name!'-> putline;
                                                (none,'You must specify a name for the attribute','error') 
                                                  -> alertUser
                                             else
                                                (if selection.first > 0 then
                                                    (selection.first, x.name[], x.kind) 
                                                      -> addItem;
                                                 else
                                                    (numberOfItems + 1,  x.name[], x.kind) 
                                                      -> addItem;
                                     if)if)if)#)
                                #);
                              addItem:
                                (# inx,kind: @integer; N,att,err: ^text; 
                                   before: @boolean; 
                                   objCx: ^ObjCont.handle
                                enter(inx,N[],kind)
                                do '*** AddItem: "' -> puttext; N[] -> puttext;
                                   ' ' ->put; kind -> put;
                                   
                                   (if (N[] -> asDW.enclosingObjCont.checkName 
                                         -> err[]) <> none then
                                       (none,err[],'Error') -> alertUser;
                                       leave addItem
                                   if);
                                   (* insert before inx *)
                                   (inx,1) -> this(BrowserItems).insert; 
                                  
                                   ('selection',inx) -> L.TIn;
                                   (inx,N[],kind)  
                                     -> asDW.enclosingObjCont.addItem -> att[];
                                   (if att.length = 0 then
                                       (none, 'File module exists:','qenv') 
                                         -> alertUser;
                                       leave addItem
                                   if);
                                   (inx,att[]) -> setIconAndName;
                                   (inx,false) -> selection.select;
                                   closeRight;
                                   (if false then
                                       inx -> asDW.enclosingObjCont.elm 
                                         -> objCx[];
                                       ('addItem:ObjX',objCx.theName[]) -> L.TTn;
                                   if);
                                   ('addItem:enclosingObjCont',asDW.enclosingObjCont.theName[]) 
                                     -> L.TTn;
                                   (inx, 0,0,true) -> display
                                #);
                           #);
                         iMove: @menuItem
                           (# eventHandler:: 
                                (# onSelect:: (* never called - has submenu *)
                                     (# 
                                     do 'Move' -> putline;
                                        (1,(0,0),this(BrowserItems)[]) 
                                          -> UD.popUp
                                #)#);
                              open:: 
                                (# 
                                do 'Move' -> name; iMove[] -> append;
                                   UD.open; 
                                   UD[] -> subMenu
                                #);
                              UD: @menu
                                (# iUp: @menuItem
                                     (# eventHandler::
                                          (# onSelect:: 
                                               (# inx: @integer; T: ^text
                                               do 'Up' -> putline; 
                                                  (if 1 < (selection.first -> inx) then
                                                      inx -> gettext -> T[];
                                                      (inx, inx - 1 -> gettext) 
                                                        -> setText;
                                                      (inx - 1, T[]) -> setText;
                                                      (T[],inx) 
                                                        -> asDW.enclosingObjCont.moveUp;
                                          if)#)#);
                                        open:: 
                                          (# 
                                          do 'Up' -> name; 
                                             iUp[] -> append; 
                                          #);
                                     #);
                                   iDown: @menuItem
                                     (# eventHandler::
                                          (# onSelect:: 
                                               (# inx: @integer; T: ^text
                                               do 'Down' -> putline; 
                                                  (if (selection.first ->inx) < numberOfItems then
                                                      inx -> gettext -> T[];
                                                      (inx, inx + 1
                                                        -> gettext) -> setText;
                                                      (inx + 1 , T[]) 
                                                        -> setText;
                                                      (T[],inx + 1) 
                                                        -> asDW.enclosingObjCont.moveUp;
                                                  if)
                                          #)#);
                                        open:: 
                                          (# 
                                          do 'Down' -> name; 
                                             iDown[] -> append; 
                                          #);
                                     #);
                                   open:: (# do iUp.open; iDown.open #)
                                #)
                           #);      
                         iCopy: @menuItem
                           (# eventHandler::
                                (# onselect::
                                     (# inx: @integer;
                                        T: ^text
                                     do (if (selection.first ->inx) 
                                            <= numberOfItems then
                                            (if true then
                                                (# dcl: ^Tree.TopNode;
                                                   obj: ^objCont.Handle;
                                                do inx -> asDW.enclosingObjCont.elm 
                                                     -> obj[];
                                                   (if obj.isModule then
                                                       (# source: @File;
                                                       do obj.getModulePath 
                                                            -> source.name;
                                                          source.openRead;
                                                          &Text[] -> T[];
                                                          loop:
                                                            (if not source.eos then
                                                                source.getLine 
                                                                  -> T.putline;
                                                                restart loop;
                                                            if);
                                                          source.close;
                                                       #);
                                                    else
                                                       asDW.enclosingObjCont.DCLs[inx][] 
                                                         -> dcl[];
                                                       dcl.doPt -> T[];
                                                   if);
                                                #);
                                             else
                                                (selection.first 
                                                  -> asDW.thisInx 
                                                  -> asDW.enclosingObjCont.elm).gettext 
                                                  -> T.append;
                                            if);
                                            (if false then
                                                '**** copy: ' -> putline;
                                                T[] -> putline;
                                                '**   enclosingObjCont:' 
                                                  -> putline; 
                                                asDW.enclosingObjCont.theEntry.doPt 
                                                  -> putline;
                                                 '**   enclosingHandle:' 
                                                  -> putline; 
                                                asDW.enclosingObjCont.enclosingHandle.theEntry.doPt 
                                                  -> putline;
                                            if);
                                            T[] -> clipBoard.textContents;

                                        if)
                                     #)
                                #);
                              open::(#do 'Copy' -> name; iCopy[] -> append #)
                           #);
                         iPaste: @dynamicMenuItem
                           (# open:: (# do 'Paste'-> name; iPaste[] -> append #)
                           #);
                         
                         textPasteHandler: @menuAction
                           (# onSelect::
                                (# inx: @integer;
                                   att: ^Text;
                                do (if selection.first = 0 then
                                       numberOfItems + 1 -> inx;
                                    else
                                       selection.first -> inx;
                                   if);
                                   (inx, clipBoard.textContents)  
                                     -> asDW.enclosingObjCont.addDecl 
                                     -> att[];
                                   (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                                   (inx,att[]) -> setIconAndName;
                                   (inx,false) -> selection.select;
                                   closeRight;
                                   (inx, 0,0,true) -> display
                                #);
                           #);
                         iPasteAsModule: @dynamicMenuItem
                           (# open:: 
                                (# 
                                do 'Paste as Module'-> name; 
                                   iPasteAsModule[] -> append 
                                #)
                           #);
                         textPasteModuleHandler: @menuAction
                           (# onSelect::
                                (# inx: @integer;
                                   att: ^Text;
                                do (if false then
                                       '**** textPasteModuleHandler:theEntry'
                                         -> putline;
                                       asDW.enclosingObjCont.theEntry.doPT 
                                         -> putline;
                                   if);
                                   (if selection.first = 0 then
                                       numberOfItems + 1 -> inx;
                                    else
                                       selection.first -> inx;
                                   if);
                                   (inx, clipBoard.textContents)  
                                     -> asDW.enclosingObjCont.pasteModule
                                   (# error::
                                        (#
                                        do (none,msg[],'Error') -> alertUser;
                                           '' -> att[];
                                   #)#)
                                     -> att[];
                                   (if att.length > 0 then
                                       (inx,1) -> this(BrowserItems).insert; (* insert before inx *)
                                       (inx,att[]) -> setIconAndName;
                                       (inx,false) -> selection.select;
                                       closeRight;
                                       (inx, 0,0,true) -> display
                                   if)
                                #);
                           #);
                         iDelete: @menuItem  
                           (# eventHandler::
                                (# onSelect:: 
                                     (# inx: @integer;
                                        ok: @boolean;
                                        message: ^Text;
                                        result: @integer;
                                     do 'iDelete: ' -> puttext;
                                        selection.first -> inx;
                                        false -> OK;
                                        'Delete item"' -> message[];
                                        asDW.enclosingObjCont.dclNames[inx][] -> message.puttext;
                                        '"?\n' -> message.puttext;
                                        
                                        (THIS(Window)[], '', message[]) -> promptUser -> result;
                                        (if result = UserYes then
                                            asDW.enclosingObjCont.dclNames[inx][] -> putline;
                                            (asDW.enclosingObjCont.dclNames[inx][],selection.first)
                                              -> asDW.enclosingObjCont.delete;
                                            (inx,1) -> this(TableView).delete;
                                            (if inx > this(TableView).numberOfItems then inx - 1 -> inx if);
                                            (inx,false) -> selection.select;
                                            (selection.first,0,0,true) -> display;
                                        if);
                                #)#); 
                              open:: 
                                (# do 'Delete' -> name; iDelete[] -> append; #);
                           #);
                         iSave: @dynamicMenuItem
                           (# open:: (# do 'Save'-> name; iSave[] -> append #);
                           #);
                         saveHandler:  @menuAction
                           (# onSelect:: (# do asDW.save #);
                           #);
                         
                         iFocus: @MenuItem
                           (#
                              open::
                                (#
                                do 'Focus On' -> name;
                                   iFocus[] -> append;
                                #);
                              eventHandler::
                                (#
                                   onSelect::
                                     (# index: @integer;
                                        content: ^objCont.Handle;
                                     do 
                                        (if selection.first = 0 then
                                            'focus on: ' -> puttext;
                                            asDW.enclosingObjCont.theName[] -> putline;
                                         else
                                            'focus on: ' -> puttext;
                                            (selection.first -> asDW.enclosingObjCont.elm).theName[] -> putline;
                                            selection.first -> index;
                                            index -> asDW.enclosingObjCont.elm -> content[];
                                            (index, content[]) -> navigateTo;
                                        if);
                                     #);
                                #);
                           #);
                         iVisibility: @MenuItem
                           (#
                              choises: @Menu
                                (# showAllItem: @MenuItem
                                     (# open::
                                          (#
                                          do 'Show All' -> name;
                                          #);
                                        eventHandler::
                                          (# onSelect::
                                               (#
                                               do (if (selection.first -> index) <= numberOfItems then
                                                      (selection.first, OSDvisibility_Open) -> visibility;
                                                  if);
                                               #);
                                          #);
                                     #);
                                   skipInternalItem: @MenuItem
                                     (# open::
                                          (#
                                          do 'Skip Internal' -> name;
                                          #);
                                        eventHandler::
                                          (# onSelect::
                                               (#
                                               do (if (selection.first -> index) <= numberOfItems then
                                                      (selection.first, OSDvisibility_SkipInternal) -> visibility;
                                                  if);
                                               #);
                                          #);
                                     #);
                                   skipAllItem: @MenuItem
                                     (# open::
                                          (#
                                          do 'Skip All' -> name;
                                          #);
                                        eventHandler::
                                          (# onSelect::
                                               (#
                                               do (if (selection.first -> index) 
                                                      <= numberOfItems then
                                                      (selection.first
                                                      , OSDvisibility_Disguised) 
                                                        -> visibility;
                                                  if);
                                               #);
                                          #);
                                     #);
                                   open::
                                     (#
                                     do showAllItem.open;
                                        showAllItem[] -> append;
                                        skipInternalItem.open;
                                        skipInternalItem[] -> append;
                                        skipAllItem.open;
                                        skipAllItem[] -> append;
                                     #);
                                #);
                              open::
                                (#
                                do 'Visibility' -> name;
                                   choises.open;
                                   choises[] -> subMenu;
                                   iVisibility[] -> append;
                                #);
                           #);
                         visibility:
                           (# index: @integer;
                              value: @integer;
                           enter (index, value)
                           do value 
                                -> (asDW.enclosingObjCont.DCLs[index].sort).setOSDvisibility;
                              reload;
                              (index, false) -> selection.select
                           #);
                         iExe: @dynamicMenuItem
                           (# open:: (# do 'Execute' -> name; iExe[] -> append #);
                           #);
                         exeHandler: @menuAction
                           (# doCompile:
                                (# objC: ^ObjectContent.handle; FN: ^text; 
                                   iMain: ^Tree.iModule; errors: ^stream
                                enter objC[]
                                do '**** MiniENV: compile: ' -> puttext;
                                   objC.theModule.name -> putline;
                                   
                                   objC.modulePath -> FN[];
                                   objC.theModule.name -> FN.append;
                                   compile.SrcExt[] -> FN.append;
                                   (* NOTE: theM <> none *)
                                   (L[],true,objC.theModule.M[],FN[]) 
                                     -> compile 
                                     -> (imain[],errors[]);
                                   (if errors[] = none then
                                       objC.markAsCompiled
                                   if)
                                exit(iMain[],errors[])
                                #);
                              onSelect::  
                                (# objX: ^ObjCont.handle;
                                   comp: ^Tree.iModule;
                                   x, y: @integer;
                                   errors: ^stream;
                                   path: ^PathRecord;
                                do (if (asDW.save -> errors[]) <> none then
                                       (* Save checks for syntax errors only
                                        * Semantic errors are not captured by Save
                                        *)
                                       '\n\n***** Syntax errors in module' 
                                         -> putline;
                                       errors[] -> showErrors;
                                    else
                                       getPath -> path[];
                                       '\n\n**** exehandler:onSelect:selection.first:' 
                                         -> puttext;
                                       selection.first  -> putint; newline;
                                       ('Do execute',index) -> L.TI;
                                       (asDW.enclosingObjCont.theName[]
                                       , selection.first) 
                                         -> L.TI;
                                       selection.first 
                                         -> asDW.enclosingObjCont.elm 
                                         -> objX[];
                                       L[] -> objX.doCompile 
                                         -> (comp[],errors[]);
                                       hideErrors;
                                       path.navigate;
                                       (if errors[] <> none then
                                           (* Syntax errors have already been 
                                            * checked by Save
                                            * Semantic errors are caught here
                                            *)
                                           '\n\n==== Errors in module ====' 
                                             -> putline;
                                           (if compile.theErrorModule <> NONE 
                                               then
                                               compile.pathToErrorModule 
                                                 -> putline;
                                               '=========================='
                                                 -> putline;
                                               compile.theErrorModule 
                                                 -> mainBrowser.selectModule;
                                           if);
                                           errors[] -> showErrors;
                                        else
                                           (if EMBEDDED then
                                               THIS(ComponentWindow)[]
                                                 -> createExecution;
                                            else
                                               THIS(ComponentWindow)[] 
                                                 -> createStandaloneExecution;
                                           if);
                                           (objX[],runMode,isXbeta) 
                                             -> execution.execute;
                                           
                                           (# begin: @integer;
                                           do (objX.theEntry.myDesc).actionPos 
                                                -> begin;
                                              rightEditor.contents[] -> target;
                                              (begin, begin) -> rightEditor.setSelection;
                                           #)
                                       if)
                                   if)
                                #)
                           #);
                         open::
                           (#
                           do iAdd.open;
                              iCopy.open;
                              iPaste.open;
                              iPasteAsModule.open;
                              iMove.open;
                              iDelete.open;
                              iFocus.open;
                              iVisibility.open;
                              iExe.open;
                              iSave.open;
                           #);
                      #);
                    saveEditBuffers: 
                      (* Check the use of this one
                       * When called from display:currentSelection.save, 
                       * only the current buffer needs to be saved;
                       * there are no rightmost buffers that need to be saved
                       * Check othher calls - perhaps only the call above is needed 
                       * since we then always save the edit buffer
                       * Also update comments in textEditor about wasChanged,
                       * we never reselect a buffer with changed elements
                       *)
                      (# errors: ^text
                      do ('SaveEditBuffers',asDW.print) -> L.TTn;
                         (if rightEditor[] <> none then 
                             (if rightEditor.wasChanged then
                                 true -> rightEditor.asDW.enclosingObjCont.wasChanged;
                                 ('SaveEditBuffer',rightEditor.contents.contents) 
                                   -> L.TTn;
                                 rightEditor.contents.contents 
                                   -> rightEditor.asDW.enclosingObjCont.saveBuffer
                                   -> rightEditor.handleErrors
                                   -> errors[]
                             if);
                             (if not rightEditor.asDW.enclosingObjCont.wasChanged then
                                 (* may be true from a previous selection *)
                                 ('SaveEditBuffer:not changed'
                                 ,rightEditor.contents.contents) 
                                   ->  L.TTn
                             if)
                          else 
                             (if asDW.right[] <> none then 
                                 right.saveEditBuffers (* never bound ...?*)
                             if);
                         if);
                      exit errors[]
                      #);
                    closeErrors:
                      (#
                      do 
                      #);
                    closeRight: 
                      (* close all Item-panes to the right and rightEditor *)
                      (# editing: @boolean;
                      enter editing
                      do ('CloseRight',asDW.print) -> L.TTn;
                         (if asDW.right[] <> none then 
                             editing -> right.closeRight;
                             right.close ;
                             none -> right[]; 
                             none -> asDW.right[]
                         if);
                         (if not editing then
                             (if rightEditor[] <> NONE then
                                 rightEditor.close;
                                 NONE -> rightEditor[];
                             if);
                         if);
                         hideErrors;
                      #);
                    pinx: @integer; 
                    
                    setIconAndName:
                      (* name and kind should be an arg here instead
                       * of str = 'xxx: @' to avoid parsing using getNameAndKind
                       * and to lift kind to a more abstract level
                       *)
                      (# trace: (# exit false #);
                         index: @integer;
                         str: ^Text;
                      enter (index, str[])
                      do (# visibility: @integer;
                            name: ^Text;
                            kind: @char;
                            icon: ^RichPixMap
                         do (if trace then
                                '**** setIconAndName: ' -> puttext; 
                                str[] -> putline;
                                '**   theEntry:A:' -> putline;
                                asDW.enclosingObjCont.theEntry.dopT -> putline;
                            if);
                            (asDW.enclosingObjCont.DCLs[index].sort).visibility 
                              -> visibility;
                            (if trace then
                                '**   visibility:' -> puttext;
                                visibility -> putint; newline;
                                asDW.enclosingObjCont.DCLs[index].dopt -> putline;
                            if);
                            str[] -> getNameAndKind -> (name[],kind);
                            (if trace then
                                '**   name: ' -> puttext; name[] -> puttext;
                                ' kind: ' -> puttext; kind -> put; newline
                            if);
                            (index, name[]) -> setText;
                            (kind,visibility) -> getIcon -> icon[];
                            (index, icon[]) -> setImage;
                         #);
                      #);
                    
                    reload:
                      (# width: @integer;
                         height: @integer;

                      do clear;
                         asDW.enclosingObjCont.getSize -> append;
                         size -> (width, height);
                         asDW.enclosingObjCont.scan
                         (# ix,w: @integer; name: ^text; kind: @char; 
                            include: @boolean;
                         do (if false then
                                '**** scan: ' -> puttext; current[] -> putline;
                            if);
                            current[] -> getNameAndKind -> (name[],kind);
                            (if false then
                                (if kind // '/' // ' ' then
                                '**   reload: "' -> puttext; name[] -> puttext;
                                    '" kind: \'' -> puttext; kind -> put; 
                                    '\'' -> put; 
                                newline;
                            if)if);
                            (if objCont.onlyModulesAndPatterns then
                                (if kind // '/' // ' ' then
                                    true -> include
                                 else
                                    false -> include
                                if)
                             else
                                true -> include
                            if);
                            (if include then
                                current[] -> fixed.widthOfText -> w;
                                w + 16 + 16 -> w;
                                (ix + 1 -> ix,current[]) -> setIconAndName;
                                (if w > width then
                                    w -> width;
                            if)if);
                         #);
                         (width, height) -> size;
                      #);
                    setUpBrowser:
                      (# p: @point; 
                      enter(pred[],pinx,asDW.enclosingObjCont[])
                      do (if true then
                             '**** setUpBrowser:'->putline
                         if);
                         pred[] -> asDW.left[];
                         pinx + 1 -> index;
                         browser[] -> open;
                         reload;
                         true -> bindBottom;
                         (if execution[] = NONE then
                             true -> THIS(ComponentWindow).sizeToFit;
                          else
                             flexible -> THIS(ComponentWindow).sizeToFit;
                         if);
                      #);
                    selectPath:
                      (# path: ^IntStack;
                      enter path[]
                      do (# inx: @integer;
                         do '**   selectPath:path:' -> puttext; 
                            path.print;
                            path.pop -> inx;
                            inx -> putint; 
                            ' selection.first: ' -> puttext;
                            selection.first -> putint;
                            newline;
                            (inx, false) -> selection.select;
                            ' selection.first:before:display ' -> puttext;
                            selection.first -> putint; newline;
                            (selection.first, 0, 0, path.empty) -> display;
                            scrollIntoView;
                            (if not path.empty then
                                path[] -> right.selectPath;
                            if);
                         #);
                      #);
                    select:
                      (*** MARK 1 ***)
                      (# trace: (#exit true #);
                         path: ^intList; inx,beginPos,endPos: @integer;
                         result: ^TextEdit;
                      enter(path[],inx,beginPos,endPos)
                      do (if trace then '****select:'->puttext; inx -> putint if);
                         (if (inx -> path.inRange) then
                             (if trace then ' inRange' -> puttext if);
                             (inx -> path.get,false) -> selection.select;
                             (if (inx + 1 -> path.inRange) then
                                 (if trace then ' +1' -> putline if);
                                 (inx -> path.get,beginPos,endPos,false) -> display;
                                 (path[],inx + 1,beginPos,endPos) -> right.select -> result[];
                              else
                                 (if trace then ' '->putline if);
                                 (inx -> path.get,beginPos,endPos,true) -> display -> result[];
                             if);
                         if);
                      exit result[]
                      #);
                    pred: ^displayWindow;
                    right: ^Browseritems;
                    index: @integer;
                    currentIndex: @integer;
                 #);

               theItems: ^BrowserItems; (* top Items of this(ComponentWindow) *)
               currentSelection: ^DisplayWindow; (* Current selection *)
               rightEditor: ^textEdit;
               errorView: ^ErrorList;

               TextEdit: TextEditor
                 (# aTextStyle: ^textStyle;
                    open::
                      (# compW,compH,width,height: @integer;
                         
                      do this(componentWindow).size -> (compW,compH);
                         this(componentWindow).height - 20 - defaults.browserH
                         - theBorderwidth * 2 
                           -> height;
                         this(componentWindow).width - theBorderwidth * 2 
                           -> width; 
                         (theBorderwidth, defaults.browserH + 20 
                         + theBorderwidth) 
                           -> position;
                         (width, height) -> size;
                         &textStyle[] -> aTextStyle[]; 
                         'Courier new' -> aTextStyle.name;
                         10 -> aTextStyle.size;
                         textFaces.plain -> aTextStyle.face;
                         aTextStyle[] -> contents.defaultstyle;
                         (if false then
                             'Linewidth: pixels: ' -> puttext; width -> putint;
                             ' maxChWidth: ' -> puttext; aTextStyle.maxChWidth 
                               -> putint; 
                             ' chars: ' -> puttext; 
                             width div aTextStyle.maxChWidth - 3 -> putint; 
                             newline;
                         if);
                         adjustLineWidth;
                         true -> bindBottom;
                         true -> bindRight;
                         editMenu.open
                      #);
                    select:
                      (# beginPos,endPos: @integer; 
                      enter (beginPos, endPos)
                      do skipWhiteSpace:
                           (if (beginPos -> contents.getChar) <= 32 then
                               beginPos + 1 -> beginPos;
                               (if beginPos < endPos then 
                                   restart skipWhiteSpace 
                           if)if);
                         (beginPos, endPos) -> contents.selection.set; 
                         (* needed to high-light selection: *)
                         contents[] -> THIS(Window).target;
                         contents.selection.scrollIntoView;
                      #);
                    adjustLineWidth:
                      (# width, height: @integer;
                      do size -> (width, height);
                         width - 15 -> width;
                         width div aTextStyle.maxChWidth - 3 
                           -> compile.lineWidth;
                         (if compile.lineWidth > 70 then
                             70 -> compile.lineWidth;
                         if);
                      #);
                    asDW: @ displayWindow
                      (# size:: (# do this(textEdit).size -> (width,height) #);
                         position:: (# do this(textEdit).position -> pos #);
                         hasEditChanges:: (# do wasChanged -> value #);
                      #);

                    init:< 
                      (# Tx: ^text; t: @styledText
                      enter Tx[]
                      do 
                         Tx -> T;
                         false -> realChange;
                         T[] -> contents.contents;
                         true -> realChange;
                      #);                
                    setUpEditor:
                      (# left: ^displayWindow; (*items;*)
                         width,height,beginPos,endPos: @integer; 
                         P: @point;
                      enter(left[],asDW.enclosingObjCont[],beginPos,endPos)
                      do left[] -> asDW.left[];
                         asDW.left.position -> P; 
                         asDW.left.size -> (width,height);
                         open;
                         asDW.enclosingObjCont.getText -> init;
                         (* 'setUpEditor: ' -> puttext;
                          * beginPos -> putint; ' ' -> put; endPos -> putint; 
                          * newline;*)
                         
                         (if (beginPos <> 0) and (endPos <> 0) then
                             (beginPos, endPos) -> select;
                         if);
                         
                         grow.bringToFront;
                      #);
                    
                    getText:
                      (# buffer: ^Text;
                      do &Text[] -> buffer[];
                         contents.all -> contents.scanText
                         (#
                         do ch -> buffer.put;
                         #);
                      exit buffer[]
                      #);
                    setSelection:
                      (# begin, end: @integer;
                      enter (begin, end)
                      do (begin, end) -> contents.selection.set;
                         contents.selection.scrollIntoView;
                      #);
                    indent:
                      (# mark: @integer;
                         
                         buffer: ^Text;
                         
                         SIMPLE_BLOCK: (# exit 0 #);
                         STD_BLOCK: (# exit 1 #);
                         IF_BLOCK: (# exit 2 #);
                         FOR_BLOCK: (# exit 3 #);
                         
                         Array:
                           (# storage: [0] ^Text;
                              init:
                                (# size: @integer;
                                enter size
                                do size -> storage.new;
                                #);
                              length:
                                (# value: @integer;
                                do storage.range -> value;
                                exit value
                                #);
                              at:
                                (# inx: @integer;
                                   value: ^Text;
                                enter inx
                                do storage[inx][] -> value[];
                                exit value[]
                                #);
                              atPut:
                                (# inx: @integer;
                                   value: ^Text;
                                enter (inx, value[])
                                do value[] -> storage[inx][];
                                #);
                           #);
                         
                         starts: @Array;
                         ends: @Array;
                         actionkeys: @Array;
                         ifKeys: @Array;
                         
                         prepare:
                           (# 
                           do 3 -> starts.init;
                              3 -> ends.init;
                              (STD_BLOCK, '(#') -> starts.atPut; 
                              (STD_BLOCK, '#)') -> ends.atPut;
                              (IF_BLOCK, '(if') -> starts.atPut;
                              (IF_BLOCK, 'if)') -> ends.atPut;
                              (FOR_BLOCK, '(for') -> starts.atPut;
                              (FOR_BLOCK, 'for)') -> ends.atPut;
                              
                              7 -> actionkeys.init;
                              (1, 'enter') -> actionkeys.atPut;
                              (2, 'do') -> actionkeys.atPut;
                              (3, 'exit') -> actionkeys.atPut;
                              (4, '(#') -> actionkeys.atPut;
                                      (5, '#)') -> actionkeys.atPut;
                              (6, '(*') -> actionkeys.atPut;
                              (7, '*)') -> actionkeys.atPut;
                              
                              3 -> ifKeys.init;
                              (1, '//') -> ifKeys.atPut;
                              (2, 'else') -> ifKeys.atPut;
                              (3, 'then') -> ifKeys.atPut;
                              
                              contents.selection.start -> mark;
                              getText -> buffer[];
                           #);
                         balanceBlock:
                           (# end: @integer;
                              begin: @integer;
                           enter end
                           do (# cnt: @integer;
                                 ch: @char;
                                 lines: @integer;
                              do end -> begin;
                                 0 -> cnt;
                                 loop:
                                   (if cnt >= 0 then
                                       begin -> buffer.inxGet -> ch;
                                       (if ch = ')' then
                                           cnt + 1 -> cnt;
                                       if);
                                       (if ch = '(' then
                                           cnt - 1 -> cnt;
                                       if);
                                       begin - 1 -> begin;
                                       (if begin > 0 then
                                           restart loop;
                                       if);
                                   if);
                              #);
                           exit begin
                           #);
                         getCurrentBlock:
                           (# cnt: @integer;
                              ch: @char;
                              lines: @integer;
                              begin: @integer;
                              end: @integer;
                           do (if mark > 0 then
                                  mark -> beginningOfLine -> endOfConstruct 
                                    -> end;
                                  end -> begin;
                                  0 -> cnt;
                                  loop:
                                    (if cnt >= 0 then
                                        begin -> buffer.inxGet -> ch;
                                        (if ch = ')' then
                                            cnt + 1 -> cnt;
                                        if);
                                        (if ch = '(' then
                                            cnt - 1 -> cnt;
                                        if);
                                        (if ch = 10 then
                                            lines + 1 -> lines;
                                        if);
                                        begin - 1 -> begin;
                                        (if begin > 0 then
                                            restart loop;
                                        if);
                                     else
                                        (if lines = 0 then
                                            0 -> cnt;
                                            restart loop;
                                        if);
                                    if);
                                  mark -> endOfLine -> end;
                              if);
                           exit (begin, end)
                           #);
                         
                         matchWord:
                           (# begin: @integer;
                              word: ^Text;
                              result: @boolean;
                           enter (begin, word[])
                           do (if (begin + word.length) <= buffer.length then
                                  true -> result;
                                  check:
                                    (for inx: word.length repeat
                                         (# ch1, ch2: @char;
                                         do begin + inx -> buffer.inxGet -> ch1;
                                            inx -> word.inxGet -> ch2;
                                            (if ch1 <> ch2 then
                                                false -> result;
                                                leave check;
                                            if);
                                         #);
                                    for);
                              if);
                           exit result
                           #);
                         matchWords:
                           (# begin: @integer;
                              words: ^Array;
                              result: @integer;
                           enter (begin, words[])
                           do search:
                                (for inx: words.length repeat
                                     (if (begin, inx -> words.at) 
                                           -> matchWord then
                                         inx -> result;
                                         leave search;
                                     if);
                                for);
                           exit result
                           #);
                         getColumn:
                           (# begin: @integer;
                              result: @integer;
                              ch: @integer;
                           enter begin
                           do (if begin > 0 then
                                  begin -> buffer.inxGet -> ch;
                                  loop:
                                    (if ch <> 10 then
                                        begin - 1 -> begin;
                                        result + 1 -> result;
                                        (if begin > 0 then
                                            begin -> buffer.inxGet -> ch;
                                            restart loop;
                                        if);
                                    if);
                              if);
                           exit result
                           #);
                         
                         beginningOfLine:
                           (# current: @integer;
                              begin: @integer;
                           enter current
                           do (# ch: @char;
                              do current -> begin;
                                 (if begin > 0 then
                                     begin -> buffer.inxGet -> ch;
                                     loop:
                                       (if ch <> 10 then
                                           begin - 1 -> begin;
                                           (if begin > 0 then
                                               begin -> buffer.inxGet -> ch;
                                               restart loop;
                                           if);
                                       if);
                                     
                                 if);
                              #);
                           exit begin
                           #);
                         endOfConstruct:
                           (# begin: @integer;
                              end: @integer;
                           enter begin
                           do (# ch: @char;
                                 candidate: @boolean;
                                 marker: @integer;
                              do begin + 1 -> end;
                                 (if end <= buffer.length then
                                     end -> buffer.inxGet -> ch;
                                     loop:
                                       (if ch <> 10 then
                                           (if ch = ')' then
                                               true -> candidate;
                                               end -> marker;
                                           if);
                                           end + 1 -> end;
                                           (if end <= buffer.length then
                                               end -> buffer.inxGet -> ch;
                                               restart loop;
                                           if);
                                       if);
                                     (if candidate then
                                         marker -> end;
                                     if);
                                 if);
                                 end - 1 -> end;
                              #);
                           exit end
                           #);
                         endOfLine:
                           (# current: @integer;
                              end: @integer;
                           enter current
                           do (# ch: @char;
                              do current + 1 -> end;
                                 (if end <= buffer.length then
                                     end -> buffer.inxGet -> ch;
                                     loop:
                                       (if ch <> 10 then
                                           end + 1 -> end;
                                           (if end <= buffer.length then
                                               end -> buffer.inxGet -> ch;
                                               restart loop;
                                           if);
                                       if);                                     
                                 if);
                                 end - 1 -> end;
                              #);
                           exit end
                           #);
                         startOfText:
                           (# begin: @integer;
                              end: @integer;
                              ch: @char;
                           enter begin
                           do begin + 1 -> end;
                              (if end <= buffer.length then
                                  end -> buffer.inxGet -> ch;
                                  loop:
                                    (if ch = 32 then
                                        end + 1 -> end;
                                        (if end <= buffer.length then
                                            end -> buffer.inxGet -> ch;
                                            restart loop;
                                        if);
                                    if);
                              if);
                              end - 1 -> end;
                           exit end
                           #);
                         indentLine:
                           (# begin: @integer;
                              end: @integer;
                              ilevel: @integer;
                           enter (begin, end, ilevel)
                           do (# clevel: @integer;
                                 delta: @integer;
                                 txt: ^Text;
                                 a, b: @integer;
                              do end - begin -> clevel;
                                 ilevel - clevel -> delta;
                                 contents.selection.get -> (a, b);
                                 (if begin <= a then
                                     a + delta -> a;
                                     b + delta -> b;
                                 if);
                                 
                                 (if delta > 0 then
                                     (begin, begin) -> contents.selection.set;
                                     &Text[] -> txt[];
                                     (for delta repeat
                                          ' ' -> txt.put;
                                     for);
                                     txt[] -> contents.insert;
                                  else
                                     (begin, begin - delta) 
                                       -> contents.selection.set;
                                     contents.delete;
                                 if);
                                 (a, b) -> contents.selection.set;
                              #);
                           #);
                         lookingAt:
                           (# index: @integer;
                              ch: @char;
                           enter index
                           do index -> buffer.inxGet -> ch;
                              'LOOK: ' -> puttext;
                              ch -> putint;
                              newline;
                           #);
                         processBlock:
                           (# begin, end: @integer;
                           enter (begin, end)
                           do (# result: @integer;
                                 line0: @integer;
                                 line1: @integer;
                                 ilevel: @integer;
                                 block: @boolean;
                              do end -> beginningOfLine -> line0;
                                 line0 -> startOfText -> line1;
                                 begin -> getColumn -> ilevel;
                                 (begin, starts[]) -> matchWords -> result;
                                 (if result
                                  //SIMPLE_BLOCK then
                                     ilevel + 1 -> ilevel;
                                  //STD_BLOCK then
                                     (# k: @integer;
                                     do (line1, actionkeys[]) 
                                          -> matchWords -> k;
                                        (if k > 0 then
                                            (if k = 4 then
                                                ilevel + 3 -> iLevel;
                                             else
                                                (if k = 6 then
                                                    ilevel + 3 -> iLevel;
                                                 else
                                                    true -> block;
                                                if);
                                            if);
                                         else
                                            ilevel + 3 -> ilevel;
                                        if);
                                     #);
                                  //IF_BLOCK then
                                     (# k: @integer
                                     do (line1, ends[]) -> matchWords -> k;
                                        (if k = 0 then
                                            (if ((line1, ifKeys[]) 
                                                  -> matchWords) <> 0 then
                                                ilevel + 1 -> ilevel;
                                             else
                                                ilevel + 4 -> ilevel;
                                            if);
                                        if);
                                     #);
                                  //FOR_BLOCK then
                                     ilevel + 5 -> ilevel;
                                 if);
                                 (if not block then
                                     (if (line1, '->') -> matchWord then
                                         iLevel + 2 -> iLevel;
                                      else
                                         (# previous: @integer;
                                         do (line1, blanks[]) 
                                              -> skipBackwards -> previous;
                                            (if (previous -> buffer.inxGet) 
                                                = ')' then
                                                previous - 1 -> previous;
                                                previous -> balanceBlock 
                                                  -> previous;
                                            if);
                                            (if previous > 0 then
                                                (previous, blanks[]) 
                                                  -> skipBackwards -> previous;
                                                (previous, identifier[]) 
                                                  -> skipBackwards -> previous;
                                                (previous, blanks[]) 
                                                  -> skipBackwards -> previous;
                                                (previous, specifier[]) 
                                                  -> skipBackwards -> previous;
                                                (previous, blanks[]) 
                                                  -> skipBackwards -> previous;
                                                (if (previous -> buffer.inxGet)
                                                    = '<' then
                                                    previous - 1 -> previous;
                                                if);
                                                (if (previous -> buffer.inxGet)
                                                    = ':' then
                                                    ilevel + 2 -> ilevel;
                                                if);
                                             else
                                                0 -> ilevel;
                                            if);
                                         #);
                                     if);
                                 if);
                                 (line0, line1, ilevel) -> indentLine;
                              #);
                           #);
                         getCurrenLine:
                           (# begin, end: @integer;
                           do mark -> beginningOfLine -> begin;
                              mark -> endOfLine -> end;
                           exit (begin, end)
                           #);
                         getCurrentConstruct:
                           (# begin, end: @integer
                           do mark -> beginningOfLine -> begin;
                              begin -> endOfConstruct -> end;
                           exit (begin, end)
                           #);
                         CharacterClass:
                           (# match:<
                                (# ch: @char;
                                   result: @boolean;
                                enter ch
                                do INNER;
                                exit result
                                #);
                           #);
                         blanks: @CharacterClass
                           (# match::
                                (#
                                do (ch = ' ') or (ch = 10) -> result;
                                #);
                           #);
                         identifier: @CharacterClass
                           (# match::
                                (#
                                do (if ch -> ascii.isLetter then
                                       true -> result;
                                    else
                                       (if ch -> ascii.isDigit then
                                           true -> result;
                                        else
                                           (if ch = '_' then
                                               true -> result;
                                           if);
                                       if);
                                   if);
                                #);
                           #);
                         specifier: @CharacterClass
                           (# match::
                                (#
                                do (ch = '@') or (ch = '^') -> result;
                                #);
                           #);
                         skipBackwards:
                           (# begin: @integer;
                              end: @integer;
                              chars: ^CharacterClass;
                              ch: @integer;
                           enter (begin, chars[])
                           do begin -> end;
                              end -> buffer.inxGet -> ch;
                              loop:
                                (if ch -> chars.match then
                                    end - 1 -> end;
                                    (if end > 0 then
                                        end -> buffer.inxGet -> ch;
                                        restart loop;
                                    if);
                                if);
                           exit end
                           #);
                      do prepare;
                         getCurrentBlock -> processBlock;
                      #);
                    
                    realChange,wasChanged: @ Boolean; 
                    contentsType:: textField
                      (# eventHandler::<
                           (# 
                              compileAndIndent:
                                (# errors: ^text;
                                   i, j: @integer;
                                   startAdjusted, endAdjusted: @integer;
                                do asDW.left.hideErrors;
                                   (if (currentSelection.save -> errors[]) 
                                       <> none then
                                       'OnTab: syntax errors'->putline;
                                       errors[] -> putline;
                                       (if true then
                                           errors[] -> asDW.left.showErrors
                                        else
                                           errors[] -> handleErrors
                                       if)
                                    else
                                       selection.get -> (i, j);
                                       loop: all -> scanText
                                       (# inx: @integer;
                                          count: @integer;
                                       do inx + 1 -> inx;
                                          (if ch > 32 then
                                              count + 1 -> count;
                                          if);
                                          (if inx = i then
                                              count - 1 -> startAdjusted;
                                          if);
                                          (if inx = j then
                                              count - 1 -> endAdjusted;
                                          if);
                                       #);
                                       asDW.enclosingObjCont.getText -> init;
                                       loop: all -> scanText
                                       (# inx: @integer;
                                          count: @integer;
                                       do inx + 1 -> inx;
                                          (if ch > 32 then
                                              count + 1 -> count;
                                          if);
                                          (if count = startAdjusted then
                                              inx + 1 -> i;
                                          if);
                                          (if count = endAdjusted then
                                              inx + 1 -> j;
                                          if);
                                       #);
                                       (i, j) -> selection.set;
                                       selection.scrollIntoView;
                                   if);
                                   false -> wasChanged;
                                #);
                              
                              onTab::
                                (#
                                do indent;
                                #);
                              indentation: @boolean;
                              onKeyDown::
                                (#
                                do (if ch = 13 then
                                       '**** retunr'->putline;
                                       true -> indentation;
                                   if);
                                #);
                              onTextChanged:: 
                                (# 
                                do (if indentation then
                                       false -> indentation;
                                       indent;
                                   if);
                                   (if realChange then true -> wasChanged if)
                                #);
                              onMouseDown:: 
                                (# p: @point;
                                do (if buttonState = 3 then
                                       localPosition -> p;
                                       (1,p,THIS(InterfaceObject)[]) 
                                         -> editMenu.popUp
                                   if)
                                #)
                           #);
                      #);
                    editMenu: @menu
                      (# iSave: @menuItem (* was iCompile !? *)
                           (# eventHandler::
                                (# onSelect::
                                     (# errors: ^Text;
                                     do '=== Save and doPT ===' -> putline;
                                        true -> currentSelection.save 
                                          -> errors[];
                                        (if errors[] = NONE then
                                            asDW.enclosingObjCont.getText 
                                              -> init;
                                        if);
                                        '========================' -> putline;
                                     #);
                                #);
                              open::
                                (# 
                                do 'Save' -> name;
                                   iSave[] -> append;
                                #);
                           #);
                         iSetBreak: @menuItem
                           (# eventHandler::
                                (# onSelect:: 
                                     (# 
                                     do 'SetBreak' -> putline;
                                        (if execution[] <> none then
                                            contents.selection.start 
                                              -> asDW.enclosingObjCont.setBreak
                                              -> breaks.add
                                         else
                                            (none,
                                            'Break points can only be set '
                                            'for modules being executed',
                                            'ERROR notification') 
                                              -> alertUser
                                        if)
                                     #)
                                #);
                              open::
                                (# 
                                do 'Set break' -> name; 
                                   iSetBreak[] -> append;
                                #)
                           #);
                         iFollow: @MenuItem
                           (# 
                              eventHandler::
                                (#
                                   followLink:
                                     (# apl: ^Tree.TopNode;
                                        dcl: ^Tree.TopNode;
                                        from, to: ^Tree.iModule;
                                        record: ^PathRecord;
                                     enter apl[]
                                     do apl.theiModule -> from[];
                                        apl.getDeclModule -> (to[],dcl[]);
                                        
                                        getPath -> record[];
                                        (*record.path.print;*)
                                        
                                        back[] -> record.back[];
                                        record[] -> back[];

                                        (if from[] -> to.eq then
                                            (dcl.beginPos, dcl.endPos) 
                                              -> setSelection
                                         else
                                            to[] -> mainBrowser.selectModule;
                                            (* Note: selectModule, 
                                             * defines dcl.beginPos 
                                             * and dcl.endPos 
                                             * If dcl[] = none then we have 
                                             * a ModuleItem
                                             * and here no rightEditor 
                                             * is selected
                                             *)
                                            (if dcl[] <> NONE then
                                                mainBrowser.rightEditor.contents[] -> target;
                                                (dcl.beginPos, dcl.endPos) 
                                                  -> mainBrowser.rightEditor.setSelection;
                                        if)if)
                                     #);
                                   onSelect::
                                     (# node: ^Tree.TopNode; 
                                        iMain: ^compile.iModule;
                                        errors: ^text
                                     do contents.selection.start
                                          -> asDW.enclosingObjCont.findNode
                                          -> node[];
                                        '**** Follow link:'-> puttext;
                                        node.doPT -> putline;
                                        (if asDW.enclosingObjCont.isCompiled 
                                            then
                                            '**   isCompiled'->putline
                                         else
                                            '**   is not compiled' -> putline;
                                            L[] 
                                              -> asDW.enclosingObjCont.doCompile 
                                              -> (iMain[],errors[]);
                                            (if errors[] <> none then
                                                '!!! Syntax errors:'->putline;
                                                errors[] -> putline; 
                                                errors[] -> asDW.showErrors;
                                                leave onSelect
                                            if)
                                        if);
                                        
                                        (if node[] <> NONE then
                                            (*'follow: ' -> puttext;
                                             * node[] -> getPatternName 
                                             * -> putline;
                                             *)
                                            node.isNameApl -> followLink
                                        if);
                                     #);
                                #);
                              open::
                                (#
                                do 'Follow Link' -> name;
                                   iFollow[] -> append;
                                #);
                           #);
                         open:: 
		           (# 
                           do iFollow.open;
                              iSetBreak.open;                              
                              iSave.open; 
                           #);
                      #);                              
                    
                    handleErrors:
                      (# S: ^stream; start,end: @integer
                      enter S[]
                      do (if S[] <> none then 
                             (*S[] -> putline;*)
                             S.reset;    
                             S.getint - 1 -> start; S.getint -> end;
                             (start,end) -> contents.selection.set;
                             (* needed to high-light selection: *)
                             contents[] -> THIS(Window).target;
                         if)
                      exit S[]
                      #);
                 #);

               ErrorList: TableView
                 (# items: @Sequence
                      (# Element:: ErrorItem;
                      #);                    
                    open::
                      (#
                      do items.init;
                      #);                    
                    ErrorItem:
                      (# start: @integer;
                         end: @integer;
                         what: ^Text;
                         
                         description:
                           (# value: ^Text;
                           do what.copy -> value[];
                              ' (' -> value.puttext;
                              start -> value.putint;
                              ' to ' -> value.puttext;
                              end -> value.putint;
                              ')' -> value.puttext;
                           exit value[]
                           #);
                         range:
                           (#
                           exit (start, end)
                           #);
                      #);
                    display:
                      (# errors: ^Stream;
                         start, end: @integer;
                         what: ^Text;
                         counter: @integer;
                         item: ^ErrorItem;
                      enter errors[]
                      do (if errors[] <> NONE then
                             errors.reset;
                             loop:
                               (if NOT errors.eos then
                                   counter + 1 -> counter;
                                   errors.getint - 1 -> start;
                                   errors.getint -> end;
                                   errors.getline -> what[];
                                   &ErrorItem[] -> item[];
                                   start -> item.start;
                                   end -> item.end;
                                   what[] -> item.what[];
                                   1 -> append;
                                   (counter, item.description) -> setText;
                                   (counter, errorIcon[]) -> setImage;
                                   item[] -> items.append;
                                   restart loop;
                               if);
                         if);
                      #);
                    
                    displayError:
                      (# item: @integer;
                      enter item
                      do (# selected: ^ErrorItem;
                         do item -> items.get -> selected[];
                            selected.range 
                              -> rightEditor.contents.selection.set;
                            rightEditor.contents[] -> target;
                         #);
                      #);
                    
                    onMouseDown::
                      (#
                      do (if selection.first > 0 then
		             selection.first -> displayError;
                         if);
                      #);
                 #);
               thisIndex: @integer
            #);
          mainBrowser: ^ComponentWindow;
          placeholder: @SpaceLayout;
       #);

     breaks: @
       (# IMPs: [4] ^Tree.TopNode; top: @integer;
          clear: (# do 0 -> top #);
          add:
            (# imp: ^Tree.TopNode
            enter imp[]
            do (if (top + 1 -> top) > IMPs.range then
                   IMPs.range -> IMPS.extend
               if);
               imp[] -> IMPS[top][]
            #);
          astPos:
            (# bcPos,beginPos,endPos: @integer
            enter bcPos
            do L: (for i: top repeat
                       (if bcPos = IMPs[i].beginBCP then
                           IMPS[i].beginPos -> beginPos;
                           IMPS[i].endPos -> endPos;
                           (if false then
                               'found astPos: ' -> puttext; beginPos -> putint;
                               ',' -> put; endPos -> putint; newline;
                           if);
                           leave L
                  if)for)
            exit(beginPos,endPos)
            #);                      
       #);
     
     createExecution:<
       (# browser: ^WorldWindow.ComponentWindow;
       enter browser[]
       do &theWorldWindow.SequenceWindow[] -> execution[];
          execution.open;
          browser.navi[] -> execution.navi[];
          (if EMBEDDED then
              theWorldWindow.placeholder[] -> theWorldWindow.mainLayout.remove;
          if); 
          execution.layout[] -> theWorldWindow.mainLayout.add;
          480 -> theWorldWindow.leftLayout.width;
          theWorldWindow.mainLayout.layout;                                  
          compile[] -> execution.setCompiler;
          L[] -> execution.setLog;
          inner; (*&|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM;*)
          execution.show;
       #);     
     createStandaloneExecution:< Navigator
       (# browser: ^WorldWindow.ComponentWindow;
          standalone: @StandaloneWindow;
          showCode::
            (#
            do caller[] -> VM.selectCode;
            #);
          showDescriptor::
            (#
            do desc[] -> browser.selectDescriptor;
            #);
          showNode::
            (#
            do node[] -> browser.selectNode;
            #);
          onClose::
            (#
            do standalone.close;
               NONE -> execution[];
            #);
       enter browser[]
       do standalone.open;
          &standalone.StandaloneSequenceWindow[] -> execution[];
          execution.open;
          execution.layout[] -> standalone.mainLayout.add;
          compile[] -> execution.setCompiler;
          L[] -> execution.setLog;
          inner; (*&|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM;*)
          standalone.mainLayout.layout;
          THIS(Navigator)[] -> execution.navi[];
          execution.show;
       #);
       
     WorldVM:< theSystemEnv.BetaVM
       (# selectCode:<
            (# caller: ^ObjDesc.RunTimeObject; 
            enter caller[]
            do inner
            #)
       #);

     execution: ^Window.SequenceWindow;

     objContRoot: ^objCont.handle;       
     ObjCont: @ObjectContent;
     theWorldWindow: @WorldWindow;
     compile: ^Tree;
     VM: ^ | WorldVM;
     theSystemEnv: ^SystemEnv;
     splitToSeparateWindows,     
     embedded: @boolean; (* browser and execution pane:
                          * true : in the same window 
                          * false: in seperate windows *)
     isXbeta: @boolean;
     runMode: @integer;
     L: @log;
  #);
