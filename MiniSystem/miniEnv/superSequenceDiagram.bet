ORIGIN '~beta/postwimp/graphicscanvas/diagram'; 
INCLUDE '~beta/guienv/controls';
INCLUDE '~beta/guienv/private/datastructures/sequence';
INCLUDE '~beta/postwimp/graphicscanvas/widgets';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE 'subwindow';
INCLUDE 'objectContent';
INCLUDE 'dialogs';
INCLUDE 'reflector';
---lib:attributes---
traceVisible: (# exit false #);
useSimpleBackground: (#exit true #);
---windowLib:attributes---
dumpObj:
  (# x: ^objDesc.runTimeObject
  enter x[]
  do '"' -> put;
     (if x[] <> none then
         x.myName -> puttext;
         (if x.isObj then '/O'->puttext if)
     if);
     '"' -> put;
  #);
-- FigureCanvasLib: attributes --
SuperSequenceDiagram: Diagram
  (# doDumpEvents: @boolean;
     dumpObjs:
       (# id: ^text;
          caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject
       enter (id[],caller[], self[], origin[])
       do (if false->doDumpEvents then
              '**** ' -> puttext; id[] -> puttext;
              ' caller: ' -> puttext; caller[] -> dumpObj;
              ' self: ' -> puttext; self[] -> dumpObj;
              ' origin: ' -> puttext; origin[] -> dumpObj;
              inner;
              newline
          if)
       #);
     up: ^RichPixmap;
     res: @Resource;
     
     pc: @integer;
     repaint:
       (# where: ^Text;
       enter where[]
       do (if false then
              pc + 1 -> pc;
              'repaint : ' -> puttext;
              pc -> putint;
              ' | ' -> puttext;
              where[] -> puttext;
              newline;
          if);
          update;
       #);   
     makeColor:
       (# red, green, blue: @integer;
          theColor: ^Color;
       enter (red, green, blue)
       do &Color[] -> theColor[];
          (# r, g, b: @real;
          do red / 255.0 -> r;
             green / 255.0 -> g;
             blue / 255.0 -> b;
             r * 0xFFFF -> theColor.red;
             g * 0xFFFF -> theColor.green;
             b * 0xFFFF -> theColor.blue;
          #);
       exit theColor[]
       #);
     createSimpleBackground:
       (* colors:
        * heading = top     : Gr�: 242,242,242, Bl� : 222, 235, 247
        * atributes = bottom: Gul: 255,245,232, Gr�n: 226, 240, 217,
        *)
       (# tiles: ^TileSet;
          isObject: @boolean;
          background: ^ColumnFigure;
       enter(tiles[],isObject)
       do (if false then
              '**** createSimpleBackground:'->puttext; isobject->putboolean;
              newline;
          if);
          &Columnfigure[] -> background[];
          background.init;
          (# row: ^RowFigure;
             top,bottom: ^rectFigure;
          do &RectFigure[] -> top[];
             top.init;
             40->top.minimumWidth; 30 -> top.minimumHeight;
             res.black[] -> top.stroke;
             (if isObject then
                 (if true then (* green *)
                     (226, 240, 217) -> makeColor -> top.fill;
                  else
                     (242,242,242) -> makeColor -> top.fill;
                 if)
              else
                 (222, 235, 247) -> makeColor -> top.fill;
             if);
             true -> top.horizontallyFlexible;
             top[] -> background.add;
             
             &RectFigure[] -> bottom[];
             bottom.init;
             40->bottom.minimumWidth; 0 -> bottom.minimumHeight;
             res.black[] -> bottom.stroke;
             (226, 240, 217) -> makeColor -> bottom.fill;
             true -> bottom.horizontallyFlexible;
             true -> bottom.verticallyFlexible;
             bottom[] -> background.add;
          #);
          background.pack;
       exit background[]
       #);
     
     createBackward:
       (# backward: ^Figure;
          tip: ^Point2d;
          foot: ^Point2d;
          left: ^Point2d;
          right: ^Point2d;
          head: ^PolygonItem;
          arrow: ^Line;
       do &Figure[] -> backward[];
          backward.init;
          
          &Point2d[] -> tip[];
          0 -> tip.x;
          3 -> tip.y;
          &Point2d[] -> left[];
          6 -> left.x;
          6 -> left.y;
          &Point2d[] -> right[];
          6 -> right.x;
          0 -> right.y;
          &PolygonItem[] -> head[];
          head.init;
          left[] -> head.points.append;
          tip[] -> head.points.append;
          right[] -> head.points.append;
          res.black[] -> head.stroke[];
          1 -> head.strokeWidth;
          head[] -> backward.add;
          
          &Line[] -> arrow[];
          tip[] -> arrow.start[];
          &Point2d[] -> foot[];
          12 -> foot.x;
          3 -> foot.y;
          foot[] -> arrow.end[];
          res.black[] -> arrow.stroke[];
          1 -> arrow.strokeWidth;
          arrow[] -> backward.add;
          
          12 -> backward.minimumWidth;
          6 -> backward.minimumHeight;
       exit backward[]
       #);
     createForward:
       (# forward: ^Figure;
          tip: ^Point2d;
          foot: ^Point2d;
          left: ^Point2d;
          right: ^Point2d;
          head: ^PolygonItem;
          arrow: ^Line;
       do &Figure[] -> forward[];
          forward.init;
          
          &Point2d[] -> tip[];
          12 -> tip.x;
          3 -> tip.y;
          &Point2d[] -> left[];
          6 -> left.x;
          6 -> left.y;
          &Point2d[] -> right[];
          6 -> right.x;
          0 -> right.y;
          &PolygonItem[] -> head[];
          head.init;
          left[] -> head.points.append;
          tip[] -> head.points.append;
          right[] -> head.points.append;
          res.black[] -> head.stroke[];
          1 -> head.strokeWidth;
          head[] -> forward.add;
          
          &Line[] -> arrow[];
          tip[] -> arrow.start[];
          &Point2d[] -> foot[];
          0 -> foot.x;
          3 -> foot.y;
          foot[] -> arrow.end[];
          res.black[] -> arrow.stroke[];
          1 -> arrow.strokeWidth;
          arrow[] -> forward.add;
          
          12 -> forward.minimumWidth;
          6 -> forward.minimumHeight;
       exit forward[]
       #);
     
     createCircle:
       (# theOvalFigure: ^OvalFigure;
          fill: ^Color;
          circle: ^CenterFigure;
       enter fill[]
       do &OvalFigure[] -> theOvalFigure[];
          theOvalFigure.init;
          fill[] -> theOvalFigure.fill;
          true -> theOvalFigure.horizontallyFlexible;
          true -> theOvalFigure.verticallyFlexible;
          &CenterFigure[] -> circle[];
          circle.init;
          theOvalFigure[] -> circle.add;
          up.width -> circle.baseMinimumWidth;
          up.height -> circle.baseMinimumHeight;
          3 -> circle.margin;
       exit circle[]
       #);


     TileSet:
       (# topleft: ^RichPixmap;
          top: ^RichPixmap;
          topright: ^RichPixmap;
          left: ^RichPixmap;
          middle: ^RichPixmap;
          right: ^RichPixmap;
          bottomleft: ^RichPixmap;
          bottom: ^RichPixmap;
          bottomright: ^RichPixmap;
          
          load:
            (# name: ^Text;
            enter name[]
            do '-topleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topleft[];
               '-top.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> top[];
               '-topright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> topright[];
               '-left.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> left[];
               '-middle.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> middle[];
               '-right.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> right[];
               '-bottomleft.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomleft[];
               '-bottom.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottom[];
               '-bottomright.png' 
                 -> (name.copy).append 
                 -> loadImage 
                 -> bottomright[];
            #);
       #);
     
     loadTileSet:
       (# name: ^Text;
          tiles: ^TileSet;
       enter name[]
       do &TileSet[] -> tiles[];
          name[] -> tiles.load;
       exit tiles[]
       #);     
     createBackground:
       (# tiles: ^TileSet;
          background: ^ColumnFigure;
       enter tiles[]
       do &Columnfigure[] -> background[];
          background.init;
          (# row: ^RowFigure;
             topleft: ^ImageFigure;
             top: ^ImageFigure;
             topright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.topleft[]
               -> createImageFigure 
               -> topleft[];
             false -> topleft.horizontallyFlexible;
             false -> topleft.verticallyFlexible;
             topleft[] -> row.add;
             
             tiles.top[]
               -> createImageFigure 
               -> top[];
             true -> top.horizontallyFlexible;
             false -> top.verticallyFlexible;
             top[] -> row.add;
             
             tiles.topright[]
               -> createImageFigure 
               -> topright[];
             false -> topright.horizontallyFlexible;
             false -> topright.verticallyFlexible;
             topright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          (# row: ^RowFigure;
             left: ^ImageFigure;
             middle: ^ImageFigure;
             right: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.left[]
               -> createImageFigure 
               -> left[];
             false -> left.horizontallyFlexible;
             true -> left.verticallyFlexible;
             left[] -> row.add;
             
             tiles.middle[]
               -> createImageFigure 
               -> middle[];
             true -> middle.horizontallyFlexible;
             true -> middle.verticallyFlexible;
             middle[] -> row.add;
             
             tiles.right[]
               -> createImageFigure 
               -> right[];
             false -> right.horizontallyFlexible;
             true -> right.verticallyFlexible;
             right[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
             true -> row.verticallyFlexible;
          #);
          (# row: ^RowFigure;
             bottomleft: ^ImageFigure;
             bottom: ^ImageFigure;
             bottomright: ^ImageFigure;
          do &RowFigure[] -> row[];
             row.init;
             tiles.bottomleft[]
               -> createImageFigure 
               -> bottomleft[];
             false -> bottomleft.horizontallyFlexible;
             false -> bottomleft.verticallyFlexible;
             bottomleft[] -> row.add;
             
             tiles.bottom[]
               -> createImageFigure 
               -> bottom[];
             true -> bottom.horizontallyFlexible;
             false -> bottom.verticallyFlexible;
             bottom[] -> row.add;
             
             tiles.bottomright[]
               -> createImageFigure 
               -> bottomright[];
             false -> bottomright.horizontallyFlexible;
             false -> bottomright.verticallyFlexible;
             bottomright[] -> row.add;
             row[] -> background.add;
             true -> row.horizontallyFlexible;
          #);
          background.pack;
       exit background[]
       #);
     
     Decoration: Composite
       (# containsPoint::
            (#
            do NONE -> target[];
            #);
       #);
     createArrow:
       (# lst: ^PointList;
          dash: @boolean;
          head: ^ArrowHead;
          arrow: ^Composite;
       enter (lst[], dash)
       do (# 
          do &Decoration[] -> arrow[];
             arrow.init;   
             (# prev: ^Point2d;
             do lst.scan
                (# segment: ^Line;
                do (if prev[] <> NONE then
                       &Line[] -> segment[];
                       segment.init;
                       prev[] -> segment.start[];
                       current[] -> segment.end[];
                       1 -> segment.strokeWidth;
                       res.colors.darkerCoolBrown[] -> segment.stroke[];
                       (if dash then
                           PenDash -> segment.style;
                       if);
                       segment[] -> arrow.add;
                   if);
                   current[] -> prev[];
                #);
             #);
             
             (# start, end: ^Point2d;
             do lst.size - 1 -> lst.get -> start[];
                lst.size -> lst.get -> end[];
                &ArrowHead[] -> head[];
                head.init;
                end[] -> head.to[];
                start[] -> head.from[];
                head.refresh;
                res.colors.darkerCoolBrown[] -> head.stroke[];
                res.colors.darkerCoolBrown[] -> head.fill[];
                head[] -> arrow.add;
             #);
          #);
       exit arrow[]
       #);
     objectDescOf:
       (# desc: ^ObjDesc;
          OD: ^Tree.TopNode;
       enter desc[]
       do desc.descInx -> compiler.getObjectDesc -> OD[];
       exit OD[]
       #);
     traceM: @boolean;
     moduleOf:
       (# desc: ^ObjDesc;
          MD: ^Tree.iModule;
       enter desc[]
       do (# OD: ^Tree.TopNode;
          do desc[] -> objectDescOf -> OD[];
             (if OD[] <> none then             
                 OD.theiModule -> MD[];
                 (if traceM then
                     '**** moduleOf:' -> puttext; MD.name -> putline;
                     (* '** objDesc: ' -> putline;
                      *OD.doPt -> putline;
                      '** MD.desc: ' -> puttext; *)
                     (MD.desc->OD[]).visibility -> putint; newline;
                     (MD.desc).dopt -> putline
             if)if);
          #);
       exit MD[]
       #);    
     visibilityOf:
       (* Visibility of object module containing desc *)
       (# desc: ^ObjDesc;
          visibility: @integer;
       enter desc[]
       do (# MD: ^tree.iModule;
             OD: ^Tree.TopNode;
          do (if traceVisible then
                 '\n**** visibilityOf: ' -> puttext; desc.name[] -> puttext;
             if);
             desc[] -> objectDescOf -> OD[];
             (if traceVisible then
                 ' visibility: ' -> puttext; 
                 (if OD[] <> none then
                     OD.visibility -> putint; newline;
                  else
                     ' OD is none' -> putline
                 if);
             if);
             desc[] -> moduleOf -> MD[];
             (if MD[] <> none then
                 MD.desc -> OD[];
                 OD.visibility -> visibility;
             if)
          #);
       exit visibility
       #);
     visibleOriginOf:
       (# self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
       enter self[]
       do (if traceVisible then
              '**** visibleOriginOf: ' -> puttext; self.myName -> putline;
          if);
          self[] -> origin[];
          search:
            (if not (origin.OSDvisibility = OSDvisibility_SkipInternal) then
                (if traceVisible then
                    '**   skipInternal:no: ' -> puttext; 
                    origin.myName -> putline;
                if);
                origin.myOrigin -> origin[];
                (if origin[] <> NONE then                   
                    restart search;
                if);
             else
                (if traceVisible then
                    '**   skipInternal:yes: ' -> puttext; 
                    origin.myName -> putline
                if)
            if);          
       exit origin[]
       #);     
     displayChain:
       (# self: ^ObjDesc.RunTimeObject;
       enter self[]
       do (# current: ^ObjDesc.RunTimeObject;
          do self.myName -> puttext;
             self.myOrigin -> current[];
             loop:
               (if current[] <> NONE then
                   '<-' -> puttext;
                   current.myName -> puttext;
                   '(' -> put;
                   current.OSDvisibility -> putint;
                   ')' -> put;
                   current.myOrigin -> current[];
                   restart loop;
               if);
             newline;
          #);
       #);
     isOrigin:
       (# candidate: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          result: @boolean;
       enter (candidate[], self[])
       do (if self[] <> NONE then
              (if false then
                  '**** isOrigin: ' -> puttext; candidate.MyName -> puttext;
                  ' ' -> put; self.myName -> putline;
              if);
              (if candidate[] = self[] then
                  true -> result;
               else
                  (candidate[], self.myOrigin) -> isOrigin -> result;
              if);
          if);
       exit result
       #);     

     commonOrigin:
       (# caller: ^ObjDesc.RunTimeObject;
          self: ^ObjDesc.RunTimeObject;
          origin: ^ObjDesc.RunTimeObject;
       enter (caller[], self[])
       do (if caller[] <> NONE then
              (if false then
                  '**** commonOrigin: ' -> puttext; caller.MyName -> puttext;
                  ' ' -> put; self.myName -> putline;
              if);
              (if (caller[], self[]) -> isOrigin then
                  caller[] -> origin[];
               else
                  (caller.myOrigin, self[]) -> commonOrigin -> origin[];
              if);
          if);
       exit origin[]
       #);     
     execute:
       (# objC: ^ObjectContent.handle; isXbeta: @boolean; 
          runMode: @integer; FN: ^text
       enter(objC[],runMode,isXbeta)
       do '**** Execute: ' -> puttext;
          (*compiler.mainDescNo -> putint; ' ' ->put;*)
          (objC.theModule.inFile).name -> FN[];
          FN[] ->  putline;
          (if not VM.execute.isRunning then
              runMode -> VM.init; (* why two inits?*)
              (compiler.runtimeDescs,compiler.mainDescNo,FN[],runMode) 
                -> VM.execute.init;
              VM.execute;
              true -> stepping;
           else
              'VM is not terminated' -> putline
          if);   
       #);
     
     BreakPoint:
       (# receiver: ^ObjDesc.RunTimeObject;
          message: ^Tree.TopNode; (* ??? *)
       enter (receiver[], message[])
       exit THIS(BreakPoint)[]
       #);
     
     breaks: @Sequence
       (# element:: BreakPoint;
          
          isBreak:
            (# receiver: ^ObjDesc.RunTimeObject;
               self: ^ObjDesc.RunTimeObject;
               desc: ^ObjDesc;
               OD: ^Tree.TopNode;
               value: @boolean;
            enter (receiver[], self[])
            do self.myObjDesc -> desc[];
               desc.descInx -> compiler.getObjectDesc -> OD[];
               search: scan
                 (#
                 do (if current.message[] = OD[] then
                        (if receiver[] = current.receiver[] then
                            true -> value;
                            leave search;
                        if);
                    if);
                 #);
            exit value
            #);
       #);
     RTT: @File;  
     VM: ^| systemenv.betaVM;
     compiler: ^Tree;   
     stepping: @boolean;
  #)
