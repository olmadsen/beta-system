ORIGIN '~beta/postwimp/demo/chaos/figures';
INCLUDE '~beta/guienv/controls';
INCLUDE '~beta/guienv/utils/framer';
INCLUDE '~beta/guienv/utils/colorTable';

INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/guienv/private/datastructures/sequence';
INCLUDE '~beta/win32lib/wingdiconsts';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/systemmetrics';
INCLUDE '~beta/guienv/utils/guienvadds';
INCLUDE '~beta/postwimp/demo/chaos/widgets';

-- GUIenvLib: attributes -- 

loadImage:
  (# name: ^Text;
     image: ^RichPixmap;
  enter name[]
  do (# path: ^Text;
     do &RichPixmap[] -> image[];
        'c:\\beta\\r5.5\\postwimp\\images\\' -> path[];
        name[] -> path.append;
        path[] -> image.readAlpha;
        false -> image.transparent;
     #);
  exit image[]
  #);

-- FigureCanvasLib: Attributes --

createImageFigure:
  (# image: ^RichPixmap;
     item: ^ImageFigure;
  enter image[]
  do &ImageFigure[] -> item[];
     item.init;
     image[] -> item.content;
       exit item[]
  #);

 Construction:
       (# hSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do (#
               do &SpaceFigure[] -> space[];
                  space.init;
                  minimum -> space.minimumWidth;
                  false -> space.horizontallyFlexible;
               #);
            exit space[]
            #);
          vSpace:
            (# 
            #);
          flexHSpace:
            (# minimum: @integer;
               space: ^SpaceFigure;
            enter minimum
            do minimum -> hSpace -> space[];
               true -> space.horizontallyFlexible;
            exit space[]
            #);
          flexVSpace:
            (#
            #);
       #);


-- WindowLib: Attributes --



LayoutManager:
  (# x, y: @integer;
     width, height: @integer;
     updating: @boolean;
     init:<
       (#
       do INNER;
       #);
     position:
       (#
       enter (x, y)
       #);
     size:
       (#
       enter (width, height)
       #);
     
     layout:<
       (# changed: ^SubWindow;
       enter changed[]
       do true -> updating;
          INNER;
          false -> updating;
       #);
  #);
SimpleLayout: LayoutManager
  (# target: ^SubWindow;
     init::<
       (#
       enter target[]
       do INNER;
       #);
  #);
CompositeLayoutManager: LayoutManager
  (# children: @Sequence
       (# element:: SubWindow;
       #);
     init::<
       (#
       do children.init;
          INNER;
       #);
     add:
       (# child: ^SubWindow;
       enter child[]
       do child[] -> children.append;
          THIS(LayoutManager)[] -> child.layout[];
       #);
     remove:
       (# child: ^SubWindow;
       enter child[]
       do child[] -> children.delete;
          NONE -> child.layout[];
       #);
  #);
HorizontalLayoutManager: CompositeLayoutManager
  (# layout::
       (# sum: @integer;
          delta: @integer;
          last: ^SubWindow;
          cx, cy: @integer;
       do children.scan
          (# w, h: @integer;
          do current.size -> (w, h);
             sum + w -> sum;
             (if changed[] <> current[] then
                 current[] -> last[];
             if);
          #);
          width - sum -> delta;
          x -> cx;
          y -> cy;
          children.scan
          (# w, h: @integer;
          do (cx, cy) -> current.position;
             current.size -> (w, h);
             (if current[] = last[] then
                 w + delta -> w;
             if);
             (w, height) -> current.size;
             cx + w -> cx;
          #);
       #);
  #);

SubWindow: Canvas
  (# layout: ^LayoutManager;
     theBorderWidth: @integer;
     flexible: @boolean;
     open::<
       (# lab: ^text; T: @text;
          create::
            (#
            do WS_THICKFRAME -> windowItemStyle;
               SM_CXFRAME -> GetSystemMetrics -> theBorderWidth;
            #);
       enter lab[]
       do (12,12) -> position;
          '153 180 209 beta' -> T.putline; 
          0 -> T.setpos; 
          T[] -> CT.load(# merge::trueObject #);          
          head.open;
          (if lab[] <> NONE then
              lab[] -> head.label;
          if);
          INNER;
       #);

     onOpenClose:<
       (#
       do INNER;
       #);
     openClose: @PushButton
       (# open::
            (#
            do '^' -> label;
               (16, 16) -> size;
            #);
          eventHandler::
            (# onMouseUp::
                 (#
                 do onOpenClose;
                 #)
            #)
       #);
     Head: @Heading;
     Heading:< FigureCanvas
       (# theStyle: @TextStyle;
          theLabel: ^Text;
          
          style:
            (# 
            enter theStyle[]
            exit theStyle[]
            #);
          label:
            (#
            enter title.content
            exit title.content
            #);
          
          panel: @CenterFigure
            (# 
               refresh:
                 (# width, height: @integer;
                 do head.size -> (width, height);
                    width -> baseMinimumWidth;
                    pack;
                    'width: ' -> puttext;
                    panel.width -> putint;
                    ' ' -> put;
                    width -> putint;
                    newline;
                    
                 #);
            #);
          row: @RowFigure;
          title: @TextFigure;
          expandImage: ^RichPixmap;
          expandHiliteImage: ^RichPixmap;
          
          expandBtn: @IconButton
            (# onExpand:: (# do onOpenClose #);
               onCollapse:: (# do onOpenClose #);
            #);
          
          eventHandler::<
            (# onFrameChanged::
                 (#
                 do panel.refresh;
                 #);
               onMouseDown::<
                 (#
                 do (if false then
                        (if buttonState = 1 then
                            THIS(SubWindow).bringToFront;
                            trackMouse
                            (# mouseMove:: 
                                 (#
                                 do (h,v) -> this(SubWindow).move; 
                                    true -> this(SubWindow).update
                                 #);
                            #);
                         else
                            INNER
                        if);
                    if);
                 #);
            #);
          open::<
            (# h,w: @integer ; C: @color;
               white: ^Color;
               construct: @Construction;
            do 'Verdana' -> theStyle.name;
               8 -> theStyle.size;
               textfaces.bold -> theStyle.face;
               this(subWindow).size -> (w,h);
               (0, 0) -> position;
               (w,20) -> size;
               true -> bindRight;
               'beta' -> CT.lookup -> C -> backgroundcolor;
               panel.init;
               true -> panel.horizontallyFlexible;
               2 -> panel.margin;
               row.init;
               true -> row.horizontallyFlexible;
               row[] -> panel.add;
               
               'icons\\expand.png' -> loadImage -> expandImage[];
               'icons\\expand-hilite.png' -> loadImage -> expandHiliteImage[];
               (expandImage[] -> createImageFigure, 
               expandHiliteImage[] -> createImageFigure)
                 -> expandBtn.init;
               expandBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               
               title.init;
               'Glass Cabinet' -> title.content;
               theStyle[] -> title.style;
               &Color[] -> white[];
               white[] -> title.stroke;
               title[] -> row.add;
               INNER;
               panel.refresh;
               panel[] -> add;
               update;
            #);
          textWidth:
            (# T: ^text; width: @integer; 
            enter T[]
            do (if T[] = none then
                   'subWindow:TextWidth:T=none'->putline
                else
                   T[] -> (style).widthOfText -> width
               if)
            exit width
            #);
       #);
     width:
       (# w,h: @integer
       do size -> (w,h)
       exit w
       #);
     height:
       (# w,h: @integer
       do size -> (w,h) 
       exit h
       #);
     left: 
       (# P: @point
       do position -> P;
       exit P.H (* I am confused: P.H is the horisontal line and thus top? *)
       #);
     top: (* and vice versa?? *)
       (# P: @point
       do position -> P;
       exit P.V (* And P.V should be left and not top? *)
       #);
     
     eventHandler::<
       (# onFrameChanged::
            (#
            do (if layout[] <> NONE then
                   (if NOT layout.updating then 
                       THIS(SubWindow)[] -> layout.layout;
                   if);
               if);
            #);
       #);
     
     CT: @colorTable;
  #);
