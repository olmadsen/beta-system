ORIGIN '~beta/postwimp/graphicscanvas/figures';
INCLUDE '~beta/guienv/controls';
INCLUDE '~beta/guienv/utils/framer';
INCLUDE '~beta/guienv/utils/colorTable';

INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate';
INCLUDE '~beta/guienv/private/datastructures/sequence';
INCLUDE '~beta/win32lib/wingdiconsts';
INCLUDE '~beta/win32lib/winuserconsts';
INCLUDE '~beta/win32lib/systemmetrics';
INCLUDE '~beta/guienv/utils/guienvadds';
INCLUDE '~beta/postwimp/graphicscanvas/widgets';

-- GUIenvLib: attributes -- 

loadImage:
  (# name: ^Text;
     image: ^RichPixmap;
  enter name[]
  do (# path: ^Text;
     do &RichPixmap[] -> image[];
        'c:\\beta\\r5.5\\postwimp\\images\\' -> path[];
        name[] -> path.append;
        path[] -> image.readAlpha;
        false -> image.transparent;
     #);
  exit image[]
  #);

-- FigureCanvasLib: Attributes --

createImageFigure:
  (# image: ^RichPixmap;
     item: ^ImageFigure;
  enter image[]
  do &ImageFigure[] -> item[];
     item.init;
     image[] -> item.content;
  exit item[]
  #);

Construction:
  (# hSpace:
       (# minimum: @integer;
          space: ^SpaceFigure;
       enter minimum
       do (#
          do &SpaceFigure[] -> space[];
             space.init;
             minimum -> space.minimumWidth;
             false -> space.horizontallyFlexible;
          #);
       exit space[]
       #);
     vSpace:
       (# 
       #);
     flexHSpace:
       (# minimum: @integer;
          space: ^SpaceFigure;
       enter minimum
       do minimum -> hSpace -> space[];
          true -> space.horizontallyFlexible;
       exit space[]
       #);
     flexVSpace:
       (#
       #);
  #);


-- WindowLib: Attributes --
LOGGING: (# exit false #);

LayoutManager:
  (# owner: ^LayoutManager;
     x, y: @integer;
     width, height: @integer;
     updating: @boolean;
     init:<
       (#
       do INNER;
       #);
     position:
       (#
       enter (x, y)
       exit (x, y)
       #);
     size:
       (#
       enter (width, height)
       exit (width, height)
       #);
     
     distribute:<
       (#
       enter (x, y, width, height)
       do INNER;
       #);
     layout:<
       (# originator: ^LayoutManager;
       enter originator[]
       do true -> updating;
          (if LOGGING then
              '[layout ' -> puttext;
              description -> puttext;
              ' ' -> put;
              x -> putint;
              ' ' -> put;
              y -> putint;
              ' ' -> put;
              width -> putint;
              ' ' -> put;
              height -> putint;
              ']' -> putline;
              
          if);
          INNER;
          false -> updating;
          (if LOGGING then
              '[done ' -> puttext;
              description -> puttext;
              ']' -> putline;
          if);
       #);
     changed:<
       (# originator: ^LayoutManager;
       enter originator[]
       do (if LOGGING then
              '[changed ' -> puttext;
              description -> puttext;
              (if originator[] <> NONE then
                  ' originator: ' -> puttext;
                  originator.description -> puttext;
              if);
              ']' -> putline;
          if);
          INNER;
       #);
     description:<
       (# value: ^Text;
       do INNER;
       exit value[]
       #);
     subordinate:
       (# layout: ^LayoutManager;
          result: @boolean;
       enter layout[]
       do (if layout[] <> NONE then
              (if layout[] = THIS(LayoutManager)[] then
                  true -> result;
               else
                  layout.owner[] -> subordinate -> result;
              if);
          if);
       exit result
       #);
  #);
SpaceLayout: LayoutManager
  (# description::
       (#
       do '{space}' -> value[];
       #);
  #);
SimpleLayout: LayoutManager
  (# target: ^SubWindow;
     init::<
       (#
       enter target[]
       do INNER;
       #);
     layout::
       (# 
       do (x, y) -> target.position;
          
          (if LOGGING then
              '[size ' -> puttext;
              description -> puttext;
              width -> putint;
              ' ' -> put;
              height -> putint;
              ']' -> puttext;
              newline;
          if);
          (width, height) -> target.size;
          (if LOGGING then
              (# w, h: @integer;
              do target.size -> (w, h);
                 '[setto ' -> puttext;
                 description -> puttext;
                 w -> putint;
                 ' ' -> put;
                 h -> putint;
                 ']' -> puttext;
                 newline;
              #);
          if);
       #);
     changed::
       (#
       do (if target[] <> NONE then
              target.position -> (x, y);
              target.size -> (width, height);
          if);
          (if owner[] <> NONE then
              THIS(SimpleLayout)[] -> owner.changed;
          if);
       #);
     description::
       (#
       do &Text[] -> value[];
          '{layout ' -> value.puttext;
          (if target[] <> NONE then
              target.description -> value.puttext;
           else
              'NONE' -> value.puttext;
          if);
          '}' -> value.puttext;
       #);
  #);
CompositeLayoutManager: LayoutManager
  (# children: @Sequence
       (# element:: LayoutManager;
       #);
     init::<
       (#
       do children.init;
          INNER;
       #);
     add:
       (# child: ^LayoutManager;
       enter child[]
       do child[] -> children.append;
          THIS(LayoutManager)[] -> child.owner[];
       #);
     remove:
       (# child: ^LayoutManager;
       enter child[]
       do child[] -> children.delete;
          NONE -> child.owner[];
       #);
  #);
HorizontalLayoutManager: CompositeLayoutManager
  (# layout::
       (# sum: @integer;
          delta: @integer;
          last: ^LayoutManager;
          cx, cy: @integer;
       do children.scan
          (# w, h: @integer;
          do current.size -> (w, h);
             sum + w -> sum;
             (if not (originator[] -> current.subordinate) then
                 current[] -> last[];
             if);
          #);
          width - sum -> delta;
          x -> cx;
          y -> cy;
          children.scan
          (# w, h: @integer;
          do (cx, cy) -> current.position;
             current.size -> (w, h);
             (if current[] = last[] then
                 w + delta -> w;
             if);
             (if not (originator[] -> current.subordinate) then
                 (w, height) -> current.size;
             if);
             cx + w -> cx;
             originator[] -> current.layout;
          #);
       #);
     changed::<
       (#
       do (if originator.owner[] = THIS(LayoutManager)[] then
              originator.height -> height;
          if);
          (if owner[] <> NONE then
              originator[] -> owner.changed;
           else
              originator[] -> layout;
          if);
	  INNER;
       #);
     description::
       (#
       do &Text[] -> value[];
          '{row ' -> value.puttext;
          children.size -> value.putint;
          '}' -> value.puttext;
       #);
  #);
VerticalLayoutManager: CompositeLayoutManager
  (# layout::
       (# sum: @integer;
          delta: @integer;
          last: ^LayoutManager;
          cx, cy: @integer;
       do children.scan
          (# w, h: @integer;
          do current.size -> (w, h);
             sum + h -> sum;
             (if not (originator[] -> current.subordinate) then
                 current[] -> last[];
             if);
          #);
          height - sum -> delta;
          x -> cx;
          y -> cy;
          children.scan
          (# w, h: @integer;
          do (cx, cy) -> current.position;
             current.size -> (w, h);
             (if current[] = last[] then
                 h + delta -> h;
             if);
             (if not (originator[] -> current.subordinate) then
                 (width, h) -> current.size;
             if);
             cy + h -> cy;
             originator[] -> current.layout;
          #);
       #);
      changed::
       (#
       do (if originator.owner[] = THIS(LayoutManager)[] then
              originator.width -> width;
          if);
          (if owner[] <> NONE then
              originator[] -> owner.changed;
           else
              originator[] -> layout;
          if);
       #);
      description::
       (#
       do &Text[] -> value[];
          '{column ' -> value.puttext;
          children.size -> value.putint;
          '}' -> value.puttext;
       #);
  #);

SubWindow: Canvas
  (# layout: @SimpleLayout;;
     theBorderWidth: @integer;
     flexible: @boolean;
     
     navigation:<
       (# value: @boolean;
       do INNER;
       exit value
       #);
     
     open::<
       (# lab: ^text; T: @text;
          create::<
            (#
            do (***WS_THICKFRAME -> windowItemStyle;
                SM_CXFRAME -> GetSystemMetrics -> theBorderWidth;***)
               true -> flexible;
               INNER;
            #);
          width, height: @integer;
       enter lab[]
       do (12,12) -> position;
          2 -> theBorderWidth;
          '153 180 209 beta' -> T.putline; 
          0 -> T.setpos; 
          T[] -> CT.load(# merge::trueObject #);          
          head.open;
          (if lab[] <> NONE then
              lab[] -> head.label;
          if);
          THIS(SubWindow)[] -> layout.init;
	 
	  true -> border.visible;
          borderStyles.shadowOut -> border.style;
          
          grow.open;
          size -> (width, height);
          (16, 16) -> grow.size;
          (width - 20, height - 20) -> grow.position;
          false -> grow.bindLeft;
          false -> grow.bindTop;
          true -> grow.bindRight;
          true -> grow.bindBottom;
          (if not flexible then
              grow.hide;
          if);
          INNER;
       #);

     onOpenClose:<
       (#
       do INNER;
       #);
     onExpand:<
       (#
       do INNER;
       #);
     onCollapse:<
       (#
       do INNER;
       #);
     onBack:<
       (# 
       do INNER;
       #);
     onForward:<
       (#
       do INNER;
       #);
     
     
     GrowBox: FigureCanvas
       (# growImage: ^RichPixmap;
          image: ^ImageFigure;
          open::<
            (#
            do THIS(Canvas).backgroundColor -> backgroundColor;
               'icons\\grow.png' -> loadImage -> growImage[];
               growImage[] -> createImageFigure -> image[] -> add;
               image.pack;
               INNER;
            #);
       #);
     
     grow: @GrowBox
       (# open::
            (#
            do 
            #);
          eventHandler::
            (# onMouseDown::
                 (# width, height: @integer;
                 do THIS(SubWindow).size -> (width, height);
                    trackMouse
                      (# mouseMove::
                           (#
                           do width + h -> width;
                              height + v -> height;
                              (width, height) -> THIS(SubWindow).size;
                              true -> THIS(Window).update;
                           #);
                      #);
                 #);
            #);
       #);
     Head: @Heading;
     Heading:< FigureCanvas
       (# theStyle: @TextStyle;
          
          style:
            (# 
            enter theStyle[]
            exit theStyle[]
            #);
          label:
            (#
            enter title.content
            exit title.content
            #);
          
          panel: @CenterFigure
            (# 
               refresh:
                 (# width, height: @integer;
                 do head.size -> (width, height);
                    width -> baseMinimumWidth;
                    height -> baseMinimumHeight;
                    pack;
                 #);
            #);
          row: @RowFigure;
          title: @TextFigure;
          expandImage: ^RichPixmap;
          expandHiliteImage: ^RichPixmap;
          
          expandBtn: @IconButton
            (# onExpand:: (# do onOpenClose #);
               onCollapse:: (# do onOpenClose #);
            #);
          
          minimizeImage: ^RichPixmap;
          minimizeHiliteImage: ^RichPixmap;
          maximizeImage: ^RichPixmap;
          maximizeHiliteImage: ^RichPixmap;
          
          miniBtn: @Toggler
            (# onExpand::
                 (#
                 do THIS(SubWindow).onExpand;
                 #);
               onCollapse::
                 (#
                 do THIS(SubWindow).onCollapse;
                 #);
            #);
          backBtn: @Toggler
            (# onExpand::
                 (#
                 do THIS(SubWindow).onBack;
                 #);
               onCollapse::
                 (#
                 do THIS(SubWindow).onBack;
                 #);
            #);
          forwardBtn: @Toggler
            (# onExpand::
                 (#
                 do THIS(SubWindow).onForward;
                 #);
               onCollapse::
                 (#
                 do THIS(SubWindow).onForward;
                 #);
            #);
          
          eventHandler::<
            (# onFrameChanged::
                 (#
                 do panel.refresh;
                 #);
               onMouseDown::<
                 (#
                 do (if false then
                        (if buttonState = 1 then
                            THIS(SubWindow).bringToFront;
                            trackMouse
                            (# mouseMove:: 
                                 (#
                                 do (h,v) -> this(SubWindow).move; 
                                    true -> this(SubWindow).update
                                 #);
                            #);
                         else
                            INNER
                        if);
                    if);
                 #);
            #);
          open::<
            (# h,w: @integer ; C: @color;
               white: ^Color;
               construct: @Construction;
            do 'Verdana' -> theStyle.name;
               8 -> theStyle.size;
               textfaces.bold -> theStyle.face;
               this(subWindow).size -> (w,h);
               (theBorderWidth, theBorderWidth) -> position;
               (w - theBorderWidth * 2, 20) -> size;
               true -> bindRight;
               'beta' -> CT.lookup -> C -> backgroundcolor;
               panel.init;
               true -> panel.horizontallyFlexible;
               2 -> panel.margin;
               row.init;
               true -> row.horizontallyFlexible;
               row[] -> panel.add;
               
               'icons\\expand.png' -> loadImage -> expandImage[];
               'icons\\expand-hilite.png' -> loadImage -> expandHiliteImage[];
               (expandImage[] -> createImageFigure, 
               expandHiliteImage[] -> createImageFigure)
                 -> expandBtn.init;
               expandBtn[] -> row.add;
               8 -> construct.hSpace -> row.add;
               
               (if navigation then
                   (#
                      backImage: ^RichPixmap;
                      back: ^ImageFigure;
                      backHiliteImage: ^RichPixmap;
                      backHilite: ^ImageFigure;
                   do 'icons\\naviback.png' -> loadImage -> backImage[];
                      'icons\\naviback-hilite.png' -> loadImage -> backHiliteImage[];
                      backImage[] -> createImageFigure -> back[];
                      backHiliteImage[] -> createImageFigure -> backHilite[];
                      (back[], backHilite[], back[], backHilite[])
                        -> backBtn.init;
                      backBtn[] -> row.add;
                      8 -> construct.HSpace -> row.add;
                   #);
                   (#
                      forwardImage: ^RichPixmap;
                      forward: ^ImageFigure;
                      forwardHiliteImage: ^RichPixmap;
                      forwardHilite: ^ImageFigure;
                   do 'icons\\naviforward.png' -> loadImage -> forwardImage[];
                      'icons\\naviforward-hilite.png' -> loadImage -> forwardHiliteImage[];
                      forwardImage[] -> createImageFigure -> forward[];
                      forwardHiliteImage[] -> createImageFigure -> forwardHilite[];
                      (forward[], forwardHilite[], forward[], forwardHilite[])
                        -> forwardBtn.init;
                      forwardBtn[] -> row.add;
                      8 -> construct.HSpace -> row.add;
                   #);
               if);
               
               title.init;
               'Glass Cabinet' -> title.content;
               theStyle[] -> title.style;
               &Color[] -> white[];
               white[] -> title.stroke;
               title[] -> row.add;
               INNER;
               (if flexible then
                   (# minimize: ^ImageFigure;
                      minimizeHilite: ^ImageFigure;
                      maximize: ^ImageFigure;
                      maximizeHilite: ^ImageFigure;
                     
                   do 
                      'icons\\minimize.png' -> loadImage -> minimizeImage[];
                      'icons\\minimize-hilite.png' -> loadImage -> minimizeHiliteImage[];
                      'icons\\maximize.png' -> loadImage -> maximizeImage[];
                      'icons\\maximize-hilite.png' -> loadImage -> maximizeHiliteImage[];
                      minimizeImage[] -> createImageFigure -> minimize[];
                      minimizeHiliteImage[] -> createImageFigure -> minimizeHilite[];
                      maximizeImage[] -> createImageFigure -> maximize[];
                      maximizeHiliteImage[] -> createImageFigure -> maximizeHilite[];
                      true -> miniBtn.on;
                      (minimize[], minimizeHilite[], maximize[], maximizeHilite[])
                        -> miniBtn.init;
                      8 -> construct.flexHSpace -> row.add;
                      miniBtn[] -> row.add;
                      
                   #);
               if);
               panel.refresh;
               panel[] -> add;
               update;
            #);
          textWidth:
            (# T: ^text; width: @integer; 
            enter T[]
            do (if T[] = none then
                   'subWindow:TextWidth:T=none'->putline
                else
                   T[] -> (style).widthOfText -> width
               if)
            exit width
            #);
       #);
     width:
       (# w,h: @integer
       do size -> (w,h)
       exit w
       #);
     height:
       (# w,h: @integer
       do size -> (w,h) 
       exit h
       #);
     left: 
       (# P: @point
       do position -> P;
       exit P.H (* I am confused: P.H is the horisontal line and thus top? *)
       #);
     top: (* and vice versa?? *)
       (# P: @point
       do position -> P;
       exit P.V (* And P.V should be left and not top? *)
       #);
     
     eventHandler::<
       (# onFrameChanged::
            (#
            do (if layout[] <> NONE then
                   (if NOT layout.updating then
                       layout.changed;
                   if);
               if);
            #);
       #);
     
     description:<
       (# value: ^Text;
       do &Text[] -> value[];
          '(window "' -> value.puttext;
          head.label -> value.puttext;
          '")' -> value.puttext;
          INNER;
       exit value[]
       #);
     CT: @colorTable;
  #);
