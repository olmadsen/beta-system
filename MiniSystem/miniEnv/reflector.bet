ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'objectContent';

-- lib: attributes --

SKIP_INTERNAL: (# exit false #);

Pattern:
  (# desc: ^ObjDesc;
     hasDo:
       (#
       exit true
       #);
  #);

ObjectReflector:
  (# template: ^ObjDesc.RunTimeObject;
     struct: ^Pattern;
     compiler: ^Tree;
     init:
       (# theTemplate: ^ObjDesc.RunTimeObject;
       enter(compiler[],theTemplate[])
       do theTemplate[] -> THIS(ObjectReflector).template[];
          &Pattern[] -> struct[];
       #);
     name:
       (# string: ^Text;
       do template.myName -> string[];
       exit string[]
       #);
     desc:
       (# value: ^ObjDesc;
       do struct.desc[] -> value[];
       exit value[]
       #);
     ori:
       (# origin: ^ObjectReflector;
       do 
       exit origin[]
       #);
     descriptionOf:
       (# template: ^ObjDesc.RunTimeObject;
          description: ^Text;
       enter template[]
       do (# name: ^Text;
             ch: @char;
          do template.myName -> name[];
             (if name.length < 0 then
                 1 -> name.inxGet -> ch;
                 (if ch//'a'//'A'//'e'//'E'//'i'//'I'//'o'//'O'//'u'//'U' then
                     'an ' -> description[];
                  else
                     'a ' -> description[];
                 if);
                 name[] -> description.append;
             if);
          #);
       exit description[]
       #);
     collectSimples:
       (# compiler: ^Tree; 
          simples: ^AttributeList;
          addSimple: compiler.SimpleCollector
            (# simple: ^AttributeReflector;               
            do &AttributeReflector[] -> simple[];
               (name[], off, kind, dcl[]) -> simple.init;
               simple[] -> simples.append;
            #);
       enter compiler[]
       do (# OD: ^Tree.TopNode;
          do &AttributeList[] -> simples[]; 
             (if false then
                 '**** collectSimples: ' ->puttext;  template.myDescInx->putint;
             if);
             template.myDescInx -> compiler.getObjectDesc -> OD[];
             (if false then OD.dopt->putline; if);
             (if OD[] <> NONE then
                 addSimple## -> OD.collectSimple
             if)
          #);
       exit simples[]
       #);

     AttributeList: List
       (# Element:: AttributeReflector;
       #);

     AttributeReflector:
       (# dcl: ^Tree.TopNode;
          theName: ^Text;
          offset: @integer;
          kind: @integer;
          init:
            (#
            enter (theName[], offset, kind, dcl[])
            do 
            #);
          owner:
            (# exit THIS(ObjectReflector)[] #);
          name:
            (#
            do 
            exit theName[]
            #);
          reference:
            (# other: ^ObjDesc.RunTimeObject;
            do (if (kind = compiler.ReferenceKind) and (offset > 0) then
                   (*template.rfields[offset][] -> other[];*)
                   offset -> template.rget -> other[];
               if);
            exit other[]
            #);
          description:
            (# str: ^Text;
            do theName.copy -> str[];
            exit str[]
            #);
          equal:
            (# other: ^AttributeReflector;
               result: @boolean;
            enter other[]
            do (other.kind = kind) AND (other.offset = offset) 
                 -> result;
            exit result
            #);
          textValue:
            (# theDescription: ^Text;
            do (# obj: ^ObjDesc.RunTimeObject;
                  value: @integer;
               do '' -> theDescription[];
                  (if kind = compiler.StringKind then
                      '\n*** textValue:off: ' -> puttext; offset -> putint;
                      ' kind: ' -> puttext; kind -> putint; newline; 
                      dcl.dopt -> putline
                  if);
                  (if offset > 0 then
                      (if kind
                       // compiler.SimpleKind then
                          offset -> template.get -> theDescription.putint;
                       // compiler.RepetionKind then
                          (# n: @integer;
                          do offset -> template.get -> n;
                             '**** repetition:'->puttext; n -> putint; newline;
                             (if n > 32 then
                                 32 -> n;
                             if);
                             (for i: n repeat
                                  offset + i -> template.get -> value;
                                  (*value -> putint; ' ' -> put;*)
                                  (if (value >= 32) AND (value <= 128) then
                                      value -> theDescription.put;
                                  if);
                             for);
                          #);
                       // compiler.StringKind then
                          (# S: @Text; V: @integer
                          do '**** String:'->puttext; 
                             offset ->  template.rget -> obj[];
                             (if obj[] = none then
                                 'none' -> theDescription.putText
                              else
                                 newline;
                                 '"' -> S.put;
                                 (for i: (2 -> obj.get) repeat 
                                      i + 2 -> obj.get -> V -> S.put;
                                 for);
                                 '"' -> S.put;
                                 S[] -> theDescription.puttext
                             if)
                          #)
                       // compiler.ReferenceKind then 
                          (*template.rfields[offset][] -> obj[];*)
                          (*'**** referenceKind:'->puttext; offset -> putint;
                           * newline; (template.myObjDesc).myid->putline;
                           *)
                          offset ->  template.rget -> obj[];
                          (if obj[] = none then
                              'none' -> theDescription.putText;
                           else
                              (# name: ^Text;
                              do 
                                 obj.myName -> name[];
                                 (if name[] <> NONE then
                                     name[] -> theDescription.putText;
                                  else 
                                     '   ' -> theDescription.putText;
                                 if);
                              #);
                          if);
                       // compiler.FloatKind then
                          (# f1,f2: @integer; val: @real
                          do offset -> template.get -> f1;
                             offset + 1 -> template.get -> f2;
                             f1 %putLongAT (@@val);
                             f2 %putLongAt (@@val + 4);
                             (* The  format for real below is for 
                              * the bank system example for OOPM
                              * We need a general solution
                              *)
                             val -> theDescription.putReal
                             (#do noexp->style; 2 -> precision #)
                          #)
                       (*else
                          '!!!! reflector:textValue:Unknown kind: ' -> puttext;
                          kind -> putint; newline;*)
                      if)            
                   else (* pattern *)
                      '  ' -> theDescription.puttext;
                  if);
               #);
               (if theDescription.length = 0 then
                   '   ' -> theDescription.puttext;
               if);
            exit theDescription[]
            #);               
       #);
  #);


Navigator:
  (# showCode:<
       (# caller: ^objDesc.RunTimeObject;
       enter caller[]
       do INNER;
       #);
     showDescriptor:<
       (# desc: ^ObjDesc;
       enter desc[]
       do INNER;
       #);
     showNode:<
       (# node: ^Tree.TopNode;;
       enter node[]
       do INNER;
       #);
     onClose:<
       (# do INNER #);
  do INNER;
  #);

