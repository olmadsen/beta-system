ORIGIN '~beta/guienv/guienv';
INCLUDE 'worldWindow';
---guienvlib:attributes---
(* Structure of qenv, env for qbeta, minienv is a similar env for Beta
  -------------------------------------------------------------------- 
 World: SuperWorld                             worldWindow.bet 
      SequenceDiagram:	                       sequencedigram.bet
  	 onAlloc: ...
         onDo: ...
         ...
      SequenceCanvas:                          sequencecanvas.bet
         sequence: @ SequenceDiagram;
	 onAlloc: ... sequence.onAlloc
         onDo 
         ...
      SequenceWindow:
         interior: @ SequenceCanvas ...
         onAlloc: ... interior.onAlloc
         onDo: ... interior.onDo
         ...
      execution: ^Window.SequenceWindow;        worldWindow.bet

      TopLevelWindow: Window ...
      StandaloneWindow: TopLevelWindow ...
      WorldWindow: TopLevelWindiw ...

      WorldVM:< theSystemEnv.BetaVM ...

      ObjCont: @ObjectContent;
      theWorldWindow: @WorldWindow;
      compile: ^Tree;
      VM: ^ | WorldVM;
      theSystemEnv: ^SystemEnv;
      objContRoot: ^objCont.handle;

   WorldWithVM: World                           worldWithVM.bet
      WorldVM::
         onAlloc:: ... execution.doAlloc ...
         onDo:: ... execution.doAlloc ...
         ...
       ...
       init(theSystemEnv[],compile[],...):
          ... &|WorldVM[] -> VM[]; 
          ... iRootModule -> OnjCont.handle -> objContRoot[];
          ... theWorldWindow.open

   qenv:  SystemEnv                             qenv.bet
      myWindowEnv: @ GUIenv
         theWorld: @WorldWithVM
         (this(SystemEnv)[],compile[],...) -> theWorld.init
      compile: @Generator -- the qbeta compiler
 *)



worldWithVM: World
  (# createStandaloneExecution:: 
       (#
       do &|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM;
       #);
     createExecution:: 
       (#
       do &|worldVM[] -> VM[] -> objCont.VM[] -> execution.setVM; 
       #);
     
     WorldVM::
       (# selectCode::
            (* Select the calling location in caller *)
            (# 
            do (# desc: ^Tree.TopNode;
                  descNo, lsc,beginPos,endPos: @integer; llx: ^text; i: @integer
               do (if traceSelect then
                      '\n**** WorldVM:SelectCode:caller:' -> puttext;
                      caller.myName -> puttext;
                      ' descInx:' -> puttext; caller.myDescInx-> putint; 
                      ' lsc:'->puttext; 
                      (if caller.myLscTop > 0 then 
                          caller.myLsc -> putint else '?'->put;
                  if)if);
                  
                  (if caller.myLscTop > 0 then (* preliminary hack *)
                      (if caller.myDescInx = compile.mainDescNo then 
                          (* do we need this *)
                          caller.myDescInx -> descNo;
                          caller.myLsc -> lsc
                       else
                          (* descNo of caller and lsc of return point *)
                          caller.topReturn -> (descNo,lsc)
                      if);
                      (if traceSelect then
                          ' return:DescNo:' -> puttext; descNo -> putint; 
                          ' return:lsc:' -> puttext; lsc -> putint; 
                      if);
                      descNo -> compile.getObjectDesc -> desc[];
                      (if traceSelect then
                          '\nlabel: ' -> puttext; desc.label -> puttext;
                          ' beginBCP:' -> puttext; desc.beginBCP -> putint;
                          ' endBCP:' -> puttext; desc.endBCP -> putint; newline;
                          (if false then
                              L:
                                desc.scanSons
                                (# i: @integer
                                do (if (i + 1 -> i) > 5 then
                                       '...\n'->puttext; leave L if);
                                   current.label -> puttext; ' '-> put;
                                   current.beginBCP -> putint; ' ' -> put;
                                   current.endBCP -> putint; newline;
                          #)if);
                          desc.doPT -> putheadN
                      if);
                      true -> desc.doPT; 
                      (if desc.father[] <> none then
                          (* OBS! true is needed to update charPos in desc *)
                          true -> desc.father.doPT -> llx[];
                       else
                          '**** desc.father is none'->putline
                      if);

                      lsc 
                        -> desc.doMapBCposToCharRange 
                        -> (beginPos,endPos);
                      (if caller.myDescInx = compile.mainDescNo then
                          '**** main'->putline;
                          caller.myDescInx -> descNo 
                       else 
                          (desc[],beginPos,endPos)
                            -> desc.father.adjustForSingularImp
                            -> (desc[],beginPos,endPos);
                          desc.getDescNo -> descNo
                      if);
                      (if traceSelect then
                          '**** CharRange:Pos: ' -> puttext; beginpos -> putint;
                          ',' -> put; endPos -> putint; 
                          ' new:descNo: ' -> puttext; descNo -> putint;  
                          newline;
                          '**** selection: ' -> puttext;
                          (if (beginPos > 0) and (llx.length > endPos) then
                              beginPos -> i;
                              L:
                                (if i <= endPos then
                                    i -> llx.inxget -> put; i + 1 -> i;
                                    restart L
                                if);
                              newline;
                           else
                              '**** beginPos/endPos are not within llx!'
                                ->putline
                      if)if);
                      (* Select and highlight calling location in caller!
                       * selectDesc also calls doMapBCposToCharRange as above
                       * so some kind of redundancy!?
                       *)
                      (caller[], descNo,&intList[], desc[], lsc)
                        -> THIS(World).selectDesc;
                  if);
               #);
               (if traceSelect then
                   '**** worldVM:selectCode:end:'->putline
               if)
            #);
          putCh:: (# do ch -> execution.put #);
          getCh:: (# do execution.get -> ch #);
          dump:
            (# x: ^objDesc.runTimeObject
            enter x[]
            do '"' -> put;
               (if x[] <> none then
                   x.myName -> puttext;
                   (if x.isObj then '/O'->puttext if)
               if);
               '"' -> put;
            #);
          doDumpEvents: @boolean;
          dumpEvent:
            (# E: ^text; caller,thisObj,org: ^objDesc.runTimeObject;
               bcPos: @integer; isObj,isIndexed: @boolean
            enter(E[],caller[],thisObj[],org[],bcPos,isObj,isIndexed)
            do (if true->doDumpEvents then
                   'Event:' -> puttext; E[] -> puttext; 
                   ':caller:'->puttext; caller[] -> dump; 
                   ' this:' -> puttext; thisObj[] -> dump; 
                   ' this.origin:' -> puttext; org[] -> dump;
                   ' this.bcPos:' -> puttext; bcpos -> putint; 
                   (if isObj then ',this.isObj'->puttext if);
                   (if isIndexed then ',isIndexed'->puttext if);
                   newline
               if)
            #);
          startEvent::
            (#
            do ('start',caller[],thisObj[],org[],bcpos,false,false) 
                 -> dumpEvent;
               (if (caller[], thisObj[], org[], bcpos) -> execution.onStart then
                   (*' :doPause:TRUE' -> puttext;*)
                   doPause;
               if);
            #);
          allocEvent::
            (* caller invokes thisObj with origin org
             * bcPos is the adr. of the allocEventQ byte code 
             * and not of the the point in caller invoking thisObj
             *)
            (#
            do (*(if thisObj.OSDvisibility > 0 then true -> doDumpEvents if);*)
               ('alloc',caller[],thisObj[],org[],bcpos,isObj,isIndexed)
                 -> dumpEvent;
               (if ((caller[],thisObj[],org[],bcpos,isObj,isIndexed) 
                     -> execution.onAlloc) then
                   (* '**** AllocEvent:Pause' -> putline;*)
                   caller[] -> selectCode;
                   doPause;
                else
                   (* '**** AllocEvent:noPause' -> putline;*)
               if);
            #);
          doEvent::
            (#
            do ('do',caller[],thisObj[],org[],bcpos,false,false) -> dumpEvent;
               (if preemptive then 'P' -> put if);

               (if (caller[], thisObj[], org[], bcpos, preemptive) 
                     -> execution.onDo then
                   (* '**** doEvent:Pause' -> putline; *)
                   caller[] -> selectCode;
                   (* '**** doEvent:after:selectCode' -> putline; *)
                   doPause;
                else
                   (*'**** doEvent:noPause'->putline;*)
               if);
            #);
          doExitEvent::
            (#
            do 
            #);
          rtnEvent::
            (#
            do ('rtn',caller[],thisObj[],org[],bcpos,false,false) -> dumpEvent;
               (if (caller[],thisObj[],org[],bcpos) -> execution.onReturn then
                   (*'**** rtnEvent:Pause\n' -> puttext;*)
                   caller[] -> selectCode;
                   doPause;
                else
                   (*'**** rtnEvent:noPause:\n' -> puttext;*)
               if);
            #);
          rtnAllocEvent::
            (#
            do ('rtnAlloc',caller[],thisObj[],org[],bcpos,false,false) 
                 -> dumpEvent;
               (if (caller[],thisObj[],org[],bcpos) -> execution.onReturnAlloc then
                   (*'**** rtnAllocEvent:Pause\n' -> puttext;*)
                   caller[] -> selectCode;
                   doPause;
                else
                   (*'**** rtnAllocEvent:noPause:\n' -> puttext;*)
               if);
            #);
          
          breakEvent::
            (# path: ^intList;
               beginPos,endPos: @integer
            do (if (caller[], thisObj[], org[], bcpos) -> execution.onBreak then
                   (* ' :doPause:TRUE' -> puttext;*)
                   bcPos -> breaks.astPos -> (beginPos,endPos);
                   &intList[] -> path[];
                   (thisObj[],thisObj.myDescInx,path[],beginPos,endPos)
                     -> THIS(World).selectCode;
                   doPause;
               if);
            #);
          display:
            (# event: ^text;
               push,popRstack: @boolean;
               from,to: ^ObjDesc.RunTimeObject; off: @integer; attNM: ^text; 
               isIndexed: @boolean; inx: @integer;
               offIsZero:< (# do inner #);
               field:
                 (# 
                 do ' field: "' -> puttext; attNM[] -> puttext; 
                    (if isIndexed then
                        '[' -> put; inx -> putint; ']' -> put
                    if);
                    '"' -> put;
                    ' off: ' -> puttext; off -> putint;
                 #);
               
            enter(event[],push,from[],popRstack,to[],off,attNM[],isIndexed,inx)
            do event[] -> puttext; 
               (if push then
                   'From: "' -> puttext; from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   (if off = 0 then
                       offIsZero
                    else
                       field
                   if);
                   inner;                       
                   ' push on: "' -> puttext; to.myName -> puttext; '"' -> put;
                else
                   'Pop from: "' -> puttext; from.myName -> puttext; '"' -> put;
                   (if popRstack then '(on rStack)' -> puttext if);
                   inner;
                   ' store at: "' -> puttext; to.myName -> puttext; '"' -> put;
                   (if off = 0 then
                       offIsZero
                    else
                       field
               if)if);
               newline
            #);
          vDisplay: display
            (# offIsZero::(# do ' const:' -> puttext #);
               value: @integer;               
            enter value
            do ' value: ' -> puttext; value -> putint; 
            #);
          rDisplay: display
            (# offisZero:: (# do ' this:' -> puttext #);
               refValue: ^ObjDesc.RunTimeObject
            enter refValue[]
            do ' ref: ' -> puttext; refValue.myName -> puttext
            #);
          vPushEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) 
                     -> execution.onVPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          vStoreEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, value) 
                     -> execution.onVStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rPushEvent::
            (#
            do 
               (if (from[], popRstack, to[], off, refValue[]) 
                     -> execution.onRPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          rStoreEvent::
            (#
            do 
               (if (from[], popRstack, to[], off, refValue[]) 
                     -> execution.onRStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          fPushEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, fValue) 
                     -> execution.onFPush then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          fStoreEvent::
            (#
            do (if (from[], popRStack, to[], off, isIndexed, inx, fValue) 
                     -> execution.onFStore then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          suspendEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, preemptive) 
                     -> execution.onSuspend then
                   caller[] -> selectCode;
                   doPause;
               if); 
            #);
          resumeEvent::
            (#
            do (if (caller[], thisObj[], org[], bcpos, preemptive) 
                     -> execution.onResume then
                   caller[] -> selectCode;
                   doPause;
               if);
            #);
          binOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onBinOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          unOpEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onUnOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          fBinOpEvent::
            (#
            do (if (operator[], fValue, to[]) -> execution.onBinOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          fUnOpEvent::
            (#
            do (if (operator[], fValue, to[]) -> execution.onUnOp then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          jmpGTevent::
            (#
            do (if (operator[], value, to[]) -> execution.onJmpGT then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          popEvent::
            (#
            do (if (operator[], value, to[]) -> execution.onPop then
                   thisStack[] -> selectCode;
                   suspend;
               if);
            #);
          errorEvent::
            (# mb: @MessageBox; path: ^intlist;
               descNo,objId,lsc,beginPos,endPos: @integer;
               desc: ^Tree.TopNode
            do '\n**** WorldWindow:errorEvent:descInx:' -> puttext;
               (if false then
                   thisObj[] -> selectCode;
                else
                   &intList[] -> path[];
                   msg.reset;
                   msg.getint -> descNo -> putint;
                   ' myDescInx: ' -> puttext;
                   thisObj.myDescInx -> putint;
                   msg.getint -> objId;
                   ' lsc: ' -> puttext;
                   msg.getint -> lsc -> putint;
                   '\n**    bcPos: ' -> puttext; bcPos -> putint;
                   descNo -> compile.getObjectDesc -> desc[];
                   true -> desc.doPT;
                   true -> desc.father.doPT;
                    lsc 
                     -> desc.doMapBCposToCharRange 
                     -> (beginPos,endPos);
                   ' beginPos: ' -> puttext; beginPos -> putint;
                   ' endPos: ' -> puttext; endPos -> putint;
                   (desc[],beginPos,endPos)
                     -> desc.father.adjustForSingularImp_X
                     -> (desc[],beginPos,endPos);
                   ' beginPos_adjust: ' -> puttext; beginPos -> putint;
                   ' endPos_adjust: ' -> puttext; endPos -> putint;

                   desc.getDescNo -> descNo;
                   (if false then
                       (thisObj[], descNo,&intList[], desc[], lsc)
                         -> THIS(World).selectDesc;
                    else
                       (thisObj[],descNo,path[],beginPos,endPos)
                         -> THIS(World).selectCode;
                   if)
               if);
               msg[] -> execution.onError;
               (if true then
                   msg.scanAll(# do ch -> execution.put #)
                else
                   msg[] -> mb.init;
               if);
               suspend
            #)
       #);
   init:
     (# BetaWorld,fileExt,arg,FN,errors: ^text; iMain: ^compile.IModule;
     enter(theSystemEnv[],compile[],BetaWorld[],fileExt[],isXbeta)
     do 'BETA MiniEnv - SVN version' -> puttext; 
        2 -> arguments -> arg[];
        run_Beta_INT -> runMode;
        (if (arg[] <> none) then 
            arg[] -> puttext;
            (if true
             // ('-c' -> arg.equal) then
                run_C_INT -> runMode 
             // ('-C' -> arg.equal) then
                save_BC_Image -> runMode 
            if)
        if);

        &|WorldVM[] -> VM[];
        (BetaWorld[],fileExt[],'.xbeta') -> compile.initDirectoryModules;
        ('minienv..log',false) -> L.open;
        (compile[],VM[],L[]) -> ObjCont.init;
        isXbeta -> compile.isXbeta;
        
        'BETAworld' 
          -> (fileExt.copy).prepend -> compile.prependPathToBetaWorld -> FN[];
        (if isXbeta then
            (1,FN.length - 15) ->FN.sub -> FN[];
            'workspace\\TST\\TST.qbeta' -> FN.append;
        if);
        (* '\n**** compile:'->putline; FN[] -> putline;*)
        
        (L[],true,none,FN[]) -> compile -> (imain[],errors[]); (* NOTE: theM = none *)

        (if errors[] <> none then
            '\n!!!!! Errors in TST: ' -> putline;
            errors[] -> putline
        if);
        ((compile.iRootModule).name,(compile.iRootModule).M[],none,none)
          -> ObjCont.handle
          -> objContRoot[];
        
        popUp.open;
        (if compile.BetaBrowser then
            false -> embedded
         else
            true -> embedded;
        if);
        (embedded,0) -> theWorldWindow.open;
     #);
#)
