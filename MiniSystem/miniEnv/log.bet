ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/file'
---lib:attributes---
trace2: (# exit false #);
log:
  (# open:<
       (# N: ^text; useScreen: @boolean
       enter(N[],useScreen)
       do (if useScreen then
              screen[] -> LOG[]
           else
              N[] -> LOGF.name;
              LOGF.openWrite;
              LOGF[] -> LOG[];
              true -> useLOGF
          if)
       #);
     LOGF: @file;
     useLOGF: @boolean;
     LOG: ^stream;
     (* T: one text
      * TT: two texts
      * I: one int
      * TI: text, int
      * TN, etc: + newline
      * T2: trace level 2
      * etc
      * And just one LOG file, including compiler and run.
      *)
     T: (# txt: ^text enter txt[] do txt[] -> LOG.puttext ; inner #);
     Tn: T(# do LOG.newline #);
     T2: (# txt: ^text enter txt[] do (if trace2 then txt[] -> LOG.puttext ; inner if)#);
     Tn2: T2(# do LOG.newline #);
     
     TT:
       (# label,val: ^text
       enter(label[],val[])
       do label[] -> LOG.puttext; ': "' -> LOG.puttext; 
          val[] -> LOG.puttext; '" ' -> LOG.puttext;
          inner
       #);
     TTn: TT(#do LOG.newline; (if useLOGF then LOGF.flush if) #);
     TI: 
       (# label: ^text; val: @integer
       enter(label[],val)
       do label[] -> LOG.puttext; ':' -> LOG.puttext; val -> LOG.putint; ' ' -> LOG.put;
          inner
       #);
     TIn: TI(#do LOG.newline #);
     N: (#do LOG.newline #);
     cT: 
       (# cond: @boolean;  msg: ^text;
       enter(cond,msg[])
       do (if cond then
              msg[] -> LOG.putline
       if)#);

  #);
intList:
  (* ad hoc ...:-(*)
  (# L: [0] @ integer; top,max: @integer;
     up:
       (# 
       do max + 1 -> max
       #);
     down: (# do max - 1 -> max #);
     add:
       (# V: @integer
       enter V
       do (if L.range = 0 then
              (*'intList:Max: ' -> puttext; max -> putint; newline;*)
              max -> L.new; max -> top 
          if);
          (if top > 0 then
              V -> L[top];
              top - 1 -> top
           else
              '\n****** OBS! intList:add:top:'->puttext; top -> putint; 
              ' range:'->puttext; L.range -> putint; newline;              
          if)
       #);
     scan:
       (# current: @integer
       do (for i: L.range repeat L[i] -> current; inner for)
       #);
     get: integerValue
       (# inx: @integer
       enter inx
       do L[inx] -> value
       #);
     inRange: booleanValue
       (# inx: @integer enter inx do (0 < inx) and (inx <= L.range) -> value #);
  #);
tHead:
  (# T: ^text; S: @text; ch: @char
  enter T[]
  do T.setPos;
     L:
       (for i: 50 repeat 
            (if T.eos then leave L if);
            T.get -> ch;
            (if ch 
             // 10 // 12 // ascii.nl then '_' -> S.put else ch -> S.put 
       if)for)
  exit S[]
  #)
          
