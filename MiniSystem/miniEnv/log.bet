ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/file'
---lib:attributes---
trace2: (# exit false #);
log:
  (# open:<
       (# N: ^text; useScreen: @boolean
       enter(N[],useScreen)
       do (if useScreen then
              screen[] -> LOG[]
           else
              N[] -> LOGF.name;
              LOGF.openWrite;
              LOGF[] -> LOG[]
          if)
       #);
     LOGF: @file;
     LOG: ^stream;
     (* T: one text
      * TT: two texts
      * I: one int
      * TI: text, int
      * TN, etc: + newline
      * T2: trace level 2
      * etc
      * And just one LOG file, including compiler and run.
      *)
     T: (# txt: ^text enter txt[] do txt[] -> LOG.puttext ; inner #);
     Tn: T(# do LOG.newline #);
     T2: (# txt: ^text enter txt[] do (if trace2 then txt[] -> LOG.puttext ; inner if)#);
     Tn2: T2(# do LOG.newline #);
     
     TT:
       (# label,val: ^text
       enter(label[],val[])
       do label[] -> LOG.puttext; ': "' -> LOG.puttext; 
          val[] -> LOG.puttext; '" ' -> LOG.puttext;
          inner
       #);
     TTn: TT(#do LOG.newline #);
     TI: 
       (# label: ^text; val: @integer
       enter(label[],val)
       do label[] -> LOG.puttext; ':' -> LOG.puttext; val -> LOG.putint; ' ' -> LOG.put;
          inner
       #);
     TIn: TI(#do LOG.newline #);
     N: (#do LOG.newline #);
     cT: 
       (# cond: @boolean;  msg: ^text;
       enter(cond,msg[])
       do (if cond then
              msg[] -> LOG.putline
       if)#);

  #);
intList:
  (* ad hoc ...:-(*)
  (# L: [0] @ integer; top,max: @integer;
     up:
       (# 
       do max + 1 -> max;
       #);
     down: (# do max - 1 -> max #);
     add:
       (# V: @integer
       enter V
       do (if L.range = 0 then max -> L.new; max -> top if);
          (* the next one was added later - find out which situation this is??*)
          (if top > L.range then top - L.range -> L.extend if);
          'intList:add:top:'->puttext; top -> putint; 
          ' range:'->puttext; L.range -> putint; newline;
          (if top > 0 then
              V -> L[top];
              top - 1 -> top
          if)
       #);
     scan:
       (# current: @integer
       do (for i: L.range repeat L[i] -> current; inner for)
       #);
     get: integerValue
       (# inx: @integer
       enter inx
       do L[inx] -> value
       #);
     inRange: booleanValue(# inx: @integer enter inx do (0 < inx) and (inx <= L.range) -> value #)
  #)
