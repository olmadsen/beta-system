ORIGIN '~beta/basiclib/systemenv';
INCLUDE '~beta/process/streamgenerator';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/basiclib/textmatch';
INCLUDE '~beta/containers/dictionary';
INCLUDE '~beta/containers/list';


(*
 * This is a very simple webserver that only handles GET requests.
 * 
 * Example URL:
 *
 * http://localhost:7913/qbeta/BETAworld/BETA/BETA.qbeta
 *
 * There is no error handling.
 *
 * The goal is to create a simple framework for implementing webservices that understands 
 * the HTTP protocol.
 * 
 * Next steps:
 *
 * 1. Dispatch message based on path in URI
 * 2. Produce JSON, HTML etc.
 *)

-- lib: attributes --

TextList: List
  (# element:: Text;
     get:
       (# index: @integer;
          elm: ^element;
       enter index
       do loop: scan
            (# i: @integer;
            do i + 1 -> i;
               (if i = index then
                  current[] -> elm[];
                  leave loop;
               if);
            #);
       exit elm[]
       #);
  #);

-- textlib: attributes --

split:
  (# ch: @char;
     parts: ^TextList;
  enter ch
  do &TextList[] -> parts[];
     (# previousIndex: @integer;
     do 0 -> previousIndex;
        reset;
        ch -> find
          (#
          do (if (previousIndex + 1) = inx then
                &Text[] -> parts.append;
             else
                (previousIndex + 1, inx - 1) -> sub -> parts.append;
                inx -> previousIndex;
             if);
          #);
        (if previousIndex = length then
          &Text[] -> parts.append;
        else
          (previousIndex + 1, length) -> sub -> parts.append;
        if);
     #);
     INNER;
  exit parts[]
  #);

-- systemlib: attributes --


QueryParameters: Dictionary
  (# element:: TextList;
     key:: Text;
  #);
HttpRequest:
  (# path: ^Text;
     query: ^QueryParameters;
     part: ^Text;
  #);
HttpResponse:
  (# status: @integer;
     message: ^Text;
     body: ^Text;
  #);

RequestHandler:
  (# prefix: ^Text;

     matches:
       (# path: ^Text;
          result: @boolean;
       enter path[]
       do prefix[] -> path.startsWith -> result;
       exit result
       #);
     RequestMethod:
       (# request: ^HttpRequest;
          response: ^HttpResponse;
       enter request[]
       do &HttpResponse[] -> response[];
          INNER;
       exit response[]
       #);
     get:< RequestMethod;
     post:< RequestMethod;
     put:< RequestMethod;
     delete:< RequestMethod;

     dispatch:
       (# verb: ^Text;
          request: ^HttpRequest;
          response: ^HttpResponse;
       enter (verb[], request[])
       do 'dispatch: ' -> putText;
          verb[] -> putLine; 
          (if 'GET' -> verb.equal then
             request[] -> get -> response[];
          else
             (if 'POST' -> verb.equal then
                request[] -> post -> response[];
             else
                (if 'PUT' -> verb.equal then
                   request[] -> put -> response[];
                else
                   (if 'DELETE' -> verb.equal then
                      request[] -> put -> response[];
                   else
                      request[] -> delete -> response[];
                   if);
                if);
             if);
          if);
       exit response[]
       #);
  #);
WebServer:
  (# TRACE: (# exit false #);
     theSocketGenerator: @SocketGenerator;

     handlers: @List
       (# element:: RequestHandler;
       #);

     init:
       (#
       do 7913 -> theSocketGenerator.bind;
       #);
     register:
       (# theRequestHandler: ^RequestHandler;
       enter theRequestHandler[]
       do theRequestHandler[] -> handlers.append;
       #);
     accept:
       (# socket: ^StreamSocket;
       do (# command: ^Text;
             verb: ^Text;
             uri: ^Text;
             header: ^Text;
             response: ^HttpResponse;
             status: ^Text;
          do 'Ready' -> putLine;
             waitForEver -> theSocketGenerator.getStreamConnection -> socket[];
             socket.getLine -> command[];
             command.reset;
             command.getAtom -> verb[];
             command.getAtom -> uri[];
             (verb[], uri[]) -> dispatch -> response[];

             &Text[] -> status[];
             'HTTP/1.1 ' -> status.putText;
             response.status -> status.putInt;
             ' ' -> status.putText;
             response.message[] -> status.putText;
             status[] -> socket.putLine;
             'Content-Type: text/plain' -> socket.putLine;
             &Text[] -> header[];
             'Content-Length: ' -> header.putText;
             (if response.body[] = NONE then
                0 -> header.putInt;
             else
                response.body.length -> header.putInt;
             if);
             header[] -> socket.putLine;
             socket.newLine;
             (if response.body[] <> NONE then
                response.body[] -> socket.putText;
             if);
             socket.close;
          #);
       #);
     dispatch:
       (*
        * The goal is to dispatch the message based on the path in the URI and
        * return JSON, HTML or XML based on the requirements of the message.
        *)
       (#  verb: ^Text;
           uri: ^Text;
           response: ^HttpResponse;
       enter (verb[], uri[])
       do (# path: ^Text;
             query: ^QueryParameters;
             part: ^Text;
             request: ^HttpRequest;
          do uri[] -> parseUri -> (path[], query[], part[]);
             &HttpRequest[] -> request[];
             path[] -> request.path[];
             query[] -> request.query[];
             part[] -> request.part[];
       loop: handlers.scan
               (# 
               do current.prefix[] -> putLine;
                  (if path[] -> current.matches then
                     (verb[], request[]) -> current.dispatch -> response[];
                     leave loop;
                  if);
               #);
              (if response[] = NONE then
                 &HttpResponse[] -> response[];
                 404 -> response.status;
                 'Not Found' -> response.message[];
                 'Resource not found' -> response.body[];
              if);
          #);
       exit response[]
       #);
     parseUri:
       (# uri: ^Text;
          path: ^Text;
          query: ^QueryParameters;
          part: ^Text;
       enter uri[]
       do (# parseQueryAndPart:
               (# input: ^Text;
               enter input[]
               do '#' -> input.split
                    (#
                    do 1 -> parts.get -> parseQuery;
                       (if parts.size > 1 then
                          2 -> parts.get -> part[];
                       if);
                    #);
               #);
             parseQuery:
               (# input: ^Text;
               enter input[]
               do &QueryParameters[] -> query[];
                  query.init;
                  '&' -> input.split
                    (#
                    do parts.scan
                         (#
                         do '=' -> current.split
                              (# name: ^Text;
                                 value: ^Text;
                                 values: ^TextList;
                              do (if parts.size = 2 then
                                    1 -> parts.get -> name[];
                                    2 -> parts.get -> value[];
                                    name[] -> query.lookup -> values[];
                                    (if values[] = NONE then
                                       &TextList[] -> values[];
                                       values.init;
                                       (name[], values[]) -> query.associate;
                                    if);
                                    value[] -> values.append;
                                 if);
                              #);
                         #);
                    #);
               #);
          do '?' -> uri.split
               (#
               do 1 -> parts.get -> path[];
                  (if parts.size > 1 then
                      2 -> parts.get -> parseQueryAndPart;
                  if);
               #);
          #);
       exit (path[], query[], part[])
       #);
  #);

-- program:descriptor --
SystemEnv
  (# theWebServer: @WebServer;
     operationsHandler: @RequestHandler
       (# get::
            (# command: ^Text;
               commands: ^TextList;
            do request.query.scanAssociations
               (#
               do
                  (if 'command' -> k.equal then
                     e.scan
                       (#
                       do current[] -> command[];
                       #);
                  if);
               #);
               (if 'step' -> command.equal then
                  'Handling STEP' -> putLine;
                  200 -> response.status;
                  'OK' -> response.message[];
                  'Let Us Step Into The Night And Pursue That Flighty Temptress, Adventure' -> response.body[];
               else
                  400 -> response.status;
                  'Bad Request' -> response.message[];
                  'Unknown command: ' -> response.body[];
                  command[] -> response.body.putLine;
               if);
            #);
       #);
  do theWebServer.init;
     '/op' -> operationsHandler.prefix[];
     operationsHandler[] -> theWebServer.register;
     cycle 
       (#
       do  theWebServer.accept;
       #);
  #)
