ORIGIN '~beta/basiclib/betaenv';
INCLUDE '../xbeta/Tree';
---lib:attributes---
AbstractSyntaxTree: Tree
  (#  Module:< node
       (# SO: ^StaticObject;
          PT:: 
            (# 
            do (0,length) -> block
               (#
               do (0,break) -> SO.PT 
               #)
            #);
          length:: (# do SO.length -> value #);
          PP:: (# do 'Module' -> lx.append #);
       enter SO[] -> append
       #);
     Items:< node 
       (# PT:: (# do scanSons(# do (pos,break) -> current.PT #)#);
          PP:: (# do 'Items' -> lx.append #);
          isEmpty: @boolean
       #);
     Item: node 
       (# sig: ^Signature
       do inner 
       #);
     Decl: Item
       (# PT::< (# do inner #);
          sig: ^Signature
       #);
     Signature:< node
       (# PP::(# do 'Signature'-> lx.append #);
          S: ^Lexem
       enter Lexem -> S[] -> append
       #);          
     StaticObject:< Decl
       (# OG: ^ObjectGeneration;
          (*isSimple:: (# do OG.isSimple -> value #);*)
          PT:: 
            (# 
            do ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; 
               (pos + 2,break) -> OG.PT 
            #);
          length:: (# do 3 + OG.length -> value #);
          PP:: (# do 'StaticObject'-> lx.append #)
       enter(sig[] -> append,OG[] -> append)
       #);
     ObjectTemplate: node
       (# 
          IS: ^Items 
       #);
     ObjectInvocation:< node (* is this an EXP? *)
       (# PP:: (# do 'ObjectInvocation' -> lx.append #);
       (*   T: ^Lexem
        enter Lexem -> T[] -> append *)
          E: ^exp
       enter E[] -> append
       #);       
     ObjectGeneration:< ObjectTemplate
       (# PT:: (# do (if IS[] <> none then (pos,break) -> IS.PT if)#);
          PP:: (# do 'ObjectGeneration' -> lx.append #);
          OI: ^ObjectInvocation
       enter(OI[] -> append,IS[] -> append)
       #);
     FuncDecl:< Decl
       (# PP:: (# do 'FuncDecl' -> lx.append #);
          arg: ^Arguments;
          itms: ^Items
       enter sig[] -> append
       #);
     Exp: item 
       (# rec: ^Receiver
       enter rec[] -> append
       #);
     Receiver:< node
       (# PP:: (# do 'Receiver' -> lx.append #);
          isBinary: @Boolean
       #);
     Unary:< Exp
       (# PP:: (# do 'Unary' -> lx.append #);
          M: ^Lexem
       enter M[] -> append
       #);
     Binary:< Exp
       (# PP:: (# do 'Binary' -> lx.append #);
          operator: ^Lexem;
          argument: ^Exp
       enter(operator[]->append, argument[]->append)
       #);
     Function:< Exp
       (# PP:: (# do 'Function' -> lx.append #);
          F: ^Lexem
       enter(lexem->append)
       #);
     KeyWord:< Exp
       (# PP:: (# do 'KeyWord' -> lx.append #)
       #);
     lexem:< Node
       (# PP:: (# do T[] -> lx.append #);
          T: ^text
       enter T[]
       #)     
  do
     inner
  #)
