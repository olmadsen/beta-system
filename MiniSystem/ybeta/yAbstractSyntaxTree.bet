ORIGIN '~beta/basiclib/betaenv';
INCLUDE '../xbeta/Tree';
---lib:attributes---
AbstractSyntaxTree: Tree
  (#  Module:< node
       (# SO: ^StaticObject;
          PT:: 
            (# 
            do (0,length) -> block
               (#
               do (0,break) -> SO.PT 
               #)
            #);
          length:: (# do SO.length -> value #);
          PP:: (# do 'Module' -> lx.append #);
       enter SO[] -> append
       #);
     Items:< node 
       (# PT:: 
            (# 
            do scanSons
               (# 
               do (pos,break) -> current.PT; 
                  (if not isLast then
                      (pos,break) -> mkbreak
                  if)
               #)
            #);
          PP:: (# do 'Items' -> lx.append #);
          isEmpty: @boolean
       #);
     Item: node 
       (# sig: ^Signature
       do inner 
       #);
     Decl: Item
       (# PT::< (# do inner #);
          sig: ^Signature
       #);
     Signature:< node
       (* In xbeta, Signature have subpatterns UnarySignature, etc 
        * Consider including arguments in the Signature
        *)
       (# PT:: 
            (# 
            do scanSons
               (#do (pos,break) -> current.PT; 
                  (if not isLast then ' ' -> lx.put if)
            #)#);
          PP::(# do 'Signature'-> lx.append #);
          S: ^Lexem; (* other arguments, and fatComma are just appended *)
          id: ^text;
          setId:
            (# 
            do ''-> id[];
               scanSons
               (# B: @boolean; L: ^Lexem
               do (if not B then 
                      current[] -> L[];
                      L.T[] -> id.append;
                  if);
                  not B -> B
               #)
            #)          
       enter id[] -> Lexem -> S[] -> append
       #);          
     StaticObject:< Decl
       (# OG: ^ObjectGeneration;
          (*isSimple:: (# do OG.isSimple -> value #);*)
          PT:: 
            (# 
            do (pos,break) -> sig.PT;
               ':' -> lx.put;
               ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; 
               (pos,break) -> OG.PT 
            #);
          length:: (# do 3 + OG.length -> value #);
          PP:: (# do 'StaticObject'-> lx.append #)
       enter(sig[] -> append,OG[] -> append)
       #);
     Pattern: Decl
       (# PT:: 
            (# 
            do (pos,break) -> sig.PT; ':' -> lx.put;
               (pos+4,true) -> mkBreak;
               (pos+4,true) -> OD.PT
            #);
          OD: ^ObjectDesc
       #);
     UnaryPattern:< Pattern
       (# PP:: (# do 'UnaryPtn:' -> lx.append; sig.id[] -> lx.append #);         
       enter (sig[]->append,OD[]->append)
       #);
     BinaryPattern:< Pattern
       (# PP:: (#do 'BinaryPtn:'-> lx.append; sig.id[]-> lx.append #);
       enter(sig[]->append,OD[]->append)
       #);
     FunctionalPattern:< Pattern
       (# PP:: (# do 'FunctionalPtn:' -> lx.append; sig.id[] -> lx.append #);
       enter(sig[] -> append,OD[]->append)
       #);
     KeywordPattern:< Pattern
       (# PP:: 
            (# 
            do 'KeywordPattern:' -> lx.append;  
               sig.id[] -> lx.append
            #);
       enter(sig[] -> append, OD[]->append)
       #);
     ObjectTemplate: node
       (# IS: ^Items 
       #);
     ObjectGeneration:< ObjectTemplate
       (# PT:: 
            (# 
            do E.PT;
               (if not IS.isEmpty then 
                   (pos+4,true) -> mkBreak;
                   (pos+4,true) -> IS.PT;
               if)
            #);
          PP:: (# do 'ObjectGeneration' -> lx.append #);
          E: ^Exp
       enter(E[] -> append,IS[] -> append)
       #);
     PatternId:< Node
       (# PP:: (#do 'PatternId'->lx.append #);
          rec: ^Receiver
       #);
     ObjectDesc:< ObjectTemplate
       (# PP:: (# do 'ObjectDesc' -> lx.append #);
          PT:: (#do (pos,break) -> IS.PT #);
          superPI: ^PatternId;
       enter(superPI[] -> append,IS[] -> append)
       #);

     Exp: item 
       (# rec: ^Receiver
       enter rec[] -> append
       #);
     Receiver:< node
       (# PP:: (# do 'Receiver' -> lx.append #);
          PT:: (# do scanSons(#do current.PT; (if not isBinary then '.' -> lx.put if)#)#);
          isBinary: @Boolean
       #);
     Unary:< Exp
       (# PT:: (# do rec.PT; M.PT #);
          PP:: (# do 'Unary' -> lx.append #);
          M: ^Lexem
       enter M[] -> append
       #);
     Binary:< Exp
       (# PP:: (# do 'Binary' -> lx.append #);
          PT::
            (#
            do (*(pos,break) -> mkBreak;*)
               rec.PT; 
               operator.PT; ' '-> lx.put;
               argument.PT
            #);
          operator: ^Lexem;
          argument: ^Exp
       enter(operator[]->append, argument[]->append)
       #);
     Function:< Exp
       (# PP:: (# do 'Function' -> lx.append #);
          PT:: (# do scanSons(#do current.PT; (if not isLast then ' ' -> lx.put if)#)#);
          F: ^Lexem
       enter(lexem->append)
       #);
     KeyWord:< Exp
       (# PP:: (# do 'KeyWord' -> lx.append #);
          PT:: 
            (# first: @boolean
            do (* first element in sons is receiver - may be empty *)
               true -> first;
               scanSons
               (#do current.PT;
                  (if not isLast and not first then ' ' -> lx.put if);
                  false -> first
               #)
            #)
       #);
     lexem:< Node
       (# PT:: (# do T[] -> lx.append #);
          PP:: (# do T[] -> lx.append #);
          T: ^text
       enter T[]
       #)     
  do
     inner
  #)
