ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'ylexer';
INCLUDE 'yAbstractSyntaxTree';

---lib:attributes---
parser: AbstractSyntaxTree
  (# pModule:
       (# symb: ^text;
          sig: ^Signature;
          M: ^Module
       do (if lex.symb = lex.symbols.idf then
              lex.sym[] -> Signature -> sig[];
              lex;
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb = lex.symbols.object then 
                      lex;
                      sig[] -> pStaticObject -> Module -> M[]
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
       exit M[]
       #);
     pStaticObject:
       (# sig: ^Signature;
          OG: ^ObjectGeneration;
          SO: ^StaticObject
       enter sig[]
       do pObjectGeneration -> OG[];
          (sig[],OG[]) -> StaticObject -> SO[]
       exit SO[]
       #);
     pObjectGeneration:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
       (# OI: ^ObjectInvocation;
          IS: ^Items;
          OG: ^ObjectGeneration
       do pObjectInvocation -> OI[];
          pMainPart -> IS[];
          (OI[],IS[]) -> ObjectGeneration -> OG[]
       exit OG[]
       #);
     pObjectInvocation:
       (# OI: ^ObjectInvocation
       do pExp -> ObjectInvocation -> OI[]
       exit OI[]
       #);
     pMainPart:
       (# IS: ^Items
       do (if lex.symb = lex.symbols.begin then '2'->put;
              lex;
              pItems -> IS[];
              'j'->put;
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  2 -> SyntaxError
              if)
           else
              Items -> IS[];
              true -> IS.isEmpty
          if)
       exit IS[]
       #);
     pItems:
       (# I: ^Items
       do Items -> I[];
          Loop:
            (#
            do (if lex.symb 
                // lex.symbols.idf then
                   (* Here we do lookahead of 1-3 symbols to determine
                    * if the next item is a DECLARATION or an EXPRESSION
                    *)
                   (if 1 -> lex.peekNext 
                    // lex.symbols.colon then
                       pDecl -> I.append; (* unary decl *)
                       lex.symb -> lex.symbols.print
                    // lex.symbols.leftBrack then 
                       (* DECL foo(v: @integer, ...): ...
                        * Exp: foo(e1,e2,e2)
                        *)
                       (if (2 -> lex.peekNext) = lex.symbols.colon then
                           pDecl -> I.append;
                        else
                           pExp -> I.append;
                       if)
                    else 
                       lex.symb -> lex.symbols.print;
                       pExp -> I.append;
                   if);
                // lex.symbols.special then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) = lex.symbols.colon then
                       pDecl -> I.append
                    else
                       pExp -> I.append
                   if)
                // lex.symbols.fatComma then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) = lex.symbols.colon then
                       pDecl -> I.append
                    else
                       pExp -> I.append
                   if);
               if);
               (if lex.symb = lex.symbols.semicolon then
                   lex; 
                   restart Loop
               if)
            #)
       exit I[]
       #);
     pDecl:
       (# I: ^Item; sig: ^Signature
       do Item-> I[];
          (if lex.symb 
           // lex.symbols.idf then 'I'->put;
              lex.sym[] -> Signature -> sig[];
              sig[] -> I.sig[] -> I.append;
              lex;
              (if lex.symb 
               // lex.symbols.colon then
                  (* unary method or pattern *)
                  lex;
                  sig[] -> pSpec -> I[]
               // lex.symbols.leftBrack then 'F'->put;
                  lex;
                  sig[] -> pFuncDecl -> I[]
               else
                  syntaxError
              if)
           // lex.symbols.special then 
              lex;
              pArgument;
              (if lex.symb = lex.symbols.colon then
                  lex;
                  pSpec
               else
                  syntaxError
              if)
           // lex.symbols.fatComma then
              lex;
              pArguments;
              (if lex.symb = lex.symbols.colon then
                  lex;
                  pSpec
               else
                  syntaxError
              if)
           else
              SyntaxError
          if)
       exit I[]
       #);
     pSpec:
       (* Incomplete
        * x : @integer
        * R: ^Foo
        * P:{ ... }
        * V:< 
        *)        
       (# sig: ^Signature; SO: ^StaticObject; OG: ^ObjectGeneration
       enter sig[]
       do (if lex.symb 
           // lex.symbols.object then
              lex; 
              sig[] -> pStaticObject -> SO[]
           // lex.symbols.begin then
              pObjectGeneration -> OG[];
              (if sig[] = none then
                  '\n*** sig none'->putline;
                  Signature -> sig[]
              if);
              (if OG[] = none then
                  '\n*** OG none'->putline;
              if);
              
              (sig[],OG[]) -> StaticObject -> SO[]
          if)
       exit SO[]
       #);
     pFuncDecl:
       (# FD: ^FuncDecl
       enter FuncDecl -> FD[]
       do FD[] -> pArguments;
          (if lex.symb = lex.symbols.rightBrack then
              lex;
              (if lex.symb = lex.symbols.colon then
                  lex;
                  pSpec (*-> FD.itms[] -> FD.append*)
               else
                  syntaxError
              if)
           else
              syntaxError
          if)
       exit FD[]
       #);          
     pArgument:
       (# FD: ^FuncDecl; I: ^Item
       enter FD[]
       do pDecl -> I[]; (* Perhaps not all decl's shpuæd be allowed *)
          (if FD[] <> none then I[] -> FD.append if);
       #);
     pArguments:
       (# FD: ^FuncDecl
       enter FD[]
       do FD[] -> pArgument; '$'->put;
          (if lex.symb // lex.symbols.fatComma //lex.symbols.comma then
              '%'->put;
              lex;
              restart pArguments
          if)
       #);

     pExp:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if E0 %then  E1 %else E2
        *)
       (# rec: ^Receiver; 
          symb: @integer; sym: ^Text;
          E: ^Exp; 
       do pReceiver -> (rec[],symb,sym[]);
          (* Receiver not empty if
           *   R.foo ...    rec = (R)
           *   R.S.foo ...  rec = (R S)
           *   A := B ...   rec = (A isBinary=true)
           * empty
           *   rec = ()
           * 
           *)
          '\nAfter pReceiver:'->putline;
          symb -> lex.symbols.print; ' ' -> put; sym[] -> putline;
          lex.symb -> lex.symbols.print; ' ' -> put; lex.sym[] -> putline;
          (if symb 
           // lex.symbols.idf then 
              (if lex.symb 
               // lex.symbols.leftBrack then
                  lex;
                  (rec[],sym[]) -> pFunction  -> E[]
               else (*unary *)
                  'U'->put; sym[] -> putline;
                  (rec[],sym[] -> Lexem) -> Unary -> E[]                  
              if)
           // lex.symbols.special then 'S'->put;
(*              lex;*)
              (rec[],sym[]) -> pBinary -> E[]
           // lex.symbols.fatComma then '6'->put;
              lex.sym[] -> puttext;
              (*lex;*)
              (rec[],sym[]) -> pKeyword -> E[]
           else
              Exp -> E[];              
              lex.symb -> lex.symbols.print; 
          if);
       exit E[]
       #);
     pReceiver:
       (# rec: ^Receiver; symb: @integer; sym: ^text
       do Receiver -> rec[];
          Loop:
            (#
            do (if lex.symb 
                // lex.symbols.idf then '9'->put;
                   lex.symb -> symb;
                   lex.sym[] -> sym[];
                   lex; 
                   lex.symb -> lex.symbols.print;
                   (if lex.symb 
                    // lex.symbols.dot then 'q'->put;
                       sym[] -> Lexem -> rec.append;
                       lex;
                       restart Loop
                    // lex.symbols.Special then
                       sym[] -> Lexem -> rec.append;
                       true -> rec.isBinary;
                       lex.symb -> symb;
                       lex.sym[] -> sym[];
                       lex
                   if)
                // lex.symbols.special
                // lex.symbols.fatComma then
                   lex.symb -> symb;
                   lex.sym[] -> sym[];
                   lex;
                // lex.symbols.textSy // lex.symbols.charSy then
                   lex.symb -> symb;
                   lex.sym[] -> sym[];
                   lex; 
                   '\n*** Parsing text: not implemented'->putline
               if)
            #)
       exit(rec[],symb,sym[])
       #);            
     pFunction:
       (# rec: ^Receiver; sym: ^text;
          F: ^Function
       enter(rec[],sym[])
       do (rec[],sym[]) -> Function -> F[];          
          loop:
            (if true then
                pExp -> F.append;
                lex.symb -> lex.symbols.print;
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex
                 else
                    6 -> SyntaxError
                if)
            if)
       exit F[]
       #);
     pBinary:
       (# rec: ^Receiver; op: ^Lexem; E: ^Exp; B: ^Binary
       enter(rec[],Lexem -> op[])
       do 'B'->put; op.doPP -> putline;
          pExp -> E[];
          (rec[],op[],E[]) -> Binary -> B[];
          't'->put;
          lex.symb-> lex.symbols.print; 
       exit B[]
       #);
     pKeyword:
       (# rec: ^Receiver; 
          sym: ^Text; (* sym = fatComma = %put *)
          K: ^KeyWord
       enter(rec[],sym[])
       do '\npKeyword: ' -> puttext; sym[] -> putline;
          rec[] -> KeyWord -> K[];
          sym[] -> Lexem -> K.append;
          Loop:
            (#
            do pExp -> K.append; 
               '7' -> put; lex.symb->lex.symbols.print;
               (if lex.symb = lex.symbols.fatComma then '8'->put;
                   lex.sym[] -> Lexem -> K.append;
                   lex;
                   restart Loop
               if)
            #)
       exit K[]
       #);
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          newline;
          3 -> lex.printlines;
          (failureTrace (*dumpStack*), 'Syntax error')  -> stop
        #);
     genTokenStream:
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.special 
                // lex.symbols.fatComma then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if)
           if)
       #);
     lex: @lexer;
     in: ^Stream;
     doParse: @boolean;
     M: ^Module
  enter in[]
  do in[]-> lex.init;
     (if doParse then
         lex;
         pModule -> M[];
         newline;
         M.doPP -> putline;
         M.doPT -> putline
      else
         genTokenStream
     if)
  #)
---program:descriptor---
(# parse: @Parser;
   FN: ^text;
   F: @file;
do 'ybeta compiler: ' -> puttext;
   2 -> arguments -> FN[];
   (if ('-x' -> FN.equalNCS) then      
       ' ' -> put;
       3 -> arguments -> FN[]
    else
       true -> parse.doParse
   if);
   FN[] -> fixExtension_xbeta -> FN[] -> putline;
   FN[] -> F.name;
   F.openRead;
   F[] -> parse
#)
