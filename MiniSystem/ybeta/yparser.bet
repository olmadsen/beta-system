ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'ylexer';
INCLUDE 'yAbstractSyntaxTree';

---lib:attributes---
parser: AbstractSyntaxTree
  (# pModule:
       (# symb: ^text;
         (* sig: ^Signature;
          res: ^Lexem;
          SO: ^StaticObject*)
       do (if lex.symb = lex.symbols.idf then '1'->put;
              lex.sym[] -> symb[];
              (*symb[] -> UnarySignature -> sig[];
              none -> Lexem -> res[];*)
              lex;
              (if lex.symb = lex.symbols.colon then '1'->put;
                  lex; 
                  (if lex.symb = lex.symbols.object then '1'->put;
                      lex;
                      (*(sig[],res[]) -> pStaticObject -> SO[]*)
                      pStaticObject
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
       #);
     pStaticObject:
       (#
       do pObject
       #);
     pObject:
       (#
       do (if lex.symb = lex.symbols.begin then '2'->put;
              lex;
              pItems;
              'j'->put;
              (if lex.symb = lex.symbols.end then
                  (*lex*)
               else
                  2 -> SyntaxError
              if)
           else
              2 -> SyntaxError
          if)
       #);
     pItems:
       (# symbId: ^text; symb: @integer
       do Loop:
            (if lex.symb 
             // lex.symbols.idf then '3'->put;
                lex.sym[] -> symbId[];
                (if lex.peekNext = lex.symbols.colon then '4'->put;
                    lex;
                    lex;
                    pDecl;
                    'p'->put;
                    lex.symb -> lex.symbols.print
                 else '5'->put;
                    lex.symb -> lex.symbols.print;
                    pAction;
                    'u'->put;
                    lex.symb -> lex.symbols.print
                if);
                (if lex.symb
                 // lex.symbols.semicolon then 'w'->put;
                    lex; restart Loop
                 // lex.symbols.end then
                    'i'->put
                 else
                    3 -> syntaxError
                if)
             // lex.symbols.fatComma then
                lex.sym[] -> symbId[];
                lex;
                pKeyword;
                (if lex.symb
                 // lex.symbols.semicolon then 'w'->put;
                    lex; restart Loop
                 // lex.symbols.end then
                 else
                    4 -> syntaxError
                if)
          if)
       #);
     pDecl: 
       (#
       do (if lex.symb 
           // lex.symbols.object then
              lex; 
              (if lex.symb = lex.symbols.idf then
                  lex
               else
                  5 -> SyntaxError
              if)
           // lex.symbols.begin then
              pObject
          if)
       #);
     pAction:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if a = b %then 
        *)
       (#
       do (if lex.symb 
           // lex.symbols.idf then 'Q'->put; 
              lex; lex.symb -> lex.symbols.print; lex.sym[] -> puttext;
              (if lex.symb 
               // lex.symbols.dot then
                  '.'->put;
                  lex;
                  pReceiver
               // lex.symbols.leftBrack then
                  lex;
                  pFunction;
               // lex.symbols.special then
                  'y'->put;
                  lex;
                  lex.sym[] -> puttext;
                  pBinary;
               else (*unary *)
                  lex.symb -> lex.symbols.print;
              if)
           // lex.symbols.fatComma then '6'->put;
              lex.sym[] -> puttext;
              lex;
              pKeyword
           else
              lex.symb -> lex.symbols.print; 
          if)
       #);
       
     pFunction:
       (# symbId: ^text; symb: @integer
       enter(symbId[],symb)
       do loop:
            (if lex.symb = lex.symbols.idf then
                lex;
                pExp;
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex
                 else
                    6 -> SyntaxError
                if)
            if)
       #);
     pBinary:
       (# 
       do pExp;
          't'->put;
          lex.symb-> lex.symbols.print; 
       #);
     pExp: 
       (#
       do (if lex.symb = lex.symbols.idf then 'e'->put;
              lex; 
              (if lex.symb = lex.symbols.special then 'r'->put;
                  lex;
                  restart pExp (* should also cover remote, keyword, function*)
               else (* unary*)
              if)
          if)
       #);
     pReceiver:
       (# 
       do (if lex.symb = lex.symbols.idf then '9'->put;
              lex; 
              lex.symb -> lex.symbols.print;
              (if lex.symb = lex.symbols.dot then 'q'->put;
                  lex;
                  restart pReceiver
              if)
          if)
       #);
     pKeyword:
       (#
       do (*lex;*)
          pExp; '7' -> put; lex.symb->lex.symbols.print;
          (if lex.symb = lex.symbols.fatComma then '8'->put;
              lex;
              restart pKeyword
          if)
       #);
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          newline;
          3 -> lex.printlines;
          (failureTrace (*dumpStack*), 'Syntax error')  -> stop
        #);
     genTokenStream:
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.special 
                // lex.symbols.fatComma then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if)
           if)
       #);
     lex: @lexer;
     in: ^Stream;
     doParse: @boolean
  enter in[]
  do in[]-> lex.init;
     (if doParse then
         lex;
         pModule
      else
         genTokenStream
     if)
  #)
---program:descriptor---
(# parse: @Parser;
   FN: ^text;
   F: @file;

do 'ybeta compiler: ' -> puttext;
   2 -> arguments -> FN[];
   (if ('-x' -> FN.equalNCS) then      
       ' ' -> put;
       3 -> arguments -> FN[]
    else
       true -> parse.doParse
   if);
   FN[] -> fixExtension_xbeta -> FN[] -> putline;
   FN[] -> F.name;
   F.openRead;
   F[] -> parse
#)
