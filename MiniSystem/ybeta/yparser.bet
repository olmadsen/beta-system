ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'ylexer';
INCLUDE 'yAbstractSyntaxTree';

---lib:attributes---
parser: AbstractSyntaxTree
  (# pModule:
       (# symb: ^text;
         (* sig: ^Signature;
          res: ^Lexem;
          SO: ^StaticObject*)
       do (if lex.symb = lex.symbols.idf then
              lex.sym[] -> symb[];
              (*symb[] -> UnarySignature -> sig[];
              none -> Lexem -> res[];*)
              lex;
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb = lex.symbols.object then 
                      lex;
                      (*(sig[],res[]) -> pStaticObject -> SO[]*)
                      pStaticObject
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
       #);
     pStaticObject:
       (#
       do pObject
       #);
     pObject:
       (#
       do (if lex.symb = lex.symbols.begin then '2'->put;
              lex;
              pItems;
              'j'->put;
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  2 -> SyntaxError
              if)
           else
              3 -> SyntaxError
          if)
       #);
     pItems:
       (# 
       do (if lex.symb 
           // lex.symbols.idf then '3'->put;
              (* Here we do lookahead of 1-3 symbols to determine
               * if the next item is a DECLARATION or an EXPRESSION
               *)
              (if 1 -> lex.peekNext 
               // lex.symbols.colon then '4'->put;
                  pDecl1; (* unary decl *)
                  'p'->put;
                  lex.symb -> lex.symbols.print
               // lex.symbols.leftBrack then 
                  (* DECL foo(v: @integer, ...): ...
                   * Exp: foo(e1,e2,e2)
                   *)
                  (if (2 -> lex.peekNext) = lex.symbols.colon then
                      pDecl1
                   else
                      pExp
                  if)
               else '5'->put;
                  lex.symb -> lex.symbols.print;
                  pExp;
                  'u'->put;
                  lex.symb -> lex.symbols.print
              if);
           // lex.symbols.special then
              (* More lookahead *)
              (if (2 -> lex.peekNext) = lex.symbols.colon then
                  pDecl1
               else
                  lex;
                  pBinary
              if)
           // lex.symbols.fatComma then
              (* More lookahead *)
              (if (2 -> lex.peekNext) = lex.symbols.colon then
                  pDecl1
               else
                  lex;
                  pKeyword;
              if);
          if);
          (if lex.symb = lex.symbols.semicolon then 'w'->put;
              lex; 
              restart pItems
          if)
       #);
     pDecl1:
       (#
       do (if lex.symb 
           // lex.symbols.idf then 'I'->put;
              lex;
              (if lex.symb 
               // lex.symbols.colon then
                  (* unary method or pattern *)
                  lex;
                  pSpec
               // lex.symbols.leftBrack then 'F'->put;
                  lex;
                  pArguments;
                  (if lex.symb = lex.symbols.rightBrack then
                      lex;
                      (if lex.symb = lex.symbols.colon then
                          lex;
                          pSpec
                       else
                          syntaxError
                      if)
                   else
                      syntaxError
                  if)
              if)
           // lex.symbols.special then 
              lex;
              pArgument;
              (if lex.symb = lex.symbols.colon then
                  lex;
                  pSpec
              if)
           // lex.symbols.fatComma then
              lex;
              pArguments;
              (if lex.symb = lex.symbols.colon then
                  lex;
                  pSpec
              if)
           else
              SyntaxError
          if)
       #);
     pArgument:
       (#
       do (if lex.symb = lex.symbols.idf then
              lex;
              (if lex.symb = lex.symbols.colon then
                  lex;
                  (if lex.symb = lex.symbols.object then
                      lex;
                      (if lex.symb = lex.symbols.idf then
                          lex
                       else
                          syntaxError
                      if)
                   else
                      syntaxError
                  if)
               else
                  syntaxError
              if)
           else
              syntaxError
          if)
       #);
     pArguments:
       (#
       do pArgument; '$'->put;
          (if lex.symb // lex.symbols.fatComma //lex.symbols.comma then
              '%'->put;
              lex;
              restart pArguments
          if)
       #);
     pSpec:
       (* Incomplete
        * x : @integer
        * R: ^Foo
        * P:{ ... }
        * V:< 
        *)        
       (#
       do (if lex.symb 
           // lex.symbols.object then
              lex; 
              (if lex.symb = lex.symbols.idf then
                  lex
               else
                  5 -> SyntaxError
              if)
           // lex.symbols.begin then
              pObject
          if)
       #);
     pExp:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if E0 %then  E1 %else E2
        *)
       (#
       do (if lex.symb 
           // lex.symbols.idf then 'Q'->put; 
              lex; lex.symb -> lex.symbols.print; lex.sym[] -> puttext;
              (if lex.symb 
               // lex.symbols.dot then
                  '.'->put;
                  lex;
                  pReceiver
               // lex.symbols.leftBrack then
                  lex;
                  'F'->put;
                  pFunction;
               // lex.symbols.special then
                  'y'->put;
                  lex;
                  lex.sym[] -> puttext;
                  pBinary;
               else (*unary *)
                  lex.symb -> lex.symbols.print;
              if)
           // lex.symbols.fatComma then '6'->put;
              lex.sym[] -> puttext;
              lex;
              pKeyword
           else
              lex.symb -> lex.symbols.print; 
          if)
       #);
       
     pFunction:
       (# symbId: ^text; symb: @integer
       enter(symbId[],symb)
       do loop:
            (if lex.symb = lex.symbols.idf then
                'Z'->put;
                lex;
                pExp;
                'X'->put;
                lex.symb -> lex.symbols.print;
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex
                 else
                    6 -> SyntaxError
                if)
            if)
       #);
     pBinary:
       (# 
       do pExp;
          't'->put;
          lex.symb-> lex.symbols.print; 
       #);
     pReceiver:
       (# 
       do (if lex.symb = lex.symbols.idf then '9'->put;
              lex; 
              lex.symb -> lex.symbols.print;
              (if lex.symb = lex.symbols.dot then 'q'->put;
                  lex;
                  restart pReceiver
              if)
          if)
       #);
     pKeyword:
       (#
       do (*lex;*)
          pExp; '7' -> put; lex.symb->lex.symbols.print;
          (if lex.symb = lex.symbols.fatComma then '8'->put;
              lex;
              restart pKeyword
          if)
       #);
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          newline;
          3 -> lex.printlines;
          (failureTrace (*dumpStack*), 'Syntax error')  -> stop
        #);
     genTokenStream:
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.special 
                // lex.symbols.fatComma then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if)
           if)
       #);
     lex: @lexer;
     in: ^Stream;
     doParse: @boolean
  enter in[]
  do in[]-> lex.init;
     (if doParse then
         lex;
         pModule
      else
         genTokenStream
     if)
  #)
---program:descriptor---
(# parse: @Parser;
   FN: ^text;
   F: @file;

do 'ybeta compiler: ' -> puttext;
   2 -> arguments -> FN[];
   (if ('-x' -> FN.equalNCS) then      
       ' ' -> put;
       3 -> arguments -> FN[]
    else
       true -> parse.doParse
   if);
   FN[] -> fixExtension_xbeta -> FN[] -> putline;
   FN[] -> F.name;
   F.openRead;
   F[] -> parse
#)
