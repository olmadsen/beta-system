ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'yparser';
(*INCLUDE 'Primitives';*)
---lib:attributes---
checker: Parser
  (# Module::<
       (# setUpOrigin:: (# do SO.setUpOrigin #);
          check::
            (#
            do SO.check;
            #);
          desc:
            (# D: ^ObjectTemplate
            do SO.desc -> D[]
            exit D[]
            #);
       #);
     Items::<
       (# setUpOrigin::
            (# 
            do scanSons(# do origin[] -> current.setupOrigin #);
               (if props[] <> none then
                   origin[] -> props.setUpOrigin
               if)
            #);
          check::
            (# 
            do (* '\nItems:check:scope:' -> putline;
                *                dopt -> putline;
                *)
               origin[] -> scope[];
               rsize + 1 -> rsize -> originOff;
               (*(if scope[] <> none then scope.dopt -> putline else 'none'->putline if);*)
               scanSons(# do scope[] -> current.check #)
            #); 
          isSimple: @boolean;
          vsize, rsize,originOff: @integer;
       #);
     Properties::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#)
       #);
     Property::<
       (# setupOrigin::
            (# 
            do origin[] -> P.setupOrigin;
               (if arg[] <> none then origin[] -> arg.setupOrigin if)
            #)
       #);
     Signature::<
       (# setUpOrigin::
            (#
            do scanSons
               (# 
               do (* '\nSig: ' -> puttext; doPT -> putline; *)
                  origin[] -> current.setupOrigin
               #);
               (if val[] <> none then origin[] -> val.setupOrigin if)
            #);
          check::
            (# 
            do scanSons
               (# 
               do (*(if scope[] = none then
                      'Sig:check:scope is none: ' -> puttext; dopt -> putline
                  if);*)
                  scope[] -> current.check 
               #);
               (if val[] <> none then scope[] -> val.check if)
            #); 
       #);
     Value::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (#
            do scanSons(#do scope[] -> current.check #)
            #)
       #);          
     StaticObject::<
       (# setUpOrigin::
            (#
            do (*(if origin[] = none then
                   'Setup: origin none: ' -> puttext;
                   sig.doPT -> putline
               if);*)
               origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# elm::ObjectTemplate
            do scope[] -> sig.check;
               scope[] -> OG.check; 
               (if origin[] <> none then
                   (* origin is none if StaticObject is a Module *)
                   origin[] -> scope[];
                   (if OG.E.isSimple then
                       scope.IS.vsize + 1 -> scope.IS.vsize -> off
                    else
                       scope.IS.rsize + 1 -> scope.IS.rsize -> off
                   if)
               if);
            #);
          desc::
            (# elm:: ObjectTemplate
            do (*'StaticObject:desc:'->puttext; doPT -> putline;*)
               (if OG.IS.isEmpty then 
                   OG.E.desc -> D[]
                else
                   OG[] -> D[]
               if);
            #);
       #);
     DynamicObject::<
       (# setUpOrigin::
            (#
            do (if origin[] = none then
                   'Setup: origin none: ' -> puttext;
                   sig.doPT -> putline
               if);
               origin[] -> sig.setUpOrigin; 
               origin[] -> PI.setUpOrigin
            #);
          check::
            (# elm::objectTemplate
            do scope[] -> PI.check;
              (* newline;
               sig.doPT -> putline;*)
               (if origin[] <> none then 
                   (*origin.doPT -> putline;*)
                   (* origin is none if StaticObject is a Module *)
                   origin[] -> scope[];
                   scope.IS.rsize + 1 -> scope.IS.rsize -> off;
                else
                   'Origin is none' -> putline
               if);
            #);
          desc::
            (# elm:: ObjectTemplate
            do (*'DO:desc:'->puttext; doPT -> putline;*)
               (if PI.ATd[] <> none then
                   PI.desc -> D[]
               if);
            #);
       #);
     (*Pattern - see yAbstractSyntaxTree *)
     ObjectGeneration::<
       (# setUpOrigin::
            (#
            do (if IS.isEmpty then
                   origin[] -> E.setUpOrigin;
                   origin[] -> IS.setUpOrigin
                else     
                   (* '\nOG:SetUpOrigin:using: ' -> putline;
                    * this(objectTemplate).dopt ->putline;
                    * '---'->putline;
                    *)
                   this(ObjectTemplate)[] -> E.setUpOrigin;
                   this(ObjectTemplate)[] -> IS.setUpOrigin;
               if)                   
            #); 
          check::
            (#
            do (if not IS.isEmpty then
                   this(ObjectTemplate)[] -> newDesc -> descNo;
               if);
               (*'OG:check:'->putline; dopt->putline;
                (if origin[] <> none then origin.dopt -> putline else 'none'->putline if);
                * *)
               origin[] (*scope[]*) -> E.check; 
               origin[] -> IS.check
            #);
       #);
     PatternId::<
       (# setUpOrigin:: (# do origin[] -> rec.setUpOrigin #);
          check:: 
            (# elm:: ObjectTemplate
            do (if (id[] <> none) and (id.length > 0) then
                   scope[] -> rec.check -> scope[];
                   (* 'PI: '->puttext; compoundsymb[] -> putline;*)
                   (*origin[] -> scope[];*)
                   (if (id[] -> scope.search -> ATd[]) <> none then
                       '*** Found patternId: ' -> puttext; id[] -> putline
                    else
                       '*** Did not find  patternId: ' -> puttext; id[] -> putline;
                       father.doPT -> putline
               if)if)
            #)
       #);
     ObjectDesc::<
       (# setUpOrigin::
            (#
            do origin[] -> superPI.setUpOrigin;
               this(ObjectTemplate)[] -> IS.setUpOrigin
            #);
          check:: 
            (# 
            do 
               this(ObjectTemplate)[] -> newDesc -> descNo;
               (if superPI[] <> none then scope[] -> superPI.check if);
               origin[] -> IS.check
            #);
       #);
     Receiver::<
       (* List of Lexems? *)
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# E: ^Exp1
            do scanSons
               (# 
               do (*'Receiverpath: '->puttext; current.doPT -> puttext; ' ' -> put;*)
                 (*(if current ##
                   // lexem## then
                      'Lexem ' -> puttext
                   // variable## then
                      'Variable:Lexem ' -> puttext
                   // TextExp## then
                      'Text:Lexem ' -> puttext  
                   else
                      'not Lexem '->puttext
                  if);*)
                  (* for R.S.foo, we need
                   * E[] -> current.check -> E[]
                   * perhaps always org as enter arg for check
                   *)
                  (*'org: '->puttext; scope.doPT -> putline;*)
                  scope[] -> current.check;
                  current[] -> E[];
                  (if (E.ATd[] <> none) and (E.ATd.desc <> none) then 
                      (*'\ndesc:'->puttext; (E.ATd.desc).doPT -> putline;*)
                      E.ATd.desc -> scope[]
                  if);
               #)
            #)          
       #);
     Unary::<
       (# setUpOrigin:: (# do origin[] -> rec.setUpOrigin; origin[] -> M.setUpOrigin #);
          check::
            (# elm:: ObjectTemplate
            do (*'Search: ' -> puttext; V.n[] -> putline;
                * 'Variable: ' -> puttext; scope.dopt ->putline;
                *)
               (if scope[] <> none then (* ad hoc *)
                   (if (M.T[] -> scope.search -> ATd[]) <> none then
                       '*** Found var: '->puttext; M.T[] -> putline
                    else
                       '*** Did NOT find var: '->puttext; M.T[] -> putline;
                       Decl -> ATd[]
                   if)
                else
                   'Variable:check: scope is none'->putline
               if)
            #);
          desc:: (# do ATd.desc -> D[] #)
       #);
     Binary::<
       (# setUpOrigin::
            (# 
            do origin[] -> rec.setUpOrigin; 
               origin[] -> operator.setUpOrigin;
               origin[] -> argument.setUpOrigin 
            #);
          check:: 
            (# elm:: ObjectTemplate
            do (* 'Binary: '-> puttext; operator.T[] -> putline;*)
               (if scope[] <> none then (* ad hoc *)
                   scope[] -> rec.check -> scope[];
                   (if (operator.T[] -> scope.search -> ATd[]) <> none then
                       '*** Found binary: '->puttext; 
                       operator.T[] -> putline
                    else
                       (if ':=' -> operator.T.equal then 
                           true -> isAssign;
                           '*** Found := (assign)' -> putline;
                        else
                           '*** Did NOT find binary: '->puttext; 
                           operator.T[] -> putline
                       if)
                   if)
                 else                    
                    'binary:check:org none ' -> putline
               if);
               (*'Arg:'->puttext; argument.doPT -> putline;
               '  in: ' -> puttext; origin.doPT -> putline;*)               
               origin[] -> argument.check 
            #)          
       #);
     Function::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#)
       #);
     KeyWord::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#)
       #);
     Name::< (# setUpOrigin:: (# do origin[] -> L.setUpOrigin #)#);
     Textt::< (# setUpOrigin:: (# do origin[] -> T.setUpOrigin #)#);
     Const::< (# setUpOrigin:: (# do origin[] -> C.setUpOrigin #)#);
     Textt1::< (# setUpOrigin:: (# do origin[] -> L.setUpOrigin #)#);
     Const1::< (# setUpOrigin:: (# do origin[] -> L.setUpOrigin #)#);
     Lexem::< (# setuporigin:: (#do(* ':' -> put; T[] -> puttext*) #)#);
     newDesc: @
       (# OD: [16] ^ObjectTemplate; 
          noOfDescs: @integer;
          anOD: ^ObjectTemplate;
          getOD: 
            (* only used from minienv *)
            (# descNo: @integer; anODx: ^ObjectTemplate
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that anOD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
  do
  #)
---program:descriptor---
(# check: @Checker;
   FN: ^text;
   F: @file;
do 'ybeta compiler: ' -> puttext;
   2 -> arguments -> FN[];
   (if ('-x' -> FN.equalNCS) then      
       ' ' -> put;
       3 -> arguments -> FN[]
    else
       true -> check.doParse
   if);
   FN[] -> fixExtension_xbeta -> FN[] -> putline;
   FN[] -> F.name;
   F.openRead;
   F[] -> check;
   '\n**** CHECKER ****' -> putline;
   check.M.setUpOrigin;
   check.M.check;
   
#)
