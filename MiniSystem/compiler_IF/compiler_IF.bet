ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE 'directoryComponents'
INCLUDE 'log';
---lib:attributes---
int2text: (# V: @integer; T: @text enter V do V -> T.putint exit T[] #);
putTI: (# T: ^text; V: @integer enter(T[],V) do T[] -> puttext; V -> putint#);
putTextL:
  (# T: [0] ^text
  enter T
  do (for i: T.range repeat
          T[i][] -> puttext
     for)
  #);
printNotNone:
  (# T: ^Text
  enter T[]
  do (if T[] <> none then
         T[] -> puttext
      else
         '-none-'->puttext
     if);
  #);
printhead:
  (# T: ^text; il,ic: @integer; ch: @char
  enter T[]
  do (if T[] = none then
         'none\n' -> puttext
      else
         loop:
            (if ic < T.length then
                (if il < 6 then
                    ic + 1 -> ic -> T.inxGet -> ch -> put;
                    (if ch = ascii.newline then il + 1 -> il if);
                    restart loop 
            if)if);
         '\n..........\n\n' -> puttext
     if)
  #);
Tree: DirectoryModules
  (# kinds: @ (* new kinds - to replace all other representations of kinds *)
       (# simple: (# exit 1 #);
          constRef: (# exit 2 #);
          varRef: (# exit 3 #);
          constVal: (# exit 4 #);
          varVal: (# exit 5 #);
          indexed: (# exit 6 #);
          string: (# exit 7 #);
          ptn: (# exit 8 #);
          virtualPtn: (# exit 9 #);
          furtherPtn: (# exit 10 #);
          finalPtn: (# exit 11 #);
          varPtn: (# exit 12 #);
          forInx: (# exit 13 #);
          objModule: (# exit 14 #);
          ptnModule: (# exit 15 #);
          action: (# exit 16 #);
          
          asText:
            (# K: @integer; T: ^text
            enter K
            do (if K
                // simple then 'simple' -> T[]
                // constRef then 'constRef' -> T[]
                // varRef then 'varRef' -> T[]
                // constVal then 'constVal' -> T[]
                // varVal then 'varVal' -> T[]
                // indexed then 'indexed' -> T[]
                // string then 'string' -> T[]
                // ptn then 'ptn' -> T[]
                // virtualPtn then 'virtualPtn' -> T[]
                // furtherPtn then 'furtherPtn' -> T[]
                // finalPtn then 'finalPtn' -> T[]
                // varPtn then 'varPtn' -> T[]
                // forInx then 'forInx' -> T[]
                // objModule then 'objModule' -> T[]
                // ptnModule then 'ptnModule' -> T[]
                // action then 'action' -> T[]
               if)
            exit T[]
            #)
       #);
     SimpleKind: (# exit 1 #);
     PatternKind: (# exit 2 #);
     ReferenceKind: (# exit 3 #);
     RepetionKind: (# exit 4 #);
     VirtualKind: (# exit 5 #);     
     
     isXbeta: @boolean;
     noComments: @boolean;
     TopNode:
       (# vNode:< TopNode;
          label:< (# lab: ^text do '???' -> lab[]; inner exit lab[] #);
          
          doPP:
            (#
            do &text[] -> lx[];
               0 -> ind;
               PP;
               false -> mark;
            exit lx[]
            #);
          PP:< 
            (# 
            do lx.newline;
               (for i: ind repeat ' ' -> lx.put for);
               '(' -> lx.put; 
               inner;
               (if son[] = none then
                   ')' -> lx.put;
                   (* lx.newline;
                   (for i: ind repeat ' ' -> lx.put for);*)
                else
                   ind + 1 -> ind;
                   (* lx.newline;
                    (for i: (ind + 1 -> ind) repeat ' ' -> lx.put for);*)
                   scanSons(# do current.PP  #);
                   (*lx.newline;*)
                   (*(for i: (ind - 1 -> ind) repeat ' ' -> lx.put for);*)
                   ')' -> lx.put; 
                   (*lx.newline;
                    (for i: (ind - 1 -> ind) repeat ' ' -> lx.put for);*)
                   ind - 1 -> ind
               if);
            exit lx[] 
            #); 
          doP:
            (# pos: @integer; break: @boolean;
            enter(pos,break)
            do &text[] -> lx[];
               (0,true) -> PT;
            exit lx[]
            #);
          doPT:
            (#
            enter mark
            do &text[] -> lx[];
               PT;
               false -> mark;
            exit lx[]
            #);
          doPTnoComments:
            (#
            do true -> noComments;
               &text[] -> lx[];
               PT;
               false -> noComments;
            exit lx[]
            #);
          length:< integerValue(# do inner #);
          superPP:
            (# mkBreak:<
                 (# pos: @integer; break: @boolean;
                 enter(pos,break)
                 do inner
                 #);
               standAlone: BooleanValue
                 (# ch: @char; ix: @integer
                 do lx.length -> ix;  (*'"' -> put;*)
                    L:
                      (if ix > 0 then                        
                          ix -> lx.inxGet -> ch; 
                          (*ch -> put;
                           (if commentBefore then 'B'->put else 'A' -> put if);
                           *)
                        (if true
                         // ch = ascii.newline then
                            true -> value;
                            leave standAlone
                         // ch <= ' ' then;
                            ix - 1 -> ix;
                            restart L
                        if)
                     else
                        true -> value
                      if);
                    (*'"'->put*)
                 #);               
               printComment:
                 (* A comment has thje form
                  * '<n> hello world' 
                  *      if only white space before the comment
                  * 'n> how are you' 
                  *      if the comment appears after 
                  *      some code on the same line
                  *)
                 (# ix,xpos: @integer
                 do (if comment[] <> none then
                        comment.setPos;
                        1 -> ix;
                        emit:
                          (# doBreak,isAlone: @boolean;
                          do standAlone -> isAlone;
                             (ix ->comment.inxGet) = '<' -> doBreak;
                             (if doBreak then 
                                 comment.get;
                                 comment.getint - 3 -> xpos;
                                 (if not commentBefore then 
                                     (pos,true) -> mkBreak;
                                 if)
                              else 
                                 comment.getint;
                                 (if not isAlone then
                                     ' ' -> lx.put
                                 if)
                             if);
                             comment.get; (* read '>' *)
                             '--' -> lx.puttext;
                             comment.scan
                             (# 
                             do (if ch <> ascii.newline then 
                                    ch -> lx.put;
                                 else
                                    comment.pos + 1 -> ix;
                                    (*(pos,true) -> mkBreak;*)
                                    restart emit 
                             if) #);
                             (if doBreak or isAlone  then
                                 (pos ,true) -> mkBreak;
                             if)
                          #)                        
                    if)
                 #);
               pos: @integer; break: @boolean;
            enter(pos,break)                
            do inner
            #);
          comment: ^text; commentBefore: @boolean;
          PT:< SuperPP
            (# 
               block:
                 (# pos,width: @integer; break: @boolean
                 enter(pos,width)
                 do lineWidth < (pos + width) -> break;
                    inner
                 #);
               mkBreak::
                 (# 
                 do (if lx.length > 0 then (* no break or space if first line *)
                        (if break then
                            lx.newline;
                            (for i: pos repeat ' ' -> lx.put for)
                         else
                            inner
                    if)if)
                 #);
               mkBreak0: mkBreak(##);
               mkBreak1: mkBreak(# do ' ' -> lx.put #);
            do (if mark then lx.getpos -> beginPos  if);
               inner;
               (if mark then lx.getpos -> endPos if)
            exit lx[]
            #);
          emitHTML:<
            (#
            do inner 
            #);
          doHTML:
            (#
            do &text[] -> lx[];
               HTML
            exit lx[]
            #);
          HTML:< SuperPP
            (#  mkBreak::
                 (#
                 do (if break then
                        '<br>\n' -> lx.append;
                        (for i: pos repeat '&nbsp;' -> lx.append for)
                    if)
                 #);
               indent:
                 (# pos: @integer
                 enter pos
                 do (for i: pos repeat '&nbsp;' -> lx.append for);
                 #);
            do inner
            #);          
          son,next,last,father: ^TopNode;
          clear:< (* Sets all variables in AST to initial values
                   * Needed when compile is called more than once
                   * on the same AST
                   *)
            (# 
            do false -> isChecked -> beingChecked; 
               inner;
               scanSons(# do current.clear #)
            #);
          append:
            (# N: ^TopNode
            enter N[]
            do (if N[] = none then 
                   '!!!! Tree:append: argument is None ' -> putline;
                   (*(dumpStack,'Tree.bet::TopNode::append') -> stop*)
               if);
               (if son[] = none then
                   N[] -> son[]
                else
                   N[] -> last.next[]
               if);
               N[] -> last[];
               this(TopNode)[] -> N.father[]
            #);
          noOfSons: IntegerValue
            (#
            do scanSons(# do value + 1 -> value #)
            #);
          scanSons:
            (# current: ^vNode;
               next: (# exit current.next[] #);
               isFirst: @boolean;
               isLast: (# exit current.next[] = none #);
            do son[] -> current[];
               true -> isFirst;
               Loop:
                 (if current[] <> none then
                     inner;
                     current.next[] -> current[];
                     false -> isFirst;
                     restart loop
                 if)
            #);
          scanReverse:
            (# current: ^TopNode;
               isLast: @boolean;
               L: [5] ^TopNode; top: @integer
            do scanSons
               (# do (if (top+1->top) > L.range then L.range -> L.extend if);
                  current[] -> L[top][]
               #);
               (for i: top repeat 
                    L[top+1-i][] -> current[];
                    i = top -> isLast;
                    INNER
               for)
            #);
          scanSubTree:
            (# doIt:<
                 (# current: ^topNode
                 enter current[]
                 do inner 
                 #);
            do this(topNode)[] -> doIt;
               scanSons
               (#
               do &current.scanSubTree
                  (# doIT:: (# do current[] -> this(scanSubTree).doIT #)#)
               #)
            #);
          scanSubTreeX:
            (# doIt:<
                 (# current: ^topNode
                 enter current[]
                 do inner 
                 #);
            do scanSons
               (#
               do current[] -> doIt;
                  &current.scanSubTree
                  (# doIT:: (# do current[] -> this(scanSubTree).doIT #)#)
               #)
            #);        
          getComment:<
            (# comm: ^text
            do inner
            exit comm[]
            #);
          doInsert:<
            (# N,atN: ^TopNode;
            enter(N[],atN[])
            do inner
            #);
          doDelete:<
            (# N: ^text
            enter N[]
            do inner
            #);
          doMoveUp:< (#  N: ^TopNode enter N[] do inner #);
          adjustForSingularImp:< 
            (# bPos,ePos: @integer;
               OD: ^TopNode;
            enter(OD[],bPos,ePos) 
            do inner 
            exit(OD[],bPos,ePos)
            #);          
          adjustForSingularImp_X:< 
            (# bPos,ePos: @integer;
               OD: ^TopNode;
            enter(OD[],bPos,ePos) 
            do inner 
            exit(OD[],bPos,ePos)
            #);
          replaceEntity:<
            (# errors: ^stream;
               path2Module,T: ^text
            enter(path2Module[],T[])
            do inner
            exit errors[]
            #);
          objDescEQ:< booleanValue
            (# trace: (#exit false #);
               dn: @integer 
            enter dn 
            do (if trace then
                   '*** objDescEq: ' -> puttext; dn -> putint; newline if);
               inner;
               (if trace then ' ' -> put; value -> putBoolean if);
            #);
          findNodeAtPos:<
            (# pos: @integer; N: ^TopNode;
               trace: (# exit false #)
            enter pos
            do inner
            exit N[]
            #);
          theModule:<
            (* Bindings in parser::module and parser.:nameApl *)
            (# ModulePtn:< TopNode;
               md: ^ModulePtn
            do inner;
               (md[],'theModule',this(TopNode)[]) -> noBinding
            exit md[]
            #);
          moduleName:< 
            (# N: ^Text 
            do inner;
               (N[],'moduleName',this(TopNode)[]) -> noBinding
            exit N[] #);
          pathToModuleFN:< (# path: ^text do inner exit path[] #);
          innFile:< (# F: ^File enter F[] do inner exit F[] #);
          doHandleDirmodules:< (# do inner #);
          theImodule:
            (# iM: ^iModule;
               M: ^TopNode
            do (if (theModule -> M[]) <> none then
                   &iModule[] -> iM[];
                   M[] -> iM.M[]
               if)
            exit iM[]
            #);
          isNameApl:< (# Na: ^TopNode do inner exit Na[] #);
          getDeclModule:<
            (# to: ^iModule;
               dclx: ^TopNode
            do inner
            exit(to[],dclx[])
            #);
          isAmodule:< (# M: ^iModule do inner exit M[] #);
          changeAttName:< 
            (# oldName,newName: ^text enter(oldName[],newName[]) do inner #); 
          getEntries:<
            (* An entry has  the form
             *    entry = (name,sort = (kind,entity))
             * For an objectDesc, a declaration is an entyr:
             *    dcl = (nameDcl, item=(kind,objectSpec))
             *)
            (# add:
                 (# T,N: ^text; E: ^TopNode
                 enter(T[],E[])
                 do (*'**   add:'->puttext; T[] -> puttext; ' ' -> put;*)
                    T.copy -> N[];
                    (if E[] <> none then
                        (* E.dopt -> putline;*)
                        E.skind -> N.puttext
                     else
                        '%' -> N.put; (*newline*)
                    if);
                    1 -> names.extend; 1 -> entries.extend;
                    N[] -> names[names.range][]; 
                    E[] -> entries[entries.range][]
                 #);
               names: [0] ^Text; entries: [0]^TopNode
            do inner
            exit(names[],entries[])
            #);
          sort:< 
            (# S: ^TopNode 
            do inner;
               (S[],'Sort',this(TopNode)[]) -> noBinding;
            exit S[]#);
          entity:< 
            (# E: ^TopNode 
            do inner; 
               (E[],'Entity',this(TopNode)[]) -> noBinding
            exit E[] #);
          myDesc:< 
            (# OD: ^TopNode
            do inner;  
               (if OD[] = none then
                   'Trans:myDesc:missing virtual binding in sub: ' -> putline;
                   doPT -> putline ;
                   PP -> putline
               if)
            exit OD[] 
            #);
          getODorigin:< (#  OD: ^TopNode do inner  exit OD[] #); 
          kind:< (# ch: @char do '?' -> ch; inner exit ch #);
          sKind:< 
            (# S: ^text do '?' -> S[]; inner exit S[] #);   
          xKind:< (# K: @integer do inner exit K #);
          enclosingImperative:<
            (# imp: ^TopNode
            do inner;
               (if imp[] = none then 
                   (if father[] <> none then 
                       father.enclosingImperative -> imp[];
               if)if)
            exit imp[]
            #);
          findNextImp:<
            (# bcp: @integer; impx: ^TopNode
            enter bcp
            do inner
            exit impx[]
            #);
          actionPos:<
            (# begin: @integer 
            do inner
            exit begin
            #);
          doMapBCposToCharRange:<
            (# lsc,B,E: @integer
            enter lsc
            do inner
            exit(B,E)
            #);
          beginPos,endPos: @integer; (* position of this(TopNode) in .bet file *)
          beginBCP,endBCP: @integer; (* bytecode position at beginning and 
                                      * end of this TopNode set by 
                                      * generator::imperative::gen
                                      *)          
          setOSDVisibility:< 
            (# value: @integer enter value do inner #);
          configureX:< 
            (# visibility: @integer do inner exit visibility #);
          setUpOrigin:< 
            (# org: ^TopNode
            enter org[]
            do org[] -> origin[]; inner 
            #);

          getDescNo:< 
            (# dNo: @integer 
            do inner;
               (if dNo = 0 then
                   (*'\n**** Perhaps no binding of virtual getDescNo: ' ->puttext;
                   'dNo = 0 label: ' -> puttext; label -> putline;
                   this(topNode).doPt -> putline*)
               if)
            exit dNo 
            #);
          getOrigin:< (# org: ^TopNode do inner exit org[] #);
               
          collectSimple:<
            (# addSimple: ##SimpleCollector
            enter addSimple##
            do inner
            #);
          getNameForOff:<
            (# attOff,descNo: @integer; isRef,isIndexed: @boolean;
               NM: ^text
            enter(attOff,descNo,isRef,isIndexed)
            do inner
            exit NM[]
            #);
          visibility:< (# VI: @ integer do inner exit VI #);
          
          isChecked,beingChecked: @boolean;
          origin: ^vNode; 
       do inner
       exit this(TopNode)[]
       #);
     getObjectDesc:< 
       (# descNo: @integer; D: ^TopNode 
       enter descNo 
       do inner;
       exit D[]
       #);
     SimpleCollector:
       (# name: ^text; off,kind: @integer; dcl: ^TopNode;
       enter(name[],off,kind,dcl[])
       do inner
       #);
     theErrorModule:< 
       (# eModule: ^Object; iM: ^iModule
       do inner;
          (if eModule[] <> none then
              &iModule[] -> iM[];
              eModule[] -> IM.M[]
          if)
       exit iM[] 
       #);
     pathToErrorModule:< (# path: ^text do inner exit path[] #);
     mainDescNo:< integerValue;
     runtimeDescs:< 
       (# rtDescs: ^Object do inner exit rtDescs[] #);
     
     iModule:< 
       (# eq: BooleanValue
            (# M1: ^iModule
            enter M1[]
            do (if M1[] <> none then
                   M[] = M1.M[] -> value
                else 
                   M[] = NONE -> value;
                   '\n***iModule: argument M1 is none'->putline;
               if)
            #);
          doPT: (# exit true -> M.doPT #);
          name:< (# exit M.moduleName #);
          pathToFN: (# exit M.pathToModuleFN #);
          inFile: 
            (# F: ^File enter F[] do(*exit*) F[]-> M.innFile -> F[] exit F[] #);
          handleDirModules: (#do M.doHandleDirModules #);
          origin: 
            (#
            exit (M.getOrigin).theiModule 
            #);
          desc:< (# exit M.MyDesc #);
          M: ^TopNode;
       exit M[] 
       #);
     iRootModule:< (# rootM: ^iModule do inner exit rootM[] #);

     browserItem:<
       (# T,N: ^text; kind: @char; xKind: @integer; syntaxErr: @boolean 
       enter T[]
       do inner
       exit(N[],xKind,kind,syntaxErr)
       #);
     mkDecl:<
       (# name: ^text; kind: @char; 
          pathToinn: ^Text; (* the current path to inn 
                             * needed for parsing a module 'mod: /'
                             * Consider if really needed!? *)
          errors: ^Text; dcl: ^TopNode;
       enter(name[],kind,pathToinn[])
       do inner
       exit(errors[],dcl[])
       #);     
     parseDecl:<
       (# in: ^Text; errors: ^stream; dcl: ^TopNode
       enter in[]
       do inner
       exit(errors[],dcl[])
       #);
     parseX_Decl:<
       (# in: ^Text; 
          errors: ^stream; dcl: ^TopNode;
          name: ^Text; kind: @integer
       enter in[]
       do inner
       exit(errors[],dcl[],name[],kind)
       #);
     pModuleX:<
       (# inn: ^text; iM: ^iModule
       enter inn[]
       do inner
       exit iM[]
       #);
     mkModuleItem:<
       (# name: ^text; kind: @char; pathToModule: ^text; moduleF: ^File;
          itemT,att: ^text; dcl: ^TopNode;
       enter(name[],kind,pathToModule[],moduleF[])
       do inner 
       exit(itemT[],att[],dcl[])
       #);     
     handle: (# first,last: @integer enter(first,last) do inner #); 
     handleReservedId:<
       (# theHandler: ##handle;
          inn: ^text; first,last: @integer
       enter(inn[],theHandler##)
       do inner;
       #);
     noBinding:
       (# N: ^object; T: ^Text; thisNode: ^TopNode
       enter(N[],T[],thisNode[])
       do (if N[] = none then
              '\n*** Virtual: ' -> puttext;  T[] -> puttext;
              ' may not be bound' -> putline;
              thisNode.doPT -> putline;
          if)
       #);
     lineWidth: @integer;
     
     mark: @boolean;  (* True if beginPos and endPos are updated in AST
                       * mark = True when using doPT for doing PT to
                       *             edit buffer
                       * mark = false when using doPT for debugging purposes
                       *)
     withPos: @boolean; (* called from minienv and positions are included
                         * Elim this var from miniCompiler::parser *)
     lx: ^text;
     ind,accL: @ integer;
     
     LG: ^LOG;
     fullPath: @boolean;       
     theM: ^TopNode;
     FN: ^text;
     iMain: ^iModule;
     error_stream: ^Stream
  enter(LG[],fullPath,theM[],FN[])       
  do 80-> linewidth;
     inner
  exit(iMain[],error_stream[])
  #)
