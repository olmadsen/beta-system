ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE 'directoryComponents'
INCLUDE 'log';
---lib:attributes---
int2text:
  (# V: @integer; T: @text enter V do V -> T.putint exit T[] #);
putBoolean:
  (# B: @boolean enter B 
  do (if B then 'True' -> puttext else 'False ' -> puttext if)
  #);
Tree: DirectoryModules
  (# SimpleKind: (# exit 1 #);
     PatternKind: (# exit 2 #);
     ReferenceKind: (# exit 3 #);
     RepetionKind: (# exit 4 #);
     VirtualKind: (# exit 5 #);
     isXbeta: @boolean;
     
     TopNode:
       (# vNode:< TopNode;
          label:< (# lab: ^text do '???' -> lab[]; inner exit lab[] #);
          doPP:
            (#
            do &text[] -> lx[];
               0 -> ind;
               PP;
               false -> mark;
            exit lx[]
            #);
          PP:< 
            (# 
            do lx.newline;
               (for i: ind repeat ' ' -> lx.put for);
               '(' -> lx.put; 
               inner;
               (if son[] = none then
                   ')' -> lx.put;
                   (* lx.newline;
                   (for i: ind repeat ' ' -> lx.put for);*)
                else
                   ind + 1 -> ind;
                   (* lx.newline;
                    (for i: (ind + 1 -> ind) repeat ' ' -> lx.put for);*)
                   scanSons(# do current.PP  #);
                   (*lx.newline;*)
                   (*(for i: (ind - 1 -> ind) repeat ' ' -> lx.put for);*)
                   ')' -> lx.put; 
                   (*lx.newline;
                    (for i: (ind - 1 -> ind) repeat ' ' -> lx.put for);*)
                   ind - 1 -> ind
               if);
            exit lx[] 
            #);
          doPT:
            (#
            enter mark
            do &text[] -> lx[];
               PT;
               false -> mark;
            exit lx[]
            #);
          doP:
            (# pos: @integer; break: @boolean;
            enter(pos,break)
            do &text[] -> lx[];
               (0,true) -> PT;
            exit lx[]
            #);
          length:< integerValue(# do inner #);
          PT:<
            (# pos: @integer; break: @boolean;
               block:
                 (# pos,width: @integer; break: @boolean
                 enter(pos,width)
                 do lineWidth < (pos + width) -> break;
                    inner
                 #);
               mkBreak:
                 (# pos: @integer; break: @boolean;
                 enter(pos,break)
                 do (if lx.length > 0 then (* no break or space if first line *)
                        (if break then
                            lx.newline;
                            (for i: pos repeat ' ' -> lx.put for)
                         else
                            inner
                    if)if)
                 #);
               mkBreak0: mkBreak(##);
               mkBreak1: mkBreak(# do ' ' -> lx.put #);
               printComment: (# do #);
            enter(pos,break) 
            do (if mark then lx.getpos -> beginPos  if);
               (if comment[] <> none then printComment if);
               inner;
               (if mark then lx.getpos -> endPos if)
            exit lx[]
            #);
          son,next,last,father: ^TopNode;
          clear:< (* Sets all variables in AST to initial values
                   * Needed when compile is called more than once
                   * on the same AST
                   *)
            (# 
            do false -> isChecked -> beingChecked; 
               inner;
               scanSons(# do current.clear #)
            #);
          append:
            (# N: ^TopNode
            enter N[]
            do (if N[] = none then 
                   (dumpStack,'Tree.bet::TopNode::append') -> stop
               if);
               (if son[] = none then
                   N[] -> son[]
                else
                   N[] -> last.next[]
               if);
               N[] -> last[];
               this(TopNode)[] -> N.father[]
            #);
          noOfSons: IntegerValue
            (#
            do scanSons(# do value + 1 -> value #)
            #);
          scanSons:
            (# current: ^vNode;
               next: (# exit current.next[] #);
               isFirst: @boolean;
               isLast: (# exit current.next[] = none #);
            do son[] -> current[];
               true -> isFirst;
               Loop:
                 (if current[] <> none then
                     inner;
                     current.next[] -> current[];
                     false -> isFirst;
                     restart loop
                 if)
            #);
          scanReverse:
            (# current: ^TopNode;
               isLast: @boolean;
               L: [5] ^TopNode; top: @integer
            do scanSons
               (# do (if (top+1->top) > L.range then L.range -> L.extend if);
                  current[] -> L[top][]
               #);
               (for i: top repeat 
                    L[top+1-i][] -> current[];
                    i = top -> isLast;
                    INNER
               for)
            #);
          scanSubTree:
            (# doIt:<
                 (# current: ^topNode
                 enter current[]
                 do inner 
                 #);
            do this(topNode)[] -> doIt;
               scanSons
               (#
               do 
                  &current.scanSubTree(# doIT:: (# do current[] -> this(scanSubTree).doIT #)#)
            #)#);
          scanSubTreeX:
            (# doIt:<
                 (# current: ^topNode
                 enter current[]
                 do inner 
                 #);
            do scanSons
               (#
               do current[] -> doIt;
                  &current.scanSubTree(# doIT:: (# do current[] -> this(scanSubTree).doIT #)#)
            #)#);        
          getComment:<
            (# comm: ^text
            do inner
            exit comm[]
            #);
          doInsert:<
            (# N,atN: ^TopNode;
            enter(N[],atN[])
            do inner
            #);
          doDelete:<
            (# N: ^text
            enter N[]
            do inner
            #);
          doMoveUp:< (#  N: ^TopNode enter N[] do inner #);
          adjustForSingularImp:< 
            (# bPos,ePos: @integer;
               OD: ^TopNode;
            enter(OD[],bPos,ePos) 
            do inner 
            exit(OD[],bPos,ePos)
            #);          
          replaceEntity:<
            (# errors: ^stream;
               path2Module,T: ^text
            enter(path2Module[],T[])
            do inner
            exit errors[]
            #);
          objDescEQ:< booleanValue
            (# trace: (#exit false #);
               dn: @integer 
            enter dn 
            do (if trace then
                   '*** objDescEq: ' -> puttext; dn -> putint; newline if);
               inner;
               (if trace then ' ' -> put; value -> putBoolean if);
            #);
          findNodeAtPos:<
            (# pos: @integer; N: ^TopNode;
               trace: (# exit false #)
            enter pos
            do inner
            exit N[]
            #);
          theModule:<
            (* Bindings in parser::module and parser.:nameApl *)
            (# md: ^TopNode
            do inner;
               (md[],'theModule',this(TopNode)[]) -> noBinding
            exit md[]
            #);
          moduleName:< 
            (# N: ^Text 
            do inner;
               (N[],'moduleName',this(TopNode)[]) -> noBinding
            exit N[] #);
          pathToModuleFN:< (# path: ^text do inner exit path[] #);
          innFile:< (# F: ^File enter F[] do inner exit F[] #);
          doHandleDirmodules:< (# do inner #);
          theImodule:
            (# iM: ^iModule;
               M: ^TopNode
            do (if (theModule -> M[]) <> none then
                   &iModule[] -> iM[];
                   M[] -> iM.M[]
               if)
            exit iM[]
            #);
          isNameApl:< (# Na: ^TopNode do inner exit Na[] #);
          getDeclModule:<
            (# to: ^iModule;
               dclx: ^TopNode
            do inner
            exit(to[],dclx[])
            #);
          isAmodule:< (# M: ^iModule do inner exit M[] #);
          changeAttName:< 
            (# oldName,newName: ^text enter(oldName[],newName[]) do inner #); 
          getEntries:<
            (* An entry has  the form
             *    entry = (name,sort = (kind,entity))
             * For an objectDesc, a declaration is an entyr:
             *    dcl = (nameDcl, item=(kind,objectSpec))
             *)
            (# add:
                 (# T,N: ^text; E: ^TopNode
                 enter(T[],E[])
                 do T.copy -> N[];
                    (if E[] <> none then
                        E.skind -> N.puttext
                     else
                        '%' -> N.put
                    if);
                    1 -> names.extend; 1 -> entries.extend;
                    N[] -> names[names.range][]; 
                    E[] -> entries[entries.range][]
                 #);
               names: [0] ^Text; entries: [0]^TopNode
            do inner
            exit(names[],entries[])
            #);
          sort:< 
            (# S: ^TopNode 
            do inner;
               (S[],'Sort',this(TopNode)[]) -> noBinding;
            exit S[]#);
          entity:< 
            (# E: ^TopNode 
            do inner; 
               (E[],'Entity',this(TopNode)[]) -> noBinding
            exit E[] #);
          myDesc:< 
            (# OD: ^TopNode
            do inner;  
               (if OD[] = none then
                   'Trans:myDesc:missing virtual binding in sub: ' -> putline;
                   doPT -> putline ;
                   PP -> putline
               if)
            exit OD[] 
            #);
          getODorigin:< (#  OD: ^TopNode do inner  exit OD[] #); 
          kind:< (# ch: @char do '?' -> ch; inner exit ch #);
          sKind:< 
            (# S: ^text do '?' -> S[]; inner exit S[] #);   
          xKind:< (# K: @integer do inner exit K #);
          enclosingImperative:<
            (# imp: ^TopNode
            do inner;
               (if imp[] = none then 
                   (if father[] <> none then 
                       father.enclosingImperative -> imp[];
               if)if)
            exit imp[]
            #);
          findNextImp:<
            (# bcp: @integer; impx: ^TopNode
            enter bcp
            do inner
            exit impx[]
            #);
          comment: ^text;
          actionPos:<
            (# begin: @integer 
            do inner
            exit begin
            #);
          doMapBCposToCharRange:<
            (# lsc,B,E: @integer
            enter lsc
            do inner
            exit(B,E)
            #);
          beginPos,endPos: @integer; (* position of this(TopNode) in .bet file *)
          beginBCP,endBCP: @integer; (* bytecode position at beginning and 
                                      * end of this TopNode set by 
                                      * generator::imperative::gen
                                      *)          
          setOSDVisibility:< 
            (# value: @integer enter value do inner #);
          configure:< 
            (# visibility: @integer do inner exit visibility #);
          setUpOrigin:< 
            (# org: ^TopNode
            enter org[]
            do org[] -> origin[]; inner 
            #);

          getDescNo:< 
            (# dNo: @integer 
            do inner;
               (if dNo = 0 then
                   (*'\n**** Perhaps no binding of virtual getDescNo: ' ->puttext;
                   'dNo = 0 label: ' -> puttext; label -> putline;
                   this(topNode).doPt -> putline*)
               if)
            exit dNo 
            #);
          getOrigin:< (# org: ^TopNode do inner exit org[] #);
               
          collectSimple:<
            (# addSimple: ##SimpleCollector
            enter addSimple##
            do inner
            #);
          getNameForOff:<
            (# attOff,descNo: @integer; isRef,isIndexed: @boolean;
               NM: ^text
            enter(attOff,descNo,isRef,isIndexed)
            do inner
            exit NM[]
            #);
          visibility:< (# VI: @ integer do inner exit VI #);
          
          isChecked,beingChecked: @boolean;
          origin: ^vNode; 
       do inner
       exit this(TopNode)[]
       #);
     getObjectDesc:< 
       (# descNo: @integer; D: ^TopNode enter descNo do inner exit D[]#);
     SimpleCollector:
       (# name: ^text; off,kind: @integer; dcl: ^TopNode;
       enter(name[],off,kind,dcl[])
       do inner
       #);
     theErrorModule:< 
       (# eModule: ^Object; iM: ^iModule
       do inner;
          (if eModule[] <> none then
              &iModule[] -> iM[];
              eModule[] -> IM.M[]
          if)
       exit iM[] 
       #);
     pathToErrorModule:< (# path: ^text do inner exit path[] #);
     mainDescNo:< integerValue;
     runtimeDescs:< 
       (# rtDescs: ^Object do inner exit rtDescs[] #);
     
     iModule:< 
       (# eq: BooleanValue
            (# M1: ^iModule
            enter M1[]
            do (if M1[] <> none then
                   M[] = M1.M[] -> value
                else 
                   M[] = NONE -> value;
                   '\n***iModule: argument M1 is none'->putline;
               if)
            #);
          doPT: (# do 'iModule:doPT:'->puttext; newline; exit true -> M.doPT #);
          name:< (# exit M.moduleName #);
          pathToFN: (# exit M.pathToModuleFN #);
          inFile: 
            (# F: ^File enter F[] do(*exit*) F[]-> M.innFile -> F[] exit F[] #);
          handleDirModules: (#do M.doHandleDirModules #);
          origin: 
            (#
            exit (M.getOrigin).theiModule 
            #);
          desc:< (# exit M.MyDesc #);
          M: ^TopNode;
       exit M[] 
       #);
     iRootModule:< (# rootM: ^iModule do inner exit rootM[] #);

     browserItem:<
       (# T,N: ^text; kind: @char; xKind: @integer; syntaxErr: @boolean 
       enter T[]
       do inner
       exit(N[],xKind,kind,syntaxErr)
       #);
     mkDeclX:<
       (# inn,pathToinn: ^text; (* the current path to inn 
                             * needed for parsing a module 'mod: /' *)
          errors: ^Text; dcl: ^TopNode;
       enter(inn[],pathToInn[])
       do inner
       exit(errors[],dcl[])
       #);
     mkDeclY:<
       (# name: ^text; kind: @char; 
          errors: ^Text; dcl: ^TopNode;
       enter(name[],kind)
       do inner
       exit(errors[],dcl[])
       #);     
     parseDecl:<
       (# in: ^Text; errors: ^stream; dcl: ^TopNode
       enter in[]
       do inner
       exit(errors[],dcl[])
       #);
     parseX_Decl:<
       (# in: ^Text; 
          errors: ^stream; dcl: ^TopNode;
          name: ^Text; kind: @char; skind: ^text
       enter in[]
       do inner
       exit(errors[],dcl[],name[],kind,skind[])
       #);
     pModuleX:<
       (# inn: ^text; iM: ^iModule
       enter inn[]
       do inner
       exit iM[]
       #);
     mkModuleItemDeclX:< (* to be eliminated *)
       (# name: ^text; kind: @char; itemT: ^text; moduleF: ^File;
          pathToModule: ^text;
          dcl: ^TopNode;
       enter(name[],kind,itemT[],pathToModule[],moduleF[])
       do inner
       exit dcl[]
       #);
    mkModuleItemDeclY:<
       (# name: ^text; kind: @char; pathToModule: ^text; moduleF: ^File;
          itemT,att: ^text; dcl: ^TopNode;
       enter(name[],kind,pathToModule[],moduleF[])
       do inner 
       exit(itemT[],att[],dcl[])
       #);     
     noBinding:
       (# N: ^object; T: ^Text; thisNode: ^TopNode
       enter(N[],T[],thisNode[])
       do (if N[] = none then
              '\n*** Virtual: ' -> puttext;  T[] -> puttext;
              ' may not be bound' -> putline;
              thisNode.doPT -> putline;
          if)
       #);
     lineWidth: @integer;
     
     mark: @boolean;  (* True if beginPos and endPos are updated in AST
                       * mark = True when using doPT for doing PT to
                       *             edit buffer
                       * mark = false when using doPT for debugging purposes
                       *)
     withPos: @boolean; (* called from minienv and positions are included
                         * Elim this var from miniCompiler::parser *)
     lx: ^text;
     ind: @ integer;
     
     LG: ^LOG;
     fullPath: @boolean;       
     theM: ^TopNode;
     FN: ^text;
     iMain: ^iModule;
     error_stream: ^Stream
  enter(LG[],fullPath,theM[],FN[])       
  do 40-> linewidth;
     inner
  exit(iMain[],error_stream[])
  #)
