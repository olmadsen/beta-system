ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/directory';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/sysutils/envstring'
---Lib:attributes---
machine_type: external (# T: [1]@ char  exit T #);

BetaLib: (# path: ^text do '$(BETALIB)' -> expandEnvVar -> path[] exit path[] #);

BetaFile: File
  (# isOpen: @boolean; 
     doOpenRead: 
       (# do (if not isOpen then openRead; true -> isOpen if); setPos #);
     doClose: (# do (if isOpen then close; false -> isOpen if) #);
  #);
createBackUpFile:
  (# F: ^File; FN: ^text
  enter F[]
  do (# B: ^BetaFile; T: ^text
     do (if F[] = none then '!!!!F is none ' -> putline if);
        (if F.name = none then '!!!! F.name is none' -> putline if);
        (F.name).copy -> FN[];
        '.back' -> (FN.copy -> T[]).append;
        (if false then
            '\n**** rename: ' -> putline; FN[] -> putline;
            '**** to: ' -> putLine; T[] -> putline;
        if);
        &BetaFile[] -> B[];
        T[] -> B.name;
        (if B.entry.exists then 
            (* '**** exists: ' -> putLine; T[] -> putline;*)
            B.delete 
        if);
        T.copy -> F.entry.rename;
     #)
  exit FN[]
  #);
newSourceFile:
  (# FN,content: ^text; F: ^File
  enter(FN[],content[])
  do &BetaFile[] -> F[];
     FN[] -> F.name;
     F.openWrite;
     content[] -> F.puttext; 
     F.close
  exit F[]
  #);
mkAuxName:
  (# FN,ext: ^text; auxF: ^text
  enter(FN[],ext[])
  do (* Somehow clumsy ;-) *)
     (if true 
      // '.bet' ->  ((FN.length-3,FN.length) -> FN.sub).equal then 
         (1,FN.length-4) -> FN.sub -> auxF[];
      // '.xbeta' ->  ((FN.length-5,FN.length) -> FN.sub).equal then 
         (1,FN.length-6) -> FN.sub -> auxF[];
      else
         '\n***** Invalid file name: ' -> puttext; FN[] -> putline;
     if);
     (*auxF[] -> screen.putline;*)
     ext[] -> auxF.append;
     (* auxF[] -> screen.putline*)
  exit auxF[]
  #);          

DirectoryModules:
  (# initDirectoryModules:<
       (# ext: ^Text;
       enter(BetaWorld[],ext[])
       do ext[] -> SrcExt[];
          ext.length -> SrcExtlgth
       #);

     DirCh: 
       (# ch: @char; T: @text
       do machine_type -> T;
          (if 'linux' -> T.equal then  '/' -> ch else '\\' -> ch if)
       exit ch
       #);
     getCWD:
       (# fullPath,CWD: ^text
       enter fullPath[]
       do fullPath.copy -> CWD[];     
          (# lastDir: @integer 
          do CWD.scanAll
             (# pos: @integer 
             do pos + 1 -> pos; 
                (if ch // '/' //  dirCh then pos -> lastDir if)
             #);
             (lastDir,CWD.length) -> CWD.delete;
          #)
       exit CWD[]
       #);   
     prependPathToBetaWorld:
       (# fn,path,fullPath: ^text
       enter fn[]
       do BetaLib -> path[];
          BetaWorld[] -> path.append;
          fn[] -> path.append -> path[];
          &text[] -> fullPath[];
          path.scanAll
          (#do (if ch = '/' then dirCh -> fullPath.put else ch -> fullPath.put if)#);
       exit fullPath[]
       #);

     getCurrentDir:
       (# getCurDir: External
            (# cwd: [1]@char;
            exit cwd
            #);
          cwd: ^text;
       do &text[]->cwd[];
          getCurDir->cwd;
       exit cwd[]
       #);
     DirectoryComponents:
       (# D: @directory;
          rpath,dir: ^text;  (* rpath = rpathX/dir *)
          current: ^text;
       enter(rpath[],dir[])
       do rpath[] -> D.name;
          (*D.entry.path.name -> putline;*)
          (*'**** dir: ' -> puttext; dir[] -> putline;*)
          (if D.empty then
              (* 'IS empty' -> putline *)
           else
              (*'XEntries in ' -> puttext; dir[] -> puttext; ':' -> put;*)
              D.scanEntries
              (# T: ^text
              do found.path -> current[]; (* current[] -> putline; *)
                 (if true
                  // '.' -> current.equal
                  // '..' -> current.equal 
                  // (current.length -> current.inxGet) = '~' then
                  else                
                     rpath.copy -> T[];
                     dirCh -> T.put;
                     (if ((SrcExt[] -> ((current.length-SrcExtLgth+1,current.length) -> current.sub).equal))
                         then
                         (if ((1,current.length-SrcExtLgth) -> current.sub -> dir.equalNCS) or BetaBrowser then
                             current[] -> T.append -> current[];
                             inner DirectoryComponents
                          else
                             '\n\n*** In: \n    "' -> puttext;
                             rpath[] -> puttext;
                             '"\n    The name of the componentfile: "' -> puttext;
                             current[] -> puttext;
                             '"\n    does not match the name of the enclosing directory: "'
                               -> puttext;
                             dir[] -> puttext; '"' -> put; newline;
                             stop
                         if)
                     if);
                     (*
                     (if ((SrcExt[] -> ((current.length-SrcExtLgth+1,current.length) -> current.sub).equal)
                         and ((1,current.length-SrcExtLgth) -> current.sub -> dir.equalNCS)) then
                         (* 'Found component file: ' -> puttext; current[] -> putline;* )
                         current[] -> T.append -> current[];
                         inner DirectoryComponents
                     if)*)
                 if)
              #)
          if)
       #);
     getBETAdirectories:
       (# D: @directory;
          rpath: ^text;
          current: ^text;
          cont: [8] ^text; isFile: [8] @ boolean; top: @integer;
          add:
            (# E: ^text; isF: @boolean
            enter(E[],isF)
            do (if (top + 1 -> top) > cont.range then 
                   cont.range -> cont.extend ;
                   isFile.range -> isFile.extend
               if);
               E[] -> cont[top][];
               isF -> isFile[top];
            exit E[]
            #);
          scan:
            (# current: ^text; currentIsFile: @boolean
            do (if true then
                   (for i: top repeat
                        cont[i][] -> current[];
                        isFile[i] -> currentIsFile;
                        inner
                   for)
                else
                   (for i: top repeat
                        (if isFile[i] then cont[i][] -> puttext; ' ' -> put if);
                   for);
                   (for i: top repeat
                        (if not isFile[i] then cont[i][] -> puttext; ' ' -> put if);
                   for);
                   inner
               if)
            #);
          isBETAdir: booleanValue
            (# dir,RP: ^text
            enter dir[]
            do (* 'IsBETAdir: ' -> puttext; rPath[] -> puttext; ' '->put; dir[] -> putline;*)
               rpath.copy -> RP[]; dirCh -> RP.put; dir[] -> RP.append;
               (RP[],dir[]) -> DirectoryComponents(# do true -> value #)
            #);
          allDir: @boolean
       enter(rpath[],allDir)
       do rpath[] -> D.name;
          (* D.entry.path.name -> putline; *)
          (if D.empty then
              (*'IS empty' -> putline*)
           else
              (* 'Entries in ' -> puttext; dir[] -> puttext; ':' -> put; *)
              D.scanEntries
              (# FN,ext: ^text;
              do found.path -> fn[];
                 (if FN.length > SrcExtLgth then
                     (FN.length-SrcExtLgth+1,FN.length) -> FN.sub -> ext[]
                  else 
                     '' -> ext[]
                 if);
                 (if true
                  // '.' -> FN.equal
                  // '..' -> FN.equal
                  // (1 -> FN.inxGet) = '.'
                  // (fn.length -> FN.inxGet) = '~' then
                  else            
                     select
                     (# whenFile:: 
                          (# 
                          do (if SrcExt[] -> ext.equalNCS then 
                                 (fn[],true) -> add
                             if)
                          #);
                        whenDir:: 
                          (# 
                          do (if (FN[] -> isBETAdir) or allDir then
                                 (FN[],false) -> add
                             if)
                          #);
                     #)
                 if)
              #);
              inner getBETAdirectories;
          if)
       #);

     testAndCreateDir: booleanValue
       (# pathD: @directory;
          path,dirN: ^text
       enter(path[],dirN[])
       do (if false then
              '**** TestAndCreateDir:Path: ' -> putline; 
              ' '-> put; path[] -> putline;
              '**    Directory: ' -> puttext; dirN[] -> putLine;
          if);
          path[] -> pathD.name;
          L:
            (if pathD.entry.exists then
                (if true then '**** OK:Path exists!' -> putline if);
                dirN[] -> pathD.createDir
                (# exists:: 
                     (# do '!!!! ERROR: Dir exists' -> putline; leave L #)
                #);
                true -> value
             else
                '!!!! ERROR:Path does not exist' -> putline;
            if)
       #);
     testAndCreateFile: 
       (# pathD: @directory;
          F: ^file;
          path,FN,fullFN,pathX: ^text
       enter(path[],FN[])
       do (if false then
              '**** TestAndCreateFile:Path: ' -> putline; 
              ' ' -> put; ; path[] -> putline;
              '**    File: ' -> puttext; FN[] -> putline;
          if);
          &File[] -> F[];
          path.copy -> pathX[];
          INNER; (* add beta extension *)
          (if false then '**   Create: ' -> puttext; FN[] -> putline; if);
          pathX[] -> pathD.name;
          L:
            (#
            do (if pathD.entry.exists then
                   FN[] ->  pathD.createFile
                   (# exists:: 
                        (#
                        do ' **** ERROR: File exists'->putline; 
                           none -> F[];
                           leave L 
                        #)
                   #);
                   pathX[] -> fullFN[];
                   dirCh -> fullFN.put;
                   FN[] -> fullFN.append;
                   fullFN[] -> F.name;           
                else
                   ' Path does not exists' -> putline
               if);
               (if false then
                   '**** created: ' -> putline; fullFN[] -> putline
               if)
            #)
       exit F[]
       #);
     testAndCreateBetaFile: testAndCReateFile
       (#
       do dirCh -> pathX.put;
          FN[] -> pathX.append;
          srcExt[] -> FN.append;
       #);
     deleteDirectory:
       (# path: ^text;
          dir,DF: @directory; F: @file;
       enter path[]
       do 'Delete dir and its files:'->putline;
          path[] -> putline;
          path[] -> dir.name;
          dir.scanEntries
          (# en: ^text
          do foundFullpath -> en[] -> putline;

             (if true
              // '.' -> ((en.length,en.length) -> en.sub).equal then 'found . or ..'->putline 
              else
                 select
                 (# whenFile::(# do en[] -> F.name; F.delete #);
                    whenDir:: (# do 'Delete of local dir: not implemented' -> putline #)
                 #)
             if)
          #);
          dir.delete
       #);
     fixExtension_bet:
       (# FN: ^text
       enter FN[]
       do (if true
           // (FN.length >= 5) and (SrcExt[] -> ((FN.length-SrcExtLgth+1,FN.length) -> FN.sub).equal) then
              (* FN = '...x.bet' *)
           // (FN.length -> FN.inxGet) = '.' then
              (2,SrcExt.length) -> SrcExt.sub -> FN.append
           else
              SrcExt[] -> FN.append
          if);
       exit FN[]
       #);
     fixExtension_xbeta:
       (# FN: ^text
       enter FN[]
       do (if true
           // (FN.length >= 7) and ('.xbeta' -> ((FN.length-5,FN.length) -> FN.sub).equal) then
              (* FN = '...x.bet' *)
           // (FN.length -> FN.inxGet) = '.' then
              'xbeta' -> FN.append
           else
              '.xbeta' -> FN.append
          if);
       exit FN[]
       #);
     path: @
       (# P: [8] ^text;
          top: @integer;
          init:< (# do 0 -> top #);
          push:
            (# dir: ^text
            enter dir[]
            do (if (top + 1 -> top) > P.range then P.range -> P.extend if);
               dir[] -> P[top][];
            #);
          pop: (# do top - 1 -> top #);
          append:
            (# pth: @text
            do (for i: top repeat 
                    P[i][] -> pth.append;
                    (if i < top then dirCh -> pth.put if)
               for)
            exit pth[]
            #)
       #);
     BetaWorld,
     pathToBetaWorld,
     SrcExt: ^Text;
     SrcExtLgth: @integer;
     BetaBrowser: @boolean;
  do inner     
  #)




