ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/figureitems';
INCLUDE '~beta/guienv/controls';
---windowlib:attributes---
mkArrow:
  (#  pol: @polygon
       (# open:: 
            (# 
            do patterns.dkgray[] -> fill.tile;
            #)
       #);               
     PP: [3] ^point;
     father: ^canvas;
     hPos,vPos: @integer; (* of arrow head *)
     right: @boolean (* head is pointing left *)
  enter(father[],vPos,hPos,right)
  do &point[] -> PP[1][];
     &point[] -> PP[2][];
     &point[] -> PP[3][];
     
     (if right then
         (vPos - 6,hPos - 3) -> PP[1];
         (vpos    ,hPos    ) -> PP[2];
         (vPos - 6,hPos + 3) -> PP[3];
      else
         (vPos + 6,hPos - 3) -> PP[1];
         (vpos    ,hPos    ) -> PP[2];
         (vPos + 6,hPos + 3) -> PP[3];         
     if);
     father[] -> pol.open;
     PP -> pol.points
  exit pol[]
  #);
mkUpArrow:
  (# pol: @polygon
       (# open:: 
            (# 
            do patterns.dkgray[] -> fill.tile;
            #)
       #);               
     PP: [3] ^point;
     father: ^canvas;
     hPos,vPos: @integer; (* of arrow head *)
  enter(father[],vPos,hPos)
  do &point[] -> PP[1][];
     &point[] -> PP[2][];
     &point[] -> PP[3][];
     (vPos - 3,hPos + 6) -> PP[1];
     (vpos    ,hPos    ) -> PP[2];
     (vPos + 3,hPos + 6) -> PP[3];         
     father[] -> pol.open;
     PP -> pol.points
  exit pol[]
  #);

hSeqLine:
  (# l: ^line;
     close:< 
       (# 
       do (if not isClosed then
              l.close; aw.close; 
              inner; 
              true -> father.update;
              true -> isClosed
           else
              'hSeqline was closed: ' -> putline;
              (*none -> l[]; l*)
          if);
       #);
     aw: ^polygon;
     father: ^canvas;
     hPos,vPos,length: @integer;
     right,isClosed: @boolean
  enter(father[],vPos,hPos,length,right)
  do &line[] -> l[]; 
     father[] -> l.open;
     (vPos,hPos) -> l.start;
     (if right then
         (vPos + length,hPos) -> l.end;
         (father[],vPos + length,hPos,right) -> mkArrow -> aw[]
      else
         (vPos - length,hPos) -> l.end;
         (father[],vPos - length,hPos,right) -> mkArrow -> aw[]
     if);
     false -> isClosed;
     inner
  #);
hSeqBrokenLine: hSeqLine
  (* ------
   *      I
   *      I
   *      I
   * <----
   * Always left
   *)
  (# lHtop,lV: ^line;
     close::< 
       (# 
       do (if lHtop[] <> none then lHtop.close if);
          (if lV[] <> none then lV.close if);
          inner 
       #);
     hTopPos,hTopLength: @integer
  enter(hTopPos,hTopLength)
  do &line[] -> lV[];
     father[] -> lV.open;
     &line[] -> lHtop[];
     father[] -> lHtop.open;
     
     (vPos - hTopLength,hTopPos) -> lHtop.start;
     (vPos,hTopPos) -> lHtop.end;
     (vPos,hTopPos) -> lV.start;
     (vPos,hPos+1) -> lV.end  (* whye is +1 needed? *)   
  #);
coLine:
  (* line showing suspended coroutine
   *     ------
   *     I    I
   *     I    I
   * ----I----I
   * I   topPos
   * I
   * I              -----
   * I              I   I
   * I              I   I
   * I              -----
   * I              ^ botPos
   * I              I
   * I              I
   * I              I
   * I--------------I
   *)
  (# leftLgth: (# exit 10 #);
     upLgth: (# exit 15 #);
     father: ^canvas;
     topHpos,topVpos,botHpos,botVpos: @integer;
     l1,l2,l3,l4: ^line;
     a: ^polygon;
     close:
       (#
       do l1.close; l2.close; l3.close; l4.close; a.close
       #)
  enter(father[],topHpos,topVpos,botHpos,botVpos)
  do &line[] -> l1[]; father[] -> l1.open;
     &line[] -> l2[]; father[] -> l2.open;
     &line[] -> l3[]; father[] -> l3.open;
     &line[] -> l4[]; father[] -> l4.open;

     (topVpos,topHpos) -> l1.start;
     (topvPos-leftLgth,topHpos) -> l1.end;
     (topVpos-leftLgth,topHpos) -> l2.start;
     (topVpos-leftLgth,botHpos+upLgth) -> l2.end;
     (topVpos-leftLgth,botHpos+upLgth) -> l3.start;
     (botVpos,botHpos+upLgth) -> l3.end;
     (botVpos,botHpos+upLgth) -> l4.start;
     (botVpos,botHpos) -> l4.end;
     (father[],botVpos,botHpos) -> mkUpArrow -> A[]
     exit this(coLine)[]
  #);
vSeqLine:
  (# l: ^line;
     move:<
       (# dx,dy: @integer
       enter(dx,dy)
       do (if l[] <> none then 
              (if false then
                  ' move l:' -> puttext; 
                  label[] -> puttext; ' ' -> put;
                  dx -> putint; 
                  ' ' -> put; dy -> putint; newline;
              if);
              (dx,dy) -> l.move;
              (dx,dy) -> T.move;
              true -> father.update;
              hPos + dx -> hPos; 
              vPos + dy -> vPos
       if)#);
     close: 
       (# 
       do (if not isClosed and (l[] <> none) then 
              (* none if never executed *)
              l.close;
              T.close;
              true -> isClosed;
              true -> father.update;
          if) 
       #);
     showPos:
       (#
       do 'h:' -> puttext; hPos -> putint;
          ' v:' -> puttext; vPos -> putint; 
          ' lgth: ' -> puttext; length -> putint; newline
       #);
     father: ^canvas;
     isClosed: @boolean;
     hPos,vPos,length: @integer;
     label: ^text;
     T: ^StaticText (* onlye used for debugging purpuse *)
  enter(father[],vPos,hPos,length,label[])
  do &line[] -> l[];
     father[] -> l.open;
     2 -> l.pen.size;
     (vPos,hPos) -> l.start;
     (vPos,hPos + length) -> l.end;
     &StaticText[] -> T[];
     father[] -> T.open;
     (40,16) -> T.size;
     label[] -> T.label;
     (vPos-20,hPos+length) -> T.position;
     false -> isClosed;
  exit l[]
  #);
seqLine:
  (# l: ^line;
     start,end: @point;
     close:< (# do (if l[] <> none then l.close if); inner #);
     father: ^canvas
  enter(father[],start,end)
  do &line[] -> l[];
     father[] -> l.open;
     start -> l.start;
     end -> l.end;
  exit l[]
  #)
     

         
