ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'zchecker';
INCLUDE '../miniCompiler/objectcode'
---lib:attributes---
generator: checker
  (# MkCom: (# t1,t2: ^text enter (t1[],t2[]) do t2[] -> T1.append -> cd.comment #);
     
    Module::
       (# gen::
            (#
            do ('Comp',newDesc.noOfDescs) -> cd.newComponent;
               SO.gen;
               this(Module)[] -> main[]
            #);
       #);
     StaticObject::
       (# gen::
            (# T: @text
            do (if not OG.IV.isSimple then 
                   '\nStaticObject is not Simple' -> cd.comment;
                   (if origin[] <> none then 
                       cd.pushThis;
                       OG.descNo -> T.putint;
                       ('staticObject: alloc: ',T[]) -> cd.com2; 
                       OG.gen;
                       cd.rswap;
                       (sig.id[],this(StaticObject).off) -> cd.rstoreg
                    else
                       (* A module object *)
                       (if not OG.IS.isEmpty then 
                           (sig.id[],none,OG[]) ->  ObjTmpStack.add
                       if)   
                   if)
               if)
            #);
          activate:: 
            (* called when Receiver *)
            (# 
            do 'StaticObject:activate: '->puttext; dopt -> putline;
               (if not OG.IV.isSimple then 
                   ('StaticObject:activate: ',dopt) -> cd.com2;
                   (sig.id[],this(StaticObject).off) -> cd.rpushg
               if)
            #);
          load::
            (* called when not receiver - i.e. value to be pushed *)
            (#
            do 'StaticObject:load: '->puttext; dopt -> putline;
               (sig.id[],off) -> cd.pushg
            #);
          store::
            (* called when var to be stored
             * does not seem to be used since store happens in Binary
             *)
            (#
            do 'StaticObject:store: '->putline; (sig.id[],off) -> cd.push
            #);
       #);
     ObjTmpStack: @
       (# item: 
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate;
            enter(N[],sig[],OT[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate;
            enter(N[],sig[],OT[])
            do (if (top+1-> top) > OTL.range then OTL.range -> OTL.extend if);
               (N[],sig[],OT[]) -> item -> OTL[top][]
            #);          
          next:
            (# inx: @integer
            do Loop:
                 (#
                 do inx +1 -> inx;
                    (if inx <= top then
                        (OTL[inx].N[],OTL[inx].sig[]) -> OTL[inx].OT.genClass;
                        restart Loop
                    if);
                 #)
            #);               
          OTL: [10] ^Item;top: @integer;
       #);
     genMain:
       (# descno: @integer
       do ('main',newDesc,false,1,0) -> cd.class;
          cd.pushThis;
          (*  (if false then
           *               'main: topModule: ' -> puttext;
           *               markIncludes.topModule.name.lexemSy -> puttext;
           *           if);
           *           ('BETAworld',(markIncludes.topModule.desc).descno,true) -> cd.alloc;
           *           (for i: markIncludes.top repeat
           *                ('origin',markIncludes.orgOff[markIncludes.top - i + 1]) -> cd.rpushg;
           *           for);
           *
           * ('x','S') -> (markIncludes.main.desc).doCall;          
           *)
          ('BETAworld',1,true) -> cd.alloc;
          (* ('x','S') -> (main.desc).doCall;          *)
          cd.stop; (* we should generate stop here and not in betaVM *)
          
          (*   (if markIncludes.main## <> ObjectModule## then
           *               '\n\n***** Only ObjectModules can be executed *****\n\n' -> putline
           *           if)
           *)
       #);
     genEventProcessor:
       (#
       do ('EventProcessor',newDesc,false,1,0) -> cd.class;
          cd.stop (* we should generate stop here and not in betaVM *)
       #);
     
     main: ^Module;
     mainDescNo: (# exit newDesc.noOfDescs -1 (*- 2*) (* ad hoc *) #);
     cd: @ObjectCode;
     descs: ^RunTimeDescriptors;
     bclst: @File;     
  do 'Generator' -> putline;
      (if true then
         'xcode'-> bclst.name;
         bclst.openWrite;
         bclst[] -> cd.init;
         'xbeta'-> cd.comment;
         m.gen;
         ObjTmpStack.next;
         genMain;
         genEventProcessor;
         cd.dump;
         cd.descs[] -> descs[]; (* why ?*)         
         bclst.close;
     if)
  #)
(* ---program:descriptor---
 * (# gen: @generator;
 *    FN: ^text;
 *    F: @file;
 * do 'ybeta compiler: ' -> puttext;
 *    2 -> arguments -> FN[];
 *    (if ('-x' -> FN.equalNCS) then      
 *        ' ' -> put;
 *        3 -> arguments -> FN[]
 *     else
 *        true -> gen.doParse
 *    if);
 *    FN[] -> fixExtension_xbeta -> FN[] -> putline;
 *    FN[] -> F.name;
 *    F.openRead;
 *    F[] -> gen;
 *    
 * #)
 * 
 *)
