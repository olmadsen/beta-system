ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'zchecker';
INCLUDE '../miniCompiler/objectcode'
---lib:attributes---
generator: checker
  (# MkCom: (# t1,t2: ^text enter (t1[],t2[]) do t2[] -> T1.append -> cd.comment #);
     
    Module::
       (# gen::
            (#
            do ('Comp',newDesc.noOfDescs) -> cd.newComponent;
               SO.gen;
               this(Module)[] -> main[];
            #);
       #);
     StaticObject::
       (# gen::
            (# T: @text
            do (if not OG.IV.isSimple then 
                   'StaticObject is not Simple' -> cd.comment;
                   'StaticObject is not Simple: ' -> puttext; 
                   dopt -> putline;
                   doPT -> cd.comment;
                   (if origin[] <> none then 
                       cd.pushThis;
                       OG.descNo -> T.putint;
                       ('staticObject: alloc: ',T[]) -> cd.com2; 
                       OG.gen;
                       cd.rswap;
                       (sig.id[],this(StaticObject).off) -> cd.rstoreg
                    else
                       (* A module object *)
                       (if not OG.IS.isEmpty then
                           '\nAdd: ' -> puttext; sig.id[] -> putline;
                           (sig.id[],none,OG[]) ->  ObjTmpStack.add
                       if)   
                   if)
               if)
            #);
          loadAdr:: 
            (* Called when Receiver 
             * R: @ Foo or R: @ Foo{...} -> push R = adr of object
             * X: @integer -> no action
             *)
            (# 
            do 'StaticObject:loadAdr: '->puttext; dopt -> putline;
               ('StaticObject:loadAdr: ', dopt) -> mkCom;
               (*cd.pushThis;*)
               (if not OG.IV.isSimple then 
                   ('StaticObject:loadADr: ',dopt) -> cd.com2;
                   (sig.id[],this(StaticObject).off) -> cd.rpushg
               if)
            #);
          load::
            (* called when not receiver - i.e. value to be pushed *)
            (#
            do 'StaticObject:load: '->puttext; dopt -> putline;
               (sig.id[],off) -> cd.pushg
            #);
          store::
            (* called when var to be stored
             * does not seem to be used since store happens in Binary
             *)
            (#
            do 'StaticObject:store: '->putline; (sig.id[],off) -> cd.push
            #);
       #);
     ObjectGeneration::
       (# gen::
            (# 
            do (*('OG: ',OI.inv.compoundSymb[]) -> MkCom;*)
               (*IS.inv.ATd.doPT -> putline*)
               (if IS.isEmpty then
                   (* check this - called when R.foo *)
                   IV.gen
                else
                   (* called when R.foo{ } *)
                   IV.loadOrigin;
                   ('Singular',descno,true) -> cd.alloc;
                   'IV:add:singular: '-> puttext; doPT -> putline;
                   ('Singular',none,this(ObjectTemplate)[]) -> ObjTmpStack.add
               if)
            #);
          genClass::
            (#
            do '\nGenClass:' -> puttext; N[] -> putline;
               (N[],sig[],descNo) -> IS.genClass
            #)
       #);
     ObjectDesc::
       (#
          genClass::
            (#
            do '\nGenClass:' -> puttext; N[] -> putline;

               (N[],sig[],descNo) -> IS.genClass
            #)
       #);
     items::
       (# genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; T: @text
            enter(N[],sig[],descNo)
            do     
               (N[], descNo, false, 1,1) -> cd.class;
               (* super *)
               ('origin',originOff) -> cd.rstore; 
               scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if I.isDecl then 
                      current.dopt -> CD.comment; 
                      current.gen; 
                  if) 
               #);
               scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if not I.isDecl then 
                      current.dopt -> CD.comment;
                      current.gen
                  if) 
               #);
               'D' -> cd.rtn;
               (vsize,rsize,1) -> CD.endClass     
            #);
          ifPrim: BooleanValue
             (#
             do (if isPrim then
                    true -> value;
                    inner
                if)
             #);
          ifPrimExePrim: ifPrim
            (#
           do props.getProp
               (# whenPrim:: 
                    (# 
                    do 'more prim: '->puttext; primNo -> putint; newline;
                       (if true
                        // primNo =  2 then 
                           ('put',primNo) ->  cd.CallPrim
                        //  50 <= primNo  then
                           primNo -> cd.op
                       if)                       
                    #)
               #);
            #)
       #);
     UnaryPattern::
       (# gen:: (# do (sig.id[],sig[],OD[]) -> objTmpStack.add #);
          loadAdr::
            (#
            do (* 'Pattern:loadAdr: '->puttext; doPT -> putline;*)
            #);
          load::
            (#
            do 'Pattern:load: '->puttext; doPT -> putline;
               ('Pattern:load: ',doPT) -> cd.com2;
               (sig.id[],OD.descno,true) -> cd.alloc;
               (*cd.rpop;*) (* depend on the return type *)
               (* and perhaps a difference
                *    R: @foo -- no rpop
                *    foo;    -- if foo on rstack it should be popped
                *)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);   
       #);
     BinaryPattern::
       (# gen:: (# do (sig.id[],sig[],OD[]) -> objTmpStack.add #);
          ifPrim:: 
            (#
            do OD.IS.ifPrim -> value
            #);
          loadAdr::
            (#
            do 'Pattern:loadAdr: '->puttext; doPT -> putline;
            #);
          load::
            (#
            do 'Pattern:load: '->puttext; doPT -> putline;
               ('Pattern:load: ',doPT) -> cd.com2;
               (if true then
                   (if not OD.IS.ifPrimExeprim then 
                       (sig.id[],OD.descno,true) -> cd.alloc;
                       cd.rpop; (* depend on the return type *)
                   if)
                else                   
                   (if '+' -> sig.id.equal then 
                       (* if primitive then ... *)
                       lex.symbols.add -> cd.op 
                    else
                       (sig.id[],OD.descno,true) -> cd.alloc;
                       cd.rpop; (* depend on the return type *)
                       (*('x','S') -> OD.doCall; *)
               if)if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #); 
       #);
     FunctionalPattern::
       (# gen:: (# do (sig.id[],sig[],OD[]) -> objTmpStack.add #);
          pushThis::
            (#
            do (if not OD.IS.ifPrim then cd.pushThis if)
            #);
          loadAdr:: (# #);
          load:: 
            (# 
            do (if not OD.IS.ifPrimExeprim then 
                   (sig.id[],OD.descno,true) -> cd.alloc 
               if)
            #);
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.loadAdr
        *    E2.loadAdr
        *    E3.execute
        * R.foo
        * R.foo{...}
        * X:= y + 12
        *)
       (# gen:: 
            (# first: @boolean
            do 'Invocation:gen: '->puttext;
               true -> first;
               scanSons
               (# E: ^Exp
               do current[] -> E[];
                  (if first then E.pushThis if);
                  (if not isLast then 
                      E.loadAdr 
                   else
                      E.execute
                  if);
                  false -> first
               #)
            #);
          loadOrigin:
            (# 
            do 'Invocation:loadOrigin' -> cd.comment
            #);
       #);
     Unary::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        * ATd = operator.Decl
        *)
       (# pushThis:: (#do cd.pushThis #); (* Perhaps loadOrigin?*)
          loadAdr:: (# do ATd.loadAdr #);
          execute:: (# do ATd.load #);
       #);
     Binary::
       (# pushThis:: (#do cd.pushThis #);
          loadAdr:: (# do execute #);
          execute::
            (#
            do rec.ATd.loadAdr;
               (* (if '+' -> operator.T.equal then 
                *                    ('$x',rec.ATD.off) -> cd.pushg 
                *                if);
                *)
               argument.gen;
               (if isAssign then 
                   ('var',rec.ATd.off) -> cd.storeg
                else
                   (if ATd.ifPrim then
                       ('$x',rec.ATD.off) -> cd.pushg 
                   if);
                   (if ATd[] = none then 
                       'none' -> putline
                    else
                       ATd.load
                   if);
               if)
            #)
       #);
     Function::
       (# pushThis:: (#do ATd.pushThis #);
          loadAdr:: (# do execute #);
          execute::
            (# first: @boolean
            do ATd.loadAdr;
               true -> first;               
               scanSons
               (#
               do (if not first then
                      current.gen
                  if);
                  false -> first
               #);
               (if ATd[] = none then 
                   'none' -> putline
                else
                   ATd.load
               if)
            #)          
       #);
     Const::
       (# execute:: (# do L.T.setpos; L.T.getInt -> cd.pushConst #);
       #);
     ObjTmpStack: @
       (# item: 
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate;
            enter(N[],sig[],OT[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate;
            enter(N[],sig[],OT[])
            do (if not OT.IS.isSimple and not OT.IS.isPrim then
                   (if (top+1-> top) > OTL.range then OTL.range -> OTL.extend if);
                   (N[],sig[],OT[]) -> item -> OTL[top][]
               if)
            #);          
          next:
            (# inx: @integer
            do Loop:
                 (#
                 do inx +1 -> inx;
                    (if inx <= top then
                        (OTL[inx].N[],OTL[inx].sig[]) -> OTL[inx].OT.genClass;
                        restart Loop
                    if);
                 #)
            #);               
          OTL: [10] ^Item;top: @integer;
       #);
     genMain:
       (# descno: @integer
       do ('main',newDesc,false,1,0) -> cd.class;
          cd.pushThis;
          (*  (if false then
           *               'main: topModule: ' -> puttext;
           *               markIncludes.topModule.name.lexemSy -> puttext;
           *           if);
           *           ('BETAworld',(markIncludes.topModule.desc).descno,true) -> cd.alloc;
           *           (for i: markIncludes.top repeat
           *                ('origin',markIncludes.orgOff[markIncludes.top - i + 1]) -> cd.rpushg;
           *           for);
           *
           * ('x','S') -> (markIncludes.main.desc).doCall;          
           *)
          ('BETAworld',1,true) -> cd.alloc;
          (*('x','S') -> (main.desc).doCall;  *)
          cd.stop; (* we should generate stop here and not in betaVM *)
          
          (*   (if markIncludes.main## <> ObjectModule## then
           *               '\n\n***** Only ObjectModules can be executed *****\n\n' -> putline
           *           if)
           *)
       #);
     genEventProcessor:
       (#
       do ('EventProcessor',newDesc,false,1,0) -> cd.class;
          cd.stop (* we should generate stop here and not in betaVM *)
       #);
     
     mainDescNo: (# exit newDesc.noOfDescs -1 (*- 2*) (* ad hoc *) #);
     cd: @ObjectCode;
     descs: ^RunTimeDescriptors;
     BC: ^File;
  enter BC[]
  do 'Generator' -> putline;
     (if true then
         BC.openWrite;
         BC[] -> cd.init;
         'zbeta'-> cd.comment;
         main.gen;
         ObjTmpStack.next;
         genMain;
         genEventProcessor;
         cd.dump;
         cd.descs[] -> descs[]; (* why ?*)         
         BC.close;
     if)
  #)

