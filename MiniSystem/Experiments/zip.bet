ORIGIN '~beta/basiclib/betaenv';
---lib:attributes---
Pair:
  (# Fst:< Object;
     Snd:< Object;
     aFst: ^Fst;
     aSnd: ^Snd;
  enter(aFst[],aSnd[])
  #);
List: 
  (# A:< Object;
     insert:
       (# e: ^A
       enter e[]
       do (if (top + 1 -> top) > L.range then L.range -> L.extend if);
          e[] -> L[top][]
       #);
     scan:
       (# current: ^A
       do (for i: top repeat
               L[i][] -> current[];
               inner
          for)
       #);
     get:
       (# inx: @integer; 
       enter inx
       do (If L[inx][] = none then 
              'get:none:'->puttext; inx -> putint; newline
          if)
       exit L[inx][]
       #);
     L: [10] ^A; top: @integer
  #);
ListX: List
  (# Zipper:
       (# B:< Object;
          PairAB: Pair(# Fst:: A; Snd:: B; exit this(PairAB)[]#);
          ListB: ListX(# A :: B #);
          ListPairAB: ListX(# A:: PairAB #);
          zip:
            (# yl: ^ListB; R: @ListPairAB
            enter yl[]
            do 'ListX:Zipper.zip' -> putline;
               (for i: 3 repeat
                    (i-> get, i-> yl.get) -> PairAB -> R.insert;
               for)
            exit R[]
            #)
       #);
  #);
testX:
  (# aNumberList: @ ListX(# A:: Number #);
     TextList: ListX(# A:: Text #);
     aTextList: @TextList;
     aNumberZipper: @aNumberList.Zipper(# B:: aTextList.A #);
     tList: @aNumberZipper.ListB;
     pList: ^aNumberZipper.ListPairAB;
     mkLists:
       (#
       do (for i: 3 repeat i * i -> Number -> aNumberList.insert for);
          aNumberList.scan(#do current.print; ' ' -> put #); newline;
          (for i: 3 repeat 
               (if i 
                // 1 then 'hello ' -> tList.insert 
                // 2 then 'old ' -> tList.insert
                // 3 then 'friend ' -> tList.insert
          if)for);
          tList.scan(#do current[] -> puttext; ' ' -> put #); newline;
       #);
  do mkLists;
     tList[] -> aNumberZipper.zip -> pList[];
     pList.scan
     (# N: ^Number
     do '('->put; current.aFst.print; ',' ->put; 
        current.aSnd[]->puttext; ')'->put; ' ' -> put
     #);
     newline
  #);
ListY: List
  (# Zip:
       (# B:< Object;
          PairAB: Pair(# Fst:: A; Snd:: B #);
          ListB: ListY(# A :: B #);
          ListPairAB: ListY(# A:: PairAB #);
          yl: ^ListB; R:  ^ListPairAB
       enter yl[]
       do 'ListY.zip' -> putline
       exit R[]
       #);
  #);
testY:
  (# iList: @ ListY(# A:: Number #);
     SList:  ListY(# A:: Text #);
     anSList: @SList;
     aZip: @anSList.zip;
     aListB: @aZip.ListB;
  do aListB[] -> iList.zip(# B:: SList #)
  #);
Number:
  (# v: @integer; 
     print: (#do v -> putint #);
  enter v
  exit this(Number)[]
  #);
(* With loose structural typing 
 *  Pair(Fst:< Object, Snd:< Object):
 *     aFst: ref Fst
 *     aSnd: ref Snd
 *  List(A:< Object):
 *     ...
 *     zip(B:< Object,yl: ref List(B)) -> v: ref List(Pair(A,B)):
 *       ...
 *  xl: ref List(Number)
 *  yl: ref List(String)
 *  zl: ref List(Pair(Number,String)
 *  zl := xl.zip(String,yl)
 *)
---program:descriptor---
(#
do testX;
   testY;
#)
