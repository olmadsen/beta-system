ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaLexer';
INCLUDE 'qStdBetaTopAST';
--Lib:attributes--
StdBetaAst: StdBetaTopAST
  (# (* we should place Noe and Item in common super for StdBetaAst and 
      * AbstractSyntaxTree; we should perhaps also defines lexems to be used
      * by both ASTs
      * And StdBetaAst should not be an attribute of AstLib
      *);
     BetaDecl: Node
       (# PP::< (# do 'Decl' -> lx.append; inner #);
          length::<
            (#
            do NS.length + 2 -> value; inner
            #);
          PT::<
            (#
            do (pos,break) -> NS.PT;  ':' -> lx.put;  
               inner PT
            #);
          NS: ^NameDecls; 
       enter NS[]->append
       #);
     BetaDataItem:< BetaDecl
       (# PP:: (#do 'DataItem'-> lx.append #);
          length:: (#do IT.length + value -> value #);
          PT::< (#do (pos,break) -> IT.PT; inner PT #);
          Label:: (#do 'DataItem' -> lab[] #);
          IT: ^Node 
       enter IT[] -> append
       #);
     NameDecls: Node
       (# PP:: (#do 'NameDecls'-> lx.append #);
          length:: 
            (# 
            do scanSons
               (#
               do current.length + value  -> value;
                  (if not isLast then value + 1 -> value if)
               #)
            #);
          PT:: 
            (# 
            do scanSons
               (#do (pos,break) -> current.PT; 
                  (if not isLast then ','->lx.put 
               if)#)
            #)
       #);
     BetaNameDecl: Node
       (# PP:: (#do 'NameDecl'-> lx.append #);
          length:: (# do N.length -> value #);
          PT:: (# do N.T[] -> lx.append #);
          label:: (#do 'NameDecl' -> lab[] #);
                     (*lexemSy:: (# do N.lexemSy -> L[] #);*)
          isDataItem:< booleanValue(# do inner #);
          isPtn:< booleanValue(# do inner #);
          N: ^BetaLexem;
          isSimple,isForInx: @boolean;
          forNo: @integer;
          off: @integer
       enter N[] -> append
       #);
     BetaLexem: Node
       (# T: ^text;
       enter T[]
       #);
     BetaName:< BetaLexem
       (# PP:: (#do 'Name:'-> lx.append; T[]->lx.append #);
          PT:: (#do T[] -> lx.append #);
          Length:: (#do T.length -> value #);
          Label:: (#do 'Name' -> lab[] #);
       #);
     BetaConst:< Transaction
       (# PP:: (#do 'Const:'-> lx.append; cst.T[] -> lx.append #);
          PT:: (#do cst.T[] -> lx.append #);
          Length:: (#do cst.length -> value #);
          Label :: (#do 'Const'->lab[] #);
          cst: ^BetaLexem
       enter cst[] -> append
       #);
     BetaString:< BetaLexem
       (# PP:: (#do 'String:'-> lx.append; T[] -> lx.append #);
          PT:: (#do T[] -> lx.append #);
       #);
     
     SimpleBetaModule: Node
       (# PT::
            (#
            do 'BetaModule:'->lx.append; filePath[] -> lx.append; 
               (pos,true) -> mkBreak
            #);
          moduleName:  ^BetaName;      
          filePath: ^text;
          inFile: ^file;
       enter filePath[]
       #);

     BetaProperties: Node
       (# PT::
            (#
            do 'BetaProperties: ' -> lx.append; (pos,true)->mkBreak;
               scanSons(#do (pos,break)->current.PT; (pos,true)->mkBreak #);
            #)
       #);
     BetaProperty: Node
       (# PT::
            (#
            do 'BetaProperty: '->lx.append; 
               scanSons(#do (pos,break)->current.PT; ' ' -> lx.put #)
            #)
       #);
     BetaFragments: Node
       (# PT::
            (#
            do 'BetaFragments:'->lx.append; (pos,true)->mkBreak;
               scanSons(#do (pos,break)->current.PT #)
            #)
       #);
     BetaFragment: Node
       (# PT::<
            (#
            do 'BetaFragment:'->lx.append; (pos,true)->mkBreak;
               (*'---' -> lx.append;
                scanSons(#do (pos,break)->current.PT; ':' -> lx.put #);*)
               inner PT
            #);
          theName,cat,language: ^BetaName
       enter(theName[]->append,cat[]->append,language[]->append)
       #);

     BetaModule: Node (* should probaly be qBetaModule? *)
       (# moduleName:  ^BetaName; inFile: ^file;
       enter moduleName[]
       #);
     FragmentEntry: BetaModule
       (# PT::<
            (#
            do (pos,length) -> block
               (#
               do '\nBetaFragmentEntry:path:' -> lx.append;
                  path[] -> lx.append; 
                  ' name:'->lx.append; fileName[]->lx.append;
                  inner PT
            #)#);
          path,fileName: ^text; (* Perhaps superflous since 
                                 * we have name and pathToFN in Module;
                                 * Module also has inFile
                                 * fileName and inFile are defined during
                                 * parsing in FragmentFile
                                 * Are not defined for a FragmentDirectory
                                 *)
       enter(path[],fileName[])
       #);
     FragmentDir: FragmentEntry
       (# PT::
            (#
            do (if false and ( not expand) then
                   true -> expand; doExpand 
               if);
               '  dir: '->lx.append; 
               (pos,true) -> mkBreak;
               scanSons
               (# 
               do (pos,break) -> current.PT;
                  (pos,break) -> mkBreak
            #)#);    
          doExpand:
            (# trace: (#exit false #);
               D: @directory;  FN,ext: ^text;
            do (if trace then
                   '**** expand:'->dumpT; path[] -> dumpTN
               if);
               (if true then
                   path[] -> D.name;
                   D.scanEntries
                   (# N: ^BetaName; FG: ^FragmentEntry
                   do found.path -> FN[];
                      (if true
                       // '.' -> FN.equal
                       // '..' -> FN.equal
                       // (1 -> FN.inxGet) = '.'
                       // (fn.length -> FN.inxGet) = '~' then
                       else           
                          select
                          (# whenFile:: 
                               (# 
                               do 'file:'->dumpT;
                                  FN[] -> BetaName -> N[];
                                  (N[],FN[] -> (path.copy).append ,FN[])
                                    -> FragmentFile -> FG[]
                                    -> append;
                                  (if false and (FG.inFile[] = none) then
                                      '**** FG.inFile is none' -> putline
                                  if)
                               #);
                             whenDir:: 
                               (# 
                               do 'dir:'->dumpT;
                                  FN[] -> BetaName -> N[];
                                  (N[],FN[] -> (path.copy).append,FN[],false) 
                                    -> FragmentDir
                                    -> append
                               #);
                          #);
                          FN[] -> dumpT
                      if)
                   #);
                   newline
                else
                   (path[],true) -> getBetaDirectories
                   (#
                   do scan
                      (# N: ^BetaName; FG: ^FragmentEntry
                      do (if currentIsFile then
                             (if trace then
                                 'File: ' -> puttext; 
                                 current[] -> (path.copy).append -> putline;
                             if);
                             current[] -> BetaName -> N[];
                             (N[],current[] -> (path.copy).append ,current[])
                               ->  FragmentFile -> FG[]
                               -> append;
                             (if FG.inFile[] = none then
                                 '**** FG.inFile is none' -> putline
                             if)
                          else
                             (if trace then
                                 'Dir: ' -> puttext;
                             if);
                             (*current[] -> (path.copy).append -> dirs.add;*)
                             'FragmentDir' -> BetaName -> N[];
                             (N[],current[] 
                               -> (path.copy).append,current[],false) 
                               -> FragmentDir -> append
                         if);
                         (if trace then  current[] -> putline if);
               #)#);if);
            #);
          expand: @boolean
       enter expand
       #);
     FragmentFile: FragmentEntry
       (# PP:: (# do 'FragmentFile' -> lx.puttext #);
          PT:: 
            (# 
            do ' file:'->lx.append;
               (pos,break) -> mkBreak;          
               (if props[] <> none then (pos,break) -> props.PT; if);
               (if pos > 0 then 
                   (* A comment with no linebreak may have been printed in props *)
                   (pos,true) -> mkBreak
               if);
               (* basiclib has no framents ==> frag[] = none *)
               (if frags[] <> none then (pos,break) -> frags.PT if)
            #);
          label:: (#do 'fragmentFile:' -> lab[] #);
          Props:  ^BetaProperty;
          Frags: ^Fragments;
          trace: (# exit false #)
       #);
     FragmentModule: BetaModule
       (# PT::
            (#
            do 'FragmentModule: ' -> lx.append; (pos,break) -> frag.PT 
            #);     
          frag: ^FragmentEntry
       enter frag[] -> append
       #);

     Fragments: Node
       (# theName,cat,language: ^BetaName;      frag: ^Fragment
       do loop:
            (if lex.symb = lex.symbols.idf then
                lex.sym[] -> BetaName -> theName[];
                lex; 
                (if lex.symb = lex.symbols.colon then
                    lex;
                    (if lex.symb = lex.symbols.idf then
                        lex.sym[] -> BetaName -> cat[];
                        lex;
                        (if lex.symb = lex.symbols.colon then
                            lex;
                            (if lex.symb = lex.symbols.idf then 
                                (* --- x:objectDesc:beta --- *)
                                lex.sym[] -> BetaName -> language[];
                                lex;                          
                             else
                                SyntaxError
                            if)
                         else
                            'BETA'-> BetaName -> language[];
                        if);
                        (if lex.symb = lex.symbols.frag then
                            lex;
                            (if true 
                             // 'descriptor' -> cat.T.equalNCS 
                             // 'descriptorForm' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> ObjDescFrag -> frag[] -> append;
                             // 'attributes' -> cat.T.equalNCS 
                             // 'attribute' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> AttFrag -> frag[] -> append
                             // 'doPart' -> cat.T.equalNCS then 
                                (theName[],cat[],language[]) 
                                  -> doPartFrag -> frag[] -> append
                             // 'mainPart' -> cat.T.equalNCS then
                                '\n!!!! MainPart category is not implemented' 
                                  -> putline
                             else
                                'Unknown category: ' -> puttext; 
                                cat.T[] -> putline
                            if);
                            (if lex.symb = lex.symbols.frag then 
                                lex;
                                restart loop
                            if);
                         else
                            SyntaxError
                        if)
                     else
                        SyntaxError
                    if)
                 else
                    SyntaxError
                if)
             else
                SyntaxError
            if);
          (if frag[] <> none then (*frag.addCommentAfter*) if)
       #);
     Fragment: Node
       (* Super pattern for ObjDescFrag, AttFrag and doPartFrag *)
       (# PT::< (# do(* breakIfNotAtEol;*) inner  #);
                   (*label:: (#do 'Fragment'-> lab[] #); bound in subpatterns *)
          entity:: (# do this(Fragment)[] -> E[] #);
                      (*sort:: (# do this(Fragment)[] -> S[] #);*)
          kind:: (# do '-' -> ch #);
          skind:: (# do ': -' -> S[] #);
          replaceEntity::<
            (#
            do '**** Fragment:replaceEntry: ' -> putline;
               inner
            #);
          theName,cat,language: ^BetaName
       enter(theName[]->append,cat[]->append,language[]->append)
          (*do inner*)
       #);
     ObjDescFrag: BetaFragment
       (# PT:: 
            (# 
            do '---' -> lx.append; theName.T[] -> lx.append;
               ':descriptor---' -> lx.append;
               (pos,break) -> OD.PT
            #);
          label:: (# do 'ObjDescFrag' -> lab[] #);
          getentries::(#do OD.getentries -> (names[],entries[]) #);
                         (*entity:: (# do this(ObjDescFrag)[] -> E[] #);
                          sort:: (# do this(ObjDescFrag)[] -> S[] #);*)
          replaceEntity::
            (#
            do '**** ObjDescFrag:replaceEntry: ' -> putline;
               inner
            #);
          OD: ^ObjectDesc
       #);
     AttFrag: BetaFragment
       (# PP:: (# do 'AttFrag'->lx.append #);
          PT:: 
            (# 
            do '---' -> lx.append; 
               theName.T[] -> lx.append;
               ':attributes---\n' -> lx.append;
               (if att[] <> none then (pos,break) -> att.PT;  if)
            #);
          label:: (#do 'AttFrag'->lab[] #);
          length:: (# do att.length -> value #);
          getentries::(#do att.getEntries -> (names[],entries[]) #);
                         (* entity:: (# do this(AttFrag)[] -> E[] #);
                          sort:: (# do this(AttFrag)[] -> S[] #);*)
          replaceEntity::
            (#
            do '**** AttFrag:replaceEntry: ' -> putline;
               inner
            #);     
          att: ^Attributes
       #);
     doPartFrag: BetaFragment
       (# PP:: (#do 'DoPart'-> lx.append #);
          PT:: 
            (# 
            do '---' -> lx.append; theName.T[] -> lx.append;
               ':doPart---\n' -> lx.append;
               (pos,break) -> ACP.PT 
            #);
          label:: (# do 'doPartFrag' -> lab[] #);
          length::(# #);
          getEntries:: (# do ('Do-part',ACP[]) -> add #);
                          (*entity:: (# do this(DoPartFrag)[] -> E[] #);
                           sort:: (# do this(DoPartFrag)[] -> S[] #);*)
          replaceEntity::
            (#
            do '**** doPartFrag:replaceEntry: ' -> putline;
               inner
            #);
          ACP: ^ActionPart
       #);
     BetaObjectSpecification: Node
       (# PT::< (#do inner PT #)
       #);
     ObjectDesc:< BetaObjectSpecification
       (# PP:: (#do 'ObjectDesc'-> lx.append #);
          length::
            (#
            do (if slt[] = none then
                   sup.length + 3 -> value;
                   (*(if withH[] <> none then withH.length + value -> value if);*)
                   (*props.length + value -> value;*)
                   (if att[] <> none then att.length + value -> value if);
                   value + acp.length + 3 -> value
                else
                   slt.length + 4 -> value
               if)
            #);
          PT::
            (#
            do (pos,break) -> sup.PT;
               (pos,length) -> block
               (#
               do (pos,break) -> mkBreak0;
                  '('->lx.put; '#'->lx.put; ' ' -> lx.put;
                  (pos + 3,break) -> att.PT;
                  (pos,break) -> acp.PT;
                  (pos,break) -> mkBreak1; 
                  '#'->lx.put; ')'->lx.put
            #)#);
          label:: (#do 'ObjectDesc'-> lab[] #);
          sup: ^PatternDen;
          props: ^BetaProperties;
          restricts: ^Restrictions;
          att: ^Attributes;
          acp: ^ActionPart;
          slt: ^Slot;
       enter(sup[]->append,att[]->append,acp[]->append)
       #);
     Restrictions: Node(##);
     BetaPattern: BetaDecl
       (# PP:: (#do 'Pattern'-> lx.append #);
          length:: (#do 1 + OD.length -> value #);
          PT:: (# do ' ' -> lx.put; (pos + 2 ,break) -> OD.PT #);
          label:: (#do 'PTN'-> lab[] #);
          OD: ^ObjectDesc;
       enter(OD[]->append)
       #);
     BetaVirtualPattern: BetaDecl
       (# PT::
            (#
            do '<' -> lx.put; ' ' -> lx.put; (pos + 2,break) -> OS.PT;
            #);
          length:: (#do value + 1 + OS.length -> value #);
          label:: (#do 'Virtual'-> lab[] #);
          OS: ^BetaObjectSpecification;
       enter(OS[]->append)
       #);
     FurtherBinding: BetaDecl
       (# PT::
            (#
            do ':< ' -> lx.append;  (pos + 2,break) -> OS.PT;
            #);
          length:: (#do value + 1 + OS.length -> value #);
          label:: (#do 'Further'-> lab[] #);
          OS: ^BetaObjectSpecification;
       enter(OS[]->append)
       #);
     FinalBinding: BetaDecl
       (# PT::
            (#
            do ': ' -> lx.append; (pos + 2,break) -> OS.PT;
            #);
          length:: (#do value + 1 + OS.length -> value #);
          label:: (#do 'Final'-> lab[] #);
          OS: ^BetaObjectSpecification;
       enter(OS[]->append)
       #);
     PatternDen: BetaObjectSpecification
       (# (* lex.symb = idf *)
          PP:: (#do 'PatternDen' -> lx.puttext #);
          length:: (# do AD.length -> value #);
          PT:: (# do (if AD[] <> none then (pos,break) -> AD.PT if) #);
          label:: (# do 'PatternDen' -> lab[] #);
          markAsSuper:
            (# 
            do (*'patternDen:markAsSuper:'->puttext; dopt -> putline;*)
               AD.markAsSuper 
            #);
               (*name: (# exit AD.name #);*)
          AD: ^Denotation;
               (*isSuper: (# enter AD.isSuper #)*)
       enter AD[] -> append
       #);
     AttributeDenotation: Denotation (*Node*)
       (* Denotation has the role of AttributeDentation in the Beta grammar
        * Remote is alos a Denotation but not the case for ComputedRemote 
        * and Index - clean-up
        *)
       (# PP:: (#do 'PatternDen' -> lx.puttext #);
          length:: (# do NA.length -> value #);
          PT:: (# do (pos,break) -> NA.PT  #);
          label:: (# do 'PatternDen' -> lab[] #);
          markAsSuper:
            (# 
            do (*NA.markAsSuper *)
            #);     
          NA: ^BetaName;
               (*isSuper: (# enter AD.isSuper #);*)
       enter NA[] -> append
       #);
     Attributes: Node
       (# PP:: (#do 'Attributes'-> lx.append #);
          length::
            (#
            do scanSons
               (#
               do current.length + value -> value;
                  (if not isLast then
                      value + 2 -> value
                  if)
               #)
            #);
          PT:: 
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then
                         ';' -> lx.put;
                         (pos,true) -> mkBreak
            if)#)#)#);
          label:: (#do 'Attributes'-> lab[] #);
       #);
     Attribute: Node
       (#
       #);
     ActionPart: Node
       (# PP:: (#do 'ActionPart' -> lx.puttext #);
          length::
            (#
            do enterP.length -> value;
               (if imps[] <> none then
                   3 + imps.length + value -> value
               if);
               exitP.length + value -> value
            #);
          PT::
            (#
            do (pos,break) -> enterP.PT ;
               (if imps.noOfSons > 0 then
                   (pos,break) -> mkBreak1;
                   'do ' -> lx.append;
                   (pos + 3,break) -> imps.PT ;
               if);
               (pos,break) -> exitP.PT ;
            #);
          label:: (#do 'ActionPart'-> lab[] #);
          enterP: ^ EnterPart;
          imps: ^Imperatives;
          exitP: ^ExitPart
       enter(enterP[]->append,imps[]->append,exitP[]->append)
       #);
     EnterPart: Node
       (# PP:: (#do 'Enter' -> lx.puttext #);
          length:: (# do (if eval[] <> none then 6 + eval.length -> value if)#);
          PT::
            (#
            do (if eval.noOfSons > 0 then
                   (pos,break) -> mkBreak1;
                   'enter' -> lx.append;
                   (pos,false) -> mkBreak1;
                   (pos,break) -> eval.PT 
               if)
            #);
          label:: (#do 'EnterPart'-> lab[] #);          
          eval: ^Evaluation; 
       enter eval[]->append
       #);
     ExitPart: Node
       (# PP:: (#do 'Exit' -> lx.puttext #);
          length:: (# do (if eval[] <> none then 5 + eval.length -> value if)#);
          label:: (#do 'ExitPart'-> lab[] #);
          PT::
            (#
            do (if eval.noOfSons > 0 then                   
                   (pos,break) -> mkBreak1;
                   'exit' -> lx.append;
                   (pos,false) -> mkBreak1;
                   (pos,break) -> eval.PT 
            if)#);
          eval: ^Evaluation; 
       enter eval[]->append
       #);
     Imperatives: Node
       (# PP:: (#do 'Imperatives' -> lx.puttext#);
          length::
            (# l: @integer
            do scanSons(# do current.length + 2 + l -> l #);
               l -> value
            #);
          PT:: 
            (#
            do (if true or (sons[] <> none) then
                   (pos,length) -> block
                   (#
                   do scanSons
                      (#
                      do (pos,break) -> current.PT ;
                         (if not isLast then
                             ';' -> lx.put;
                             (pos,break) -> mkBreak1;
            if)#)#)if)#);
          label:: (#do 'Imperatives'-> lab[] #);
       #);
     Slot: Node(##);

     Evaluation: Imperative (*Node*)
       (# PP::(#do 'Eval'->lx.puttext #);
          length::
            (#
            do scanSons
               (#
               do current.length + value -> value; 
                  (if not isLast then 4 + value -> value if)
            #)#);
          PT::
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then
                         (pos + 2,break) -> mkBreak0; 
                         ' -> ' -> lx.append;
            if)#)#)#);
          label:: (#do 'Evaluation'-> lab[] #);
       #);
     Imperative: Node
       (#
       #);
     IfImp: Imperative
       (# PP:: (#do 'If'->lx.puttext #);
          length::
            (# 
            do (if true then
                   100000 -> value;
                   (* for break imn implist with ifImp *)
                else
                   4 + eval.length -> value;
                   (if thenPart[] <> none then
                       6 + thenPart.length + value -> value
                    else
                       alt.length + value -> value
                   if);
                   (if elsePart[] <> none then
                       5 + elsePart.length + value -> value
                   if);
                   4 + value -> value
            if)#);
          PT::
            (#
            do (pos,length) -> block
               (#
               do '(' 'if ' -> lx.append; 
                  (pos,break) -> eval.PT ;
                  (if thenPart.noOfSons > 0 then
                      ' then' -> lx.append;
                      (pos+4,break) -> mkBreak1;
                      (pos+4,break) -> thenPart.PT
                   else
                      (pos + 1,break) -> mkBreak1;
                      (pos+1,break) -> alt.PT 
                  if);
                  (if elsePart.noOfSons > 0 then
                      (pos + 1,break) -> mkBreak1;
                      'else' -> lx.append;
                      (pos + 4,break) -> mkBreak1;
                      (pos+4,break) -> elsePart.PT 
                  if);
                  (pos,break) -> mkBreak1;
                  'if' ')' -> lx.append;
            #)#);
          label:: (#do 'IfImp'-> lab[] #);          
          eval: ^Evaluation;
          thenPart,elsePart: ^Imperatives;
          alt: ^Alternatives
       enter(eval[]->append,thenPart[]->append,elsePart[]->append,alt[]->append)
       #);
     Alternatives: Node
       (# PP:: (# do 'Alternatives' -> lx.puttext #);
          length:: 
            (# l: @ integer 
            do scanSons(# do current.length + l -> l #); l -> value 
            #);
          PT::
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then (pos,break) -> mkBreak1 if);
            #)#)#)
       #);
     Alternative: Node
       (# PP:: (# do 'Alternative' -> lx.puttext #);
          length::
            (#
            do (if true then
                   10000 -> value (* ensure break at alternatives in if *)
                else
                   (if imps[] = none then
                       sel.length  -> value
                    else
                       sel.length  + 6 + imps.length -> value
            if)if)#);
          PT:: (#
               do (pos,length) -> block
                  (#
                  do (pos,break) -> sel.PT;
                     (if imps.noOfSons > 0 then 
                         ' then' -> lx.append;
                         (pos+3,break) -> mkBreak1;
                         (pos+3,break) -> imps.PT 
               if)#)#);
          sel: ^Selections;
          imps: ^Imperatives
       enter(sel[]->append,imps[]->append)
       #);
     Selections: Node
       (# PP:: (# do 'Selections' -> lx.puttext #);
          length::
            (# 
            do scanSons(#do 3 + current.length + value -> value #)
            #);
          PT:: 
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do '// ' -> lx.append; (pos,break) -> current.PT;
                     (if not isLast then
                         (pos,break) -> mkBreak1
            if)#)#)#)
       #);
     Selection: Node
       (# PP:: (# do 'Selection' -> lx.puttext #);
          length:: (# do EV.length -> value #);
          PT:: (# do (pos,break) -> EV.PT  #);
          EV: ^Evaluation
       enter EV[] -> append
       #);
     ForImp: Imperative
       (# PP:: (#do 'For' -> lx.puttext #);
          length::
            (#
            do (if true then
                   100000 -> value
                else
                   5 + inx.length + 2 + inxItem.length + 8 + imps.length + 5 -> value
            if)#);
          PT::
            (#
            do (pos,length) -> block
               (#
               do '(' -> lx.put; 'for ' -> lx.append; (* avoid cunfusing Beta PP *)
                  (if inx[] <> none then
                      (pos,break) -> inx.PT ;
                      ':' -> lx.put; ' ' -> lx.put;
                  if);
                  (if rangee[] <> none then
                      (pos,break) -> rangee.PT ; 
                  if);
                  ' repeat' -> lx.append;
                  (pos + 5,break) -> mkBreak1;
                  (pos + 5,break) -> imps.PT ;
                  (pos,break) -> mkBreak1;
                  'for' -> lx.append; ')' -> lx.put
            #)#);
          inx: ^BetaNameDecl (*Lexem*);
          inxItem: ^ForImpItem;
          rangee: ^Evaluation;
          imps: ^Imperatives;
          (* ( for i: E repeat ... for )
           * ( for E repeat ... for )
           * ( for a + b repeat ... for )
           * ( for -a + b repeat ... for )
           *)
       enter(inx[]->append,inxItem[]->append,rangee[]->append,imps[]->append)
       #);
     ForImpItem: Node
       (# PP:: (# do 'ForImpItem' -> lx.puttext #);
          label:: (#do 'ForImpItem' -> lab[] #);
          kind:: (# do 'F' -> ch #);
       #);
     LabelledImp: Imperative
       (# PP:: (# do 'LabelledImp' -> lx.puttext #);
          length:: 
            (# 
            do (if true then 
                   100000 -> value 
                else lab.length + 2 + imp.length -> value
               if)
            #);
          PT::
            (#
            do (pos,break) -> lab.PT ; ':' -> lx.put;
               (pos,length) -> block
               (#
               do (pos+2,break) -> mkBreak1;
                  (pos+2,break) -> imp.PT 
               #)
            #);
          label:: (#do 'LabelledImp'-> lab[] #);          
          lab: ^BetaNameDecl;
          imp: ^Imperative
       enter(lab[],imp[])
       #);
     Break: Imperative
       (# PT::< (# do inner; (pos,break) -> lab.PT  #);
          length::< (# do inner; lab.length + value -> value #);
          lab: ^NameApl 
       enter lab[]
       #);
     LeaveImp: Break
       (# PP::(#do 'leave '->lx.puttext #);
          length:: (# do 6 -> value #);
          PT::(#do 'leave ' -> lx.append #);
          label:: (#do 'Leave'-> lab[] #);
       #);
     RestartImp: Break
       (# PP::(#do 'restart'->lx.puttext #);
          length:: (# do 8 -> value #);
          PT:: (#do 'restart ' -> lx.append #);
          label:: (#do 'Restart'-> lab[] #);
       #);     
     InnerImp: Imperative
       (# length:: 
            (# 
            do 5 -> value; 
               (if N[] <> none then N.length + 1 + value -> value if)#);
          PT:: 
            (# 
            do 'inner' -> lx.append; 
               (if N[] <> none then 
                   ' ' -> lx.put;
                   (pos,break) -> N.PT
               if)
            #);
          label:: (#do 'Inner'-> lab[] #);
          N: ^NameApl
       enter N[]
       #);
     Transaction: Node
       (# PP::< (#do 'Transaction:'-> lx.append; inner #);
       #);
     Expr: Transaction (##);
     BetaBinaryExp: Expr
       (# PP::(#do 'BinExp:'->lx.puttext; op->lex.symbols.asText -> lx.append #);
          length:: (# do lE.length + 4 + rE.length -> value #);
          PT::
            (#
            do (pos,break) -> lE.PT; ' ' -> lx.put;
               op -> lex.symbols.asText -> lx.append;
               ' ' -> lx.put; (pos,break) -> rE.PT ;
            #);
          label:: (#do 'BinayExp'->lab[] #);
          lE,rE: ^Expr; op: @integer
       enter(lE[]->append,op,rE[]->append) 
       #);
     BetaUnaryExp: Expr
       (# E: ^Expr; op: @integer 
       enter(op,E[]->append)
       #);
     BetaTerm: Expr
       (# PP:: (#do 'Term'->lx.append #);
          PT:: (# do (pos,break) -> T.PT #);
          length:: (# do T.length -> value #);
          label:: (#do 'Term'->lab[] #);
          T: ^transaction
       enter T[]->append
       #);

     ObjEval: Transaction
       (# PP:: (#do 'ObjEval' -> lx.append #);
          PT:: (# do (pos,break) -> OS.PT #);
          length:: (#do OS.length -> value #);
          label:: (#do 'ObjEval'->lab[] #);
          OS: ^BetaObjectSpecification;
       enter OS[]->append
       #);
     Reference: Transaction
       (# PP:: (#do 'Reference' -> lx.puttext #);
          length:: (# do OV.length + 2 -> value #);
          PT:: (# do (pos,break) -> OV.PT ; '[]' -> lx.append #);
          label:: (#do 'Reference'->lab[] #);
          OV: ^ObjEval
       enter OV[]
       #);
     StructureRef: Transaction
       (# PP:: (#do 'StructureRef' -> lx.puttext #);
          length:: (# do OV.length + 2 -> value #);
          PT:: (# do (pos,break) -> OV.PT ; '##' -> lx.append #);
          label:: (#do 'StrucRef'->lab[] #);
          OV:  ^ObjEval
       enter OV[]
       #);
     Denotation: Node(##);
     aChar: Transaction
       (# PT:: (#do theCh.T[] -> lx.append #);
          length:: (# do 3 -> value #);
          theCh: ^BetaLexem
       enter theCh[] -> append
       #);
     aText: Transaction
       (# PT:: (#do theTxt.T[] -> lx.append #);
          Length:: (#do theTxt.length -> value #);
          theTxt: ^BetaLexem
       enter theTxt[] -> append     
       #);
     EvaluationList: Transaction
       (# PP:: (# do 'EvalList' -> lx.puttext #);
          length:: 
            (#
            do 2 -> value;
               scanSons
               (#
               do current.length + value -> value;
                  (if not isLast then 1 + value -> value if)
               #)
            #);
          PT:: 
            (#
            do '(' -> lx.put;
               (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then 
                         (pos + 1, break) -> mkBreak0;
                         ',' -> lx.put 
                     if)
                  #);
                  ')' -> lx.put;
               #)
            #);
       #);
     NoneValue: Transaction
       (# PP:: (# do 'none' -> lx.puttext #);
          length:: (# do 6 -> value #);
          PT:: (# do ' none' -> lx.puttext #);
          label:: (# do 'none'->lab[] #); 
       #);
     NameApl: Denotation
       (# PP:: (#do  'NameApl'->lx.puttext #);
          length:: (# do (if N[] <> none then N.length -> value if) #);
          PT:: 
            (# 
            do (if N[] <> none then 
                   N.T[] -> lx.append;
                   (*(if not isImplicitSuper then N.PT if) *)
               if)
            #);
          N: ^BetaLexem;
       enter N[] -> append
       #);
     Remote: Denotation
       (# PP:: (# do 'Remote' -> lx.append #);
          length :: (#do scanSons(# do current.length + 1 + value -> value #)#);
          PT:: 
            (#
            do scanSons
               (#do (pos,break) -> current.PT;
                  (if not isLast then '.' -> lx.put if)
            #)#)
       #);
     ComputedRemote: Transaction
       (# PP:: (# do 'ComputedRemote'-> lx.puttext #);
          label::(#do 'ComputedRemote' -> lab[] #);
          length:: (# do evl.length + NA.length -> value (* ??*)#); 
          PT:: 
            (# 
            do (pos,break) -> evl.PT; 
               '.' -> lx.put;
               NA.PT
            #);          
          evl: ^EvaluationList;
          NA: ^NameApl
       enter(evl[]->append,NA[]->append)
       #);
     ComputedRemoteX: Transaction 
       (# tra: ^Transaction
       enter tra[]
       #);
     ComputedRemoteAsDenotation: Denotation
       (# CR: ^ComputedRemote
       enter CR[] -> append
       #);
     thisObj: Denotation
       (#
       #);
     Indexed: Denotation
       (# PP:: (# do 'Indexed' -> lx.puttext #);
          PT:: 
            (# 
            do (pos,break) -> NA.PT ;
               '[' -> lx.put; (pos,break) -> EV.PT ; ']' -> lx.put
            #);
          length:: (# do NA.length + 1 + EV.length + 1 -> value #); 
          Label:: (#do 'Indexed'-> lab[] #);
          NA: ^Denotation; (* was NameApl; but gives sem error *)
          EV,uE: ^Evaluation
       enter(NA[] -> append,EV[]->append,uE[]->append)
       #);
     DynamicObjectGeneration: Transaction
       (# PP:: (#do 'DynObjGen'-> lx.puttext #);
          length:: (# do 1 + OS.length -> value #);
          PT:: 
            (# 
            do '&' -> lx.put; 
               (pos,break) -> OS.PT;
               (if isRef and (EV[] <> none) then 
                   (pos,break) -> EV.PT
               if);
               (if isRef then '[' -> lx.put; ']' -> lx.put if);
            #);
          isRef: @boolean; 
          OS: ^BetaObjectSpecification;
          EV: ^Evaluation
       enter(OS[] -> append, EV[] -> append)
       #);
     StaticItem: Node
       (# PP:: (#do label -> lx.append #);
          PT:: 
            (# 
            do ' '-> lx.put; '@' -> lx.put; ' ' -> lx.put;  
               (if OS[] <> none then
                   (pos + 2,break) -> OS.PT
                else
                   '-none-' -> lx.append
               if);
            #);
          length:: (# do OS.length + 3 -> value #);
          Label:: (# do 'StaticItem' -> lab[] #);
          OS: ^BetaObjectSpecification
       enter OS[]
       #);
     DynamicItem: Node
       (# PT:: 
            (# 
            do ' '-> lx.put; '^' -> lx.put; ' ' -> lx.put;  
               (if OS[] <> none then
                   (pos + 2,break) -> OS.PT
                else
                   '-none-' -> lx.append
               if);
            #);
          length:: (# do OS.length + 3 -> value #);
          Label:: (# do 'DynamicItem' -> lab[] #);
          OS: ^BetaObjectSpecification
       enter OS[]
       #);
     Repetition: Node
       (# PP:: (#do 'rep' -> lx.puttext #);
          PT:: 
            (#
            do (pos,break) -> inx.PT ; (pos,break) -> IT.PT  
            #);
          length:: (# do inx.length + IT.length -> value #);
          label:: (#do 'Repetition' -> lab[] #);
          kind:: (# do '[' -> ch #);
          inx: ^Index;
          IT: ^Node
       enter(inx[]->append, IT[]->append)
       #);
     Index: Node
       (# PP:: (#do 'Index' -> lx.puttext #);
          PT:: (# do '[' -> lx.put; (pos,break) -> EV.PT ; ']' -> lx.put #);
          length:: (# do 2 + EV.length -> value #);
          label:: (#do 'Index' -> lab[] #);
          EV: ^Evaluation
       enter EV[] -> append
       #);
     VarPtn: Node
       (# PP: (# do 'VarPtn' -> lx.puttext #);
          length:: (# do AD.length + 3 -> value #);
          PT:: (# do ' ##' -> lx.append; (pos + 3,break) -> AD.PT #);
          kind:: (# do '*' -> ch #);
          Entity:: (# do AD.entity -> E[] #);
          AD: ^AttributeDenotation
       enter AD[] -> append
       #);
     syntaxError:
       (# no: @integer
       enter no
       do
          '**** syntax error: '->puttext; no -> putint; newline;
          (if true then
              5 -> lex.printlines
           else
              (for i: 100 repeat
                   (if (lex.bTop - 99 + i > 0 )
                       and (lex.bTop - 99 + i < lex.buffer.range) then
                       lex.buffer[lex.bTop - 99 + i] -> put
                   if)
          for)if);
          stop
       #);
  do inner
  #)

