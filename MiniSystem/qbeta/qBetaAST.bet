ORIGIN 'qabstractSyntaxTree';
--AstLib:attributes--
BetaDecl: Item
  (# PP::< (# do 'Decl' -> lx.append; inner #);
     PT::<
       (#
       do (pos,break) -> NS.PT;  ':' -> lx.put;  
          (pos,break) -> mkBreak;
          inner PT
       #);
     NS: ^NameDecls; 
  enter NS[]->append
  #);
BetaDataItem: BetaDecl
  (# PP:: (#do 'DataItem'-> lx.append #);
     PT::<
       (#do (pos,break) -> IT.PT; inner PT #);
     IT: ^Item 
  enter IT[] -> append
  #);
NameDecls: Item
  (# PP:: (#do 'NameDecls'-> lx.append #);
     PT:: 
       (# 
       do scanSons
          (#do (pos,break) -> current.PT; (if not isLast then ','->lx.put if)#)
       #)
  #);
NameDecl: Item
  (# PP:: (#do 'NameDecl'-> lx.append #);
  #);
BetaLexem: Item
  (# T: ^text;
  enter T[]
  #);
BetaName: BetaLexem
  (# PP:: (#do 'Name:'-> lx.append; T[]->lx.append #);
     PT:: (#do T[] -> lx.append #);
  #);
BetaConst: Transaction
  (# PP:: (#do 'Const:'-> lx.append; cst.T[] -> lx.append #);
     PT:: (#do cst.T[] -> lx.append #);
     cst: ^BetaLexem
  enter cst[] -> append
  #);
  
SimpleBetaModule: Item
  (# PT::
       (#
       do 'BetaModule:'->lx.append; filePath[] -> lx.append; 
          (pos,true) -> mkBreak
       #);
     moduleName:  ^BetaName;      
     filePath: ^text;
     inFile: ^file;
  enter filePath[]
  #);

BetaProperties: Item
  (# PT::
       (#
       do 'BetaProperties: ' -> lx.append; (pos,true)->mkBreak;
          scanSons(#do (pos,break)->current.PT; (pos,true)->mkBreak #);
       #)
  #);
BetaProperty: Item
  (# PT::
       (#
       do 'BetaProperty: '->lx.append; 
          scanSons(#do (pos,break)->current.PT; ' ' -> lx.put #)
       #)
  #);
BetaFragments: Item
  (# PT::
       (#
       do
          'BetaFragments:'->lx.append; (pos,true)->mkBreak;
          scanSons(#do (pos,break)->current.PT #)
       #)
  #);
BetaFragment: Item
  (# PT::<
       (#
       do 'BetaFragment:'->lx.append; (pos,true)->mkBreak;
          (*'---' -> lx.append;
          scanSons(#do (pos,break)->current.PT; ':' -> lx.put #);*)
          inner PT
       #);
     theName,cat,language: ^BetaName
  enter(theName[]->append,cat[]->append,language[]->append)
  #);

BetaModule: Item (* should probaly be qBetaModule? *)
  (# moduleName:  ^BetaName; inFile: ^file;
  enter moduleName[]
  #);
FragmentEntry: BetaModule
  (# PT::<
       (#
       do (pos,length) -> block
          (#
          do '\nBetaFragmentEntry:path:' -> lx.append;
             path[] -> lx.append; 
             ' name:'->lx.append; fileName[]->lx.append;
             inner PT
          #);
       #);
     path,fileName: ^text; (* Perhaps superflous since 
                            * we have name and pathToFN in Module;
                            * Module also has inFile
                            * fileName and inFile are defined during
                            * parsing in FragmentFile
                            * Are not defined for a FragmentDirectory
                            *)
  enter(path[],fileName[])
  #);
FragmentDir: FragmentEntry
  (# PT::
       (#
       do (if false and ( not expand) then
              true -> expand; doExpand 
          if);
          '  dir: '->lx.append; 
          (pos,true) -> mkBreak;
          scanSons
          (# 
          do (pos,break) -> current.PT;
             (pos,break) -> mkBreak
          #)
       #);    
     doExpand:
       (# trace: (#exit false #);
          D: @directory;  FN,ext: ^text;
       do (if trace then
              '**** expand:'->dumpT; path[] -> dumpTN
          if);
          (if true then
              path[] -> D.name;
              D.scanEntries
              (# N: ^BetaName; FG: ^FragmentEntry
              do found.path -> FN[];
                 (if true
                  // '.' -> FN.equal
                  // '..' -> FN.equal
                  // (1 -> FN.inxGet) = '.'
                  // (fn.length -> FN.inxGet) = '~' then
                  else           
                     select
                     (# whenFile:: 
                          (# 
                          do 'file:'->dumpT;
                             FN[] -> BetaName -> N[];
                             (N[],FN[] -> (path.copy).append ,FN[])
                               -> FragmentFile -> FG[]
                               -> append;
                             (if false and (FG.inFile[] = none) then
                                 '**** FG.inFile is none' -> putline
                             if)
                          #);
                        whenDir:: 
                          (# 
                          do 'dir:'->dumpT;
                             FN[] -> BetaName -> N[];
                             (N[],FN[] -> (path.copy).append,FN[],false) 
                               -> FragmentDir
                               -> append
                          #);
                     #);
                     FN[] -> dumpT
                 if)
              #);
              newline
           else
              (path[],true) -> getBetaDirectories
              (#
              do scan
                 (# N: ^BetaName; FG: ^FragmentEntry
                 do (if currentIsFile then
                        (if trace then
                            'File: ' -> puttext; 
                            current[] -> (path.copy).append -> putline;
                        if);
                        current[] -> BetaName -> N[];
                        (N[],current[] -> (path.copy).append ,current[])
                          ->  FragmentFile -> FG[]
                          -> append;
                        (if FG.inFile[] = none then
                            '**** FG.inFile is none' -> putline
                        if)
                     else
                        (if trace then
                            'Dir: ' -> puttext;
                        if);
                        (*current[] -> (path.copy).append -> dirs.add;*)
                        'FragmentDir' -> BetaName -> N[];
                        (N[],current[] 
                          -> (path.copy).append,current[],false) 
                          -> FragmentDir -> append
                    if);
                    (if trace then  current[] -> putline if);
          #)#);if);
       #);
     expand: @boolean
  enter expand
  #);
FragmentFile: FragmentEntry
  (# PP:: (# do 'FragmentFile' -> lx.puttext #);
     PT:: 
       (# 
       do ' file:'->lx.append;
          (pos,break) -> mkBreak;          
          (if props[] <> none then (pos,break) -> props.PT; if);
          (if pos > 0 then 
              (* A comment with no linebreak may have been printed in props *)
              (pos,true) -> mkBreak
          if);
          (* basiclib has no framents ==> frag[] = none *)
          (if frags[] <> none then (pos,break) -> frags.PT if)
       #);
     label:: (#do 'fragmentFile:' -> lab[] #);
     Props:  ^NewProperty;
     Frags: ^Fragments;
     trace: (# exit false #)

  #);
FragmentModule: BetaModule
  (# PT::
       (#
       do 'FragmentModule: ' -> lx.append; (pos,break) -> frag.PT 
       #);     
     frag: ^FragmentEntry
  enter frag[] -> append
  #);

Fragments: Item
  (# theName,cat,language: ^BetaName;      frag: ^Fragment
  do loop:
       (if lex.symb = lex.symbols.idf then
          lex.sym[] -> BetaName -> theName[];
          lex; 
          (if lex.symb = lex.symbols.colon then
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> BetaName -> cat[];
                  lex;
                  (if lex.symb = lex.symbols.colon then
                      lex;
                      (if lex.symb = lex.symbols.idf then 
                          (* --- x:objectDesc:beta --- *)
                          lex.sym[] -> BetaName -> language[];
                          lex;                          
                       else
                          SyntaxError
                      if)
                   else
                      'BETA'-> BetaName -> language[];
                  if);
                  (if lex.symb = lex.symbols.frag then
                      lex;
                      (if true 
                       // 'descriptor' -> cat.T.equalNCS 
                       // 'descriptorForm' -> cat.T.equalNCS then
                          (theName[],cat[],language[]) 
                            -> ObjDescFrag -> frag[] -> append;
                       // 'attributes' -> cat.T.equalNCS 
                       // 'attribute' -> cat.T.equalNCS then
                          (theName[],cat[],language[]) 
                            -> AttFrag -> frag[] -> append
                       // 'doPart' -> cat.T.equalNCS then 
                          (theName[],cat[],language[]) 
                            -> doPartFrag -> frag[] -> append
                       // 'mainPart' -> cat.T.equalNCS then
                          '\n!!!! MainPart category is not implemented' 
                            -> putline
                       else
                          'Unknown category: ' -> puttext; 
                          cat.T[] -> putline
                      if);
                      (if lex.symb = lex.symbols.frag then 
                          lex;
                          restart loop
                      if);
                   else
                      SyntaxError
                  if)
               else
                  SyntaxError
              if)
           else
              SyntaxError
          if)
       else
          SyntaxError
       if);
     (if frag[] <> none then (*frag.addCommentAfter*) if)
  #);
Fragment: Item
  (* Super pattern for ObjDescFrag, AttFrag and doPartFrag *)
  (# PT::< (# do(* breakIfNotAtEol;*) inner  #);
     (*label:: (#do 'Fragment'-> lab[] #); bound in subpatterns *)
     entity:: (# do this(Fragment)[] -> E[] #);
     (*sort:: (# do this(Fragment)[] -> S[] #);*)
     kind:: (# do '-' -> ch #);
     skind:: (# do ': -' -> S[] #);
     replaceEntity::<
       (#
       do '**** Fragment:replaceEntry: ' -> putline;
          inner
       #);
     theName,cat,language: ^BetaName
  enter(theName[]->append,cat[]->append,language[]->append)
  (*do inner*)
  #);
ObjDescFrag: BetaFragment
  (# PT:: 
       (# 
       do '---' -> lx.append; theName.T[] -> lx.append;
          ':descriptor---' -> lx.append;
          (pos,break) -> OD.PT
       #);
     label:: (# do 'ObjDescFrag' -> lab[] #);
     getentries::(#do OD.getentries -> (names[],entries[]) #);
     (*entity:: (# do this(ObjDescFrag)[] -> E[] #);
      sort:: (# do this(ObjDescFrag)[] -> S[] #);*)
     replaceEntity::
       (#
       do '**** ObjDescFrag:replaceEntry: ' -> putline;
          inner
       #);
     OD: ^ObjectDesc
  (*do (*PatternDen -> * ) ObjectDesc -> OD[] -> append;*)
  #);
AttFrag: BetaFragment
  (# PP:: (# do 'AttFrag'->lx.append #);
     PT:: 
       (# 
       do '---' -> lx.append; 
          theName.T[] -> lx.append;
          ':attributes---\n' -> lx.append;
          (if att[] <> none then (pos,break) -> att.PT;  if)
       #);
     label:: (#do 'AttFrag'->lab[] #);
     length:: (# do att.length -> value #);
     getentries::(#do att.getEntries -> (names[],entries[]) #);
     (* entity:: (# do this(AttFrag)[] -> E[] #);
     sort:: (# do this(AttFrag)[] -> S[] #);*)
     replaceEntity::
       (#
       do '**** AttFrag:replaceEntry: ' -> putline;
          inner
       #);     
     att: ^Attributes
  (*do Attributes -> att[] -> append*)
  #);
doPartFrag: BetaFragment
  (# PP:: (#do 'DoPart'-> lx.append #);
     PT:: 
       (# 
       do '---' -> lx.append; theName.T[] -> lx.append;
          ':doPart---\n' -> lx.append;
          (pos,break) -> ACP.PT 
       #);
     label:: (# do 'doPartFrag' -> lab[] #);
     length::(# #);
     getEntries:: (# do ('Do-part',ACP[]) -> add #);
     (*entity:: (# do this(DoPartFrag)[] -> E[] #);
     sort:: (# do this(DoPartFrag)[] -> S[] #);*)
     replaceEntity::
       (#
       do '**** doPartFrag:replaceEntry: ' -> putline;
          inner
       #);
     ACP: ^ActionPart
  (*do ActionPart -> ACP[] -> append;*)
  #);
BetaObjectSpecification: Item
  (# PT::< (#do inner PT #)
  #);
ObjectDesc: BetaObjectSpecification
  (# PP:: (#do 'ObjectDesc'-> lx.append #);
     PT::
       (#
       do (if sup[] <> none then  (pos + 3,break) -> sup.PT; if);
          (pos,length) -> block
          (#
          do '(# '->lx.append;
             (if att[] <> none then  (pos + 3,break) -> att.PT; if);
              (pos,break) -> acp.PT;
             '#)'->lx.append
       #)#);
     sup: ^PatternDen;
     props: ^BetaProperties;
     restricts: ^Restrictions;
     att: ^Attributes;
     acp: ^ActionPart;
     slt: ^Slot;
  enter(sup[]->append,att[]->append,acp[]->append)
  #);
Restrictions: Item(##);
BetaPattern: BetaDecl
  (# PP:: (#do 'Pattern'-> lx.append #);
     PT::
       (#
       do (pos,break) -> OD.PT
       #);
     OD: ^ObjectDesc;
  enter(OD[]->append)
  #);
BetaVirtualPattern: BetaDecl
  (# PT::
       (#
       do '<' -> lx.put; ' ' -> lx.put; (pos,break) -> OS.PT;
       #);
     OS: ^BetaObjectSpecification;
  enter(OS[]->append)
  #);
FurtherBinding: BetaDecl
  (# PT::
       (#
       do ':< ' -> lx.append;  (pos,break) -> OS.PT;
       #);
     OS: ^BetaObjectSpecification;
  enter(OS[]->append)
  #);
FinalBinding: BetaDecl
  (# PT::
       (#
       do ': ' -> lx.append; (pos,break) -> OS.PT;
       #);
     OS: ^BetaObjectSpecification;
  enter(OS[]->append)
  #);
PatternDen: BetaObjectSpecification
  (# (* lex.symb = idf *)
     PP:: (#do 'PatternDen' -> lx.puttext #);
     length:: (# do AD.length -> value #);
     PT:: (# do (if AD[] <> none then (pos,break) -> AD.PT if) #);
     label:: (# do 'PatternDen' -> lab[] #);
     markAsSuper:
       (# 
       do (*'patternDen:markAsSuper:'->puttext; dopt -> putline;*)
          AD.markAsSuper 
       #);
     (*name: (# exit AD.name #);*)
     AD: ^AttributeDenotation;
     (*isSuper: (# enter AD.isSuper #)*)
  enter AD[] -> append
  #);
AttributeDenotation: Item
  (# PP:: (#do 'PatternDen' -> lx.puttext #);
     length:: (# do NA.length -> value #);
     PT:: (# do (pos,break) -> NA.PT  #);
     label:: (# do 'PatternDen' -> lab[] #);
     markAsSuper:
       (# 
       do (*NA.markAsSuper *)
       #);
     
     NA: ^BetaName;
     (*isSuper: (# enter AD.isSuper #);*)
  enter NA[] -> append
  #);
     
Attributes: Item
  (# PP:: (#do 'Attributes'-> lx.append #);
     PT:: 
       (#
       do scanSons
          (#
          do (pos,break) -> current.PT;
             (if not isLast then
                 ';' -> lx.put;
                 (pos,true) -> mkBreak
       if)#)#);
  #);
Attribute: Item
  (#
  #);
ActionPart: Item
  (# PP:: (#do 'ActionPart' -> lx.puttext #);
     length::
       (#
       do enterP.length -> value;
          (if imps[] <> none then
              3 + imps.length + value -> value
          if);
          exitP.length + value -> value
       #);
     PT::
       (#
       do (pos,break) -> enterP.PT ;
          (if imps[] <> none then
              (pos,break) -> mkBreak1;
              'do ' -> lx.append;
              (pos + 3,break) -> imps.PT ;
          if);
          (pos,break) -> exitP.PT ;
       #);
     enterP: ^ EnterPart;
     imps: ^Imperatives;
     exitP: ^ExitPart
  enter(enterP[]->append,imps[]->append,exitP[]->append)
  #);
EnterPart: Item
  (# PP:: (#do 'Enter' -> lx.puttext #);
     length:: (# do (if eval[] <> none then 6 + eval.length -> value if)#);
     PT::
       (#
       do (if eval.noOfSons > 0 then
              (pos,break) -> mkBreak1;
              'enter' -> lx.append;
              (pos,false) -> mkBreak1;
              (pos,break) -> eval.PT 
          if)
       #);
     eval: ^Evaluation; 
  enter eval[]->append
  #);
ExitPart: Item
  (# PP:: (#do 'Exit' -> lx.puttext #);
     length:: (# do (if eval[] <> none then 5 + eval.length -> value if)#);
     PT::
       (#
       do (if eval.noOfSons > 0 then                   
              (pos,break) -> mkBreak1;
              'exit' -> lx.append;
              (pos,false) -> mkBreak1;
              (pos,break) -> eval.PT 
          if)
       #);
     eval: ^Evaluation; 
  enter eval[]->append
  #);
Imperatives: Item
  (# PP:: (#do 'Imperatives' -> lx.puttext#);
     length::
       (# l: @integer
       do (if son[] <> none then
              scanSons(# do current.length + 2 + l -> l #);
              l -> value
          if)
       #);
     PT:: 
       (#
       do (if son[] <> none then
              (pos,length) -> block
              (#
              do scanSons
                 (#
                 do (pos,break) -> current.PT ;
                    (if not isLast then
                        ';' -> lx.put;
                        (pos,break) -> mkBreak1;                             
       if)#)#)if)#)
  #);
Slot: Item(##);

Evaluation: Item
  (# PP::(#do 'Eval'->lx.puttext #);
     length::
       (#
       do scanSons
          (#
          do current.length + value -> value; 
             (if not isLast then 4 + value -> value if)
          #)
       #);
     PT::
       (#
       do (pos,length) -> block
          (#
          do scanSons
             (#
             do (pos,break) -> current.PT;
                (if not isLast then
                    (pos + 2,break) -> mkBreak0; 
                    ' -> ' -> lx.append;
       if)#)#)#)
  #);
Imperative: Item
  (#
  #);

Transaction: Item
  (# PP::< (#do 'Transaction:'-> lx.append; inner #);
  #);
Expr: Transaction (##);
BetaBinaryExp: Expr
  (# PP::(#do 'BinExp:'->lx.puttext; op->lex.symbols.asText -> lx.append #);
     length:: (# do lE.length + 4 + rE.length -> value #);
     PT::
       (#
       do (pos,break) -> lE.PT; ' ' -> lx.put;
          op -> lex.symbols.asText -> lx.append;
          ' ' -> lx.put; (pos,break) -> rE.PT ;
       #);
     lE,rE: ^Expr; op: @integer
  enter(lE[]->append,op,rE[]->append) 
  #);
BetaUnaryExp: Expr
  (# E: ^Expr; op: @integer 
  enter(op,E[]->append)
  #);
Term: Expr
  (# PP:: (#do 'Term'->lx.append #);
     PT:: (# do (pos,break) -> T.PT #);
     T: ^transaction
  enter T[]->append
  #);

ObjEval: Transaction
  (# PP:: (#do 'ObjEval' -> lx.append #);
     PT:: (# do (pos,break) -> OS.PT #);
     OS: ^BetaObjectSpecification;
  enter OS[]->append
  #);
Reference: Transaction(##);
Denotation: Item(##);
ComputedRemote: Transaction 
  (# tra: ^Transaction
  enter tra[]
  #);
ComputedRemoteAsDenotation: Denotation
  (# CR: ^ComputedRemote
  enter CR[] -> append
  #);
aChar: Transaction
  (# PT:: (#do theCh.T[] -> lx.append #);
     theCh: ^BetaLexem
  enter theCh[] -> append
  #);
aText: Transaction
  (# PT:: (#do theTxt.T[] -> lx.append #);
     theTxt: ^BetaLexem
  enter theTxt[] -> append     
  #);
EvaluationList: Transaction(##);
NoneValue: Transaction(##);
Indexed: Denotation
  (# NA: ^Denotation (* was NameApl; but gives sem error *)
  enter NA[] -> append
  #);
NameApl: Denotation
  (# PP:: (#do  'NameApl'->lx.puttext #);
     length:: (# do (if N[] <> none then N.length -> value if) #);
     PT:: 
       (# 
       do (if N[] <> none then 
              (pos,break) -> N.PT (*(if not isImplicitSuper then N.PT if) *)
          if)
       #);
     N: ^Lexem;
  #);
DynamicObjectGeneration: Transaction(##);
StaticItem: Item
  (# PT:: 
       (# 
       do ' '-> lx.put; '@' -> lx.put; ' ' -> lx.put;  
          (if OS[] <> none then
              (pos + 2,break) -> OS.PT
           else
              '-none-' -> lx.append
          if);
       #);
     OS: ^BetaObjectSpecification
  enter OS[]
  #);
DynamicItem: Item
  (# PT:: 
       (# 
       do ' '-> lx.put; '^' -> lx.put; ' ' -> lx.put;  
          (if OS[] <> none then
              (pos + 2,break) -> OS.PT
           else
              '-none-' -> lx.append
          if);
       #);
     OS: ^BetaObjectSpecification
  enter OS[]
  #);
syntaxError:
  (# no: @integer
  enter no
  do
     '**** syntax error: '->puttext; no -> putint; newline
  #);



