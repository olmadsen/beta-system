ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'; 
INCLUDE 'qunitparser' 
---lib:attributes--- 
traceUnit: (#exit false #);

UnitHandler: checker
  (# Pattern::<
       (# getUnit:: 
            (# 
            do (if trx or (OG.primNo = vAssign_prim) or traceUnit then
                   '**** pattern:getUnit: ' -> puttext; sig.dopt -> putline;
                   dopt -> putline
               if);
               OG.getUnit -> U[]
            #);
          computeUnit::
            (#
            do (if true then
                   '**** Pattern:computeUnit. ' -> puttext; sig.dopt -> putline
               if);
               getUnit -> U[]               
            #);
       #);
     DataItem::<
       (# getUnit::
            (#
            do (if traceUnit then
                   '**** DataItem:getUnit: ' -> puttext; dopt -> putline
               if);
               (if OG.IS.isEmpty then
                   (OG.super.last).getUnit -> U[]
                else
                   (*'!!!! OBS! DataItem:getUnit:singular DataItem:'-> puttext; 
                   dopt -> putline*)
               if)
            #);
       #);
     ObjectCall::<
       (# isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectCall:isUnitValueObj: ' -> puttext; doPT -> putline
               if);
               (if super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               if);
               (if traceUnit then
                   '**** ObjectCall:isUnitValueObj= ' -> puttext; 
                   value -> putboolean; ' ' -> put;
                   doPT -> putline
               if);
            #);
          getUnit:: 
            (# ptn: ^Pattern 
            do (if traceUnit then
                   '**** ObjectCall:getUnit: ' -> puttext; dopt -> putline
               if);               
               (* Ex: "k1 * s" -> "kg * % s" *)
               super.getUnit -> U[]
            #);
          getUnitPropShort::
            (# ptn: ^Pattern; 
            do (if traceUnit then
                   '**** objectCall:getUnitPropShort: ' -> puttext; dopt -> putline;
               if);
               (super.last).ATd[] -> ptn[];
               propNo -> ptn.OG.getUnitPropShort -> U[];
            #);          
          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU: ^text;
            do (if traceUnit then
                   '**** ObjectCall:computeUnit: ' -> puttext; dopt -> putline;
                   '**   super.last.label: ' -> puttext; (super.last).label -> putline;
               if);
               (super.last).computeUnit -> U[];
            #);
          getConstLiteral:: 
            (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
            do (if traceUnit then
                   '**** ObjectCall:getConstLiteral: ' -> puttext; dopt -> putline; 
               if);
               super.getConstLiteral -> value
            #);
       #);
     ObjectGenerator::<
       (# isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectGenerator:isUnitValueObj: ' -> puttext; doPT -> putline
               if);
               (if IS.isEmpty and super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               else
                   IS.newBasicProp.unit[] <> none -> value;
               if);
               (*
               (if not (IS.newBasicProp.unit[] <> none -> value) then
                   (if super.ATd[] <> none then
                       (if super.ATd.isPattern then
                           (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
                if)if)if)           *)
               (if traceUnit then
                   '**** ObjectGenerator:isUnitValueObj= ' -> puttext; 
                   value -> putboolean; newline;
                   (if value then doPT -> putline if)
               if);
            #);
          getUnit::
            (# D: ^Decl
            do (if trx or traceUnit then 
                   '**** objectGenerator:getUnit:' -> putline; 
                   dopt -> putline if);
               (if (1 -> getUnitPropShort -> U[]) = none then
                   (if (super.ATd[] <> none) then
                       (if trx or traceUnit then
                           '**   OG:super.ATd.getUnit: ' -> putline;
                       if);
                       super.ATd.getUnit -> U[]
                   if);
                   (if U[] = none then 
                       getReturnDecl -> D[];
                       (if D[] <> none then
                           D.OG.getUnitPropShort -> U[]
                        else
                           (if false then
                               (if trx or traceUnit then 
                                   '**   OG:no associated unit:use:#Float' 
                                     -> putline
                               if);                       
                               '#Float' -> U[]
                           if)
                       if)
                   if)
               if);
               (if traceUnit then
                   '**   OG:Unit: ' -> puttext; U[] -> putline;
               if)
            #);  
         getUnitPropShort::
            (# UN: ^NewProperty;
            do (if (IS.newBasicProp.unit[]-> UN[]) <> none then
                   (* unit is defined for this OG*)
                   L:
                     UN.args.scanSons
                     (# i: @integer
                     do current.scanSons
                        (# S: ^StringObj
                        do (if current.isStringLiteral then
                               (current[] -> S[]).T[] -> U[];
                               (if propNo = i then leave L if);
                           if);
                           i + 1 -> i
                     #)#)
                else
                   (if IS.newBasicProp.primNo 
                    // float_prim then
                       '#Float' -> U[]
                    // integer_prim then
                       '#Integer' -> U[]
                   if)
               if)
            #);          
       #);
     invocation::<
       (* inv ::= rec msg
        * msg ::= unary
        *      |  binary
        *      |  functional
        *      |  keyword
        * binary ::=  +, -, *, /, ^, ...
        * Ex
        *  A ^ (0 - 1)
        * rec.getOp -> op
        * msg.getUnit -> U
        *)
       (# getUnit::
            (#
            do (if traceUnit then 
                   '**** Invocation:getUnit: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               computeUnit -> U[]
            #);
          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU,msgU: ^text;
               isBase,sameDim: @boolean; lCF,rCF: @real
            do (if trx or traceUnit then
                   '**** Invocation:ComputedUnit: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               scanSons
               (#  
               do i + 1 -> i; 
                  (if i 
                   // 1 then current[] -> rec[];
                   // 2 then current[] -> msg[]
                  if);
               #);
               (if i = 2 then
                   (* perhaps a binary method *)
                   rec.computeUnit -> recU[] -> U[]; (* "kg" *)
                   (if trx or traceUnit then
                       '**   Invocation:rec:unit: ' -> puttext; U[] -> putline;
                   if);
                   (if U[] = none then
                       msg.computeUnit -> U[]; (* "*s", U = "kg*s" *)
                       (if trx or traceUnit then
                           '**** Inv:getUnit:U none ' -> puttext; 
                           dopt -> putline;
                           U[] -> putline
                       if)
                    else
                       (if (1 -> U.inxGet) = '#' then
                           leave computeUnit 
                       if);
                       msg.computeUnit -> msgU[];
                       (if trx or traceUnit then
                           '**   msgU: ' -> puttext; msgU[] -> putline
                       if);
                       (if msgU[] <> none then
                           (if (1 -> msgU.inxGet) = '#' then
                               leave computeUnit
                            else
                               (if (1 -> msgU.inxGet) 
                                // '-' // '+' then
                                   (if traceUnit then
                                       '**** U,msgU: ' -> puttext; 
                                       U[] -> puttext; ',' -> put; 
                                       msgU[] -> puttext; ':' -> put; 
                                       msgU.length -> putint;
                                       newline;
                                   if);
                                   (if msgU.length = 1 then
                                       (* unary minus as in X^-1 *)
                                       leave computeUnit
                                   if);
                                   (2,msgU.length)->msgU.sub -> msgU[];
                                   (if not (msgU[] -> U.equalNCS) then
                                       (* the code below needs to be 
                                        * cleaned up and completed
                                        * Must check if one of U and msgU
                                        * is a base unit and then convert
                                        * the other.
                                        * If none is a base unit then
                                        * we need conversion factor for both
                                        * AND! We must check if both are
                                        * in the same dimension
                                        *)
                                       (if false then
                                           '\n**** Different units in addition: '
                                             -> puttext;
                                           U[] -> puttext;  ',' -> put;
                                           msgU[] -> putline; 
                                           dopt -> putline;
                                           newline;
                                       if);
                                       (U[],msgU[])
                                         -> unitTable.findAndCheck
                                         -> (sameDim,lCF,rCF);
                                       (if (lCF = 0) and (rCF <> 0) then
                                           msg.scanSons
                                           (# i: @integer
                                           do i + 1 -> i;
                                              (if i = 2 then
                                                  (if false then
                                                      current.doPT -> puttext; 
                                                      ':'->put;
                                                      current.label -> puttext; 
                                                      ',' -> put;
                                                  if);
                                                  current.scanSons
                                                  (#
                                                  do (if false then
                                                         current.dopt -> puttext;
                                                         ':'->put;
                                                         current.label -> puttext; 
                                                     if)
                                                  #);
                                                  '**** addConvFactor:R: ' -> puttext;
                                                  current.label -> puttext;
                                                  ' ' -> put;
                                                  current.dopt -> puttext;
                                                  ' ' -> put; rCF -> putreal;
                                                  newline;
                                                  rCF -> current.addConvFactor
                                              if)
                                           #);
                                           (if false then
                                               '  rConvF: ' -> puttext;
                                               rCF -> putReal; newline;
                                           if)
                                        else
                                           '**** addConvFactor:L: ' -> puttext;
                                           rec.label -> puttext; ' ' -> put;
                                           rec.dopt -> puttext;
                                           ' ' -> put; lCF -> putreal;
                                           newline;
                                           lCF -> rec.addConvFactor;
                                           msgU[] -> U[];
                                           (if false then
                                               '  lConvF: ' -> puttext;
                                               lCF -> putReal; newline;
                                           if)
                                       if)
                                   if)
                                else
                                   msgU[] -> (U.copy).append -> U[]; (* "*s", U = "kg*s" *)
                           if)if)
                        else
                           msg.computeUnit -> (U.copy).append -> U[]; (* "*s", U = "kg*s" *)
                   if)if);
                   (if traceUnit then
                       '**   Invocation:isBinary:rec: ' -> puttext; rec.dopt -> puttext;
                       ' unit: "' -> puttext; recU[] -> puttext;
                       '" msgU: "' -> puttext; U[] -> puttext; 
                       '" msg: ' -> puttext; msg.doPT -> puttext;
                       ' args: ' -> puttext; msg.args.dopt -> putline
                   if)
                else
                   (* pehaps a onst literal ? *)
                   rec.getUnit -> U[]
               if);
            #);
          getConstLiteral:: 
             (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
             do (if traceUnit then
                    '**** Invocation:getConstLiteral: ' -> puttext; dopt -> putline;
                if);
                scanSons
                (#  
                do i + 1 -> i;
                   (if i 
                    // 1 then current[] -> rec[] 
                    // 2 then current[] -> msg[] 
                   if);
                #);
                MaxInt -> value;
                (if i = 2 then
                    (if traceUnit then
                        '**   perhaps a binary method?' -> putline;
                    if);
                    (if msg.isObjectInvocation then
                        (msg[]->OI[]).type.isOp -> op[];
                        (if traceUnit then
                            '**   op: ' -> puttext; op[] -> putline;
                        if);
                        (if '-' -> op.equal then
                            (if traceUnit then '*** got -\n' -> puttext; if);
                            rec.getConstLiteral -> v;
                            OI.args.scanArgs(#do current.getConstLiteral -> u #);
                            (if traceUnit then
                                v -> putint; ' ' -> put; u -> putint; newline;
                            if);
                            v - u -> value
                        if)
                    if)
                 else (* perhaps (0 - 1) *)
                    rec.getConstLiteral -> value
                if)
             #);
       #);
     ObjectInvocation::<
       (# getUnit::
            (# argU: ^text;  i: @integer; arg: ^ObjectSpecification
            do (if traceUnit then 
                   '**** ObjectInvocation:getUnit: ' -> puttext; dopt -> putline;
               if);
               ATd.getUnit -> U[];
               (if traceUnit then
                   '**   OI:ATd.getUnit: ' -> puttext; U[] -> putline
               if);
               (if (U[] <> none) and (args[] <> none) then
                   (if traceUnit then
                       '**   getUnit:OI:binary: ' -> puttext; dopt -> puttext;
                       ' args: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then
                       arg.getUnit -> argU[];
                       (if traceUnit then
                           '**   OI:argU: ' -> puttext; argU[] -> putline
                       if);
                       (if toFix then
                           '\n!!!! ObjectInvocation:getUnit: ' -> putline;
                           '     We must reconsider the combinations'
                           ' of #Integer and #Float' -> putline
                       if);
                       (if true 
                        // ('#Integer' -> argU.equal) 
                           and ('#Integer' -> U.equal) then
                        // ('#Float' -> argU.equal) 
                           and ('#Float' -> U.equal) then
                        else                           
                           argU[] -> (U.copy).append -> U[]
                   if)if)
               if);
               (if traceUnit then
                   '**   OI:finalU: ' -> puttext; U[] -> puttext;
                   ' OF: '->puttext; doPT -> putline
               if);               
            #);
          computeUnit::
            (# argU: ^text;  i,V: @integer; arg: ^ObjectSpecification
            do (if trx or traceUnit then
                   '**** ObjectInvocation:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               type.isOp -> U[];
               (if trx or traceUnit then
                   '**   OI:computeUnit:type.op: "' -> puttext; 
                   U[] -> puttext; '"' -> put; newline;
               if);
               (if (U[] <> none) and (args[] <> none) then
                   (if trx or traceUnit then
                       '**   OI:computeUnit:isBinary: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then 
                       (if traceUnit then
                           '**   arg.label: ' -> puttext; arg.label -> putline;
                           '**   arg: ' -> puttext; arg.dopt -> putline;
                       if);
                       (if true
                        // '^' -> U.equal then 
                           (if traceUnit then '**   got: ^' -> putline; if);
                           arg.getConstLiteral -> V;
                           &text[] -> argU[]; V -> argU.putint;
                           argU[] -> (U.copy).append -> U[];
                        else                           
                           arg.getUnit -> argU[];
                           (if true
                            // '-' -> U.equal then
                               (if false then
                                   '**** U: ' -> puttext; U[] -> puttext;
                                   ' ' -> put; argU[]-> putline
                               if)
                            // (1 -> argU.inxGet) = '#' then (* float or integer *)
                               argU[] -> U[]
                            else
                               (if toFix then
                                   '\n!!!! ObjectInvocation:computeUnit: ' 
                                     -> putline;
                                   '     We must reconsider the combinations'
                                   ' of #Integer and #Float' -> putline
                               if);
                               (if true 
                                // ('#Integer' -> argU.equal) 
                                   and ('#Integer' -> U.equal) then
                                // ('#Float' -> argU.equal) 
                                   and ('#Float' -> U.equal) then
                                else 
                                   argU[] -> (U.copy).append -> U[];
                       if)if)if);
                       (if traceUnit then
                           '**   OI:computeUnit:final:unit: ' -> puttext; 
                           U[] -> putline
                       if)
                   if)
                else
                   (if trx or traceUnit then 
                       '**   OI:computeUnit:not binary:U: ' -> puttext;
                       U[]->putline;
                       doPT -> putline;
                       ATd.computeUnit -> putline
                   if);
                   
               if)
            #);
          getConstLiteral:: 
            (# op: ^Text
            do (if trx or traceUnit then
                   '**** ObjectInvocation:getConstLiteral: ' -> puttext; dopt -> putline;
                   '**   Not implememnted' -> putline
               if); 
               
            #);   
          addConvFactor::
            (#
            do '**** OI:addConvFactor: ' -> puttext; dopt -> puttext; ' '-> put;
               CF -> putReal; newline;
               (if convFactor <> 0 then
                   '**** OI:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   CF -> convFactor; true -> done;
               if)
            #)
       #);
     BracketedExp::<
       (# getUnit:: (# do IV.getUnit -> U[] #);
          computeUnit::
            (#
            do (if traceUnit then
                   '**** BracketedExp:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               IV.computeUnit -> U[]
            #);
           getConstLiteral:: (# do IV.getConstLiteral -> value #)
       #);
     Name::< 
       (# getConstLiteral::
            (#
            do '**** Name:getConstLiteral: ' -> puttext; dopt -> putline;
               MaxInt -> value
            #)
       #);
     Const::< 
       (# getUnit:: (# do '#Integer' -> U[] #);
          computeUnit::(# do getUnit -> U[] #);
          getConstLiteral:: (# do T.setPos; T.getInt -> value #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** Const:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** Const:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done -> convDone 
               if)
            #);
          convDone: @boolean;
          int2floatDone:: 
            (# 
            do convDone -> value; 
               cd.com(#do 'convDone:'->TT; convDone -> BB #)
            #);
       #);
     FloatConst::<
       (# getUnit:: (# do '#Float' -> U[] #);
          computeUnit::(# do getUnit -> U[] #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** FloatConst:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** FloatConst:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done; 
               if)
            #);
       #);
  do inner
  #)
