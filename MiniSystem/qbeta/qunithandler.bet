ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'
---lib:attributes---
traceUnit: (#exit false #);
UnitHandler: checker
  (# Pattern::<
       (# getUnitX:: 
            (# 
            do (if traceUnit then
                   '**** pattern:getUnitX: ' -> puttext; sig.dopt -> putline;
               if);
               OG.getUnitX -> U[]
            #);
       #);
     DataItem::<
       (# getUnitX::
            (#
            do (if traceUnit then
                   '**** DataItem:getUnitX: ' -> puttext; dopt -> putline
               if);
               (if OG.IS.isEmpty then
                   (OG.super.last).getUnitX -> U[]
                else
                   (*'!!!!! OBS! DataItem:getUnitX:singular DataItem:'-> puttext; 
                   dopt -> putline*)
               if)
            #);
       #);
     ObjectCall::<
       (# getUnitX:: 
            (# ptn: ^Pattern 
            do (if traceUnit then
                   '**** ObjectCall:getUnitX: ' -> puttext; dopt -> putline
               if);               
               (if true then
                   (* Ex: "k1 * s" -> "kg * % s" *)
                   super.getUnitX -> U[]
                else                   
                   (super.last).getUnitX -> U[] 
               if)
            #);
          getUnitPropShort::
            (# ptn: ^Pattern; 
            do (if false then
                   '**** objectCall:getUnitPropShort: ' -> puttext; dopt -> putline;
               if);
               (super.last).ATd[] -> ptn[];
               propNo -> ptn.OG.getUnitPropShort -> U[];
            #);          
          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU: ^text;
            do (if traceUnit then
                   '**** ObjectCall:computeUnit: ' -> puttext; dopt -> putline;
                   '**   super.last.label: ' -> puttext; (super.last).label -> putline;
               if);
               (if true then
                   (super.last).computeUnit -> U[];
                else
                   super.scanSons
                   (#  
                   do i + 1 -> i;
                      (if i 
                       // 1 then current[] -> rec[] 
                       // 2 then current[] -> msg[] 
                      if);
                   #);
                   (if i = 2 then
                       (* perhaps a binary method *)
                       (if true then
                           rec.computeUnit -> recU[]
                        else
                           rec.getUnitX -> recU[];
                       if);
                       msg.computeUnit -> U[];
                       (if traceUnit then
                           '**    binary:rec: ' -> puttext; rec.dopt -> puttext;
                           ' unit: ' -> puttext; recU[] -> puttext;
                           ' msgU: ' -> puttext; U[] -> puttext; 
                           ' msg: ' -> puttext; msg.label -> puttext;
                           ' args: ' -> puttext; msg.args.dopt -> putline
                       if)
               if)if)
            #);
          getConstLiteral:: 
            (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
            do (if traceUnit then
                   '*** ObvjectCall:getConstLiteral: ' -> puttext; dopt -> putline; 
               if);
               (if true then
                   super.getConstLiteral -> value
                else
               super.scanSons
               (#  
               do i + 1 -> i;
                  (if i 
                   // 1 then current[] -> rec[] 
                   // 2 then current[] -> msg[] 
                  if);
               #);
               (if i = 2 then
                   (* perhaps a binary method *)
                   (if msg.isObjectInvocation then
                       (msg[]->OI[]).type.isOp -> op[];
                       (if '-' -> op.equal then
                           (* '*** got -' -> puttext;*)
                           rec.getConstLiteral -> v;
                           OI.scanSons(#do current.getConstLiteral -> u #);
                           (* v -> putint; ' ' -> put; u -> putint;*)
                           v - u -> value
               if)if)if)if)
            #);
       #);
     ObjectGenerator::<
       (# getUnitX::
            (#
            do (if traceUnit then 
                   '**** objectGenerator:getUnitX:\n' -> puttext; dopt -> putline if);
               (if (getUnitPropShort -> U[]) = none then
                   (if (super.ATd[] <> none) then
                       (if traceUnit then
                           '**   OG:super.ATd.getUnitX: ' -> putline;
                       if);
                       super.ATd.getUnitX -> U[]
               if)if);
               (if traceUnit then
                   '**   OG: ' -> puttext; U[] -> putline;
               if)
            #);  
         getUnitPropShort::
            (# UN: ^NewProperty;
            do (if (IS.newBasicProp.unit[]-> UN[]) <> none then
                   (* unit is defined for this OG*)
                   L:
                     UN.args.scanSons
                     (# i: @integer
                     do current.scanSons
                        (# S: ^StringObj
                        do (if current.isStringLiteral then
                               (current[] -> S[]).T[] -> U[];
                               (if propNo = i then leave L if);
                           if);
                           i + 1 -> i
                     #)#)
                else
                   (if IS.newBasicProp.primNo 
                    // float_prim then
                       'Float' -> U[]
                    // integer_prim then
                       'Integer' -> U[]
                   if)
               if)
            #);          
       #);
     invocation::<
       (* inv ::= rec msg
        * msg ::= unary
        *      |  binary
        *      |  functional
        *      |  keyword
        * binary ::=  +, -, *, /, ^, ...
        * Ex
        *  A ^ (0 - 1)
        * rec.getOp -> op
        * msg.getUnit -> U
        *)
       (# getUnitX::
            (#
            do (if traceUnit then 
                   '**** Invocation:getUnitX: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               computeUnit -> U[]
            #);
          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU: ^text;
            do (if traceUnit then
                   '**** Invocation:ComputedUnit: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               scanSons
               (#  
               do i + 1 -> i; (*current.label -> putline; current.dopt -> putline;*)
                  (if i 
                   // 1 then current[] -> rec[] ; (*rec.doPP -> putline*)
                   // 2 then current[] -> msg[] 
                  if);
               #);
               (if i = 2 then
                   (* perhaps a binary method *)
                   (if true then
                       rec.computeUnit -> recU[] -> U[] (* "kg" *)
                    else
                       rec.getUnitX -> recU[];
                   if);
                   (if U[] = none then
                       msg.computeUnit -> U[]; (* "*s", U = "kg*s" *)
                       (if false then
                           '**** Invocation:getUnitX:U none ' -> puttext; dopt -> putline;
                           U[] -> putline
                       if)
                    else
                       msg.computeUnit -> (U.copy).append -> U[]; (* "*s", U = "kg*s" *)
                   if);
                   (if traceUnit then
                       '**   Invocation:isBinary:rec: ' -> puttext; rec.dopt -> puttext;
                       ' unit: "' -> puttext; recU[] -> puttext;
                       '" msgU: "' -> puttext; U[] -> puttext; 
                       '" msg: ' -> puttext; msg.doPT -> puttext;
                       ' args: ' -> puttext; msg.args.dopt -> putline
                   if)
                else
                   (* pehaps a onst literal ? *)
                   rec.getUnitX -> U[]
               if);
            #);
          getConstLiteral:: 
             (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
             do (if traceUnit then
                    '**** Invocation:getConstLiteral: ' -> puttext; dopt -> putline;
                if);
               scanSons
               (#  
               do i + 1 -> i;
                  (if i 
                   // 1 then current[] -> rec[] 
                   // 2 then current[] -> msg[] 
                  if);
               #);
               (if i = 2 then
                   (* perhaps a binary method *)
                   (if msg.isObjectInvocation then
                       (msg[]->OI[]).type.isOp -> op[];
                       (if '-' -> op.equal then
                           (*'*** got -' -> puttext;*)
                           rec.getConstLiteral -> v;
                           OI.args.scanArgs(#do current.getConstLiteral -> u #);
                           (* v -> putint; ' ' -> put; u -> putint; newline; *)
                           v - u -> value
                   if)if)
                else (* perhaps (0 - 1) *)
                   rec.getConstLiteral -> value
               if)
            #);
       #);
     ObjectInvocation::<
       (# getUnitX::
            (# argU: ^text;  i: @integer; arg: ^ObjectSpecification
            do (if traceUnit then 
                   '**** ObjectInvocation:getUnitX: ' -> puttext; dopt -> putline;
               if);
               ATd.getUnitX -> U[];
               (*'KOKS: ' -> puttext; U[] -> putline;*)
               (If (U[] <> none) and (args[] <> none) then
                   (if traceUnit then
                       '**   getUnitX:OI:binary: ' -> puttext; dopt -> puttext;
                       ' args: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then
                       arg.getUnitX -> argU[];
                       argU[] -> (U.copy).append -> U[]
               if)if)
            #);
          computeUnit::
            (# argU: ^text;  i,V: @integer; arg: ^ObjectSpecification
            do (if traceUnit then
                   '**** ObjectInvocation:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               type.isOp -> U[];
               (if traceUnit then
                   '**   OI:computeUnit:type.op: "' -> puttext; 
                   U[] -> puttext; '"' -> put; newline;
               if);
               (if (U[] <> none) and (args[] <> none) then
                   (if traceUnit then
                       '**   OI:computeUnit:isBinary: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then 
                       (if traceUnit then
                           '**   arg.label: ' -> puttext; arg.label -> putline;
                       if);
                       (if true
                        // arg.isStringLiteral then
                           arg.getUnitX -> argU[];
                        else 
                           arg.getConstLiteral -> V;
                           &text[] -> argU[];
                           V -> argU.putint;
                       if);
                       argU[] -> (U.copy).append -> U[];
                       (if traceUnit then
                           '**   unit: ' -> puttext; U[] -> putline
                       if)
               if)if)
            #);
          getConstLiteral:: 
            (# op: ^Text
            do (if true or traceUnit then
                   '**** ObjectInvocation:getConstLiteral: ' -> puttext; dopt -> putline;
                   '**   Not implememnted' -> putline
               if); 
               
            #);      
       #);
     BracketedExp::<
       (# getUnitX:: (# do IV.getUnitX -> U[] #);
          computeUnit::
            (#
            do (if traceUnit then
                   '**** BracketedExp:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               IV.computeUnit -> U[]
            #);
           getConstLiteral:: (# do IV.getConstLiteral -> value #)
       #);
     Const::< 
       (# getUnitX:: (# do 'Integer' -> U[] #);
          computeUnit::(# do getUnitX -> U[] #);
          getConstLiteral:: (# do T.setPos; T.getInt -> value #)
       #);
     FloatConst::<
       (# getUnitX:: (# do 'Float' -> U[] #);
          computeUnit::(# do getUnitX -> U[] #);
          (*getConstLiteral:: (# do T.setPos; T.getInt -> value #)*)
       #);
  do inner
  #)
