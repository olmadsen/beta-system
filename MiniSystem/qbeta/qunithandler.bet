ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'; 
INCLUDE 'qunitparser' 
---lib:attributes--- 
withDimProp: (# exit true #);
doCheckUnits: (# exit false #);
UnitHandler: checker
  (# ModuleItem::<
       (# selectForPrintUnits:: (# do not MD.isIncluded -> done #);
       #);
     Pattern::<
       (# isN2N: BooleanValue
            (# inArg,outArg: ^Decl; inn: @integer
            do scanargs(#do inn + 1 -> inn; currentArg[] -> inArg[] #);
               (if inn = 1 then 
                   (if unitIssue then 'isN2N:'->dumpT; inArg.dopt-> dumpT; if);
                   (if inArg.OG.primNo = integer_prim then
                       getreturnDecl -> outArg[]; 
                       (if unitIssue then outArg.dopt-> dumpTN; if);
                       (if outarg[] <> none then
                           outarg.OG.primno = integer_prim -> value;
                           (if unitIssue then 
                               'isN2N:'->dumpT;
                               (if value then 'TRUE'->dumpTN 
                                else 'FALSE'->dumpTN if);
                           if)
                           (* receiver must also be integer *)
               if)if)if)
            #);
          getExpUnit:: 
            (# 
            do '**** pattern:getExpUnit:shouldNotHappen: ' -> putline;
               dopt -> puthead
            #);
          hasGenericUnit: booleanValue
            (# U: ^text
            do (if (1 -> OG.getUnitPropShort -> U[]) <> none then
                   '$' -> U.equal -> value;
                   (if value and traceUnit then
                       '**** ptn:hasGenericUnit: ' -> puttext; 
                       sig.dopt -> puttext; ' unit: ' -> puttext; 
                       U[] -> putline
               if)if)
            #);
          printUnit::
            (# DI: ^Decl; U: ^Text
            do OG.getReturnDecl -> DI[];
               (if DI[] <> none then
                   (*DI.dopt -> putline;*)
                   '' -> DI.OG.getExpUnit -> U[];
                   (*U[] -> putline;*)
                   (rec[],U[],E[]) -> doPrintUnit
               if)
            #);
          mapVarUnit:
            (# qual: ^ObjectGenerator; unit,U: ^text; UT: ^UnitTree
            enter(qual[],unit[])
            do (if traceUnit then
                   '**** ptn:mapVarUnit: ' -> puttext; unit[] -> puttext;
                   ' qual: ' -> putline; qual.dopt -> puthead;
                   '**   Ptn: ' -> putline; dopt -> puthead;
               if);
               (if OG.IS.newBasicProp.unit[] <> none then
                   OG.IS.newBasicProp.unit.args.scanSons
                   (#
                   do current.scanSons
                      (# S: ^StringObj
                      do (if current.isStringLiteral then
                             (current[]->S[]).T[] -> U[]
                      if)#)#)
                else
                   '#F' -> U[]; (* probably dont work - see SlideEx *)
               if);
               (if false then U[] -> putline; if);

               U[] -> parseUnit -> UT[]; 
               (if traceUnit then
                   '**   UT: ' -> puttext; true -> UT.print -> putline;
               if);
               (if true then
                   unit[] -> UT.replaceUnitVar;
                else
                   qual.getExpUnit -> UT.replaceUnitVar;
               if);
               (if traceUnit then 
                   '** replaced: ' -> puttext; true -> UT.print -> putline
               if);
               true -> UT.print -> U[]
            exit U[]
            #);
       #);
     DataItem::<
       (# getExpUnit::
            (#
            do '**** DataItem:getUnit:shoulNotHappen: ' -> puttext; 
               dopt -> putline
            #);
          checkUnits::
            (# unitWarning:
                 (# T: ^text
                 enter T[]
                 do srcOS[] -> warning
                    (#
                    do T[] -> msg; 
                       '\n**   source: "'->msg; 
                       (if srcOs[] <> none then
                           srcOS.dopt -> msg;
                        else
                           'none'->msg
                       if);
                       '" unit: "' -> msg; 
                       (if srcQual[] <> none then srcQual.getUnitName -> msg; if);
                       '" dimension: "'->msg;
                       srcU[] -> msg; '"\n' -> msg;
                       '**   destination: "' -> msg; dopt -> msg; '"'->msg;
                       ' unit: "' -> msg; dstU[] -> msg; '"\n' -> msg;
                       (if false then
                           'srcQual:'->msg; srcQual.doPT -> msg;
                           '\ndstQual:'->msg; dstQual.doPT -> msg
                    if)#)
                 #);
               checkSameDim: 
                 (# 
                 do (if (srcQual[] <> dstQual[]) 
                        and ('#' <> (1->srcU.inxGet))
                        and ('#' <> (1->dstU.inxGet))
                        and (srcQual[] <> floatDecl.OG[])
                        and (srcQual[] <> integerDecl.OG[])
                        then
                        'Same dimension-vector but not same dimension'
                          -> unitWarning;
                    if)
                 #);
               srcU,dstU,Ux,U: ^text; sameDim: @boolean; 
               BV: ^BaseVector; srcCF,dstCF,srcCFx: @real
            do (if false then '**** checkUnits:' -> putline; newline if);
               (if true then
                   dstQual.getUnitName -> dstU[]
                else
                   1 -> dstQual.getUnitPropShort -> dstU[];
               if);
               srcOS.getExpUnit -> srcU[];
               (* can dstU and srcU be none? Yes, for char, boolean, string *)
               (if false then
                   dopt -> puttext; ' := ' -> puttext; srcOS.dopt ->putline;
                   '**   dstUnit: ' -> puttext; dstU[] -> putline;
                   '**   srcUnit: ' -> puttext; srcU[] -> putline;
               if);
               (if (srcU[] <> none) and (dstU[] <> none) and
                   (srcU.length > 0) and (dstU.length > 0) then
                   (if true
                    // srcU[] -> dstU.equalNCS then
                       (*checkSameDim(#do 'srcU = dstU'->putline #);*)
                       (* can we have #I here? *)
                       floatDecl.OG[] -> srcQual[] -> dstQual[]
                    // '#F' -> dstU.equalNCS then
                       (if traceUnit then
                           '**   dstQual:'->putline;
                           dstQual.dopt -> puthead;
                           '**   srcQual:'->putline; 
                           srcQual.dopt -> puthead;
                       if);
                       floatDecl.OG[] -> srcQual[]
                    // '#I' -> dstU.equalNCS then
                       (if true
                        // '#Q' -> srcU.equalNCS then
                           (* must check this case: see assignment of
                            * '#Q' -> U[] in qunithandler
                            *)
                           integerDecl.OG[] -> dstQual[]
                        // '#F' -> srcU.equalNCS then
                           floatDecl.OG[] -> dstQual[]
                        // '#I' -> srcU.equalNCS then 'Bingo:'->dumpT;
                           (*emitTrace;*)
                           integerDecl.OG[] -> srcQual[]
                        else
                           (* src is a unit and dst is an integer;
                            * may be x * 6 "s^-2" where
                            * dst is the parameter V of 
                            *    * V: var integer : ...
                            * src is 6 with unit "S^-2" and
                            * dst is V: var integer with unit '#I'
                            *)
                           (if '(#Q)*(#Q)' -> srcU.equalNCS then
                                   '#) #)'; (* to fool Beta-indent *)
                               'Perhaps unit mismatch' -> unitWarning
                           if);
                           floatDecl.OG[] -> srcQual[] -> dstQual[];
                           srcU[] -> dstU[]
                       if)
                    // ('U' -> srcU.equal) or ('U' -> srcU.equal) then
                       'Should not happen: unit is "U"'->unitWarning
                    else
                       (* Check if srcU and dstU are units in the same 
                        * dimension and return possible conversion factors
                        * to the corresponding base unit
                        *)
                       
                       (srcU[],dstU[])
                         -> unitTable.findAndCheck
                         -> (sameDim,srcCF,dstCF);
                           (*checkSameDim(#do 'after:findAndCheck'->putline#);*)
                       (if sameDim then
                           (*checkSameDim(#do 'sameDim'->putline #);*)
                           (if false then
                               srcU[] -> puttext; ' ' -> put;
                               srcOS.dopt -> putline;
                               dstU[] -> puttext; ' ' -> put;
                               dopt -> putline;
                           if);
                           srcU[] -> parseUnit -> mkBaseVector -> BV[];
                           (if false then
                               BV.print -> putline;
                               'src:convFC: ' -> puttext;
                           if);
                           BV.convFactor -> srcCFx;
                           (if false then
                               srcCFx -> putReal; ' '->put; srcCF->putReal;
                               ' dstCF: ' -> puttext; dstCF -> putReal;
                           if);
                           (if srcCFx <> srcCF then srcCFX -> srcCF if);
                           (if false then
                               ' srcCF: ' -> puttext; srcCF -> putreal;
                               newline;
                           if);
                           dstU[] -> parseUnit -> mkBaseVector -> BV[];
                           (if dstCF = 0 then BV.convFactor -> dstCF if);
                           (if false then
                               ' dstCF:' ->puttext; dstCF->putreal;newline;
                           if);
                           
                           (if (srcCF = 0) or (dstCF = 0) then 
                               'Implict conversion between units '
                               'is not possible here.\n'
                               '     You should use "toBase" and/or "fromBase".'
                                 -> unitWarning 
                           if);
                           (if srcCF = dstCF then
                               (* No conversion needed
                                * If CF = 1 then srcU and dstU both
                                * are the base unit of the dimension
                                *)
                            else
                               (if false then
                                   '**** addConvFactor:src: ' -> puttext;
                                   srcOS.doPT -> puttext; ' srcCF:' -> puttext;
                                   srcCF -> putreal; 
                                   ' dstCF:' -> puttext; dstCF -> putreal; 
                                   ' src*dst:CF: ' -> puttext;
                                   srcCF * dstCF -> putreal; 
                                   newline;
                                   srcCF * dstCF -> srcOS.addConvFactor;
                               if)
                           if);
                           floatDecl.OG[] -> srcQual[] -> dstQual[]
                        else
                           (# UT1,UT2: ^UnitTree; dstBV,srcBV: ^BaseVector
                           do dstU[] 
                                -> parseUnit 
                                -> UT1[] -> mkBaseVector -> dstBV[];
                              (if false then
                                  '**   checkqual:parsed:dstU: '->puttext; 
                                  true -> UT1.print -> putline;
                                  dstBV.print;
                              if);
                              srcU[] 
                                -> parseUnit 
                                -> UT2[] -> mkBaseVector -> srcBV[];
                              (if false then
                                  '**   checkqual:parsed:srcU: '->puttext; 
                                  true -> UT2.print -> putline;
                                  srcBV.print
                              if);
                              (if srcBV[] -> dstBV.equal
                                  (# nonMatchingCV::
                                       (#
                                       do 'non matching conversion factor:'
                                            -> unitWarning
                                  #)#)                                  
                                  then
                                  checkSameDim
                               else
                                  'non matching units:' -> unitWarning;
                                  (if true then 
                                      '*** srcU:'->puttext; srcU[] -> puttext;
                                      ' '-> put;
                                      true -> UT2.print -> putline;
                                      (if withDimProp then
                                          srcBv.asSymbols -> putline;
                                       else
                                          srcBV.print; 
                                      if);
                                      '*** dstU:'->puttext; dstU[]  -> puttext;
                                      ' ' -> put;
                                      true -> UT1.print -> putline;
                                      (if withDimProp then
                                          dstBv.asSymbols -> putline;
                                       else
                                          dstBV.print -> putline
                                      if)
                                  if);
                                  dstBV.print
                           if)#);
                           floatDecl.OG[] -> srcQual[] -> dstQual[]
                   if)if)
                else
                   (if false then (* this  case is not complete! *)
                       'ToBeFixed:srcU:' -> puttext; srcU[] -> puttext;
                       ' srcOS: ' -> puttext; srcOs.dopt -> puttext;
                       ' dstU: ' -> puttext; dstU[] -> puttext;
                       ' dst: ' -> puttext; dopt -> putline
               if)if)
            #)
       #);
     AssignmentStatement::<
       (# getExpUnit::
            (#
            do (if true then
                   '**** AssignmentStatement:getExpUnit: ' -> puttext;
                   dopt -> putline
               if)
            #);
          selectForPrintUnits::
            (* see invocation::selectForPrintUnits:: ... 
             * See also doPrintUnit, and printUnit at other places
             * Apparently used by switch --showUnits
             *)
            (#
            do (if false then
                   '**** SelectForPrintUnits:'->dumpT; dopt -> dumpTN;
               if);
               (none,none,left.last) -> doPrintUnit; 
               (left.last,none,right.super.last) -> doPrintUnit
            #)
          
       #);
     ObjectCall::<
       (# getExpUnit:: 
            (# 
            do (if traceUnit then
                   '**** OC:getExpUnit: ' -> puttext; dopt -> putline;
               if);
               super.getExpUnit -> U[];
               (if traceUnit then
                   '**** ObjectCall:GEU: '->puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectCall:isUnitValueObj: ' -> puttext; 
                   doPT -> puthead
               if);
               (if (super.ATd.asDecl).isPattern then
                   (super.ATd.asDecl -> ptn[]).OG.isUnitValueObj -> value
               if);
               (if traceUnit then
                   '**** ObjectCall:isUnitValueObj= ' -> puttext; 
                   value -> putboolean; newline
               if);
            #);
          getUnitPropShort::
            (# ptn: ^Pattern; 
            do (if traceUnit then
                   '**** objectCall:getUnitPropShort: ' -> puttext; 
                   dopt ->puthead
               if);
               (super.last).ATd[] -> ptn[];
               propNo -> ptn.OG.getUnitPropShort -> U[];
            #);          
          getConstLiteral:: 
            (# 
            do (if traceUnit then
                   '**** ObjectCall:getConstLiteral: ' -> puttext;
                   dopt -> putline; 
               if);
               super.getConstLiteral -> value
            #);
       #);
     ObjectGenerator::<
       (# getUnitProp::
            (# ptn: ^Pattern
            do (* '**** getUnitProp: ' -> putline;
                dopt -> puthead;*)
               (if ((super.ATd[]->ptn[]) <> none) then
                   ptn.OG.getUnitProp -> UN[];
                else
                   IS.newBasicProp.unit[] -> UN[];
               if)
            #);
          getExpUnit:: 
            (# ptn: ^Pattern
            do (if  traceUnit then
                   '**** OG:getExpUnit: ' -> puttext; dopt -> putheadN
               if);
               (if arg1Qual[] <> none then
                   (if showUnits or traceUnit then
                       '**** OG:getExpUnit:arg1Unit: ' -> puttext;
                       arg1Unit[] -> putline
                   if);
                   super.ATd.asDecl->ptn[];
                   (if false then
                       arg1Qual.getExpUnit -> U[];
                       super.ATd[]->ptn[];
                       (if false then
                           U[] -> putline;
                           ptn.dopt -> putline;
                   if)if);
                   (arg1Qual[],arg1Unit[]) -> ptn.mapVarUnit -> U[];
                   leave getExpUnit       
               if);
               (* We may have an OG where super is a dataItem as in
                *    distToAlpha / rocketSpeed  where rocketSpeed 
                * is an OG with super rocketSpeed: var Velocity.Mass
                * We should fix the parser here!
                *)
               (if IS.isEmpty (*and super.ATd.isPattern*) then
                   super.getExpUnit -> U[]
                else
                   (if IS.newBasicProp.unit[] <> none then
                       IS.newBasicProp.unit.args.scanSons
                       (#
                       do current.scanSons
                          (# S: ^StringObj
                          do (if current.isStringLiteral then
                                 (current[] -> S[]).T.copy -> U[];
                       if)#)#)
                    else
                       (if primNo                            
                        // float_prim then '#F' -> U[]
                        // integer_prim then '#I' -> U[]
               if)if)if);
               (if traceUnit then
                   '**** OG:GEU:end: '->puttext; dopt -> puthead;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          hasGenericUnit: booleanValue
            (# U: ^text
            do (if (1 -> getUnitPropShort -> U[]) <> none then
                   '$' -> U.equal -> value;
                   (if value or traceUnit then
                       '**** OG:hasGenericUnit: ' -> puttext; 
                       sig.dopt -> puttext; ' unit: ' -> puttext; 
                       U[] -> putline
               if)if)
            #);       
          isUnitValueObj::
            (* Need to be reconsidered!
             * Not clear why we test for super.ATd being a pattern?
             * For 'OG = a{}' where a: var Area.squareMeter, a.ATd is DataItem
             * For OG = '3{}' and OG = '3 m{]' 3.ATd = integer_decl
             * but integer is not the declaration of 3 - it is the type of 3
             * Perhaps we juts need to check:
             *    IS.isEmpty and (super.ATd.asDecl).OG.isUnitValueObj
             *)
            (# ptn: ^Pattern; DI: ^DataItem; E: ^Exp
            do (if traceUnit then
                   '\n**** ObjectGenerator:isUnitValueObj: ' -> puttext; 
                   doPT -> puthead
               if);
               (if IS.isEmpty and (super.ATd.asDecl).isPattern then
                   (super.ATd.asDecl -> ptn[]).OG.isUnitValueObj -> value
                else
                   IS.newBasicProp.unit[] <> none -> value;
               if);
               (if not value then
                   IS.newBasicProp.unit[] <> none -> value;
               if);
               (if IS.isEmpty and not value then
                   (super.ATd.asDecl).OG.isUnitValueObj -> value
               if);
               (if traceUnit then
                   '\n**** ObjectGenerator:isUnitValueObj=' -> puttext; 
                   value -> putboolean; newline;
                   (if value then doPT -> puthead if)
               if);
            #);  
          getUnitPropShort::
            (# UN: ^NewProperty; E: ^Exp; OI: ^ObjectInvocation
            do (if trx or traceUnit then 
                   '**** ObjectGenerator:getUnitPropShort:' -> puttext; 
                   dopt -> putheadN 
               if);
               (if IS.isEmpty then
                   super.scanSons
                   (#
                   do current[] -> E[]
                   #);
                   propNo -> (E.ATd.asDecl).OG.getUnitPropShort -> U[]
                else
                   (if (IS.newBasicProp.unit[] -> UN[]) <> none then
                       (* unit is defined for this OG*)
                       L:
                         UN.args.scanSons
                         (# i: @integer
                         do i + 1 -> i;
                            current.scanSons
                            (# S: ^StringObj
                            do (if current.isStringLiteral then
                                   (current[] -> S[]).T.copy -> U[];
                                   (if propNo = i then leave L if);
                         if)#)#)
                    else
                       (if IS.newBasicProp.primNo 
                        // float_prim then
                           '#F' -> U[]
                        // integer_prim then '#I' -> U[]
                       (* // char_prim then '#C' -> U[]
                        // boolean_prim then '#B'-> U[]
                        // string_prim then '#S'-> U[]*)
               if)if)if)
            #);          
          getConstLiteral:: 
            (# 
            do (if traceUnit then
                   '**** ObjectGenerator:getConstLiteral: ' -> puttext;
                   dopt -> puthead
               if);
               super.getConstLiteral -> value
            #);
       #);
     invocation::<
       (* inv ::= rec msg
        * msg ::= unary
        *      |  binary
        *      |  functional
        *      |  keyword
        * binary ::=  +, -, *, /, ^, ...
        * Ex
        *  A ^ (0 - 1)
        * rec.getOp -> op
        * msg.getUnit -> U
        *)
       (# getExpUnit::
            (#
            do (if traceUnit then
                   '**** INV:getExpUnit: ' -> puttext; dopt -> puttext;
                   ' recU: ' -> puttext; recU[] -> putline;
               if);
               (if recU[] = none then '' -> recU[] if);
               recU[] -> U[];
               scanSons
               (# E: ^Exp; Ux,Uy: ^text
               do U[] -> current.getExpUnit -> Ux[];
                  (*'**   son: ' -> puttext; current.dopt->puttext; 
                  ' ' -> put; Ux[] -> putline;*)
                  (if Ux[] <> none then
                      (if true 
                       // 'U' -> Ux.equal then
                          current[] -> E[];
                          (E.ATd.asDecl).OG.getUnitPropShort -> Uy[];
                          (if traceUnit then
                              '**** INV:got: "U": '->puttext; dopt -> puthead;
                              current.dopt -> puthead;
                              E.ATd.dopt -> puthead;
                              '*   recU: ' -> puttext; U[] -> putline;
                              Uy[] -> putline;
                          if);
                          (if Uy[] <> none then
                              (if true = ('U*U' -> Uy.equal) then
                                  U.copy -> Uy[];
                                  '*' -> Uy.put;
                                  U[] -> Uy.puttext;
                                  Uy[] -> U[]
                               else
                                  Ux[] -> U[]
                              if)
                           else
                              Ux[] -> U[]
                          if);
                          (if traceUnit then
                              '** trans: ' -> puttext; U[] -> putline 
                          if);
                       // 'U*U' -> Ux.equal then
                          '!!!! got: "U*U": '->puttext; dopt -> puthead;
                       else
                          (*'**   INV:getExp:else2:U: ' ->puttext; U[]->puttext;
                          ' Ux: '->puttext; Ux[] -> putline;*)
                          Ux[] -> U[]
                      if)
                   else
                      (*'**   INV:getExp:else1:U: ' -> puttext; U[]->puttext;
                      ' Ux: '->puttext; Ux[] -> putline;*)
                      Ux[] -> U[]    
               if)#);
               (if traceUnit then
                   '**** INV:getExp:end:: ' -> puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          getConstLiteral:: 
            (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; 
               OI: ^ObjectInvocation
            do (if traceUnit then
                   '**** Invocation:getConstLiteral: ' -> puttext; 
                   dopt -> putline;
               if);
               scanSons
               (#  
               do i + 1 -> i;
                  (if i 
                   // 1 then current[] -> rec[] 
                   // 2 then current[] -> msg[] 
                  if);
               #);
               MaxInt -> value;
               (if i = 2 then
                   (if traceUnit then
                       '**   perhaps a binary method?' -> putline;
                   if);
                   (if msg.isObjectInvocation then
                       (msg[]->OI[]).type.isOp -> op[];
                       (if traceUnit then
                           '**   op: ' -> puttext; op[] -> putline;
                       if);
                       (if '-' -> op.equal then
                           (if traceUnit then '*** got -\n' -> puttext; if);
                           rec.getConstLiteral -> v;
                           OI.args.scanArgs(#do current.getConstLiteral -> u #);
                           (if traceUnit then
                               v -> putint; ' ' -> put; u -> putint; newline;
                           if);
                           v - u -> value
                   if)if)
                else (* perhaps (0 - 1) *)
                   rec.getConstLiteral -> value
               if)
            #);
          selectForPrintUnits::
            (* we should consider 
             *   assignments:  V := E, print units for V and E 
             *   invocations:  foo(E), print unit for E and formal arg?
             *   invocation:   R.foo(E1).S.bar(E2).T.fisk(E3)
             * The argumenst E, E1,E2,E3 should be processed automatically 
             * during the scan
             * But why dont we get foo(3.19"m") in A1 := foo(3.19"m")?
             *)
            (# hasAssign: BooleanValue
                 (#
                 do L:
                      scanSons
                      (# rec,E,arg: ^Exp; i: @integer
                      do i + 1 -> i;
                         E[] -> rec[];
                         current[] -> E[];
                         (if E.ATd[] <> none then
                             (if E.ATd.primNo
                              // vassign_prim // rassign_prim then
                                 '\n!!!! INV:selectForPrintUnits:hasAssign:'
                                   ->puttext;
                                 'shpuldNotHappen:'->dumpT;
                                 dopt -> dumpTN;
                                 true -> value;
                                 (none,none,rec[]) -> doPrintUnit;
                                 E.args.scanSons
                                 (# argx: ^ObjectSpecification
                                 do current->argx[];
                                    (if argx.IS.isEmpty then
                                        (rec[],(argx.super.last))
                                          -> (argx.super.last).printUnit;
                                        (*
                                        (rec[],none,(argx.super.last))
                                          -> doPrintUnit;*)
                                 if)#);
                                 leave L
                 if)if)#)#)
            do hasAssign
            #);
       #);
     ObjectInvocation::<
       (# argUnit:
            (# U: ^Text; n: @integer; arg: ^ObjectGenerator
            do (if unitIssue then
                   '\n**** argUnit:'->dumpt; args.dopt->putheadN
               if);
               args.scanArgs
               (#
               do n + 1 -> n; current[] -> arg[]; 
               #);
               (if unitIssue and (arg[] <> none) then 
                   '**   argUnit:arg:'->dumpT;
                   arg.dopt->dumpTN 
               if);
               (if n = 1 then '' -> arg.getExpUnit -> U[] if);
               (if unitIssue then 
                   '**   argUnit:U:'->puttext; U[] -> dumptn 
               if)
            exit U[]
            #);
          isN2NwithUnitArg:
            (# U,argU: ^text; ptn: ^Pattern; arg: ^ObjectGenerator; rec: ^Exp;
               n: @integer
            enter U[]
            do args.scanArgs
               (#
               do n + 1 -> n; current[] -> arg[];
                  '' -> current.getExpUnit -> argU[];
                  (if unitIssue then '**   argU:' -> dumpT; argU[] -> dumpTN if)
               #);
               (* case foo(exp) where
                * foo(V: var float/int)->float/int: ...
                * and exp.unit = U, 
                * then U -> foo(exp).unit
                *)
               (if (n = 1) and unitIssue then
                   '**** int2int?: '->dumpT; dopt -> dumpTN;
                   'argU:'-> dumpT;  argU[] -> dumpTN;
               if);
               this(ObjectInvocation)[] -> getReceiver -> rec[];
               (if (unitIssue) and (arg[] <> none) and (rec[] <> none) then
                   (# B1,B2,B3: @boolean
                   do '\narg:'->dumpT; arg.dopt->dumpt; arg.label->dumpTN;
                      not rec.isUnitvalueObj -> b1;
                      arg.isUnitValueObj -> b2;
                      (ATd[]->ptn[]).isN2N -> b3;
                      'not rec.isUnitValobj:\t'-> dumpT;
                      b1 -> putboolean;  newline;
                      '(rec.ATd.OG.primNo = integer_prim):' ->dumpT;
                      (rec.ATd.OG.primNo = integer_prim) -> putboolean; newline;
                      '(ATd[]->ptn[]).isN2N:\t'->dumpT;
                      b3 -> putboolean; newline;
                      'arg.isUnitValueObj:' -> dumpT;
                      arg.isUnitValueObj -> putboolean; newline;
               #)if);
               
               (* a2: var Area.SquareMeter
                * A: 3 * a2    : '* a2'.unit = a2.unit = m
                * B: 3 m * 5 m : '* 5m'.unit = '5m'.unit = m
                *)
               (if (rec[] <> none)
                   and not rec.isUnitvalueObj
                   and (rec.ATd.OG.primNo = integer_prim)
                   and (ATd[]->ptn[]).isN2N
                   and arg.isUnitValueObj then
                   'ExpUnit:'->dumpT; expUnit[] -> dumpt;
                   argU[] -> dumpTN;
                   argU[] -> U[] 
               if);
            exit U[]
            #);
          isUnitArg2N:
            (# isInt:< (# do inner #);
               isFloat:< (# do inner #);
               U,parU: ^text; ptn: ^Pattern; D: ^Decl
            enter U[]
            do (if unitIssue then
                   '**** isUnitArg2N:'->puttext; dopt -> puthead; ' ' -> put;
                   ATd.label -> puttext; ' ' -> put;
                   U[] -> putline;
               if);               
               ATd[] -> ptn[];
               (if (ptn.getReturnDecl -> D[]) <> none then
                   D.OG.getExpUnit  -> parU[]; (*parU[] -> dumpt; *)
                   (if parU[] <> none then
                       (if true
                        // '#I'->parU.equal then
                           argUnit -> U[];
                           isInt
                        // '#F'->parU.equal then
                           argUnit -> U[];
                           IsFloat
               if)if)if);
               (if unitIssue then 
                   '**   isUnitArg2N:res:'->dumpt; U[] -> dumptn if)
            exit U[]
            #);
          getExpUnit:: 
            (* pattern:
             *    foo, bar(exp), @put e :at ix
             *    := exp
             *    + exp, - exp, * exp, / exp, ^exp
             * dataItem: X, rocketSpeed
             *)
            (# getBinArg: 
                 (#
                 do L:
                      (if args[] <> none then
                          args.scanArgs
                          (#
                          do current.getExpUnit -> U[];
                             (* current.getExpUnit may return #F or #integer
                              * and these should not be appended to recU
                              *)
                             leave L
                      #)if)
                 #);
               filterNumeric:
                 (# op: @char; Ux: ^Text
                 do getBinArg; 
                    (if traceUnit then
                        '**   OI:GEU:filterNumeric: "' ->puttext; dopt->puttext;
                        '"  recU: "' -> puttext; recU[] -> puttext;
                        '"  U: "' -> puttext; U[] -> puttext; '"'->put; newline
                    if);
                    (if true
                     // '#F' -> recU.equal
                     // '#I' -> recU.equal then
                        inner;
                        (if op
                         // '*' then
                         // '/' then
                            '(1/(' -> Ux[];
                            U.copy -> Ux.append;
                            '))'-> Ux.append;
                            Ux[] -> U[]
                         else
                            (* return U *)
                        if)
                     // '#F' -> U.equal (* why again? *)
                     // '#I' -> U.equal then
                        recU[] -> U[] (* return recU *)                        
                     // '#Q' -> U.equal then
                        (if '#Q' -> recU.equal then 
                            recU[] -> U[] 
                         else
                            '\n!!! OBS!:'->puttext;
                            'A combination of units "#Q" and "' -> puttext;
                            recU[] -> puttext;
                            '" in: ' -> puttext; 
                            'unitHandler::filterNumeric'->putline
                        if)
                     else
                        inner;
                        recU.copy -> Ux[];
                        '(' -> Ux.prepend; ')' -> Ux.append;
                        op -> Ux.put; '(' -> Ux.put;
                        U.copy -> Ux.puttext; ')' -> Ux.put;
                        Ux[] -> U[]
                    if);
                    (if traceUnit then
                        '**   OI:filterNumeric:end: '->puttext; U[] -> putline;
                    if)
                 #);
               V: @integer; rec: ^Exp; recINV: ^ObjectInvocation
            do (if traceUnit then
                   '**** OI:getExpUnit: ' -> puttext; dopt -> puttext;
                   ' recU: '->puttext; recU[] -> puttext; 
                   ' ATd: '->puttext; Atd.sig.dopt -> putline
               if);
               (if ATd[] <> none then
                   (if true
                    // (ATd.asDecl).isDataItem then
                       (if expUnit[] <> none then
                           expUnit.copy -> U[];
                       if);
                       (if (unit[] <> none) and
                           (unit.T[] <> none) and (unit.T.length > 0) then
                           (*'OI:unit:'->dumpT; unit.dopt->dumptN;*)
                           unit.T[] -> U[]
                       if)
                    // (ATd.asDecl).isPattern then
                       (* '**   ATd.isPattern: ' -> puttext;
                        * ATd.primNo -> putint; newline;
                        *)
                       (if recU[] = none then '' -> recU[] if);
                       (if (ATd.asDecl).primNo
                        // 109 // 61 (* + float and int *)
                        // 110 // 62 (* - *) then
                           args.scanArgs(#do current.getExpUnit -> U[] #);
                           (* recU and U must be equal *)
                        // 112 // 66 (* * float and int *)then
                           (* recU/U may be a numeric constant or dataItem *)
                           filterNumeric(#do '*'->op #)
                        // 121 // 67 (* / float and int *) then
                           filterNumeric(#do '/' -> op #)
                           (* // '^' -- not a primitive *)
                        // vassign_prim //rassign_prim then
                           (* What is the purpose of the code below?
                            * Seemes redundant!
                            *)
                           (# dstBV,srcBV: ^BaseVector; T: ^UnitTree
                           do args.scanArgs(#do current.getExpUnit -> U[] #);
                              (if traceUnit then
                                  '**   assign: '->puttext; recU[] -> puttext;
                                  ' ' -> put; U[] -> putline;
                              if);
                              (if true 
                               // '#F' -> recU.equal then
                                  (if true
                                   // '#F' -> U.equal then
                                   // '#I' -> U.equal then
                                  if)
                                  (* incompete if no match above (or below) *)
                               // '#I' -> recU.equal then
                                  (if true
                                   // '#F' -> U.equal then
                                   // '#I' -> U.equal then
                                  if)
                               // recU.length = 0 then
                                  (* check what to do here! *)
                               else                                
                                  (if doCheckUnits then
                                      recU[] 
                                        -> parseUnit -> mkBaseVector -> dstBV[];
                                      U[] -> parseUnit -> T[] 
                                        -> mkBaseVector -> srcBV[];
                                      (if srcBV[] -> dstBV.equal then
                                          '**** equal:'->puttext; 
                                          recU[] -> puttext;
                                          ' ' -> put; U[] -> putline;
                                          (*true -> T.print -> putline;*)
                                       else
                                          '**** not equal:'->puttext; 
                                          U[] -> puttext;
                                          ' ' -> put; recU[] -> putline;
                                          dstBV.print;
                                          true -> T.print->putline;
                                          srcBV.print;
                           if)if)if)#)
                        else
                           (* Q or R.Q where Q = this(OI) and 
                            * Q: oneOf: foo, bar(exp), @put e :at ix
                            *)
                           (if traceUnit then
                               '**** OI:getExpUnit:sig: "' -> puttext;
                               ATd.sig.dopt -> puttext; '"' -> put;
                               (ATd.sig.dopt).length -> putint; newline;
                               dopt -> putline;
                           if);
                           (if '^' = (1->((ATd.asDecl).sig.dopt).inxGet) then
                               (if traceUnit then '**** got ^:' ->putline if);
                               args.scanArgs(#do current.getConstLiteral ->V #);
                               '(' -> recU.prepend; ')' -> recU.append;
                               '^' -> recU.put; '(' -> recU.put;
                               V -> recU.putint; ')' -> recU.put;
                               recU[] -> U[];
                               (*  '**** ^res: ' -> puttext; U[]->putline*)
                            else
                               (# ptn: ^Pattern; argU: ^Text; n: @integer;
                                  arg: ^ObjectGenerator
                               do (if unitIssue or traceUnit then
                                      '**** OI:GEU:ptn: '->puttext; 
                                      dopt -> putline; ATd.dopt -> putheadN;
                                      args.dopt -> puttext; newline;
                                  if);
                                  (if (ATd.asDecl -> ptn[]).hasGenericUnit then
                                      '$' -> U[]
                                   else
                                      expUnit[] -> U[]; 
                                  if);

                                  (if traceUnit then 
                                      '**   U:'->puttext; U[] -> putline 
                                  if);

                                  U[] -> isN2NwithUnitArg -> U[];
                                  (if (U[] <> none) and 
                                      (('#I'->U.equal) or ('#F'->U.equal)) then 
                                      (* are sure that there is just one 
                                       * argument? *)
                                      U[] -> isUnitArg2N -> U[];
                                  if);
                                  (if U[] = none then 
                                      (if (ATd.asDecl).OG.primNo 
                                       // stringget_prim 
                                       // indexedget_prim 
                                       // indexedPut_prim then
                                          '#I' -> U[]
                                       else
                                          (* can be <=, && or other binary
                                           * operators ...
                                          (*U[] -> isUnitArg2N -> U[];*)
                                          (if U[] = none then '#Q' -> U[] if)
               if)if)#)if)if)if)if);
               (if traceUnit then
                   '**** OI:GEU:end: ' -> puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          getConstLiteral:: 
            (# op: ^Text
            do (if trx or traceUnit then
                   '**** ObjectInvocation:getConstLiteral: ' -> puttext; 
                   dopt -> putline;
                   '**   Not implememnted' -> putline
               if)               
            #);   
          addConvFactor::
            (#
            do (if false then
                   '**** OI:addConvFactor: ' -> puttext; 
                   dopt -> puttext; ' '-> put;
                   CF -> putReal; newline;
               if);
               (if convFactor <> 0 then
                   '**** OI:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   CF -> convFactor; true -> done;
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #);

          selectForPrintUnits::
            (* may be reached trhough general traverse in qabstractsyntaxtree
             * In addition an explicit doPrintUnit of this(OI) may be 
             * invoked on the argument of an assign in Invocation;
             * controlled by a boolean in doPrintUnit
             *)
            (#
            do args.scanSons
               (# arg: ^ObjectSpecification
               do (if current.isObjectGenerator then
                      current[] -> arg[];
                      (if arg.IS.isEmpty then  
                          (this(ObjectInvocation)[],(arg.super.last))
                            -> (arg.super.last).ATd.printUnit;
                          
                          (this(ObjectInvocation)[],none,(arg.super.last))
                            -> doPrintUnit;
               if)if)#)
            #);
          printUnit::
            (#
            do (*'OI:printUnit: '->puttext; dopt -> putline;*)
               (rec[],E[]) -> ATd.printUnit
            #)
       #);
     BracketedExp::<
       (# getExpUnit::
            (#
            do recU[] -> IV.getExpUnit -> U[];
               (if (unit[] <> none) 
                   and (unit.T[] <> none) and (unit.T.length > 0) then
                   (*'**** BE: ' -> dumpT; U[] -> dumpT;*)
                   unit.T[] -> dumptN;
                   unit.T[] -> U[]
               if)
            #);
          getConstLiteral:: (# do IV.getConstLiteral -> value #)
       #);
     Name::< 
       (# getConstLiteral::
            (#
            do '**** Name:getConstLiteral: ' -> puttext; dopt -> putline;
               MaxInt -> value
            #)
       #);
     Const::< 
       (# isUnitValueObj::
            (#
            do (if unitIssue then
                   '**** Const:isUnitValueObj:'-> puttext; dopt -> puttext;
               if);
               (if (unit[] <> none) and (unit.T[] <> none) then
                   (if unitIssue then
                       ' true: ' -> dumpT;
                       unit.T[] -> putline;
                   if);
                   true -> value
                else
                   (if unitIssue then
                       ' false: ' -> dumpT;
                       newline
               if)if)
            #);
          getExpUnit::
            (#
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if traceUnit then
                       '**** Const:getExpUnit: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '#I' -> U[]
               if)
            #);
          getConstLiteral:: (# do T.setPos; T.getInt -> value #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** Const:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** Const:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done -> convDone 
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #);
          convDone: @boolean;
          printUnit:: (#do 'Const:printUnit:'-> puttext; dopt -> putline #);
          int2floatDone:: 
            (# 
            do convDone -> value; 
               cd.com(#do 'convDone:'->TT; convDone -> BB #)
            #);
       #);
     FloatConst::<
       (# getExpUnit::
            (# 
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if traceUnit then
                       '**** FloatConst:getExpUnit: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '#F' -> U[]
               if)
            #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   (*'**** FloatConst:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline*)
                else
                   (*'**** FloatConst:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;*)
                   CF  -> convFactor; true -> done; 
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #);
          printUnit::
          (# 
          do (*'FloatConst:printUnit:'-> puttext; dopt -> putline;*)
             (rec[],none,E[]) -> doPrintUnit
          #);
       #);
     
     (******************** public patterns **************)
     (* TODO:
      * dimension names and unit names must be identifiers - not expressions
      * check that a new dim/uit name is not already defines -- must uniqueu
      * check that no dim name is also a unit name and vide versa
      * In %dimension N dimExp, dimExp must be an expression of dim names
      * we have a problem with expressions like
      *    exhaustSpeed := 1000000.0 "m*s^-1"
      * In the %unit version "m*s^-1" was defined in
      *    %unit "MpS", "m*s^-1"
      * which it is not in the %dimension version
      * We must convert "m*s^-1" to "MpS" by finding the dimension and
      * then the corresponding unit - but is this always clear if several units?
      * We have temporarily added it to %unit
      *)
     addToDimTable:: (# do unitProp[] -> dimTable.add #);
     addToUnitTable:: (# do unitProp[] -> unitTable.add #);
     mkBaseVector:
       (# T: ^UnitTree; BVl,BVr: ^baseVector;
          notValidUnit:< Object
       enter T[]
       <<SLOT mkBaseVector:doPart>>
       exit BVl[]                   
       #);
     findDimElm:
       (# noDimensionFound:< Object;
          UorD: ^Text; 
          isUnit,isPrimaryUnit: @boolean;
          current,dim: ^dimTable.dimElm; theConvFactor: @ Real
       enter UorD[]
       do L:
            UorD[] -> unitTable.find
          (#
          do (if UorD[] -> current.US[1].equalNCS then
                 true -> isUnit;
                 current.theDimElm[] -> dim[];
                 current.convFactor -> theConvFactor;
                 (if theConvFactor = 1.0 then true -> isPrimaryUnit if);
                 (*'**** findDimElm:U: ' -> dumpT; 
                 (if dim[] = none then 
                  else
                     dim.print
                 if);*)
                 (*'**   convFactor: ' -> puttext; theConvFactor -> putreal;
                 newline; current.print;
                 newline;*)
                 leave L
             if)
          #);
          (if dim[] = none then
              L:
                UorD[] -> dimTable.find
              (#
              do (if UorD[] -> current.US[1].equalNCS then
                     (*true -> current.inUse;*)
                     current[] -> dim[];
                     (*'**** findDimElmD:' -> dumpTN; dim.print;*)
                     leave L
                 if)
              #);
          if);
          dim[] -> current[];
          (if dim[] = none then
              noDimensionFound
           else
              inner
          if)
       #);     
     noOfBaseDims,noOfBaseUnits: @integer;     
     BaseVector:
       (# <<SLOT BaseVectorLib:attributes>>;
          theBase: [noOfBaseUnits] @integer;  
          theDim: [noOfBaseUnits] ^dimTable.DimElm;
          (* [8] is Dimension, just technical*)

          convFactor: @Real;
          equal: BooleanValue
            (# BV: ^BaseVector;
               nonMatchingCV:< (# do inner #);
            enter BV[]
            <<SLOT BaseVector_equal:doPart>>
            #);
          print:
            (# T: @text
              <<SLOT BaseVector_print:doPart>>
            exit T[]
            #);
          asSymbols:
            (# T: @text
              <<SLOT asSymbols:doPart>>
            exit T[]
            #);
            
          (*do 8 -> noOfBaseUnits*)
       exit this(Basevector)[]
       #);     
     TimeInx: (# exit 1 #);
     LengthInx: (# exit 2 #);
     MassInx: (# exit 3 #);
     ElectInx: (#exit 4 #);
     TempInx: (#exit 5 #);
     SubstanceInx: (#exit 6 #);
     LuminousInx: (#exit 7 #);
     dimTable: @
       (# <<SLOT dimTableLib:attributes>>;
          add:
            (# prop: ^NewProperty;
            enter prop[]
            <<SLOT dimTableAdd:doPart>>
            #);
          dimElm:
            (# <<SLOT dimTable_dimElm_LIB:attributes>>;
               dim: ^Decl; 
               name: ^Lexem;
               isBaseDim: @boolean;
               dimExp: ^StringObj;
               prop: ^NewProperty;
               baseInx: @integer; (* if base dim, index into baseVector *)
               US: [5] ^Text; UStop: @integer;
               inUse: @boolean;
               print: <<SLOT dimTable_dimElm_print:descriptor>>;
            enter(dim[],prop[])
            exit this(dimElm)[]
            #);   
          find:
            (# u: ^text; current: ^dimElm
            enter U[]
            <<SLOT dimTable_find:dopart>>
            #);  
          scan:
            (# current: ^dimElm
            do (for i: top repeat
                    DU[i][] -> current[];
                    inner scan
               for)
            #);
          print: <<SLOT dimTable_print:descriptor>>;          
          DU: [7] ^dimElm; top: @integer; (* DU other name? *)
          N: ^ObjectGenerator; DI: ^Decl;
          L: ^dimElm
       #);
     unitTable: @
       (# <<SLOT unitTableLib:attributes>>;
          add:
            (# prop: ^NewProperty; unitPtn: ^Pattern
            enter prop[]
            <<SLOT unitTableAdd:doPart>>
            #);
          unitElm:
            (# <<SLOT unitTable_unitElm_LIB:attributes>>;
               dim: ^Decl; 
               theDimElm: ^dimTable.DimElm;
               isBaseDim: @boolean;
               unit: ^Pattern;
               isPrimaryUnit: @boolean;
               US: [5] ^Text; UStop: @integer;
               convFactor: @real;
               prop: ^NewProperty;
               baseInx: @integer; (* if base unit, index into baseVector *)
               print: <<SLOT unitTable_unitElm_print:descriptor>>;
            enter(dim[],unit[],prop[],theDimElm[])
            exit this(unitElm)[]
            #);
          findAndCheck:
            (* Lookup lU and rU to check if they belong to the same
             * dimension. This could be meter and centimeter. 
             * If same dimension, true is returned together with the conversion
             * factors to the base unit.
             * For base unit, convFactor = 0; should probably be 1
             * Currently only the unit names of lU and rU are searched, thus 
             * "m2" and "m*m" will not be matched as in the same dimension,
             * even if they are the same unit. 
             * Perhaps this should be changed!?
             *)
            (# lU,rU: ^text; sameDim: @boolean;
               lDim,rDim: ^Decl;
               lCF,rCF: @real
            enter(lU[],rU[])
            <<SLOT unitTable_findCheck:doPart>> 
            exit(sameDim,lCF,rCF)
            #);
          find:
            (# u: ^text; current: ^unitElm
            enter U[]
            <<SLOT unitTable_find:dopart>>
            #);
          findUOG: find
            (# uOG: ^ObjectGenerator
              <<SLOT unitTable_findUOG:dopart>>
            exit uOG[]
            #);
          findInAll:
            (# U: ^text; current: ^unitElm; U1: @text
            enter U[]
            <<SLOT unitTable_findInAll:doPart>>
            #);
          findUOGall: findInAll
            (# uOG: ^ObjectGenerator
              <<SLOT unitTable_findUOGall:dopart>>
            exit uOG[]
            #);
          scan:
            (# current: ^unitElm
              <<SLOT unitTable_scan:dopart>>
            #);
          print: <<SLOT unitTable_print:descriptor>>;            
          DU: [7] ^unitElm; top: @integer;
          (*N: ^ObjectGenerator; DI: ^Decl;*)
          L: ^unitElm
       #);
     doPrintUnit:
       (* See ObjectInvocation:selectForPrintUnit regarding E.unitPrinted *)
       (# rec: ^Exp; E: ^Exp; recU,U: ^text; UT: ^UnitTree; BV: ^BaseVector;
          stripUnit: 
            (* Perhaps a kind of hack;
             * we may have U = '(1/(#F))' or similar and 
             * we need to reduce it to '#F'
             * We should look into using #F and #I and combinations
             * with numbers like '(1/(#I))'
             *)
            (# U,Ux: ^text; stripped: @boolean
            enter U[]
            do U[] -> Ux[];
               L: 
                 (if (1->Ux.inxGet) = '(' then
                     (2,Ux.length-1) -> Ux.sub -> Ux[];
                     (if ('1/'-> ((1,2) -> Ux.sub).equal) then
                         (3,Ux.length) -> Ux.sub -> Ux[];
                         true -> stripped;
                         restart L
                     if)
                 if);
               (if stripped then 
                   (if traceUE then
                       '**** stripUnit: "'->puttext; U[] -> puttext;
                       '" to: "'->puttext; Ux[] -> puttext; '"\n'->puttext
                   if);
                   Ux[] -> U[]
               if)
            exit U[]
            #);
       enter(rec[],recU[],E[])
       do (if not E.unitPrinted then
              (if recU[] = none then
                  (if rec[] = none then
                      '' -> recU[] 
                   else
                      rec.getExpUnit -> recU[];
              if)if);
              (if ((recU[] -> E.getExpUnit -> U[]) <> none) 
                  and (U.length > 0) then
                  U[] -> stripUnit -> U[];
                  (if true
                   // '#I' -> U.equal
                   // '#F' -> U.equal 
                   // 'U' -> U.equal 
                   // '#Q' -> U.equal then
                   else
                      (if traceUnit then 
                          '**** doPrintUnit:'->puttext;
                          ' rec: ' -> puttext; 
                          (if rec[] = none then
                              'none'->puttext
                           else
                              rec.dopt -> puttext
                          if);
                          ' E: ' -> puttext; E.dopt -> putline;
                      if);  
                      notify:
                        E[] -> notification
                      (# printHeading::
                           (#do 'UNIT of expression' -> puttext #);
                         report:: (#do true -> value #)
                      do 'Expression: ' -> msg;
                         E.dopt -> msg; 
                         '\n**         unit: ' -> msg;
                         U[] -> msg;
                         '\n**    dimension: ' -> msg;
                         U[] -> parseUnit -> UT[] 
                           -> mkBaseVector 
                         (# notValidUnit::(#do leave notify #)#)
                           -> BV[];
                         BV.print -> msg
                  #)if);
                  true -> E.unitPrinted
          if)if)
       #);
     decodeUnits:
       (* used to be in qsemchecker.bet but has no purpose? *)       
       (# UT: ^UnitTree; BV: ^Basevector
       do (if false then '**** decodeUnits:'->putline if);          
          unitTable.scan
          (#
          do (if false then current.print; if);
             (for i: current.UStop repeat 
                  (if false then
                      '**   parse: ' -> puttext;
                      current.US[i][] -> putline;
                  if);
                  current.US[i][] -> parseUnit -> UT[];
                  UT[] -> mkBasevector  -> BV[];
                  (if false then
                      '**   parsed: ' -> puttext; true->UT.print->putline;
                      BV.print
          if)for)#)
       #)
  do (if traceUE then dimTable.print; if);
     inner
  #)
