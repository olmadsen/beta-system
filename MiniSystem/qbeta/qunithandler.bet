ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'; 
INCLUDE 'qunitparser' 
---lib:attributes--- 
doCheckUnits: (# exit false #);
useNewUnitHandler: (# exit true #);
UnitHandler: checker
  (# Pattern::<
       (# isN2N: BooleanValue
            (# inArg,outArg: ^Decl; inn: @integer
            do scanargs(#do inn + 1 -> inn; currentArg[] -> inArg[] #);
               (if inn = 1 then 
                   (if unitIssue then 'isN2N:'->dumpT; inArg.dopt-> dumpT; if);
                   (if inArg.OG.primNo = integer_prim then
                       getreturnDecl -> outArg[]; 
                       (if unitIssue then outArg.dopt-> dumpTN; if);
                       (if outarg[] <> none then
                           outarg.OG.primno = integer_prim -> value;
                           (if unitIssue then 
                               'isN2N:'->dumpT;
                               (if value then 'TRUE'->dumpTN 
                                else 'FALSE'->dumpTN if);
                           if)
                           (* receiver must also be integer *)
               if)if)if)
            #);
          getExpUnit:: 
            (# 
            do '**** pattern:getExpUnit:shoulNotHappen: ' -> putline;
               dopt -> puthead
            #);
          hasGenericUnit: booleanValue
            (# U: ^text
            do (if (1 -> OG.getUnitPropShort -> U[]) <> none then
                   '$' -> U.equal -> value;
                   (if value and traceUnit then
                       '**** ptn:hasGenericUnit: ' -> puttext; 
                       sig.dopt -> puttext; ' unit: ' -> puttext; 
                       U[] -> putline
               if)if)
            #);
          mapVarUnit:
            (# qual: ^ObjectGenerator; unit,U: ^text; UT: ^UnitTree
            enter(qual[],unit[])
            do (if traceUnit then
                   '**** ptn:mapVarUnit: ' -> puttext; unit[] -> puttext;
                   ' qual: ' -> putline; qual.dopt -> puthead;
                   '**   Ptn: ' -> putline; dopt -> puthead;
               if);
               (if OG.IS.newBasicProp.unit[] <> none then
                   OG.IS.newBasicProp.unit.args.scanSons
                   (#
                   do current.scanSons
                      (# S: ^StringObj
                      do (if current.isStringLiteral then
                             (current[]->S[]).T[] -> U[]
                         if)
                      #)
                   #);
                else
                   '#F' -> U[]; (* probably dont work - see SlideEx *)
               if);
               (if false then U[] -> putline; if);

               U[] -> parseUnit -> UT[]; 
               (if traceUnit then
                   '**   UT: ' -> puttext; true -> UT.print -> putline;
               if);
               (if true then
                   unit[] -> UT.replaceUnitVar;
                else
                   qual.getExpUnit -> UT.replaceUnitVar;
               if);
               (if traceUnit then 
                   '** replaced: ' -> puttext; true -> UT.print -> putline
               if);
               true -> UT.print -> U[]
            exit U[]
            #);
       #);
     DataItem::<
       (# getExpUnit::
            (#
            do '**** DataItem:getUnit:shoulNotHappen: ' -> puttext; 
               dopt -> putline
            #);
       #);
     ObjectCall::<
       (# getExpUnit:: 
            (# 
            do (if traceUnit then
                   '**** OC:getExpUnit: ' -> puttext; dopt -> putline;
               if);
               super.getExpUnit -> U[];
               (if traceUnit then
                   '**** ObjectCall:GEU: '->puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectCall:isUnitValueObj: ' -> puttext; 
                   doPT -> puthead
               if);
               (if (super.ATd.asDecl).isPattern then
                   (super.ATd.asDecl -> ptn[]).OG.isUnitValueObj -> value
               if);
               (if traceUnit then
                   '**** ObjectCall:isUnitValueObj= ' -> puttext; 
                   value -> putboolean; newline
               if);
            #);
          getUnitPropShort::
            (# ptn: ^Pattern; 
            do (if traceUnit then
                   '**** objectCall:getUnitPropShort: ' -> puttext; 
                   dopt ->puthead
               if);
               (super.last).ATd[] -> ptn[];
               propNo -> ptn.OG.getUnitPropShort -> U[];
            #);          
          getConstLiteral:: 
            (# 
            do (if traceUnit then
                   '**** ObjectCall:getConstLiteral: ' -> puttext;
                   dopt -> putline; 
               if);
               super.getConstLiteral -> value
            #);
       #);
     ObjectGenerator::<
       (# getUnitProp::
            (# ptn: ^Pattern
            do (* '**** getUnitProp: ' -> putline;
               dopt -> puthead;*)
               (if ((super.ATd[]->ptn[]) <> none) then
                   ptn.OG.getUnitProp -> UN[];
                else
                   IS.newBasicProp.UNIT[] -> UN[];
               if)
            #);
          getExpUnit:: 
            (# ptn: ^Pattern
            do (if  traceUnit then
                   '**** OG:getExpUnit: ' -> puttext; dopt -> putheadN
               if);
               (if arg1Qual[] <> none then
                   (if showUnits or traceUnit then
                       '**** OG:getExpUnit:arg1Unit: ' -> puttext;
                       arg1Unit[] -> putline
                   if);
                   super.ATd.asDecl->ptn[];
                   (if false then
                       arg1Qual.getExpUnit -> U[];
                       super.ATd[]->ptn[];
                       (if false then
                           U[] -> putline;
                           ptn.dopt -> putline;
                   if)if);
                   (arg1Qual[],arg1Unit[]) -> ptn.mapVarUnit -> U[];
                   leave getExpUnit       
               if);
               (* We may have an OG where super is a dataItem as in
                *    distToAlpha / rocketSpeed  where rocketSpeed 
                * is an OG with super rocketSpeed: var Velocity.Mass
                * We should fix the parser here!
                *)
               (if IS.isEmpty (*and super.ATd.isPattern*) then
                   super.getExpUnit -> U[]
                else
                   (if IS.newBasicProp.unit[] <> none then
                       IS.newBasicProp.unit.args.scanSons
                       (#
                       do current.scanSons
                          (# S: ^StringObj
                          do (if current.isStringLiteral then
                                 (current[] -> S[]).T[] -> U[];
                             if)
                          #)
                       #)
                    else
                       (if primNo                            
                        // float_prim then '#F' -> U[]
                        // integer_prim then '#I' -> U[]
               if)if)if);
               (if traceUnit then
                   '**** OG:GEU: '->puttext; dopt -> puthead;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          hasGenericUnit: booleanValue
            (# U: ^text
            do (if (1 -> getUnitPropShort -> U[]) <> none then
                   '$' -> U.equal -> value;
                   (if value or traceUnit then
                       '**** OG:hasGenericUnit: ' -> puttext; 
                       sig.dopt -> puttext; ' unit: ' -> puttext; 
                       U[] -> putline
               if)if)
            #);       
          isUnitValueObj::
            (* Need to be reconsidered!
             * Not clear why we test for super.ATd being a pattern?
             * For 'OG = a{}' where a: var Area.squareMeter, a.ATd is DataItem
             * For OG = '3{}' and OG = '3 m{]' 3.ATd = integer_decl
             * but integer is not the declaration of 3 - it is the type of 3
             * Perhaps we juts need to check:
             *    IS.isEmpty and (super.ATd.asDecl).OG.isUnitValueObj
             *)
            (# ptn: ^Pattern; DI: ^DataItem; E: ^Exp
            do (if traceUnit then
                   '\n**** ObjectGenerator:isUnitValueObj: ' -> puttext; 
                   doPT -> puthead
               if);
               (if IS.isEmpty and (super.ATd.asDecl).isPattern then
                   (super.ATd.asDecl -> ptn[]).OG.isUnitValueObj -> value
               else
                   IS.newBasicProp.unit[] <> none -> value;
               if);
               (if not value then
                   IS.newBasicProp.unit[] <> none -> value;
               if);
               (if IS.isEmpty and not value then
                   (super.ATd.asDecl).OG.isUnitValueObj -> value
               if);
               (*
               (if not (IS.newBasicProp.unit[] <> none -> value) then
                   (if super.ATd[] <> none then
                       (if super.ATd.isPattern then
                           (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
                if)if)if)*)
               (if traceUnit then
                   '\n**** ObjectGenerator:isUnitValueObj=' -> puttext; 
                   value -> putboolean; newline;
                   (if value then doPT -> puthead if)
               if);
            #);  
         getUnitPropShort::
            (# UN: ^NewProperty; E: ^Exp; OI: ^ObjectInvocation
            do (if trx or traceUnit then 
                   '**** ObjectGenerator:getUnitPropShort:' -> putline; 
                   dopt -> puthead 
               if);
               (if IS.isEmpty then
                   super.scanSons
                   (#
                   do current[] -> E[]
                   #);
                   propNo -> (E.ATd.asDecl).OG.getUnitPropShort -> U[]
                else
                   (if (IS.newBasicProp.unit[]-> UN[]) <> none then
                       (* unit is defined for this OG*)
                       L:
                         UN.args.scanSons
                         (# i: @integer
                         do i + 1 -> i;
                            current.scanSons
                            (# S: ^StringObj
                            do (if current.isStringLiteral then
                                   (current[] -> S[]).T[] -> U[];
                                   (if propNo = i then leave L if);
                               if);
                         #)#)
                    else
                       (if IS.newBasicProp.primNo 
                        // float_prim then
                           '#F' -> U[]
                        // integer_prim then
                           '#I' -> U[]
                       if)
            if)if)#);          
          getConstLiteral:: 
            (# 
            do (if traceUnit then
                   '**** ObjectGenerator:getConstLiteral: ' -> puttext;
                   dopt -> puthead
               if);
               super.getConstLiteral -> value
            #);
       #);
     invocation::<
       (* inv ::= rec msg
        * msg ::= unary
        *      |  binary
        *      |  functional
        *      |  keyword
        * binary ::=  +, -, *, /, ^, ...
        * Ex
        *  A ^ (0 - 1)
        * rec.getOp -> op
        * msg.getUnit -> U
        *)
       (# getExpUnit::
            (#
            do (if traceUnit then
                   '**** INV:getExpUnit: ' -> puttext; dopt -> putline;
               if);
               (if recU[] = none then '' -> recU[] if);
               recU[] -> U[];
               scanSons
               (# E: ^Exp; Ux,Uy: ^text
               do U[] -> current.getExpUnit -> Ux[];
                  (if Ux[] <> none then
                      (if true 
                       // 'U' -> Ux.equal then
                          current[] -> E[];
                          (E.ATd.asDecl).OG.getUnitPropShort -> Uy[];
                           (if traceUnit then
                               '**** INV:got: "U": '->puttext; dopt -> puthead;
                               current.dopt -> puthead;
                               E.ATd.dopt -> puthead;
                               '*   recU: ' -> puttext; U[] -> putline;
                               Uy[] -> putline;
                           if);
                           (if Uy[] <> none then
                               (if true
                                // 'U*U' -> Uy.equal then
                                   U.copy -> Uy[];
                                   '*' -> Uy.put;
                                   U[] -> Uy.puttext;
                                   Uy[] -> U[]
                                else
                                   Ux[] -> U[]
                               if)
                            else
                               Ux[] -> U[]
                           if);
                           (if traceUnit then
                               '** trans: ' -> puttext; U[] -> putline 
                           if);
                        // 'U*U' -> Ux.equal then
                           '!!!! got: "U*U": '->puttext; dopt -> puthead;
                        else
                           Ux[] -> U[]
                       if)
                    else
                       Ux[] -> U[]    
                   if);
               #);
               (if traceUnit then
                   '**** INV:GEU: ' -> puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          getConstLiteral:: 
            (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; 
               OI: ^ObjectInvocation
             do (if traceUnit then
                    '**** Invocation:getConstLiteral: ' -> puttext; 
                    dopt -> putline;
                if);
                scanSons
                (#  
                do i + 1 -> i;
                   (if i 
                    // 1 then current[] -> rec[] 
                    // 2 then current[] -> msg[] 
                   if);
                #);
                MaxInt -> value;
                (if i = 2 then
                    (if traceUnit then
                        '**   perhaps a binary method?' -> putline;
                    if);
                    (if msg.isObjectInvocation then
                        (msg[]->OI[]).type.isOp -> op[];
                        (if traceUnit then
                            '**   op: ' -> puttext; op[] -> putline;
                        if);
                        (if '-' -> op.equal then
                            (if traceUnit then '*** got -\n' -> puttext; if);
                            rec.getConstLiteral -> v;
                            OI.args.scanArgs(#do current.getConstLiteral -> u #);
                            (if traceUnit then
                                v -> putint; ' ' -> put; u -> putint; newline;
                            if);
                            v - u -> value
                        if)
                    if)
                 else (* perhaps (0 - 1) *)
                    rec.getConstLiteral -> value
                if)
            #);
          printUnits::
            (# U: ^text; UT: ^UnitTree; BV: ^BaseVector
            do (if ((getExpUnit -> U[]) <> none) and (U.length > 0) then
                   (if true
                    // 'U' -> U.equal // 'Q' -> U.equal then 
                       leave printUnits 
                   if);
                   (if true
                    // '#I' -> U.equal
                    // '#F' -> U.equal then
                    else
                       (if not noPT then
                           this(Invocation)[] -> notification
                           (# printHeading::
                                (#do 'UNIT of Invocation' -> puttext #);
                              report:: (#do true -> value #)
                           do 'Invocation: ' -> msg;
                              dopt -> msg; 
                              '\n**   has unit  : ' -> msg;
                              U[] -> msg;
                              '\n**   dimension: ' -> msg;
                              U[] -> parseUnit -> UT[] -> mkBaseVector -> BV[];
                              BV.print -> msg
                           #)
                        else
                           '\n**** Invocation: ' -> puttext;
                           dopt -> puttext; 
                           '\n**   has unit  : ' -> puttext;
                           U[] -> puttext;
                           '\n**   in base units: ' -> puttext;
                           U[] -> parseUnit -> UT[] -> mkBaseVector -> BV[];
                           BV.print -> puttext                           
                       if);
                       true -> noPT
               if)if);

            #)          
       #);
     ObjectInvocation::<
       (# isN2NwithUnitArg:
            (# U,argU: ^text; ptn: ^Pattern; arg: ^ObjectGenerator; rec: ^Exp;
               n: @integer
            enter U[]
            do args.scanArgs
               (#
               do n + 1 -> n; current[]->arg[];
                  ''->current.getExpUnit -> argU[];
                  (if unitIssue then
                      '**   argU:' -> dumpT;
                      argU[] -> dumpTN
                  if)
               #);
               (* case foo(exp) where
                * foo(V: var float/int)->float/int: ...
                * and exp.unit = U, 
                * then U -> foo(exp).unit
                *)
               (if (n = 1) and unitIssue then
                   '**** int2int?: '->dumpT;
                   dopt -> dumpTN;
                   ptn.dopt -> dumpTN;
                   argU[]->dumpTN;
               if);
               this(ObjectInvocation)[] 
                 -> getReceiver
                 -> rec[];
               (if (unitIssue) and
                   (arg[] <> none) and (rec[] <> none) then
                   (# B1,B2,B3: @boolean
                   do '\narg:'->dumpT; arg.dopt->dumpt;
                      arg.label->dumpTN;
                      not rec.isUnitvalueObj -> b1;
                      arg.isUnitValueObj -> b2;
                      (ATd[]->ptn[]).isN2N -> b3;
                      'not rec.isUnitValobj:\t'-> dumpT;
                      b1 -> putboolean;  newline;
                      '(rec.ATd.OG.primNo = integer_prim):'
                        ->dumpT;
                      (rec.ATd.OG.primNo = integer_prim)
                        -> putboolean; newline;
                      '(ATd[]->ptn[]).isN2N:\t'->dumpT;
                      b3 -> putboolean; newline;
                      'arg.isUnitValueObj:' 
                        -> dumpT;
                      arg.isUnitValueObj 
                        -> putboolean;
                      newline;
                   #)
               if);
               
               (* a2: var Area.SquareMeter
                * A: 3 * a2    : '* a2'.unit = a2.unit = m
                * B: 3 m * 5 m : '* 5m'.unit = '5m'.unit = m
                *)
               (if (rec[] <> none)
                   and not rec.isUnitvalueObj
                   and (rec.ATd.OG.primNo = integer_prim)
                   and (ATd[]->ptn[]).isN2N
                   and arg.isUnitValueObj then
                   'ExpUnit:'->dumpT; expUnit[] -> dumpt;
                   argU[] -> dumpTN;
                   argU[] -> U[] 
               if);
            exit U[]
            #);
          getExpUnit:: 
            (* pattern:
             *    foo, bar(exp), @put e :at ix
             *    := exp
             *    + exp, - exp, * exp, / exp, ^exp
             * dataItem: X, rocketSpeed
             *)
            (# getBinArg: 
                 (#
                 do L:
                      (if args[] <> none then
                          args.scanArgs
                          (#
                          do current.getExpUnit -> U[];
                             (* current.getExpUnit may return #F or #integer
                              * and these should not be appended to recU
                              *)
                             leave L
                          #);
                      if)
                 #);
               filterNumeric:
                 (# op: @char
                 do getBinArg; 
                    (if false then
                        '***  for: ' -> puttext; dopt -> puttext;
                        ' got: ' -> puttext;
                        '  recU: ' -> puttext; recU[] -> puttext;
                        '  U: ' -> puttext; U[] -> putline;
                    if);
                    (if true
                     // '#F' -> recU.equal
                     // '#I' -> recU.equal then
                        (* return U *)
                     // '#F' -> U.equal
                     // '#I' -> U.equal then
                        recU[] -> U[] (* return recU *)
                     else
                        inner;
                        '(' -> recU.prepend; ')' -> recU.append;
                        op -> recU.put; '(' -> recU.put;
                        U[] -> recU.puttext; ')' -> recU.put;
                        recU[] -> U[]
                    if)
                 #);
               V: @integer; rec: ^Exp; recINV: ^ObjectInvocation
            do (if traceUnit then
                   '**** OI:getExpUnit: ' -> puttext; dopt -> putline;
               if);
               (if ATd[] <> none then
                   (if true
                    // (ATd.asDecl).isDataItem then
                       (if expUnit[] <> none then
                           expUnit.copy -> U[];
                       if);
                       (if (unit[] <> none) and
                           (unit.T[] <> none) and (unit.T.length > 0) then
                           'OI:unit:'->dumpT; unit.dopt->dumptN;
                           unit.T[] -> U[]
                       if)
                    // (ATd.asDecl).isPattern then
                       (* '**   ATd.isPattern: ' -> puttext;
                        * ATd.primNo -> putint; newline;
                        *)
                       (if recU[] = none then '' -> recU[] if);
                       (if (ATd.asDecl).primNo
                        // 109 (* + *)
                        // 110 (* - *) then
                           args.scanArgs(#do current.getExpUnit -> U[] #);
                           (* recU and U must be equal *)
                        // 112 (* * *)then
                           (* recU/U may be a numeric constant or dataItem *)
                           filterNumeric(#do '*'->op #)
                        // 121 (* / *) then
                           filterNumeric(#do '/' -> op #)
                           (* // '^' -- not a primitive *)
                        // vassign_prim //rassign_prim then
                           (* What is the purpose of the code below?
                            * Seemes redundant!
                            *)
                           (# dstBV,srcBV: ^BaseVector; T: ^UnitTree
                           do args.scanArgs(#do current.getExpUnit -> U[] #);
                              (if traceUnit then
                                  '**   assign: '->puttext; recU[] -> puttext;
                                  ' ' -> put; U[] -> putline;
                              if);
                              (if true 
                               // '#F' -> recU.equal then
                                  (if true
                                   // '#F' -> U.equal then
                                   // '#I' -> U.equal then
                                  if)
                                  (* incompete if no match above (or below) *)
                               // '#I' -> recU.equal then
                                  (if true
                                   // '#F' -> U.equal then
                                   // '#I' -> U.equal then
                                  if)
                               // recU.length = 0 then
                                  (* check what to do here! *)
                               else                                
                                  (if doCheckUnits then
                                      recU[] 
                                        -> parseUnit -> mkBaseVector -> dstBV[];
                                      U[] -> parseUnit -> T[] 
                                        -> mkBaseVector -> srcBV[];
                                      (if srcBV[] -> dstBV.equal then
                                          '**** equal:'->puttext; 
                                          recU[] -> puttext;
                                          ' ' -> put; U[] -> putline;
                                          (*true -> T.print -> putline;*)
                                       else
                                          '**** not equal:'->puttext; 
                                          U[] -> puttext;
                                          ' ' -> put; recU[] -> putline;
                                          dstBV.print;
                                          true -> T.print->putline;
                                          srcBV.print;
                              if)if)if)#)
                        else
                           (* Q or R.Q where Q = this(OI) and 
                            * Q: oneOf: foo, bar(exp), @put e :at ix
                            *)
                           (if traceUnit then
                               '**** OI:getExpUnit:sig: "' -> puttext;
                                ATd.sig.dopt -> puttext; '"' -> put;
                               (ATd.sig.dopt).length -> putint; newline;
                               dopt -> putline;
                            if);
                           (if '^' = (1->((ATd.asDecl).sig.dopt).inxGet) then
                               (if traceUnit then '**** got ^:' ->putline if);
                               args.scanArgs(#do current.getConstLiteral ->V #);
                               '(' -> recU.prepend; ')' -> recU.append;
                               '^' -> recU.put; '(' -> recU.put;
                               V -> recU.putint; ')' -> recU.put;
                               recU[] -> U[];
                               (*  '**** ^res: ' -> puttext; U[]->putline*)
                            else
                               (# ptn: ^Pattern; argU: ^Text; n: @integer;
                                  arg: ^ObjectGenerator
                               do (if unitIssue or traceUnit then
                                      '**** OI:GEU:ptn: '->puttext; 
                                      dopt -> putline;
                                      ATd.dopt -> putline;
                                      args.dopt -> puttext; newline;
                                  if);
                                  (if (ATd.asDecl -> ptn[]).hasGenericUnit then
                                      '$' -> U[]
                                   else
                                      expUnit[] -> U[]; 
                                  if);

                                  (if traceUnit then 
                                      '**   U:'->puttext; U[] -> putline 
                                  if);
                                  (if true then
                                      U[] -> isN2NwithUnitArg -> U[]
                                   else
                                  (* the code below must be cleaned up.
                                   * And we should probably use 
                                   * int2intWithUnit ...
                                   * Perhaps we can mark this as int2intUnit?
                                   *)
                                  args.scanArgs
                                  (#
                                  do n + 1 -> n; current[]->arg[];
                                     ''->current.getExpUnit -> argU[];
                                     (if unitIssue then
                                         '**   argU:' -> dumpT;
                                         argU[] -> dumpTN
                                     if)
                                  #);
                                  (* case foo(exp) where
                                   * foo(V: var float/int)->float/int: ...
                                   * and exp.unit = U, 
                                   * then U -> foo(exp).unit
                                   *)
                                  (if (n = 1) and unitIssue then
                                      '**** int2int?: '->dumpT;
                                      dopt -> dumpTN;
                                      ptn.dopt -> dumpTN;
                                      argU[]->dumpTN;
                                  if);
                                  this(ObjectInvocation)[] 
                                    -> getReceiver
                                    -> rec[];
                                  (if (unitIssue) and
                                      (arg[] <> none) and (rec[] <> none) then
                                      (# B1,B2,B3: @boolean
                                      do '\narg:'->dumpT; arg.dopt->dumpt;
                                         arg.label->dumpTN;
                                         not rec.isUnitvalueObj -> b1;
                                         arg.isUnitValueObj -> b2;
                                         (ATd[]->ptn[]).isN2N -> b3;
                                         'not rec.isUnitValobj:\t'-> dumpT;
                                         b1 -> putboolean;  newline;
                                         '(rec.ATd.OG.primNo = integer_prim):'
                                           ->dumpT;
                                         (rec.ATd.OG.primNo = integer_prim)
                                           -> putboolean; newline;
                                         '(ATd[]->ptn[]).isN2N:\t'->dumpT;
                                         b3 -> putboolean; newline;
                                         'arg.isUnitValueObj:' 
                                           -> dumpT;
                                         arg.isUnitValueObj 
                                           -> putboolean;
                                         newline;
                                      #)
                                  if);
                                  (* a2: var Area.SquareMeter
                                   * A: 3 * a2    : '* a2'.unit = a2.unit = m
                                   * B: 3 m * 5 m : '* 5m'.unit = '5m'.unit = m
                                   *)
                                  (if (rec[] <> none)
                                      and not rec.isUnitvalueObj
                                      and (rec.ATd.OG.primNo = integer_prim)
                                      and (ATd[]->ptn[]).isN2N
                                      and arg.isUnitValueObj then
                                      'ExpUnit:'->dumpT; expUnit[] -> dumpt;
                                      argU[] -> dumpTN;
                                      argU[] -> U[] 
                                  if);
                                  if);
                                  (if U[] = none then 
                                      (if (ATd.asDecl).OG.primNo 
                                       // stringget_prim 
                                       // indexedget_prim 
                                       // indexedPut_prim then
                                          '#I' -> U[]
                                       else
                                          (* can be <=, && or other binary
                                           * operators ...
                                           *)
                                          '#Q' -> U[] 
                                  if)if)
               #)if)if)if)if);               
               (if traceUnit then
                   '**** OI:GEU:end: ' -> puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          getConstLiteral:: 
            (# op: ^Text
            do (if trx or traceUnit then
                   '**** ObjectInvocation:getConstLiteral: ' -> puttext; 
                   dopt -> putline;
                   '**   Not implememnted' -> putline
               if); 
               
            #);   
          addConvFactor::
            (#
            do (if false then
                   '**** OI:addConvFactor: ' -> puttext; 
                   dopt -> puttext; ' '-> put;
                   CF -> putReal; newline;
               if);
               (if convFactor <> 0 then
                   '**** OI:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   CF -> convFactor; true -> done;
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #);

       #);
     BracketedExp::<
       (# getExpUnit::
            (#
            do recU[] -> IV.getExpUnit -> U[];
               (if (unit[] <> none) 
                   and (unit.T[] <> none) and (unit.T.length > 0) then
                   '**** BE: ' -> dumpT; U[] -> dumpT;
                   unit.T[] -> dumptN;
                   unit.T[] -> U[]
               if)
            #);
           getConstLiteral:: (# do IV.getConstLiteral -> value #)
       #);
     Name::< 
       (# getConstLiteral::
            (#
            do '**** Name:getConstLiteral: ' -> puttext; dopt -> putline;
               MaxInt -> value
            #)
       #);
     Const::< 
       (# isUnitValueObj::
            (#
            do (if unitIssue then
                   '**** Const:isUnitValueObj:'-> puttext; dopt -> puttext;
               if);
               (if (unit[] <> none) and (unit.T[] <> none) then
                   (if unitIssue then
                       ' true: ' -> dumpT;
                       unit.T[] -> putline;
                   if);
                   true -> value
                else
                   (if unitIssue then
                       ' false: ' -> dumpT;
                       newline
               if)if)
            #);
          getExpUnit::
            (#
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**** Const:semcheck: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '#I' -> U[]
               if)
            #);
          getConstLiteral:: (# do T.setPos; T.getInt -> value #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** Const:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** Const:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done -> convDone 
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #);
          convDone: @boolean;
          int2floatDone:: 
            (# 
            do convDone -> value; 
               cd.com(#do 'convDone:'->TT; convDone -> BB #)
            #);
       #);
     FloatConst::<
       (# getExpUnit::
            (# 
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if traceUnit then
                       '**** FloatConst:getExpUnit: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '#F' -> U[]
              if)
            #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** FloatConst:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** FloatConst:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done; 
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #)
       #);
     addToUnitTable::
       (#
       do unitProp[] -> unitTable.add
       #);
     BaseVector:
       (# theBase: [8] @integer;  (* [8] is Dimension, just technical*)
          noOfBaseUnits: @integer;
          convFactor: @Real;
          add:
            (# BV: ^BaseVector
            enter BV[]
            do (for i: noOfBaseUnits - 1 repeat 
                    theBase[i] + BV.theBase[i] -> theBase[i]
               for);
               BV.convFactor * convFactor -> convFactor
            #);
          minus:
            (# BV: ^BaseVector
            enter BV[]
            do (if false then
                   '**** BaseVector: left:' -> putline;
                   print;
                   '**   right: ' -> putline;
                   BV.print
               if);
               (for i: noOfBaseUnits - 1 repeat 
                    theBase[i] - BV.theBase[i] -> theBase[i]
               for)
            #);
          mult:
            (# C: @integer
            enter C
            do (for i: noOfBaseUnits - 1 repeat 
                    theBase[i] * C -> theBase[i]
               for)
            #);
          equal: BooleanValue
            (# BV: ^BaseVector;
               nonMatchingCV:< (# do inner #);
            enter BV[]
            do true -> value;
               (for i: noOfBaseUnits - 1 repeat 
                    (theBase[i] = BV.theBase[i]) and value -> value
               for);
               (if false and (BV.convFactor <> convFactor) then
                   '!!!! Conversion factors differ: ' -> putline;
                   'source: ' -> puttext; BV.print -> putline;
                   'destination: ' -> puttext; print -> putline;
                   nonMatchingCV
               if)
            #);
          rootN:
            (* In general we have a unit "u"^(left,right)
             * where left  = 1 and right is a positve integer
             * like "m*m"^(1/2), "m*m*m"^(1/3) or similar
             * 
             * all base units in the vector must be a multiply
             * of right or zero
             *)
            (# rootNerror:< 
                 (# M: ^text
                 enter M[]
                 do inner
                 #);
               numerator,denumerator: @integer
            enter(numerator,denumerator)
            do (if true then
                   '**** baseVector:rootN:'->puttext;
                   numerator -> putint; ' ' -> put; denumerator -> putint;
                   newline;
               if);
               (if numerator <> 1 then
                   'numerator is not 1 (one)' -> rootNerror
               if);
               (for i: noOfBaseUnits - 1 repeat
                    (if (theBase[i] mod denumerator) = 0 then
                        theBase[i] div denumerator -> theBase[i]
                     else
                        'value of a base unit is not a multiply of the denumerator'
                        -> rootNerror
               if)for);
               (*print*)
            #);
          print:
            (# T: @text
            do 'Cnv[' -> T.puttext; convFactor -> T.putReal; ']' -> T.put;
               (for i: noOfBaseUnits - 1 repeat
                    (if i 
                     // TimeInx then 'Time[' -> T.puttext
                     // LengthInx then 'Lgth[' -> T.puttext
                     // MassInx then 'Mass[' -> T.puttext
                     // ElectInx then 'Elec[' -> T.puttext
                     // TempInx then 'Temp[' -> T.puttext
                     // SubstanceInx then 'Subs[' -> T.puttext
                     // LuminousInx then 'Lumn[' -> T.puttext
                     else
                        'Inx = ' -> T.puttext;  i -> T.putint; ':' -> T.put
                    if);
                    theBase[i] -> T.putint; ']' -> T.put
               for);
               T.newline
            exit T[]
            #)
       do 8 -> noOfBaseUnits
       exit this(Basevector)[]
       #);     
     TimeInx: (# exit 1 #);
     LengthInx: (# exit 2 #);
     MassInx: (# exit 3 #);
     ElectInx: (#exit 4 #);
     TempInx: (#exit 5 #);
     SubstanceInx: (#exit 6 #);
     LuminousInx: (#exit 7 #);
     unitTable: @
       (# unitElm:
            (# dim: ^Decl; 
               isBaseDim: @boolean;
               unit: ^Pattern;
               isBaseUnit: @boolean;
               US: [5] ^Text; UStop: @integer;
               convFactor: @real;
               prop: ^NewProperty;
               baseInx: @integer; (* if base unit, index into baseVector *)
               decodeProp:
                 (# n: @integer; dimN: ^text; UT: ^UnitTree; BV: ^BaseVector
                 do prop.args.scanSons
                    (# INV: ^Invocation; 
                    do current[] -> INV[];
                       INV.scanSons
                       (# C: ^lexem
                       do (*current.dopt -> puttext; ',' -> put;*)
                          current[] -> C[];
                          (if true 
                           // current.isStringLiteral then
                              UStop + 1 -> UStop;;
                              C.T.copy -> US[UStop][];
                           // current.isConstLiteral then
                              n + 1 -> n;
                              C.T.setPos; C.T.getReal -> convFactor
                    if)#)#);
                    (if traceUE then
                        UStop -> putint; ' ' -> put; n -> putint;
                    if);
                    (* a base dimension has a form like
                     *    %unit "m", i.e only one unit
                     * a derived dimension has a form like
                     *    %unit "MpS", "m*s^-1", "m/s", 1
                     *        i.e. also a defintion in the form of other units 
                     *        and a conversitaion factor of 1 (one)
                     *)
                    UStop = 1 -> isBaseDim;
                    (if traceUE and isBaseDim then
                        ' base dimension '->puttext if);
                    (if isBaseDim then
                        (if convFactor = 0 then
                            true -> isBaseUnit;
                            1.0 -> convFactor
                         else
                            (* non base unit of base dim *)
                        if)
                     else 
                        (if convFactor = 1 then
                              (* for derived dimensions, we must set a 
                               * conversion factor of 1 (one) for the base unit
                               *)
                              true -> isBaseUnit
                         else
                            (* best to compute here, but some of the dimensions
                             * and units have not yet been added to the table; 
                             * a seperate scan is necessary
                             * Now we just compute it when needed below
                             '**** Derived dim: '
                             'compute conv factor of non base unit: ' 
                             -> puttext; US[2][] -> putline;
                             prop.dopt -> putline;
                             US[2][] -> parseUnit -> UT[]; UT.print->putline;
                             UT[] -> mkBaseVector -> BV[];
                             BV.print
                             *)
                    if)if);
                    dim.sig.dopt -> dimN[];
                    (if traceUE then 
                        ' baseDim:'->puttext; dimN[] -> putline if);
                    (if isBaseDim then
                        (if true 
                         // 'Dimension' -> dimN.equalNCS 
                         // 'Unit' -> dimN.equalNCS then
                            8 -> baseInx
                         // 'Time' -> dimN.equalNCS then
                            1 -> baseInx
                         // 'length' -> dimN.equalNCS then
                            2 -> baseInx
                         // 'Mass' -> dimN.equalNCS then
                            3 -> baseInx
                         // 'ElectricCurrent' -> dimN.equalNCS then
                            4 -> baseInx                         
                         // 'ThermodynamicTemperature' -> dimN.equalNCS then
                            5 -> baseInx                         
                         // 'AmountOfSubstance' -> dimN.equalNCS then
                            6 -> baseInx
                         // 'LuminousImtenmsity' -> dimN.equalNCS then
                            7 -> baseInx
                         else
                            '!!!! OBS! no matching base unit: ' -> puttext;
                            dimN[] -> puthead;
                            prop.dopt -> putline;
                    if)if)
                 #);

               print:
                 (#
                 do (if isBaseDim then
                        'Base Dimension: "' -> puttext
                     else
                        'Derived Dimension: "' -> puttext; 
                    if);
                    dim.sig.dopt -> puttext;
                    (if (convFactor = 1.0) 
                        or isBaseDim and (convFactor = 0.0) then
                        '" base unit: "' -> puttext;
                         unit.sig.dopt -> puttext;
                        '" ' -> puttext;
                     else
                        '" not base unit: ' -> puttext;
                    if);
                    (for i: UStop repeat 
                         '"'->put; US[i][] -> puttext; '"'-> put; ' ' -> put 
                    for);
                    (if convFactor <> 0 then 
                        'convFac: ' -> puttext;
                        convFactor -> putReal
                    if);
                    (if false then
                        ' ' -> put; prop.dopt -> putline
                    if);
                    newline;
                 #);
              
            enter(dim[],unit[],prop[])
            exit this(unitElm)[]
            #);
     
          add:
            (# prop: ^NewProperty; P: ^Pattern
            enter prop[]
            do (if traceUE then
                   '**** prop: ' -> puttext; prop.dopt -> puttext;
                   ' in:sig: ' -> puttext;
                   (prop.enclosingObjectGenerator).sig.dopt ->puttext;
                   ' arg1: ' -> puttext; 
                   prop.getSArg1 -> puttext;
                   newline;
               if);
               (if '$' -> (prop.getSarg1).equal then
                   leave add
               if);
               (prop.enclosingObjectGenerator).enclosingObjectGenerator 
                 -> N[];
               N.father[] -> DI[];   
               (if traceUE then 
                   DI.sig.dopt ->putline;
               if);
               (prop.enclosingObjectGenerator).father[] -> P[]; 
               (if (top + 1 -> top) > DU.range then DU.range -> DU.extend if);
               (DI[],P[],prop[]) -> unitElm -> DU[top][];
               DU[top].decodeProp
            #);
          find:
            (# u: ^text; current: ^unitElm
            enter U[]
            do L:
                 scan
                 (# 
                 do (if U[] -> current.US[1].equalNCS then
                        (if traceUE then
                            '**   found: "' -> puttext;
                            U[] -> puttext; '" -> ' -> puttext;
                            current.print;
                        if);
                        current[] -> this(find).current[];
                        inner find;
                        leave L
                    if)
                 #)
            #);
          findInAll:
            (# U: ^text; current: ^unitElm; U1: @text
            enter U[]
            do U.scanAll(#do (if ch // '(' // ')' then else ch -> U1.put if)#);
               U1[] -> U[];
               L:
                 scan
                 (# 
                 do (for i: current.UStop  repeat
                         (if U[] -> current.US[i].equalNCS then
                             (if traceUE then
                                 '**   findInAll:found: "' -> puttext;
                                 U[] -> puttext; '" -> ' -> puttext;
                                 current.print;
                             if);
                             current[] -> this(findInAll).current[];
                             inner findInAll;
                             leave L
                    if)for)
                 #)
            #);            
          findU: find
            (# isBase: @boolean; CF: @real
            do current.isBaseDim -> isBase;
               current.convFactor -> CF
            exit(isBase,CF)
            #);
          findAndCheck:
            (* Lookup lU and rU to check if they belong to the same
             * dimension. This could be meter and centimeter. 
             * If same dimension, true is returned together with the conversion
             * factors to the base unit.
             * For base unit, convFactor = 0; should probably be 1
             * Currently only the unit names of lU and rU are searched, thus 
             * "m2" and "m*m" will not be matched as in the same dimension,
             * even if they are the same unit. 
             * Perhaps this should be changed!?
             *)
            (# lU,rU: ^text; sameDim: @boolean;
               lDim,rDim: ^Decl;
               lCF,rCF: @real
            enter(lU[],rU[])
            do (if traceUE then
                   '**** unitTable.findandCheck:lU: "'->puttext; lU[]->puttext;
                   '" rU: "' -> puttext; rU[] -> puttext; '"' -> putline
               if);
               lU[] -> findInAll
               (#
               do current.dim[] -> lDim[];
                  current.convFactor -> lCF
               #);
               rU[] -> findInAll
               (#
               do current.dim[] -> rDim[];
                  current.convFactor -> rCF
               #);
               lDim[] = rDim[] -> sameDim;
               (if traceUE then
                   '**   sameDim: ' -> puttext; sameDim -> putBoolean;
                   newline
               if)
            exit(sameDim,lCF,rCF)
            #);
          checkIfSame:
            (# lU,rU: ^text; sameDim: @boolean;
               lDim,rDim: ^Decl;
               lCF,rCF: @real
            enter(lU[],rU[])
            do (if traceUE then
                   '**** unitTable:checkIfSame:lU: "' -> puttext; lU[]->puttext;
                   '" rU: "' -> puttext; rU[] -> puttext; '"' -> putline;
               if);
               lU[] -> FindInAll
               (#
               do current.dim[] -> lDim[]
               #);
               rU[] -> FindInAll
               (#
               do current.dim[] -> rDim[]
               #); 
               lDim[] = rDim[] -> sameDim;
               (if traceUE then
                   '**   checkIfSame:sameDim: ' -> puttext; sameDim -> putBoolean;
                   newline
               if)
            exit sameDim
            #);
          findUOG: find
            (# uOG: ^ObjectGenerator
            do current.unit.OG[] -> uOG[];
            exit uOG[]
            #);
           findUOGall: findInAll
            (# uOG: ^ObjectGenerator
            do current.unit.OG[] -> uOG[];
            exit uOG[]
            #);
          scan:
            (# current: ^unitElm
            do
               (for i: top repeat
                    DU[i][] -> current[];
                    inner
               for)
            #);
          print:
            (#
            do '**** UnitTable: ' -> putline;
               (for i: top repeat
                    DU[i].print;
               for)
            #);
          DU: [7] ^unitElm; top: @integer;
          N: ^ObjectGenerator; DI: ^Decl;
          L: ^unitElm
       #);
     mkBaseVector:
       (# getConstLiteral:
            (# op: ^text; V: @integer; isNeg: @boolean
            enter op[]
            do (if traceUE then 
                   '**** getConstLiteral: ' -> puttext; op[] ->puttext if);
               (if (1 -> op.inxGet) = '-' then
                   true -> isNeg; 
                   2 -> op.setpos;
               if);
               op[] -> readNumber -> V; (* readNumber makes op.setPos!
                                         * So setPos above, is superflous!
                                         **)
            exit V
            #);
          T: ^UnitTree; BVl,BVr: ^baseVector
       enter T[]
       do (if traceUE then 
              '**** mkBaseVector: ' -> puttext; true -> T.print -> putline;
          if);
          (if T.token
           // mult then
              T.left[] -> mkBaseVector -> BVl[];
              T.right[] -> mkBaseVector -> BVr[];
              BVr[] -> BVl.add
           // divv then
              T.left[] -> mkBaseVector -> BVl[];
              T.right[] -> mkBaseVector -> BVr[];
              BVr[] -> BVl.minus
           // expT then 
              T.left[] -> mkBaseVector -> BVl[];
              (if traceUE then
                  '**   mkBaseVector:expT: ' -> puttext; T.print ->putline;
                  BVl.print  -> puttext;
              if);
              (if true then
                  (if traceUE then
                      T.print -> putline;
                      T.right.print->putline;
                      T.right.op[]->putline;
                  if);
                  (if '/' -> T.right.op.equal then
                      (* we assume T.right = (1/2) but should be checked *)
                      (T.right.left.op[]->getConstLiteral
                      ,T.right.right.op[] -> getConstLiteral)
                        -> BVl.rootN
                      (# rootnError::
                           (#
                           do '\n\n!!! WARNING:'-> puttext;
                              M[] -> putline;
                              '    in: '  -> puttext;
                              T.print -> putline;
                              '\n! This message must be improved!'-> putline
                           #)#)
                   else
                      T.right.op[] -> getConstLiteral -> BVl.mult
                  if);
               else
                  T.right.op[] -> readNumber -> BVl.mult
              if)
           // idf then
              (if traceUE then
                  '**   MBK:idf: '->puttext; T.op[] -> putline; 
              if);
              T.op[] -> unitTable.find
              (# theDim: ^text; UT: ^UnitTree; BV: ^BaseVector
              do current.dim.sig.dopt -> theDim[];
                 (if traceUE then
                     '**   MBK:idf:thedim: ' -> puttext; theDim[] ->putline
                 if);
                 (if current.isBaseDim then
                     BaseVector -> BVl[];
                     1 -> BVl.theBase[current.baseInx];
                     current.convFactor -> BVL.convFactor;
                     (if (current.convFactor = 0) 
                         and not current.isBaseUnit then
                         '**** convFactor is zero:'->putline;
                         current.print
                     if);
                  else (* Derived dimension *)
                     (if traceUE then
                         '**** Derived dimension: ' -> puttext; 
                         theDim[] -> puttext;
                         ' ' -> put; current.US[2][] -> putline;
                         (*current.print*)
                     if);
                     current.US[2][] 
                       -> parseUnit 
                       -> mkBaseVector -> BVl[];
                     (if current.isBaseUnit then
                         (if current.convFactor <> 1.0 then
                             '**** derived base unit wrong convFactor:'
                               ->puttext;
                             current.convFactor -> putreal; newline;
                             current.print
                         if);
                         current.convFactor -> BVL.convFactor;
                      else
                         current.US[2][] -> parseUnit -> UT[]; 
                         UT[] -> mkBaseVector -> BV[];
                         BV.convFactor -> BVl.convFactor;
                         (if false then
                             '**** compute convFactor from: ' -> puttext;
                             current.US[2][] -> putline;
                             current.print;
                             UT.print->putline;
                             BV.print -> putline;
                         if)
                     if);
                 if);
              #);
              (if BVl[] = none then 
                  '!!!! Unit not found: ' -> puttext; T.print-> putline;
                  BaseVector -> BVl[];
              if);
              (if traceUE then 
                  'MBK:idf:final: ' -> putline; BVL.print -> puttext if)
           // number then
              'MBK:number: '->puttext;
              T.op[] -> putline;
              BaseVector -> BVl[]
           // var then 
              BaseVector -> BVl[]
           else
              '*** token not handled: '->puttext; T.token ->putint; newline
          if);
          (if traceUE then
              '**** mkBaseVector:res: ' -> putline; BVL.print -> puttext
          if)
       exit BVl[]
       #);     
  do (*unitTable.print;*)
     inner
  #)
