ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'; 
INCLUDE 'qunitparser' 
---lib:attributes--- 
UnitHandler: checker
  (# Pattern::<
       (# getUnit:: 
            (# 
            do (if trx or (OG.primNo = vAssign_prim) or traceUnit then
                   '**** pattern:getUnit: ' -> putline;
                   dopt -> puthead
               if);
               OG.getUnit -> U[]
            #);
          computeUnit::
            (#
            do (if true then
                   '**** Pattern:computeUnit. ' -> puttext; sig.dopt -> putline
               if);
               getUnit -> U[]               
            #);
       #);
     DataItem::<
       (# getUnit::
            (#
            do (if traceUnit then
                   '**** DataItem:getUnit: ' -> puttext; dopt -> putline
               if);
               (if OG.IS.isEmpty then
                   (OG.super.last).getUnit -> U[]
                else
                   (*'!!!! OBS! DataItem:getUnit:singular:'-> puttext; 
                   dopt -> putline*)
               if)
            #);
       #);
     ObjectCall::<
       (# getExpUnit:: 
            (# 
            do '**** OC:getExpUnit: ' -> puttext; dopt -> putline;
               super.getExpUnit -> U[];
               (if true then
                   '**** ObjectCall:GEU: '->puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectCall:isUnitValueObj: ' -> puttext; doPT -> puthead
               if);
               (if super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               if);
               (if traceUnit then
                   '**** ObjectCall:isUnitValueObj= ' -> puttext; 
                   value -> putboolean; newline
               if);
            #);
          getUnit:: 
            (# ptn: ^Pattern 
            do (if traceUnit then
                   '**** ObjectCall:getUnit: ' -> puttext; dopt -> puthead
               if);               
               (* Ex: "k1 * s" -> "kg * % s" *)
               super.getUnit -> U[]
            #);
          getUnitPropShort::
            (# ptn: ^Pattern; 
            do (if traceUnit then
                   '**** objectCall:getUnitPropShort: ' -> puttext; dopt ->puthead
               if);
               (super.last).ATd[] -> ptn[];
               propNo -> ptn.OG.getUnitPropShort -> U[];
            #);          
          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU: ^text;
            do (if traceUnit then
                   '**** ObjectCall:computeUnit: ' -> puttext; dopt -> puthead;
                   '**   super.last.label: ' -> puttext; (super.last).label -> putline;
               if);
               (super.last).computeUnit -> U[];
            #);
          getConstLiteral:: 
            (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
            do (if traceUnit then
                   '**** ObjectCall:getConstLiteral: ' -> puttext; dopt -> putline; 
               if);
               super.getConstLiteral -> value
            #);
       #);
     ObjectGenerator::<
       (# getExpUnit:: 
            (#
            do  '**** OG:getExpUnit: ' -> puttext; dopt -> putline;
               (* We may have an OG where super is a dataItem as in
                *    distToAlpha / rocketSpeed  where rocketSpeed 
                * is an OG with super rocketSpeed: var Velocity.Mass
                * We should fix the parser here!
                *)
               (if IS.isEmpty (*and super.ATd.isPattern*) then
                   super.getExpUnit -> U[]
               if);
               (if true then
                   '**** OG:GEU: '->puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          getUnitX::
            (# ptn: ^Pattern
            do (if false or traceUnit then
                   '**** ObjectGenerator:getUnitX: ' -> puttext; 
                   doPT -> puthead
               if);
               (* see comment above *)
               (if IS.isEmpty and super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.getUnitX -> U[]
               else
                   (if IS.newBasicProp.unit[] <> none then
                       IS.newBasicProp.unit.args.scanSons
                       (#
                       do current.scanSons
                          (# S: ^StringObj
                          do (if current.isStringLiteral then
                                 (current[] -> S[]).T[] -> U[];
                             if)
                          #)
                       #)
                    else
                       (if primNo                            
                        // float_prim then '#Float' -> U[]
                        // integer_prim then '#Integer' -> U[]
                       if)
               if)if)
               #);
          isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectGenerator:isUnitValueObj: ' -> puttext; 
                   doPT -> puthead
               if);
               (if IS.isEmpty and super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               else
                   IS.newBasicProp.unit[] <> none -> value;
               if);
               (*
               (if not (IS.newBasicProp.unit[] <> none -> value) then
                   (if super.ATd[] <> none then
                       (if super.ATd.isPattern then
                           (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
                if)if)if)           *)
               (if traceUnit then
                   '**** ObjectGenerator:isUnitValueObj=' -> puttext; 
                   value -> putboolean; newline;
                   (if value then doPT -> puthead if)
               if);
            #);
          getUnit::
            (# D: ^Decl
            do (if trx or traceUnit then 
                   '**** objectGenerator:getUnit:' -> putline; dopt->puthead if);
               (if (1 -> getUnitPropShort -> U[]) = none then
                   (if (super.ATd[] <> none) then
                       (if trx or traceUnit then
                           '**   OG:super.ATd.getUnit: ' -> putline;
                       if);
                       super.ATd.getUnit -> U[]
                   if);
                   (if U[] = none then 
                       getReturnDecl -> D[];
                       (if D[] <> none then
                           1  -> D.OG.getUnitPropShort -> U[]
                        else
                           (if false then
                               (if trx or traceUnit then 
                                   '**   OG:no associated unit:use:#Float' 
                                     -> putline
                               if);                       
                               '#Float' -> U[]
                           if)
                       if)
                   if)
               if);
               (if traceUnit then
                   '**   OG:getUnit:GOT: ' -> puttext; U[] -> putline;
               if)
            #);  
         getUnitPropShort::
            (# UN: ^NewProperty; E: ^Exp; OI: ^ObjectInvocation
            do (if trx or traceUnit then 
                   '**** objectGenerator:getUnitPropShort:' -> putline; 
                   dopt -> puthead 
               if);
               (if IS.isEmpty then
                   super.scanSons
                   (#
                   do current[] -> E[]
                   #);
                   propNo -> E.ATd.OG.getUnitPropShort -> U[]
                else
               (if (IS.newBasicProp.unit[]-> UN[]) <> none then
                   (* unit is defined for this OG*)
                   L:
                     UN.args.scanSons
                     (# i: @integer
                     do i + 1 -> i;
                        current.scanSons
                        (# S: ^StringObj
                        do (if current.isStringLiteral then
                               (current[] -> S[]).T[] -> U[];
                               (if propNo = i then leave L if);
                           if);
                     #)#)
                else
                   (if IS.newBasicProp.primNo 
                    // float_prim then
                       '#Float' -> U[]
                    // integer_prim then
                       '#Integer' -> U[]
                   if)
               if)
            if)#);          
       #);
     invocation::<
       (* inv ::= rec msg
        * msg ::= unary
        *      |  binary
        *      |  functional
        *      |  keyword
        * binary ::=  +, -, *, /, ^, ...
        * Ex
        *  A ^ (0 - 1)
        * rec.getOp -> op
        * msg.getUnit -> U
        *)
       (# defUnit::
            (# emitUnits:
                 (# i: @integer; E: ^Exp; U: ^text
                 enter(i,E[],U[])
                 do (U[] <> none) or hasUnits -> hasUnits;
                    '**   INV::i='->T.puttext; i -> T.putint;
                    ' ' ->T.put; E.dopt -> T.puttext;
                    ' unit:'->T.puttext; U[] -> T.putline;
                 #);
               T: @text; hasUnits: @boolean; U: ^text
            do (if true then
                   '**** INV:defUnit: '-> puttext; dopt -> putline;
                   '' -> getExpUnit -> U[];
                   (if U[] <> none then
                       '**** INV:defUnit:unit: '->puttext; dopt -> puttext;
                       ' unit: ' -> puttext; U[] -> putline
                   if)
                else
                   '**** INV:units:OF:'->T.puttext; dopt -> T.putline;
                   (if ('t := distToAlpha / rocketSpeed' -> (doPT).equalNCS) then
                       doPP ->putline
                   if);
                   scanSons
                   (# i: @integer; E: ^Exp
                   do i + 1 -> i;
                      (i,(current[]->E[]),E.getExpUnit) -> emitUnits
                   #);
                   (if hasUnits then T[] -> putline if);
               if);
               true -> done
            #);
          getExpUnit::
            (#
            do '**** INV:getExpUnit: ' -> puttext; dopt -> putline;
               (if recU[] = none then '' -> recU[] if);
               recU[] -> U[];
               scanSons
               (#
               do U[] -> current.getExpUnit -> U[]
               #);
               '**** INV:GEU: ' -> puttext; dopt -> puttext;
               ' unit: ' -> puttext; U[] -> putline
            #);
          getUnit::
            (#
            do (if traceUnit then 
                   '**** Invocation:getUnit: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               computeUnit -> U[]
            #);

          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU,msgU: ^text;
               isBase,sameDim: @boolean; lCF,rCF: @real
            do (if trx or traceUnit then
                   '**** Invocation:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               scanSons
               (#  
               do i + 1 -> i; 
                  (if i 
                   // 1 then current[] -> rec[];
                   // 2 then current[] -> msg[]
                  if);
               #);
               (if i = 2 then
                   (* perhaps a binary method *)
                   rec.computeUnit -> recU[] -> U[]; (* "kg" *)
                   (if trx or traceUnit then
                       '**   Invocation:rec:unit: ' -> puttext; U[] -> putline;
                   if);
                   (if U[] = none then
                       msg.computeUnit -> U[]; (* "*s", U = "kg*s" *)
                       (if trx or traceUnit then
                           '**** Inv:getUnit:U none ' -> puttext; 
                           dopt -> putline;
                           U[] -> putline
                       if)
                    else
                       (if (1 -> U.inxGet) = '#' then
                           leave computeUnit 
                       if);
                       msg.computeUnit -> msgU[];
                       (if trx or traceUnit then
                           '**   msgU: ' -> puttext; msgU[] -> putline
                       if);
                       (if msgU[] <> none then
                           (if (1 -> msgU.inxGet) = '#' then
                               leave computeUnit
                            else
                               (if (1 -> msgU.inxGet) 
                                // '-' // '+' then
                                   (if traceUnit then
                                       '**** U,msgU: ' -> puttext; 
                                       U[] -> puttext; ',' -> put; 
                                       msgU[] -> puttext; ':' -> put; 
                                       msgU.length -> putint;
                                       newline;
                                   if);
                                   (if msgU.length = 1 then
                                       (* unary minus as in X^-1 *)
                                       leave computeUnit
                                   if);
                                   (2,msgU.length)->msgU.sub -> msgU[];
                                   (if not (msgU[] -> U.equalNCS) then
                                       (* the code below needs to be 
                                        * cleaned up and completed
                                        * Must check if one of U and msgU
                                        * is a base unit and then convert
                                        * the other.
                                        * If none is a base unit then
                                        * we need conversion factor for both
                                        * AND! We must check if both are
                                        * in the same dimension
                                        *)
                                       (if false then
                                           '\n**** Different units in addition: '
                                             -> puttext;
                                           U[] -> puttext;  ',' -> put;
                                           msgU[] -> putline; 
                                           dopt -> putline;
                                           newline;
                                       if);
                                       (U[],msgU[])
                                         -> unitTable.findAndCheck
                                         -> (sameDim,lCF,rCF);
                                       (if (lCF = 0) and (rCF <> 0) then
                                           msg.scanSons
                                           (# i: @integer
                                           do i + 1 -> i;
                                              (if i = 2 then
                                                  (if false then
                                                      current.doPT -> puttext; 
                                                      ':'->put;
                                                      current.label -> puttext; 
                                                      ',' -> put;
                                                  if);
                                                  current.scanSons
                                                  (#
                                                  do (if false then
                                                         current.dopt -> puttext;
                                                         ':'->put;
                                                         current.label -> puttext; 
                                                     if)
                                                  #);
                                                  '**** addConvFactor:R: ' -> puttext;
                                                  current.label -> puttext;
                                                  ' ' -> put;
                                                  current.dopt -> puttext;
                                                  ' ' -> put; rCF -> putreal;
                                                  newline;
                                                  rCF -> current.addConvFactor
                                              if)
                                           #);
                                           (if false then
                                               '  rConvF: ' -> puttext;
                                               rCF -> putReal; newline;
                                           if)
                                        else
                                           '**** addConvFactor:L: ' -> puttext;
                                           rec.label -> puttext; ' ' -> put;
                                           rec.dopt -> puttext;
                                           ' ' -> put; lCF -> putreal;
                                           newline;
                                           lCF -> rec.addConvFactor;
                                           msgU[] -> U[];
                                           (if false then
                                               '  lConvF: ' -> puttext;
                                               lCF -> putReal; newline;
                                           if)
                                       if)
                                   if)
                                else
                                   msgU[] -> (U.copy).append -> U[]; (* "*s", U = "kg*s" *)
                           if)if)
                        else
                           msg.computeUnit -> (U.copy).append -> U[]; (* "*s", U = "kg*s" *)
                   if)if);
                   (if traceUnit then
                       '**   Invocation:isBinary:rec: ' -> puttext; rec.dopt -> puttext;
                       ' unit: "' -> puttext; recU[] -> puttext;
                       '" msgU: "' -> puttext; U[] -> puttext; 
                       '" msg: ' -> puttext; msg.doPT -> puttext;
                       ' args: ' -> puttext; msg.args.dopt -> putline
                   if)
                else 
                   (* pehaps a const literal ? *)
                   rec.getUnit -> U[];
               if);
            #);
          getConstLiteral:: 
             (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
             do (if traceUnit then
                    '**** Invocation:getConstLiteral: ' -> puttext; dopt -> putline;
                if);
                scanSons
                (#  
                do i + 1 -> i;
                   (if i 
                    // 1 then current[] -> rec[] 
                    // 2 then current[] -> msg[] 
                   if);
                #);
                MaxInt -> value;
                (if i = 2 then
                    (if traceUnit then
                        '**   perhaps a binary method?' -> putline;
                    if);
                    (if msg.isObjectInvocation then
                        (msg[]->OI[]).type.isOp -> op[];
                        (if traceUnit then
                            '**   op: ' -> puttext; op[] -> putline;
                        if);
                        (if '-' -> op.equal then
                            (if traceUnit then '*** got -\n' -> puttext; if);
                            rec.getConstLiteral -> v;
                            OI.args.scanArgs(#do current.getConstLiteral -> u #);
                            (if traceUnit then
                                v -> putint; ' ' -> put; u -> putint; newline;
                            if);
                            v - u -> value
                        if)
                    if)
                 else (* perhaps (0 - 1) *)
                    rec.getConstLiteral -> value
                if)
             #);
       #);
     ObjectInvocation::<
       (# getExpUnit:: 
            (* pattern:
             *    foo, bar(exp), @put e :at ix
             *    := exp
             *    + exp, - exp, * exp, / exp, ^exp
             * dataItem: X, rocketSpeed
             *)
            (# addBinArg: 
                 (#
                 do L:
                      (if args[] <> none then
                          args.scanArgs
                          (#
                          do current.getExpUnit -> recU.puttext;
                             leave L
                          #);
                      if)
                 #)
            do '**** OI:getExpUnit: ' -> puttext; dopt -> putline;
               (if ATd[] <> none then
                   (if true
                    // ATd.isDataItem then
                       '**   ATd.isDataitem: ' -> puttext; expUnit[] ->putline;
                       (if expUnit[] <> none then
                           expUnit.copy -> U[];
                       if)
                    // ATd.isPattern then
                       '**   ATd.isPattern: ' -> puttext;
                       ATd.primNo -> putint; newline;
                       (if recU[] = none then '' -> recU[] if);
                       (if ATd.primNo
                        // 109 (* + *)
                        // 110 (* - *) then
                           args.scanArgs(#do current.getExpUnit -> U[] #);
                           (* recU and U must be equal *)
                        // 112 then
                           (* recU/U may be a numeric constant or dataItem *)
                           
                           '*'->recU.put; addBinArg; recU[] -> U[]
                           (* // '^' -- not a primitive *)
                        // 121 then
                           '/' -> recU.put; addBinArg; recU[] -> U[]
                        // vassign_prim //rassign_prim then
                           (# dstBV,srcBV: ^BaseVector; T: ^UnitTree
                           do
                              args.scanArgs(#do current.getExpUnit -> U[] #);
                              '**   assign: '->puttext; recU[] -> puttext;
                              ' ' -> put; U[] -> putline;
                              (if true 
                               // '#Float' -> recU.equal then
                                  (if true
                                   // '#Float' -> U.equal then
                                   // '#Integer' -> U.equal then
                                  if)
                                  (* incompete if no match above (or below) *)
                               // '#Integer' -> recU.equal then
                                  (if true
                                   // '#Float' -> U.equal then
                                   // '#Integer' -> U.equal then
                                  if)
                               else
                                  recU[] 
                                    -> parseUnit -> mkBaseVector -> dstBV[];
                                  U[] -> parseUnit -> T[] 
                                    -> mkBaseVector -> srcBV[];
                                  (if srcBV[] -> dstBV.equal then
                                      '**** equal:'->puttext; recU[] -> puttext;
                                      ' ' -> put; U[] -> putline;
                                      (*true -> T.print -> putline;*)
                                   else
                                      '**** not equal:'->puttext; 
                                      U[] -> puttext;
                                      ' ' -> put; recU[] -> putline;
                                      dstBV.print;
                                      true -> T.print->putline;
                                      srcBV.print;
                              if)if)
                           #)
                        else
                           (*'###'->U[]; addBinArg;*)
                           expUnit[] -> U[];
                           args.scanArgs(#do '' -> current.getExpUnit #);
                           (if U[] = none then 'Q' -> U[] if)
                           
                       if)
                   if);
               if);  
               (if false then
                   expUnit[] -> U[];
                   L:
                     (if args[] <> none then
                     args.scanArgs
                         (# T: ^Text
                         do current.getExpUnit -> T[];
                            '**   arg: ' -> puttext; current.dopt -> puttext;
                            ' unit: ' -> puttext; T[] -> putline;
                            (if T[] <> none then
                                (if U[] = none then '#U' -> U[] if);
                                '[' -> U.put; T[] -> U.puttext; ']'->U.put;
                                leave L
               if)#)if);if);
               '**** OI:GEU: ' -> puttext; dopt -> puttext;
               ' unit: ' -> puttext; U[] -> putline
            #);
          getUnit::
            (# argU,Ux: ^text;  i: @integer; arg: ^ObjectSpecification
            do (if traceUnit then 
                   '**** ObjectInvocation:getUnit: ' -> puttext; dopt->putline;
               if);
               ATd.getUnit -> U[];
               (if type## <> Binary## then
                   (if false then
                       '**   OI:getUnit:not:binary:'->puttext; U[]->putline;
                   if);
                   leave getUnit
                else
                   (if false then
                       '**   OI:getUnit:binary:'->puttext; U[]->putline 
               if)if);
               (if false then
                   (*type.isOp -> Ux[]; -- will loop *)
                   (if Ux[] = none then
                       (* perhap some func call foo(e) - unit is U *)
                       leave getUnit
                    else
                       '**** ObjectInvocation:getUnit:binary???? ' -> puttext; 
                       dopt -> puthead;
               if)if);
               (if traceUnit then
                   '**   OI:ATd.getUnit: ' -> puttext; U[] -> putline
               if);
               (if (U[] <> none) and (args[] <> none) then
                   (if traceUnit then
                       '**   getUnit:OI:binary: ' -> puttext; dopt -> puttext;
                       ' args: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then
                       arg.getUnit -> argU[];
                       (if traceUnit then
                           '**   OI:getUnit:argU: ' -> puttext; argU[] -> putline
                       if);
                       (if toFix then
                           '\n!!!! ObjectInvocation:getUnit: ' -> putline;
                           '     We must reconsider the combinations'
                           ' of #Integer and #Float' -> putline
                       if);
                       (if true 
                        // ('#Integer' -> argU.equal) 
                           and ('#Integer' -> U.equal) then
                        // ('#Float' -> argU.equal) 
                           and ('#Float' -> U.equal) then
                        else                           
                           argU[] -> (U.copy).append -> U[]
                   if)if)
               if);
               (if traceUnit then
                   '**   OI:getUnit:finalU: ' -> puttext; U[] -> puttext;
                   ' OF: '->puttext; doPT -> puthead
               if);               
            #);
          computeUnit::
            (# argU: ^text;  i,V: @integer; arg: ^ObjectSpecification
            do (if trx or traceUnit then
                   '**** ObjectInvocation:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               type.isOp -> U[]; (* U = '^', '*', '-', '+' *)
               (if trx or traceUnit then
                   '**   OI:computeUnit:type.op: "' -> puttext; 
                   U[] -> puttext; '"' -> put; newline;
               if);
               (if (U[] <> none) and (args[] <> none) then
                   (if trx or traceUnit then
                       '**   OI:computeUnit:isBinary: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then 
                       (if traceUnit then
                           '**   arg.label: ' -> puttext; arg.label -> putline;
                           '**   arg: ' -> puttext; arg.dopt -> putline;
                       if);
                       (if true
                        // '^' -> U.equal then 
                           (if traceUnit then '**   got: ^' -> putline; if);
                           arg.getConstLiteral -> V;
                           &text[] -> argU[]; V -> argU.putint;
                           argU[] -> (U.copy).append -> U[];
                        else                           
                           arg.getUnit -> argU[];
                           (if true
                            // '-' -> U.equal then
                               (if false then
                                   '**** U: ' -> puttext; U[] -> puttext;
                                   ' ' -> put; argU[]-> putline
                               if)
                            // (1 -> argU.inxGet) = '#' then (* float or integer *)
                               argU[] -> U[]
                            else
                               (if toFix then
                                   '\n!!!! ObjectInvocation:computeUnit: ' 
                                     -> putline;
                                   '     We must reconsider the combinations'
                                   ' of #Integer and #Float' -> putline
                               if);
                               (if true 
                                // ('#Integer' -> argU.equal) 
                                   and ('#Integer' -> U.equal) then
                                // ('#Float' -> argU.equal) 
                                   and ('#Float' -> U.equal) then
                                else 
                                   argU[] -> (U.copy).append -> U[];
                       if)if)if);
                       (if traceUnit then
                           '**   OI:computeUnit:final:unit: ' -> puttext; 
                           U[] -> putline
                       if)
                   if)
                else
                   (if trx or traceUnit then 
                       '**   OI:computeUnit:not binary:U: ' -> puttext;
                       U[]->putline;
                       doPT -> putline;
                       ATd.computeUnit -> putline
               if)if)
            #);
          getConstLiteral:: 
            (# op: ^Text
            do (if trx or traceUnit then
                   '**** ObjectInvocation:getConstLiteral: ' -> puttext; 
                   dopt -> putline;
                   '**   Not implememnted' -> putline
               if); 
               
            #);   
          addConvFactor::
            (#
            do '**** OI:addConvFactor: ' -> puttext; dopt -> puttext; ' '-> put;
               CF -> putReal; newline;
               (if convFactor <> 0 then
                   '**** OI:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   CF -> convFactor; true -> done;
               if)
            #)
       #);
     BracketedExp::<
       (# getExpUnit::
            (#
            do recU[] -> IV.getExpUnit -> U[]
            #);
          getUnit:: (# do IV.getUnit -> U[] #);
          computeUnit::
            (#
            do (if traceUnit then
                   '**** BracketedExp:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               IV.computeUnit -> U[]
            #);
           getConstLiteral:: (# do IV.getConstLiteral -> value #)
       #);
     Name::< 
       (# getConstLiteral::
            (#
            do '**** Name:getConstLiteral: ' -> puttext; dopt -> putline;
               MaxInt -> value
            #)
       #);
     Const::< 
       (# getExpUnit::
            (#
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**** Const:semcheck: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '' -> U[]
               if)
            #);
          getUnitX:: (# do '#Integer' -> U[] #);
            (* Lexem::getUnit returns unit.T[] if not non, else inner
             * so if a unit is definedm we dont come here
             *)
          getUnit::          
            (# 
            do '#Integer' -> U[]
            #);
          computeUnit::(# do getUnit -> U[] #);
          getConstLiteral:: (# do T.setPos; T.getInt -> value #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** Const:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** Const:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done -> convDone 
               if)
            #);
          convDone: @boolean;
          int2floatDone:: 
            (# 
            do convDone -> value; 
               cd.com(#do 'convDone:'->TT; convDone -> BB #)
            #);
       #);
     FloatConst::<
       (# getExpUnit::
            (# 
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if true then
                       '**** FloatConst:semcheck: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '#Float' -> U[]
              if)
            #);
          getUnitX::
            (# ptn: ^Pattern
            do (if false or traceUnit then
                   '**** ObjectGenerator:getUnitX: ' -> puttext; 
                   doPT -> puthead
               if);
               '#Float' -> U[] 
            #);
          getUnit:: (* se comments at Const:getUnit *)
            (# 
            do '#Float' -> U[] 
            #);
          computeUnit::(# do getUnit -> U[] #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** FloatConst:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** FloatConst:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done; 
               if)
            #);
       #);
  do inner
  #)
