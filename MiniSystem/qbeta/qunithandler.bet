ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual';
INCLUDE 'qunitparser'
---lib:attributes---
traceUnit: (#exit false #);

UnitHandler: checker
  (# Pattern::<
       (# getUnitX:: 
            (# 
            do (if traceUnit then
                   '**** pattern:getUnitX: ' -> puttext; sig.dopt -> putline;
               if);
               OG.getUnitX -> U[]
            #);
       #);
     DataItem::<
       (# getUnitX::
            (#
            do (if traceUnit then
                   '**** DataItem:getUnitX: ' -> puttext; dopt -> putline
               if);
               (if OG.IS.isEmpty then
                   (OG.super.last).getUnitX -> U[]
                else
                   (*'!!!!! OBS! DataItem:getUnitX:singular DataItem:'-> puttext; 
                   dopt -> putline*)
               if)
            #);
       #);
     ObjectCall::<
       (# isUnitValueObj::
            (# ptn: ^Pattern
            do (if false then
                   '**** ObjectCall:isUnitValueObj: ' -> puttext; doPT -> putline
               if);
               (if super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               if)
            #);
          getUnitX:: 
            (# ptn: ^Pattern 
            do (if traceUnit then
                   '**** ObjectCall:getUnitX: ' -> puttext; dopt -> putline
               if);               
               (if true then
                   (* Ex: "k1 * s" -> "kg * % s" *)
                   super.getUnitX -> U[]
                else                   
                   (super.last).getUnitX -> U[] 
               if)
            #);
          getUnitPropShort::
            (# ptn: ^Pattern; 
            do (if traceUnit then
                   '**** objectCall:getUnitPropShort: ' -> puttext; dopt -> putline;
               if);
               (super.last).ATd[] -> ptn[];
               propNo -> ptn.OG.getUnitPropShort -> U[];
            #);          
          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU: ^text;
            do (if traceUnit then
                   '**** ObjectCall:computeUnit: ' -> puttext; dopt -> putline;
                   '**   super.last.label: ' -> puttext; (super.last).label -> putline;
               if);
               (if true then
                   (super.last).computeUnit -> U[];
                else
                   super.scanSons
                   (#  
                   do i + 1 -> i;
                      (if i 
                       // 1 then current[] -> rec[] 
                       // 2 then current[] -> msg[] 
                      if);
                   #);
                   (if i = 2 then
                       (* perhaps a binary method *)
                       (if true then
                           rec.computeUnit -> recU[]
                        else
                           rec.getUnitX -> recU[];
                       if);
                       msg.computeUnit -> U[];
                       (if traceUnit then
                           '**    binary:rec: ' -> puttext; rec.dopt -> puttext;
                           ' unit: ' -> puttext; recU[] -> puttext;
                           ' msgU: ' -> puttext; U[] -> puttext; 
                           ' msg: ' -> puttext; msg.label -> puttext;
                           ' args: ' -> puttext; msg.args.dopt -> putline
                       if)
               if)if)
            #);
          getConstLiteral:: 
            (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
            do (if traceUnit then
                   '**** ObjectCall:getConstLiteral: ' -> puttext; dopt -> putline; 
               if);
               (if true then
                   super.getConstLiteral -> value
                else
               super.scanSons
               (#  
               do i + 1 -> i;
                  (if i 
                   // 1 then current[] -> rec[] 
                   // 2 then current[] -> msg[] 
                  if);
               #);
               (if i = 2 then
                   (* perhaps a binary method *)
                   (if msg.isObjectInvocation then
                       (msg[]->OI[]).type.isOp -> op[];
                       (if true 
                        // '-' -> op.equal then
                           (* '*** got -' -> puttext;*)
                           rec.getConstLiteral -> v;
                           OI.scanSons(#do current.getConstLiteral -> u #);
                           (* v -> putint; ' ' -> put; u -> putint;*)
                           v - u -> value
                        // '+' -> op.equal then
                           '**** getConstLiteral:got + ' -> puttext;
                           dopt -> putline
               if)if)if)if)
            #);
       #);
     ObjectGenerator::<
       (# isUnitValueObj::
            (# ptn: ^Pattern
            do (if false then
                   '**** ObjectGenerator:isUnitValueObj: ' -> puttext; doPT -> putline
               if);
               IS.newBasicProp.unit[] <> none -> value;
               (*
               (if not (IS.newBasicProp.unit[] <> none -> value) then
                   (if super.ATd[] <> none then
                       (if super.ATd.isPattern then
                           (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               if)if)if)           *)        
            #);
          getUnitX::
            (#
            do (if traceUnit then 
                   '**** objectGenerator:getUnitX:\n' -> puttext; dopt -> putline if);
               (if (getUnitPropShort -> U[]) = none then
                   (if (super.ATd[] <> none) then
                       (if traceUnit then
                           '**   OG:super.ATd.getUnitX: ' -> putline;
                       if);
                       super.ATd.getUnitX -> U[]
               if)if);
               (if traceUnit then
                   '**   OG:Unit: ' -> puttext; U[] -> putline;
               if)
            #);  
         getUnitPropShort::
            (# UN: ^NewProperty;
            do (if (IS.newBasicProp.unit[]-> UN[]) <> none then
                   (* unit is defined for this OG*)
                   L:
                     UN.args.scanSons
                     (# i: @integer
                     do current.scanSons
                        (# S: ^StringObj
                        do (if current.isStringLiteral then
                               (current[] -> S[]).T[] -> U[];
                               (if propNo = i then leave L if);
                           if);
                           i + 1 -> i
                     #)#)
                else
                   (if IS.newBasicProp.primNo 
                    // float_prim then
                       '#Float' -> U[]
                    // integer_prim then
                       '#Integer' -> U[]
                   if)
               if)
            #);          
       #);
     invocation::<
       (* inv ::= rec msg
        * msg ::= unary
        *      |  binary
        *      |  functional
        *      |  keyword
        * binary ::=  +, -, *, /, ^, ...
        * Ex
        *  A ^ (0 - 1)
        * rec.getOp -> op
        * msg.getUnit -> U
        *)
       (# getUnitX::
            (#
            do (if traceUnit then 
                   '**** Invocation:getUnitX: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               computeUnit -> U[]
            #);
          computeUnit::
            (# rec,msg: ^Exp; i: @integer; recU,msgU: ^text;
            do (if traceUnit then
                   '**** Invocation:ComputedUnit: ' -> puttext; dopt -> putline
               if);
               (* Ex: "k1 * s" -> "kg * % s" *)
               scanSons
               (#  
               do i + 1 -> i; (*current.label -> putline; current.dopt -> putline;*)
                  (if i 
                   // 1 then current[] -> rec[] ; (*rec.doPP -> putline*)
                   // 2 then current[] -> msg[] 
                  if);
               #);
               (if i = 2 then
                   (* perhaps a binary method *)
                   (if true then
                       rec.computeUnit -> recU[] -> U[] (* "kg" *)
                    else
                       rec.getUnitX -> recU[];
                   if);
                   (if traceUnit then
                       '**   Invocation:rec:unit: ' -> puttext; U[] -> putline;
                   if);
                   (if U[] = none then
                       msg.computeUnit -> U[]; (* "*s", U = "kg*s" *)
                       (if traceUnit then
                           '**** Invocation:getUnitX:U none ' -> puttext; dopt -> putline;
                           U[] -> putline
                       if)
                    else
                       (if (1 -> U.inxGet) = '#' then
                           leave computeUnit 
                       if);
                       (if true then
                           msg.computeUnit -> msgU[];
                           (if msgU[] <> none then
                               (if (1 -> msgU.inxGet) = '#' then
                                   leave computeUnit
                                else
                                   (if (1 -> msgU.inxGet) 
                                    // '-' // '+' then
                                       (if traceUnit then
                                           '**** U,msgU: ' -> puttext; 
                                           U[] -> puttext; ',' -> put; 
                                           msgU[] -> puttext; ':' -> put; 
                                           msgU.length -> putint;
                                           newline;
                                       if);
                                       (if msgU.length = 1 then
                                           (* unary minus as in X^-1 *)
                                           leave computeUnit
                                       if);
                                       (2,msgU.length)->msgU.sub -> msgU[];
                                       (if not (msgU[] -> U.equalNCS) then
                                           '\n**** Different units in addition: '
                                             -> puttext;
                                           U[] -> puttext;  ',' -> put;
                                           msgU[] -> putline; 
                                           dopt -> putline;
                                           newline
                                       if)
                                    else
                                       msgU[] -> (U.copy).append -> U[]; (* "*s", U = "kg*s" *)
                           if)if)if)
                        else
                           msg.computeUnit -> (U.copy).append -> U[]; (* "*s", U = "kg*s" *)
                   if)if);
                   (if traceUnit then
                       '**   Invocation:isBinary:rec: ' -> puttext; rec.dopt -> puttext;
                       ' unit: "' -> puttext; recU[] -> puttext;
                       '" msgU: "' -> puttext; U[] -> puttext; 
                       '" msg: ' -> puttext; msg.doPT -> puttext;
                       ' args: ' -> puttext; msg.args.dopt -> putline
                   if)
                else
                   (* pehaps a onst literal ? *)
                   rec.getUnitX -> U[]
               if);
            #);
          getConstLiteral:: 
             (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; OI: ^ObjectInvocation
             do (if traceUnit then
                    '**** Invocation:getConstLiteral: ' -> puttext; dopt -> putline;
                if);
                scanSons
                (#  
                do i + 1 -> i;
                   (if i 
                    // 1 then current[] -> rec[] 
                    // 2 then current[] -> msg[] 
                   if);
                #);
                MaxInt -> value;
                (if i = 2 then
                    (if traceUnit then
                        '**   perhaps a binary method?' -> putline;
                    if);
                    (if msg.isObjectInvocation then
                        (msg[]->OI[]).type.isOp -> op[];
                        (if traceUnit then
                            '**   op: ' -> puttext; op[] -> putline;
                        if);
                        (if '-' -> op.equal then
                            (if traceUnit then '*** got -\n' -> puttext; if);
                            rec.getConstLiteral -> v;
                            OI.args.scanArgs(#do current.getConstLiteral -> u #);
                            (if traceUnit then
                                v -> putint; ' ' -> put; u -> putint; newline;
                            if);
                            v - u -> value
                        if)
                    if)
                 else (* perhaps (0 - 1) *)
                    rec.getConstLiteral -> value
                if)
             #);
       #);
     ObjectInvocation::<
       (# getUnitX::
            (# argU: ^text;  i: @integer; arg: ^ObjectSpecification
            do (if traceUnit then 
                   '**** ObjectInvocation:getUnitX: ' -> puttext; dopt -> putline;
               if);
               ATd.getUnitX -> U[];
               (if traceUnit then
                   '**   OI:ATd.getUnitX: ' -> puttext; U[] -> putline
               if);
               (if (U[] <> none) and (args[] <> none) then
                   (if traceUnit then
                       '**   getUnitX:OI:binary: ' -> puttext; dopt -> puttext;
                       ' args: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then
                       arg.getUnitX -> argU[];
                       (if traceUnit then
                           '**   OI:argU: ' -> puttext; argU[] -> putline
                       if);
                       argU[] -> (U.copy).append -> U[]
                   if)
               if);
               (if traceUnit then
                   '**   OI:finalU: ' -> puttext; U[] -> putline
               if);               
            #);
          computeUnit::
            (# argU: ^text;  i,V: @integer; arg: ^ObjectSpecification
            do (if traceUnit then
                   '**** ObjectInvocation:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               type.isOp -> U[];
               (if traceUnit then
                   '**   OI:computeUnit:type.op: "' -> puttext; 
                   U[] -> puttext; '"' -> put; newline;
               if);
               (if (U[] <> none) and (args[] <> none) then
                   (if traceUnit then
                       '**   OI:computeUnit:isBinary: ' -> puttext; args.dopt -> putline;
                   if);
                   args.scanArgs
                   (#
                   do i + 1 -> i; current[] -> arg[]; 
                   #);
                   (if i = 1 then 
                       (if traceUnit then
                           '**   arg.label: ' -> puttext; arg.label -> putline;
                           '**   arg: ' -> puttext; arg.dopt -> putline;
                       if);
                       (if true
                        // '^' -> U.equal then 
                           (if traceUnit then '**   got: ^' -> putline; if);
                           arg.getConstLiteral -> V;
                           &text[] -> argU[]; V -> argU.putint;
                           argU[] -> (U.copy).append -> U[];
                        else                           
                           (if true = arg.isStringLiteral then 
                               arg.getUnitX -> argU[];
                            else
                               (if true then
                                   arg.getUnitX -> argU[];
                                   (if '+' -> U.equal then
                                       (if traceUnit then
                                           '** OI:computeUnit:got+: ' 
                                             -> puttext;
                                           dopt -> putline;
                                           '**   OI:got+:argU: ' -> puttext;   
                                           argU[] -> putline
                                       if)
                                   if)
                                else
                                   arg.getConstLiteral -> v;
                                   (if v < MaxInt then
                                       (*arg.doPP -> putline;*)
                                       &text[] -> argU[]; V -> argU.putint;
                                    else
                                       (* problem with ^(0-1), here getConstLiteral
                                        * and (Ax * S), here getUnitX *)
                                       arg.getUnitX -> argU[];
                               if)if)
                           if);
                           (if true
                            // '-' -> U.equal then
                               (if false then
                                   '**** U: ' -> puttext; U[] -> puttext;
                                   ' ' -> put; argU[]-> putline
                               if)
                            // (1 -> argU.inxGet) = '#' then (* float or integer *)
                               argU[] -> U[]
                            else
                               argU[] -> (U.copy).append -> U[];
                       if)if);
                       (if false then
                           argU[] -> (U.copy).append -> U[];
                       if);
                       (if traceUnit then
                           '**   OI:computeUnit:final:unit: ' -> puttext; 
                           U[] -> putline
                       if)
               if)if)
            #);
          getConstLiteral:: 
            (# op: ^Text
            do (if true or traceUnit then
                   '**** ObjectInvocation:getConstLiteral: ' -> puttext; dopt -> putline;
                   '**   Not implememnted' -> putline
               if); 
               
            #);      
       #);
     BracketedExp::<
       (# getUnitX:: (# do IV.getUnitX -> U[] #);
          computeUnit::
            (#
            do (if traceUnit then
                   '**** BracketedExp:ComputeUnit: ' -> puttext; dopt -> putline
               if);
               IV.computeUnit -> U[]
            #);
           getConstLiteral:: (# do IV.getConstLiteral -> value #)
       #);
     Name::< 
       (# getConstLiteral::
            (#
            do '**** Name:getConstLiteral: ' -> puttext; dopt -> putline;
               MaxInt -> value
            #)
       #);
     Const::< 
       (# getUnitX:: (# do '#Integer' -> U[] #);
          computeUnit::(# do getUnitX -> U[] #);
          getConstLiteral:: (# do T.setPos; T.getInt -> value #)
       #);
     FloatConst::<
       (# getUnitX:: (# do '#Float' -> U[] #);
          computeUnit::(# do getUnitX -> U[] #);
          (*getConstLiteral:: (# do T.setPos; T.getInt -> value #)*)
       #);
  do inner
  #)
