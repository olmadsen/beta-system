ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'; 
INCLUDE 'qunitparser' 
---lib:attributes--- 
doCheckUnits: (# exit false #);
useNewUnitHandler: (# exit true #);
UnitHandler: checker
  (# Pattern::<
       (# getExpUnit:: 
            (# 
            do '**** pattern:getExpUnit:shoulNotHappen: ' -> putline;
               dopt -> puthead
            #);
          hasUnitVar: booleanValue
            (# U: ^text
            do (if (1 -> OG.getUnitPropShort -> U[]) <> none then
                   (if traceUnit then
                       '**** ptn:hasUnitVar: ' -> puttext; U[] -> putline;
                       'X' -> U.equal -> value
               if)if)
            #)
       #);
     DataItem::<
       (# getExpUnit::
            (#
            do '**** DataItem:getUnit:shoulNotHappen: ' -> puttext; 
               dopt -> putline
            #);
       #);
     ObjectCall::<
       (# getExpUnit:: 
            (# 
            do (if traceUnit then
                   '**** OC:getExpUnit: ' -> puttext; dopt -> putline;
               if);
               super.getExpUnit -> U[];
               (if traceUnit then
                   '**** ObjectCall:GEU: '->puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectCall:isUnitValueObj: ' -> puttext; 
                   doPT -> puthead
               if);
               (if super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               if);
               (if traceUnit then
                   '**** ObjectCall:isUnitValueObj= ' -> puttext; 
                   value -> putboolean; newline
               if);
            #);
          getUnitPropShort::
            (# ptn: ^Pattern; 
            do (if traceUnit then
                   '**** objectCall:getUnitPropShort: ' -> puttext; 
                   dopt ->puthead
               if);
               (super.last).ATd[] -> ptn[];
               propNo -> ptn.OG.getUnitPropShort -> U[];
            #);          
          getConstLiteral:: 
            (# 
            do (if traceUnit then
                   '**** ObjectCall:getConstLiteral: ' -> puttext;
                   dopt -> putline; 
               if);
               super.getConstLiteral -> value
            #);
       #);
     ObjectGenerator::<
       (# getUnitProp::
            (# ptn: ^Pattern
            do (* '**** getUnitProp: ' -> putline;
               dopt -> puthead;*)
               (if ((super.ATd[]->ptn[]) <> none) then
                   ptn.OG.getUnitProp -> UN[];
                else
                   IS.newBasicProp.UNIT[] -> UN[];
               if)
            #);
          getExpUnit:: 
            (#
            do (if traceUnit then
                   '**** OG:getExpUnit: ' -> puttext; dopt -> puthead
               if);
               (* We may have an OG where super is a dataItem as in
                *    distToAlpha / rocketSpeed  where rocketSpeed 
                * is an OG with super rocketSpeed: var Velocity.Mass
                * We should fix the parser here!
                *)
               (if IS.isEmpty (*and super.ATd.isPattern*) then
                   super.getExpUnit -> U[]
                else
                   (if IS.newBasicProp.unit[] <> none then
                       IS.newBasicProp.unit.args.scanSons
                       (#
                       do current.scanSons
                          (# S: ^StringObj
                          do (if current.isStringLiteral then
                                 (current[] -> S[]).T[] -> U[];
                             if)
                          #)
                       #)
                    else
                       (if primNo                            
                        // float_prim then '#Float' -> U[]
                        // integer_prim then '#Integer' -> U[]
                   if)if)
               if);
               (if traceUnit then
                   '**** OG:GEU: '->puttext; dopt -> puthead;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          isUnitValueObj::
            (# ptn: ^Pattern
            do (if traceUnit then
                   '**** ObjectGenerator:isUnitValueObj: ' -> puttext; 
                   doPT -> puthead
               if);
               (if IS.isEmpty and super.ATd.isPattern then
                   (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
               else
                   IS.newBasicProp.unit[] <> none -> value;
               if);
               (*
               (if not (IS.newBasicProp.unit[] <> none -> value) then
                   (if super.ATd[] <> none then
                       (if super.ATd.isPattern then
                           (super.ATd[] -> ptn[]).OG.isUnitValueObj -> value
                if)if)if)           *)
               (if traceUnit then
                   '**** ObjectGenerator:isUnitValueObj=' -> puttext; 
                   value -> putboolean; newline;
                   (if value then doPT -> puthead if)
               if);
            #);  
         getUnitPropShort::
            (# UN: ^NewProperty; E: ^Exp; OI: ^ObjectInvocation
            do (if trx or traceUnit then 
                   '**** objectGenerator:getUnitPropShort:' -> putline; 
                   dopt -> puthead 
               if);
               (if IS.isEmpty then
                   super.scanSons
                   (#
                   do current[] -> E[]
                   #);
                   propNo -> E.ATd.OG.getUnitPropShort -> U[]
                else
               (if (IS.newBasicProp.unit[]-> UN[]) <> none then
                   (* unit is defined for this OG*)
                   L:
                     UN.args.scanSons
                     (# i: @integer
                     do i + 1 -> i;
                        current.scanSons
                        (# S: ^StringObj
                        do (if current.isStringLiteral then
                               (current[] -> S[]).T[] -> U[];
                               (if propNo = i then leave L if);
                           if);
                     #)#)
                else
                   (if IS.newBasicProp.primNo 
                    // float_prim then
                       '#Float' -> U[]
                    // integer_prim then
                       '#Integer' -> U[]
                   if)
               if)
            if)#);          
          getConstLiteral:: 
            (# 
            do (if traceUnit then
                   '**** ObjectGenerator:getConstLiteral: ' -> puttext;
                   dopt -> puthead
               if);
               super.getConstLiteral -> value
            #);
       #);
     invocation::<
       (* inv ::= rec msg
        * msg ::= unary
        *      |  binary
        *      |  functional
        *      |  keyword
        * binary ::=  +, -, *, /, ^, ...
        * Ex
        *  A ^ (0 - 1)
        * rec.getOp -> op
        * msg.getUnit -> U
        *)
       (# getExpUnit::
            (#
            do (if traceUnit then
                   '**** INV:getExpUnit: ' -> puttext; dopt -> putline;
               if);
               (if recU[] = none then '' -> recU[] if);
               recU[] -> U[];
               scanSons
               (# E: ^Exp; Ux,Uy: ^text
               do U[] -> current.getExpUnit -> Ux[];
                   (if Ux[] <> none then
                       (if true 
                        // 'U' -> Ux.equal then
                           current[] -> E[];
                           E.ATd.OG.getUnitPropShort -> Uy[];
                           (if traceUnit then
                               '**** INV:got: "U": '->puttext; dopt -> puthead;
                               current.dopt -> puthead;
                               E.ATd.dopt -> puthead;
                               '*   recU: ' -> puttext; U[] -> putline;
                               Uy[] -> putline;
                           if);
                           (if Uy[] <> none then
                               (if true
                                // 'U*U' -> Uy.equal then
                                   U.copy -> Uy[];
                                   '*' -> Uy.put;
                                   U[] -> Uy.puttext;
                                   Uy[] -> U[]
                                else
                                   Ux[] -> U[]
                               if)
                            else
                               Ux[] -> U[]
                           if);
                           (if traceUnit then
                               '** trans: ' -> puttext; U[] -> putline 
                           if);
                        // 'U*U' -> Ux.equal then
                           '!!!! got: "U*U": '->puttext; dopt -> puthead;
                        else
                           Ux[] -> U[]
                       if)
                    else
                       Ux[] -> U[]    
                   if);
               #);
               (if traceUnit then
                   '**** INV:GEU: ' -> puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          getConstLiteral:: 
            (# rec,msg: ^Exp; v,u,i: @integer; op,recU: ^text; 
               OI: ^ObjectInvocation
             do (if traceUnit then
                    '**** Invocation:getConstLiteral: ' -> puttext; 
                    dopt -> putline;
                if);
                scanSons
                (#  
                do i + 1 -> i;
                   (if i 
                    // 1 then current[] -> rec[] 
                    // 2 then current[] -> msg[] 
                   if);
                #);
                MaxInt -> value;
                (if i = 2 then
                    (if traceUnit then
                        '**   perhaps a binary method?' -> putline;
                    if);
                    (if msg.isObjectInvocation then
                        (msg[]->OI[]).type.isOp -> op[];
                        (if traceUnit then
                            '**   op: ' -> puttext; op[] -> putline;
                        if);
                        (if '-' -> op.equal then
                            (if traceUnit then '*** got -\n' -> puttext; if);
                            rec.getConstLiteral -> v;
                            OI.args.scanArgs(#do current.getConstLiteral -> u #);
                            (if traceUnit then
                                v -> putint; ' ' -> put; u -> putint; newline;
                            if);
                            v - u -> value
                        if)
                    if)
                 else (* perhaps (0 - 1) *)
                    rec.getConstLiteral -> value
                if)
             #);
       #);
     ObjectInvocation::<
       (# getExpUnit:: 
            (* pattern:
             *    foo, bar(exp), @put e :at ix
             *    := exp
             *    + exp, - exp, * exp, / exp, ^exp
             * dataItem: X, rocketSpeed
             *)
            (# getBinArg: 
                 (#
                 do L:
                      (if args[] <> none then
                          args.scanArgs
                          (#
                          do current.getExpUnit -> U[];
                             (* current.getExpUnit may return #Float or #integer
                              * and these should not be appended to recU
                              *)
                             leave L
                          #);
                      if)
                 #);
               filterNumeric:
                 (# op: @char
                 do getBinArg; 
                    (if false then
                        '***  for: ' -> puttext; dopt -> puttext;
                        ' got: ' -> puttext;
                        '  recU: ' -> puttext; recU[] -> puttext;
                        '  U: ' -> puttext; U[] -> putline;
                    if);
                    (if true
                     // '#Float' -> recU.equal
                     // '#Integer' -> recU.equal then
                        (* return U *)
                     // '#Float' -> U.equal
                     // '#Integer' -> U.equal then
                        recU[] -> U[] (* retunr recU *)
                     else
                        inner;
                        '(' -> recU.prepend; ')' -> recU.append;
                        op -> recU.put; '(' -> recU.put;
                        U[] -> recU.puttext; ')' -> recU.put;
                        recU[] -> U[]
                    if)
                 #);
               V: @integer
            do (if traceUnit then
                   '**** OI:getExpUnit: ' -> puttext; dopt -> putline;
               if);
               (if ATd[] <> none then
                   (if true
                    // ATd.isDataItem then
                       (if expUnit[] <> none then
                           expUnit.copy -> U[];
                       if)
                    // ATd.isPattern then
                       (* '**   ATd.isPattern: ' -> puttext;
                        * ATd.primNo -> putint; newline;
                        *)
                       (if recU[] = none then '' -> recU[] if);
                       (if ATd.primNo
                        // 109 (* + *)
                        // 110 (* - *) then
                           args.scanArgs(#do current.getExpUnit -> U[] #);
                           (* recU and U must be equal *)
                        // 112 then
                           (* recU/U may be a numeric constant or dataItem *)
                           filterNumeric(#do '*'->op #)
                        // 121 then
                           filterNumeric(#do '/' -> op #)
                           (* // '^' -- not a primitive *)
                        // vassign_prim //rassign_prim then
                           (# dstBV,srcBV: ^BaseVector; T: ^UnitTree
                           do
                              args.scanArgs(#do current.getExpUnit -> U[] #);
                              (if traceUnit then
                                  '**   assign: '->puttext; recU[] -> puttext;
                                  ' ' -> put; U[] -> putline;
                              if);
                              (if true 
                               // '#Float' -> recU.equal then
                                  (if true
                                   // '#Float' -> U.equal then
                                   // '#Integer' -> U.equal then
                                  if)
                                  (* incompete if no match above (or below) *)
                               // '#Integer' -> recU.equal then
                                  (if true
                                   // '#Float' -> U.equal then
                                   // '#Integer' -> U.equal then
                                  if)
                               // recU.length = 0 then
                                  (* check what to do here! *)
                               else                                
                                  (if doCheckUnits then
                                      recU[] 
                                        -> parseUnit -> mkBaseVector -> dstBV[];
                                      U[] -> parseUnit -> T[] 
                                        -> mkBaseVector -> srcBV[];
                                      (if srcBV[] -> dstBV.equal then
                                          '**** equal:'->puttext; 
                                          recU[] -> puttext;
                                          ' ' -> put; U[] -> putline;
                                          (*true -> T.print -> putline;*)
                                       else
                                          '**** not equal:'->puttext; 
                                          U[] -> puttext;
                                          ' ' -> put; recU[] -> putline;
                                      dstBV.print;
                                          true -> T.print->putline;
                                          srcBV.print;
                              if)if)if)
                           #)
                        else
                           (* Q or R.Q where Q = this(OI) and 
                            * Q: oneOf: foo, bar(exp), @put e :at ix
                            *)
                            (if false then
                                ATd.sig.dopt -> puthead;
                                (ATd.sig.dopt).length -> putint; newline;
                            if);
                           (if '^ ' -> (ATd.sig.dopt).equal then
                               (*'**** got ^:' ->putline;*)
                               args.scanArgs(#do current.getConstLiteral -> V #);
                               '(' -> recU.prepend; ')' -> recU.append;
                               '^' -> recU.put; '(' -> recU.put;
                               V -> recU.putint; ')' -> recU.put;
                               recU[] -> U[];
                               (*  '**** ^res: ' -> puttext; U[]->putline*)
                            else
                               (# ptn: ^Pattern
                               do (if traceUnit then
                                      '**** OI:GEU:ptn: '->puttext; 
                                      ATd.dopt -> putline;
                                      args.dopt -> puttext; ' ' -> put;
                                  if);
                                  (if (ATd[] -> ptn[]).hasUnitVar then
                                      'X' -> U[]
                                   else
                                      expUnit[] -> U[]; 
                                  if);
                               #);
                               (if traceUnit then U[] -> putline if);
                               args.scanArgs(#do ''->current.getExpUnit #);
                               (if U[] = none then 'Q' -> U[] if)
                           if)
                       if)
                   if);
               if);               
               (if traceUnit then
                   '**** OI:GEU: ' -> puttext; dopt -> puttext;
                   ' unit: ' -> puttext; U[] -> putline
               if)
            #);
          getConstLiteral:: 
            (# op: ^Text
            do (if trx or traceUnit then
                   '**** ObjectInvocation:getConstLiteral: ' -> puttext; 
                   dopt -> putline;
                   '**   Not implememnted' -> putline
               if); 
               
            #);   
          addConvFactor::
            (#
            do '**** OI:addConvFactor: ' -> puttext; dopt -> puttext; ' '-> put;
               CF -> putReal; newline;
               (if convFactor <> 0 then
                   '**** OI:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   CF -> convFactor; true -> done;
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #)
       #);
     BracketedExp::<
       (# getExpUnit::
            (#
            do recU[] -> IV.getExpUnit -> U[]
            #);
           getConstLiteral:: (# do IV.getConstLiteral -> value #)
       #);
     Name::< 
       (# getConstLiteral::
            (#
            do '**** Name:getConstLiteral: ' -> puttext; dopt -> putline;
               MaxInt -> value
            #)
       #);
     Const::< 
       (# getExpUnit::
            (#
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**** Const:semcheck: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '#Integer' -> U[]
               if)
            #);
          getConstLiteral:: (# do T.setPos; T.getInt -> value #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** Const:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** Const:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done -> convDone 
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #);
          convDone: @boolean;
          int2floatDone:: 
            (# 
            do convDone -> value; 
               cd.com(#do 'convDone:'->TT; convDone -> BB #)
            #);
       #);
     FloatConst::<
       (# getExpUnit::
            (# 
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if traceUnit then
                       '**** FloatConst:getExpUnit: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> U[] 
                else
                   '#Float' -> U[]
              if)
            #);
          addConvFactor:: 
            (# 
            do (if convFactor > 0 then
                   '**** FloatConst:addConvFactor:skip: ' -> puttext;
                   dopt -> puttext;
                   ' old: ' -> puttext; convFactor -> putreal;
                   ' new: ' -> puttext; CF -> putreal; newline
                else
                   '**** FloatConst:addConvFactor: ' -> puttext;
                   CF -> putReal; newline;
                   CF  -> convFactor; true -> done; 
               if)
            #);
          hasConvFactor:: (# do convFactor <> 0 -> value #)
       #);
  do inner
  #)
