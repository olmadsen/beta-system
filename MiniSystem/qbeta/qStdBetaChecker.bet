ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaParser';
---LIB:attributes---
qStdBetaChecker: parseStdBetaModule
  (# StdBetaModule::
       (# setUpOrigin::
            (#
            do (if false then
                   'StdBetaModule:setUpOrigin:'->dumpT;
                   moduleName.doPT->dumpTN;
               if);
               origin[] -> frags.setUpOrigin;
               true -> done
            #);
       #);
     BetaFragments::<
       (# setUpOrigin::(#do (*'BetaFragments:setUpOrigin'->traceCheckN*) #);
          check::
            (# 
            do (*'BetaFragments:check:'->traceCheckN;*)
            #)
       #);
     AttFrag::<
       (# setUpOrigin::(#do (*'AttFrag:setUpOrigin'->traceCheckN*) #);
          check::
            (#
            do (*'AttFrag:check:'->traceCheckN;*)
            #);
       #);
     ObjDescFrag::<
       (# setUpOrigin::(#do (*'ObjDescFrag:setUpOrigin'->traceCheckN*) #);
          check::
            (#
            do (*'ObjDescFrag:check:'->traceCheckN;*)
            #);
       #);
     DoPartFrag::<
       (# setUpOrigin::(#do 'DoPartFrag:setUpOrigin'->traceCheckN #);
          check::
            (#
            do (*'DoPartFrag:check:'->traceCheckN;*)
            #);
       #);
     Attributes::<
       (# setUpOrigin::
            (#
            do (*'Attributes:setUpOrigin'->traceCheckN; *)
               (if false then doPT -> putHeadN if)
            #);
          check::
            (#
            do (*'Attributes:check:'->traceCheckN;*)
            #);
          localSearch::
            (#
            do (*'**** Attributes.localSearch:'->traceCheck; 
                * NA.T[]->traceCheckN;
                *)
               loop:
                 scanSons
                 (#
                 do NA[] -> current.localSearch -> (dcl[],pn);
                    (if dcl[] <> none then
                        leave Loop
            if)#)#)
       #);
     AttSlot::
       (# setUpOrigin::
            (#
            do (*'AttSlot:setUpOrigin:'->traceCheck; doPT -> traceCheckN*)
            #);
       #);
     ObjDescSlot::
       (# setUpOrigin::
            (#
            do (*'ObjDescSlot:setUpOrigin:'->traceCheck; 
                * doPT -> traceCheckN;*)
               scanBindings
               (#
               do origin[] -> current.setUpOrigin
            #)#);
       #);
     DoPartSlot::
       (# setUpOrigin::
            (#
            do (*'DoPartSlot:setUpOrigin:'->traceCheck; 
                * doPT -> traceCheckN*)
            #);
       #);
     BetaDecl::<
       (# setUpOrigin::
            (#
            do this(BetaDecl)[] -> NS.addDclRef;
            #);
          theDesc::
            (#
            do IT.theDesc -> aDesc[]
            #);
          localSearch::
            (#
            do NA[] -> NS.localSearch -> (dcl[],pn)
            #);
       #);
     NameDecls::
       (# addDclRef:
            (# dcl: ^BetaDecl; ND: ^BetaNameDecl
            enter dcl[]
            do scanSons(#do dcl[] -> (current[]->ND[]).theDcl[] #)
            #);
          localSearch::
            (#
            do loop:
                 scanSons
                 (# pn: @integer
                 do NA[]->current.localSearch-> (dcl[],pn);
                    (if dcl[] <> none then
                        leave loop
            if)#)#)
       #);
     BetaNameDecl::
       (# localSearch::
            (#
            do (if NA.T[] -> N.T.equalNCS then
                   (* '**** NameDecl:found:'-> traceCheck; 
                    * NA.T[]->traceCheckN;*)
                   (if theDcl[] = none then
                       '!!!! theDcl is none'->dumpTN;
                   if);
                   theDcl[] -> dcl[];
            if)#);
          theDcl: ^BetaDecl
       #);
     StaticItem::<
       (# check::
            (#
            do (*'StaticItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #)
       #);
     DynamicItem::<
       (# check::
            (#
            do (*'DynamicItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #)
       #);
     Repetition::<
       (# check:: 
            (#do (*'Repetition:check:'->traceCheck; dopt -> traceCheck*) #);
          theDesc::
            (#
            do repetitionDesc[] -> aDesc[]
            #);
       #);
     BetaPattern::<
       (# check::
            (#
            do (*'BetaPattern:check:'->traceCheckN;*)
            #);
          theDesc:: (# do OD[] -> aDesc[] #);
       #);
     BetaVirtualPattern::
       (# check::
            (#
            do (*'BetaVirtualPattern:check:'->traceCheckN;*)
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# 
            do OS.theDesc -> aDesc[] 
            #);
       #);
     FurtherBinding::
       (# check::
            (#
            do (*'FurtherBinding:check:'->traceCheckN;*)
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# 
            do OS.theDesc -> aDesc[] 
            #);
       #);
     FinalBinding::
       (# check::
            (#
            do (*'FinalBinding:check:'->traceCheckN;*)
            #);
          theDesc:: (# do OS.theDesc -> aDesc[] #);
       #);
     ObjectDesc::<
       (# setUpOrigin::
            (#
            do (*'ObjectDesc:setUpOrigin'->traceCheck; label->traceCheckN*)
               origin[] -> sup.setupOrigin; 
               this(ObjectDesc)[] -> att.setUpOrigin;
               this(ObjectDesc)[] -> acp.setUpOrigin;
               true -> done;
            #);
          check::
            (#
            do (*'ObjectDesc:check:'->traceCheckN;*)
            #);
          theDesc::
            (#
            do this(ObjectDesc)[] -> aDesc[]
            #);
          scanDecls:
            (#
            do (* remember labels and forImpIndex *)
               att.scanSons
               (#
               do
               #)
            #);
          localSearch::
            (# aDesc:  ^ObjectDesc
            do NA[] -> att.localSearch -> (dcl[],pn);
               (if dcl[] = none then
                   (if (sup.theDesc -> aDesc[]) <> none then
                       NA[] -> aDesc.localSearch -> (dcl[],pn);
                       (if dcl[] <> none then
                           pn + 1 -> pn;
                           (*'**   found in super: ->dumpT;NA.dopt->dumpTN*)
            if)if)if)#);
          search:
            (# NA: ^BetaName; dcl:  ^BetaDecl; pn,on: @integer
            enter NA[]
            do (*'ObjDesc:Search:' -> traceCheckN;*)
               (if NA.T.length > 0 then 
                   (if false then
                       '**** Search:' -> traceCheck; NA.T[] -> traceCheckN;
                       '**   in:' -> traceCheckN;
                       doPT -> traceCheckN;
                   if);
                   NA[] -> localSearch -> (dcl[],pn);
                   (if dcl[] = none then
                       (if origin[] <> none then
                           NA[] -> origin.search -> (dcl[],pn,on)
               if)if)if)
            exit(dcl[],pn,on)
            #);
       #);
     ActionPart::<
       (# check::
            (#
            do (*'ActionPart:check:'->traceCheckN;*)
              (* enterP.check;
               imps.check;
               exitP.check*)
            #)
       #);
     Imperatives::<
       (# check::
            (#
            do (*'Imperatives:check:'->traceCheckN;*)
            #);
       #);
     IfImp::<
       (# check::
            (#
            do (*'IfImp:check:'->traceCheckN;*)
            #)
       #);
     PatternDen::<
       (# check::
            (#
            do (*'PatternDen:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do AD.theDesc -> aDesc[]
            #);
       #);
     NameApl::<
       (# check::
            (# dcl: ^BetaDecl; pn,on: @integer
            do (*'NameApl:check:'->traceCheck; doPT->traceCheckN;*)
               (if N.T.length > 0 then 
                   (if false then
                       '**** AD:Search:'->traceCheck; T[]->traceCheckN;
                   if);
                   (if origin[] <> none then
                       N[] -> origin.search -> (dcl[] -> ATd[],pn,on);
                       on + 1 -> on;
                       (if (dcl[] <> none) then
                           (if false then
                               '**** Found:'->traceCheck;
                               N.T[] -> traceCheck;
                               ' pn: ' -> traceCheck; pn -> putint;
                               ' on: ' -> traceCheck; on -> putint; newline
                           if)
                        else                           
                           '\n**** did not find: ' -> traceCheck;
                           N.T[] -> traceCheckN;
                           father.father.father.father.doPT -> dumpTN;
                           (if origin[] = none then
                               '**   NameApl:origin is none'->dumpTN
                            else
                               (if theEncOD <> objDesc[] then
                                   (theEncOD).father.father.dopt -> putHeadN
                                else
                                   (theEncOD).dopt -> putHeadN
                               if)
                       if)if)
                    else
                       'empty'->traceCheckN
               if)if);
               true -> done
            #);
          theDesc::
            (#
            do L:
                 (if ATd[] <> none then 
                     (*ATd.dopt->putHeadN; *)
                     ATd.theDesc -> aDesc[] 
                else
                   (if N.T.length > 0 then
                       '**** enforce:check:'->dumpT; dopt->dumpTN;
                       check;
                       restart L
                    else
                       (if theEncOD <> objDesc[] then
                           objDesc[] -> aDesc[];
                           (*'**   return:objDesc:'->dumpTN; 
                           aDesc.dopt->dumptn*)
                        else
                           (*'**   return:none:in:objDesc'->dumpTN*)
                       if)
                 if)if)
            #);
          ATd: ^BetaDecl
       #);
     Indexed::<
       (# theDesc:: 
            (#do (*'Indexed:theDesc:'->traceCheck; dopt -> traceCheckN*) #);
       #);
     Remote::<
       (# setUpOrigin::
            (#
            do (*'Remote:setUpOrigin:'->traceCheck; dopt -> dumpTN;*)
            #);
          Check::
            (# predDesc: ^ObjectDesc
            do (*'Remote:check:'->traceCheck; dopt -> dumpTN;*)
               scanSons
               (# AD: ^AttributeDenotation
               do (*current.doPT -> dumpTN;*)
                  (if not isFirst then
                      predDesc[] -> current.setUpOrigin
                  if);
                  (current[]->AD[]).check;
                  AD.theDesc -> predDesc[]
            #)#);
       #);
     BetaName::<
       (# setUpOrigin::
            (#
            do (if false and (origin[] = none) then
                   (* must be betaenv *)
                   'Name:origin is none:'->traceCheck; T[]->traceCheckN
               if)
            #);
          check::
            (# 
            do (*'BetaName:check:'->traceCheck;*)
            #)
       #);
     findPredefinedDesc:
       (# descName: ^Text;  ptn:  ^BetaPattern
       enter descName[]
       do (if false then
              'findPredefinedDesc:'->dumpT; descName[] -> dumpT;
              ' in topModule:'-> dumpT; topModule.label -> dumpTN;
              topModule.doPT -> putheadN;
          if);
          topModule.frags.scanSons
          (# i: @integer; objFrag: ^ObjDescFrag; 
             att: ^Attributes; dcl:  ^BetaDecl; pn: @integer
          do (*current.label -> dumpTN;*)
             (if (i + 1 -> i) = 1 then
                 (current[]->objFrag[]).OD.att[] -> att[];
                 descName[] -> BetaName -> att.localSearch -> (dcl[],pn);
                 (if dcl[] <> none then 
                     (if false then
                         dcl.label->dumpT; dcl.IT.label -> dumpTN;
                         dcl.doPT -> dumpTN;
                     if);
                     dcl.IT[] -> ptn[];
                     inner findPredefinedDesc;
                  else
                     '\n!!!! Compiler error: "'->puttext;
                     descName[] -> puttext;
                     '" pattern not found in betaenv'->putline
                 if);
              else
                 '\n!!!! Potential compiler problem:'->putline;
                 '!!   More than one fragment in betaenv'->putline;
       if)#)#);
     findPredefinedDescs:
       (#
       do 'Object' -> findPredefinedDesc
          (#
          do ptn.OD[] -> objDesc[]
          #);
          'Repetition' -> findPredefinedDesc
          (#
          do ptn.OD[] -> repetitionDesc[]
          #);
       #);
  do (if doTrace then 
         '**** StdBetaChecker: '->puttext; newline;
         '**** topModule:' -> dumpTN; 
         (if topModule[] <> none then
             topModule.doPT -> putheadN;
             '------'->dumpTN
         if);
     if);
     topModule.setUpOrigin;
     findPredefinedDescs;
     topModule.check;
  #)
