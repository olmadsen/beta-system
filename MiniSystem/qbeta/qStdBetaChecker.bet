ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaTypes';
---LIB:attributes---
qStdBetaChecker: qStdBetaTypes
  (# StdBetaModule::<
       (# setUpOrigin::
            (#
            do (if false then
                   'StdBetaModule:setUpOrigin:'->dumpT;
                   (if origin[] <> none then
                       origin.label -> dumpT;
                    else
                       '-none-'->dumpT
                   if);
                   moduleName.doPT->dumpTN;
               if);
               origin[] -> frags.setUpOrigin;
               true -> done
            #);
       #);
     BetaFragments::<
       (# setUpOrigin::
            (#do (*'BetaFragments:setUpOrigin:'->traceCheckN;*)
               scanSons(#do origin[] -> current.setUpOrigin #);
               true -> done
            #);
          check::
            (# 
            do (if traceChecker then 
                   'BetaFragments:check:'->traceCheckN;
               if)
            #)
       #);
     AttFrag::<
       (# setUpOrigin::
            (#
            do (if false then
                   '**** AttFrag:setUpOrigin:'->dumpT; dopt -> putheadN;
               if);
               att.scanSons(#do origin[] -> current.setUpOrigin #);
               true -> done
            #);
          check::
            (#
            do (if traceChecker then 
                   'AttFrag:check:'->traceCheckN;
               if)
            #);
       #);
     ObjDescFrag::<
       (# setUpOrigin::
            (#
            do (*'**** ObjDescFrag:setUpOrigin:'->dumpT; dopt->putheadN;*)
               (if true then
                   origin[] -> OD.setUpOrigin; 
                   true -> done
                else
                   OD.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (#
            do (if traceChecker then 'ObjDescFrag:check:'->traceCheckN; if);
               OD.check; true -> done
            #);
          theDesc::
            (#
            do OD[] -> aDesc[]
            #);
       #);
     DoPartFrag::<
       (# setUpOrigin::
            (#
            do (*'DoPartFrag:setUpOrigin:'->traceCheckN*)
               DP.scanSons(#do origin[] -> current.setUpOrigin #);
               origin[] -> DP.setUpOrigin;
               true -> done
            #);
          check::
            (#
            do (if traceChecker then 'DoPartFrag:check:'->traceCheckN; if)
            #);
       #);
     Attributes::<
       (# setUpOrigin::
            (#
            do (*'Attributes:setUpOrigin'->traceCheckN; *)
               (if false then doPT -> putHeadN if)
            #);
          check::
            (#
            do (if traceChecker then 'Attributes:check:'->traceCheckN; if);
            #);
          localSearch::
            (#
            do (if false then
                   '**** Attributes.localSearch:'->traceCheck; 
                   NA.T[]->traceCheckN;
               if);
               loop:
                 scanSons
                 (#
                 do NA[] -> current.localSearch -> (dcl[],pn);
                    (if dcl[] <> none then
                        leave Loop
            if)#)#)
       #);
     AttSlot::<
       (# setUpOrigin::
            (# OD: ^ObjectDesc
            do (if false then
                    'AttSlot:setUpOrigin:'->dumpT; doPT -> dumpTN;
                    (if origin[] = none then 
                        'Origin is none:'->dumptn
                     else
                        origin.dopt -> putheadN
               if)if);
               scanBindings(#do origin[] -> current.setUpOrigin #);
               (* origin may be a forImp - must be handled!!! *)
               (if false and (origin[] = none) then
                   '*** origin is none'->dumpT; dopt -> dumpTN;
                   father.father.dopt -> putheadN
                else
                   this(AttSlot)[] -> (origin[]->OD[]).attSlots.add
               if)
            #);
          check::
            (#
            do (if traceChecker then
                   'AttSlot:Check:'->traceCheck; doPT -> traceCheckN;
               if);
               scanBindings
               (#
               do current.check
               #)
            #);
       #);
     ObjDescSlot::<
       (# setUpOrigin::
            (#
            do (*'ObjDescSlot:setUpOrigin:'->dumpT; doPT -> dumpTN; *)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
          check::
            (#
            do (if traceChecker then
                   'ObjDescSlot:Check:'->traceCheck; doPT -> traceCheckN;
               if);
               scanBindings
               (#
               do current.check
            #)#);               
          theDesc::
            (# ODF:  ^ObjDescFrag;
            do scanBindings(#do (current[]->ODF[]).OD[] -> aDesc[] #);
            #)
       #);
     DoPartSlot::<
       (# setUpOrigin::
            (#
            do (*'DoPartSlot:setUpOrigin:'->traceCheck;doPT -> traceCheckN*)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
          check::
            (#
            do (if traceChecker then
                   'DoPartSlot:Check:'->traceCheck; doPT -> traceCheckN;
               if);
               scanBindings
               (#
               do current.check
            #)#);   
       #);
     BetaDecl::<
       (# setUpOrigin::
            (#
            do (*'BetaDecl:setUpOrigin:'->dumpT; dopt -> putHeadN;;*)
               this(BetaDecl)[] -> NS.addDclRef;
               NS[] -> IT.NS[]
            #);
          check::
            (#
            do (if traceChecker then 'BetaDecl:check:'->dumptn if);
            #);
          theDesc::
            (#
            do IT.theDesc -> aDesc[]
            #);
          exitType::
            (#
            do (*'**** Decl:exitType:'->dumpT; IT.label -> dumpT; IT.doPT->dumpTN;*)
               IT.exitType -> TP[]
            #);
          localSearch::
            (#
            do NA[] -> NS.localSearch -> (dcl[],pn)
            #);
       #);
     NameDecls::
       (# theDesc::
            (# ND: ^BetaNameDecl
            do L:
                 scanSons(#do current[] -> ND[]; leave L #);
               ND.theDesc -> aDesc[];
            #);
          addDclRef:
            (# dcl: ^BetaDecl; ND: ^BetaNameDecl
            enter dcl[]
            do scanSons(#do dcl[] -> (current[]->ND[]).theDcl[] #); 
            #);
          localSearch::
            (#
            do loop:
                 scanSons
                 (# pn: @integer
                 do NA[]->current.localSearch-> (dcl[],pn);
                    (if dcl[] <> none then
                        leave loop
            if)#)#)
       #);
     BetaNameDecl::<
       (# theDesc::
            (#
            do theDcl.theDesc -> aDesc[]
            #);
          localSearch::
            (#
            do (if NA.T[] -> N.T.equalNCS then
                   (* '**** NameDecl:found:'-> traceCheck; 
                    * NA.T[]->traceCheckN;*)
                   (if theDcl[] = none then
                       '!!!! theDcl is none: '->dumpT; label -> dumpT;
                       dopt -> dumpTN;
                       '!!   searching:'->dumpT; NA.T[] -> dumpTN;
                   if);
                   this(BetaNameDecl)[] -> dcl[];
            if)#);
          exitType::
            (#
            do (*'**** NameDecl:'->dumpT; theDcl.label -> dumpT; 
               theDcl.dopt -> dumpTN;*)
               theDcl.exitType -> TP[]
            #);
               
          theDcl: ^BetaDecl
       #);
     StaticItem::<
       (# setUpOrigin:: (#do  NS[] -> OS.NS[] #);
          check::
            (#
            do (*'StaticItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #);
          
          exitType::
            (#
            do (*'**** StaticItem:'->dumpT; OS.label -> dumpT; 
               OS.dopt -> dumpTN;*)
               OS.exitType -> TP[]
            #);
       #);
     DynamicItem::<
       (# check::
            (#
            do (*'DynamicItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #);
          exitType::
            (#
            do (*'**** DynamicItem:'->dumpT; OS.label -> dumpT; 
               OS.dopt -> dumpTN;*)
               OS.exitType -> TP[]
            #);
       #);
     Repetition::<
       (# check:: 
            (#do (*'Repetition:check:'->traceCheck; dopt -> traceCheck*) #);
          theDesc::
            (#
            do repetitionDesc[] -> aDesc[]
            #);
       #);
     Index::< (# #);
     VarPtn::<
       (# check::
            (#
            do AD.check
            #);
          theDesc::
            (#
            do AD.theDesc -> aDesc[]
            #)
       #);
     BetaPattern::<
       (# setUpOrigin::
            (#
            do NS[] -> OD.NS[]
            #);
          check::
            (#
            do (*'BetaPattern:check:'->traceCheckN;*)
            #);
          theDesc:: (# do OD[] -> aDesc[] #);
          exitType::
            (#
            do (*'**** PTN:exitType:'->dumpT; isprimitive -> putboolean;
                ' ' -> put; dopt -> putHeadN;*)
               OD[] -> value_type -> TP[]
            #);
       #);
     BetaVirtualPattern::<
       (# setUpOrigin:: (#do NS[] -> OS.NS[] #);
          check::
            (#
            do (if traceChecker then 
                   'BetaVirtualPattern:check:'->traceCheckN if);
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# 
            do OS.theDesc -> aDesc[] 
            #);
       #);
     handleBinding:
       (# VB: ^VirtualBinding;
       enter VB[]
       do (if false then
              VB.NS.dopt -> putline;
              VB.doPT -> putline;
          if);
          VB.NS.scanSons
          (# ND: ^BetaNameDecl; ATd: ^BetaNameDecl; pn,on: @integer
          do current[] -> ND[];
             ND.N[] -> VB.origin.superSearch -> (ATd[],pn);
             (if false then
                 '**  the binding:'->putline;
                 ND.theDcl.dopt -> putline;
             if);
             (if ATd[] <> none then
                 (if ATd.theDcl.IT.isVirtualPtn then
                     ATd.theDesc -> VB.OS.setImplicitSuper; (* case 1 *)
                     (if false then '**   the virtual:'->putline; if);
                     ATd.theDcl.NS[] -> VB.superNS[];
                  else
                     VB.father[] -> SemanticError
                     (#
                     do 'The declaration matching the above virtual binding'
                          -> msg;
                        ' is not virtual:\n'-> msg;
                        ATd.dopt -> msg
                 #)if);
                 ATd[] -> VB.vDcl[];
                 (if false then ATd.dopt -> putline if)
              else
                 VB.father[] -> SemanticError
                 (#
                 do 'No corresponding virtual found for the above binding '
                      -> msg;
                 #);
             if);
             (if false then newline if);
             (if traceChecker then 'handleBinding:end'-> dumptn if);
          #)
       #);          
     FurtherBinding::<
       (# setUpOrigin:: (#do NS[] -> OS.NS[] #);
          check::
            (#
            do (if traceChecker then
                   'FurtherBinding:check:'->dumpTN;
               if);
               this(FurtherBinding)[] -> handleBinding
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# do OS.theDesc -> aDesc[] #);
       #);
     FinalBinding::<
       (* 1: V:: A
        * 2: V:: A(# ... #)
        * 3: V:: (# ... #) - an implicit super
        *)
       (# setUpOrigin:: (#do NS[] -> OS.NS[] #);
          check::
            (# ATd: ^BetaDecl; pn,on: @integer
            do (if traceChecker then
                   'FinalBinding:check:'->dumpTN;
               if);
               this(FinalBinding)[] -> handleBinding
            #);
          theDesc:: (# do OS.theDesc -> aDesc[] #);
       #);
     ObjectDesc::<
       (# setUpOrigin::
            (#
            do (if false then
                   'ObjectDesc:setUpOrigin:'->dumpT; 
                   (if (origin[] = none) then
                       'origin=none:'->dumpTN
                   if);
                   dopt -> putheadN
               if);
               (if slt[] <> none then
                   origin[] -> slt.setUpOrigin
                else
                   origin[] -> sup.setupOrigin; 
                   this(ObjectDesc)[] -> att.setUpOrigin;
                   this(ObjectDesc)[] -> acp.setUpOrigin;
               if);
               true -> done;
            #);
          check::
            (#
            do (if false then
                   '**** ObjectDesc:check:'->traceCheck; 
                   ' sup:'->dumpT; sup.label->dumpTN; dopt -> putHeadN;
               if);
               (if slt[] = none then
                   sup.check;
                   sup.theDesc -> superDesc[];
                   (if superDesc[] = objDesc(*superObject*)[] then
                       none -> superDesc[]
                    else
                       (if (superDesc[] <> none) and (superDesc.att[] = none) 
                           then 
                           none -> superDesc[] (* hack ???*)
                       if);
                   if);
                   isSimple or sup.isExternal -> isSimple; (* ??? *)
                   (if false then
                       '**   isSimple:'-> dumpT; sup.isExternal->putboolean; 
                       ' '->put; isSimple->putBoolean; newline
                   if)
                else
                   slt.scanBindings
                   (# ODF:  ^ObjDescFrag
                   do (current[]->ODF[]).OD.check; 
                      (*'binding:'->dumpt; aDesc.dopt->putheadn *)
               #)if);
               (if false and (superDesc[] <> none) then
                   '**** got super:'->dumpT; dopt -> putHeadN
               if);
            #);
          theDesc::
            (#
            do (if slt[] <> none then
                   (*'**** objDesc:theDesc:slot:'->dumpT; dopt -> dumpT;*)
                   slt.scanBindings
                   (# ODF:  ^ObjDescFrag
                   do (current[]->ODF[]).OD[] -> aDesc[]; 
                      (*'binding:'->dumpt; aDesc.dopt->putheadn *)
                   #);
                   (if aDesc[] = none then 
                       (* probably no binding of slot 
                        * we dont handle default in MDbody
                        *)
                       objDesc[] -> aDesc[]
                   if)
                else
                   this(ObjectDesc)[] -> aDesc[]
               if)
            #);
          nxType:
            (# TP,supTP: ^type
            enter TP[]
            do (if false then
                   '**** nxType:'->dumpT;
               if);
               (if isPrimitive then (if false then 'primitive:'->dumpT; if);
                   (if this(objectDesc)[]
                    // integerDesc[] then
                       integerDesc[] -> value_type -> TP[]
                    // charDesc[] then
                       charDesc[] -> value_type -> TP[]
                    // booleanDesc[] then
                       booleanDesc[] -> value_type -> TP[]
                    else
                       '!!!! nxType:primitive:no match:'->dumpTN;
                       dopt -> putheadN;
                   if)
                else  (if false then 'NOT primitive:'->dumpT; if);
                   (if not isChecked then
                       ('objectDesc:ncType:notChecked',doPT) -> LG.TTn;
                       check (* we may enter a recursive loop
                              * we should fetch the N/X-part 
                              *)
                   if);
                   inner;
                   (if false then
                       doPT -> putline;
                       'superType: ' -> puttext;
                       (if supTP[] <> none then supTP.print -> putline if);
                       'mainType:' -> puttext;
                       (if (TP[] <> none) then
                           TP.print -> putline;
                        else
                           'none' -> putline
                   if)if);
                   (if supTP[] <> none then
                       TP[] -> supTP.append -> TP[]
                   if);
                   (if false then
                       'All: ' -> puttext; 
                       (if TP[] <> none then TP.print -> putline 
                   if)if)
               if)
            exit TP[]
            #);
          enterType:: 
            (# supTP: ^type; 
            do (if false then 'enterType:'->puttext; doPT -> putline; if);
               TP[] -> nxType
               (#
               do sup.enterType -> supTP[];
                  acp.enterType -> TP[]
               #) -> TP[]
            #);
          exitType:: 
            (# 
            do (if false then 
                   '\n**** ObjectDesc:exitType:'->dumpT; doPT->putHeadN 
               if);
               TP[] -> nxType
               (#
               do sup.exitType -> supTP[];
                  acp.exitType -> TP[];
               #) -> TP[];
               (if false then
                   (if(tp[] <> none) then
                       '**   ObjDesc:exitType:got:' -> dumpT; TP.print
                    else
                       '**   TP is none'->dumptn
               if)if)
            #);
          topSuper:
            (# topDesc: ^ObjectDesc
            do (if (superDesc[] <> none) and (superDesc[] <> objDesc[]) then
                   superDesc.TopSuper -> topDesc[]
                else
                   this(ObjectDesc)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          scanDecls:
            (#
            do (* remember labels and forImpIndex *)
               att.scanSons
               (#
               do
               #)
            #);
          superSearch::
            (# aDesc: ^ObjectDesc
            do (if (sup.theDesc -> aDesc[]) <> none then
                   NA[] -> aDesc.localSearch -> (dcl[],pn);
                   (if dcl[] <> none then
                       pn + 1 -> pn;
                       (*'**   found in super: ->dumpT';NA.dopt->dumpTN*)
               if)if)
            #);
          localSearch::
            (# aDesc:  ^ObjectDesc
            do NA[] -> att.localSearch -> (dcl[],pn);
               (if dcl[] = none then
                   NA[] -> superSearch -> (dcl[],pn);
               if);
               (if dcl[] = none then
                   NA[] -> attSlots.search -> (dcl[],pn);
                   (if false and (dcl[] <> none) then
                       '**** found:in:slots:'->dumpT; NA.dopt -> dumpTN;
               if)if)
            #);
          search::
            (# 
            do (if false then
                   'ObjDesc:Search:' -> traceCheckN;
               if);
               (if NA.T.length > 0 then 
                   (if false then
                       '**** Search:' -> traceCheck; NA.T[] -> traceCheckN;
                       '**   in:' -> traceCheckN;
                       doPT -> putHeadN;
                   if);
                   (if slt[] <> none then
                       '**** ObjectDesc:isSlot:'->dumpt;
                       slt.scanBindings
                       (# od: ^ObjectDesc; ODF:  ^ObjDescFrag
                       do (current[]->ODF[]).OD[] -> od[];
                          NA[] -> od.localSearch -> (dcl[],pn);
                       #)
                    else
                       NA[] -> localSearch -> (dcl[],pn);
                   if);
                   (if dcl[] = none then
                       (if origin[] <> none then
                           NA[] -> origin.search -> (dcl[],pn,on);
                           on + 1 -> on
            if)if)if)#);
          attSlots: @
            (# aSlots: [3] ^AttSlot; top: @integer; trace: (#exit false #);
               anAttSlot: ^AttSlot;
               add:
                 (#
                 enter anAttSlot[]
                 do (if (top + 1 -> top) > aSlots.range then
                        aSlots.range -> aSlots.extend
                    if);
                    (if trace then
                        '**** added slot: ' -> dumpt; anAttSlot.dopt -> dumptn;
                        '**   in: ' -> dumptn; dopt -> putheadN;
                    if);
                    anAttSlot[] -> aSlots[top][]
                 #);
               scan:
                 (# current: ^Attributes;
                 do (for i: top repeat
                         aSlots[i].scanBindings
                         (# anAttFrag: ^AttFrag;
                         do (if trace then
                                '**   binding:'->dumpT; current.dopt -> dumpTN;
                            if);
                            (current[]->anAttFrag[]).att[] 
                              -> this(scan).current[]; 
                            inner scan
                         #)
                    for)
                 #);
               search:
                 (# NA: ^Name; dcl: ^BetaNameDecl; pn: @integer
                 enter NA[]
                 do (if trace and (top > 0) then
                        '**** attSlots:search:'->dumpT; NA.dopt -> dumpTN;
                        print;
                        '----'->dumptn;
                    if);
                    L:
                      scan
                      (#
                      do NA[] -> current.localSearch -> (dcl[],pn);
                         (if dcl[] <> none then
                             (if trace then
                                 '**   attSlots:found:'->dumpT; NA.dopt->dumpTN;
                             if);
                             leave L
                      if)#)
                 exit(dcl[],pn)
                 #);
               print:
                 (#
                 do (for i: top repeat aSlots[i].dopt -> dumpTN for)
                 #)
            #);
       #);
     ActionPart::<
       (# check::
            (#
            do (*'ActionPart:check:'->traceCheckN;*)
              (* enterP.check;
               imps.check;
               exitP.check*)
            #);
          enterType:: (# do enterP.enterType -> TP[] #);
          exitType:: 
            (# 
            do (if exitP[] = none then
                  (* <<SLOT xxx:Descriptor>> *)
                   'exitP none '->dumpT; father.dopt -> dumpTN;
                   none_type -> tp[]
               else
                   exitP.exitType -> TP[];
               if)
            #);
       #);
     EnterPart::<
       (#
          check:: (# do (if eval[] <> none then Eval.check if) #);
          enterType:: (# do (if eval[] <> none then eval.enterType -> TP[] if)#)
       #);
     ExitPart::<
       (# 
          Check:: (# do (if eval[] <> none then Eval.check if) #);
          exitType:: (# do (if eval[] <> none then eval.exitType -> TP[] if)#)
       #);
     Imperatives::<
       (# check::
            (#
            do (*'Imperatives:check:'->traceCheckN;*)
            #);
       #);
     IfImp::<
       (# check::
            (#
            do (*'IfImp:check:'->traceCheckN;*)
            #)
       #);
     ForImp::<
       (# setUpOrigin::
            (#
            do (*'ForImp:setUpOrigin:'->dumpT; dopt -> dumpTN;*)
               origin[] -> inxDecl.setUpOrigin;
               origin[] -> rangee.setUpOrigin;
               this(ForImp)[] -> imps.setUpOrigin;
               true -> done
            #);
          check::
            (#
            do (if false then 'ForImp:check:'->dumpT; dopt -> dumpTN; if)
            #);
          search::
            (#
            do NA[] -> inxDecl.localSearch -> (dcl[],pn);
               (if dcl[] <> none then
                   (if false then
                       'ForImp:search:'->dumpT; NA.dopt -> dumpTN;
                       'in:' -> dumpTN; dopt -> dumpTN;
                       '**** found in forImp:'->dumpT; NA.dopt -> dumpTN; 
                   if);
                   (*inxDecl[] -> dcl[];*) 0 -> pn -> on;
                else
                   NA[] -> origin.search -> (dcl[],pn,on)
               if);
            #);
          theDesc::
            (#
            do 'ForImp:theDecl:missing Integer Desc'->traceCheck;
            #)
       #);
     LabelledImp::<
       (# setUpOrigin::
            (#
            do (if false then
                   'LabelledImp:setUpOrigin:'->dumpT; dopt -> putHeadN;
               if);
               origin[] -> lab.setUpOrigin;
               this(labelledImp)[] -> imp.setUpOrigin;
               true -> done
            #);
          search::
            (#
            do NA[] -> lab.localSearch -> (dcl[],pn);
               (if dcl[] <> none then
                   (if false then
                       'LabelledImp:search:'->dumpT; NA.dopt -> dumpTN;
                       'in:' -> dumpTN; dopt -> putHeadN;
                       '**** found in forImp:'->dumpT; NA.dopt -> dumpTN; 
                   if);
                   (*inxDecl[] -> dcl[];*) 0 -> pn -> on;
                else
                   NA[] -> origin.search -> (dcl[],pn,on)
               if);
            #)
       #);
     PatternDen::<
       (# check::
            (#
            do (*'PatternDen:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do AD.theDesc -> aDesc[]
            #);
          exitType::
            (#
            do (*'**** PatternDen:exitType:'->dumpT; AD.label->dumpT;
               AD.dopt->dumpTN;*)
               AD.exitType -> TP[]
            #);
          isThisBlockLevel: BooleanValue
            (#
            do (AD.noOfSons  = 1) and ((AD.lastDen).on = 1) -> value
            #);
       #);
     NameApl::<
       (# updateOrigin::
            (#
            do (*'**** NameApl:updateOrigin:'->dumpT; dopt -> dumpTN;
               org.dopt -> putheadN;*)
               org[] -> origin[] -> setUpOrigin
            #);
          check::
            (# dcl: ^BetaNAmeDecl; trace: @boolean
            do (*'syntaxErroar'->N.T.equalNCS -> trace;*)
               (if trace then
                   'NameApl:check:'->dumpT; doPT->dumpT;
                   (if origin[] = none then ' origin is none'-> dumpTN if);
                   origin.dopt -> putheadN;
               if);
               (if (N.T.length > 0) and not isSlot then 
                   (if trace then
                       '**** AD:Search:'->dumpT; N.T[]->dumpTN;
                   if);
                   (if origin[] <> none then
                       N[] -> origin.search -> (dcl[] -> ATd[],pn,on);
                       (if (dcl[] <> none) then
                           (if false then
                               '**** Found:'->traceCheck;
                               N.T[] -> traceCheck;
                               ' pn: ' -> traceCheck; pn -> putint;
                               ' on: ' -> traceCheck; on -> putint; newline
                           if)
                        else
                           this(NameApl)[] -> SemanticError
                           (#
                           do 'Did not find a declaration of: "'->msg;
                              N.dopt -> msg; '"'->msg
                           #);
                           (if N.father[] <> none then
                               N.father.dopt -> putheadN;
                           if);
                           '?'->Name->BetaNameDecl -> ATd[];
                           errorDecl[] -> ATd.theDcl[]
                       if)
                    else
                       (*'empty'->traceCheckN*)
               if)if);
               true -> done
            #);
          theDesc::
            (#
            do L:
                 (if ATd[] <> none then 
                     (*ATd.dopt->putHeadN; *)
                     ATd.theDesc -> aDesc[] 
                else
                     (if N.T.length > 0 then
                         (if not N.beingChecked and not N.isChecked then
                             (if false then
                                 '**** enforce:check:'->dumpT; dopt->putHeadN;
                                 (*father.father.dopt->putheadN;*)
                             if);
                             check;
                             restart L
                          else
                             '**** nameApl:theDecl:beingChecked:'->dumpT;
                             dopt -> dumpTN;
                             objDesc[] -> aDesc[]
                         if);
                    else
                       (if implicitSuperOD[] <> none then
                           (if false then 'theDesc:implicitSuper:'->dumptN; if);
                           implicitSuperOD[] -> aDesc[]
                        else
                           (if theEncOD <> objDesc[] then
                               objDesc[] -> aDesc[];
                               (if false then
                                   '**   return:objDesc:'->dumpTN; 
                                   aDesc.dopt->dumptn
                               if)
                            else
                               (if false then
                                   '**** theDesc:'->dumptN;dopt->dumpTN;
                                   '**   theEnc: ' -> dumpTN;
                                   (if theEncOD <> none then
                                       (theEncOD).dopt -> dumpt
                                    else
                                       'none'->dumptN;
                                   if);
                                   '**   objDesc: ' -> dumpTN;
                                   (if objDesc <> none then
                                       objDesc.dopt -> dumpt
                                    else
                                       'none'->dumptN;
                               if)if);
                               (*'**   return:none:in:objDesc'->dumpTN*)
            if)if)if)if)#);
          exitType::
            (#
            do (if not isEmpty then
                   (if false then
                       '**** NameApl:exitType:'->dumpT;dopt->dumpT;
                       ATd.label->dumpT; ATd.dopt -> dumpTN;
                   if);
                   ATd.exitType -> TP[];
               if)
            #);
          (*ATd: ^BetaNameDecl (*BetaDecl; *)
       #);
     ThisObject::<
       (# theDesc::
            (#
            do AD.theDesc -> aDesc[]
            #)
       #);
     Indexed::<
       (# updateOrigin::
            (#
            do org[] -> origin[] -> NA.origin[];
               (*'**** updateOrigin:'->dumpTN; origin.doPP->dumpTN;*)
            #);
          check::
            (#
            do (if false then
                   '**** Indexed:check:'->dumpT; dopt->dumpTN; doPP -> dumpTN;
                   '**** origin:'->dumpT; 
                   (if origin[] <> none then 
                       origin.doPT -> putHeadN else 'none'->dumptn 
               if)if);
               NA.check;
               EV.check;
               uE.check;
               NA.ATd[] -> ATd[];
               NA.on -> on
            #);
          theDesc:: 
            (# repItem: ^Repetition (* BetaPattern*)
            do (*'Indexed:theDesc:'->dumpT; dopt -> dumpTN;
               doPP -> dumpTN;*)
               (if ATd[] <> none then 
                   (*'aaaa'->dumptn;
                   ATd.doPP -> dumpTN;
                   'aaaaX'->dumptn;
                   ATd.theDcl.doPP -> dumpTN;*)
                   ATd.theDcl.IT[] -> repItem[];

                   repItem.IT.theDesc -> aDesc[] 
               if);
            #);

       #);
     Remote::<
       (# setUpOrigin::
            (#
            do (*'Remote:setUpOrigin:'->traceCheck; dopt -> dumpTN;*)
            #);
          updateOrigin:: 
            (#  AD: ^AttributeDenotation
            do (*'**** Remote:updateOrigin:'->dumpT; dopt -> dumpTN;*)
               org[] -> origin[];
               scanSons(#do org[]-> (current[]->AD[]).updateOrigin#)
            #);
          Check::
            (# predDesc: ^ObjectDesc
            do (if false then
                   'Remote:check:'->dumpT; dopt -> dumpTN;
                   doPP -> dumpTN;
               if);
               scanSons
               (# AD: ^AttributeDenotation
               do (if not isFirst then
                      predDesc[] -> (current[]->AD[]).UpdateOrigin
                  if);
                  (current[]->AD[]).check;
                  AD.theDesc -> predDesc[];
                  (if false then
                      '**   AD.theDesc:'->dumpT; predDesc.dopt -> putheadN;
                  if)
            #)#);
          theDesc::
            (#
            do (if false then
                   '**** Remote:theDesc:'->dumpT; doPT -> dumpTN;
               if);
               scanSons
               (# AD: ^AttributeDenotation
               do (if isFirst then
                      (if false then
                          '**   theDesc:'->dumptn;
                          (current.theDesc).doPT -> putheadN;
                      if)
                   else
                      (if false then
                          '**   tail:'->dumpTN;
                          ((current[]->AD[]).theDesc).dopt -> putheadN;
                      if);
                      (current[]->AD[]).theDesc -> aDesc[]
            if)#)#)
       #);
     
     BetaTerm::<
       (# exitType::
            (#
            do (*'**** BetaTerm:exitType:'->dumpT; T.label->dumpT; T.dopt->dumpTN;*)
               T.exitType -> TP[]
            #)
       #);
     ObjectReference::<
       (# theDesc::
            (#
            do OV.theDesc -> aDesc[]
            #);
          exitType::
             (#
             do (*'**** ObjectReference:exitType:'->dumpT; OV.label->dumpT;
                OV.dopt->dumpTN;*)
                OV.theDesc -> ref_type -> TP[]
             #)
       #);
     ObjectEvaluation::<
       (# theDesc:: (# do OS.theDesc -> aDesc[] #);
          exitType::
             (#
             do (*'**** ObjectEvaluation:exitType:'->dumpT; OS.label->dumpT;
                OS.dopt->dumpTN;*)
                OS.exitType -> TP[]
             #)
       #);
     DynamicObjectGeneration::<
       (# check::(#do (*'**** DynObjGen:check:'->dumpT; dopt->dumpTN;*) #);
          theDesc:: (#do OS.theDesc -> aDesc[] #);
          exitType::
            (#
            do (if isRef then
                   OS.theDesc -> ref_type -> TP[] 
                else
                   (OS.theDesc).exitType -> TP[]
               if);
               (* not correct - here we have &P
                * we need to go into the descriptor - only ref if &P[]
                *)
            #)
       #);
     findPredefinedDesc:
       (# descName: ^Text; dcl:  ^BetaNameDecl; ptn:  ^BetaPattern
       enter descName[]
       do (if false then
              'findPredefinedDesc:'->dumpT; descName[] -> dumpT;
              ' in topModule:'-> dumpT; topModule.label -> dumpTN;
              topModule.doPT -> putheadN;
          if);
          topModule.frags.scanSons
          (# i: @integer; objFrag: ^ObjDescFrag; 
             att: ^Attributes;  pn: @integer
          do (*current.label -> dumpTN;*)
             (if (i + 1 -> i) = 1 then
                 (current[]->objFrag[]).OD.att[] -> att[];
                 descName[] -> Name -> att.localSearch -> (dcl[],pn);
                 (if dcl[] <> none then 
                     (if false then
                         dcl.label->dumpT; 
                         dcl.doPT -> dumpTN;
                     if);
                     dcl.theDcl.IT[] -> ptn[];
                     inner findPredefinedDesc;
                  else
                     '\n!!!! Compiler error: "'->puttext;
                     descName[] -> puttext;
                     '" pattern not found in betaenv'->putline
                 if);
              else
                 '\n!!!! Potential compiler problem:'->putline;
                 '!!   More than one fragment in betaenv'->putline;
       if)#)#);
     findPredefinedDescs:
       (#
       do 'Object' -> findPredefinedDesc
          (#
          do ptn.OD[] -> objDesc[]
          #);
          'Repetition' -> findPredefinedDesc
          (#
          do ptn.OD[] -> repetitionDesc[]
          #);
          'errorName'->findPredefinedDesc(#do dcl.theDcl[] -> errorDecl[] #);
       #);
     markPrimitiveDescs:
       (#
       do topModule.frags.scanSons
          (# OD: ^ObjectDesc; objFrag: ^ObjDescFrag; ptn: ^BetaPattern
          do (*'**** markPrimitives'->dumpt; current.label -> dumptN;*)
             (current[] -> objFrag[]).OD[] -> OD[];
             OD.att.scanSons
             (# dcl: ^BetaDecl
             do (*'**   dcl:'->dumpt; current.label -> dumptn;*)
                (if current## = BetaDecl## then
                    current[] -> dcl[];
                    dcl.NS.scanSons
                    (# N: ^BetaNameDecl;
                    do current[] -> N[];
                       (if true
                        // 'integer' -> N.N.T.equalNCS then
                           true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive;
                           dcl.IT[]->ptn[]; ptn.OD[]->integerDesc[]
                        // 'int32' -> N.N.T.equalNCS then
                           true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive
                        // 'char' -> N.N.T.equalNCS then
                           true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive;
                           dcl.IT[]->ptn[]; ptn.OD[]->charDesc[]
                        // 'boolean' -> N.N.T.equalNCS then
                           true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive;
                           (dcl.IT[]->ptn[]).OD[] -> booleanDesc[]
                        // 'trueValue' -> N.N.T.equalNCS then
                           (* true -> dcl.isPrimitive; *)
                           (*dcl.IT.setPrimitive*)
                        // 'falseValue' -> N.N.T.equalNCS then
                           (*true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive*)
                        // 'false' -> N.N.T.equalNCS then
                           (*true -> dcl.isPrimitive; 
                            dcl.IT.setPrimitive*)
                           dcl.IT.setSimple;
                           (dcl.IT[]->ptn[]).OD[] -> falseDesc[]
                        // 'true' -> N.N.T.equalNCS then
                           (*true -> dcl.isPrimitive; 
                            dcl.IT.setPrimitive*)
                           dcl.IT.setSimple;
                           (dcl.IT[]->ptn[]).OD[] -> trueDesc[]
                        // 'real' -> N.N.T.equalNCS then
                           true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive
                        // 'repetition' -> N.N.T.equalNCS then
                           (*true -> dcl.isPrimitive; 
                            dcl.IT.setPrimitive*)
                           (dcl.IT[]->ptn[]).OD[] -> repetitionDesc[]
          if)#)if)#)#)
       #);
     repetitionDesc,structureRefDesc, immutableDesc,
     integerDesc,charDesc,booleanDesc,falseDesc,trueDesc,textDesc,
     processEventDesc: ^ObjectDesc;
     
     SemanticError:
       (# msg:
            (# T: ^Text; 
            enter T[]
            do T[] -> puttext
            #);
          N: ^StdbetaNode
       enter N[]
       do '\n**** Semantic error:'->putline;
          N.dopt -> putline;
          inner;
          newline
       #);          
     checkStdBeta:
       (#
       do (if doTrace then 
              '**** StdBetaChecker: '->puttext; newline;
              '**** topModule:' -> dumpTN; 
              (if topModule[] <> none then
                  topModule.doPT -> putheadN;
                  '------'->dumpTN
              if);
          if);
          (*true -> traceChecker;*)
          topModule.setUpOrigin;
          findPredefinedDescs;
          markPrimitiveDescs;
          topModule.check;
       #);
  do 
     inner
  #)
