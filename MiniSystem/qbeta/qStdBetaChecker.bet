ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaParser';
---LIB:attributes---
qStdBetaChecker: parseStdBetaModule
  (# StdBetaModule::<
       (# setUpOrigin::
            (#
            do (if true then
                   'StdBetaModule:setUpOrigin:'->dumpT;
                   (if origin[] <> none then
                       origin.label -> dumpT;
                    else
                       '-none-'->dumpT
                   if);
                   moduleName.doPT->dumpTN;
               if);
               origin[] -> frags.setUpOrigin;
               true -> done
            #);
       #);
     BetaFragments::<
       (# setUpOrigin::
            (#do (*'BetaFragments:setUpOrigin:'->traceCheckN;*)
               scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (# 
            do (if traceChecker then 
                   'BetaFragments:check:'->traceCheckN;
               if)
            #)
       #);
     AttFrag::<
       (# setUpOrigin::
            (#
            do (*'AttFrag:setUpOrigin:'->traceCheckN;*)
               att.scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (if traceChecker then 
                   'AttFrag:check:'->traceCheckN;
               if)
            #);
       #);
     ObjDescFrag::<
       (# setUpOrigin::
            (#
            do (*'ObjDescFrag:setUpOrigin:'->traceCheck; *)
               OD.scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (if traceChecker then 'ObjDescFrag:check:'->traceCheckN; if)
            #);
       #);
     DoPartFrag::<
       (# setUpOrigin::
            (#
            do (*'DoPartFrag:setUpOrigin:'->traceCheckN*)
               DP.scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (if traceChecker then 'DoPartFrag:check:'->traceCheckN; if)
            #);
       #);
     Attributes::<
       (# setUpOrigin::
            (#
            do (*'Attributes:setUpOrigin'->traceCheckN; *)
               (if false then doPT -> putHeadN if)
            #);
          check::
            (#
            do (if traceChecker then 'Attributes:check:'->traceCheckN; if);
            #);
          localSearch::
            (#
            do (if false then
                   '**** Attributes.localSearch:'->traceCheck; 
                   NA.T[]->traceCheckN;
               if);
               loop:
                 scanSons
                 (#
                 do NA[] -> current.localSearch -> (dcl[],pn);
                    (if dcl[] <> none then
                        leave Loop
            if)#)#)
       #);
     AttSlot::<
       (# setUpOrigin::
            (#
            do (*'AttSlot:setUpOrigin:'->traceCheck; doPT -> traceCheckN;*)
               scanBindings(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (if traceChecker then
                   'AttSlot:Check:'->traceCheck; doPT -> traceCheckN;
               if);
               scanBindings
               (#
               do current.check
               #)
            #);
       #);
     ObjDescSlot::<
       (# setUpOrigin::
            (#
            do (*'ObjDescSlot:setUpOrigin:'->traceCheck; 
                * doPT -> traceCheckN;*)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
       #);
     DoPartSlot::<
       (# setUpOrigin::
            (#
            do (*'DoPartSlot:setUpOrigin:'->traceCheck;doPT -> traceCheckN*)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
       #);
     BetaDecl::<
       (# setUpOrigin::
            (#
            do (*'BetaDecl:setUpOrigin:'->dumpT; dopt -> dumpTN;*)
               this(BetaDecl)[] -> NS.addDclRef;
            #);
          check::
            (#
            do (if traceChecker then 'BetaDecl:check:'->dumptn if);
            #);
          theDesc::
            (#
            do IT.theDesc -> aDesc[]
            #);
          localSearch::
            (#
            do NA[] -> NS.localSearch -> (dcl[],pn)
            #);
       #);
     NameDecls::
       (# addDclRef:
            (# dcl: ^BetaDecl; ND: ^BetaNameDecl
            enter dcl[]
            do scanSons(#do dcl[] -> (current[]->ND[]).theDcl[] #); 
            #);
          localSearch::
            (#
            do loop:
                 scanSons
                 (# pn: @integer
                 do NA[]->current.localSearch-> (dcl[],pn);
                    (if dcl[] <> none then
                        leave loop
            if)#)#)
       #);
     BetaNameDecl::<
       (# localSearch::
            (#
            do (if NA.T[] -> N.T.equalNCS then
                   (* '**** NameDecl:found:'-> traceCheck; 
                    * NA.T[]->traceCheckN;*)
                   (if theDcl[] = none then
                       '!!!! theDcl is none'->dumpTN;
                   if);
                   theDcl[] -> dcl[];
            if)#);
          theDcl: ^BetaDecl
       #);
     StaticItem::<
       (# check::
            (#
            do (*'StaticItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #)
       #);
     DynamicItem::<
       (# check::
            (#
            do (*'DynamicItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #)
       #);
     Repetition::<
       (# check:: 
            (#do (*'Repetition:check:'->traceCheck; dopt -> traceCheck*) #);
          theDesc::
            (#
            do repetitionDesc[] -> aDesc[]
            #);
       #);
     BetaPattern::<
       (# check::
            (#
            do (*'BetaPattern:check:'->traceCheckN;*)
            #);
          theDesc:: (# do OD[] -> aDesc[] #);
       #);
     BetaVirtualPattern::<
       (# check::
            (#
            do (if traceChecker then 
                   'BetaVirtualPattern:check:'->traceCheckN if);
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# 
            do OS.theDesc -> aDesc[] 
            #);
       #);
     handleBinding:
       (# VB: ^VirtualBinding;
       enter VB[]
       do (if false then
              VB.NS.dopt -> putline;
              VB.doPT -> putline;
          if);
          VB.NS.scanSons
          (# ND: ^BetaNameDecl; ATd: ^BetaDecl; pn,on: @integer
          do current[] -> ND[];
             ND.N[] -> VB.origin.superSearch -> (ATd[],pn);
             (if false then
                 '**  the binding:'->putline;
                 ND.theDcl.dopt -> putline;
             if);
             (if ATd[] <> none then
                 (if ATd.IT.isVirtualPtn then
                     ATd.theDesc -> VB.OS.setImplicitSuper; (* case 1 *)
                     (if false then '**   the virtual:'->putline; if);
                     ATd.NS[] -> VB.superNS[];
                  else
                     VB.father[] -> SemanticError
                     (#
                     do 'The declaration matching the above virtual binding'
                          -> msg;
                        ' is not virtual:\n'-> msg;
                        ATd.dopt -> msg
                 #)if);
                 (if false then ATd.dopt -> putline if)
              else
                 VB.father[] -> SemanticError
                 (#
                 do 'No corresponding virtual found for the above binding '
                      -> msg;
                 #);
             if);
             (if false then newline if);
             (if traceChecker then 'handleBinding:end'-> dumptn if);
          #)
       #);          
     FurtherBinding::<
       (# check::
            (#
            do (if traceChecker then
                   'FurtherBinding:check:'->dumpTN;
               if);
               this(FurtherBinding)[] -> handleBinding
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# do OS.theDesc -> aDesc[] #);
       #);
     FinalBinding::<
       (* 1: V:: A
        * 2: V:: A(# ... #)
        * 3: V:: (# ... #) - an implicit super
        *)
       (# check::
            (# ATd: ^BetaDecl; pn,on: @integer
            do (if traceChecker then
                   'FinalBinding:check:'->dumpTN;
               if);
               this(FinalBinding)[] -> handleBinding
            #);
          theDesc:: (# do OS.theDesc -> aDesc[] #);
       #);
     ObjectDesc::<
       (# setUpOrigin::
            (#
            do (*'ObjectDesc:setUpOrigin'->traceCheck; label->traceCheckN*)
               origin[] -> sup.setupOrigin; 
               this(ObjectDesc)[] -> att.setUpOrigin;
               this(ObjectDesc)[] -> acp.setUpOrigin;
               true -> done;
            #);
          check::
            (#
            do (*'ObjectDesc:check:'->traceCheckN;*)
            #);
          theDesc::
            (#
            do this(ObjectDesc)[] -> aDesc[]
            #);
          scanDecls:
            (#
            do (* remember labels and forImpIndex *)
               att.scanSons
               (#
               do
               #)
            #);
          superSearch::
            (# aDesc: ^ObjectDesc
            do (if (sup.theDesc -> aDesc[]) <> none then
                   NA[] -> aDesc.localSearch -> (dcl[],pn);
                   (if dcl[] <> none then
                       pn + 1 -> pn;
                       (*'**   found in super: ->dumpT';NA.dopt->dumpTN*)
               if)if)
            #);
          localSearch::
            (# aDesc:  ^ObjectDesc
            do NA[] -> att.localSearch -> (dcl[],pn);
               (if dcl[] = none then
                   NA[] -> superSearch -> (dcl[],pn);
            if)#);
          search::
            (# 
            do (if false then
                   'ObjDesc:Search:' -> traceCheckN;
               if);
               (if NA.T.length > 0 then 
                   (if false then
                       '**** Search:' -> traceCheck; NA.T[] -> traceCheckN;
                       '**   in:' -> traceCheckN;
                       doPT -> traceCheckN;
                   if);
                   NA[] -> localSearch -> (dcl[],pn);
                   (if dcl[] = none then
                       (if origin[] <> none then
                           NA[] -> origin.search -> (dcl[],pn,on);
                           on + 1 -> on
            if)if)if)#);
       #);
     ActionPart::<
       (# check::
            (#
            do (*'ActionPart:check:'->traceCheckN;*)
              (* enterP.check;
               imps.check;
               exitP.check*)
            #)
       #);
     Imperatives::<
       (# check::
            (#
            do (*'Imperatives:check:'->traceCheckN;*)
            #);
       #);
     IfImp::<
       (# check::
            (#
            do (*'IfImp:check:'->traceCheckN;*)
            #)
       #);
     ForImp::<
       (# setUpOrigin::
            (#
            do (*'ForImp:setUpOrigin:'->dumpT; dopt -> dumpTN;*)
               origin[] -> inxDecl.setUpOrigin;
               origin[] -> rangee.setUpOrigin;
               this(ForImp)[] -> imps.setUpOrigin;
               true -> done
            #);
          check::
            (#
            do (if false then 'ForImp:check:'->dumpT; dopt -> dumpTN; if)
            #);
          search::
            (#
            do NA[] -> inxDecl.localSearch -> (dcl[],pn);
               (if dcl[] <> none then
                   (if false then
                       'ForImp:search:'->dumpT; NA.dopt -> dumpTN;
                       'in:' -> dumpTN; dopt -> dumpTN;
                       '**** found in forImp:'->dumpT; NA.dopt -> dumpTN; 
                   if);
                   inxDecl[] -> dcl[]; 0 -> pn -> on;
                else
                   NA[] -> origin.search -> (dcl[],pn,on)
               if);
            #);
          theDesc::
            (#
            do 'ForImp:theDecl:missing Integer Desc'->traceCheck;
            #)
       #);
     PatternDen::<
       (# check::
            (#
            do (*'PatternDen:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do AD.theDesc -> aDesc[]
            #);
       #);
     NameApl::<
       (# check::
            (# dcl: ^BetaDecl; pn,on: @integer
            do (if false then
                   'NameApl:check:'->traceCheck; doPT->traceCheckN;
               if);
               (if (N.T.length > 0) and not isSlot then 
                   (if false then
                       '**** AD:Search:'->traceCheck; N.T[]->traceCheckN;
                   if);
                   (if origin[] <> none then
                       N[] -> origin.search -> (dcl[] -> ATd[],pn,on);
                       (if (dcl[] <> none) then
                           (if false then
                               '**** Found:'->traceCheck;
                               N.T[] -> traceCheck;
                               ' pn: ' -> traceCheck; pn -> putint;
                               ' on: ' -> traceCheck; on -> putint; newline
                           if)
                        else
                           this(NameApl)[] -> SemanticError
                           (#
                           do 'Did not find a declaration of: "'->msg;
                              N.dopt -> msg; '"'->msg
                           #)
                       if)
                    else
                       'empty'->traceCheckN
               if)if);
               true -> done
            #);
          theDesc::
            (#
            do L:
                 (if ATd[] <> none then 
                     (*ATd.dopt->putHeadN; *)
                     ATd.theDesc -> aDesc[] 
                else
                   (if N.T.length > 0 then
                       '**** enforce:check:'->dumpT; dopt->putHeadN;
                       check;
                       restart L
                    else
                       (if implicitSuperOD[] <> none then
                           (if false then 'theDesc:implicitSuper:'->dumptN; if);
                           implicitSuperOD[] -> aDesc[]
                        else
                           (if theEncOD <> objDesc[] then
                               objDesc[] -> aDesc[];
                               (if false then
                                   '**   return:objDesc:'->dumpTN; 
                                   aDesc.dopt->dumptn
                               if)
                            else
                               (*'**   return:none:in:objDesc'->dumpTN*)
            if)if)if)if)#);
          ATd: ^BetaDecl
       #);
     Indexed::<
       (# theDesc:: 
            (#do (*'Indexed:theDesc:'->traceCheck; dopt -> traceCheckN*) #);
       #);
     Remote::<
       (# setUpOrigin::
            (#
            do (*'Remote:setUpOrigin:'->traceCheck; dopt -> dumpTN;*)
            #);
          Check::
            (# predDesc: ^ObjectDesc
            do (*'Remote:check:'->traceCheck; dopt -> dumpTN;*)
               scanSons
               (# AD: ^AttributeDenotation
               do (*current.doPT -> dumpTN;*)
                  (if not isFirst then
                      predDesc[] -> current.setUpOrigin
                  if);
                  (current[]->AD[]).check;
                  AD.theDesc -> predDesc[]
            #)#);
       #);
     findPredefinedDesc:
       (# descName: ^Text;  ptn:  ^BetaPattern
       enter descName[]
       do (if false then
              'findPredefinedDesc:'->dumpT; descName[] -> dumpT;
              ' in topModule:'-> dumpT; topModule.label -> dumpTN;
              topModule.doPT -> putheadN;
          if);
          topModule.frags.scanSons
          (# i: @integer; objFrag: ^ObjDescFrag; 
             att: ^Attributes; dcl:  ^BetaDecl; pn: @integer
          do (*current.label -> dumpTN;*)
             (if (i + 1 -> i) = 1 then
                 (current[]->objFrag[]).OD.att[] -> att[];
                 descName[] -> Name -> att.localSearch -> (dcl[],pn);
                 (if dcl[] <> none then 
                     (if false then
                         dcl.label->dumpT; dcl.IT.label -> dumpTN;
                         dcl.doPT -> dumpTN;
                     if);
                     dcl.IT[] -> ptn[];
                     inner findPredefinedDesc;
                  else
                     '\n!!!! Compiler error: "'->puttext;
                     descName[] -> puttext;
                     '" pattern not found in betaenv'->putline
                 if);
              else
                 '\n!!!! Potential compiler problem:'->putline;
                 '!!   More than one fragment in betaenv'->putline;
       if)#)#);
     findPredefinedDescs:
       (#
       do 'Object' -> findPredefinedDesc
          (#
          do ptn.OD[] -> objDesc[]
          #);
          'Repetition' -> findPredefinedDesc
          (#
          do ptn.OD[] -> repetitionDesc[]
          #);
       #);
     markPrimitiveDescs:
       (#
       do topModule.frags.scanSons
          (# OD: ^ObjectDesc; objFrag: ^ObjDescFrag;
          do '**** markPrimitives'->dumpt; current.label -> dumptN;
             (current[] -> objFrag[]).OD[] -> OD[];
             OD.att.scanSons
             (# dcl: ^BetaDecl
             do (*'**   dcl:'->dumpt; current.label -> dumptn;*)
                (if current## = BetaDecl## then
                    current[] -> dcl[];
                    dcl.NS.scanSons
                    (# N: ^BetaNameDecl;
                    do current[] -> N[];
                       (if true
                        // 'integer' -> N.N.T.equalNCS then
                           '** got integer'->dumptn;
                           true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive
                    if)#)
                if)
             #)
          #)
       #);
     SemanticError:
       (# msg:
            (# T: ^Text; 
            enter T[]
            do T[] -> puttext
            #);
          N: ^StdbetaNode
       enter N[]
       do '\n**** Semantic error:'->putline;
          N.dopt -> putline;
          inner;
          newline
       #);          
          
  do (if doTrace then 
         '**** StdBetaChecker: '->puttext; newline;
         '**** topModule:' -> dumpTN; 
         (if topModule[] <> none then
             topModule.doPT -> putheadN;
             '------'->dumpTN
         if);
     if);
     topModule.setUpOrigin;
     findPredefinedDescs;
     markPrimitiveDescs;
     topModule.check;
     inner
  #)
