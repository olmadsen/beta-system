ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaParser';
---LIB:attributes---
qStdBetaChecker: parseStdBetaModule
  (# StdBetaModule::
       (# setUpOrigin::
            (#
            do (if true then
                   'StdBetaModule:setUpOrigin:'->dumpT;
                   moduleName.doPT->dumpTN;
               if);
               origin[] -> frags.setUpOrigin;
               true -> done
            #);
       #);
     BetaFragments::<
       (# setUpOrigin::
            (#do (*'BetaFragments:setUpOrigin:'->traceCheckN;*)
               scanSons(#do origin[] -> current.setUpOrigin#)
            #);
          check::
            (# 
            do (*'BetaFragments:check:'->traceCheckN;*)
            #)
       #);
     AttFrag::<
       (# setUpOrigin::
            (#
            do (*'AttFrag:setUpOrigin:'->traceCheckN;*)
               att.scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (*'AttFrag:check:'->traceCheckN;*)
            #);
       #);
     ObjDescFrag::<
       (# setUpOrigin::
            (#
            do (*'ObjDescFrag:setUpOrigin:'->traceCheck; 
                * theName.dopt->dumpTN*)
               OD.scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (*'ObjDescFrag:check:'->traceCheckN;*)
            #);
       #);
     DoPartFrag::<
       (# setUpOrigin::
            (#
            do (*'DoPartFrag:setUpOrigin:'->traceCheckN*)
               DP.scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (*'DoPartFrag:check:'->traceCheckN;*)
            #);
       #);
     Attributes::<
       (# setUpOrigin::
            (#
            do (*'Attributes:setUpOrigin'->traceCheckN; *)
               (if false then doPT -> putHeadN if)
            #);
          check::
            (#
            do (*'Attributes:check:'->traceCheckN;*)
            #);
          localSearch::
            (#
            do (if false then
                   '**** Attributes.localSearch:'->traceCheck; 
                   NA.T[]->traceCheckN;
               if);
               loop:
                 scanSons
                 (#
                 do NA[] -> current.localSearch -> (dcl[],pn);
                    (if dcl[] <> none then
                        leave Loop
            if)#)#)
       #);
     AttSlot::
       (# setUpOrigin::
            (#
            do (*'AttSlot:setUpOrigin:'->traceCheck; doPT -> traceCheckN;*)
               scanBindings(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do scanBindings
               (#
               do current.check
               #)
            #);
       #);
     ObjDescSlot::
       (# setUpOrigin::
            (#
            do (*'ObjDescSlot:setUpOrigin:'->traceCheck; 
                * doPT -> traceCheckN;*)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
       #);
     DoPartSlot::
       (# setUpOrigin::
            (#
            do (*'DoPartSlot:setUpOrigin:'->traceCheck;doPT -> traceCheckN*)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
       #);
     BetaDecl::<
       (# setUpOrigin::
            (#
            do (*'BetaDecl:setUpOrigin:'->dumpT; dopt -> dumpTN;*)
               this(BetaDecl)[] -> NS.addDclRef;
            #);
          theDesc::
            (#
            do IT.theDesc -> aDesc[]
            #);
          localSearch::
            (#
            do NA[] -> NS.localSearch -> (dcl[],pn)
            #);
       #);
     NameDecls::
       (# addDclRef:
            (# dcl: ^BetaDecl; ND: ^BetaNameDecl
            enter dcl[]
            do scanSons(#do dcl[] -> (current[]->ND[]).theDcl[] #); 
            #);
          localSearch::
            (#
            do loop:
                 scanSons
                 (# pn: @integer
                 do NA[]->current.localSearch-> (dcl[],pn);
                    (if dcl[] <> none then
                        leave loop
            if)#)#)
       #);
     BetaNameDecl::
       (# localSearch::
            (#
            do (if NA.T[] -> N.T.equalNCS then
                   (* '**** NameDecl:found:'-> traceCheck; 
                    * NA.T[]->traceCheckN;*)
                   (if theDcl[] = none then
                       '!!!! theDcl is none'->dumpTN;
                   if);
                   theDcl[] -> dcl[];
            if)#);
          theDcl: ^BetaDecl
       #);
     StaticItem::<
       (# check::
            (#
            do (*'StaticItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #)
       #);
     DynamicItem::<
       (# check::
            (#
            do (*'DynamicItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #)
       #);
     Repetition::<
       (# check:: 
            (#do (*'Repetition:check:'->traceCheck; dopt -> traceCheck*) #);
          theDesc::
            (#
            do repetitionDesc[] -> aDesc[]
            #);
       #);
     BetaPattern::<
       (# check::
            (#
            do (*'BetaPattern:check:'->traceCheckN;*)
            #);
          theDesc:: (# do OD[] -> aDesc[] #);
       #);
     BetaVirtualPattern::
       (# check::
            (#
            do (*'BetaVirtualPattern:check:'->traceCheckN;*)
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# 
            do OS.theDesc -> aDesc[] 
            #);
       #);
     FurtherBinding::
       (# check::
            (#
            do 'FurtherBinding:check:'->traceCheckN;
               NS.dopt -> traceCheckN;
               doPT -> traceCheckN
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# 
            do OS.theDesc -> aDesc[] 
            #);
       #);
     FinalBinding::
       (* 1: V:: A
        * 2: V:: A(# ... #)
        * 3: V:: (# ... #) - an implicit super
        *)
       (# check::
            (# ATd: ^BetaDecl; pn,on: @integer
            do 'FinalBinding:check:'->traceCheck;
               NS.dopt -> traceCheckN;
               doPT -> traceCheckN;
               NS.scanSons
               (# ND: ^BetaNameDecl;
               do current[] -> ND[];
                  ND.N[] -> origin.superSearch -> (ATd[],pn);
                  '**  the binding:'->dumpTN;
                  ND.theDcl.dopt -> dumpTN;
                  (if ATd[] <> none then
                      (if ATd.IT.isVirtualPtn then
                          ATd.theDesc -> OS.setImplicitSuper; (* case 1 *)
                          '**   the virtual:'->dumpTN;
                          ATd.NS[] -> superNS[];
                       else
                          '!!!! declaration in super is not virtual:'-> dumpTN
                      if);
                      ATd.dopt -> dumpTN
                   else
                      '**** no corresponding virtual found'->dumpTN
                  if);
                  newline
               #)#);
          theDesc:: (# do OS.theDesc -> aDesc[] #);
       #);
     ObjectDesc::<
       (# setUpOrigin::
            (#
            do (*'ObjectDesc:setUpOrigin'->traceCheck; label->traceCheckN*)
               origin[] -> sup.setupOrigin; 
               this(ObjectDesc)[] -> att.setUpOrigin;
               this(ObjectDesc)[] -> acp.setUpOrigin;
               true -> done;
            #);
          check::
            (#
            do (*'ObjectDesc:check:'->traceCheckN;*)
            #);
          theDesc::
            (#
            do this(ObjectDesc)[] -> aDesc[]
            #);
          scanDecls:
            (#
            do (* remember labels and forImpIndex *)
               att.scanSons
               (#
               do
               #)
            #);
          superSearch::
            (# aDesc: ^ObjectDesc
            do  (if (sup.theDesc -> aDesc[]) = none then
                    (if (sup.AD.implicitSuperOD[] -> aDesc[]) = none then
                        (if false then
                            '**  no super'->dumpTN; dopt -> dumptn;
                        if);
                        leave superSearch
                     else
                        '**   try implicisSuper'->dumpTN
                    if)
                if);
               NA[] -> aDesc.localSearch -> (dcl[],pn);
               (if dcl[] <> none then
                   pn + 1 -> pn;
                   (*'**   found in super: ->dumpT';NA.dopt->dumpTN*)
               if)
            #);
          localSearch::
            (# aDesc:  ^ObjectDesc
            do NA[] -> att.localSearch -> (dcl[],pn);
               (if dcl[] = none then
                   (if true then
                       NA[] -> superSearch -> (dcl[],pn);
                    else
                       (if (sup.theDesc -> aDesc[]) <> none then
                           NA[] -> aDesc.localSearch -> (dcl[],pn);
                           (if dcl[] <> none then
                               pn + 1 -> pn;
                               (*'**   found in super: ->dumpT';
                                * NA.dopt->dumpTN*)
            if)if)if)if)#);
          search::
            (# 
            do 'ObjDesc:Search:' -> traceCheckN;
               (if NA.T.length > 0 then 
                   (if false then
                       '**** Search:' -> traceCheck; NA.T[] -> traceCheckN;
                       '**   in:' -> traceCheckN;
                       doPT -> traceCheckN;
                   if);
                   NA[] -> localSearch -> (dcl[],pn);
                   (if dcl[] = none then
                       (if origin[] <> none then
                           NA[] -> origin.search -> (dcl[],pn,on)
               if)if)if)
            #);
       #);
     ActionPart::<
       (# check::
            (#
            do (*'ActionPart:check:'->traceCheckN;*)
              (* enterP.check;
               imps.check;
               exitP.check*)
            #)
       #);
     Imperatives::<
       (# check::
            (#
            do (*'Imperatives:check:'->traceCheckN;*)
            #);
       #);
     IfImp::<
       (# check::
            (#
            do (*'IfImp:check:'->traceCheckN;*)
            #)
       #);
     ForImp::<
       (# setUpOrigin::
            (#
            do (*'ForImp:setUpOrigin:'->dumpT; dopt -> dumpTN;*)
               (*origin[] -> inx.setUpOrigin;*)
               origin[] -> inxDecl.setUpOrigin;
               origin[] -> rangee.setUpOrigin;
               this(ForImp)[] -> imps.setUpOrigin;
               true -> done
            #);
          check::(#do 'ForImp:check:'->dumpT; dopt -> dumpTN;  #);
          search::
            (#
            do NA[] -> inxDecl.localSearch -> (dcl[],pn);
               (if dcl[] <> none then
                   (*NA.T[] -> inx.N.T.equalNCS then*)
                   'ForImp:search:'->dumpT; NA.dopt -> dumpTN;
                   'in:' -> dumpTN; dopt -> dumpTN;
                   '**** found in forImp:'->dumpT; NA.dopt -> dumpTN; 
                   inxDecl[] -> dcl[]; 0 -> pn -> on;
                else
                   NA[] -> origin.search -> (dcl[],pn,on)
               if);
            #);
          theDesc::
            (#
            do 'ForImp:theDecl:missing Integer Desc'->traceCheck;
            #)
       #);
     PatternDen::<
       (# check::
            (#
            do (*'PatternDen:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do AD.theDesc -> aDesc[]
            #);
       #);
     NameApl::<
       (# check::
            (# dcl: ^BetaDecl; pn,on: @integer
            do 'NameApl:check:'->traceCheck; doPT->traceCheckN;
               (if N.T.length > 0 then 
                   (if false then
                       '**** AD:Search:'->traceCheck; N.T[]->traceCheckN;
                   if);
                   (if origin[] <> none then
                       N[] -> origin.search -> (dcl[] -> ATd[],pn,on);
                       on + 1 -> on;
                       (if (dcl[] <> none) then
                           (if true then
                               '**** Found:'->traceCheck;
                               N.T[] -> traceCheck;
                               ' pn: ' -> traceCheck; pn -> putint;
                               ' on: ' -> traceCheck; on -> putint; newline
                           if)
                        else                           
                           '\n**** did not find: ' -> traceCheck;
                           N.T[] -> traceCheckN;
                           father.father.father.father.doPT -> dumpTN;
                           (if origin[] = none then
                               '**   NameApl:origin is none'->dumpTN
                            else
                               (if theEncOD <> objDesc[] then
                                   (theEncOD).father.father.dopt -> putHeadN
                                else
                                   (theEncOD).dopt -> putHeadN
                               if)
                       if)if)
                    else
                       'empty'->traceCheckN
               if)if);
               true -> done
            #);
          theDesc::
            (#
            do L:
                 (if ATd[] <> none then 
                     (*ATd.dopt->putHeadN; *)
                     ATd.theDesc -> aDesc[] 
                else
                   (if N.T.length > 0 then
                       '**** enforce:check:'->dumpT; dopt->dumpTN;
                       check;
                       restart L
                    else
                       (if implicitSuperOD[] <> none then
                           'theDesc:implicitSuper:'->dumptN;
                           implicitSuperOD[] -> aDesc[]
                        else
                           (if theEncOD <> objDesc[] then
                               objDesc[] -> aDesc[];
                               '**   return:objDesc:'->dumpTN; 
                                aDesc.dopt->dumptn
                            else
                               (*'**   return:none:in:objDesc'->dumpTN*)
                       if)if)
                 if)if)
            #);
          ATd: ^BetaDecl
       #);
     Indexed::<
       (# theDesc:: 
            (#do (*'Indexed:theDesc:'->traceCheck; dopt -> traceCheckN*) #);
       #);
     Remote::<
       (# setUpOrigin::
            (#
            do (*'Remote:setUpOrigin:'->traceCheck; dopt -> dumpTN;*)
            #);
          Check::
            (# predDesc: ^ObjectDesc
            do (*'Remote:check:'->traceCheck; dopt -> dumpTN;*)
               scanSons
               (# AD: ^AttributeDenotation
               do (*current.doPT -> dumpTN;*)
                  (if not isFirst then
                      predDesc[] -> current.setUpOrigin
                  if);
                  (current[]->AD[]).check;
                  AD.theDesc -> predDesc[]
            #)#);
       #);
     BetaName::<
       (# setUpOrigin::
            (#
            do (if false and (origin[] = none) then
                   (* must be betaenv *)
                   'Name:origin is none:'->traceCheck; T[]->traceCheckN
               if)
            #);
          check::
            (# 
            do (*'BetaName:check:'->traceCheck;*)
            #)
       #);
     findPredefinedDesc:
       (# descName: ^Text;  ptn:  ^BetaPattern
       enter descName[]
       do (if false then
              'findPredefinedDesc:'->dumpT; descName[] -> dumpT;
              ' in topModule:'-> dumpT; topModule.label -> dumpTN;
              topModule.doPT -> putheadN;
          if);
          topModule.frags.scanSons
          (# i: @integer; objFrag: ^ObjDescFrag; 
             att: ^Attributes; dcl:  ^BetaDecl; pn: @integer
          do (*current.label -> dumpTN;*)
             (if (i + 1 -> i) = 1 then
                 (current[]->objFrag[]).OD.att[] -> att[];
                 descName[] -> BetaName -> att.localSearch -> (dcl[],pn);
                 (if dcl[] <> none then 
                     (if false then
                         dcl.label->dumpT; dcl.IT.label -> dumpTN;
                         dcl.doPT -> dumpTN;
                     if);
                     dcl.IT[] -> ptn[];
                     inner findPredefinedDesc;
                  else
                     '\n!!!! Compiler error: "'->puttext;
                     descName[] -> puttext;
                     '" pattern not found in betaenv'->putline
                 if);
              else
                 '\n!!!! Potential compiler problem:'->putline;
                 '!!   More than one fragment in betaenv'->putline;
       if)#)#);
     findPredefinedDescs:
       (#
       do 'Object' -> findPredefinedDesc
          (#
          do ptn.OD[] -> objDesc[]
          #);
          'Repetition' -> findPredefinedDesc
          (#
          do ptn.OD[] -> repetitionDesc[]
          #);
       #);
  do (if doTrace then 
         '**** StdBetaChecker: '->puttext; newline;
         '**** topModule:' -> dumpTN; 
         (if topModule[] <> none then
             topModule.doPT -> putheadN;
             '------'->dumpTN
         if);
     if);
     topModule.setUpOrigin;
     findPredefinedDescs;
     topModule.check;
  #)
