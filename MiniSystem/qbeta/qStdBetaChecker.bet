ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaTypes';
---LIB:attributes---
qStdBetaChecker: qStdBetaTypes
  (# StdBetaModule::<
       (# setUpOrigin::
            (#
            do (if false then
                   'StdBetaModule:setUpOrigin:'->dumpT;
                   (if origin[] <> none then
                       origin.label -> dumpT;
                    else
                       '-none-'->dumpT
                   if);
                   moduleName.doPT->dumpTN;
               if);
               origin[] -> frags.setUpOrigin;
               true -> done
            #);
       #);
     BetaFragments::<
       (# setUpOrigin::
            (#do (*'BetaFragments:setUpOrigin:'->traceCheckN;*)
               scanSons(#do origin[] -> current.setUpOrigin #);
               true -> done
            #);
          check::
            (# 
            do (if traceChecker then 
                   'BetaFragments:check:'->traceCheckN;
               if)
            #)
       #);
     AttFrag::<
       (# setUpOrigin::
            (#
            do (if false then
                   '**** AttFrag:setUpOrigin:'->dumpT; dopt -> putheadN;
               if);
               att.scanSons(#do origin[] -> current.setUpOrigin #);
               true -> done
            #);
          check::
            (#
            do (if traceChecker then 
                   'AttFrag:check:'->traceCheckN;
               if)
            #);
       #);
     ObjDescFrag::<
       (# setUpOrigin::
            (#
            do (*'**** ObjDescFrag:setUpOrigin:'->dumpT; dopt->putheadN;*)
               (if true then
                   origin[] -> OD.setUpOrigin; 
                   true -> done
                else
                   OD.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (#
            do (if traceChecker then 'ObjDescFrag:check:'->traceCheckN; if)
            #);
          theDesc::
            (#
            do OD[] -> aDesc[]
            #);
       #);
     DoPartFrag::<
       (# setUpOrigin::
            (#
            do (*'DoPartFrag:setUpOrigin:'->traceCheckN*)
               DP.scanSons(#do origin[] -> current.setUpOrigin #)
            #);
          check::
            (#
            do (if traceChecker then 'DoPartFrag:check:'->traceCheckN; if)
            #);
       #);
     Attributes::<
       (# setUpOrigin::
            (#
            do (*'Attributes:setUpOrigin'->traceCheckN; *)
               (if false then doPT -> putHeadN if)
            #);
          check::
            (#
            do (if traceChecker then 'Attributes:check:'->traceCheckN; if);
            #);
          localSearch::
            (#
            do (if false then
                   '**** Attributes.localSearch:'->traceCheck; 
                   NA.T[]->traceCheckN;
               if);
               loop:
                 scanSons
                 (#
                 do NA[] -> current.localSearch -> (dcl[],pn);
                    (if dcl[] <> none then
                        leave Loop
            if)#)#)
       #);
     AttSlot::<
       (# setUpOrigin::
            (# OD: ^ObjectDesc
            do (if false then
                    'AttSlot:setUpOrigin:'->dumpT; doPT -> dumpTN;
                    (if origin[] = none then 
                        'Origin is none:'->dumptn
                     else
                        origin.dopt -> putheadN
               if)if);
               scanBindings(#do origin[] -> current.setUpOrigin #);
               (* origin may be a forImp - must be handled!!! *)
               (if false and (origin[] = none) then
                   '*** origin is none'->dumpT; dopt -> dumpTN;
                   father.father.dopt -> putheadN
                else
                   this(AttSlot)[] -> (origin[]->OD[]).attSlots.add
               if)
            #);
          check::
            (#
            do (if traceChecker then
                   'AttSlot:Check:'->traceCheck; doPT -> traceCheckN;
               if);
               scanBindings
               (#
               do current.check
               #)
            #);
       #);
     ObjDescSlot::<
       (# setUpOrigin::
            (#
            do (*'ObjDescSlot:setUpOrigin:'->dumpT; doPT -> dumpTN; *)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
          theDesc::
            (# ODF:  ^ObjDescFrag;
            do scanBindings(#do (current[]->ODF[]).OD[] -> aDesc[] #);
            #)
       #);
     DoPartSlot::<
       (# setUpOrigin::
            (#
            do (*'DoPartSlot:setUpOrigin:'->traceCheck;doPT -> traceCheckN*)
               scanBindings(#do origin[] -> current.setUpOrigin#)
            #);
       #);
     BetaDecl::<
       (# setUpOrigin::
            (#
            do (*'BetaDecl:setUpOrigin:'->dumpT; dopt -> putHeadN;;*)
               this(BetaDecl)[] -> NS.addDclRef;
               NS[] -> IT.NS[]
            #);
          check::
            (#
            do (if traceChecker then 'BetaDecl:check:'->dumptn if);
            #);
          theDesc::
            (#
            do IT.theDesc -> aDesc[]
            #);
          exitType::
            (#
            do '**** Decl:exitType:'->dumpT; IT.label -> dumpT; IT.doPT->dumpTN;
               IT.exitType -> TP[]
            #);
          localSearch::
            (#
            do NA[] -> NS.localSearch -> (dcl[],pn)
            #);
       #);
     NameDecls::
       (# addDclRef:
            (# dcl: ^BetaDecl; ND: ^BetaNameDecl
            enter dcl[]
            do scanSons(#do dcl[] -> (current[]->ND[]).theDcl[] #); 
            #);
          localSearch::
            (#
            do loop:
                 scanSons
                 (# pn: @integer
                 do NA[]->current.localSearch-> (dcl[],pn);
                    (if dcl[] <> none then
                        leave loop
            if)#)#)
       #);
     BetaNameDecl::<
       (# theDesc::
            (#
            do theDcl.theDesc -> aDesc[]
            #);
          localSearch::
            (#
            do (if NA.T[] -> N.T.equalNCS then
                   (* '**** NameDecl:found:'-> traceCheck; 
                    * NA.T[]->traceCheckN;*)
                   (if theDcl[] = none then
                       '!!!! theDcl is none: '->dumpT; label -> dumpT;
                       dopt -> dumpTN;
                       '!!   searching:'->dumpT; NA.T[] -> dumpTN;
                   if);
                   this(BetaNameDecl)[] -> dcl[];
            if)#);
          exitType::
            (#
            do '**** NameDecl:'->dumpT; theDcl.label -> dumpT; 
               theDcl.dopt -> dumpTN;
               theDcl.exitType -> TP[]
            #);
               
          theDcl: ^BetaDecl
       #);
     StaticItem::<
       (# setUpOrigin:: (#do  NS[] -> OS.NS[] #);
          check::
            (#
            do (*'StaticItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #);
          
          exitType::
            (#
            do '**** StaticItem:'->dumpT; OS.label -> dumpT; 
               OS.dopt -> dumpTN;
               OS.exitType -> TP[]
            #);
       #);
     DynamicItem::<
       (# check::
            (#
            do (*'DynamicItem:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #);
          exitType::
            (#
            do '**** DynamicItem:'->dumpT; OS.label -> dumpT; 
               OS.dopt -> dumpTN;
               OS.exitType -> TP[]
            #);
       #);
     Repetition::<
       (# check:: 
            (#do (*'Repetition:check:'->traceCheck; dopt -> traceCheck*) #);
          theDesc::
            (#
            do repetitionDesc[] -> aDesc[]
            #);
       #);
     BetaPattern::<
       (# setUpOrigin::
            (#
            do NS[] -> OD.NS[]
            #);
          check::
            (#
            do (*'BetaPattern:check:'->traceCheckN;*)
            #);
          theDesc:: (# do OD[] -> aDesc[] #);
          exitType::
            (#
            do '**** PTN:exitType:'->dumpT; isprimitive -> putboolean;
               ' ' -> put; dopt -> putHeadN;
               OD[] -> value_type -> TP[]
            #);
       #);
     BetaVirtualPattern::<
       (# setUpOrigin:: (#do NS[] -> OS.NS[] #);
          check::
            (#
            do (if traceChecker then 
                   'BetaVirtualPattern:check:'->traceCheckN if);
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# 
            do OS.theDesc -> aDesc[] 
            #);
       #);
     handleBinding:
       (# VB: ^VirtualBinding;
       enter VB[]
       do (if false then
              VB.NS.dopt -> putline;
              VB.doPT -> putline;
          if);
          VB.NS.scanSons
          (# ND: ^BetaNameDecl; ATd: ^BetaNameDecl; pn,on: @integer
          do current[] -> ND[];
             ND.N[] -> VB.origin.superSearch -> (ATd[],pn);
             (if false then
                 '**  the binding:'->putline;
                 ND.theDcl.dopt -> putline;
             if);
             (if ATd[] <> none then
                 (if ATd.theDcl.IT.isVirtualPtn then
                     ATd.theDesc -> VB.OS.setImplicitSuper; (* case 1 *)
                     (if false then '**   the virtual:'->putline; if);
                     ATd.theDcl.NS[] -> VB.superNS[];
                  else
                     VB.father[] -> SemanticError
                     (#
                     do 'The declaration matching the above virtual binding'
                          -> msg;
                        ' is not virtual:\n'-> msg;
                        ATd.dopt -> msg
                 #)if);
                 (if false then ATd.dopt -> putline if)
              else
                 VB.father[] -> SemanticError
                 (#
                 do 'No corresponding virtual found for the above binding '
                      -> msg;
                 #);
             if);
             (if false then newline if);
             (if traceChecker then 'handleBinding:end'-> dumptn if);
          #)
       #);          
     FurtherBinding::<
       (# setUpOrigin:: (#do NS[] -> OS.NS[] #);
          check::
            (#
            do (if traceChecker then
                   'FurtherBinding:check:'->dumpTN;
               if);
               this(FurtherBinding)[] -> handleBinding
            #);
          theDesc:: 
            (* Must find the binding of this(Virtual) *)
            (# do OS.theDesc -> aDesc[] #);
       #);
     FinalBinding::<
       (* 1: V:: A
        * 2: V:: A(# ... #)
        * 3: V:: (# ... #) - an implicit super
        *)
       (# setUpOrigin:: (#do NS[] -> OS.NS[] #);
          check::
            (# ATd: ^BetaDecl; pn,on: @integer
            do (if traceChecker then
                   'FinalBinding:check:'->dumpTN;
               if);
               this(FinalBinding)[] -> handleBinding
            #);
          theDesc:: (# do OS.theDesc -> aDesc[] #);
       #);
     ObjectDesc::<
       (# setUpOrigin::
            (#
            do (if false then
                   'ObjectDesc:setUpOrigin:'->dumpT; 
                   (if (origin[] = none) then
                       'origin=none:'->dumpTN
                   if);
                   dopt -> putheadN
               if);
               (if slt[] <> none then
                   origin[] -> slt.setUpOrigin
                else
                   origin[] -> sup.setupOrigin; 
                   this(ObjectDesc)[] -> att.setUpOrigin;
                   this(ObjectDesc)[] -> acp.setUpOrigin;
               if);
               true -> done;
            #);
          check::
            (#
            do (*'ObjectDesc:check:'->traceCheckN;*)
            #);
          theDesc::
            (#
            do (if slt[] <> none then
                   slt.scanBindings
                   (# od: ^ObjectDesc; ODF:  ^ObjDescFrag
                   do (current[]->ODF[]).OD[] -> aDesc[];
                   #)
                else
                   this(ObjectDesc)[] -> aDesc[]
               if)
            #);
          scanDecls:
            (#
            do (* remember labels and forImpIndex *)
               att.scanSons
               (#
               do
               #)
            #);
          superSearch::
            (# aDesc: ^ObjectDesc
            do (if (sup.theDesc -> aDesc[]) <> none then
                   NA[] -> aDesc.localSearch -> (dcl[],pn);
                   (if dcl[] <> none then
                       pn + 1 -> pn;
                       (*'**   found in super: ->dumpT';NA.dopt->dumpTN*)
               if)if)
            #);
          localSearch::
            (# aDesc:  ^ObjectDesc
            do NA[] -> att.localSearch -> (dcl[],pn);
               (if dcl[] = none then
                   NA[] -> superSearch -> (dcl[],pn);
               if);
               (if dcl[] = none then
                   NA[] -> attSlots.search -> (dcl[],pn);
                   (if dcl[] <> none then
                       '**** found:in:slots:'->dumpT; NA.dopt -> dumpTN;
               if)if)
            #);
          search::
            (# 
            do (if false then
                   'ObjDesc:Search:' -> traceCheckN;
               if);
               (if NA.T.length > 0 then 
                   (if false then
                       '**** Search:' -> traceCheck; NA.T[] -> traceCheckN;
                       '**   in:' -> traceCheckN;
                       doPT -> putHeadN;
                   if);
                   (if slt[] <> none then
                       '**** ObjectDesc:isSlot:'->dumpt;
                       slt.scanBindings
                       (# od: ^ObjectDesc; ODF:  ^ObjDescFrag
                       do (current[]->ODF[]).OD[] -> od[];
                          NA[] -> od.localSearch -> (dcl[],pn);
                       #)
                    else
                       NA[] -> localSearch -> (dcl[],pn);
                   if);
                   (if dcl[] = none then
                       (if origin[] <> none then
                           NA[] -> origin.search -> (dcl[],pn,on);
                           on + 1 -> on
            if)if)if)#);
          attSlots: @
            (# aSlots: [3] ^AttSlot; top: @integer; trace: (#exit false #);
               anAttSlot: ^AttSlot;
               add:
                 (#
                 enter anAttSlot[]
                 do (if (top + 1 -> top) > aSlots.range then
                        aSlots.range -> aSlots.extend
                    if);
                    (if trace then
                        '**** added slot: ' -> dumpt; anAttSlot.dopt -> dumptn;
                        '**   in: ' -> dumptn; dopt -> putheadN;
                    if);
                    anAttSlot[] -> aSlots[top][]
                 #);
               scan:
                 (# current: ^Attributes;
                 do (for i: top repeat
                         aSlots[i].scanBindings
                         (# anAttFrag: ^AttFrag;
                         do (if trace then
                                '**   binding:'->dumpT; current.dopt -> dumpTN;
                            if);
                            (current[]->anAttFrag[]).att[] 
                              -> this(scan).current[]; 
                            inner scan
                         #)
                    for)
                 #);
               search:
                 (# NA: ^Name; dcl: ^BetaNameDecl; pn: @integer
                 enter NA[]
                 do (if trace and (top > 0) then
                        '**** attSlots:search:'->dumpT; NA.dopt -> dumpTN;
                        print;
                        '----'->dumptn;
                    if);
                    L:
                      scan
                      (#
                      do NA[] -> current.localSearch -> (dcl[],pn);
                         (if dcl[] <> none then
                             (if trace then
                                 '**   attSlots:found:'->dumpT; NA.dopt->dumpTN;
                             if);
                             leave L
                      if)#)
                 exit(dcl[],pn)
                 #);
               print:
                 (#
                 do (for i: top repeat aSlots[i].dopt -> dumpTN for)
                 #)
            #);
       #);
     ActionPart::<
       (# check::
            (#
            do (*'ActionPart:check:'->traceCheckN;*)
              (* enterP.check;
               imps.check;
               exitP.check*)
            #)
       #);
     Imperatives::<
       (# check::
            (#
            do (*'Imperatives:check:'->traceCheckN;*)
            #);
       #);
     IfImp::<
       (# check::
            (#
            do (*'IfImp:check:'->traceCheckN;*)
            #)
       #);
     ForImp::<
       (# setUpOrigin::
            (#
            do (*'ForImp:setUpOrigin:'->dumpT; dopt -> dumpTN;*)
               origin[] -> inxDecl.setUpOrigin;
               origin[] -> rangee.setUpOrigin;
               this(ForImp)[] -> imps.setUpOrigin;
               true -> done
            #);
          check::
            (#
            do (if false then 'ForImp:check:'->dumpT; dopt -> dumpTN; if)
            #);
          search::
            (#
            do NA[] -> inxDecl.localSearch -> (dcl[],pn);
               (if dcl[] <> none then
                   (if false then
                       'ForImp:search:'->dumpT; NA.dopt -> dumpTN;
                       'in:' -> dumpTN; dopt -> dumpTN;
                       '**** found in forImp:'->dumpT; NA.dopt -> dumpTN; 
                   if);
                   (*inxDecl[] -> dcl[];*) 0 -> pn -> on;
                else
                   NA[] -> origin.search -> (dcl[],pn,on)
               if);
            #);
          theDesc::
            (#
            do 'ForImp:theDecl:missing Integer Desc'->traceCheck;
            #)
       #);
     PatternDen::<
       (# check::
            (#
            do (*'PatternDen:check:'->traceCheck; doPT -> traceCheckN;*)
            #);
          theDesc::
            (#
            do AD.theDesc -> aDesc[]
            #);
          exitType::
            (#
            do '**** PatternDen:exitType:'->dumpT; AD.label->dumpT;
               AD.dopt->dumpTN;
               AD.exitType -> TP[]
            #)
       #);
     NameApl::<
       (# check::
            (# dcl: ^BetaNAmeDecl; trace: @boolean
            do (*'no_nyi'->N.T.equalNCS -> trace;*)
               (if trace then
                   'NameApl:check:'->dumpT; doPT->dumpT;
                   origin.dopt -> putheadN;
               if);
               (if (N.T.length > 0) and not isSlot then 
                   (if trace then
                       '**** AD:Search:'->dumpT; N.T[]->dumpTN;
                   if);
                   (if origin[] <> none then
                       N[] -> origin.search -> (dcl[] -> ATd[],pn,on);
                       (if (dcl[] <> none) then
                           (if false then
                               '**** Found:'->traceCheck;
                               N.T[] -> traceCheck;
                               ' pn: ' -> traceCheck; pn -> putint;
                               ' on: ' -> traceCheck; on -> putint; newline
                           if)
                        else
                           this(NameApl)[] -> SemanticError
                           (#
                           do 'Did not find a declaration of: "'->msg;
                              N.dopt -> msg; '"'->msg
                           #);
                           '?'->Name->BetaNameDecl -> ATd[];
                           errorDecl[] -> ATd.theDcl[]
                       if)
                    else
                       'empty'->traceCheckN
               if)if);
               true -> done
            #);
          theDesc::
            (#
            do L:
                 (if ATd[] <> none then 
                     (*ATd.dopt->putHeadN; *)
                     ATd.theDesc -> aDesc[] 
                else
                     (if N.T.length > 0 then
                         (if not N.beingChecked and not N.isChecked then
                             '**** enforce:check:'->dumpT; dopt->putHeadN;
                             check;
                             restart L
                          else
                             '**** nameApl:theDecl:beingChecked:'->dumpT;
                             dopt -> dumpTN;
                             objDesc[] -> aDesc[]
                         if);
                    else
                       (if implicitSuperOD[] <> none then
                           (if false then 'theDesc:implicitSuper:'->dumptN; if);
                           implicitSuperOD[] -> aDesc[]
                        else
                           (if theEncOD <> objDesc[] then
                               objDesc[] -> aDesc[];
                               (if false then
                                   '**   return:objDesc:'->dumpTN; 
                                   aDesc.dopt->dumptn
                               if)
                            else
                               (if false then
                                   '**** theDesc:'->dumptN;dopt->dumpTN;
                                   '**   theEnc: ' -> dumpTN;
                                   (if theEncOD <> none then
                                       (theEncOD).dopt -> dumpt
                                    else
                                       'none'->dumptN;
                                   if);
                                   '**   objDesc: ' -> dumpTN;
                                   (if objDesc <> none then
                                       objDesc.dopt -> dumpt
                                    else
                                       'none'->dumptN;
                               if)if);
                               (*'**   return:none:in:objDesc'->dumpTN*)
            if)if)if)if)#);
          exitType::
            (#
            do '**** NameApl:exitType:'->dumpT; ATd.label -> dumpT;
               ATd.dopt -> dumpTN;
               ATd.exitType -> TP[]
            #);
          ATd: ^BetaNameDecl (*BetaDecl; *)
       #);
     Indexed::<
       (# theDesc:: 
            (#do (*'Indexed:theDesc:'->traceCheck; dopt -> traceCheckN*) #);
       #);
     Remote::<
       (# setUpOrigin::
            (#
            do (*'Remote:setUpOrigin:'->traceCheck; dopt -> dumpTN;*)
            #);
          Check::
            (# predDesc: ^ObjectDesc
            do (if false then
                   'Remote:check:'->dumpT; dopt -> dumpTN;
               if);
               scanSons
               (# AD: ^AttributeDenotation
               do (if not isFirst then
                      predDesc[] -> current.setUpOrigin
                  if);
                  (current[]->AD[]).check;
                  AD.theDesc -> predDesc[];
                  (if false then
                      '**   AD.theDesc:'->dumpT; predDesc.dopt -> putheadN;
                  if)
            #)#);
          theDesc::
            (#
            do (if false then
                   '**** Remote:theDesc:'->dumpT; doPT -> dumpTN;
               if);
               scanSons
               (# AD: ^AttributeDenotation
               do (if isFirst then
                      (if false then
                          '**   theDesc:'->dumptn;
                          (current.theDesc).doPT -> putheadN;
                      if)
                   else
                      (if false then
                          '**   tail:'->dumpTN;
                          ((current[]->AD[]).theDesc).dopt -> putheadN;
                      if);
                      (current[]->AD[]).theDesc -> aDesc[]
            if)#)#)
       #);
     
     BetaTerm::<
       (# exitType::
            (#
            do '**** BetaTerm:exitType:'->dumpT; T.label->dumpT; T.dopt->dumpTN;
               T.exitType -> TP[]
            #)
       #);
     ObjectReference::<
       (# exitType::
             (#
             do '**** ObjectReference:exitType:'->dumpT; OV.label->dumpT;
                OV.dopt->dumpTN;
                OV.theDesc -> ref_type -> TP[]
             #)
       #);
     ObjectEvaluation::<
       (# exitType::
             (#
             do '**** ObjectEvaluation:exitType:'->dumpT; OS.label->dumpT;
                OS.dopt->dumpTN;
                OS.exitType -> TP[]
             #)
       #);
     DynamicObjectGeneration::<
       (# theDesc::
            (#
            do OS.theDesc -> aDesc[]
            #);
          exitType::
            (#
            do (if isRef then
                   OS.theDesc -> ref_type -> TP[] 
                else
                   (OS.theDesc).exitType -> TP[]
               if);
               (* not correct - here we have
                * &P
                * we need to go into the 
                * descriptor - only ref
                * if &P[]
                *)
            #)
       #);
     findPredefinedDesc:
       (# descName: ^Text; dcl:  ^BetaNameDecl; ptn:  ^BetaPattern
       enter descName[]
       do (if false then
              'findPredefinedDesc:'->dumpT; descName[] -> dumpT;
              ' in topModule:'-> dumpT; topModule.label -> dumpTN;
              topModule.doPT -> putheadN;
          if);
          topModule.frags.scanSons
          (# i: @integer; objFrag: ^ObjDescFrag; 
             att: ^Attributes;  pn: @integer
          do (*current.label -> dumpTN;*)
             (if (i + 1 -> i) = 1 then
                 (current[]->objFrag[]).OD.att[] -> att[];
                 descName[] -> Name -> att.localSearch -> (dcl[],pn);
                 (if dcl[] <> none then 
                     (if false then
                         dcl.label->dumpT; 
                         dcl.doPT -> dumpTN;
                     if);
                     dcl.theDcl.IT[] -> ptn[];
                     inner findPredefinedDesc;
                  else
                     '\n!!!! Compiler error: "'->puttext;
                     descName[] -> puttext;
                     '" pattern not found in betaenv'->putline
                 if);
              else
                 '\n!!!! Potential compiler problem:'->putline;
                 '!!   More than one fragment in betaenv'->putline;
       if)#)#);
     findPredefinedDescs:
       (#
       do 'Object' -> findPredefinedDesc
          (#
          do ptn.OD[] -> objDesc[]
          #);
          'Repetition' -> findPredefinedDesc
          (#
          do ptn.OD[] -> repetitionDesc[]
          #);
          'errorName'->findPredefinedDesc(#do dcl.theDcl[] -> errorDecl[] #);
       #);
     markPrimitiveDescs:
       (#
       do topModule.frags.scanSons
          (# OD: ^ObjectDesc; objFrag: ^ObjDescFrag;
          do (*'**** markPrimitives'->dumpt; current.label -> dumptN;*)
             (current[] -> objFrag[]).OD[] -> OD[];
             OD.att.scanSons
             (# dcl: ^BetaDecl
             do (*'**   dcl:'->dumpt; current.label -> dumptn;*)
                (if current## = BetaDecl## then
                    current[] -> dcl[];
                    dcl.NS.scanSons
                    (# N: ^BetaNameDecl;
                    do current[] -> N[];
                       (if true
                        // 'integer' -> N.N.T.equalNCS then
                           (*'** got integer'->dumptn;*)
                           true -> dcl.isPrimitive; 
                           dcl.IT.setPrimitive
          if)#)if)#)#)
       #);
     SemanticError:
       (# msg:
            (# T: ^Text; 
            enter T[]
            do T[] -> puttext
            #);
          N: ^StdbetaNode
       enter N[]
       do '\n**** Semantic error:'->putline;
          N.dopt -> putline;
          inner;
          newline
       #);          
     checkStdBeta:
       (#
       do (if doTrace then 
              '**** StdBetaChecker: '->puttext; newline;
              '**** topModule:' -> dumpTN; 
              (if topModule[] <> none then
                  topModule.doPT -> putheadN;
                  '------'->dumpTN
              if);
          if);
          topModule.setUpOrigin;
          findPredefinedDescs;
          markPrimitiveDescs;
          topModule.check;
       #);
  do 
     inner
  #)
