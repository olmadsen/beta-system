ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qlexer';
INCLUDE 'qabstractSyntaxTree';
INCLUDE 'qprimitives';
---lib:attributes---
newKWS: (# exit false #);
parser: AbstractSyntaxTree
  (# iRootModule::
       (# root: @ iModule;
       do rootModule[] -> root.M[];
          (*rootModule.name.lexemSy -> root.nm[];*)
          root[] -> rootM[];
       #);
     
     superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)
          
       enter fileName[]
       do (path.append).copy -> pathToFN[];
          lex[] -> oldLex[];
          &lexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          true -> lex.isXbeta;
          lex;
          INNER;
          inFile.close;
          oldLex[] -> lex[];
       #);
     pModule: superParser
       (# checkModuleName:
            (# pos,i: @integer; MN: ^text
            do pathToFN.scanAll
               (#
               do i + 1 -> i;
                  (if ch = dirCh then
                      i -> pos
                  if);
               #);
               (pos +1,pathToFN.length) -> pathToFn.sub -> MN[];
               (if MN[] -> sig.id.equal then
                else
                   '\n*** Fatal error: The name of the object module:\n\t"' -> puttext; 
                   sig.id[] -> puttext;
                   '"\n    must be the same as the name of the directory in:\n\t'->puttext;
                   pathToFN[] -> puttext;
                   '\n    Directory name is: "' -> puttext;
                   MN[] -> puttext; '" - These names are case sensitive\n' -> putline;
                   stop
               if)
            #);
          symb: ^text;
          sig: ^Signature;
          M: ^Module
       do (if lex.symb = lex.symbols.idf then
              (if true then
                  pSignature -> sig[]
               else
                  (lex.sym[],none,false) -> Signature -> sig[];
                  lex;
              if);
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb 
                   // lex.symbols.constRef then 
                      lex;
                      (true,false,sig[]) -> pDataItem -> Module -> M[];
                      pathToFN[] -> M.pathToFN[];
                      inFile[] -> M.inFile[];
                      checkModuleName
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
       exit M[]
       #);
     pDataItem:
       (# isConst,isValue: @boolean;
          sig: ^Signature;
          OG: ^ObjectGenerator;
          DI: ^DataItem
       enter(isConst,isValue,sig[])
       do pObjectGenerator -> OG[];
          sig.doPT -> OG.singularName[];
          OG.IS.handleProps;
          (isConst,isValue,sig[],OG[]) -> DataItem -> DI[]
       exit DI[]
       #);
     pObjectGenerator:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
       (# IV: ^Invocation;
          IS: ^Items;          
          OG: ^ObjectGenerator;;
       do pInvocation -> IV[];
          pMainPart -> IS[];
          (*IS.handleProps;*)
          (IV[],IS[]) -> ObjectGenerator -> OG[]
       exit OG[]
       #);
     pMainPart:
       (# IS: ^Items; props: ^Properties
       do (if lex.symb = lex.symbols.begin then 
              lex;

              pItems -> IS[];
             
              (if lex.symb // lex.symbols.end // lex.symbols.eos then
                  lex;
               else
                  2 -> SyntaxError
              if);
           else
              Items -> IS[];
              Properties -> IS.props[];
              Include -> IS.incl[] -> IS.append;
              true -> IS.isEmpty
          if);
          (if true then
              (if IS.props.comment[] <> none then
                  'props has comment: ' -> puttext; 
                  IS.props.comment[] -> putline
              if);

              (if (IS.incl[] <> none) and (IS.incl.comment[] <> none) then
                  (* 'include has comment: ' -> puttext; 
                   IS.incl.comment[] -> putline;*)
                  (if IS.props.length > 1 then 
                      (* append incl comment to props comment *)
                      IS.incl.comment[] -> IS.props.addComment
                   else
                      IS.incl.comment[] -> IS.addComment
              if)if)
          if)
       exit IS[]
       #);
     pProperties:
       (# 
          pProps:
            (# prop: ^Property
            do (if lex.symb 
                // lex.symbols.idf then
                   lex.sym[] -> name -> Property -> prop[] ->  props.append;
                   lex;     
                   pProperties -> prop.arg[] -> prop.append;                   
                // lex.symbols.const then 
                   lex.sym[] -> Const -> Property -> prop[] -> props.append;
                   lex;
                   pProperties -> prop.arg[] -> prop.append;
               if);
               (if lex.symb = lex.symbols.comma then
                   lex;
                   restart pProps
               if)
            #);
          Props: ^Properties; 
       do Properties -> Props[];
          (if lex.symb = lex.symbols.leftSquare then
              lex;
              pProps;
              (if lex.symb = lex.symbols.rightSquare then 
                  lex
               else
                  SyntaxError;
              if);
              (if lex.symb = lex.symbols.semicolon then
                  lex
              if)          
          if)
       exit Props[]
       #);
     handleProps:
       (# sig: ^Signature; ptnKind: @integer; OD: ^ObjectGenerator; 
          D: ^Decl; P: ^Pattern
       enter(sig[],ptnKind,OD[])
       do  OD.IS.handleProps; 
          
          (if OD.IS.primNo 
           // rAssign_prim // vAssign_prim then
              (sig[],OD[],ptnKind) -> AssignmentPtnGen -> P[] -> D[]
           // restart_prim // leave_prim then
              (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
           // indexedPut_prim 
           // indexedGet_prim
           // stringGet_prim
           // indexed_prim
           // asString_prim then
              (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
           // put_prim // ifthen_prim // inner_prim // none_prim
           // suspend_prim // resume_prim 
           // disable_prim // enable_prim // attach_prim
           // cmpAndSwap_prim // fork_prim // sleep_prim // thisCore_prim 
           // file_open_prim // file_get_prim 
           // file_eof_prim // file_close_prim 
           // dumpObj_prim then
              (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
           else              
              (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
          if);
          OD.IS.isPrimitive -> P.isPrimitivePtn;
          (if D.primNo
           // object_prim then D[] -> objectDecl[]
           // none_prim then D[] -> noneDecl[]
           // integer_prim then D[] -> integerDecl[]
           // char_prim then D[] -> charDecl[]
           // string_prim then D[] -> stringDecl[]
           // boolean_prim then D[] -> booleanDecl[]
           // error_prim then D[] -> errorDecl[]
           // this_prim then D[] -> thisDecl[]
           // thisCore_prim then D[] -> thisCoreDecl[]
           // Resume_prim then D[] -> resumeDecl[]
           // ifThen_prim then D[] -> ifThenDecl[]
           // indexed_prim then D[] -> IndexedDecl[]
           else
              (if D.isCore 
               // core_prim then D[] -> coreDecl[]                            
          if)if)
       exit D[]
       #);
     pItems:
       (# I: ^Items
       do Items -> I[]; true -> I.commentBefore;
          pProperties -> I.props[]; (* append dont work since not an item
                                     * Should be!*)
          Include -> I.incl[] -> I.append;
          (if lex.symb = lex.symbols.include then
              lex;
              Loop:
                (if true then
                    pInvocation -> I.incl.append;
                    (if lex.symb = lex.symbols.comma then
                        lex;
                        restart Loop
          if)if)if);
          Loop:
            (# D: ^Decl
            do (if lex.symb 
                // lex.symbols.inArg // lex.symbols.outArg then
                   pDecl -> D[] -> I.append
                // lex.symbols.idf then
                   (* Here we do lookahead of 1-3 symbols to determine
                    * if the next item is a DECLARATION or an EXPRESSION
                    *)
                   (if 1 -> lex.peekNext 
                    // lex.symbols.value 
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                    // lex.symbols.further
                    // lex.symbols.final then
                       pDecl -> I.append; 
                       (*lex.symb -> lex.symbols.print*)
                    // lex.symbols.leftBrack then 
                       (* DECL foo(v: @integer, ...): ...
                        * Exp: foo(e1,e2,e2)
                        *)
                       (if (3 -> lex.peekNext) 
                        // lex.symbols.colon // lex.symbols.virtual then
                           pDecl -> I.append;
                        else
                           pObjectGenerator -> I.append;
                       if)
                    else 
                       pObjectGenerator -> I.append;
                   if);
                // lex.symbols.special then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon (* nevher happne with ne arg syntax? *)
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       (if (1 -> lex.peekNext) = lex.symbols.colon then
                           (* Needed for new syntx for arguments:
                            *    ++ :
                            *       in V: var integer
                            *)
                           pDecl -> I.append
                        else
                           pObjectGenerator -> I.append
                   if)if)
                // lex.symbols.keyword then
                   (* More lookahead *)
                   (if (1 -> lex.sym.inxGet) = '@' then
                       (*'keywords: ' -> putline;*)
                   if);
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon then
                       (if newKWS then
                           'newKWS: ' -> puttext; lex.current -> putline;
                       if);
                       (if (3 -> lex.peekNext) = lex.symbols.idf then
                           pObjectGenerator -> I.append
                        else
                           pDecl -> I.append
                       if)
                    // lex.symbols.virtual then
                       pDecl -> I.append
                    else 
                       (if (1 -> lex.sym.inxGet) = '@' then
                           (if newKWS then
                               'PO"'->puttext; 
                               1 -> lex.peeknext -> putint; '"' -> put;
                               newline; 
                           if);
                           (if (1 -> lex.peekNext) = lex.symbols.colon then
                               (if newKWS then
                                   'pDecl' -> putline;
                               if);
                               pDecl -> D[] -> I.append;
                               D.setNewId
                            else
                               (if newKWS then
                                   'pObj:' -> puttext;
                                   lex.symb -> lex.symbols.asText -> puttext;
                                   ' ' -> put; lex.sym[] -> putline;
                               if);
                               pObjectGenerator -> I.append
                           if)
                        else
                           (if newKWS and false then
                               'pObj:A:' -> putline;
                           if);
                           pObjectGenerator -> I.append
                       if)
                   if);
                // lex.symbols.string then
                   pObjectGenerator -> I.append
                // lex.symbols.leftBrack then
                   (* (exp) ... *)
                   pObjectGenerator -> I.append
               if);
               (if lex.symb = lex.symbols.semicolon then
                   lex; 
                   restart Loop
               if)
            #)
       exit I[]
       #);
     pDecl:
       (# D: ^Decl; sig: ^Signature; OD: ^ObjectGenerator; ptnKind: @integer;
          P: ^Pattern; isInArg,isOutArg: @boolean
       do (if false and newKWS then
              'pDecl: ' -> puttext; lex.current -> putline
          if);
          (if lex.symb 
           // lex.symbols.inArg then
              lex;
              true -> isInArg
           // lex.symbols.outArg then
              lex;
              true -> isOutArg            
          if);
          pSignature -> sig[];
          L:
            (#
            do (if lex.symb
                // lex.symbols.colon then
                   (* plainPtn or data-item *)
                   lex;
                   (if lex.symb 
                    // lex.symbols.constRef then 
                       lex;
                       (true,false,sig[]) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varRef then
                       lex;
                       (false,false,sig[]) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.constVal then 
                       lex;
                       (true,true,sig[]) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varVal then
                       lex;
                       (false,true,sig[]) -> pDataItem -> D[];
                       leave L                  
                    else
                       plainPtn -> ptnKind
                   if);
                // lex.symbols.virtual then
                   lex; 
                   virtualPtn -> ptnKind               
                // lex.symbols.further then
                   lex; 
                   furtherPtn-> ptnKind
                // lex.symbols.final then
                   lex; 
                   FinalPtn -> ptnKind
                else
                   3 -> syntaxError;
                   errorDecl[] -> D[];
                   leave L
               if);
               pObjectGenerator -> OD[];
               
               OD.IS.handleProps;           
               (if OD.IS.primNo 
                // rAssign_prim // vAssign_prim then
                   (sig[],OD[],ptnKind) -> AssignmentPtnGen -> P[] -> D[]
                // restart_prim // leave_prim then
                   (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
                // indexedPut_prim 
                // indexedGet_prim
                // stringGet_prim
                // indexed_prim
                // asString_prim then
                   (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
                // put_prim // ifthen_prim // inner_prim // none_prim
                // suspend_prim // resume_prim 
                // disable_prim // enable_prim // attach_prim
                // cmpAndSwap_prim // fork_prim // sleep_prim // thisCore_prim 
                // file_open_prim // file_get_prim 
                // file_eof_prim // file_close_prim 
                // dumpObj_prim then
                   (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
                else              
                   (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
               if);
               OD.IS.isPrimitive -> P.isPrimitivePtn;
               (if D.primNo
                // object_prim then D[] -> objectDecl[]
                // none_prim then D[] -> noneDecl[]
                // integer_prim then D[] -> integerDecl[]
                // char_prim then D[] -> charDecl[]
                // string_prim then D[] -> stringDecl[]
                // boolean_prim then D[] -> booleanDecl[]
                // error_prim then D[] -> errorDecl[]
                // this_prim then D[] -> thisDecl[]
                // thisCore_prim then D[] -> thisCoreDecl[]
                // Resume_prim then D[] -> resumeDecl[]
                // ifThen_prim then D[] -> ifThenDecl[]
                // indexed_prim then D[] -> IndexedDecl[]
                else
                   (if D.isCore = core_prim then D[] -> coreDecl[]
               if)if);
            #);
          isInArg -> D.isInArg;
          isOutArg -> D.isOutArg;
       exit D[]
       #);
     pSignature:
       (* foo:
        * fool(a: ?integer, ...):
        * %put x: ?integer ... :
        * ++ V: ?integer: 
        *)
       (# sym: ^text; sig: ^Signature; args: ^Arguments       
       do (if lex.symb              
           // lex.symbols.idf then 
              lex.sym[] -> sym[];
              lex;
              (if false and (lex.symb = lex.symbols.leftBrack) then
                  lex;
                  Arguments -> args[]; true -> args.isFunction;
                  pArguments
                  (#
                  do D[] -> args.append
                  #);
                  (if lex.symb = lex.symbols.rightBrack then
                      lex;
                   else
                      syntaxError
                  if);
                  (sym[],args[],false) -> FunctionSigGen -> sig[];
               else 
                  (* UnarySignature *)
                  Arguments -> args[];
                  (sym[],args[],false) -> UnarySigGen -> sig[]
              if)
           // lex.symbols.keyword then
              (if (1 -> lex.sym.inxGet) = '@' then
                  lex.sym[] -> sym[]; (*sym[] -> putline;*)
                  lex;
                  Arguments -> args[]; 
                  sym[] -> name -> args.append;
                  true -> args.isNewKeyWord;
                  (if lex.symb = lex.symbols.colon then 
                      (* do we need this test?*)
                  if)
               else
                  lex.sym[] -> sym[];
                  lex;
                  Arguments -> args[]; 
                  sym[] -> name -> args.append;
                  pArguments
                  (#
                  do D[] -> args.append
                  #); 
              if);
              (sym[],args[],true) -> KeyWordSigGen -> sig[];
              sig.setId
           // lex.symbols.special then
              (* binary *)
              lex.sym[] -> sym[];
              lex;
              Arguments -> args[]; true -> args.isBinary;
              (if lex.symb = lex.symbols.colon then
                  (sym[],args[],false) -> BinarySigGen -> sig[]
               else
                  pArgument -> args.append;
                  (sym[],args[],false) -> BinarySigGen -> sig[]
              if)
          if);
          (if lex.symb = lex.symbols.value then
              lex;
              pValue -> sig.val[] -> sig.append;
              (*'Sig: ' -> puttext; sig.doPT -> putline; *)
          if);
          (*'Sig: ' -> puttext; sig.doPT -> putline;*)
       exit sig[]
       #);     

     pArgument:
       (# D: ^Decl; P: ^Pattern
       do pDecl -> D[]; (* Perhaps not all decl's should be allowed *)
          true -> D.isArg;
          (if D## = pattern## then
              D[] -> P[];
              (if P.ptnKind = plainPtn then
                  SyntaxError
                  (#do 'A non-virtual pattern cannot be an argument' -> putline #)
          if)if)
       exit D[]
       #);
     pArguments:
       (# D: ^TopNode
       do Loop:
            (#
            do pArgument -> D[]; 
               inner pArguments;
               (if lex.symb 
                // lex.symbols.fatComma then
                   lex.sym[] -> Name -> D[];
                   lex;
                   inner pArguments;
                   restart Loop
                // lex.symbols.comma then
                   lex;
                   restart Loop
               if)
            #)
       #);
     pValue:
       (# V: ^Value
       do Value -> V[];
          (if lex.symb = lex.symbols.leftBrack then
              lex; 
              Loop:
                (#
                do pDecl -> V.append;
                   (if lex.symb 
                    // lex.symbols.comma then
                       lex;
                       restart Loop
                    // lex.symbols.rightBrack then
                       lex
                   if)
                #)
           else
              pDecl -> V.append
          if)
       exit V[]
       #);
     pInvocation:
       (* foo
        * R.foo
        * R ++ E
        * R.%put E1 %at Inx
        * a:= a + b * 117
        * R.S ++ E . %put E %at I
        *)
       (# IV: ^Invocation;
          E: ^Exp;
          i: @integer
       do Invocation -> IV[]; 
          (if fat then 
              'pExp:A: ' -> puttext; lex.current -> putline;
          if);
          Loop:
            (#
            do i + 1 -> i;
               pExp -> E[] -> IV.append; (* elim is E.isEmpty *)
               (if fat then 
                   'pExp:B: ' -> puttext; lex.current -> putline;
               if);
               (if lex.symb 
                // lex.symbols.dot then
                   lex;
                   restart Loop
                // lex.symbols.special then 
                   restart Loop
                // lex.symbols.idf then
                   (*lex;
                   (If lex.symb = lex.symbols.colon then
                       'Bingo: '->puttext; lex.current -> putline;
                       lex;
                       restart loop
                   if)*)
               if)
            #);
          (if i = 1 then E.isEmpty -> IV.isEmpty if);
          (if fat then 
              'pExp:C: ' -> puttext; lex.current -> putline;
          if);
       exit IV[]
       #);
     fat: @boolean;
     scanForBrace:
       (# T,inn: ^Text; first,last: @integer
       enter T[]
       do  0 -> first -> last;
          T.scanAll
          (# toInn,predIsSlash: @boolean; pos: @integer
          do pos + 1 -> pos; 
             (if ch 
              // '\\' then true -> predIsSlash
              // '{' then
                 (*'**** got { in: ' -> puttext; T[] -> putline;*)
                 &text[] -> inn[];
                 not predIsSlash -> toInn;
                 false -> predIsSlash;
                 pos -> first;
              // '}' then
                 not predIsSlash -> toInn;
                 false -> predIsSlash;
                 pos -> last;
                 inner scanForBrace
              else
                 false -> predIsSlash;
                 (if toInn then ch -> inn.put if)
             if);
          #)
       #);
     handleString: 
       (# T: ^Text; S: ^StringObj; E: ^Invocation; err: ^text
       enter T[]
       do T[] -> StringObj -> S[];

          T[] -> scanForBrace
          (# 
          do (*'**** inn: ' -> puttext; inn[] -> puttext;*) 
             inn[] -> parseInv -> (err[],E[]);
             (if err[] <> none then
                 '*** syntax error' -> putline
              else
                 E[] -> S.append;
                 (*' Exp: ' -> puttext; E.dopt -> putline;*)
             if)
          #)
       exit S[]
       #);
     pExp:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if E0 %then E1 %else E2
        *)
       (# sym,sym2: ^Text;
          E: ^Exp; 
       do (* '\npExp: ' -> puttext; lex.symb -> lex.symbols.print; 
           *  ' ' -> put; lex.sym[] -> puttext;
           * *)
          (if lex.symb 
           // lex.symbols.const then
              lex.sym[] -> Const -> E[];
              lex;
           // lex.symbols.string then
              lex.sym[] -> handleString -> E[];
              lex;
           // lex.symbols.charSy then 
              lex.sym[] -> CharObj -> E[];
              lex;
           // lex.symbols.idf then 
              lex.sym[] -> sym[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then
                  lex;
                  sym[] -> pFunction  -> E[]
               else (*unary *)
                  (sym[],arguments) -> UnaryGen -> E[]
              if)
           // lex.symbols.special then
              lex.sym[] -> sym[];
              lex;
              sym[] -> pBinary -> E[]
           // lex.symbols.keyword then 
              lex.sym[] -> sym[];
              lex;             
              (*'exp:kw:' -> puttext; lex.current -> putline;*)
              sym[] -> pKeyword -> E[]
           // lex.symbols.leftBrack then
              lex.sym[] -> sym[];
              lex;
              pBracketedExp -> E[]
          (* // lex.symbols.begin then
              pMainPart -> ObjectGeneratorExp -> E[]*)
           else 
              Exp -> E[]; 
              true -> E.isEmpty
          if);
       exit E[]
       #);
     pFunction:
       (# sym: ^text;
          F: ^Exp;
          args: ^Arguments;
          OG: ^ObjectGenerator
       enter sym[]
       do Arguments -> args[];  true -> args.isFunction;         
          loop:
            (if true then
                pObjectGenerator -> OG[];(* -> F.append;*)
                OG[] -> Args.append;
                (*lex.symb -> lex.symbols.print;*)
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex;
                   (* (if lex.skipcomment.comment.length > 0  then 
                        '*** got comment:A:' -> putline;
                        lex.skipcomment.comment[] -> putline
                    if)*)
                 else
                    6 -> SyntaxError
                if)
            if);
          (sym[],args[]) -> FunctionGen -> F[];
        (*  (if args.comment[] <> none then
              '*** got comment:B:' -> putline;
              args.doPT -> putline;
              args.comment[] -> F.commentAfter[]
          if)*)
       exit F[]
       #);
     pBinary:
       (# op: ^text; IV: ^ObjectGenerator; B: ^Exp; args: ^Arguments
       enter op[]
       do Arguments -> args[];
          true -> args.isBinary;
          pObjectGenerator -> IV[] -> args.append;
          (op[],args[]) -> BinaryGen -> B[];
       exit B[]
       #);
     pKeyword:
       (# sym,id: ^Text; (* sym = keyword = %put *)
          K: ^Exp;
          args: ^Arguments; OG: ^objectGenerator; newKW: @boolean
       enter(sym[])
       do sym[] -> id[]; 
          Arguments -> args[];
          true -> args.isKeyWord; false -> newKW;
          (if false then
              'parseKW: ' -> puttext; lex.current -> putline;
          if);
          (if (1 -> sym.inxGet) = '@' then
              (if newKWS and false then
                  '@parseKw:'->puttext; id[] -> putline;
              if);
              ':' -> sym.put;
              sym.copy -> Name -> args.append;
              false -> fat; false -> newKW;
              loop:
                (#
                do pObjectGenerator -> OG[] -> args.append; 
                   (if newKWS then
                       'newFatComma:' -> puttext; args.noOfSons -> putint;
                       ' ' -> put;
                       lex.current -> putline;
                       'args: ' -> putline;
                       args.dopt -> putline
                   if);
                   (if true then
                       (if lex.symb 
                        // lex.symbols.fatComma then 
                           (* ':' -> lex.sym.append;;*)
                           lex.sym[] -> Name -> args.append;
                           lex.sym[] -> id.append;
                           lex;
                           restart Loop
                       if)
                    else
                       (if lex.symb = lex.symbols.colon then
                           (if (1 -> lex.peekNext) = lex.symbols.idf then
                               lex;
                               '' -> sym[];
                               ':' -> sym.put;
                               lex.sym[] -> sym.puttext; 
                               lex.sym[] -> Name -> args.append;
                               sym[] -> id.append;
                               lex;
                               id[] -> putline;
                               restart loop
                if)if)if)#);
              false -> fat;
           else
              (if false and newKWS then
                  'pKeyword:'->puttext; id[] -> puttext; '<' -> put; 
              if);
              sym.copy -> Name -> args.append;
              Loop:
                (#
                do pObjectGenerator -> OG[] -> args.append; 
                   (*'[' -> put; OG.doPT -> puttext; ']' -> put;*)
                   (if lex.symb 
                    // lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                   if);
                #);
          if);
          (*'>'->put; args.doPT -> puttext; '.'->put; newline;*)
          (id[],args[]) -> KeyWordGen -> K[];
          (if newKW then
              'endKeyword:length: ' -> puttext; args.noOfSons -> putint; 
              newline;
              K.dopt -> putline;
          if);
       exit K[]
       #);
     pBracketedExp:
       (# E: ^exp; I: ^Invocation
       do (* pExp *) pInvocation  -> I[];
          (if lex.symb = lex.symbols.rightBrack then
              lex
           else
              111 -> SyntaxError
          if);
          I[] -> BracketedExp -> E[]
       exit E[]
       #);
     
     parseSubText:
       (# xsyntaxerror:< 
            (# errorStream: ^stream
            do '!!!! syntax error'->putline;
               lex.errorStream[] -> errorStream[] -> putline;
               inner
            exit errorStream[]
            #);
          inn: ^text; (* the qbeta text to be parsed *)
          oldLex: ^Lexer;
          errs: ^Stream; ind: @integer
       enter inn[]
       do lex[] -> oldLex[];
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          false -> hasSyntaxError;
          0 -> inn.setPos;
          lex;
          inner;
          (if hasSyntaxError then
              xsyntaxError -> errs[] (* check if this is ever used, including
                                      * exit errors[] below
                                      *)
          if);
          oldlex[] -> lex[];
       exit errs[]
       #);
     browserItem::
       (#
       do '\n**** browserItem: ' -> puttext; T[] -> putline;
          T[] -> parseSubText
          (#
          do '!!!! browserItem:not implemented'->putline
          #) 
       #);
     parseInv: parseSubText
       (# xsyntaxerror:: (# do 'syntax error' -> putline #);
          E: ^Invocation
       do pInvocation -> E[];
       exit E[]
       #);
     mkItems: parseSubText
       (# IS: ^Items
       do pItems -> IS[]
       exit IS[]
       #);
     parseItemsText::
       (# ind: @integer
       do (if false then
              '**** parseItemsText: ' -> putline; inn[] -> putline;
          if);
          L:
            (#
            do inn[] -> mkItems
               (# xsyntaxerror::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               #) -> (errors[],IS[]);
               (if false then
                   '**** after parse: ' -> putline; IS.doPT -> putline;
               if)
            #)
       #);
     parseDeclTextX:: 
       (# 
       do 
          L:
            (# DIx: ^Decl
            do inn[] -> parseSubText
               (# xSyntaxError::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               do pDecl -> DIx[]
               exit DIx[]
               #) -> (errors[],DI[])
            #)
       #);
     parseDeclText: parseSubText
       (# DI: ^Decl
       do pDecl -> DI[];
       exit DI[]
       #);
     mkModuleItem::<
       (# DI: ^DataItem; M: ^Module; errs: ^stream; MI: ^ModuleItem;
       do 'mkModuleItem: ' -> putline; 
          name.copy -> itemT[];
          name.copy -> att[];
          (if kind
           // '/' then (* object module *)
              ': =\n   dummy: ?integer' -> itemT.append;
              ': /' -> att.puttext
           else (* pattern module - but not suppprted in qbeta *)
              ':\n   d: ?integer' -> itemT;
              ':' -> att.put
          if);
          itemT[] -> putline;
          itemT[] -> parseDeclText -> (errs[],DI[]);
          DI.dopt -> putline;
          DI[] -> Module -> M[];
          (name[],M[]) -> ModuleItem -> MI[] -> dcl[];
          DI.sig[] -> MI.sig[];
          (* pathToModule[] -> MI.dir[];*)
          moduleF[] -> MI.md.inFile[];  
          true -> MI.isParsed; (* needed? *)
          dcl[] -> M.father[];  (* needed? *)
       #); 
     mkDecl::
       (#
       do '\n**** parser:mkDeclY:' -> putline;  
          'kind: ' -> puttext; kind -> put; ' ' -> put; name[] -> putline;
          (if kind
           // ' ' then (* pattern *)
              ':\n   dummy: ? integer' -> name.puttext;
           // '@' then  (* object *)
              ': =\n   dummy: ? integer' -> name.puttext;
          if);
          name[] -> parseDeclText -> (errors[],dcl[]);          
       #);
     parseX_decl::
       (# dclx: ^Decl;
       do (*'*** parseX_decl:'->putline; in[] -> putline;*)
          in[] -> parseSubText
          (# 
          do pDecl -> dclX[]
          #) -> errors[];
          (if errors[] <> none then
              '\n!!!! parse errors: ' -> putline;
              errors[] -> putline
           else
              (*(if dclX[] = none then 'dclX:none'->putline
               else
                  'dclX: ' -> puttext; dclX.doPT -> putline
              if);
              (if dclX.sig[] = none then 'sig is none'->putline
               else
                  'sig: ' -> puttext; dclX.sig.doPT -> putline
              if);              
              (if dclX.sig.id[] =none then
                  'id is none ' -> putline
               else
                  dclX.sig.id[] -> putline
              if);*)
              dclX.sig.id[] -> name[];
              (if true
               // ('obj' -> (dclX.label).equal)
               // ('Module' -> (dclX.label).equal) then
                  kinds.objModule -> kind;
               else 
                  'Item is a "' -> errors[];
                  dclX.label -> errors.puttext;
                  '" - it must be an object of the form "obj: =? ..."' 
                    -> errors.puttext
              if)
              (*': /' -> skind[];*)
          if);
          dclX[] -> dcl[];
       #);
     scanTokens:
       (# inn: ^text; oldLex: ^Lexer
       enter inn[]
       do lex[] -> oldLex[];
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          false -> hasSyntaxError;
          loop:
            (if true then
                lex;
                inner;
                (if lex.symb <> lex.symbols.eos then restart Loop if)
            if);
          (if hasSyntaxError then
             (* xsyntaxError -> errs[] (* check if this is ever used, including
                                      * exit errors[] below
                                      *)
          if);
          oldlex[] -> lex[];
       #);
     handleReservedId::
       (#
       do inn.setpos;
          inn[] -> scanTokens
          (# 
          do 
             (if lex.symb 
              // lex.symbols.varVal
              // lex.symbols.constVal
              // lex.symbols.varRef
              // lex.symbols.constRef
              // lex.symbols.outArg 
              // lex.symbols.inArg 
              // lex.symbols.keyword
                 then
                 (lex.nextCh.posBeforeName,lex.nextCh.pos - 1) -> theHandler
              // lex.symbols.fatComma
                 then
                 (if (1->lex.sym.inxGet) = ':' then
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 1) -> theHandler
                  else
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 2) -> theHandler
                 if)
             if);
       #)#);
                  
     hasSyntaxError: @boolean;
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          newline;
          3 -> lex.printlines;
          newline;

          true -> hasSyntaxError;
          inner;
          
          (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
          lex.oldPos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;

          lex.nextCh.pos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;
          'Syntax error (' -> lex.errorStream.puttext;
          n -> lex.errorStream.putint;')' -> lex.errorStream.put;
          
          ' expected symbols: ' -> lex.errorStream.puttext;          
          '?' -> lex.errorStream.put; (* temporary *)
          lex.errorStream.newLine;
          skip:
            (#
            do lex; 
               (if lex.symb = lex.symbols.eos then leave skip if);
               (if lex.symb = lex.symbols.semicolon then
                   (*lex*)
               else
                   restart skip
               if)
            #);
          (if true then
              lex.errorStream[] -> putline;              
           else
              (failureTrace (*dumpStack*),'Syntax error in:\n'->lex.fileName.prepend)  
                -> stop
          if)
        #);
     genTokenStream: superParser
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.const
                // lex.symbols.charSy
                // lex.symbols.string
                // lex.symbols.special 
                // lex.symbols.keyword 
                // lex.symbols.fatComma then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if)
           if)
       #);

     topPath: ^text;
     onlyLex: @boolean;
     rootModule,
     main: ^Module
  do (if onlyLex then
         FN[] -> genTokenStream
      else
         (* There is a mess with respect to compile being called from
          * the stand-alone compiler, qbeta or from qenv
          * From qenv the first call of compile differs from subsequent calls.
          * The first call from qenv parse all modules and builds their ASTs
          * Subsequent calls use exisiting AST's - i.e. no parsing
          * When en entity is text-edited in qenv, it is parsed and replaces
          * the old vewrsion on the ASTs
          * 
          * Fullpath:false - called from qbeta
          *         : true - called from qenv
          * rootModule:false - called from qbeta or first call from qenv
          *            true  - subsequent calls from qenv
          * withPos: false - call from qbeta and used by lexer 
          *                  to print errormessages on stdout
          * withPos: true  - from qend and used by lexer to return String with
          *                  errors and positions of these in qenv buffer
          * A clean-up here is needed
          *)
         (if false then
             (if fullPath then
                 'fullPath:true ' -> puttext
              else 
                 'fullPath:false ' -> puttext
             if);
             (if withPos then
                 'withPos:true ' -> puttext
              else
                 'withPos:false ' -> puttext
             if);
             (if rootModule[] <> none then
                 'rootModule:not none'->putline
              else
                 'rootModule:none' -> putline
         if)if);
         
         (if rootModule[] = none  then 
             (* Called from qbeta stand-alone compiler or 
              * first compilation from qenv when starting qenv
              *)
             &lexer[] -> lex[]; 
             true -> lex.isXbeta;
             path.init;
             (fullPath,FN[]) -> locateWorld -> topPath[];
             topPath[] -> pModule -> rootModule[];
             rootModule.handleDirModules (* all of BETAworld is parsed*)
             (# pDirModule::
                  (#
                  do (*'pDirModule: ' -> puttext; moduleDir[] -> putline;*)
                     moduleDir[] -> path.push;
                     (path.append,moduleDir[]) -> DirectoryComponents
                     (# 
                     do (*'DirElm: ' -> puttext; current[] -> putline;*)
                        current[] -> pModule -> md[];
                        (*'Module: ' -> putline;  md.doPT -> putline;*)
                     #);
                     path.pop
                  #)
             #)
               -> main[];
          else
             (*'**** Parser called from qenv - thus no parsing' -> putline;*)
             theM[] -> main[];
             rootModule.clear
         if);
         &iModule[] -> iMain[];
         main[] -> iMain.M[];
         (*main.doPT -> putline;*)
         (*main.DI.OG.doPT -> putline;*)
         (*main.doPP -> putline;*)
         (*rootModule.doPP -> putline;*)
         (if not hasSyntaxError then
             inner
         if)
     if)
  #)
