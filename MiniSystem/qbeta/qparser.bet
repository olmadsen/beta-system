ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qlexer';
INCLUDE 'qabstractSyntaxTree';
INCLUDE 'qprimitives';
---lib:attributes---
parser: AbstractSyntaxTree
  (# iRootModule::
       (# root: @ iModule;
       do rootModule[] -> root.M[];
          (*rootModule.name.lexemSy -> root.nm[];*)
          root[] -> rootM[];
       #);
     
     superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)
          
       enter fileName[]
       do (path.append).copy -> pathToFN[];
          lex[] -> oldLex[];
          &lexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          lex;
          INNER;
          inFile.close;
          oldLex[] -> lex[];
       #);
     pModule: superParser
       (# checkModuleName:
            (# pos,i: @integer; MN: ^text
            do pathToFN.scanAll
               (#
               do i + 1 -> i;
                  (if ch = '\\' then
                      i -> pos
                  if);
               #);
               (pos +1,pathToFN.length) -> pathToFn.sub -> MN[];
               (if MN[] -> sig.id.equal then
                else
                   '\n*** Fatal error: The name of the object module:\n\t"' -> puttext; 
                   sig.id[] -> puttext;
                   '"\n    must be the same as the name of the directory in:\n\t'->puttext;
                   pathToFN[] -> puttext;
                   '\n    Directory name is: "' -> puttext;
                   MN[] -> puttext; '" - These names are case sensitive\n' -> putline;
                   stop
               if)
            #);
          symb: ^text;
          sig: ^Signature;
          M: ^Module
       do (if lex.symb = lex.symbols.idf then
              (lex.sym[],none,false) -> Signature -> sig[];
              lex;
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb 
                   // lex.symbols.constRef then 
                      lex;
                      (true,sig[]) -> pDataItem -> Module -> M[];
                      pathToFN[] -> M.pathToFN[];
                      inFile[] -> M.inFile[];
                      checkModuleName
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
       exit M[]
       #);
     pDataItem:
       (# isConst: @boolean;
          sig: ^Signature;
          OG: ^ObjectGenerator;
          DI: ^DataItem
       enter(isConst,sig[])
       do pObjectGenerator -> OG[];
          sig.doPT -> OG.singularName[];
          (isConst,sig[],OG[]) -> DataItem -> DI[]
       exit DI[]
       #);
     pObjectGenerator:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
       (# IV: ^Invocation;
          IS: ^Items;          
          OG: ^ObjectGenerator;;
       do pInvocation -> IV[];
          pMainPart -> IS[];
          (IV[],IS[]) -> ObjectGenerator -> OG[]
       exit OG[]
       #);
     pMainPart:
       (# IS: ^Items; props: ^Properties
       do (if lex.symb = lex.symbols.begin then 
              lex;

              pItems -> IS[];
             
              (if lex.symb = lex.symbols.end then
                  lex;
               else
                  2 -> SyntaxError
              if)
           else
              Items -> IS[];
              true -> IS.isEmpty
          if)
       exit IS[]
       #);
     pProperties:
       (# Props: ^Properties; E: ^Exp; prop: ^Property
       do Properties -> Props[];
          L:
            (#
            do (if lex.symb 
                // lex.symbols.idf then
                   lex.sym[] -> name -> E[]
                // lex.symbols.const then 
                   lex.sym[] -> Const -> E[]
               if);
               Property -> prop[];
               E[] -> prop.P[] -> prop.append;
               prop[] -> props.append;
               lex;
               Loop:
                 (if lex.symb 
                  // lex.symbols.comma then
                     lex;
                     restart L
                  // lex.symbols.leftSquare then 
                     lex;
                     pProperties -> prop.arg[] -> prop.append;
                     restart Loop
                  // lex.symbols.rightSquare then 
                     lex;
                 if)
            #)
       exit Props[]
       #);
     pItems:
       (# I: ^Items
       do Items -> I[];
          (if lex.symb = lex.symbols.leftSquare then
              lex;
              pProperties -> I.props[]; (* append dont work since not an item
                                         * Should be!*)
              (if lex.symb = lex.symbols.semicolon then
                  lex
              if)
          if);
          Include -> I.incl[] -> I.append;
          (if lex.symb = lex.symbols.include then
              lex;
              Loop:
                (if true then
                    pInvocation -> I.incl.append;
                    (if lex.symb = lex.symbols.comma then
                        lex;
                        restart Loop
                if)if);
          if);
          Loop:
            (#
            do (if lex.symb 
                // lex.symbols.idf then
                   (* Here we do lookahead of 1-3 symbols to determine
                    * if the next item is a DECLARATION or an EXPRESSION
                    *)
                   (if 1 -> lex.peekNext 
                    // lex.symbols.value 
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                    // lex.symbols.further
                    // lex.symbols.final then
                       pDecl -> I.append; 
                       (*lex.symb -> lex.symbols.print*)
                    // lex.symbols.leftBrack then 
                       (* DECL foo(v: @integer, ...): ...
                        * Exp: foo(e1,e2,e2)
                        *)
                       (if (3 -> lex.peekNext) 
                        // lex.symbols.colon // lex.symbols.virtual then
                           pDecl -> I.append;
                        else
                           pObjectGenerator -> I.append;
                       if)
                    else 
                       pObjectGenerator -> I.append;
                   if);
                // lex.symbols.special then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       pObjectGenerator -> I.append
                   if)
                // lex.symbols.keyword then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       pObjectGenerator -> I.append
                   if);
                // lex.symbols.string then
                   pObjectGenerator -> I.append
                // lex.symbols.leftBrack then
                   (* (exp) ... *)
                   pObjectGenerator -> I.append
               if);
               (if lex.symb = lex.symbols.semicolon then
                   lex; 
                   restart Loop
               if)
            #)
       exit I[]
       #);
     pDecl:
       (# D: ^Decl; sig: ^Signature; OD: ^ObjectGenerator; ptnKind: @integer;
          P: ^Pattern
       do (*lex.symb -> lex.symbols.print; ' ' -> put; lex.sym[] -> putline;*)
          pSignature -> sig[];
          (if lex.symb
           // lex.symbols.colon then
              (* plainPtn or data-item *)
              lex;
              (if lex.symb 
               // lex.symbols.constRef then 
                  lex;
                  (true,sig[]) -> pDataItem -> D[];
                  leave pDecl
               // lex.symbols.varRef then
                  lex;
                  (false,sig[]) -> pDataItem -> D[];
                  leave pDecl
               else
                  plainPtn -> ptnKind
              if);
           // lex.symbols.virtual then
              lex; 
              virtualPtn -> ptnKind               
           // lex.symbols.further then
              lex; 
              furtherPtn-> ptnKind
           // lex.symbols.final then
              lex; 
              FinalPtn -> ptnKind
           else
              syntaxError
          if);
          pObjectGenerator -> OD[];
          (sig[],OD[]) -> Pattern -> P[] -> D[]; 
          ptnKind -> P.ptnKind;
          OD.IS.ifBasic -> P.isBasicPtn;
          (if D.primNo            
           // object_prim then D[] -> objectDecl[]
           // none_prim then D[] -> noneDecl[]
           // integer_prim then D[] -> integerDecl[]
           // char_prim then D[] -> charDecl[]
           // string_prim then D[] -> stringDecl[]
           // boolean_prim then D[] -> booleanDecl[]
           // error_prim then D[] -> errorDecl[]
           // this_prim then D[] -> thisDecl[]
           // thisCore_prim then D[] -> thisCoreDecl[]
           // Resume_prim then D[] -> resumeDecl[];
           // ifThen_prim then D[] -> ifThenDecl[]
           else
              (if D.isCore 
               // core_prim then D[] -> coreDecl[]                            
          if)if)          
       exit D[]
       #);
     pSignature:
       (* foo:
        * fool(a: ?integer, ...):
        * %put x: ?integer ... :
        * ++ V: ?integer: 
        *)
       (# sym: ^text; sig: ^Signature; args: ^Arguments       
       do (if lex.symb              
           // lex.symbols.idf then 
              lex.sym[] -> sym[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then
                  lex;
                  Arguments -> args[]; true -> args.isFunction;
                  pArguments
                  (#
                  do D[] -> args.append
                  #);
                  (if lex.symb = lex.symbols.rightBrack then
                      lex;
                   else
                      syntaxError
                  if);
                  (sym[],args[],false) -> FunctionSigGen -> sig[];
               else 
                  (* UnarySignature *)
                  Arguments -> args[];
                  (sym[],args[],false) -> UnarySigGen -> sig[]
              if)
           // lex.symbols.keyword then
              lex.sym[] -> sym[];
              lex;
              Arguments -> args[]; 
              sym[] -> name -> args.append;
              pArguments
              (#
              do D[] -> args.append
              #); 
              (sym[],args[],true) -> KeyWordSigGen -> sig[];
              sig.setId
           // lex.symbols.special then
              (* binary *)
              lex.sym[] -> sym[];
              lex;
              Arguments -> args[]; true -> args.isBinary;
              pArgument -> args.append;
              (sym[],args[],false) -> BinarySigGen -> sig[]
          if);
          (if lex.symb = lex.symbols.value then
              lex;
              pValue -> sig.val[] -> sig.append
          if);
          (*'Sig: ' -> puttext; sig.doPT -> putline;*)
       exit sig[]
       #);     

     pArgument:
       (# D: ^Decl; P: ^Pattern
       do pDecl -> D[]; (* Perhaps not all decl's should be allowed *)
          (if D## = pattern## then
              D[] -> P[];
              (if P.ptnKind = plainPtn then
                  SyntaxError
                  (#do 'A non-virtual pattern cannot be an argument' -> putline #)
          if)if)
       exit D[]
       #);
     pArguments:
       (# D: ^TopNode
       do Loop:
            (#
            do pArgument -> D[]; 
               inner pArguments;
               (if lex.symb 
                // lex.symbols.fatComma then
                   lex.sym[] -> Name -> D[];
                   lex;
                   inner pArguments;
                   restart Loop
                // lex.symbols.comma then
                   lex;
                   restart Loop
               if)
            #)
       #);
     pValue:
       (# V: ^Value
       do Value -> V[];
          (if lex.symb = lex.symbols.leftBrack then
              lex; 
              Loop:
                (#
                do pDecl -> V.append;
                   (if lex.symb 
                    // lex.symbols.comma then
                       lex;
                       restart Loop
                    // lex.symbols.rightBrack then
                       lex
                   if)
                #)
           else
              pDecl -> V.append
          if)
       exit V[]
       #);
     pInvocation:
       (* foo
        * R.foo
        * R ++ E
        * R.%put E1 %at Inx
        * a:= a + b * 117
        * R.S ++ E . %put E %at I
        *)
       (# IV: ^Invocation;
          E: ^Exp;
          i: @integer
       do Invocation -> IV[]; 
          Loop:
            (#
            do i + 1 -> i;
               pExp -> E[] -> IV.append; (* elim is E.isEmpty *)
               (if lex.symb 
                // lex.symbols.dot then
                   lex;
                   restart Loop
                // lex.symbols.special then 
                   restart Loop
               if)
            #);
          (if i = 1 then E.isEmpty -> IV.isEmpty if)
       exit IV[]
       #);
     pExp:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if E0 %then E1 %else E2
        *)
       (# sym,sym2: ^Text;
          E: ^Exp; 
       do (* '\npExp: ' -> puttext; lex.symb -> lex.symbols.print; 
           *  ' ' -> put; lex.sym[] -> puttext;
           * *)
          (if lex.symb 
           // lex.symbols.const then
              lex.sym[] -> Const -> E[];
              lex;
           // lex.symbols.string then
              lex.sym[] -> StringObj -> E[];
              lex;
           // lex.symbols.charSy then 
              lex.sym[] -> CharObj -> E[];
              lex;
           // lex.symbols.idf then 
              lex.sym[] -> sym[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then
                  lex;
                  sym[] -> pFunction  -> E[]
               else (*unary *)
                  (sym[],arguments) -> UnaryGen -> E[]
              if)
           // lex.symbols.special then
              lex.sym[] -> sym[];
              lex;
              sym[] -> pBinary -> E[]
           // lex.symbols.keyword then 
              lex.sym[] -> sym[];
              lex;             
              (*lex.sym[] -> puttext;*)
              sym[] -> pKeyword -> E[]
           // lex.symbols.leftBrack then
              lex.sym[] -> sym[];
              lex;
              pBracketedExp -> E[]
          (* // lex.symbols.begin then
              pMainPart -> ObjectGeneratorExp -> E[]*)
           else 
              Exp -> E[]; 
              true -> E.isEmpty
          if);
       exit E[]
       #);
     pFunction:
       (# sym: ^text;
          F: ^Exp;
          args: ^Arguments;
          OG: ^ObjectGenerator
       enter sym[]
       do Arguments -> args[];  true -> args.isFunction;         
          loop:
            (if true then
                pObjectGenerator -> OG[];(* -> F.append;*)
                OG[] -> Args.append;
                (*lex.symb -> lex.symbols.print;*)
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex
                 else
                    6 -> SyntaxError
                if)
            if);
          (sym[],args[]) -> FunctionGen -> F[]
       exit F[]
       #);
     pBinary:
       (# op: ^text; IV: ^ObjectGenerator; B: ^Exp; args: ^Arguments
       enter op[]
       do Arguments -> args[];
          true -> args.isBinary;
          pObjectGenerator -> IV[] -> args.append;
          (op[],args[]) -> BinaryGen -> B[];
       exit B[]
       #);
     pKeyword:
       (# sym,id: ^Text; (* sym = keyword = %put *)
          K: ^Exp;
          args: ^Arguments
       enter(sym[])
       do sym[] -> id[]; 
          Arguments -> args[];
          true -> args.isKeyWord;
          sym.copy -> Name -> args.append;
          Loop:
            (#
            do pObjectGenerator -> args.append; 
               (if lex.symb 
                (*// lex.symbols.keyword *)
                // lex.symbols.fatComma then 
                   lex.sym[] -> Name -> args.append;
                   lex.sym[] -> id.append;
                   lex;
                   restart Loop
               if);
            #);
          (id[],args[]) -> KeyWordGen -> K[]
       exit K[]
       #);
     pBracketedExp:
       (# E: ^exp; I: ^Invocation
       do (* pExp *) pInvocation  -> I[];
          (if lex.symb = lex.symbols.rightBrack then
              lex
           else
              111 -> SyntaxError
          if);
          I[] -> BracketedExp -> E[]
       exit E[]
       #);

     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          newline;
          3 -> lex.printlines;
          newline;
          inner;
          (failureTrace (*dumpStack*),'Syntax error in:\n'->lex.fileName.prepend)  
            -> stop
        #);
     genTokenStream: superParser
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.const
                // lex.symbols.charSy
                // lex.symbols.string
                // lex.symbols.special 
                // lex.symbols.keyword 
                // lex.symbols.fatComma then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if)
           if)
       #);
     lex: ^lexer;
     (*FN: ^text;*)
     topPath: ^text;
     onlyLex: @boolean;
     rootModule,
     m,main: ^Module
  do (if onlyLex then
         FN[] -> genTokenStream
      else
         &lexer[] -> lex[]; 
         (if true then
             path.init;
             locateWorld.init;
             (fullPath,FN[]) -> locateWorld -> topPath[];
             (*'topPath: ' -> puttext; topPath[] -> putline;*)
             topPath[] -> pModule -> rootModule[];
             rootModule.handleDirModules
             (# pDirModule::
                  (#
                  do (*'pDirModule: ' -> puttext; moduleDir[] -> putline;*)
                     moduleDir[] -> path.push;
                     (path.append,moduleDir[]) -> DirectoryComponents
                     (# 
                     do (*'DirElm: ' -> puttext; current[] -> putline;*)
                        current[] -> pModule -> md[];
                        (*'Module: ' -> putline;  md.doPT -> putline;*)
                     #);
                     path.pop
                  #)
             #)
               -> main[];
          else
             FN[] ->  pModule -> main[];
         if);
         (*main.doPT -> putline;*)
         (*rootModule.doPP -> putline;*)
         inner
     if);
  #)
