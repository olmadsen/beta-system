ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qlexer';
INCLUDE 'qModuleHandler';
INCLUDE 'qprimitives';
INCLUDE 'qStdBetaParser';
INCLUDE 'qStdBetaChecker';
INCLUDE 'qStdBetaAllocator';
INCLUDE 'qStdBetaGenerator';
INCLUDE 'qsyntaxErrorMessages';
BODY 'parseBody'
---lib:attributes---
(************************ Grammar **********************************
 * Module ::= DataItem
 * Item ::= Decl | ObjectSpec | Property
 * Decl ::= DataItem | Pattern 
 * ObjectSpec::= ObjectCall | ObjectDescriptor
 * ObjectCall ::= Invocation
 * ObjectDescriptor ::= Invocation MainPart
 * MainPart ::= Item *
 * Invocation ::= Exp '.' Exp
 *             |  Exp '%&' exp 
 * Exp ::= Const | FloatConst| Char | String | '(' Exp ')'
 *      |  ObjectInvocation
 * ObjectInvocation ::= Idf
 *                   |  Idf '(' Arguments ')'
 *                   |  KeyWord
 *                   |  Special Argument
 * Arguments ::= ObjectSpec * ,
 *)
parser: ModuleHandler
  (# Irootmodule::
       (# root: @ iModule;
       do rootModule[] -> root.M[];
          (*rootModule.name.lexemSy -> root.nm[];*)
          root[] -> rootM[];
       #);     
     superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)  
          altParser: @boolean
       enter(fileName[],altParser)
       do (path.append).copy -> pathToFN[];
          lex[] -> oldLex[];
          &lexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          (if false then
              '**** superParser: ' -> putline; inFile.name -> putline;
              '**   pathToFN: ' -> puttext; pathToFN[] -> putline;
          if);
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          true -> lex.isXbeta;
          traceParse -> lex.traceParse;
          lex;
          true -> pNewFatCommaFile;
          INNER;
          inFile.close;
          (if oldLex[] <> none then
              oldLex.hasLexError or lex.hasLexError -> oldlex.hasLexError;
          if);
          oldLex[] -> lex[];
       #);
     pModule: superParser
       (# checkModuleName:
            (# pos,i: @integer; MN: ^text
            do pathToFN.scanAll
               (#
               do i + 1 -> i;
                  (if ch = dirCh then
                      i -> pos
                  if);
               #);
               (pos +1,pathToFN.length) -> pathToFn.sub -> MN[];
               (if false then
                   '**** checkModuleName: ' -> puttext; 
                   pos -> putint; newline;
                   pathToFN[] -> putline;
                   mn[] -> putline;
                   sig.dopt -> putline;
               if);
               (if MN[] -> sig.id.equal then
                else
                   newline;
                   '*** Fatal error: The name of the object module:\n\t"' 
                     -> puttext; 
                   sig.id[] -> puttext;
                   '"\n    ' -> puttext;
                   'must be the same as the name of the directory in:\n\t'
                     ->puttext;
                   pathToFN[] -> puttext;
                   '\n    Directory name is: "' -> puttext;
                   MN[] -> puttext; 
                   '" - These names are case sensitive\n' -> putline;
                   stop
               if)
            #);
          symb: ^text;
          sig: ^Signature;
          M: ^Module; E: ^Exp
       do (if lex.symb = lex.symbols.idf then
              'pModule'->trace;
              pSignature -> sig[];
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb 
                   // lex.symbols.constRef then 
                      lex;
                      (true,false,sig[],true) -> pSuperDataItem 
                      (#
                      do sig[] -> OG.sig[];
                         (true,sig[],OG[]) -> Module -> DI[]
                      #) -> M[];
                      pathToFN[] -> M.pathToFN[];
                      inFile[] -> M.inFile[];
                      (if not parseMain then
                          checkModuleName
                      if)
                   else
                      3 -> SyntaxError
                  if)
               else
                  2 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if)
       exit M[]
       #);
     pSuperDataItem:
       (# isConst,isValue,isModule: @boolean;
          sig: ^Signature;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem
       enter(isConst,isValue,sig[],isModule)
       do (if isModule then
              true -> pObjectDescriptor -> OG[];
           else
              pObjectSpec -> OG[]
          if);
          inner
       exit DI[]
       #);
     pDataItem: pSuperDataItem
       (# 
       do 'pDataItem'->trace;
          (isConst,isValue,sig[],OG[]) -> DataItem -> DI[];
          (if ((OG.super.doPT).length = 0) and (OG.IS.isEmpty) then
              118 -> SynTaxError
          if)
       #);
     pVarRefType:
       (# isConst,isValue: @boolean;
          rightB: @integer;
          sig: ^Signature;
          typeId: ^Text;
          E: ^Exp;
          IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;
          bracks: ^text;
          special: @boolean; 
          (*avoid adding () to typeId for XV: ref Indexed(range,#char)*)
       enter(isConst,isValue,sig[])
       do next:
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> typeId[];
              lex;
              L:
              (if lex.symb
               // lex.symbols.leftBrack 
               // lex.symbols.leftSquare
               // lex.symbols.begin then
                  lex.symb + 1 -> rightB;
                  (* remember double brackets: (), [], {} *)
                  lex.symb -> lex.symbols.astext -> bracks[]; 
                  rightB -> lex.symbols.asText -> bracks.append; 
                  lex;
                  L:
                    (#
                    do pExp; (* !!!!! *)
                       (if lex.symb = lex.symbols.comma then
                           lex;
                           true -> special;
                           restart L
                    if)#);
                  (if lex.symb = rightB then
                      (if false and not special then
                          bracks[] -> typeId.append -> typeId[];
                      if);
                      lex;
                      (if lex.symb = lex.symbols.fatComma then
                          lex.sym[] -> typeId.append -> typeId[];
                          lex;
                          restart L
                       else
                          (*(if lex.symb = lex.symbols.dot then
                              lex;
                              restart next
                          if)*)
                      if)
                   else
                      120 -> syntaxError
                  if)
               else
                  (*(if lex.symb = lex.symbols.dot then
                      lex;
                      restart next
                  if)*)
              if);
           else
              119 -> syntaxError
          if);
       exit typeId[]
       #);
     pVarRefTypeNoBrack:
       (# isConst,isValue: @boolean;
          rightB: @integer;
          sig: ^Signature;
          typeId: ^Text;
          E: ^Exp; args: ^Arguments;
          (*avoid adding () to typeId for XV: ref Indexed(range,#char) *)
       enter(isConst,isValue,sig[])
       do 'pVarRefTypeNoBrack:' ->trace;
          (if lex.symb = lex.symbols.idf then
              (*':idf:'->puttext;*)
              lex.sym[] -> typeId[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then
                  Arguments -> args[]; true -> args.isFunction;
                  readArgs:
                    (#
                    do lex;
                       pObjectSpec -> args.append;
                       (if lex.symb 
                        // lex.symbols.comma then
                           restart readArgs
                        // lex.symbols.rightBrack then
                           lex
                        else
                           999 -> syntaxError
              if)#)if);
              'pVarRefTypeNoBrack:after:pExp:new:' ->trace
              (#
              do (if args[] <> none then args.dopt -> dumpTN if)
              #);
              L: (* what goes one here? *)
                (if lex.symb 
                 // lex.symbols.fatComma then
                    lex.sym[] -> typeId.append -> typeId[];
                    lex;
                    restart L
              if);
           else
              119 -> syntaxError
          if);
       exit(typeId[],args[])
       #);
     pVarRefTypeNoBrack2:
       (# isConst,isValue: @boolean;
          rightB: @integer;
          sig: ^Signature;
          typeId: ^Text;
          E: ^Exp;
          IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;
          bracks: ^text;
          special: @boolean; 
          (*avoid adding () to typeId for XV: ref Indexed(range,#char) *)
       enter(isConst,isValue,sig[])
       do 'pVarRefTypeNoBrack2:'->trace;
          (if lex.symb = lex.symbols.idf then
              (*':idf:'->puttext;*)
              lex.sym[] -> typeId[];
              lex;
              L:
                (if lex.symb 
                 // lex.symbols.fatComma then
                    lex.sym[] -> typeId.append -> typeId[];
                    lex;
                    restart L
              if);
           else
              119 -> syntaxError
          if);
       exit typeId[]
       #);
     pVarRefDI:
       (# E: ^Exp; IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;
          args: ^Arguments;
          isConst,isValue: @boolean; sig: ^Signature; typeId: ^Text
       enter(isConst,isValue,sig[])
       do Invocation -> IV[];
          next:
            (if true then
                (isConst,isValue,sig[]) 
                  -> pVarRefTypeNoBrack -> (typeId[],args[]);
                (if args[] = none then
                    (typeId[],Arguments) -> unaryGen -> E[] -> IV.append;
                 else
                    (typeId[],args[]) -> functionGen -> E[] -> IV.append;
                if);
                (if lex.symb = lex.symbols.dot then
                    lex;
                    restart next
            if)if);
          Items -> IS[]; true -> IS.isEmpty -> IV.isEmpty;
          (IV[],IS[]) -> ObjectDescriptor -> OG[];
          (isConst,isValue,sig[],OG[]) -> DataItem -> DI[];
          (if false then 
              newline;
              '**** DI:with:VarRefType: ' -> putline;
              DI.dopt -> putline;
              newline
          if)
       exit DI[]
       #);
     pLabelDecl:
       (# OG: ^ObjectSpecification;
          D: ^LabelDecl;
          sig: ^Signature;
       enter sig[]            
       do pObjectDescriptor -> OG[];
          (sig[],OG[]) -> LabelDecl -> D[]
       exit D[]
       #);
     pStatement: 
       (# S: ^Statement (* ObjectSpecification *)
       <<SLOT pStatement:doPart>>
       exit S[]
       #);
     (* Exp: Item ...
      * Statement: Exp ...
      * Assignment: Statement ...
      * ObjectSpecification: Statement ...
      * ObjectDescriptor: ObjectSpecification ...
      * <Statement> ::= <Assignment>  I <ObjectDescriptor> 
      * Seems that pObjectSpec is OK
      *  pStatement: calls pInvocation 
      *    if assign then pAssign
      *    else pMainPart
      * We may eliminate ObjectSpecification  and call pStatment directly
      *)

     pObjectSpec:
       (# S: ^Statement
       do 'pObjectSpec:'->trace;
          (if invAsDerivedP then
              pObjectDescriptor -> S[]
           else
              pStatement -> S[]
          if)
       exit S[]
       #);
     pObjectDescriptor:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
       (# IV: ^Invocation;
          IS: ^Items;          
          OG: ^ObjectDescriptor;
          E: ^Exp;
          OI: ^ObjectInvocation;
          inPtn: @boolean
       enter inPtn
       do 'pOD'->trace; 
          (if invAsDerivedP then
              'pOD:invAsDerivedP'->trace;
              (*lex.parenthLevel + 1 -> lex.parenthLevel;*)
              pInvocation -> IV[];
              pBindings -> IS[];
              'pOd:afterBindings'->trace;
              IS[] -> pMainPartII -> IS[];
              'pOD:after:MainPartII'->trace;
              (IV[],IS[]) -> ObjectDescriptor -> OG[];
              OG.IS.handleNewProps;
           else
              'pOd:old'->trace;
              pInvocation -> IV[];
              pMainPart -> IS[]; (* if we split OG into singular and pattern
                                  * then there must be a main part *)
              (if IV.isEmpty and IS.isEmpty then
                  222 -> syntaxError
              if);
              (if false and pNewFatCommaFile then
                  '**** pOG:IV:' -> puttext; IV.dopt -> putline;
                  '**   IS: ' -> puttext; IS.dopt -> puthead;
              if);
              
              (if inPtn and pNewFatCommaFile and IS.isEmpty then 
                  IV.last -> E[]; 
                  (if false then
                      '**   E: ' -> putline;
                      E.args.scansons
                      (#do current.dopt -> puthead;
                      #);
                      E.args.noOfSons -> putint;  ' ' -> put; 
                      E.args.inBraces -> putboolean; 
                      newline;
                  if);
                  (if (E.args[] <> none) 
                      and (E.args.noOfSons = 4)
                      and (E.args.inBraces) 
                      and E.isObjectInvocation then
                      (if false then
                          '**** pOG:got:arg:as:mainPart: ' -> puttext;
                          E.args.noOfSons -> putint; newline;
                          IV.dopt -> puthead;
                      if);
                      IV.mkOG -> (IV[],IS[]);
                      (if false then
                          '**   IV:' -> puttext; IV.dopt -> putline;
                          '**   IS:' -> putline; IS.dopt -> putHead
              if)if)if);
              (IV[],IS[]) -> ObjectDescriptor -> OG[];
              OG.IS.handleNewProps;
          if)
       exit OG[]
       #);
     pBindings:
       (# B: ^Items (*Bindings*)
       do 'pBindings'->traceT;
          Items -> B[];
          (*(if lex.symb = lex.symbols.semicolon then lex if);*)
          (if lex.symb
           // lex.symbols.leftBrack then
              lex;
              'pBindings('->traceT;
           else
              (if (1->lex.peekNext) = lex.symbols.idf then
                  'pBindings:idf'->trace; 
                  (if 2 -> lex.peekNext
                   // lex.symbols.further then
                      'pBindings:further'->traceT;
                   // lex.symbols.final then
                      'pBindings:final'->traceT;
                      lex;
                      lex;
                      lex;
                      'pBindings:final:lex'->traceT;
              if)if)
          if);
          (if false and invAsDerivedP then
              lex.parenthLevel - 1 -> lex.parenthLevel;
          if)
       exit B[]
       #);
     pMainPartII:
       (# IS: ^Items;
       enter IS[]
       do 'pMainPartII'->trace;
          (if lex.symb = lex.symbols.begin then 
              'pMainPartII:after leftCurly'->trace;
              lex;
              pItems -> IS[];
              'pMainPartII:after:items'->trace;
              (if lex.symb // lex.symbols.end // lex.symbols.eos then
                  lex;
               else
                  lex.symb -> lex.symbols.asText ->putline;;
                  2 -> SyntaxError
              if);
           else
              Items -> IS[];
              true -> IS.isEmpty
          if);
       exit IS[]
       #);
       
     pMainPart:
       (# IS: ^Items;
       do 'pMainPart:'->trace;
          (if lex.symb = lex.symbols.begin then 
              'pMainPart:after leftCurly'->trace;
              lex;
              pItems -> IS[];
              'pMainPart:after:items'->trace;
              (if lex.symb // lex.symbols.end // lex.symbols.eos then
                  lex;
               else
                  lex.symb -> lex.symbols.asText ->putline;;
                  22 -> SyntaxError
              if);
           else
              Items -> IS[];
              true -> IS.isEmpty
          if);
       exit IS[]
       #);
     pNewProperty:
       (# propId: ^Name; NP: ^NewProperty; args: ^NewPropertyArguments
       enter Name -> propId[]
       do NewPropertyArguments -> args[];
          parseArgs:
            (if lex.symb 
             // lex.symbols.idf 
             // lex.symbols.const
             // lex.symbols.floatConst
             // lex.symbols.string then
                pInvocation -> args.append;
                (if lex.symb = lex.symbols.comma then
                    lex;
                    restart parseArgs
            if)if);
          (propId[],args[]) -> NewProperty -> NP[];
          (if ('%BetaModule' -> propID.T.equalNCS) then
              (if handleBetaModules then
                  NP[] -> parseStdBeta;
          if)if);
       exit NP[]
       #);
     parseStdBeta:
       (# prop: ^NewProperty;
          stdParser: @ qStdBetaGenerator
       enter prop[]
       do (if false then 
              '**** parseStdBeta:\n'->dumpT;
              topPath[] -> dumpTN;
              FN[] -> dumptN;
              getCurrentDir -> dumpTN
          if);
          prop.args.scanSons
          (# INV: ^Invocation; 
          do current[] -> INV[];
             INV.scanSons
             (# S: ^StringObj;  mainModule,topModule: ^stdParser.StdBetaModule;
                errors:  ^Stream
             do (if current.isStringLiteral then
                    current[] -> S[];
                    (none,false,none,S.T[],getCurrentDir,cd[]) 
                      -> stdBetaCompiler
                      -> (iMain[],errors[],mainModule[],topModule[]);
                    (mainModule[],topModule[])
                      -> stdBetaCompiler.add
          if)#)#);
       #); 
  
     handleProps:
       (# sig: ^Signature; ptnKind: @integer; OD: ^ObjectDescriptor; 
          D: ^Decl; P: ^Pattern
       enter(sig[],ptnKind,OD[])
       do  (*OD.IS.handleProps; *)
          
          (if OD.IS.primNo 
           // restart_prim // leave_prim then
              (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
           // indexedPut_prim 
           // indexedGet_prim
           // stringGet_prim
           // indexed_prim // rIndexed_prim
           // asString_prim then
              (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
           // put_prim // get_prim
           // ifthen_prim // inner_prim // none_prim
           // suspend_prim // resume_prim 
           // disable_prim // enable_prim // attach_prim
           // cmpAndSwap_prim // fork_prim // sleep_prim // thisCore_prim 
           // file_open_prim // file_get_prim 
           // file_eof_prim // file_close_prim 
           // dumpObj_prim then
              (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
           else              
              (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
          if);
          OD.IS.isPrimitive -> P.isPrimitivePtn;
          (if D.primNo
           // object_prim then D[] -> objectDecl[]
           // none_prim then D[] -> noneDecl[]
           // integer_prim then D[] -> integerDecl[]
           // char_prim then D[] -> charDecl[]
           // string_prim then D[] -> stringDecl[]
           // boolean_prim then D[] -> booleanDecl[]
           // float_prim then D[] -> floatDecl[]
           // error_prim then D[] -> errorDecl[]
           // this_prim then D[] -> thisDecl[]
           // thisCore_prim then D[] -> thisCoreDecl[]
           // Resume_prim then D[] -> resumeDecl[]
           // ifThen_prim then D[] -> ifThenDecl[]
           // indexed_prim then D[] -> IndexedDecl[]
           else
              (if D.isCore = core_prim then D[] -> coreDecl[]
          if)if)
       exit D[]
       #);
     pItems:
       (# I: ^Items
       do 'pItems'->trace;
          Items -> I[]; true -> I.commentBefore;
          Loop:
            (# D: ^Decl
            do (if lex.symb 
                // lex.symbols.inArg // lex.symbols.outArg 
                // lex.symbols.class (*// lex.symbols.designator*) then
                   pDecl -> D[] -> I.append
                // lex.symbols.idf then
                   (* Here we do lookahead of 1-3 symbols to determine
                    * if the next item is a DECLARATION or an EXPRESSION
                    *)
                   (if 1 -> lex.peekNext 
                    // lex.symbols.comma
                    // lex.symbols.return
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                    // lex.symbols.further
                    // lex.symbols.final then
                       pDecl -> I.append; 
                       (*lex.symb -> lex.symbols.print*)
                    // lex.symbols.leftBrack then 
                       (* DECL foo(v: var integer, ...): ...
                        * Exp: foo(e1,e2,e2)
                        *)
                       (if (3 -> lex.peekNext) 
                        // lex.symbols.colon // lex.symbols.virtual then
                           pDecl -> I.append;
                        else
                           (if ((2->lex.peekNext) = lex.symbols.designator) then
                               'gotDesignator'->trace;
                               pDecl -> I.append;
                            else
                               (if false then
                                   pObjectDescriptor -> I.append;
                                else
                                   pObjectSpec -> I.append;
                       if)if)if)
                    // lex.symbols.leftSquare then
                       (if pNewFatCommaFile then
                           (if (3 -> lex.peekNext) 
                            // lex.symbols.colon 
                            // lex.symbols.virtual then
                               pDecl -> I.append;
                            else
                               (if false then
                                   pObjectDescriptor -> I.append;
                                else
                                   pObjectSpec -> I.append;
                           if)if)
                        else
                           (if false then
                               pObjectDescriptor -> I.append;
                            else
                               pObjectSpec -> I.append;
                       if)if)
                    else 
                       (if false then
                           pObjectDescriptor -> I.append;
                        else
                           pObjectSpec -> I.append;
                   if)if);
                // lex.symbols.special then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon
                       (* never happen with new arg syntax? *)
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       (if (1 -> lex.peekNext) 
                        // lex.symbols.colon then
                           (* Needed for new syntax for arguments:
                            *    ++ :
                            *       in V: var integer
                            *)
                           pDecl -> I.append
                        // lex.symbols.virtual then
                           pDecl -> I.append                    
                        // lex.symbols.further
                        // lex.symbols.final then
                           pDecl -> I.append                           
                        else
                           (if false then
                               pObjectDescriptor -> I.append;
                            else
                               (# OGx: ^ObjectDescriptor
                               do pObjectSpec -> OGx[] -> I.append;
                               #)
                           if)
                   if)if)
                // lex.symbols.string then
                   (if false then
                       pObjectDescriptor -> I.append;
                    else
                       pObjectSpec -> I.append
                   if)
                // lex.symbols.leftBrack then
                   (* (exp) ... *)
                   (if false then
                       pObjectDescriptor -> I.append;
                    else
                       pObjectSpec -> I.append
                   if)
                // lex.symbols.property then
                   (# propId: ^text
                   do lex.sym[] -> propId[];
                      lex;
                      propId[] -> pNewProperty -> I.append;
                   #)
                // lex.symbols.const 
                // lex.symbols.floatConst 
                // lex.symbols.charSy then 
                   pObjectDescriptor -> I.append; (* perhaps OG *)
                // lex.symbols.dots then
                   lex;
                   Dots -> I.append
                // lex.symbols.slotBegin then
                   lex; 
                   pSlot -> I.append
               if);
               (if lex.symb = lex.symbols.semicolon then
                   lex; 
                   restart Loop
               if)
            #)
       exit I[]
       #);
     pDecl:
       (# D: ^Decl; sig: ^Signature; OD: ^ObjectDescriptor; 
          ptnKind: @integer; DI: ^DataItem;
          P: ^Pattern; isInArg,isOutArg,mustBePattern,isDesignator: @boolean
       do (if lex.symb 
           // lex.symbols.inArg then
              lex;
              true -> isInArg
           // lex.symbols.outArg then
              lex;
              true -> isOutArg            
           // lex.symbols.class then
              lex; 
              true -> mustBePattern
           // lex.symbols.designator then
              lex;
              true -> isDesignator
          if);
          'pDecl:after:inOut' -> trace;
          pSignature -> sig[];
          'pDecl:after:pSignature: '->trace;
          L:
            (#
            do (if lex.symb
                // lex.symbols.colon then
                   (* plainPtn or data-item *)
                   lex;
                   (if lex.symb 
                    // lex.symbols.constRef then 
                       lex;
                       (true,false,sig[],false) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varRef then
                       lex; 
                       (if pNewFatCommaFile then
                           (if false then
                               '**** varRef:('->puttext; sig.dopt -> puttext;
                               ' ' -> put; 
                               lex.symb -> lex.symbols.asText -> puttext; 
                               ' '->put; lex.sym[] -> puttext;
                           if);
                           (false,false,sig[]) -> pVarRefDI -> D[];
                        else
                           (false,false,sig[],false) ->pDataItem -> D[];
                       if);
                       leave L
                    // lex.symbols.constVal then 
                       lex;
                       (true,true,sig[],false) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varVal then
                       lex;
                       (false,true,sig[],false) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.doSy then
                       lex;
                       (sig[]) -> pLabelDecl -> D[];
                       leave L                       
                    else
                       plainPtn -> ptnKind
                   if);
                // lex.symbols.virtual then
                   lex; 
                   (if lex.symb
                    // lex.symbols.constRef then 
                       lex;
                       (true,false,sig[],false) -> pDataItem -> D[] -> DI[];
                       true -> DI.virtualDI;
                       leave L
                    // lex.symbols.varRef then
                       lex; 
                       (if pNewFatCommaFile then
                           (if false then
                               '**** varRef:('->puttext; sig.dopt -> puttext;
                               ' ' -> put; 
                               lex.symb -> lex.symbols.asText -> puttext; 
                               ' '->put; lex.sym[] -> puttext;
                           if);
                           (false,false,sig[]) -> pVarRefDI -> D[] -> DI[];
                           true -> DI.virtualDI;
                        else
                           (false,false,sig[],false) ->pDataItem -> D[] -> DI[];
                           true -> DI.virtualDI;
                       if);
                       leave L
                    // lex.symbols.constVal then 
                       lex;
                       (true,true,sig[],false) -> pDataItem -> D[] -> DI[];
                       true -> DI.virtualDI;
                       leave L
                    // lex.symbols.varVal then
                       lex;
                       (false,true,sig[],false) -> pDataItem -> D[] -> DI[];
                       true -> DI.virtualDI;
                       leave L
                    else
                       virtualPtn -> ptnKind
                   if)
                // lex.symbols.further then
                   lex; 
                   furtherPtn-> ptnKind
                // lex.symbols.final then
                   lex; 
                   FinalPtn -> ptnKind
                else
                   3 -> syntaxError;
                   (if errorDecl[] = none then 
                       '**** errorDecl is none' -> putline
                   if);
                   errorDecl[] -> D[];
                   leave L
               if);
               true -> pObjectDescriptor -> OD[];
               
               (*OD.IS.handleNewProps;*)
               (if OD.IS.primNo 
                // restart_prim // leave_prim then
                   (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
                // indexedPut_prim 
                // indexedGet_prim
                // stringGet_prim
                // indexed_prim
                // rIndexed_prim
                // asString_prim then
                   (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
                // put_prim // get_prim
                // ifthen_prim // inner_prim // none_prim
                // suspend_prim // resume_prim 
                // disable_prim // enable_prim // attach_prim
                // cmpAndSwap_prim // fork_prim // sleep_prim 
                // thisCore_prim 
                // file_open_prim // file_get_prim 
                // file_eof_prim // file_close_prim 
                // dumpObj_prim then
                   (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
                else
                   (if false then
                       '**** ptn: ' -> putline;
                       sig.dopt -> putline;
                       sig.id[] -> putline;
                       (*sig._a_rgs.dopt -> putline; '---'-> putline;
                        * sig._a_rgs.scanSons(#do current.dopt->putline #);
                        *)
                   if);
                   (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
               if);
               OD.IS.isPrimitive -> P.isPrimitivePtn;
               (if D.primNo
                // object_prim then D[] -> objectDecl[]
                // none_prim then D[] -> noneDecl[]
                // integer_prim then D[] -> integerDecl[]
                // char_prim then D[] -> charDecl[]
                // string_prim then D[] -> stringDecl[]
                // boolean_prim then D[] -> booleanDecl[]
                // float_prim then D[] -> floatDecl[]
                // error_prim then D[] -> errorDecl[]
                // this_prim then D[] -> thisDecl[]
                // thisCore_prim then D[] -> thisCoreDecl[]
                // Resume_prim then D[] -> resumeDecl[]
                // ifThen_prim then D[] -> ifThenDecl[]
                // indexed_prim then D[] -> IndexedDecl[]
                else
                   (if D.isCore = core_prim then D[] -> coreDecl[]
               if)if);
            #);
          isInArg -> D.isInArg;
          isOutArg -> D.isOutArg;
          (if false then
              isDesignator -> D.isDesignator;
              (if isDesignator then '**** designator: ' -> puttext; D.doPT -> putline if);
          if)
       exit D[]
       #);
     mkProp:
       (# propId:  ^Name; NP: ^NewProperty; args: ^NewPropertyArguments;
          stringArg:  ^StringObj; T:  ^Text; inv: ^Invocation
       enter(Name -> propId[],T[])
       do NewPropertyArguments -> args[];
          Invocation -> inv[]; 
          T[] -> StringObj -> stringArg[] -> inv.append;
          inv[] -> args.append;
          (propId[],args[]) -> NewProperty -> NP[]
       exit NP[]
       #);
     pArgument:
       (# D: ^Decl; P: ^Pattern
       do pDecl -> D[]; 
          true -> D.isArg; (* when is D.isArg used ? *)
          true -> D.isInArg -> D.inSig; (* is NOT inArg in return *)
          (if D## = pattern## then
              D[] -> P[];
              (if P.ptnKind = plainPtn then
                  SyntaxError
                  (#
                  do 'A non-virtual pattern cannot be an argument' 
                       -> putline 
          #)if)if)
       exit D[]
       #);
     pSignature:
       (* foo: ...
        * foo(a: var T, b: ref S): ...
        * foo(x: var integer):at[inx: var integer]:do{V: <Object}: ...
        * ++ V: var integer: ...
        *)
       (# sym,id,fc: ^text; names: ^NameList; sig: ^Signature; 
          args: ^Arguments; 
          prevSymb: @char;
          D: ^Decl; Itm: ^Items; isDesignator: @Boolean
       do NameList -> names[]; Items -> Itm[];
          'pSig'->trace;
          (if lex.symb
           // lex.symbols.idf then 
              (* got foo *)
              lex.sym[] -> sym[] -> NameDecl -> names.append;
              sym.copy -> id[];
              lex; (* ':' ( [ { *)
              (if lex.symb                   
               // lex.symbols.leftBrack 
               // lex.symbols.leftSquare
               // lex.symbols.begin then
                  'pSig:id'->trace;
                  lex.symb -> prevSymb;  
                  ('%$B',lex.sym.copy) -> mkProp -> Itm.append;
                  lex; 
                  (if lex.symb = lex.symbols.designator then
                      lex;
                      true -> isDesignator
                  if);
                  Arguments -> args[]; true -> args.isKeyword;
                  pArgument -> D[] -> Itm.append;
                  isDesignator -> D.isDesignator;
                  (if false and isDesignator then 
                      '**** designator:X: ' -> puttext;
                      D.doPT -> putline
                  if);
                  (sym[],names[],Itm[]) -> Signature -> sig[];
                  'after:pArg:pDecl'->trace;
                  (if lex.symb 
                   // prevSymb + 1 then
                      &text[] -> fc[]; lex.sym[] -> fc.append;
                      lex;
                      'prevSymb+1'->trace;
                      pParam:
                        (#
                        do (if lex.symb 
                            // lex.symbols.fatComma then
                               lex.sym[] -> id.append;
                               lex.sym[] -> fc.append;
                               lex;
                               (* next must be bracket *)
                               (if lex.symb                
                                // lex.symbols.leftBrack 
                                // lex.symbols.leftSquare
                                // lex.symbols.begin then
                                   lex.symb -> prevSymb; 
                                   lex.sym[] -> fc.append;
                                   lex; 
                                else
                                   666 -> SyntaxError
                               if);
                            // lex.symbols.comma then
                               lex;
                            else
                               ('%$E',fc[]) -> mkProp -> Itm.append;
                               leave pParam
                           if);
                           pArgument -> D[];
                           ('%$S',fc[]) -> mkProp -> Itm.append;
                           D[] -> Itm.append;
                           (if lex.symb 
                            // (prevSymb + 1) then
                               lex;
                               prevSymb + 1 -> lex.symbols.asText -> fc[];
                               'restartFat'->trace;
                               restart pParam
                            // lex.symbols.comma then
                               'restartCommaInFat'->trace;
                               ('%$S',',') -> mkProp -> Itm.append;
                               restart pParam
                            else
                               888 -> syntaxError
                           if)
                        #);
                      id[] -> sig.id[];
                      'prevSymb+1:end'->trace;
                   // lex.symbols.comma then
                      (* foo(x: var T , y: var S, ...): ...
                       *              ;
                       *)
                      lex; 
                      'commaNew'->trace;
                      ('%$S',',') -> mkProp -> Itm.append;
                      pCommaPar:
                        (#
                        do (* foo(x: var T , y: var S, ...): ...
                            *                ;
                            *)
                           pArgument -> D[] -> Itm.append;
                           (* foo(x: var T , y: var S, ...): ...
                            *                        ;    ;
                            *)
                           (if lex.symb 
                            // lex.symbols.comma then
                               lex;
                               'commaRestart'->trace;
                               ('%$S',',') -> mkProp -> Itm.append;
                               restart pCommaPar
                            // (prevSymb + 1) then
                               'commaRbrack'->trace;
                               ('%$E', prevSymb + 1 ->lex.symbols.asText)
                                 -> mkProp -> Itm.append;
                               lex
                        if)#)
                  if);
                  D.sig.id[] -> id[]; 
               else
                  'pSig:unary'->trace;
                  (sym[],names[],Itm[]) -> Signature -> sig[];
              if)
           // lex.symbols.special then                
              (* binary *)
              lex.sym[] -> sym[] -> NameDecl -> names.append;
              lex;
              'pSig:special'->trace;
              Arguments -> args[]; true -> args.isBinary;
              (if lex.symb 
               // lex.symbols.colon 
               // lex.symbols.virtual 
               // lex.symbols.further 
               // lex.symbols.final then
                  (sym[],names[],Itm[]) -> Signature -> sig[];
                  true -> sig.isBinary
               else
                  pArgument -> args.append;
                  args.scanSons
                  (# DI: ^DataItem
                  do current[] -> DI[]; 
                     DI[] -> Itm.append;
                     true->DI.isInArg
                  #);
                  (sym[],names[],Itm[]) -> Signature -> sig[];
              if)
           (*// lex.symbols.keyword then  
              (* old .xbeta syntax 
               * we  come here with .qbeta files that still have
               * @-keywords like @if in BETA.qbeta
               * )
              lex.sym[] -> sym[] -> nameDecl -> names.append;
              lex;
              Arguments -> args[]; 
              sym[] -> name -> args.append;
              true -> args.isNewKeyWord;
              (sym[],names[],Itm[]) -> Signature -> sig[];*)
           else
              '-error-' -> NameDecl -> names.append;
              4 -> syntaxError;
              ('-error-',names[],Itm[]) -> Signature -> sig[];
          if);
          (if lex.symb = lex.symbols.return then
              lex;
              pReturn(#do D[] -> Itm.append #) -> sig.return[]

          if);
          (if false then
              (if Itm.NoOfSons > 0 then
                  '\n**** signature items: ' -> puttext; sig.id[] -> putline;
                  Itm.dopt -> putline
          if)if);
          Invocation -> Itm.super[]; true -> Itm.super.ischecked;
          (*Itm[] -> sig.paramItems[];*) (* perhaps an argument to Signature? *)
          (*Itm[] -> sig.append*)
       exit sig[]
       #);
     pReturn:
       (# rtn: ^Arguments; D: ^Decl
       do Arguments -> rtn[]; true -> rtn.isReturn;
          (* check if lex.symb = lex.symbols.leftBracket and then 
           * perhaps pSigArgs; however do we have fatComma in return?
           *)
          pArgument -> D[] -> rtn.append; 
          false -> D.isInArg; true -> D.isOutArg;
          inner pReturn
       exit rtn[]
       #);
     brackAsText:
       (# sy: @integer; T: ^Text
       enter sy
       do (if sy
           // lex.symbols.leftBrack then '(' -> T[]
           // lex.symbols.rightBrack then ')' -> T[]
           // lex.symbols.begin then '{' -> T[]
           // lex.symbols.end then '}' -> T[]
           // lex.symbols.leftSquare then '[' -> T[]
           // lex.symbols.rightSquare then ']' -> T[]
           else
              '?' -> T[]
          if)
       exit T[]
       #);
     pArguments:
       (# args: ^Arguments; rightB: @integer; lastArg: ^Node
       enter(args[],rightB)
       do args.scanSons(#do current[] -> lastArg[] #);
          Arguments -> args[];
          true -> args.isFunction; false -> args.isKeyword;
          lastArg[] -> args.append;
          getArgs:
            (#
            do lex;
               (if lex.symb <> rightB then
                   inner pArguments;
                   (if lex.symb
                    // lex.symbols.comma then
                       restart getArgs
                    // rightB then
                       lex
                    else
                       200 -> syntaxError
            if)if)#)
       exit args[]
       #);
     pInvocation:
       (* foo
        * R.foo    .foo is a method invocation with possible arguments
        * R ++ E   ++ E is a method invocation with argument E
        * R.put(E):at [ix]
        * a:= a + b * 117
        * R.S ++ E . put(E):at[i]
        * foo.a ++ 12 OK
        * foo . ++ 12 - not OK; but accepted by parser
        *)
       (# IV: ^Invocation; OI: ^ObjectInvocation;
          E: ^Exp;
          i: @integer
       do 'pInvocation'->trace;
          (if true then
              pExp -> E[];
              (if E## = Invocation## then
                  E[] -> IV[]
               else
                  Invocation -> IV[];
                  E[] -> IV.append;   
              if);
              leave pInvocation
          if);
          (* do we need to set IV.isEmpty above? *)
          (if i = 1 then 
              E.isEmpty -> IV.isEmpty;
              (* if E.isEmpty, we have IV = (invocation (???))
               * where '???' is the label of an empty exp
               * This is an annoying special case that complicates
               * the compiler; we test for this situation 
               * in ObjectDescriptor::qGen and other places!
               * it would be more clean to do
               *  none -> IV.son[] where we get IV =  (invocation ())
               *)
          if);
       exit IV[]
       #);
     scanForBrace:
       (# T,inn: ^Text; first,last: @integer
       enter T[]
       do 0 -> first -> last;
          (* need to reconsider this one! Not clear what it does!
           * we should test that { and } are matching
           *)
          T.scanAll
          (# toInn,predIsSlash: @boolean; leftB,pos: @integer
          do pos + 1 -> pos; 
             (if ch 
              // '\\' then true -> predIsSlash
              // '{' then
                 &text[] -> inn[]; (* collect string between '{' and '}' *)
                 not predIsSlash -> toInn;
                 false -> predIsSlash;
                 pos -> first;
                 (if (leftB + 1 -> leftB) > 1 then
                     '!!!! Nested curlyLeftCh in String: "' -> puttext;
                     T[] -> puttext; '"\n' -> puttext
                 if);
                   // '}' then
                 (if not predIsSlash and ((leftB - 1 -> leftB) < 0) then
                     '!!!! No matching left brace "{" in String: "' -> puttext;
                     T[] -> puttext; '"\n' -> puttext
                  else
                     not predIsSlash -> toInn;
                     pos -> last;
                     (if not predIsSlash then
                         inner scanForBrace (* inn must be an Invocation *)
                 if)if);
                 false -> predIsSlash;
              else
                 false -> predIsSlash;
                 (if toInn then ch -> inn.put if)
             if);
          #)
       #);
     handleString: 
       (# T: ^Text; S: ^StringObj; E: ^Invocation; err: ^text
       enter T[]
       do T[] -> StringObj -> S[];
          T[] -> scanForBrace
          (# 
          do inn[] -> parseInv -> (err[],E[]);
             (if err[] <> none then
                 '*** syntax error' -> putline
              else
                 E[] -> S.append;
             if)
          #);
       exit S[]
       #);
     mkBinary:
        (* binE = (BinaryExp 
                      rec 
                      (ObjectInvocation 
                          op 
                          (arguments 
                              (ObjectGeneration 
                                  (Invocation arg) (Items)))))
         *)
        (# rec,arg: ^Exp; op: ^text; 
           IV: ^Invocation; OI: ^ObjectInvocation; 
           OGx: ^ObjectDescriptor; IS: ^Items;
           binE:  ^BinaryExp;
           args: ^Arguments
        enter(rec[],op[],arg[])
        do stripInv:
             (if (arg## = Invocation##) and (arg.noOfSons = 1) then
                 arg.son[] -> arg[];
                 restart stripInv
             if);
           (if arg## = Invocation## then
               (*'**** mkBinary:arg is Invocation:'->dumpT; arg.dopt->dumpTN;*)
               arg[] -> IV[]
            else
               arg[]->(Invocation->IV[]).append;
           if);
           (IV[],Items->IS[]) -> ObjectDescriptor -> OGx[];
           true -> IS.isEmpty;
           OGx[] -> (Arguments->args[]).append;
           (op[],args[]) -> ObjectInvocation -> OI[];
           '' -> StringObj -> OI.unit[];
           OI.binary -> OI.type[];
           (rec[],op[],OI[]) -> BinaryExp -> binE[];
        exit binE[]
        #);
     pExp:
       (# E,rE: ^Exp; sym: ^text; 
       do 'pExp'->trace;
          pSimpleExp -> E[]; (* E may be empty - should be fixed *)
          (if (lex.sym[] -> lex.symbols.isRelOp) then 
              (if E.isEmpty then
                  lex.sym[] -> sym[];
                  lex;
                  sym[] -> pBinary -> E[];
                  (if false then
                      '**** single:relOp:'->dumpt; sym[]->dumpT; E.doPP->dumpTN
                  if);
                  leave pExp
              if);
              'pExp:=' -> trace;
              lex.sym[] -> sym[];
              lex;
              pSimpleExp -> rE[];
              (E[],sym[],rE[]) -> mkBinary -> E[]
          if);          
       exit E[]
       #);
     pSimpleExp:
       (# E,rE: ^Exp; sym: ^text;
       do 'pSimpleExp'->trace; 
          pTerm -> E[]; 
          L:
            (if (lex.sym[] -> lex.symbols.isAddOp) then 
                'pSimpleExp:addOp' -> trace;
                lex.sym[] -> sym[];
                lex;
                pTerm -> rE[];
                (E[],sym[],rE[]) -> mkBinary -> E[];
                restart L
            if)
       exit E[]
       #);
    pTerm:
       (# E,rE: ^Exp; sym: ^text; isUnaryAddOp: @boolean;
       do 'pTerm'->trace;                  
          (if (lex.sym[],lex.symb) -> lex.symbols.isUnaryAddOp then
              'unaryAddOp'->trace;
              lex.sym[] -> sym[];
              lex;
              true -> isUnaryAddOp
          if);
          pFactor -> E[];
          L:
            (if true
             // isUnaryAddOp then
                'return !'->trace;
                (sym[]->Name,E[]) -> UnaryExp -> E[]                
             // (lex.sym[] -> lex.symbols.isMultOp) 
             // lex.sym[] -> lex.symbols.isTrueSpecial then 
                'pTerm:*' -> trace;
                lex.sym[] -> sym[];
                lex;
                pFactor -> rE[];
                (E[],sym[],rE[]) -> mkBinary -> E[];
                restart L
            if)
       exit E[]
       #);          
     pFactor:
       (# E,rE: ^Exp; sym: ^text; isNotOp: @boolean
       do 'pFactor'->trace;          
          (if (lex.sym[],lex.symb) -> lex.symbols.isNotOP then
              'got !'->trace;
              lex;
              true -> isNotOp
          if);                    
          pPrimary -> E[];
          L:
            (if true
             // isNotOp then
                'return !'->trace;
                ('!'->Name,E[]) -> UnaryExp -> E[]
             // lex.sym[] -> lex.symbols.isTrueSpecial then 
                'pFactor:special:' -> trace;
                lex.sym[] -> sym[];
                lex;
                pPrimary -> rE[];
                (E[],sym[],rE[]) -> mkBinary -> E[];
                restart L
            if)
       exit E[]
       #);
     pPrimary:
       (# E: ^Exp; IV: ^Invocation; symbol: ^Text
       do 'pPrimary'->trace;
          Invocation -> IV[];
          L:
            (if true then
                (if lex.symb 
                 // lex.symbols.const then
                    lex.sym[] -> symbol[];
                    lex;
                    (if lex.symb // lex.symbols.string // lex.symbols.idf then
                        symbol[] -> FloatConst -> E[] -> IV.append
                     else
                        symbol[] -> Const -> E[] -> IV.append;
                    if);
                 // lex.symbols.floatConst then
                    lex.sym[] -> FloatConst -> E[] -> IV.append;
                    lex;              
                 // lex.symbols.string then
                    lex.sym[] -> handleString -> E[] -> IV.append;
                    lex;
                 // lex.symbols.charSy then 
                    lex.sym[] -> CharObj -> E[] -> IV.append;
                    lex;
                 // lex.symbols.idf then
                    'pTerm:idf:'->trace;
                    pOI -> E[] -> IV.append;
                 // lex.symbols.leftBrack then
                    lex;
                    pBracketedExp -> E[] -> IV.append
                 else
                    'pTerm:empty'->trace;
                    Exp -> E[] -> IV.append;; 
                    true -> E.isEmpty -> IV.isEmpty
                if);
                (if lex.symb // lex.symbols.string // lex.symbols.idf then
                    'pFactor:unit '-> trace;
                    (if 'Const'->(E.label).equal then                        
                        '**** unit: '->puttext; E.label->puttext; ':' ->puttext;
                        lex.sym[] -> putline;
                    if);
                    lex.sym[] -> StringObj -> E.unit[];
                    lex
                 else
                    '' -> StringObj -> E.unit[]
                if);
                
                (if (lex.symb = lex.symbols.dot) then
                    (* OBS! Check that restart actually has a match 
                     * and not being empty
                     *)
                    lex; 
                    'pTerm:dot'->trace;
                    restart L
            if)if)
       exit IV[]
       #);
    pOI:
      (# E: ^Exp; prevSymb: @char; sym: ^text; lINV,rINV: ^Invocation;
         OG: ^ObjectDescriptor;   IS: ^Items; 
       do 'pOI' -> trace;        
          lex.sym[] -> sym[];
          (if ('if' -> sym.equalNCS) then
              (*'Got if'->putline;*)
              lex;
              pIfExp -> E[];
              leave pOI
          if);
          (if '#' = (1 -> sym.inxGet) then
              (*'Got # '->puttext; sym[] -> putline;*)
              ((false,false,Signature) -> pVarRefTypeNoBrack2,Arguments)
                -> UnaryGen ->  E[];
              (*newline; lex.symb -> lex.symbols.asText -> putline;*)
              leave pOI
          if);
          (if false and invAsDerivedP then 
              lex.symbols.semicolon -> lex.symb
           else
              lex;
          if);
          (if lex.symb
           // lex.symbols.leftBrack 
           // lex.symbols.leftSquare
           // lex.symbols.begin then
              'pOI:(' -> trace;        
              lex.symb -> prevSymb;
              lex;
              (sym[],prevSymb) -> pNewFatComma -> E[]
           else (*unary *)
             'pOI:unary' -> trace;  
              (sym[],arguments) -> UnaryGen -> E[]
          if)
       exit E[]
       #); 
     pNewFatComma:
       (# sy,sig,comma: ^text; E,F: ^exp;
          args: ^Arguments;
          IS: ^Items;
          IV: ^Invocation;
          leftB,rightB: @char;
          isFatComma: @boolean;
          asCh:
            (# sy: @integer; T: ^Text
            enter sy
            do (if sy
                // lex.symbols.leftBrack then '(' -> T[]
                // lex.symbols.rightBrack then ')' -> T[]
                // lex.symbols.begin then '{' -> T[]
                // lex.symbols.end then '}' -> T[]
                // lex.symbols.leftSquare then '[' -> T[]
                // lex.symbols.rightSquare then ']' -> T[]
                else
                   '?' -> T[]
               if)
            exit T[]
            #);
          N: ^Node; gotComma: @boolean
       enter(sy[],leftB)
       do (if false then
              'pNFCX: ' -> puttext; sy[] -> puttext; ' ' -> put;
              leftB -> asCh -> puttext;
          if);
          leftB + 1 -> rightB;
          (if leftB = lex.symbols.leftSquare then true -> isFatComma if);
          
          Arguments -> args[];  true -> args.isKeyword;
          sy.copy -> sig[]; 
          sig.copy -> comma[] -> name -> args.append;
          leftB -> asCh -> comma[];

          loop:
            (if true then
                (if lex.symb <> rightB then
                    comma[] -> Name -> args.append;
                    (if leftB = lex.symbols.begin then
                        pItems -> IS[];
                        Invocation -> IV[];
                        Exp -> E[] -> IV.append;
                        true -> IV.isEmpty -> E.isEmpty;
                        (IV[],IS[]) -> ObjectDescriptor -> args.append
                     else
                        pObjectSpec -> N[] -> args.append;
                    if)
                 else
                    (if pNewFatCommaFile then
                        'Hovsa: "'->puttext;
                        sig[] -> puttext; '"  "' -> puttext; 
                        lex.symb -> lex.symbols.asText ->  puttext;
                        '"'->putline;
                        121 -> syntaxError
                    if);
                if);
                (if lex.symb 
                 // lex.symbols.comma // lex.symbols.semiColon then
                    true -> gotComma;
                    (args[],rightB) -> pArguments
                    (#
                    do pObjectSpec -> args.append;
                    #) -> args[];
                    (sig[],args[]) -> functionGen -> F[]
                 // rightB then
                    (if not gotComma then
                        rightB -> asCh -> Name -> args.append;
                    if);
                    '' -> comma[];
                    lex;
                    (if lex.symb = lex.symbols.fatcomma then
                        true -> isFatComma;
                        lex.sym.copy -> sig.puttext;
                        lex.sym.copy -> comma.puttext;
                        lex;
                        (if lex.symb 
                         // lex.symbols.leftBrack
                         // lex.symbols.leftSquare
                         // lex.symbols.begin then
                            lex.symb -> leftB;
                            leftB + 1 -> rightB;
                            comma[] -> name -> args.append;
                            leftB -> asCh -> comma[];
                            lex;
                            restart loop
                    if)if)
                 // lex.symbols.eos then
                    (*'***  eof: ' -> puttext; *)
                    leftB -> asCH;
                    (*asCH -> puttext; newline;*)
                    (if '}' -> (rightB -> asCH).equal then
                        rightB -> asCh -> Name -> args.append
                     else
                        '***** end-of-file met before closing'
                        'bracket of: "' -> puttext;
                        leftB -> asCH -> puttext;
                        '"\n'->putline
                    if)
                 else
                    117 -> syntaxError
                if)    
            if);
          (if leftB = lex.symbols.begin then
              true -> args.inBraces;              
          if);
          (if false then
              '**** newFatComma:X:sig: "' -> puttext; sig[] -> puttext;
              '" sy: "' -> puttext; sy[] -> puttext;
              '" leftB: "' -> puttext; leftB -> asCH -> puttext;
              '" ' -> puttext; lex.symb -> lex.symbols.asText -> putline;
              args.scanSons
              (#
              do '**   arg: ' -> puttext; current.label -> puttext;
                 ' ' -> put; current.dopt -> putline
              #)
          if);
          (if isFatComma then
              (sig[],args[]) -> KeyWordgen -> F[];
           else
              (if gotComma then
                  (*(sy[],args[]) -> FunctionGen -> F[]*)
               else
                  (sy[],args[]) -> KeyWordgen -> F[]
          if)if)
       exit F[]
       #);
     pFunction:
       (# sym: ^text;
          F: ^Exp;
          args: ^Arguments;
          OG: ^ObjectSpecification
       enter sym[]
       do Arguments -> args[];  true -> args.isFunction;         
          loop:
            (if true then
                (if true then
                    pObjectSpec -> OG[]
                 else
                    pObjectDescriptor -> OG[];(* -> F.append;*)
                if);
                OG[] -> Args.append;
                (*lex.symb -> lex.symbols.print;*)
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex;
                   (* (if lex.skipcomment.comment.length > 0  then 
                        '*** got comment:A:' -> putline;
                        lex.skipcomment.comment[] -> putline
                    if)*)
                 else
                    6 -> SyntaxError
                if)
            if);
          (sym[],args[]) -> FunctionGen -> F[];
          (* (if args.comment[] <> none then
              '*** got comment:B:' -> putline;
              args.doPT -> putline;
              args.comment[] -> F.commentAfter[]
          if)*)
       exit F[]
       #);
     pBinary:
       (# op: ^text; IV: ^ObjectSpecification; B: ^Exp; args: ^Arguments
       enter op[]
       do Arguments -> args[];
          true -> args.isBinary;
          (if true then
              pObjectSpec-> IV[] -> args.append;
           else
              pObjectDescriptor -> IV[] -> args.append;
          if);
          (op[],args[]) -> BinaryGen -> B[];
       exit B[]
       #);
     pKeyword:
       (# sym,id: ^Text; (* sym = keyword = %put *)
          K: ^Exp;
          args: ^Arguments; OG: ^Statement(*objectSpecification;*)
       enter(sym[])
       do sym[] -> id[]; 
          Arguments -> args[];
          true -> args.isKeyWord;
          (if (1 -> sym.inxGet) = '@' then
              (if ('@if' -> sym.equalNCS) then
                  (*'@parseKw:'->puttext; id[] -> putline;*)
                  (*' ' -> put; lex.sym[]  -> puttext;
                  ' ' -> put; lex.symb -> lex.symbols.asText->putline;*)
                  pIfExp -> K[];
                  leave pKeyWord
              if);
              ':' -> sym.put;
              sym.copy -> Name -> args.append;
              loop:
                (#
                do (if true then
                       pObjectSpec -> OG[] -> args.append;
                    else
                       pObjectDescriptor -> OG[] -> args.append; 
                   if);
                   (if lex.symb = lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                if)#);
           else 'Bt!'->putline; (* We never come here! *)
              sym.copy -> Name -> args.append;
              Loop:
                (#
                do pObjectDescriptor -> OG[] -> args.append; 
                   (if lex.symb = lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                   if);
                #);
          if);
          (id[],args[]) -> KeyWordGen -> K[];
       exit K[]
       #);
     pIfExp:
       (# ifE: ^Exp; cond,thenPart,elsePart: ^Statement(*ObjectSpecification*)
       do pObjectSpec -> cond[];
          (if (lex.symb <> lex.symbols.fatComma)
              and not (':then' -> lex.sym.equalNCS) then
              130 -> syntaxError
          if);
          lex;
          pObjectSpec -> thenPart[];
          (*thenPart.dopt -> putline;*)
          (*lex.symb -> lex.symbols.asText -> puttext;
          ' ' -> put; lex.sym[] -> putline;*)
          (if (lex.symb = lex.symbols.fatComma)
              and (':else' -> lex.sym.equalNCS) then
              (*'   elsePart:\n' -> puttext;*)
              lex;
              pObjectSpec -> elsePart[];
              (cond[],thenPart[],elsePart[]) -> IfThenElse -> IfE[]
           else
              (cond[],thenPart[]) -> IfThen -> IfE[]
          if)
       exit ifE[]
       #);
     pBracketedExp:
       (# E: ^exp; I: ^Invocation
       do (* pExp *) pInvocation  -> I[];
          'pBracketedExp' -> trace;
          I[] -> BracketedExp -> E[];
          L:
            (if lex.symb 
             // lex.symbols.comma then
                lex;
                pInvocation -> E.append;
                restart L
             // lex.symbols.rightBrack then
                lex
             else
                111 -> SyntaxError
            if);
       exit E[]
       #);
     pSlot:
        (# S: ^Slot; id: ^text
        do (if lex.symb = lex.symbols.idf then
               lex.sym[] -> id[];
               lex;
               (if lex.symb <> lex.symbols.slotEnd then
                   113->syntaxError
               if);
               lex;
               id[] -> Slot -> S[];
               Items -> S.slotItems[]; (* ensure slotItems <> none *)
            else               
               112 -> syntaxError
           if)
        exit S[]
        #);
            
     parseSubText:
       (# xsyntaxerror:< 
            (# errorStream: ^stream
            do '!!!! syntax error'->putline;
               lex.errorStream[] -> errorStream[] -> putline;
               inner
            exit errorStream[]
            #);
          inn: ^text; (* the qbeta text to be parsed *)
          oldLex: ^Lexer;
          oldHasSyntaxError: @boolean;
          errs: ^Stream; ind: @integer
       enter inn[]
       do lex[] -> oldLex[]; 
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          hasSyntaxError -> oldHasSyntaxError;
          false -> hasSyntaxError;
          0 -> inn.setPos;
          lex;
          inner;
          (if hasSyntaxError then
              xsyntaxError -> errs[] (* check if this is ever used, 
                                      * including exit errors[] below
                                      *)
          if);
          oldHasSyntaxError or hasSyntaxError -> hasSyntaxError;          
          lex.hasLexError or oldLex.hasLexError -> oldLex.hasLexError;
          oldlex[] -> lex[]; 
       exit errs[]
       #);
     browserItem::
       (#
       do '\n**** browserItem: ' -> puttext; T[] -> putline;
          T[] -> parseSubText
          (#
          do '!!!! browserItem:not implemented'->putline
          #) 
       #);
     parseInv: parseSubText
       (# xsyntaxerror:: (# do 'syntax error' -> putline #);
          E: ^Invocation
       do pInvocation -> E[];
       exit E[]
       #);
     mkItems: parseSubText
       (# IS: ^Items
       do pItems -> IS[]
       exit IS[]
       #);
     parseObjectDescriptorText: parseSubText
       (# OG: ^ObjectDescriptor
       do pObjectDescriptor -> OG[]
       exit OG[]
       #);
     parseItemsText::
       (# ind: @integer
       do (if false then
              '**** parseItemsText: ' -> putline; inn[] -> putline;
          if);
          L:
            (#
            do inn[] -> mkItems
               (# xsyntaxerror::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               #) -> (errors[],IS[]);
               (if false then
                   '**** after parse: ' -> putline; IS.doPT -> putline;
               if)
            #)
       #);
     parseDeclTextX:: 
       (# 
       do '***parseDeclTextX: ' -> putline; inn[] -> putline;
          L:
            (# DIx: ^Decl
            do inn[] -> parseSubText
               (# xSyntaxError::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               do pDecl -> DIx[]
               exit DIx[]
               #) -> (errors[],DI[])
            #)
       #);
     parseDeclText: parseSubText
       (# DI: ^Decl
       do pDecl -> DI[];
       exit DI[]
       #);
     parseStdBetaPtn: parseSubText
       (# sig: ^Signature; OD: ^ObjectDescriptor; DI: ^Decl
       do pSignature -> sig[];
          (if lex.symb = lex.symbols.colon then
              lex;
              true -> pObjectDescriptor -> OD[];
          if)
       exit(sig[],OD[])
       #);
     mkModuleItem::<
       (# DI: ^DataItem; M: ^Module; errs: ^stream; MI: ^ModuleItem;
       do 'mkModuleItem: ' -> putline; 
          name.copy -> itemT[];
          name.copy -> att[];
          (if kind
           // '/' then (* object module *)
              ': obj\n   dummy: var integer' -> itemT.append;
              ': /' -> att.puttext
           else (* pattern module - but not suppprted in qbeta *)
              ':\n   d: var integer' -> itemT;
              ':' -> att.put
          if);
          itemT[] -> putline;
          itemT[] -> parseDeclText -> (errs[],DI[]);
          DI.dopt -> putline;
          '\n!!!!! mkModuleItem: must be fixed! ' -> putline;
          (true,DI.sig[],DI.OG[]) -> Module -> M[];
          (true,name[],M[]) -> ModuleItem -> MI[] -> dcl[];
          (*DI.sig[] -> MI.sig[];*)
          (* pathToModule[] -> MI.dir[];*)
          moduleF[] -> MI.md.inFile[];  
          true -> MI.isParsed; (* needed? *)
          dcl[] -> M.father[];  (* needed? *)
       #); 
     mkDecl::
       (#
       do '\n**** parser:mkDeclY:' -> putline;  
          'kind: ' -> puttext; kind -> put; ' ' -> put; name[] -> putline;
          (if kind
           // ' ' then (* pattern *)
              ':\n   dummy: ? integer' -> name.puttext;
           // '@' then  (* object *)
              ': =\n   dummy: ? integer' -> name.puttext;
          if);
          name[] -> parseDeclText -> (errors[],dcl[]);          
       #);
     parseX_decl::
       (# dclx: ^Decl;
       do (*'*** parseX_decl:'->putline; in[] -> putline;*)
          in[] -> parseSubText
          (# 
          do pDecl -> dclX[]
          #) -> errors[];
          (if errors[] <> none then
              '\n!!!! parse errors: ' -> putline;
              errors[] -> putline
           else
              (*(if dclX[] = none then 'dclX:none'->putline
               else
                  'dclX: ' -> puttext; dclX.doPT -> putline
              if);
              (if dclX.sig[] = none then 'sig is none'->putline
               else
                  'sig: ' -> puttext; dclX.sig.doPT -> putline
              if);              
              (if dclX.sig.id[] =none then
                  'id is none ' -> putline
               else
                  dclX.sig.id[] -> putline
              if);*)
              dclX.sig.id[] -> name[];
              (if true
               // ('obj' -> (dclX.label).equal)
               // ('Module' -> (dclX.label).equal) then
                  kinds.objModule -> kind;
               else 
                  'Item is a "' -> errors[];
                  dclX.label -> errors.puttext;
                  '" - it must be an object of the form "obj: =? ..."' 
                    -> errors.puttext
              if)
              (*': /' -> skind[];*)
          if);
          dclX[] -> dcl[];
       #);
     pDirModuleX::
       (# 
       do (if false then
              '**** pDirModuleX: ' -> puttext; moduleDir[] -> putline;
              '**   path: '-> puttext; pathToDir.append -> putline;
          if);
          (*moduleDir[] -> path.push;*)
          pathToDir[] -> path.push;
          (pathToDir[],moduleDir[],false) -> DirectoryComponents
          (# 
          do (if true then
                 '**   pDirModuleX:DirElm/current:\n' -> puttext; 
                 current[] -> putline;
             if);             
             (current[],isAltExtension) -> pModule -> md[];
             (if false then
                 '**   Module: ' -> puttext;  md.sig.doPT -> putline;
             if)
          #);
          path.pop          
       #);
     scanTokens:
       (# inn: ^text; oldLex: ^Lexer
       enter inn[]
       do lex[] -> oldLex[];
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          false -> hasSyntaxError;
          loop:
            (if true then
                lex;
                inner;
                (if lex.symb <> lex.symbols.eos then restart Loop if)
            if);
          (if hasSyntaxError then
              (* xsyntaxError -> errs[] 
               * check if this is ever used, 
               * including exit errors[] below
               *)
          if);
          oldlex[] -> lex[];
       #);
     handleReservedId::
       (#
       do inn.setpos;
          inn[] -> scanTokens
          (# 
          do (if lex.symb 
              // lex.symbols.varVal
              // lex.symbols.constVal
              // lex.symbols.varRef
              // lex.symbols.constRef
              // lex.symbols.outArg 
              // lex.symbols.inArg 
             (* // lex.symbols.keyword*)
                 then
                 (lex.nextCh.posBeforeName,lex.nextCh.pos - 1)
                   -> theHandler
              // lex.symbols.fatComma
                 then
                 (if (1->lex.sym.inxGet) = ':' then
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 1) 
                       -> theHandler
                  else
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 2) 
                       -> theHandler
       if)if)#)#);
                  
     hasSyntaxError: @boolean;
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          (if lex.fileName[] <> none then
              ' file:\n   ' -> puttext; lex.fileName[] -> putline
          if);
          3 -> lex.printlines;
          newline;

          true -> hasSyntaxError;
          inner;
          
          (if lex.errorStream[] = none then &text[]->lex.errorStream[] if);
          lex.oldPos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;
          lex.nextCh.pos->lex.errorStream.putint; ' '->lex.errorStream.put;
          'Syntax error (' -> lex.errorStream.puttext;
          n -> lex.errorStream.putint;')' -> lex.errorStream.put;
          
          ' expected symbol(s): ' -> lex.errorStream.puttext;   
          n -> syntaxErrMsg -> lex.errorStream.putline;          
          lex.errorStream.newLine;

          skip:
            (#
            do lex; 
               (if lex.symb = lex.symbols.eos then leave skip if);
               (if lex.symb = lex.symbols.semicolon then
                   (*lex*)
               else
                   restart skip
               if)
            #);
          (if true then
              lex.errorStream[] -> putline;              
           else
              (failureTrace,'Syntax error in:\n'->lex.fileName.prepend)  
                -> stop
          if)
       #);
     trace:
       (# S: ^Text
       enter S[]
       do (if traceParse then
              S[] -> puttext; ':'->put;
              lex.symb -> putint; ' ' -> put;
              lex.symb -> lex.symbols.asText -> puttext;
              ' "'->puttext; lex.sym[] -> puttext; '"'->put;
              ' pLevel:'->puttext; lex.parenthLevel -> putint; newline;
              inner trace
          if)
       #);
     traceT: (* always trace parsing *)
       (# S: ^Text
       enter S[]
       do (if true then
              S[] -> puttext; ':'->put;
              lex.symb -> putint; ' ' -> put;
              lex.symb -> lex.symbols.asText -> puttext;
              ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
              inner traceT
          if)
       #);
     genTokenStream: superParser
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.const
                // lex.symbols.floatConst
                // lex.symbols.charSy
                // lex.symbols.string
                // lex.symbols.special 
               (* // lex.symbols.keyword *)
                // lex.symbols.fatComma 
                // lex.symbols.property then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if);
           if)
       #);
     parseBetaWorld:
       (* parse all modules in BetaWorld *)
       (#
       do (* Currenly we assume that BETAworld is using.xbeta syntax!*)
          (topPath[],false) -> pModule -> rootModule[];
          rootModule.handleDirModules (* all of BETAworld is parsed*)
          (# pDirModule::
               (#
               do (if false then
                      '**** pDirModule: ' -> puttext;
                      moduleDirName[] -> putline
                  if);
                  (if not locateWorld.aMiniBetaModule 
                      and ('MiniBeta' -> moduleDirName.equal) then
                   else
                      moduleDirName[] -> path.push;
                      (path.append,moduleDirName[],false) -> DirectoryComponents
                      (# body:: (* A body dir exists *)
                           (#
                           do (if traceSlots then
                                  '**** got body: '-> puttext; FN[]->puttext;
                                  ' path[top]: ' -> puttext;
                                  path.P[path.top][] -> puttext; newline;
                              if);
                              true -> hasBody
                           #);
                         pBody:
                           (#
                           do (if false then
                                  '**** theModule:withBody:'->puttext;
                                  theModule.sig.dopt -> putline;
                              if);
                              'body' -> path.push;
                              (path.append,'body',true) -> DirectoryComponents
                              (# FN: ^text; match: @Boolean
                              do (if false then current[] -> putline; if);
                                 (current[],true) -> superParser
                                 (# IS: ^Items
                                 do pItems -> IS[];
                                    (if traceSlots then
                                        IS.dopt -> putline;
                                        '**** Add:to:slot: '->puttext;
                                        current[] 
                                          -> selectFileNameInPath -> putline;
                                        '**   in:'->putline;
                                        theModule.doPT -> putline
                                    if);
                                    current[] -> selectFileNameInPath -> FN[];
                                    findSlot:
                                      theModule.OG.IS.scanSlots
                                      (#
                                      do (if traceSlots then
                                             '**   slot: ' -> puttext;
                                             currentSlot.id[] -> puttext;
                                             ' ' -> put;
                                             FN[] -> puttext; ' ' -> put;
                                             currentSlot.dopt -> putline;
                                         if);
                                         false -> match;
                                         (if currentSlot.id[]->FN.equalNCS then 
                                             (if traceSlots then
                                                 '**   match: '->puttext;
                                                 currentSlot.dopt -> putline;
                                                 '**   bindTo:'->putline;
                                                 IS.dopt->putline
                                             if);
                                             true -> match;
                                             IS[] -> currentSlot.slotItems[];
                                             currentSlot[] -> IS.father[];
                                             (if traceSlots then
                                                 '** theBinding:'->putline;
                                                 currentSlot.dopt -> putline;
                                             if);
                                             leave findSlot
                                      if)#);
                                    (if not match then
                                        '**** no slot found for: ' ->puttext;
                                        FN[]->putline
                                    if)
                              #)#);
                              path.pop
                           #);
                         hasBody: @boolean
                      do (current[],isAltExtension) -> pModule ->theModule[];
                         (if hasBody then pBody; false -> hasBody  if)
                      #);
                      path.pop    
                  if)
               #)
          #)
            -> main[];
       #);
     topPath: ^text;
     onlyLex: @boolean;
     rootModule,
     main: ^Module;
     mainPT,mainPP,printHTMLfile: @boolean;
     altParser: @boolean;
    do true -> newFatComma -> altParser;
     (if onlyLex then
         (FN[],altParser) -> genTokenStream
      else
         (* There is a mess with respect to compile being called from
          * the stand-alone compiler, qbeta or from qenv
          * From qenv the first call of compile differs from subsequent 
          * calls.
          * The first call from qenv parse all modules and builds their 
          * ASTs
          * Subsequent calls use exisiting AST's - i.e. no parsing
          * When en entity is text-edited in qenv, it is parsed and 
          * replaces the old version on the ASTs
          * 
          * Fullpath:false - called from qbeta
          *         : true - called from qenv
          * rootModule:false - called from qbeta or first call from qenv
          *            true  - subsequent calls from qenv
          * withPos: false - call from qbeta and used by lexer 
          *                  to print errormessages on stdout
          * withPos: true  - from qend and used by lexer to return 
          *                  String with
          *                  errors and positions of these in qenv buffer
          * A clean-up here is needed
          *)
         (if false then
             (if fullPath then
                 'fullPath:true ' -> puttext
              else 
                 'fullPath:false ' -> puttext
             if);
             (if withPos then
                 'withPos:true ' -> puttext
              else
                 'withPos:false ' -> puttext
             if);
             (if rootModule[] <> none then
                 'rootModule:not none'->putline
              else
                 'rootModule:none' -> putline
         if)if);
         
         (if rootModule[] = none  then 
             (* Called from qbeta stand-alone compiler or 
              * first compilation from qenv when starting qenv
              *)
             &lexer[] -> lex[]; 
             true -> lex.isXbeta;
             path.init;
             (fullPath,FN[]) -> locateWorld -> topPath[];
             (if parseMain then
                 (FN[],true) -> pModule -> main[]
              else
                 parseBetaWorld;
             if)
          else
             (*'*** Parser called from qenv - thus no parsing'- putline;*)
             theM[] -> main[];
             rootModule.clear;
             main.clear
         if);
         &iModule[] -> iMain[];
         main[] -> iMain.M[];
         (*'**** rootModule: ' -> putline; rootModule.doPT -> putheadN;*)
         (if mainPT then
             '**** main: ' -> putline; main.doPT -> putline
         if);
         (if printHTMLfile then
             (# FNx: ^text; F: @file
             do FN[] -> FNx[];
                '.html' -> ((1,FN.length - 6) -> FN.sub).append -> FN[];
                FN[] -> F.name;
                F.openWrite;
                main.doHTML -> F.putline;
                F.close
             #);
         if);
         (if false then
             (# AST: ^ Node
             do main.copyAST -> AST[];
                '*** The AST copy:' -> putline;
                (*AST.doPP -> putline;*)
                AST.doPT -> putline;
                '---' -> putline;
         #)if);
         (if mainPP then
             main.doPP -> putline
         if);
         (*rootModule.doPP -> putline;*)
         lex.hasLexError or hasSyntaxError -> hasSyntaxError;
         (* hasSyntaxError:false => dont calle execute *)
         (if not hasSyntaxError and not parseMain then
             inner
         if)
     if)
  #)
