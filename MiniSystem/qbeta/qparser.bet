ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qlexer';
INCLUDE 'qModuleHandler';
INCLUDE 'qprimitives';
INCLUDE 'qsyntaxErrorMessages';
BODY 'parseBody'
---lib:attributes---
(************************ Grammar **********************************
 * Module ::= DataItem
 * Item ::= Decl | ObjectSpec | Property
 * Decl ::= DataItem | Pattern 
 * ObjectSpec::= ObjectCall | ObjectGenerator
 * ObjectCall ::= Invocation
 * ObjectGenerator ::= Invocation MainPart
 * MainPart ::= Item *
 * Invocation ::= Exp '.' Exp
 *             |  Exp '%&' exp 
 * Exp ::= Const | FloatConst| Char | String | '(' Exp ')'
 *      |  ObjectInvocation
 * ObjectInvocation ::= Idf
 *                   |  Idf '(' Arguments ')'
 *                   |  KeyWord
 *                   |  Special Argument
 * Arguments ::= ObjectSpec * ,
 *)
parser: ModuleHandler
  (# iRootModule::
       (# root: @ iModule;
       do rootModule[] -> root.M[];
          (*rootModule.name.lexemSy -> root.nm[];*)
          root[] -> rootM[];
       #);     
     superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)  
          altParser: @boolean
       enter(fileName[],altParser)
       do (path.append).copy -> pathToFN[];
          lex[] -> oldLex[];
          &lexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          (if false then
              '**** superParser: ' -> putline; inFile.name -> putline;
              '**   pathToFN: ' -> puttext; pathToFN[] -> putline;
          if);
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          true -> lex.isXbeta;
          lex;
          newFatComma and not altParser -> pNewFatCommaFile;
          (if false and pNewFatCommaFile then
              '**** parse new syntax:\n' -> puttext; fileName[] -> putline
          if);
          INNER;
          inFile.close;
          (if oldLex[] <> none then
              oldLex.hasLexError or lex.hasLexError -> oldlex.hasLexError;
          if);
          oldLex[] -> lex[];
       #);
     pModule: superParser
       (# checkModuleName:
            (# pos,i: @integer; MN: ^text
            do pathToFN.scanAll
               (#
               do i + 1 -> i;
                  (if ch = dirCh then
                      i -> pos
                  if);
               #);
               (pos +1,pathToFN.length) -> pathToFn.sub -> MN[];
               (if false then
                   '**** checkModuleName: ' -> puttext; 
                   pos -> putint; newline;
                   pathToFN[] -> putline;
                   mn[] -> putline;
                   sig.dopt -> putline;
               if);
               (if MN[] -> sig.id.equal then
                else
                   newline;
                   '*** Fatal error: The name of the object module:\n\t"' 
                     -> puttext; 
                   sig.id[] -> puttext;
                   '"\n    ' -> puttext;
                   'must be the same as the name of the directory in:\n\t'
                     ->puttext;
                   pathToFN[] -> puttext;
                   '\n    Directory name is: "' -> puttext;
                   MN[] -> puttext; 
                   '" - These names are case sensitive\n' -> putline;
                   stop
               if)
            #);
          symb: ^text;
          sig: ^Signature;
          M: ^Module; E: ^Exp
       do (if lex.symb = lex.symbols.idf then
              pSignatureNew -> sig[];
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb 
                   // lex.symbols.constRef then 
                      lex;
                      (true,false,sig[],true) -> pSuperDataItem 
                      (#
                      do sig[] -> OG.sig[];
                         (true,sig[],OG[]) -> Module -> DI[]
                      #) -> M[];
                      pathToFN[] -> M.pathToFN[];
                      inFile[] -> M.inFile[];
                      checkModuleName
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if)
       exit M[]
       #);
     pSuperDataItem:
       (# isConst,isValue,isModule: @boolean;
          sig: ^Signature;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem
       enter(isConst,isValue,sig[],isModule)
       do (if isModule then
              true -> pObjectGenerator -> OG[];
           else
              pObjectSpec -> OG[]
          if);
          inner
       exit DI[]
       #);
     pDataItem: pSuperDataItem
       (# 
       do (isConst,isValue,sig[],OG[]) -> DataItem -> DI[];
          (if ((OG.super.doPT).length = 0) and (OG.IS.isEmpty) then
              118 -> SynTaxError
          if)
       #);
     pVarRefType:
       (# isConst,isValue: @boolean;
          rightB: @integer;
          sig: ^Signature;
          typeId: ^Text;
          E: ^Exp;
          IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;
          bracks: ^text;
          special: @boolean; 
          (*avoid adding () to typeId for XV: ref Indexed(range,#char) *)
       enter(isConst,isValue,sig[])
       do next:
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> typeId[];
              lex;
              L:
              (if lex.symb
               // lex.symbols.leftBrack 
               // lex.symbols.leftSquare
               // lex.symbols.begin then
                  lex.symb + 1 -> rightB;
                  (* remember double brackets: (), [], {} *)
                  lex.symb -> lex.symbols.astext -> bracks[]; 
                  rightB -> lex.symbols.asText -> bracks.append; 
                  lex;
                  L:
                    (#
                    do pExp; (* !!!!! *)
                       (if lex.symb = lex.symbols.comma then
                           lex;
                           true -> special;
                           restart L
                    if)#);
                  (if lex.symb = rightB then
                      (if false and not special then
                          bracks[] -> typeId.append -> typeId[];
                      if);
                      lex;
                      (if lex.symb = lex.symbols.fatComma then
                          lex.sym[] -> typeId.append -> typeId[];
                          lex;
                          restart L
                       else
                          (*(if lex.symb = lex.symbols.dot then
                              lex;
                              restart next
                          if)*)
                      if)
                   else
                      120 -> syntaxError
                  if)
               else
                  (*(if lex.symb = lex.symbols.dot then
                      lex;
                      restart next
                  if)*)
              if);
           else
              119 -> syntaxError
          if);
       exit typeId[]
       #);
     pVarRefTypeNoBrack:
       (# isConst,isValue: @boolean;
          rightB: @integer;
          sig: ^Signature;
          typeId: ^Text;
          E: ^Exp; args: ^Arguments;
          (*avoid adding () to typeId for XV: ref Indexed(range,#char) *)
       enter(isConst,isValue,sig[])
       do 'pVarRefTypeNoBrack:' ->trace;
          (if lex.symb = lex.symbols.idf then
              (*':idf:'->puttext;*)
              lex.sym[] -> typeId[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then
                  Arguments -> args[]; true -> args.isFunction;
                  readArgs:
                    (#
                    do lex;
                       pObjectSpec -> args.append;
                       (if lex.symb 
                        // lex.symbols.comma then
                           restart readArgs
                        // lex.symbols.rightBrack then
                           lex
                        else
                           999 -> syntaxError
              if)#)if);
              'pVarRefTypeNoBrack:after:pExp:new:' ->trace
              (#
              do (if args[] <> none then args.dopt -> dumpTN if)
              #);
              L: (* what goes one here? *)
                (if lex.symb 
                 // lex.symbols.fatComma then
                    lex.sym[] -> typeId.append -> typeId[];
                    lex;
                    restart L
              if);
           else
              119 -> syntaxError
          if);
       exit(typeId[],args[])
       #);
     pVarRefTypeNoBrack2:
       (# isConst,isValue: @boolean;
          rightB: @integer;
          sig: ^Signature;
          typeId: ^Text;
          E: ^Exp;
          IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;
          bracks: ^text;
          special: @boolean; 
          (*avoid adding () to typeId for XV: ref Indexed(range,#char) *)
       enter(isConst,isValue,sig[])
       do 'pVarRefTypeNoBrack2:'->trace;
          (if lex.symb = lex.symbols.idf then
              (*':idf:'->puttext;*)
              lex.sym[] -> typeId[];
              lex;
              L:
                (if lex.symb 
                 // lex.symbols.fatComma then
                    lex.sym[] -> typeId.append -> typeId[];
                    lex;
                    restart L
              if);
           else
              119 -> syntaxError
          if);
       exit typeId[]
       #);
     pVarRefDI:
       (# E: ^Exp; IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;
          args: ^Arguments;
          isConst,isValue: @boolean; sig: ^Signature; typeId: ^Text
       enter(isConst,isValue,sig[])
       do Invocation -> IV[];
          next:
            (if true then
                (isConst,isValue,sig[]) 
                  -> pVarRefTypeNoBrack -> (typeId[],args[]);
                (if args[] = none then
                    (typeId[],Arguments) -> unaryGen -> E[] -> IV.append;
                 else
                    (typeId[],args[]) -> functionGen -> E[] -> IV.append;
                if);
                (if lex.symb = lex.symbols.dot then
                    lex;
                    restart next
            if)if);
          Items -> IS[]; true -> IS.isEmpty -> IV.isEmpty;
          (IV[],IS[]) -> ObjectGenerator -> OG[];
          (isConst,isValue,sig[],OG[]) -> DataItem -> DI[];
          (if false then 
              newline;
              '**** DI:with:VarRefType: ' -> putline;
              DI.dopt -> putline;
              newline
          if)
       exit DI[]
       #);
     pLabelDecl:
       (# OG: ^ObjectSpecification;
          D: ^LabelDecl;
          sig: ^Signature;
       enter sig[]            
       do pObjectGenerator -> OG[];
          (sig[],OG[]) -> LabelDecl -> D[]
       exit D[]
       #);
     pStatement: 
       (# S: ^Statement (* ObjectSpecification *)
       <<SLOT pStatement:doPart>>
       exit S[]
       #);
     pObjectSpec:
       (# IV: ^Invocation; E: ^Exp; OI: ^ObjectInvocation;
          IS: ^Items;          
          OS: ^ObjectSpecification; S: ^Statement
       do (if true then
              pStatement -> S[]
           else
              pInvocation -> IV[];
              pMainPart -> IS[]; 
              (if pNewFatCommaFile and IS.isEmpty then 
                  IV.last -> E[]; 
                  (if false then
                      E.args.noOfSons -> putint;  ' ' -> put; 
                      E.args.inBraces -> putboolean; 
                      newline;
                  if);
                  (if (E.args[] <> none) 
                      and (E.args.noOfSons = 4) (* OBS! hack! *)
                      and (E.args.inBraces) 
                      and E.isObjectInvocation then
                      (if false then
                          '**** pOG:got:arg:as:mainPart: ' -> puttext;
                          E.args.noOfSons -> putint; newline;
                          IV.dopt -> puthead;
                      if);                      
                      IV.mkOG -> (IV[],IS[]);
                      (if false then
                          '**   IV:' -> puttext; IV.dopt -> putline;
                          '**   IS:' -> putline; IS.dopt -> putHead
              if)if)if);              
              (IV[],IS[]) -> ObjectGenerator -> OS[];
              OS.IS.handleNewProps;
              OS[] -> S[];
              (if false then
                  '*** pObjectSpec: ' -> puttext; OS.dopt -> putline;
                  OS.doPP -> putline
              if);
          if);
       exit S[]
       #);
     pObjectGenerator:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
       (# IV: ^Invocation;
          IS: ^Items;          
          OG: ^ObjectGenerator;
          E: ^Exp;
          OI: ^ObjectInvocation;
          inPtn: @boolean
       enter inPtn
       do pInvocation -> IV[];
          pMainPart -> IS[]; (* if we split OG into singular and pattern
                              * then there must be a main part *)
          (if IV.isEmpty and IS.isEmpty then
              222 -> syntaxError
          if);
          (if false and pNewFatCommaFile then
              '**** pOG:IV:' -> puttext; IV.dopt -> putline;
              '**   IS: ' -> puttext; IS.dopt -> puthead;
          if);
              
          (if inPtn and pNewFatCommaFile and IS.isEmpty then 
              IV.last -> E[]; 
              (if false then
                  '**   E: ' -> putline;
                  E.args.scansons
                  (#do current.dopt -> puthead;
                  #);
                  E.args.noOfSons -> putint;  ' ' -> put; 
                  E.args.inBraces -> putboolean; 
                  newline;
              if);
              (if (E.args[] <> none) 
                  and (E.args.noOfSons = 4)
                  and (E.args.inBraces) 
                  and E.isObjectInvocation then
                  (if false then
                      '**** pOG:got:arg:as:mainPart: ' -> puttext;
                      E.args.noOfSons -> putint; newline;
                      IV.dopt -> puthead;
                  if);
                  IV.mkOG -> (IV[],IS[]);
                  (if false then
                      '**   IV:' -> puttext; IV.dopt -> putline;
                      '**   IS:' -> putline; IS.dopt -> putHead
          if)if)if);
          (IV[],IS[]) -> ObjectGenerator -> OG[];
          OG.IS.handleNewProps;
       exit OG[]
       #);
     pMainPart:
       (# IS: ^Items;
       do 'pMainPart:'->trace;
          (if lex.symb = lex.symbols.begin then 
              'pMainPart:after leftCurly'->trace;
              lex;
              pItems -> IS[];
              'pMainPart:after:items'->trace;
              (if lex.symb // lex.symbols.end // lex.symbols.eos then
                  lex;
               else
                  lex.symb -> lex.symbols.asText ->putline;;
                  2 -> SyntaxError
              if);
           else
              Items -> IS[];
              true -> IS.isEmpty
          if);
       exit IS[]
       #);
     pNewProperty:
       (# propId: ^Name; NP: ^NewProperty; args: ^NewPropertyArguments
       enter Name -> propId[]
       do NewPropertyArguments -> args[];
          parseArgs:
            (if lex.symb 
             // lex.symbols.idf 
             // lex.symbols.const
             // lex.symbols.floatConst
             // lex.symbols.string then
                pInvocation -> args.append;
                (if lex.symb = lex.symbols.comma then
                    lex;
                    restart parseArgs
            if)if);
          (propId[],args[]) -> NewProperty -> NP[]
       exit NP[]
       #);
  
     handleProps:
       (# sig: ^Signature; ptnKind: @integer; OD: ^ObjectGenerator; 
          D: ^Decl; P: ^Pattern
       enter(sig[],ptnKind,OD[])
       do  (*OD.IS.handleProps; *)
          
          (if OD.IS.primNo 
           // restart_prim // leave_prim then
              (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
           // indexedPut_prim 
           // indexedGet_prim
           // stringGet_prim
           // indexed_prim // rIndexed_prim
           // asString_prim then
              (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
           // put_prim // get_prim
           // ifthen_prim // inner_prim // none_prim
           // suspend_prim // resume_prim 
           // disable_prim // enable_prim // attach_prim
           // cmpAndSwap_prim // fork_prim // sleep_prim // thisCore_prim 
           // file_open_prim // file_get_prim 
           // file_eof_prim // file_close_prim 
           // dumpObj_prim then
              (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
           else              
              (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
          if);
          OD.IS.isPrimitive -> P.isPrimitivePtn;
          (if D.primNo
           // object_prim then D[] -> objectDecl[]
           // none_prim then D[] -> noneDecl[]
           // integer_prim then D[] -> integerDecl[]
           // char_prim then D[] -> charDecl[]
           // string_prim then D[] -> stringDecl[]
           // boolean_prim then D[] -> booleanDecl[]
           // error_prim then D[] -> errorDecl[]
           // this_prim then D[] -> thisDecl[]
           // thisCore_prim then D[] -> thisCoreDecl[]
           // Resume_prim then D[] -> resumeDecl[]
           // ifThen_prim then D[] -> ifThenDecl[]
           // indexed_prim then D[] -> IndexedDecl[]
           else
              (if D.isCore = core_prim then D[] -> coreDecl[]
          if)if)
       exit D[]
       #);
     pItems:
       (# I: ^Items
       do Items -> I[]; true -> I.commentBefore;
          Loop:
            (# D: ^Decl
            do (if lex.symb 
                // lex.symbols.inArg // lex.symbols.outArg 
                // lex.symbols.class then
                   pDecl -> D[] -> I.append
                // lex.symbols.idf then
                   (* Here we do lookahead of 1-3 symbols to determine
                    * if the next item is a DECLARATION or an EXPRESSION
                    *)
                   (if 1 -> lex.peekNext 
                    // lex.symbols.comma
                    // lex.symbols.return
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                    // lex.symbols.further
                    // lex.symbols.final then
                       pDecl -> I.append; 
                       (*lex.symb -> lex.symbols.print*)
                       
                    // lex.symbols.leftBrack then 
                       (* DECL foo(v: var integer, ...): ...
                        * Exp: foo(e1,e2,e2)
                        *)
                       (if (3 -> lex.peekNext) 
                        // lex.symbols.colon // lex.symbols.virtual then
                           pDecl -> I.append;
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append;
                           if)
                       if)
                    // lex.symbols.leftSquare then
                       (if pNewFatCommaFile then
                           (if (3 -> lex.peekNext) 
                            // lex.symbols.colon 
                            // lex.symbols.virtual then
                               pDecl -> I.append;
                            else
                               (if false then
                                   pObjectGenerator -> I.append;
                                else
                                   pObjectSpec -> I.append;
                               if)
                           if)
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append;
                           if)
                       if)
                    else 
                       (if false then
                           pObjectGenerator -> I.append;
                        else
                           pObjectSpec -> I.append;
                       if)
                   if);
                // lex.symbols.special then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon
                       (* never happen with new arg syntax? *)
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       (if (1 -> lex.peekNext) 
                        // lex.symbols.colon then
                           (* Needed for new syntax for arguments:
                            *    ++ :
                            *       in V: var integer
                            *)
                           pDecl -> I.append
                        // lex.symbols.virtual then
                           pDecl -> I.append                    
                        // lex.symbols.further
                        // lex.symbols.final then
                           pDecl -> I.append                           
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               (# OGx: ^ObjectGenerator
                               do pObjectSpec -> OGx[] -> I.append;
                               #)
                           if)
                   if)if)
                // lex.symbols.keyword then
                   (* More lookahead *)
                   (if (1 -> lex.sym.inxGet) = '@' then
                       (*'keywords: ' -> putline;*)
                   if);
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon then
                       (if (3 -> lex.peekNext) = lex.symbols.idf then
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append
                           if)
                        else
                           pDecl -> I.append
                       if)
                    // lex.symbols.virtual then
                       pDecl -> I.append   
                    else 
                       (if (1 -> lex.sym.inxGet) = '@' then
                           (if (1 -> lex.peekNext) = lex.symbols.colon 
                               then
                               pDecl -> D[] -> I.append;
                               D.setNewId
                            else
                               (if false then
                                   pObjectGenerator -> I.append;
                                else
                                   pObjectSpec -> I.append
                               if)
                           if)
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append
                           if)
                       if)
                   if);
                // lex.symbols.string then
                   (if false then
                       pObjectGenerator -> I.append;
                    else
                       pObjectSpec -> I.append
                   if)
               
                // lex.symbols.leftBrack then
                   (* (exp) ... *)
                   (if false then
                       pObjectGenerator -> I.append;
                    else
                       pObjectSpec -> I.append
                   if)
                // lex.symbols.property then
                   (# propId: ^text
                   do lex.sym[] -> propId[];
                      lex;
                      propId[] -> pNewProperty -> I.append;
                   #)
                // lex.symbols.const 
                // lex.symbols.floatConst 
                // lex.symbols.charSy then 
                   pObjectGenerator -> I.append; (* perhaps OG *)
                // lex.symbols.dots then
                   lex;
                   Dots -> I.append
                // lex.symbols.slotBegin then
                   lex; 
                   pSlot -> I.append
               if);
               (if lex.symb = lex.symbols.semicolon then
                   lex; 
                   restart Loop
               if)
            #)
       exit I[]
       #);
     pDecl:
       (# D: ^Decl; sig: ^Signature; OD: ^ObjectGenerator; 
          ptnKind: @integer;
          P: ^Pattern; isInArg,isOutArg,mustBePattern: @boolean
       do (if lex.symb 
           // lex.symbols.inArg then
              lex;
              true -> isInArg
           // lex.symbols.outArg then
              lex;
              true -> isOutArg            
           // lex.symbols.class then
              lex; 
              true -> mustBePattern
          if);
          'pDecl:after:inOut' -> trace;
          pSignatureNEW -> sig[];
          'pDecl:after:pSignature: '->trace;
          L:
            (#
            do (if lex.symb
                // lex.symbols.colon then
                   (* plainPtn or data-item *)
                   lex;
                   (if lex.symb 
                    // lex.symbols.constRef then 
                       lex;
                       (true,false,sig[],false) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varRef then
                       lex; 
                       (if pNewFatCommaFile then
                           (if false then
                               '**** varRef:('->puttext; sig.dopt -> puttext;
                               ' ' -> put; 
                               lex.symb -> lex.symbols.asText -> puttext; 
                               ' '->put; lex.sym[] -> puttext;
                           if);
                           (false,false,sig[]) -> pVarRefDI -> D[];
                           (*(# di: ^dataitem
                           do ')' -> putline; D[] -> di[];
                              (if (DI.OG.super.last).isEmpty then 
                                  'kuk' -> putline
                           if)#);*)
                        else
                           (false,false,sig[],false) ->pDataItem -> D[];
                       if);
                       leave L
                    // lex.symbols.constVal then 
                       lex;
                       (true,true,sig[],false) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varVal then
                       lex;
                       (false,true,sig[],false) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.doSy then
                       lex;
                       (sig[]) -> pLabelDecl -> D[];
                       leave L                       
                    else
                       plainPtn -> ptnKind
                   if);
                // lex.symbols.virtual then
                   lex; 
                   virtualPtn -> ptnKind               
                // lex.symbols.further then
                   lex; 
                   furtherPtn-> ptnKind
                // lex.symbols.final then
                   lex; 
                   FinalPtn -> ptnKind
                else
                   3 -> syntaxError;
                   (if errorDecl[] = none then 
                       '**** errorDecl is none' -> putline
                   if);
                   errorDecl[] -> D[];
                   leave L
               if);
               true -> pObjectGenerator -> OD[];
               
               (*OD.IS.handleNewProps;*)
               (if OD.IS.primNo 
                // restart_prim // leave_prim then
                   (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
                // indexedPut_prim 
                // indexedGet_prim
                // stringGet_prim
                // indexed_prim
                // rIndexed_prim
                // asString_prim then
                   (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
                // put_prim // get_prim
                // ifthen_prim // inner_prim // none_prim
                // suspend_prim // resume_prim 
                // disable_prim // enable_prim // attach_prim
                // cmpAndSwap_prim // fork_prim // sleep_prim 
                // thisCore_prim 
                // file_open_prim // file_get_prim 
                // file_eof_prim // file_close_prim 
                // dumpObj_prim then
                   (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
                else
                   (if false then
                       '**** ptn: ' -> putline;
                       sig.dopt -> putline;
                       sig.id[] -> putline;
                       (*sig._a_rgs.dopt -> putline; '---'-> putline;
                        * sig._a_rgs.scanSons(#do current.dopt->putline #);
                        *)
                   if);
                   (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
               if);
               OD.IS.isPrimitive -> P.isPrimitivePtn;
               (if D.primNo
                // object_prim then D[] -> objectDecl[]
                // none_prim then D[] -> noneDecl[]
                // integer_prim then D[] -> integerDecl[]
                // char_prim then D[] -> charDecl[]
                // string_prim then D[] -> stringDecl[]
                // boolean_prim then D[] -> booleanDecl[]
                // float_prim then D[] -> floatDecl[]
                // error_prim then D[] -> errorDecl[]
                // this_prim then D[] -> thisDecl[]
                // thisCore_prim then D[] -> thisCoreDecl[]
                // Resume_prim then D[] -> resumeDecl[]
                // ifThen_prim then D[] -> ifThenDecl[]
                // indexed_prim then D[] -> IndexedDecl[]
                else
                   (if D.isCore = core_prim then D[] -> coreDecl[]
               if)if);
            #);
          isInArg -> D.isInArg;
          isOutArg -> D.isOutArg;
       exit D[]
       #);
     mkProp:
       (# propId:  ^Name; NP: ^NewProperty; args: ^NewPropertyArguments;
          stringArg:  ^StringObj; T:  ^Text
       enter(Name -> propId[],T[])
       do NewPropertyArguments -> args[];
          T[] -> StringObj -> stringArg[] -> args.append;
          (propId[],args[]) -> NewProperty -> NP[]
       exit NP[]
       #);
     pArgNew:
       (# D: ^Decl
       do pDecl -> D[]; 
          true -> D.isArg; (* when is D.isArg used ? *)
          true -> D.isInArg -> D.inSig; (* is NOT inArg in return *)
       exit D[]
       #);
     pSignatureNEW:
       (* foo: ...
        * foo(a: var T, b: ref S): ...
        * foo(x: var integer):at[inx: var integer]:do{V: <Object}: ...
        * ++ V: var integer: ...
        *)
       (# sym,id,fc: ^text; names: ^NameList; sig: ^Signature; 
          args: ^Arguments; 
          prevSymb: @char;
          D: ^Decl; Itm: ^Items; 
       do NameList -> names[]; Items -> Itm[];
          'pSigNew'->trace;
          (if lex.symb
           // lex.symbols.idf then 
              (* got foo *)
              lex.sym[] -> sym[] -> NameDecl -> names.append;
              sym.copy -> id[];
              lex; (* ':' ( [ { *)
              (if lex.symb                   
               // lex.symbols.leftBrack 
               // lex.symbols.leftSquare
               // lex.symbols.begin then
                  'pSigNew:id'->trace;
                  lex.symb -> prevSymb;  
                  ('%$B',lex.sym[]) -> mkProp -> Itm.append;
                  lex; 
                  Arguments -> args[]; true -> args.isKeyword;
                  (sym[],names[],args[],true) -> KeyWordSigGen -> sig[];
                  true -> sig.isNewFatCommaSig;
                  pArgNew -> D[] -> sig.append; 
                  'after:pArg:pDecl'->trace;
                  D.copyAST -> Itm.append;
                  (if lex.symb 
                   // prevSymb + 1 then
                      &text[] -> fc[]; lex.sym[] -> fc.append;
                      lex;
                      'prevSymb+1'->trace;
                      pParam:
                        (#
                        do (if lex.symb 
                            // lex.symbols.fatComma then
                               lex.sym[] -> id.append;
                               lex.sym[] -> fc.append;
                               lex;
                               (* next must be bracket *)
                               (if lex.symb                
                                // lex.symbols.leftBrack 
                                // lex.symbols.leftSquare
                                // lex.symbols.begin then
                                   lex.symb -> prevSymb; 
                                   lex.sym[] -> fc.append;
                                   lex; 
                                else
                                   666 -> SyntaxError
                               if);
                            // lex.symbols.comma then
                               lex;
                            else
                               ('%$E',fc[]) -> mkProp -> Itm.append;
                               leave pParam
                           if);
                           pArgNew -> D[] -> sig.append;
                           ('%$S',fc[]) -> mkProp -> Itm.append;
                           D.copyAST -> Itm.append;
                           (if lex.symb 
                            // (prevSymb + 1) then
                               lex;
                               prevSymb + 1 -> lex.symbols.asText -> fc[];
                               'restartFat'->trace;
                               restart pParam
                            // lex.symbols.comma then
                               'restartCommaInFat'->trace;
                               ('%$S',',') -> mkProp -> Itm.append;
                               restart pParam
                            else
                               888 -> syntaxError
                           if)
                        #);
                      id[] -> sig.id[]
                   // lex.symbols.comma then
                      (* foo(x: var T , y: var S, ...): ...
                       *              ;
                       *)
                      lex; 
                      'commaNew'->trace;
                      ('%$S',',') -> mkProp -> Itm.append;
                      pCommaPar:
                        (#
                        do (* foo(x: var T , y: var S, ...): ...
                            *                ;
                            *)
                           pArgNew -> D[] -> sig.append;
                           D.copyAST -> Itm.append;
                           (* foo(x: var T , y: var S, ...): ...
                            *                        ;    ;
                            *)
                           (if lex.symb 
                            // lex.symbols.comma then
                               lex;
                               'commaRestart'->trace;
                               ('%S',',') -> mkProp -> Itm.append;
                               restart pCommaPar
                            // (prevSymb + 1) then
                               'commaRbrack'->trace;
                               ('%$E', prevSymb + 1 ->lex.symbols.asText)
                                 -> mkProp -> Itm.append;
                               lex
                        if)#)
                  if);
                  D.sig.id[] -> id[]; 
               else
                  'pSigNew:unary'->trace;
                  (sym[],names[],arguments,false) -> UnarySigGen -> sig[]
              if)
           // lex.symbols.special then                
              (* binary *)
              lex.sym[] -> sym[] -> NameDecl -> names.append;
              lex;
              'pSigNew:special'->trace;
              Arguments -> args[]; true -> args.isBinary;
              (if lex.symb 
               // lex.symbols.colon 
               // lex.symbols.virtual 
               // lex.symbols.further 
               // lex.symbols.final then
                  (sym[],names[],args[],false) -> BinarySigGen -> sig[]
               else
                  pArgument -> args.append;
                  args.scanSons
                  (# DI: ^DataItem
                  do current[] -> DI[]; DI.copyAST -> Itm.append;
                     true->DI.isInArg
                  #);
                  (sym[],names[],args[],false) -> BinarySigGen -> sig[]
              if)
           // lex.symbols.keyword then  
              (* old .xbeta syntax 
               * we  come here with .qbeta files that still have
               * @-keywords like @if in BETA.qbeta
               *)
              (if (1 -> lex.sym.inxGet) = '@' then
                  lex.sym[] -> sym[] -> nameDecl -> names.append;
                  lex;
                  Arguments -> args[]; 
                  sym[] -> name -> args.append;
                  true -> args.isNewKeyWord;
                  (if lex.symb = lex.symbols.colon then 
                      (* do we need this test?*)
                  if)
               else '\n!!!pSignature: do we come here?' -> putline;
                  lex.sym[] -> sym[];
                  lex;
                  Arguments -> args[]; 
                  sym[] -> name -> args.append;
                  pArguments(#do D[] -> args.append; D.copyAST -> Itm.append #); 
              if);
              (sym[],names[],args[],true) -> KeyWordSigGen -> sig[];
           else
              '-error-' -> NameDecl -> names.append;
              4 -> syntaxError;
              ('-error-',names[],Arguments,false) -> UnarySigGen -> sig[]
          if);
          (if lex.symb = lex.symbols.return then
              lex;
              pReturn -> sig.return[] -> sig.append
          if);
          (if false then
              (if Itm.NoOfSons > 0 then
                  '\n**** signature items: ' -> puttext; sig.id[] -> putline;
                  Itm.dopt -> putline
          if)if);
          Itm[] -> sig.paramItems[]; (* perhaps an argument to Signature? *)
       exit sig[]
       #);
     pSignatureX:
       (* foo:
        * fool(a: ?integer, ...):
        * %put x: ?integer ... :
        * ++ V: ?integer: 
        *)
       (# sym,id: ^text; names: ^NameList; sig: ^Signature; 
          args: ^Arguments; 
          prevSymb: @char;
          elimArgs: (# exit true #)
       do NameList -> names[];
          L: 
            (if lex.symb              
             // lex.symbols.idf then 
                lex.sym[] -> sym[] -> NameDecl -> names.append;
                lex;
                (if pNewFatCommaFile then
                    (if lex.symb 
                     // lex.symbols.comma then
                        lex; 
                        restart L
                     // lex.symbols.leftBrack 
                     // lex.symbols.leftSquare
                     // lex.symbols.begin then
                        lex.symb -> prevSymb;
                        lex;
                        Arguments -> args[]; true -> args.isKeyword;
                        (if elimArgs then
                            (sym[],names[],args[],true) 
                              -> KeyWordSigGen -> sig[];
                            (* Note sym[]->sig.id[] is overwritten below*)
                        if);
                        (sym[],prevSymb) -> pSigArgs
                        (#
                        do (if elimArgs then
                               (* This implies that Arguments is empty
                                * in the sons of Signature;
                                * we need to clean-up the structure of
                                * Signature!
                                *)
                               D[] -> sig.append
                            else
                               D[] -> args.append;  
                           if);
                        #) 
                          -> id[];
                        names.scan
                        (* a bloody hack to ensure that T = if:then:else
                         * otherwise T = if
                         *)
                        (# i: @integer
                        do (if (i + 1) < 2 then id[] -> current.T[] if)
                        #);
                        (if not elimArgs then
                            (sym[],names[],args[],true) 
                              -> KeyWordSigGen -> sig[];
                        if);
                        id[] -> sig.id[];
                        true -> sig.isNewFatCommaSig;
                     else
                        (sym[],names[],arguments,false)
                          -> UnarySigGen -> sig[]
                    if)
                 else (* UnarySignature *)
                    Arguments -> args[];
                    (sym[],names[],args[],false) -> UnarySigGen -> sig[]
                if)
             // lex.symbols.keyword then
                (* old .xbeta syntax 
                 * we  come here with .qbeta files that still have
                 * @-keywords like @while
                 *)
                (if (1 -> lex.sym.inxGet) = '@' then
                    lex.sym[] -> sym[] -> nameDecl -> names.append;
                    lex;
                    Arguments -> args[]; 
                    sym[] -> name -> args.append;
                    true -> args.isNewKeyWord;
                    (if lex.symb = lex.symbols.colon then 
                        (* do we need this test?*)
                    if)
                 else '\n!!!pSignature: do we come here?' -> putline;
                    lex.sym[] -> sym[];
                    lex;
                    Arguments -> args[]; 
                    sym[] -> name -> args.append;
                    pArguments(#do D[] -> args.append #); 
                if);
                (sym[],names[],args[],true) -> KeyWordSigGen -> sig[];
             // lex.symbols.special then
                (* binary *)
                lex.sym[] -> sym[] -> NameDecl -> names.append;
                lex;
                Arguments -> args[]; true -> args.isBinary;
                (if lex.symb 
                 // lex.symbols.colon 
                 // lex.symbols.virtual 
                 // lex.symbols.further 
                 // lex.symbols.final then
                    (sym[],names[],args[],false) -> BinarySigGen -> sig[]
                 else
                    pArgument -> args.append;
                    args.scanSons
                    (# di: ^DataItem
                    do current[] -> DI[];
                      true->DI.isInArg
                    #);
                    (sym[],names[],args[],false) -> BinarySigGen -> sig[]
                if)
             else 
                '-error-' -> NameDecl -> names.append;
                4 -> syntaxError;
                ('-error-',names[],Arguments,false) -> UnarySigGen -> sig[]
            if);
          (if lex.symb = lex.symbols.return then
              lex;
              pReturn -> sig.return[] -> sig.append
          if);
       exit sig[]
       #);   
     pReturn:
       (# rtn: ^Arguments; D: ^Decl
       do Arguments -> rtn[]; true -> rtn.isReturn;
          (* check if lex.symb = lex.symbols.leftBracket and then 
           * perhaps pSigArgs; however do we have fatComma in return?
           *)
          pSigArg -> D[] -> rtn.append; false -> D.isInArg
       exit rtn[]
       #);
     brackAsText:
       (# sy: @integer; T: ^Text
       enter sy
       do (if sy
           // lex.symbols.leftBrack then '(' -> T[]
           // lex.symbols.rightBrack then ')' -> T[]
           // lex.symbols.begin then '{' -> T[]
           // lex.symbols.end then '}' -> T[]
           // lex.symbols.leftSquare then '[' -> T[]
           // lex.symbols.rightSquare then ']' -> T[]
           else
              '?' -> T[]
          if)
       exit T[]
       #);
     pSigArg:
       (# D: ^Decl; P: ^Pattern
       do pDecl -> D[]; (* Perhaps not all decl's should be allowed *)
          true -> D.isArg; (* when is D.isArg used ? *)
          true -> D.isInArg -> D.inSig; (* is NOT inArg in return *)
          (if D## = pattern## then
              D[] -> P[];
              (if P.ptnKind = plainPtn then
                  SyntaxError
                  (#
                  do 'A non-virtual pattern cannot be an argument' 
                       -> putline 
          #)if)if)
       exit D[]
       #);
     pSigArgs:
       (* comma is each element in the signature including brackets
        * id is the signature stripped from brackest
        *)
       (# sym: ^Text; D: ^Node; id,comma: ^text;
          leftB,rightB: @char
       enter(sym[],leftB)
       do leftB + 1 -> rightB;
          sym.copy -> comma[]; 
          leftB -> brackAsText -> name -> D[];
          sym.copy -> id[];
          (if false then
              '**** pSigArgs:A:sym: "' -> puttext; sym[] -> puttext;
              '" id: "' -> puttext; id[] -> puttext; 
              '"  "' -> puttext; comma[] -> puttext; 
              '" D: ' -> puttext; D.dopt -> putline;
          if);
          inner pSigArgs;
          Loop:
            (#
            do pSigArg -> D[]; 
               inner pSigArgs;
               (if lex.symb 
                // rightB (*lex.symbols.rightBrack*) then
                   lex;
                   (if lex.symb = lex.symbols.fatComma then
                       rightB -> brackAsText -> comma[];
                       lex.sym.copy -> comma.append;
                       lex.sym.copy -> id.append;
                       lex;
                       (if lex.symb 
                        // lex.symbols.leftBrack 
                        // lex.symbols.leftSquare
                        // lex.symbols.begin then
                           lex.symb -> leftB;
                           leftB + 1 -> rightB;
                           leftB -> brackAsText -> comma.puttext -> Name -> D[];
                           (if false then
                               '**** pSigArgs:B:id: "'->puttext; id[]->puttext;
                               '"  "' -> puttext; comma[] -> puttext; newline;
                           if);
                           lex;
                           inner pSigArgs;
                           restart Loop
                        else
                           111 -> syntaxError
                       if)
                    else
                       rightB -> brackAsText -> comma[] -> name -> D[];
                       (if false then comma.copy -> id.append; if);
                       (if false then
                           '**** pSigArgs:C:id: "' -> puttext; id[] -> puttext;
                           '"  "' -> puttext; comma[] -> puttext; newline;
                       if);
                       inner pSigArgs
                   if)
                // lex.symbols.comma then
                   ',' -> comma[] -> name -> D[];
                   (*',' -> id.append;*)
                   (*'**** psigArgs: ' -> puttext; id[]->putline;*)
                   inner pSigArgs;
                   lex;
                   restart Loop
               if)
            #)
       exit id[]
       #);
     pArgumentsNew:
       (# args: ^Arguments; rightB: @integer; lastArg: ^Node
       enter(args[],rightB)
       do args.scanSons(#do current[] -> lastArg[] #);
          Arguments -> args[];
          true -> args.isFunction; false -> args.isKeyword;
          lastArg[] -> args.append;
          getArgs:
            (#
            do lex;
               (if lex.symb <> rightB then
                   inner pArgumentsNew;
                   (if lex.symb
                    // lex.symbols.comma then
                       restart getArgs
                    // rightB then
                       lex
                    else
                       200 -> syntaxError
            if)if)#)
       exit args[]
       #);
     pArgument:
       (# D: ^Decl; P: ^Pattern
       do pDecl -> D[]; (* Perhaps not all decl's should be allowed *)
          true -> D.isArg;
          (if D## = pattern## then
              D[] -> P[];
              (if P.ptnKind = plainPtn then
                  SyntaxError
                  (#
                  do 'A non-virtual pattern cannot be an argument' 
                       -> putline 
          #)if)if)
       exit D[]
       #);
     pArguments:
       (# D: ^Decl
       do Loop:
            (#
            do pArgument -> D[]; 
               inner pArguments;
               (if lex.symb 
                // lex.symbols.fatComma then
                   lex.sym[] -> Name -> D[];
                   lex;
                   inner pArguments;
                   restart Loop
                // lex.symbols.comma then
                   lex;
                   restart Loop
               if)
            #)
       #);
     pInvocation:
       (* foo
        * R.foo
        * R ++ E
        * R.%put E1 %at Inx
        * a:= a + b * 117
        * R.S ++ E . %put E %at I
        *)
       (# IV: ^Invocation;
          E: ^Exp;
          i: @integer
       do 'pInvocation:'->trace;
          Invocation -> IV[];
          Loop:
            (#
            do i + 1 -> i;
               pExp -> E[] -> IV.append; (* elim is E.isEmpty *)
               (if lex.symb 
                // lex.symbols.dot then
                   lex;
                   restart Loop
                // lex.symbols.special then
                   restart Loop
                // lex.symbols.idf then
               if)
            #);          
          (if i = 1 then 
              E.isEmpty -> IV.isEmpty;
              (* if E.isEmpty, we have IV = (invocation (???))
               * where '???' is the label of an empty exp
               * This is an annoying special case that complicates
               * the compiler; we test for this situation 
               * in ObjectGenerator::qGen and other places!
               * it would be more clean to do
               *  none -> IV.son[] where we get IV =  (invocation ())
               *)
          if);
       exit IV[]
       #);
     scanForBrace:
       (# T,inn: ^Text; first,last: @integer
       enter T[]
       do 0 -> first -> last;
          (* need to reconsider this one! Not clear what it does!
           * we should test that { and } are matching
           *)
          T.scanAll
          (# toInn,predIsSlash: @boolean; leftB,pos: @integer
          do pos + 1 -> pos; 
             (if ch 
              // '\\' then true -> predIsSlash
              // '{' then
                 &text[] -> inn[]; (* collect string between { and } *)
                 not predIsSlash -> toInn;
                 false -> predIsSlash;
                 pos -> first;
                 (if (leftB + 1 -> leftB) > 1 then
                     '!!!! Nested curlyLeftCh in String: "' -> puttext;
                     T[] -> puttext; '"\n' -> puttext
                 if);
              // '}' then
                 (if not predIsSlash and ((leftB - 1 -> leftB) < 0) then
                     '!!!! No matching left brace "{" in String: "' -> puttext;
                     T[] -> puttext; '"\n' -> puttext
                  else
                     not predIsSlash -> toInn;
                     pos -> last;
                     (if not predIsSlash then
                         inner scanForBrace (* inn must be an Invocation *)
                 if)if);
                 false -> predIsSlash;
              else
                 false -> predIsSlash;
                 (if toInn then ch -> inn.put if)
             if);
          #)
       #);
     handleString: 
       (# T: ^Text; S: ^StringObj; E: ^Invocation; err: ^text
       enter T[]
       do T[] -> StringObj -> S[];
          T[] -> scanForBrace
          (# 
          do inn[] -> parseInv -> (err[],E[]);
             (if err[] <> none then
                 '*** syntax error' -> putline
              else
                 E[] -> S.append;
             if)
          #);
       exit S[]
       #);
     pExp:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if E0 %then E1 %else E2
        *)
       (# sym,sym2: ^Text;
          E: ^Exp; prevSymb: @char
       do 'pExp:'->trace;
          L:
          (if lex.symb 
           // lex.symbols.const then
              lex.sym[] -> Const -> E[];
              lex;
           // lex.symbols.floatConst then
              lex.sym[] -> FloatConst -> E[];
              lex;              
           // lex.symbols.string then
              lex.sym[] -> handleString -> E[];
              lex;
           // lex.symbols.charSy then 
              lex.sym[] -> CharObj -> E[];
              lex;
           // lex.symbols.idf then 
              'pExp:idf:'->trace;              
              lex.sym[] -> sym[];
              (* lex;*)
              (if pNewFatCommaFile then
                  (if '#' = (1 -> sym.inxGet) then
                      (*'Got # '->puttext; sym[] -> putline;*)
                      ((false,false,Signature) -> pVarRefTypeNoBrack2,Arguments)
                        -> UnaryGen ->  E[];
                      (*newline; lex.symb -> lex.symbols.asText -> putline;*)
                      leave L
                  if);
                  lex;
                  (if lex.symb
                   // lex.symbols.leftBrack 
                   // lex.symbols.leftSquare
                   // lex.symbols.begin then
                      lex.symb -> prevSymb;
                      lex;
                      (if false then
                          'goFAT: ' -> puttext; 
                          sym[] -> puttext;
                          ' ' -> puttext; 
                          prevSymb -> lex.symbols.asText -> puttext;
                          newline;
                      if);
                      (sym[],prevSymb) -> pNewFatComma -> E[]
                   else (*unary *)
                      (sym[],arguments) -> UnaryGen -> E[]
                  if)
               else     
                  lex;
                  (if lex.symb 
                   // lex.symbols.leftBrack then
                      lex;
                      sym[] -> pFunction  -> E[]
                   else 
                      (sym[],arguments) -> UnaryGen -> E[]
                  if)
              if)
           // lex.symbols.special then
              lex.sym[] -> sym[];
              lex;
              sym[] -> pBinary -> E[]
           // lex.symbols.keyword then 
              lex.sym[] -> sym[];
              lex;             
              (*'exp:kw:' -> puttext; lex.current -> putline;*)
              sym[] -> pKeyword -> E[]
           // lex.symbols.leftBrack then
              lex.sym[] -> sym[];
              lex;
              pBracketedExp -> E[]
          (* // lex.symbols.begin then
              pMainPart -> ObjectGeneratorExp -> E[]*)
           else
              Exp -> E[]; 
              true -> E.isEmpty
          if);
          (if lex.symb // lex.symbols.string // lex.symbols.idf then
              (* *** got string: ' -> puttext; E.dopt -> puttext;
               lex .sym[] -> putline;
               *)
              lex.sym[] -> StringObj -> E.unit[];
              lex
           else
              StringObj -> E.unit[]
          if)
       exit E[]
       #);
     pNewFatComma:
       (# sy,sig,comma: ^text; E,F: ^exp;
          args: ^Arguments;
          IS: ^Items;
          IV: ^Invocation;
          leftB,rightB: @char;
          isFatComma: @boolean;
          asCh:
            (# sy: @integer; T: ^Text
            enter sy
            do (if sy
                // lex.symbols.leftBrack then '(' -> T[]
                // lex.symbols.rightBrack then ')' -> T[]
                // lex.symbols.begin then '{' -> T[]
                // lex.symbols.end then '}' -> T[]
                // lex.symbols.leftSquare then '[' -> T[]
                // lex.symbols.rightSquare then ']' -> T[]
                else
                   '?' -> T[]
               if)
            exit T[]
            #);
          N: ^Node; gotComma: @boolean
       enter(sy[],leftB)
       do (if false then
              'pNFCX: ' -> puttext; sy[] -> puttext; ' ' -> put;
              leftB -> asCh -> puttext;
          if);
          leftB + 1 -> rightB;
          (if leftB = lex.symbols.leftSquare then true -> isFatComma if);
          
          Arguments -> args[];  true -> args.isKeyword;
          sy.copy -> sig[]; 
          sig.copy -> comma[] -> name -> args.append;
          leftB -> asCh -> comma[];

          loop:
            (if true then
                (if lex.symb <> rightB then
                    comma[] -> Name -> args.append;
                    (if leftB = lex.symbols.begin then
                        pItems -> IS[];
                        Invocation -> IV[];
                        Exp -> E[] -> IV.append;
                        true -> IV.isEmpty -> E.isEmpty;
                        (IV[],IS[]) -> ObjectGenerator -> args.append
                     else
                        pObjectSpec -> N[] -> args.append;
                    if)
                 else
                    (if pNewFatCommaFile then
                        'Hovsa: "'->puttext;
                        sig[] -> puttext; '"  "' -> puttext; 
                        lex.symb -> lex.symbols.asText ->  puttext;
                        '"'->putline;
                        121 -> syntaxError
                    if);
                if);
                (if lex.symb 
                 // lex.symbols.comma // lex.symbols.semiColon then
                    true -> gotComma;
                    (args[],rightB) -> pArgumentsNew
                    (#
                    do pObjectSpec -> args.append;
                    #) -> args[];
                    (sig[],args[]) -> functionGen -> F[]
                 // rightB then
                    (if not gotComma then
                        rightB -> asCh -> Name -> args.append;
                    if);
                    '' -> comma[];
                    lex;
                    (if lex.symb = lex.symbols.fatcomma then
                        true -> isFatComma;
                        lex.sym.copy -> sig.puttext;
                        lex.sym.copy -> comma.puttext;
                        lex;
                        (if lex.symb 
                         // lex.symbols.leftBrack
                         // lex.symbols.leftSquare
                         // lex.symbols.begin then
                            lex.symb -> leftB;
                            leftB + 1 -> rightB;
                            comma[] -> name -> args.append;
                            leftB -> asCh -> comma[];
                            lex;
                            restart loop
                    if)if)
                 // lex.symbols.eos then
                    (*'***  eof: ' -> puttext; *)
                    leftB -> asCH;
                    (*asCH -> puttext; newline;*)
                    (if '}' -> (rightB -> asCH).equal then
                        rightB -> asCh -> Name -> args.append
                     else
                        '***** end-of-file met before closing'
                        'bracket of: "' -> puttext;
                        leftB -> asCH -> puttext;
                        '"\n'->putline
                    if)
                 else
                    117 -> syntaxError
                if)    
            if);
          (if leftB = lex.symbols.begin then
              true -> args.inBraces;              
          if);
          (if false then
              '**** newFatComma:X:sig: "' -> puttext; sig[] -> puttext;
              '" sy: "' -> puttext; sy[] -> puttext;
              '" leftB: "' -> puttext; leftB -> asCH -> puttext;
              '" ' -> puttext; lex.symb -> lex.symbols.asText -> putline;
              args.scanSons
              (#
              do '**   arg: ' -> puttext; current.label -> puttext;
                 ' ' -> put; current.dopt -> putline
              #)
          if);
          (if isFatComma then
              (sig[],args[]) -> KeyWordgen -> F[];
           else
              (if gotComma then
                  (*(sy[],args[]) -> FunctionGen -> F[]*)
               else
                  (sy[],args[]) -> KeyWordgen -> F[]
          if)if)
       exit F[]
       #);
     pFunction:
       (# sym: ^text;
          F: ^Exp;
          args: ^Arguments;
          OG: ^ObjectSpecification
       enter sym[]
       do Arguments -> args[];  true -> args.isFunction;         
          loop:
            (if true then
                (if true then
                    pObjectSpec -> OG[]
                 else
                    pObjectGenerator -> OG[];(* -> F.append;*)
                if);
                OG[] -> Args.append;
                (*lex.symb -> lex.symbols.print;*)
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex;
                   (* (if lex.skipcomment.comment.length > 0  then 
                        '*** got comment:A:' -> putline;
                        lex.skipcomment.comment[] -> putline
                    if)*)
                 else
                    6 -> SyntaxError
                if)
            if);
          (sym[],args[]) -> FunctionGen -> F[];
          (* (if args.comment[] <> none then
              '*** got comment:B:' -> putline;
              args.doPT -> putline;
              args.comment[] -> F.commentAfter[]
          if)*)
       exit F[]
       #);
     pBinary:
       (# op: ^text; IV: ^ObjectSpecification; B: ^Exp; args: ^Arguments
       enter op[]
       do Arguments -> args[];
          true -> args.isBinary;
          (if true then
              pObjectSpec-> IV[] -> args.append;
           else
              pObjectGenerator -> IV[] -> args.append;
          if);
          (op[],args[]) -> BinaryGen -> B[];
       exit B[]
       #);
     pKeyword:
       (# sym,id: ^Text; (* sym = keyword = %put *)
          K: ^Exp;
          args: ^Arguments; OG: ^Statement(*objectSpecification;*)
       enter(sym[])
       do sym[] -> id[]; 
          Arguments -> args[];
          true -> args.isKeyWord;
          (if (1 -> sym.inxGet) = '@' then
              (if ('@if' -> sym.equalNCS) then
                  (*'@parseKw:'->puttext; id[] -> putline;*)
                  (*' ' -> put; lex.sym[]  -> puttext;
                  ' ' -> put; lex.symb -> lex.symbols.asText->putline;*)
                  pIfExp -> K[];
                  leave pKeyWord
              if);
              ':' -> sym.put;
              sym.copy -> Name -> args.append;
              loop:
                (#
                do (if true then
                       pObjectSpec -> OG[] -> args.append;
                    else
                       pObjectGenerator -> OG[] -> args.append; 
                   if);
                   (if lex.symb = lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                if)#);
           else 'Bt!'->putline; (* We never come here! *)
              sym.copy -> Name -> args.append;
              Loop:
                (#
                do pObjectGenerator -> OG[] -> args.append; 
                   (if lex.symb = lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                   if);
                #);
          if);
          (id[],args[]) -> KeyWordGen -> K[];
       exit K[]
       #);
     pIfExp:
       (# ifE: ^Exp; cond,thenPart,elsePart: ^Statement(*ObjectSpecification*)
       do pObjectSpec -> cond[];
          (if (lex.symb <> lex.symbols.fatComma)
              and not (':then' -> lex.sym.equalNCS) then
              130 -> syntaxError
          if);
          lex;
          pObjectSpec -> thenPart[];
          (*thenPart.dopt -> putline;*)
          (*lex.symb -> lex.symbols.asText -> puttext;
          ' ' -> put; lex.sym[] -> putline;*)
          (if (lex.symb = lex.symbols.fatComma)
              and (':else' -> lex.sym.equalNCS) then
              (*'   elsePart:\n' -> puttext;*)
              lex;
              pObjectSpec -> elsePart[];
              (cond[],thenPart[],elsePart[]) -> IfThenElse -> IfE[]
           else
              (cond[],thenPart[]) -> IfThen -> IfE[]
          if)
       exit ifE[]
       #);
     pBracketedExp:
       (# E: ^exp; I: ^Invocation
       do (* pExp *) pInvocation  -> I[];
          I[] -> BracketedExp -> E[];
          L:
            (if lex.symb 
             // lex.symbols.comma then
                lex;
                pInvocation -> E.append;
                restart L
             // lex.symbols.rightBrack then
                lex
             else
                111 -> SyntaxError
            if);
       exit E[]
       #);
     pSlot:
        (# S: ^Slot; id: ^text
        do (if lex.symb = lex.symbols.idf then
               lex.sym[] -> id[];
               lex;
               (if lex.symb <> lex.symbols.slotEnd then
                   113->syntaxError
               if);
               lex;
               id[] -> Slot -> S[];
               Items -> S.slotItems[]; (* ensure slotItems <> none *)
            else               
               112 -> syntaxError
           if)
        exit S[]
        #);
            
     parseSubText:
       (# xsyntaxerror:< 
            (# errorStream: ^stream
            do '!!!! syntax error'->putline;
               lex.errorStream[] -> errorStream[] -> putline;
               inner
            exit errorStream[]
            #);
          inn: ^text; (* the qbeta text to be parsed *)
          oldLex: ^Lexer;
          oldHasSyntaxError: @boolean;
          errs: ^Stream; ind: @integer
       enter inn[]
       do lex[] -> oldLex[]; 
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          hasSyntaxError -> oldHasSyntaxError;
          false -> hasSyntaxError;
          0 -> inn.setPos;
          lex;
          inner;
          (if hasSyntaxError then
              xsyntaxError -> errs[] (* check if this is ever used, 
                                      * including exit errors[] below
                                      *)
          if);
          oldHasSyntaxError or hasSyntaxError -> hasSyntaxError;          
          lex.hasLexError or oldLex.hasLexError -> oldLex.hasLexError;
          oldlex[] -> lex[]; 
       exit errs[]
       #);
     browserItem::
       (#
       do '\n**** browserItem: ' -> puttext; T[] -> putline;
          T[] -> parseSubText
          (#
          do '!!!! browserItem:not implemented'->putline
          #) 
       #);
     parseInv: parseSubText
       (# xsyntaxerror:: (# do 'syntax error' -> putline #);
          E: ^Invocation
       do pInvocation -> E[];
       exit E[]
       #);
     mkItems: parseSubText
       (# IS: ^Items
       do pItems -> IS[]
       exit IS[]
       #);
     parseObjectGeneratorText: parseSubText
       (# OG: ^ObjectGenerator
       do pObjectGenerator -> OG[]
       exit OG[]
       #);
     parseItemsText::
       (# ind: @integer
       do (if false then
              '**** parseItemsText: ' -> putline; inn[] -> putline;
          if);
          L:
            (#
            do inn[] -> mkItems
               (# xsyntaxerror::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               #) -> (errors[],IS[]);
               (if false then
                   '**** after parse: ' -> putline; IS.doPT -> putline;
               if)
            #)
       #);
     parseDeclTextX:: 
       (# 
       do '***parseDeclTextX: ' -> putline; inn[] -> putline;
          L:
            (# DIx: ^Decl
            do inn[] -> parseSubText
               (# xSyntaxError::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               do pDecl -> DIx[]
               exit DIx[]
               #) -> (errors[],DI[])
            #)
       #);
     parseDeclText: parseSubText
       (# DI: ^Decl
       do pDecl -> DI[];
       exit DI[]
       #);
     mkModuleItem::<
       (# DI: ^DataItem; M: ^Module; errs: ^stream; MI: ^ModuleItem;
       do 'mkModuleItem: ' -> putline; 
          name.copy -> itemT[];
          name.copy -> att[];
          (if kind
           // '/' then (* object module *)
              ': obj\n   dummy: var integer' -> itemT.append;
              ': /' -> att.puttext
           else (* pattern module - but not suppprted in qbeta *)
              ':\n   d: var integer' -> itemT;
              ':' -> att.put
          if);
          itemT[] -> putline;
          itemT[] -> parseDeclText -> (errs[],DI[]);
          DI.dopt -> putline;
          '\n!!!!! mkModuleItem: must be fixed! ' -> putline;
          (true,DI.sig[],DI.OG[]) -> Module -> M[];
          (true,name[],M[]) -> ModuleItem -> MI[] -> dcl[];
          (*DI.sig[] -> MI.sig[];*)
          (* pathToModule[] -> MI.dir[];*)
          moduleF[] -> MI.md.inFile[];  
          true -> MI.isParsed; (* needed? *)
          dcl[] -> M.father[];  (* needed? *)
       #); 
     mkDecl::
       (#
       do '\n**** parser:mkDeclY:' -> putline;  
          'kind: ' -> puttext; kind -> put; ' ' -> put; name[] -> putline;
          (if kind
           // ' ' then (* pattern *)
              ':\n   dummy: ? integer' -> name.puttext;
           // '@' then  (* object *)
              ': =\n   dummy: ? integer' -> name.puttext;
          if);
          name[] -> parseDeclText -> (errors[],dcl[]);          
       #);
     parseX_decl::
       (# dclx: ^Decl;
       do (*'*** parseX_decl:'->putline; in[] -> putline;*)
          in[] -> parseSubText
          (# 
          do pDecl -> dclX[]
          #) -> errors[];
          (if errors[] <> none then
              '\n!!!! parse errors: ' -> putline;
              errors[] -> putline
           else
              (*(if dclX[] = none then 'dclX:none'->putline
               else
                  'dclX: ' -> puttext; dclX.doPT -> putline
              if);
              (if dclX.sig[] = none then 'sig is none'->putline
               else
                  'sig: ' -> puttext; dclX.sig.doPT -> putline
              if);              
              (if dclX.sig.id[] =none then
                  'id is none ' -> putline
               else
                  dclX.sig.id[] -> putline
              if);*)
              dclX.sig.id[] -> name[];
              (if true
               // ('obj' -> (dclX.label).equal)
               // ('Module' -> (dclX.label).equal) then
                  kinds.objModule -> kind;
               else 
                  'Item is a "' -> errors[];
                  dclX.label -> errors.puttext;
                  '" - it must be an object of the form "obj: =? ..."' 
                    -> errors.puttext
              if)
              (*': /' -> skind[];*)
          if);
          dclX[] -> dcl[];
       #);
     pDirModuleX::
       (# 
       do (if false then
              '**** pDirModuleX: ' -> puttext; moduleDir[] -> putline;
              '**   path: '-> puttext; pathToDir.append -> putline;
          if);
          (*moduleDir[] -> path.push;*)
          pathToDir[] -> path.push;
          (pathToDir[],moduleDir[],false) -> DirectoryComponents
          (# 
          do (if true then
                 '**   pDirModuleX:DirElm/current:\n' -> puttext; 
                 current[] -> putline;
             if);             
             (current[],isAltExtension) -> pModule -> md[];
             (if false then
                 '**   Module: ' -> puttext;  md.sig.doPT -> putline;
             if)
          #);
          path.pop          
       #);
     scanTokens:
       (# inn: ^text; oldLex: ^Lexer
       enter inn[]
       do lex[] -> oldLex[];
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          false -> hasSyntaxError;
          loop:
            (if true then
                lex;
                inner;
                (if lex.symb <> lex.symbols.eos then restart Loop if)
            if);
          (if hasSyntaxError then
              (* xsyntaxError -> errs[] (* check if this is ever used, 
                                         * including
                                         * exit errors[] below
                                         *)
          if);
          oldlex[] -> lex[];
       #);
     handleReservedId::
       (#
       do inn.setpos;
          inn[] -> scanTokens
          (# 
          do 
             (if lex.symb 
              // lex.symbols.varVal
              // lex.symbols.constVal
              // lex.symbols.varRef
              // lex.symbols.constRef
              // lex.symbols.outArg 
              // lex.symbols.inArg 
              // lex.symbols.keyword
                 then
                 (lex.nextCh.posBeforeName,lex.nextCh.pos - 1)
                   -> theHandler
              // lex.symbols.fatComma
                 then
                 (if (1->lex.sym.inxGet) = ':' then
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 1) 
                       -> theHandler
                  else
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 2) 
                       -> theHandler
                 if)
             if);
       #)#);
                  
     hasSyntaxError: @boolean;
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          (if lex.fileName[] <> none then
              ' file:\n   ' -> puttext; lex.fileName[] -> putline
          if);
          3 -> lex.printlines;
          newline;

          true -> hasSyntaxError;
          inner;
          
          (if lex.errorStream[] = none then &text[]->lex.errorStream[] if);
          lex.oldPos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;
          lex.nextCh.pos->lex.errorStream.putint; ' '->lex.errorStream.put;
          'Syntax error (' -> lex.errorStream.puttext;
          n -> lex.errorStream.putint;')' -> lex.errorStream.put;
          
          ' expected symbols: ' -> lex.errorStream.puttext;          
          '?' -> lex.errorStream.put; (* temporary *)
          lex.errorStream.newLine;
          n -> syntaxErrMsg -> lex.errorStream.putline;
          skip:
            (#
            do lex; 
               (if lex.symb = lex.symbols.eos then leave skip if);
               (if lex.symb = lex.symbols.semicolon then
                   (*lex*)
               else
                   restart skip
               if)
            #);
          (if true then
              lex.errorStream[] -> putline;              
           else
              (failureTrace,'Syntax error in:\n'->lex.fileName.prepend)  
                -> stop
          if)
       #);
          trace:
            (# S: ^Text
            enter S[]
            do (if false then
                   S[] -> puttext; ':'->put;
                   lex.symb -> putint; ' ' -> put;
                   lex.symb -> lex.symbols.asText -> puttext;
                   ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
                   inner trace
               if)
            #);
          genTokenStream: superParser
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.const
                // lex.symbols.floatConst
                // lex.symbols.charSy
                // lex.symbols.string
                // lex.symbols.special 
                // lex.symbols.keyword 
                // lex.symbols.fatComma 
                // lex.symbols.property then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if);
           if)
       #);
     parseBetaWorld:
       (* parse all modules in BetaWorld *)
       (#
       do (* Currenly we assume that BETAworld is using.xbeta syntax!*)
          (topPath[],false) -> pModule -> rootModule[];
          rootModule.handleDirModules (* all of BETAworld is parsed*)
          (# pDirModule::
               (#
               do (if false then
                      '**** pDirModule: ' -> puttext;
                      moduleDirName[] -> putline
                  if);
                  (if not locateWorld.aMiniBetaModule 
                      and ('MiniBeta' -> moduleDirName.equal) then
                   else
                      moduleDirName[] -> path.push;
                      (path.append,moduleDirName[],false) -> DirectoryComponents
                      (# body:: (* A body dir exists *)
                           (#
                           do (if traceSlots then
                                  '**** got body: '-> puttext; FN[]->puttext;
                                  ' path[top]: ' -> puttext;
                                  path.P[path.top][] -> puttext; newline;
                              if);
                              true -> hasBody
                           #);
                         pBody:
                           (#
                           do (if false then
                                  '**** theModule:withBody:'->puttext;
                                  theModule.sig.dopt -> putline;
                              if);
                              'body' -> path.push;
                              (path.append,'body',true) -> DirectoryComponents
                              (# FN: ^text; match: @Boolean
                              do (if false then current[] -> putline; if);
                                 (current[],true) -> superParser
                                 (# IS: ^Items
                                 do pItems -> IS[];
                                    (if traceSlots then
                                        IS.dopt -> putline;
                                        '**** Add:to:slot: '->puttext;
                                        current[] 
                                          -> selectFileNameInPath -> putline;
                                        '**   in:'->putline;
                                        theModule.doPT -> putline
                                    if);
                                    current[] -> selectFileNameInPath -> FN[];
                                    findSlot:
                                      theModule.OG.IS.scanSlots
                                      (#
                                      do (if traceSlots then
                                             '**   slot: ' -> puttext;
                                             currentSlot.id[] -> puttext;
                                             ' ' -> put;
                                             FN[] -> puttext; ' ' -> put;
                                             currentSlot.dopt -> putline;
                                         if);
                                         false -> match;
                                         (if currentSlot.id[]->FN.equalNCS then 
                                             (if traceSlots then
                                                 '**   match: '->puttext;
                                                 currentSlot.dopt -> putline;
                                                 '**   bindTo:'->putline;
                                                 IS.dopt->putline
                                             if);
                                             true -> match;
                                             IS[] -> currentSlot.slotItems[];
                                             currentSlot[] -> IS.father[];
                                             (if traceSlots then
                                                 '** theBinding:'->putline;
                                                 currentSlot.dopt -> putline;
                                             if);
                                             leave findSlot
                                      if)#);
                                    (if not match then
                                        '**** no slot found for: ' ->puttext;
                                        FN[]->putline
                                    if)
                              #)#);
                              path.pop
                           #);
                         hasBody: @boolean
                      do (current[],isAltExtension) -> pModule ->theModule[];
                         (if hasBody then pBody; false -> hasBody  if)
                      #);
                      path.pop    
                  if)
               #)
          #)
            -> main[];
       #);
     topPath: ^text;
     onlyLex: @boolean;
     rootModule,
     main: ^Module;
     mainPT,mainPP,printHTMLfile: @boolean;
     altParser: @boolean;
    do true -> newFatComma -> altParser;
     (if onlyLex then
         (FN[],altParser) -> genTokenStream
      else
         (* There is a mess with respect to compile being called from
          * the stand-alone compiler, qbeta or from qenv
          * From qenv the first call of compile differs from subsequent 
          * calls.
          * The first call from qenv parse all modules and builds their 
          * ASTs
          * Subsequent calls use exisiting AST's - i.e. no parsing
          * When en entity is text-edited in qenv, it is parsed and 
          * replaces the old version on the ASTs
          * 
          * Fullpath:false - called from qbeta
          *         : true - called from qenv
          * rootModule:false - called from qbeta or first call from qenv
          *            true  - subsequent calls from qenv
          * withPos: false - call from qbeta and used by lexer 
          *                  to print errormessages on stdout
          * withPos: true  - from qend and used by lexer to return 
          *                  String with
          *                  errors and positions of these in qenv buffer
          * A clean-up here is needed
          *)
         (if false then
             (if fullPath then
                 'fullPath:true ' -> puttext
              else 
                 'fullPath:false ' -> puttext
             if);
             (if withPos then
                 'withPos:true ' -> puttext
              else
                 'withPos:false ' -> puttext
             if);
             (if rootModule[] <> none then
                 'rootModule:not none'->putline
              else
                 'rootModule:none' -> putline
         if)if);
         
         (if rootModule[] = none  then 
             (* Called from qbeta stand-alone compiler or 
              * first compilation from qenv when starting qenv
              *)
             &lexer[] -> lex[]; 
             true -> lex.isXbeta;
             path.init;
             (fullPath,FN[]) -> locateWorld -> topPath[];
             parseBetaWorld;
          else
             (*'*** Parser called from qenv - thus no parsing'- putline;*)
             theM[] -> main[];
             rootModule.clear;
             main.clear
         if);
         &iModule[] -> iMain[];
         main[] -> iMain.M[];
         (*'**** rootModule: ' -> putline; rootModule.doPT -> putheadN;*)
         (if mainPT then
             '**** main: ' -> putline; main.doPT -> putline
         if);
         (if printHTMLfile then
             (# FNx: ^text; F: @file
             do FN[] -> FNx[];
                '.html' -> ((1,FN.length - 6) -> FN.sub).append -> FN[];
                FN[] -> F.name;
                F.openWrite;
                main.doHTML -> F.putline;
                F.close
             #);
         if);
         (if false then
             (# AST: ^ Node
             do main.copyAST -> AST[];
                '*** The AST copy:' -> putline;
                (*AST.doPP -> putline;*)
                AST.doPT -> putline;
                '---' -> putline;
         #)if);
         (if mainPP then
             main.doPP -> putline
         if);
         (*rootModule.doPP -> putline;*)
         lex.hasLexError or hasSyntaxError -> hasSyntaxError;
         (* hasSyntaxError:false => dont calle execute *)
         (if not hasSyntaxError then
             inner
         if)
     if)
  #)
