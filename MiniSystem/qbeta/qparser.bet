ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qlexer';
INCLUDE 'qabstractSyntaxTree';
INCLUDE 'qprimitives';
---lib:attributes---
parser: AbstractSyntaxTree
  (# iRootModule::
       (# root: @ iModule;
       do rootModule[] -> root.M[];
          (*rootModule.name.lexemSy -> root.nm[];*)
          root[] -> rootM[];
       #);
     
     superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)
          
       enter fileName[]
       do (path.append).copy -> pathToFN[];
          lex[] -> oldLex[];
          &lexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          inFile[] -> lex.init; 
          lex;
          INNER;
          inFile.close;
          oldLex[] -> lex[];
       #);
     pModule: superParser
       (# symb: ^text;
          sig: ^Signature;
          M: ^Module
       do (if lex.symb = lex.symbols.idf then
              (lex.sym[],false) -> Signature -> sig[];
              lex;
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb = lex.symbols.object then 
                      lex;
                      sig[] -> pStaticObject -> Module -> M[];
                      pathToFN[] -> M.pathToFN[];
                      inFile[] -> M.inFile[];
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if);
       exit M[]
       #);
     pStaticObject:
       (# sig: ^Signature;
          OG: ^ObjectGenerator;
          SO: ^StaticObject
       enter sig[]
       do pObjectGenerator -> OG[];
          sig.doPT -> OG.singularName[];
          (sig[],OG[]) -> StaticObject -> SO[]
       exit SO[]
       #);
     pDynamicObject:
       (# sig: ^Signature;
          PI: ^PatternId;
          dObj: ^DynamicObject
       enter sig[]
       do pPatternId -> PI[];
          (sig[],PI[]) -> DynamicObject -> dObj[]
       exit dObj[]
       #);
     pObjectGenerator:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
       (# IV: ^Invocation;
          IS: ^Items;          
          OG: ^ObjectGenerator;;
       do pInvocation -> IV[];
          pMainPart -> IS[];
          (IV[],IS[]) -> ObjectGenerator -> OG[]
       exit OG[]
       #);
     pMainPart:
       (# IS: ^Items; props: ^Properties
       do (if lex.symb = lex.symbols.begin then 
              lex;

              pItems -> IS[];
             
              (if lex.symb = lex.symbols.end then
                  lex;
               else
                  2 -> SyntaxError
              if)
           else
              Items -> IS[];
              true -> IS.isEmpty
          if)
       exit IS[]
       #);
     pProperties:
       (# Props: ^Properties; E: ^Exp; prop: ^Property
       do Properties -> Props[];
          L:
            (#
            do (if lex.symb 
                // lex.symbols.idf then
                   lex.sym[] -> name -> E[]
                // lex.symbols.const then 
                   lex.sym[] -> Const -> E[]
               if);
               Property -> prop[];
               E[] -> prop.P[] -> prop.append;
               prop[] -> props.append;
               lex;
               Loop:
                 (if lex.symb 
                  // lex.symbols.comma then
                     lex;
                     restart L
                  // lex.symbols.leftSquare then 
                     lex;
                     pProperties -> prop.arg[] -> prop.append;
                     restart Loop
                  // lex.symbols.rightSquare then 
                     lex;
                 if)
            #)
       exit Props[]
       #);
     pItems:
       (# I: ^Items
       do Items -> I[];
          (if lex.symb = lex.symbols.leftSquare then
              lex;
              pProperties -> I.props[]; (* append dont work since not an item
                                         * Should be!*)
              (if lex.symb = lex.symbols.semicolon then
                  lex
              if)
          if);
          Include -> I.incl[] -> I.append;
          (if lex.symb = lex.symbols.include then
              lex;
              Loop:
                (if true then
                    pInvocation -> I.incl.append;
                    (if lex.symb = lex.symbols.comma then
                        lex;
                        restart Loop
                if)if);
          if);
          Loop:
            (#
            do (if lex.symb 
                // lex.symbols.idf then
                   (* Here we do lookahead of 1-3 symbols to determine
                    * if the next item is a DECLARATION or an EXPRESSION
                    *)
                   (if 1 -> lex.peekNext 
                    // lex.symbols.value 
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                    // lex.symbols.further
                    // lex.symbols.final then
                       pDecl -> I.append; 
                       (*lex.symb -> lex.symbols.print*)
                    // lex.symbols.leftBrack then 
                       (* DECL foo(v: @integer, ...): ...
                        * Exp: foo(e1,e2,e2)
                        *)
                       (if (3 -> lex.peekNext) 
                        // lex.symbols.colon // lex.symbols.virtual then
                           pDecl -> I.append;
                        else
                           pObjectGenerator -> I.append;
                       if)
                    else 
                       pObjectGenerator -> I.append;
                   if);
                // lex.symbols.special then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       pObjectGenerator -> I.append
                   if)
                // lex.symbols.keyword then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       pObjectGenerator -> I.append
                   if);
                // lex.symbols.leftBrack then
                   (* (exp) ... *)
                   pObjectGenerator -> I.append
               if);
               (if lex.symb = lex.symbols.semicolon then
                   lex; 
                   restart Loop
               if)
            #)
       exit I[]
       #);
     pDecl:
       (# D: ^Decl; sig: ^Signature
       do 
          (if lex.symb 
           // lex.symbols.idf then
              (lex.sym[],false) -> Signature -> sig[];
              lex;
              (if lex.symb = lex.symbols.value then
                  lex;
                  pValue -> sig.val[] -> sig.append
              if);
              (if lex.symb 
               // lex.symbols.colon then             
                  (* unary method or pattern *)
                  lex;
                  sig[] -> pSpec -> D[]
               // lex.symbols.virtual then
                  lex; 
                  sig[] -> pVirtualPtn -> D[];
               // lex.symbols.further then
                  lex;
                  sig[] -> pFurtherPtn -> D[];  
               // lex.symbols.final then
                  lex;
                  sig[] -> pFinalPtn -> D[];                  
               // lex.symbols.leftBrack then 
                  lex;
                  sig[] -> pFunctionalPtn -> D[]
               else
                  syntaxError
              if)
           // lex.symbols.special then 
              (lex.sym[],false) -> Signature -> sig[];
              lex;
              sig[] -> pBinaryPtn -> D[];
           // lex.symbols.keyword then
              (lex.sym[],true) -> Signature -> sig[];
              lex;
              sig[] -> pKeywordPtn -> D[];
           else
              SyntaxError
          if);
          (if D.primNo            
           // object_prim then D[] -> objectDecl[]
           // none_prim then D[] -> noneDecl[]
           // integer_prim then D[] -> integerDecl[]
           // char_prim then D[] -> charDecl[]
           // string_prim then D[] -> stringDecl[]
           // boolean_prim then D[] -> booleanDecl[]
           // string_prim then D[] -> stringDecl[]
           // error_prim then D[] -> errorDecl[]
           // this_prim then D[] -> thisDecl[]
           // thisCore_prim then D[] -> thisCoreDecl[]
           else
              (if D.isCore 
               // core_prim then D[] -> coreDecl[]                            
          if)if)
       exit D[]
       #);
     pSpec:
       (# sig: ^Signature; D: ^Decl
       enter sig[]
       do (if lex.symb = lex.symbols.leftSquare then
              lex;
              sig[] -> pRepetition -> D[];
              D.doPP -> putline;
           else
              sig[] -> pSimpleSpec -> D[]
          if)
       exit D[]
       #);
     pRepetition:
       (# sig: ^Signature; 
          index,elm: ^Objectgenerator; 
          PI: ^PatternId;
          D: ^Decl
       enter sig[]
       do pObjectGenerator -> index[];
          (if lex.symb = lex.symbols.rightSquare then
              lex;
              (if lex.symb
               // lex.symbols.object then
                  lex;
                  pObjectGenerator -> elm[];
                  (sig[],index[],elm[]) -> StaticObjectRepetition -> D[]
               // lex.symbols.ref then
                  lex;
                  pPatternId -> PI[];
                  (sig[],index[],PI[]) -> DynamicObjectRepetition -> D[]
              if)
           else
              SyntaxError
          if)
       exit D[]
       #);
     pSimpleSpec:
       (* Incomplete
        * x : @integer
        * R: ^Foo
        * P:{ ... }
        * V:< 
        *)        
       (# sig: ^Signature; D: ^Decl
       enter sig[]
       do (if lex.symb 
           // lex.symbols.object then
              lex; 
              sig[] -> pStaticObject -> D[]
           // lex.symbols.ref then
              lex;
              sig[] -> pDynamicObject -> D[]
           else
              sig[] -> pUnaryPtn -> D[]
          if)
       exit D[]
       #);
     pUnaryPtn:
       (# sig: ^Signature; OD: ^ObjectGenerator; D: ^Decl
       enter sig[]
       do pObjectGenerator -> OD[];
          (if OD.IS.ifBasic then
              (sig[],OD[]) -> BasicUnaryPattern -> D[]
           else
              (sig[],OD[]) -> UnaryPattern -> D[]
          if)
       exit D[]
       #);
     pVirtualPtn:
       (# sig: ^Signature; OD: ^ObjectGenerator; D: ^Decl
       enter sig[]
       do pObjectGenerator -> OD[];
          (sig[],OD[]) -> VirtualPattern -> D[]
       exit D[]
       #);     
     pFurtherPtn:
       (# sig: ^Signature; OD: ^ObjectGenerator; D: ^Decl
       enter sig[]
       do pObjectGenerator -> OD[];
          (sig[],OD[]) -> FurtherPattern -> D[]
       exit D[]
       #);
     pFinalPtn:
       (# sig: ^Signature; OD: ^ObjectGenerator; D: ^Decl
       enter sig[]
       do pObjectGenerator -> OD[];
          (sig[],OD[]) -> FinalPattern -> D[]
       exit D[]
       #);            
     pBinaryPtn:
       (# sig: ^Signature; 
          BP: ^Pattern;
          OD: ^ObjectGenerator; 
       enter sig[]
       do Arguments -> sig.args[] -> sig.append;
          true -> sig.args.isBinary;
          pArgument -> sig.args.append;
          (if lex.symb = lex.symbols.value then
              lex;
              pValue -> sig.val[] -> sig.append
          if);
          (if lex.symb = lex.symbols.colon then
              lex;
              pObjectGenerator -> OD[];
              (if OD.IS.ifBasic then
                  (sig[],OD[]) -> BasicBinaryPattern -> BP[]
               else
                  (sig[],OD[]) -> BinaryPattern -> BP[]
              if)
           else
              SyntaxError
          if)
        exit BP[]
        #);
     pFunctionalPtn:
       (# sig: ^Signature;
          OD: ^ObjectGenerator; 
          FD: ^Pattern
       enter sig[]
       do Arguments -> sig.args[] -> sig.append;
          true -> sig.args.isFunction;
          pArguments
          (#
          do D[] -> sig.args.append
          #);
          (if lex.symb = lex.symbols.rightBrack then
              lex;
              (if lex.symb = lex.symbols.value then
                  lex;
                  pValue -> sig.val[] -> sig.append
              if);
              (if lex.symb = lex.symbols.colon then
                  lex;
                  pObjectGenerator -> OD[];
                  (if OD.IS.ifBasic then
                      (sig[],OD[]) -> BasicFunctionalPattern -> FD[]
                   else                  
                      (sig[],OD[]) -> FunctionalPattern -> FD[];
                  if)
               else
                  syntaxError
              if)
           else
              syntaxError
          if)
       exit FD[]
       #); 
     pKeywordPtn:
       (# sig: ^Signature;
          OD: ^ObjectGenerator;
          KP: ^Pattern
       enter sig[]
       do Arguments -> sig.args[] -> sig.append;
          true -> sig.args.isKeyWord;
          sig.id.copy -> Name -> sig.args.append; (* clumsy *)
          pArguments
          (#
          do D[] -> sig.args.append
          #);
          (*'pKW: '->putline; sig.doPT -> putline;*)
          sig.setId;
          (if lex.symb = lex.symbols.value then
              lex;
              pValue -> sig.val[] -> sig.append
          if);
          (if lex.symb = lex.symbols.colon then
              lex;
              pObjectGenerator -> OD[];
              (if OD.IS.ifBasic then
                  (sig[],OD[]) -> BasicKeywordPattern -> KP[];
               else
                  (sig[],OD[]) -> KeywordPattern -> KP[];                  
              if)
           else
              syntaxError
          if)
       exit KP[]
       #);
     pArgument:
       (# D: ^Decl
       do pDecl -> D[]; (* Perhaps not all decl's should be allowed *)
       exit D[]
       #);
     pArguments:
       (# D: ^TopNode
       do Loop:
            (#
            do pArgument -> D[]; 
               inner pArguments;
               (if lex.symb 
                // lex.symbols.keyword
                // lex.symbols.fatComma then
                   lex.sym[] -> Name -> D[];
                   lex;
                   inner pArguments;
                   restart Loop
                // lex.symbols.comma then
                   lex;
                   restart Loop
               if)
            #)
       #);
     pValue:
       (# V: ^Value
       do Value -> V[];
          (if lex.symb = lex.symbols.leftBrack then
              lex; 
              Loop:
                (#
                do pDecl -> V.append;
                   (if lex.symb 
                    // lex.symbols.comma then
                       lex;
                       restart Loop
                    // lex.symbols.rightBrack then
                       lex
                   if)
                #)
           else
              pDecl -> V.append
          if)
       exit V[]
       #);
     pPatternId:
       (# IV: ^Invocation; 
          PI: ^PatternId
       do pInvocation -> IV[];
          IV[] -> PatternId -> PI[]; 
       exit PI[]
       #);
     pInvocation:
       (* foo
        * R.foo
        * R ++ E
        * R.%put E1 %at Inx
        * a:= a + b * 117
        * R.S ++ E . %put E %at I
        *)
       (# IV: ^Invocation;
          E: ^Exp;
          i: @integer
       do Invocation -> IV[]; 
          Loop:
            (#
            do i + 1 -> i;
               pExp -> E[] -> IV.append;
               (if lex.symb 
                // lex.symbols.dot then
                   lex;
                   restart Loop
                // lex.symbols.special then 
                   restart Loop
               if)
            #);
          (if i = 1 then E.isEmpty -> IV.isEmpty if)
       exit IV[]
       #);
     pExp:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if E0 %then E1 %else E2
        *)
       (# sym,sym2: ^Text;
          E: ^Exp; 
       do (*'pI: ' -> puttext; lex.symb -> lex.symbols.print;*)
          (if lex.symb 
           // lex.symbols.const then
              lex.sym[] -> Const -> E[];
              lex;
           // lex.symbols.string then
              lex.sym[] -> StringObj -> E[];
              lex
           // lex.symbols.charSy then 
              lex.sym[] -> CharObj -> E[];
              lex;
           // lex.symbols.idf then 
              lex.sym[] -> sym[];
              lex;
              (if lex.symb = lex.symbols.leftBrack then
                  lex;
                  sym[] -> pFunction  -> E[]
               else (*unary *)
                  (sym[] -> Name,arguments) -> Unary -> E[];
              if)
           // lex.symbols.special then
              lex.sym[] -> sym[];
              lex;
              sym[] -> pBinary -> E[]
           // lex.symbols.keyword then 
              lex.sym[] -> sym[];
              lex;             
              (*lex.sym[] -> puttext;*)
              sym[] -> pKeyword -> E[]
           // lex.symbols.leftBrack then
              lex.sym[] -> sym[];
              lex;
              pBracketedExp -> E[]
          (* // lex.symbols.begin then
              pMainPart -> ObjectGeneratorExp -> E[]*)
           else 
              Exp -> E[]; 
              true -> E.isEmpty
          if);
       exit E[]
       #);
     pFunction:
       (# sym: ^text;
          F: ^Function;
          args: ^Arguments;
          OG: ^ObjectGenerator
       enter sym[]
       do Arguments -> args[];  true -> args.isFunction;         
          loop:
            (if true then
                pObjectGenerator -> OG[];(* -> F.append;*)
                OG[] -> Args.append;
                (*lex.symb -> lex.symbols.print;*)
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex
                 else
                    6 -> SyntaxError
                if)
            if);
           (sym[],args[]) -> Function -> F[];       
       exit F[]
       #);
     pBinary:
       (# op: ^Name; IV: ^ObjectGenerator; B: ^Binary; args: ^Arguments
       enter Name -> op[]
       do Arguments -> args[];
          true -> args.isBinary;
          pObjectGenerator -> IV[] -> args.append;
          (op[],args[]) -> Binary -> B[];
       exit B[]
       #);
     pKeyword:
       (# sym,id: ^Text; (* sym = keyword = %put *)
          K: ^KeyWord;
          args: ^Arguments
       enter(sym[])
       do (*'\npKeyword: ' -> puttext; sym[] -> putline;*)
         
          sym[] -> id[]; 
          Arguments -> args[];
          true -> args.isKeyWord;
          sym.copy -> Name -> args.append; (*K.append;*) 
          (*           (if true
           *            // '%inner' -> id.equalNCS 
           *            // '%leave' -> id.equalNCS
           *            // '%restart' -> id.equalNCS then  
           *               'Bingo: ' -> puttext; args.doP -> putline;
           *               (if lex.symb
           *                // lex.symbols.idf 
           *                // lex.symbols.keyword 
           *                // lex.symbols.fatComma then 
           *                   lex.symb -> putint; ' ' ->put;
           *                   lex.sym[] -> puttext; newline;
           *                   lex.sym[] -> Name -> args.append;
           *                   lex
           *                else
           *                   '???'->putline
           *               if)
           *            else
           *)
              Loop:
                (#
                do pObjectGenerator -> args.append; 
                   (* 'pK:afterARg: ' -> puttext; 
                    * lex.symb->lex.symbols.print;
                    * newline;
                    *)
                   (if lex.symb 
                    // lex.symbols.keyword 
                    // lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                   if);
                #);
       (*if);*)
          (*lex.symb -> lex.symbols.print; newline;*)
          (id[],args[]) -> KeyWord -> K[];
          (*K.doP -> putline*)
          (*id[] -> K.id[];*)
       exit K[]
       #);
     pBracketedExp:
       (# E: ^exp
       do pExp -> E[];
          (if lex.symb = lex.symbols.rightBrack then
              lex
           else
              SyntaxError
          if);
          E[] -> BracketedExp -> E[]
       exit E[]
       #);
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          newline;
          3 -> lex.printlines;
          (failureTrace (*dumpStack*), 'Syntax error')  -> stop
        #);
     genTokenStream: superParser
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.const
                // lex.symbols.charSy
                // lex.symbols.string
                // lex.symbols.special 
                // lex.symbols.keyword 
                // lex.symbols.fatComma then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if)
           if)
       #);
     lex: ^lexer;
     (*FN: ^text;*)
     topPath: ^text;
     onlyLex: @boolean;
     rootModule,
     m,main: ^Module
  do (if onlyLex then
         FN[] -> genTokenStream
      else
         &lexer[] -> lex[]; 
         (if true then
             path.init;
             locateWorld.init;
             (fullPath,FN[]) -> locateWorld -> topPath[];
             (*'topPath: ' -> puttext; topPath[] -> putline;*)
             topPath[] -> pModule -> rootModule[];
             rootModule.handleDirModules
             (# pDirModule::
                  (#
                  do (*'pDirModule: ' -> puttext; moduleDir[] -> putline;*)
                     moduleDir[] -> path.push;
                     (path.append,moduleDir[]) -> DirectoryComponents
                     (# 
                     do (*'DirElm: ' -> puttext; current[] -> putline;*)
                        current[] -> pModule -> md[];
                        (*'Module: ' -> putline;  md.doPT -> putline;*)
                     #);
                     path.pop
                  #)
             #)
               -> main[];
          else
             FN[] ->  pModule -> main[];
         if);
         main.doPT -> putline;
         (*rootModule.doPT -> putline;*)
         (* main.doPT -> putline;*)
         inner
     if);
  #)
