ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qlexer';
INCLUDE 'qabstractSyntaxTree';
INCLUDE 'qprimitives';
INCLUDE 'qsyntaxErrorMessages'
---lib:attributes---
(************************ Grammar **********************************
 * Module ::= DataItem
 * Item ::= Decl | ObjectSpec | Property
 * Decl ::= DataItem | Pattern 
 * ObjectSpec::= ObjectCall | ObjectGenerator
 * ObjectCall ::= Invocation
 * ObjectGenerator ::= Invocation MainPart
 * MainPart ::= Item *
 * Invocation ::= Exp '.' Exp
 *             |  Exp '%&' exp 
 * Exp ::= Const | FloatConst| Char | String | '(' Exp ')'
 *      |  ObjectInvocation
 * ObjectInvocation ::= Idf
 *                   |  Idf '(' Arguments ')'
 *                   |  KeyWord
 *                   |  Special Argument
 * Arguments ::= ObjectSpec * ,
 *)
parser: AbstractSyntaxTree
  (# iRootModule::
       (# root: @ iModule;
       do rootModule[] -> root.M[];
          (*rootModule.name.lexemSy -> root.nm[];*)
          root[] -> rootM[];
       #);     
     superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)  
          altParser: @boolean
       enter(fileName[],altParser)
       do (path.append).copy -> pathToFN[];
          lex[] -> oldLex[];
          &lexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          (if false then
              '**** superParser: ' -> putline; inFile.name -> putline;
              '**   pathToFN: ' -> puttext; pathToFN[] -> putline;
          if);
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          true -> lex.isXbeta;
          lex;
          newFatComma and altParser -> pNewFatCommaFile;
          (if false and pNewFatCommaFile then
              '**** parse new syntax:\n' -> puttext; fileName[] -> putline
          if);
          INNER;
          inFile.close;
          oldLex.hasLexError or lex.hasLexError -> oldlex.hasLexError;
          oldLex[] -> lex[];
       #);
     pModule: superParser
       (# checkModuleName:
            (# pos,i: @integer; MN: ^text
            do pathToFN.scanAll
               (#
               do i + 1 -> i;
                  (if ch = dirCh then
                      i -> pos
                  if);
               #);
               (pos +1,pathToFN.length) -> pathToFn.sub -> MN[];
               (if false then
                   '**** checkModuleName: ' -> puttext; 
                   pos -> putint; newline;
                   pathToFN[] -> putline;
                   mn[] -> putline;
                   sig.dopt -> putline;
               if);
               (if MN[] -> sig.id.equal then
                else
                   newline;
                   '*** Fatal error: The name of the object module:\n\t"' 
                     -> puttext; 
                   sig.id[] -> puttext;
                   '"\n    ' -> puttext;
                   'must be the same as the name of the directory in:\n\t'
                     ->puttext;
                   pathToFN[] -> puttext;
                   '\n    Directory name is: "' -> puttext;
                   MN[] -> puttext; 
                   '" - These names are case sensitive\n' -> putline;
                   stop
               if)
            #);
          symb: ^text;
          sig: ^Signature;
          M: ^Module
       do (if lex.symb = lex.symbols.idf then
              (if true then
                  pSignature -> sig[]
               else
                  (lex.sym[],none,false) -> Signature -> sig[];
                  lex;
              if);
              (if lex.symb = lex.symbols.colon then
                  lex; 
                  (if lex.symb 
                   // lex.symbols.constRef then 
                      lex;
                      (true,false,sig[]) -> pSuperDataItem 
                      (#
                      do sig[] -> OG.sig[];
                         (true,sig[],OG[]) -> Module -> DI[]
                      #) -> M[];
                      pathToFN[] -> M.pathToFN[];
                      inFile[] -> M.inFile[];
                      checkModuleName
                   else
                      1 -> SyntaxError
                  if)
               else
                  1 -> SyntaxError
              if)
           else
              1 -> SyntaxError
          if)
       exit M[]
       #);
     pSuperDataItem:
       (# isConst,isValue: @boolean;
          sig: ^Signature;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem
       enter(isConst,isValue,sig[])
       do (if true then
              pObjectSpec -> OG[]
           else
              pObjectGenerator -> OG[];
          if);
          inner
       exit DI[]
       #);
     pDataItem: pSuperDataItem
       (# 
       do (isConst,isValue,sig[],OG[]) -> DataItem -> DI[];
          (if ((OG.super.doPT).length = 0) and (OG.IS.isEmpty) then
              118 -> SynTaxError
          if)
       #);
     pVarRefType:
       (# isConst,isValue: @boolean;
          rightB: @integer;
          sig: ^Signature;
          typeId: ^Text;
          E: ^Exp;
          IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;

          special: @boolean; 
          (*avoid adding () to typeId for XV: ref Indexed(range,#char) *)
       enter(isConst,isValue,sig[])
       do (*'**** pVarRefType: ' -> puttext;
           lex.symb -> lex.symbols.asText -> putline;*)
          
          next:
          (if lex.symb = lex.symbols.idf then
              (*':idf:'->puttext;*)
              lex.sym[] -> typeId[];
              lex;
              L:
              (if lex.symb
               // lex.symbols.leftBrack 
               // lex.symbols.leftSquare
               // lex.symbols.begin then
                  lex.symb + 1 -> rightB;
                  lex;
                  L:
                    (#
                    do pExp;
                       (if lex.symb = lex.symbols.comma then
                           lex;
                           true -> special;
                           restart L
                    if)#);
                  (if lex.symb = rightB then
                      (if not special then
                          '()' -> typeId.append -> typeId[];
                      if);
                      lex;
                      (if lex.symb = lex.symbols.fatComma then
                          lex.sym[] -> typeId.append -> typeId[];
                          lex;
                          restart L
                       else;
                          (*(if lex.symb = lex.symbols.dot then
                              lex;
                              restart next
                          if)*)
                      if)
                   else
                      120 -> syntaxError
                  if)
               else
                  (*(if lex.symb = lex.symbols.dot then
                      lex;
                      restart next
                  if)*)
              if);
           else
              119 -> syntaxError
          if);
       exit typeId[]
       #);
     pVarRefDI:
       (# E: ^Exp; IV: ^Invocation;
          IS: ^Items;
          OG: ^ObjectSpecification;
          DI: ^SuperDataItem;
          
          isConst,isValue: @boolean; sig: ^Signature; typeId: ^Text
       enter(isConst,isValue,sig[])
       do Invocation -> IV[];
          next:
          (if true then
              (isConst,isValue,sig[]) -> pVarRefType -> typeId[];         
              Items -> IS[]; true -> IS.isEmpty -> IV.isEmpty;
              (typeId[],Arguments) -> unaryGen -> E[] -> IV.append;
              (if lex.symb = lex.symbols.dot then
                  lex;
                  restart next
          if)if);
          (IV[],IS[]) -> ObjectGenerator -> OG[];
          (isConst,isValue,sig[],OG[]) -> DataItem -> DI[];
          (if false then 
              newline;
              '**** DI:with:VarRefType: ' -> putline;
              DI.dopt -> putline;
              newline
          if)
       exit DI[]
       #);
     pLabelDecl:
       (# OG: ^ObjectSpecification;
          D: ^LabelDecl;
          sig: ^Signature;
       enter sig[]            
       do pObjectGenerator -> OG[];
          (sig[],OG[]) -> LabelDecl -> D[]
       exit D[]
       #);
     pObjectSpec:
       (# IV: ^Invocation;
          IS: ^Items;          
          OS: ^ObjectSpecification
       do pInvocation -> IV[];
          pMainPart -> IS[]; 
          (if false and IS.isEmpty then
              (IV[],IS[]) -> ObjectCall -> OS[]
           else
              (IV[],IS[]) -> ObjectGenerator -> OS[]
          if);
          OS.IS.handleNewProps;
          (if false then
              '*** pObjectSpec: ' -> puttext; OS.dopt -> putline;
              OS.doPP -> putline
          if);
       exit OS[]
       #);
     pObjectGenerator:
       (* <ObjectInvocation>
        * <ObjectInvocation> <MainPart>
        *)
       (# IV: ^Invocation;
          IS: ^Items;          
          OG: ^ObjectGenerator;
          E: ^Exp;
          OI: ^ObjectInvocation;
          inPtn: @boolean
       enter inPtn
       do pInvocation -> IV[];
          (if false then
              '**** pInv: ' -> puttext; IV.dopt -> puttext;
              ' ' -> put; lex.symb -> lex.symbols.asText -> putline;
          if);
          pMainPart -> IS[]; (* if we split OG into singular and pattern
                              * then there must be a main part *)
          (if inPtn and pNewFatCommaFile and IS.isEmpty then 
              IV.last -> E[]; 
              (if (E.args[] <> none) 
                  and (E.args.noOfSons = 3)
                  and (E.args.inBraces) 
                  and E.isObjectInvocation then
                  (if false then
                      '**** pOG:got:arg:as:mainPart: ' -> puttext;
                      E.args.noOfSons -> putint; newline;
                      IV.dopt -> puthead;
                  if);
                  (E[]->OI[]).mkOG -> (IV[],IS[])
              if)
          if);
          (IV[],IS[]) -> ObjectGenerator -> OG[];
          OG.IS.handleNewProps;
       exit OG[]
       #);
     pMainPart:
       (# IS: ^Items;
       do (if lex.symb = lex.symbols.begin then 
              lex;
              pItems -> IS[];
              (if lex.symb // lex.symbols.end // lex.symbols.eos then
                  lex;
               else
                  2 -> SyntaxError
              if);
           else
              Items -> IS[];
              true -> IS.isEmpty
          if);
       exit IS[]
       #);
     pNewProperty:
       (# propId: ^Name; NP: ^NewProperty; args: ^NewPropertyArguments
       enter Name -> propId[]
       do NewPropertyArguments -> args[];
          parseArgs:
            (if lex.symb 
             // lex.symbols.idf 
             // lex.symbols.const
             // lex.symbols.floatConst
             // lex.symbols.string then
                pInvocation -> args.append;
                (if lex.symb = lex.symbols.comma then
                    lex;
                    restart parseArgs
            if)if);
          (propId[],args[]) -> NewProperty -> NP[]
       exit NP[]
       #);
  
     handleProps:
       (# sig: ^Signature; ptnKind: @integer; OD: ^ObjectGenerator; 
          D: ^Decl; P: ^Pattern
       enter(sig[],ptnKind,OD[])
       do  (*OD.IS.handleProps; *)
          
          (if OD.IS.primNo 
           // rAssign_prim // vAssign_prim then
              (sig[],OD[],ptnKind) -> AssignmentPtnGen -> P[] -> D[]
           // restart_prim // leave_prim then
              (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
           // indexedPut_prim 
           // indexedGet_prim
           // stringGet_prim
           // indexed_prim
           // asString_prim then
              (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
           // put_prim // get_prim
           // ifthen_prim // inner_prim // none_prim
           // suspend_prim // resume_prim 
           // disable_prim // enable_prim // attach_prim
           // cmpAndSwap_prim // fork_prim // sleep_prim // thisCore_prim 
           // file_open_prim // file_get_prim 
           // file_eof_prim // file_close_prim 
           // dumpObj_prim then
              (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
           else              
              (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
          if);
          OD.IS.isPrimitive -> P.isPrimitivePtn;
          (if D.primNo
           // object_prim then D[] -> objectDecl[]
           // none_prim then D[] -> noneDecl[]
           // integer_prim then D[] -> integerDecl[]
           // char_prim then D[] -> charDecl[]
           // string_prim then D[] -> stringDecl[]
           // boolean_prim then D[] -> booleanDecl[]
           // error_prim then D[] -> errorDecl[]
           // this_prim then D[] -> thisDecl[]
           // thisCore_prim then D[] -> thisCoreDecl[]
           // Resume_prim then D[] -> resumeDecl[]
           // ifThen_prim then D[] -> ifThenDecl[]
           // indexed_prim then D[] -> IndexedDecl[]
           else
              (if D.isCore 
               // core_prim then D[] -> coreDecl[]                            
          if)if)
       exit D[]
       #);
     pItems:
       (# I: ^Items
       do Items -> I[]; true -> I.commentBefore;

          Loop:
            (# D: ^Decl
            do (if lex.symb 
                // lex.symbols.inArg // lex.symbols.outArg then
                   pDecl -> D[] -> I.append
                // lex.symbols.idf then
                   (* Here we do lookahead of 1-3 symbols to determine
                    * if the next item is a DECLARATION or an EXPRESSION
                    *)
                   (if 1 -> lex.peekNext 
                    // lex.symbols.value 
                    // lex.symbols.colon 
                    // lex.symbols.virtual 
                    // lex.symbols.further
                    // lex.symbols.final then
                       pDecl -> I.append; 
                       (*lex.symb -> lex.symbols.print*)
                       
                    // lex.symbols.leftBrack then 
                       (* DECL foo(v: var integer, ...): ...
                        * Exp: foo(e1,e2,e2)
                        *)
                       (if (3 -> lex.peekNext) 
                        // lex.symbols.colon // lex.symbols.virtual then
                           pDecl -> I.append;
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append;
                           if)
                       if)
                    // lex.symbols.leftSquare
                    (*// lex.symbols.begin*) then
                       (if pNewFatCommaFile then
                           (if (3 -> lex.peekNext) 
                            // lex.symbols.colon // lex.symbols.virtual then
                               pDecl -> I.append;
                            else
                               (if false then
                                   pObjectGenerator -> I.append;
                                else
                                   pObjectSpec -> I.append;
                               if)
                           if)
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append;
                           if)
                       if)
                    else 
                       (if false then
                           pObjectGenerator -> I.append;
                        else
                           pObjectSpec -> I.append;
                       if)
                   if);
                // lex.symbols.special then
                   (* More lookahead *)
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon 
                       (* never happen with new arg syntax? *)
                    // lex.symbols.virtual 
                       then
                       pDecl -> I.append
                    else
                       (if (1 -> lex.peekNext) = lex.symbols.colon then
                           (* Needed for new syntax for arguments:
                            *    ++ :
                            *       in V: var integer
                            *)
                           pDecl -> I.append
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append
                           if)
                   if)if)
                // lex.symbols.keyword then
                   (* More lookahead *)
                   (if (1 -> lex.sym.inxGet) = '@' then
                       (*'keywords: ' -> putline;*)
                   if);
                   (if (2 -> lex.peekNext) 
                    // lex.symbols.colon then
                       (if (3 -> lex.peekNext) = lex.symbols.idf then
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append
                           if)
                        else
                           pDecl -> I.append
                       if)
                    // lex.symbols.virtual then
                       pDecl -> I.append
                    else 
                       (if (1 -> lex.sym.inxGet) = '@' then
                           (if (1 -> lex.peekNext) = lex.symbols.colon 
                               then
                               pDecl -> D[] -> I.append;
                               D.setNewId
                            else
                               (if false then
                                   pObjectGenerator -> I.append;
                                else
                                   pObjectSpec -> I.append
                               if)
                           if)
                        else
                           (if false then
                               pObjectGenerator -> I.append;
                            else
                               pObjectSpec -> I.append
                           if)
                       if)
                   if);
                // lex.symbols.string then
                   (if false then
                       pObjectGenerator -> I.append;
                    else
                       pObjectSpec -> I.append
                   if)
               
                // lex.symbols.leftBrack then
                   (* (exp) ... *)
                   (if false then
                       pObjectGenerator -> I.append;
                    else
                       pObjectSpec -> I.append
                   if)
                // lex.symbols.property then
                   (# propId: ^text
                   do lex.sym[] -> propId[];
                      lex;
                      propId[] -> pNewProperty -> I.append;
                   #)
                // lex.symbols.const 
                // lex.symbols.floatConst 
                // lex.symbols.charSy then 
                   pObjectGenerator -> I.append; (* perhaps OG *)
               if);
               (if lex.symb = lex.symbols.semicolon then
                   lex; 
                   restart Loop
               if)
            #)
       exit I[]
       #);
     pDecl:
       (# D: ^Decl; sig: ^Signature; OD: ^ObjectGenerator; 
          ptnKind: @integer;
          P: ^Pattern; isInArg,isOutArg: @boolean
       do (if lex.symb 
           // lex.symbols.inArg then
              lex;
              true -> isInArg
           // lex.symbols.outArg then
              lex;
              true -> isOutArg            
          if);
          pSignature -> sig[];
          L:
            (#
            do (if lex.symb
                // lex.symbols.colon then
                   (* plainPtn or data-item *)
                   lex;
                   (if lex.symb 
                    // lex.symbols.constRef then 
                       lex;
                       (true,false,sig[]) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varRef then
                       lex; 
                       (if pNewFatCommaFile then
                           (*'**** varRef:('->puttext; sig.dopt -> puttext;
                           ' ' -> put;*)
                           (false,false,sig[]) -> pVarRefDI -> D[];
                           (*(# di: ^dataitem
                           do ')' -> putline; D[] -> di[];
                              (if (DI.OG.super.last).isEmpty then 
                                  'kuk' -> putline
                           if)#);*)
                        else
                           (false,false,sig[]) ->pDataItem -> D[];
                       if);
                       leave L
                    // lex.symbols.constVal then 
                       lex;
                       (true,true,sig[]) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.varVal then
                       lex;
                       (false,true,sig[]) -> pDataItem -> D[];
                       leave L
                    // lex.symbols.doSy then
                       lex;
                       (sig[]) -> pLabelDecl -> D[];
                       leave L                       
                    else
                       plainPtn -> ptnKind
                   if);
                // lex.symbols.virtual then
                   lex; 
                   virtualPtn -> ptnKind               
                // lex.symbols.further then
                   lex; 
                   furtherPtn-> ptnKind
                // lex.symbols.final then
                   lex; 
                   FinalPtn -> ptnKind
                else
                   3 -> syntaxError;
                   (if errorDecl[] = none then 
                       '**** errorDecl is none' -> putline
                   if);
                   errorDecl[] -> D[];
                   leave L
               if);
               true -> pObjectGenerator -> OD[];
               
               (*OD.IS.handleNewProps;*)
               (if OD.IS.primNo 
                // rAssign_prim // vAssign_prim then
                   (sig[],OD[],ptnKind) -> AssignmentPtnGen -> P[] -> D[]
                // restart_prim // leave_prim then
                   (sig[],OD[],ptnKind) -> BreakPtnGen -> P[] -> D[]; 
                // indexedPut_prim 
                // indexedGet_prim
                // stringGet_prim
                // indexed_prim
                // asString_prim then
                   (sig[],OD[],ptnKind) -> IndexedPtnGen -> P[] -> D[]
                // put_prim // get_prim
                // ifthen_prim // inner_prim // none_prim
                // suspend_prim // resume_prim 
                // disable_prim // enable_prim // attach_prim
                // cmpAndSwap_prim // fork_prim // sleep_prim 
                // thisCore_prim 
                // file_open_prim // file_get_prim 
                // file_eof_prim // file_close_prim 
                // dumpObj_prim then
                   (sig[],OD[],ptnKind) -> OtherPrimPtnGen -> P[] -> D[]
                else
                   (if false then
                       '**** ptn: ' -> putline;
                       sig.dopt -> putline;
                       sig.id[] -> putline;
                       (*sig._a_rgs.dopt -> putline; '---'-> putline;
                        * sig._a_rgs.scanSons(#do current.dopt->putline #);
                        *)
                   if);
                   (sig[],OD[],ptnKind) -> GeneralPtnGen -> P[] -> D[]; 
               if);
               OD.IS.isPrimitive -> P.isPrimitivePtn;
               (if D.primNo
                // object_prim then D[] -> objectDecl[]
                // none_prim then D[] -> noneDecl[]
                // integer_prim then D[] -> integerDecl[]
                // char_prim then D[] -> charDecl[]
                // string_prim then D[] -> stringDecl[]
                // boolean_prim then D[] -> booleanDecl[]
                // float_prim then D[] -> floatDecl[]
                // error_prim then D[] -> errorDecl[]
                // this_prim then D[] -> thisDecl[]
                // thisCore_prim then D[] -> thisCoreDecl[]
                // Resume_prim then D[] -> resumeDecl[]
                // ifThen_prim then D[] -> ifThenDecl[]
                // indexed_prim then D[] -> IndexedDecl[]
                else
                   (if D.isCore = core_prim then D[] -> coreDecl[]
               if)if);
            #);
          isInArg -> D.isInArg;
          isOutArg -> D.isOutArg;
       exit D[]
       #);
     pSignature:
       (* foo:
        * fool(a: ?integer, ...):
        * %put x: ?integer ... :
        * ++ V: ?integer: 
        *)
       (# sym,id: ^text; sig: ^Signature; args: ^Arguments; prevSymb: @char;
          elimArgs: (# exit true #)
       do (if lex.symb              
           // lex.symbols.idf then 
              lex.sym[] -> sym[];
              lex;
              (if pNewFatCommaFile then
                  (if lex.symb 
                   // lex.symbols.leftBrack 
                   // lex.symbols.leftSquare
                   // lex.symbols.begin then
                      lex.symb -> prevSymb;
                      (if false then
                          '**** pSignature:arguments: ' -> puttext;
                          sym[] -> putline;
                      if);
                      lex;
                      Arguments -> args[]; true -> args.isKeyword;
                      (if elimArgs then
                          (sym[],args[],true) -> KeyWordSigGen -> sig[];
                          (* Note sym[]->sig.id[] is overwritten below *)
                      if);
                      (sym[],prevSymb) -> pSigArgs
                      (#
                      do (if elimArgs then
                             D[] -> sig.append
                          else
                             D[] -> args.append;  
                         if);
                         (if false then D.dopt -> putline if)
                      #) 
                        -> id[];
                      (if not elimArgs then
                          (sym[],args[],true) -> KeyWordSigGen -> sig[];
                      if);
                      id[] -> sig.id[];
                      true -> sig.isNewFatCommaSig;
                      (if false then
                          '**** pSignature: ' -> puttext; sig.dopt -> puttext;
                          ' id: ' -> puttext; id[] -> putline
                      if)
                   else
                      (sym[],arguments,false) -> UnarySigGen -> sig[]
                  if)
               else 
                  (* UnarySignature *)
                  Arguments -> args[];
                  (sym[],args[],false) -> UnarySigGen -> sig[]
              if)
           // lex.symbols.keyword then
              (if (1 -> lex.sym.inxGet) = '@' then
                  lex.sym[] -> sym[]; (*sym[] -> putline;*)
                  lex;
                  Arguments -> args[]; 
                  sym[] -> name -> args.append;
                  true -> args.isNewKeyWord;
                  (if lex.symb = lex.symbols.colon then 
                      (* do we need this test?*)
                  if)
               else '\n!!!pSignature: do we come here?' -> putline;
                  lex.sym[] -> sym[];
                  lex;
                  Arguments -> args[]; 
                  sym[] -> name -> args.append;
                  pArguments
                  (#
                  do D[] -> args.append
                  #); 
              if);
              (sym[],args[],true) -> KeyWordSigGen -> sig[];
           // lex.symbols.special then
              (* binary *)
              lex.sym[] -> sym[];
              lex;
              Arguments -> args[]; true -> args.isBinary;
              (if lex.symb = lex.symbols.colon then
                  (sym[],args[],false) -> BinarySigGen -> sig[]
               else
                  pArgument -> args.append;
                  (sym[],args[],false) -> BinarySigGen -> sig[]
              if)
          if);
       exit sig[]
       #);     
     brackAsText:
       (# sy: @integer; T: ^Text
       enter sy
       do (if sy
           // lex.symbols.leftBrack then '(' -> T[]
           // lex.symbols.rightBrack then ')' -> T[]
           // lex.symbols.begin then '{' -> T[]
           // lex.symbols.end then '}' -> T[]
           // lex.symbols.leftSquare then '[' -> T[]
           // lex.symbols.rightSquare then ']' -> T[]
           else
              '?' -> T[]
          if)
       exit T[]
       #);
     pSigArg:
       (# D: ^Decl; P: ^Pattern
       do pDecl -> D[]; (* Perhaps not all decl's should be allowed *)
          true -> D.isArg; (* when is D.isArg used ? *)
          true -> D.isInArg;
          (if D## = pattern## then
              D[] -> P[];
              (if P.ptnKind = plainPtn then
                  SyntaxError
                  (#
                  do 'A non-virtual pattern cannot be an argument' 
                       -> putline 
          #)if)if)
       exit D[]
       #);
     pSigArgs:
       (# sym: ^Text; D: ^TopNode; id,comma: ^text;
          leftB,rightB: @char
       enter(sym[],leftB)
       do leftB + 1 -> rightB;
          sym.copy -> comma[]; 
          leftB -> brackAsText -> comma.puttext -> name -> D[];
          comma.copy -> id[];
          inner pSigArgs;
          Loop:
            (#
            do pSigArg -> D[]; 
               inner pSigArgs;
               (if lex.symb 
                // rightB (*lex.symbols.rightBrack*) then
                   lex;
                   (if lex.symb 
                    // lex.symbols.fatComma then
                       rightB -> brackAsText -> comma[];
                       lex.sym.copy -> comma.append;
                       lex;
                       (if lex.symb 
                        // lex.symbols.leftBrack 
                        // lex.symbols.leftSquare
                        // lex.symbols.begin then
                           lex.symb -> leftB;
                           leftB + 1 -> rightB;
                           leftB -> brackAsText -> comma.puttext -> Name -> D[];
                           comma.copy -> id.append;
                           lex;
                           inner pSigArgs;
                           restart Loop
                        else
                           111 -> syntaxError
                       if)
                    else
                       rightB -> brackAsText -> comma[] -> name -> D[];
                       comma.copy -> id.append;
                       inner pSigArgs
                   if)
                // lex.symbols.comma then
                   ',' -> comma[] -> name -> D[];
                   ',' -> id.append;
                   inner pSigArgs;
                   lex;
                   restart Loop
               if)
            #)
       exit id[]
       #);
     pArgument:
       (# D: ^Decl; P: ^Pattern
       do pDecl -> D[]; (* Perhaps not all decl's should be allowed *)
          true -> D.isArg;
          (if D## = pattern## then
              D[] -> P[];
              (if P.ptnKind = plainPtn then
                  SyntaxError
                  (#
                  do 'A non-virtual pattern cannot be an argument' 
                       -> putline 
          #)if)if)
       exit D[]
       #);
     pArguments:
       (# D: ^TopNode
       do Loop:
            (#
            do pArgument -> D[]; 
               inner pArguments;
               (if lex.symb 
                // lex.symbols.fatComma then
                   lex.sym[] -> Name -> D[];
                   lex;
                   inner pArguments;
                   restart Loop
                // lex.symbols.comma then
                   lex;
                   restart Loop
               if)
            #)
       #);
     pInvocation:
       (* foo
        * R.foo
        * R ++ E
        * R.%put E1 %at Inx
        * a:= a + b * 117
        * R.S ++ E . %put E %at I
        *)
       (# IV: ^Invocation;
          E: ^Exp;
          i: @integer
       do Invocation -> IV[]; 
          Loop:
            (#
            do i + 1 -> i;
               pExp -> E[] -> IV.append; (* elim is E.isEmpty *)
               (if lex.symb 
                // lex.symbols.dot then
                   lex;
                   restart Loop
                // lex.symbols.special then 
                   restart Loop
                // lex.symbols.idf then
               if)
            #);          
          (if i = 1 then 
              E.isEmpty -> IV.isEmpty;
              (* if E.isEmpty, we have IV = (invocation (???))
               * where '???' is the label of an empty exp
               * This is an annoying special case that complicates
               * the compiler; we test for this situation 
               * in ObjectGenerator::qGen and other places!
               * it would be more clean to do
               *  none -> IV.son[] where we get IV =  (invocation ())
               *)
          if)
       exit IV[]
       #);
     scanForBrace:
       (# T,inn: ^Text; first,last: @integer
       enter T[]
       do 0 -> first -> last;
          T.scanAll
          (# toInn,predIsSlash: @boolean; pos: @integer
          do pos + 1 -> pos; 
             (if ch 
              // '\\' then true -> predIsSlash
              // '{' then
                 (*'**** got { in: ' -> puttext; T[] -> putline;*)
                 &text[] -> inn[];
                 not predIsSlash -> toInn;
                 false -> predIsSlash;
                 pos -> first;
              // '}' then
                 not predIsSlash -> toInn;
                 false -> predIsSlash;
                 pos -> last;
                 inner scanForBrace
              else
                 false -> predIsSlash;
                 (if toInn then ch -> inn.put if)
             if);
          #)
       #);
     handleString: 
       (# T: ^Text; S: ^StringObj; E: ^Invocation; err: ^text
       enter T[]
       do T[] -> StringObj -> S[];

          T[] -> scanForBrace
          (# 
          do (*'**** inn: ' -> puttext; inn[] -> puttext;*) 
             inn[] -> parseInv -> (err[],E[]);
             (if err[] <> none then
                 '*** syntax error' -> putline
              else
                 E[] -> S.append;
                 (*' Exp: ' -> puttext; E.dopt -> putline;*)
             if)
          #)
       exit S[]
       #);
     pExp:
       (* R.foo
        * f(e1,e2,e3)
        * a + b
        * %if E0 %then E1 %else E2
        *)
       (# sym,sym2: ^Text;
          E: ^Exp; prevSymb: @char
       do (* '\npExp: ' -> puttext; lex.symb -> lex.symbols.print; 
           *  ' ' -> put; lex.sym[] -> puttext;
           *)
          L:
          (if lex.symb 
           // lex.symbols.const then
              lex.sym[] -> Const -> E[];
              lex;
           // lex.symbols.floatConst then
              lex.sym[] -> FloatConst -> E[];
              lex;              
           // lex.symbols.string then
              lex.sym[] -> handleString -> E[];
              lex;
           // lex.symbols.charSy then 
              lex.sym[] -> CharObj -> E[];
              lex;
           // lex.symbols.idf then 
              lex.sym[] -> sym[];
             (* lex;*)
              (if pNewFatCommaFile then
                  (if '#' = (1 -> sym.inxGet) then
                      (*'Got # '->puttext; sym[] -> putline;*)
                      ((false,false,Signature) -> pVarRefType, Arguments)
                        -> UnaryGen ->  E[];
                      (*newline; lex.symb -> lex.symbols.asText -> putline;*)
                      leave L
                  if);
                  lex;
                  (if lex.symb
                   // lex.symbols.leftBrack 
                   // lex.symbols.leftSquare
                   // lex.symbols.begin then
                      lex.symb -> prevSymb;
                      lex;
                      (if false then
                          'goFAT: ' -> puttext; 
                          sym[] -> puttext;
                          ' ' -> puttext; 
                          prevSymb -> lex.symbols.asText -> puttext;
                          newline;
                      if);
                      (sym[],prevSymb) -> pNewFatCommaX -> E[]
                   else (*unary *)
                      (sym[],arguments) -> UnaryGen -> E[]
                  if)
               else     
                  lex;
                  (if lex.symb 
                   // lex.symbols.leftBrack then
                      lex;
                      sym[] -> pFunction  -> E[]
                   else 
                      (sym[],arguments) -> UnaryGen -> E[]
                  if)
              if)
           // lex.symbols.special then
              lex.sym[] -> sym[];
              lex;
              sym[] -> pBinary -> E[]
           // lex.symbols.keyword then 
              lex.sym[] -> sym[];
              lex;             
              (*'exp:kw:' -> puttext; lex.current -> putline;*)
              sym[] -> pKeyword -> E[]
           // lex.symbols.leftBrack then
              lex.sym[] -> sym[];
              lex;
              pBracketedExp -> E[]
          (* // lex.symbols.begin then
              pMainPart -> ObjectGeneratorExp -> E[]*)
           else
              Exp -> E[]; 
              true -> E.isEmpty
          if);
          (if lex.symb = lex.symbols.string then
              (* *** got string: ' -> puttext; E.dopt -> puttext;
               lex .sym[] -> putline;
               *)
              lex.sym[] -> StringObj -> E.unit[];
              lex
           else
              StringObj -> E.unit[]
          if)
       exit E[]
       #);
     pNewFatCommaX:
       (# sy,sig,comma: ^text; E,F: ^exp;
          args: ^Arguments;
          IS: ^Items;
          IV: ^Invocation;
          leftB,rightB: @char;
          isFatComma: @boolean;
          asCh:
            (# sy: @integer; T: ^Text
            enter sy
            do (if sy
                // lex.symbols.leftBrack then '(' -> T[]
                // lex.symbols.rightBrack then ')' -> T[]
                // lex.symbols.begin then '{' -> T[]
                // lex.symbols.end then '}' -> T[]
                // lex.symbols.leftSquare then '[' -> T[]
                // lex.symbols.rightSquare then ']' -> T[]
                else
                   '?' -> T[]
               if)
            exit T[]
            #);
       enter(sy[],leftB)
       do (if false then
              'pNFCX: ' -> puttext; sy[] -> puttext; ' ' -> put;
              leftB -> asCh -> puttext;
          if);
          leftB + 1 -> rightB;
          (if leftB = lex.symbols.leftSquare then true -> isFatComma if);
          (if false then
              ' ' -> put; rightB -> asCh -> puttext; ' ' -> put;
          if);
          
          Arguments -> args[];  true -> args.isKeyword;
          sy.copy -> sig[]; leftB -> asCh -> sig.puttext; 
          sig.copy -> comma[];
          
          (if false then
              sig[] -> puttext;  ' ' -> put; comma[] -> putline;
          if);
          loop:
            (if true then
                (if false then
                    '**** ' -> puttext;  sig[] -> puttext; ' ' -> put; 
                    lex.symb -> lex.symbols.asText ->  putline;
                if);
                (if lex.symb <> rightB then
                    comma[] -> Name -> args.append;
                    (if leftB = lex.symbols.begin then
                        pItems -> IS[];
                        Invocation -> IV[];
                        Exp -> E[] -> IV.append;
                        true -> IV.isEmpty -> E.isEmpty;
                        (IV[],IS[]) -> ObjectGenerator -> args.append
                     else
                        pObjectSpec -> args.append;
                    if)
                 else
                    (if pNewFatCommaFile then
                        'Hovsa: "'->puttext;
                        sig[] -> puttext; '"  "' -> puttext; 
                        lex.symb -> lex.symbols.asText ->  puttext;
                        '"'->putline;
                        121 -> syntaxError
                    if);
                if);
                (if lex.symb 
                 // lex.symbols.comma // lex.symbols.semiColon then
                    ',' -> sig.put;
                    ',' -> comma[];
                    lex;
                    restart loop
                 // rightB then
                    rightB -> asCh -> sig.puttext;
                    rightB -> asCh -> comma[];
                    lex;
                    (if lex.symb = lex.symbols.fatcomma then
                        true -> isFatComma;
                        lex.sym.copy -> sig.puttext;
                        lex.sym.copy -> comma.puttext;
                        lex;
                        (if lex.symb 
                         // lex.symbols.leftBrack
                         // lex.symbols.leftSquare
                         // lex.symbols.begin then
                            lex.symb -> leftB;
                            leftB + 1 -> rightB;
                            leftB -> asCh -> sig.puttext;
                            leftB -> asCh -> comma.puttext;
                            lex;
                            restart loop
                        if)
                     else
                        leftB + 1 -> asCh -> Name -> args.append;  
                    if)
                 // lex.symbols.eos then
                 else
                    117 -> syntaxError
                if)      
            if);
          (if leftB = lex.symbols.begin then
              true -> args.inBraces;              
          if);
          (if false then
              '**** newFatComma:X:sig: "' -> puttext; sig[] -> puttext;
              '" sy: "' -> puttext; sy[] -> puttext;
              '" leftB: "' -> puttext; leftB -> asCH -> puttext;
              '" ' -> puttext; lex.symb -> lex.symbols.asText -> putline;
              args.scanSons
              (#
              do current.dopt -> putline
              #)
          if);
          (if isFatComma then
              (sig[],args[]) -> KeyWordgen -> F[];
           else
              (sy[],args[]) -> KeyWordgen -> F[]
          if)
       exit F[]
       #);
     pFunction:
       (# sym: ^text;
          F: ^Exp;
          args: ^Arguments;
          OG: ^ObjectSpecification
       enter sym[]
       do Arguments -> args[];  true -> args.isFunction;         
          loop:
            (if true then
                (if true then
                    pObjectSpec -> OG[]
                 else
                    pObjectGenerator -> OG[];(* -> F.append;*)
                if);
                OG[] -> Args.append;
                (*lex.symb -> lex.symbols.print;*)
                (if lex.symb 
                 // lex.symbols.comma then
                    lex;
                    restart loop
                 // lex.symbols.rightBrack then
                    lex;
                   (* (if lex.skipcomment.comment.length > 0  then 
                        '*** got comment:A:' -> putline;
                        lex.skipcomment.comment[] -> putline
                    if)*)
                 else
                    6 -> SyntaxError
                if)
            if);
          (sym[],args[]) -> FunctionGen -> F[];
          (* (if args.comment[] <> none then
              '*** got comment:B:' -> putline;
              args.doPT -> putline;
              args.comment[] -> F.commentAfter[]
          if)*)
       exit F[]
       #);
     pBinary:
       (# op: ^text; IV: ^ObjectSpecification; B: ^Exp; args: ^Arguments
       enter op[]
       do Arguments -> args[];
          true -> args.isBinary;
          (if true then
              pObjectSpec-> IV[] -> args.append;
           else
              pObjectGenerator -> IV[] -> args.append;
          if);
          (op[],args[]) -> BinaryGen -> B[];
       exit B[]
       #);
     pKeyword:
       (# sym,id: ^Text; (* sym = keyword = %put *)
          K: ^Exp;
          args: ^Arguments; OG: ^objectSpecification;
       enter(sym[])
       do sym[] -> id[]; 
          Arguments -> args[];
          true -> args.isKeyWord;
          (if (1 -> sym.inxGet) = '@' then
              (if ('@if' -> sym.equalNCS) then
                  (*'@parseKw:'->puttext; id[] -> putline;*)
                  (*' ' -> put; lex.sym[]  -> puttext;
                  ' ' -> put; lex.symb -> lex.symbols.asText->putline;*)
                  pIfExp -> K[];
                  leave pKeyWord
              if);
              ':' -> sym.put;
              sym.copy -> Name -> args.append;
              loop:
                (#
                do (if true then
                       pObjectSpec -> OG[] -> args.append;
                    else
                       pObjectGenerator -> OG[] -> args.append; 
                   if);
                   (if lex.symb = lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                if)#);
           else 'Båt!'->putline; (* We never come here! *)
              sym.copy -> Name -> args.append;
              Loop:
                (#
                do pObjectGenerator -> OG[] -> args.append; 
                   (if lex.symb = lex.symbols.fatComma then 
                       lex.sym[] -> Name -> args.append;
                       lex.sym[] -> id.append;
                       lex;
                       restart Loop
                   if);
                #);
          if);
          (id[],args[]) -> KeyWordGen -> K[];
       exit K[]
       #);
     pIfExp:
       (# ifE: ^Exp; cond,thenPart,elsePart: ^ObjectSpecification
       do pObjectSpec -> cond[];
          (if (lex.symb <> lex.symbols.fatComma)
              and not (':then' -> lex.sym.equalNCS) then
              117 -> syntaxError
          if);
          lex;
          pObjectSpec -> thenPart[];
          (*thenPart.dopt -> putline;*)
          (*lex.symb -> lex.symbols.asText -> puttext;
          ' ' -> put; lex.sym[] -> putline;*)
          (if (lex.symb = lex.symbols.fatComma)
              and (':else' -> lex.sym.equalNCS) then
              (*'   elsePart:\n' -> puttext;*)
              lex;
              pObjectSpec -> elsePart[];
              (cond[],thenPart[],elsePart[]) -> IfThenElse -> IfE[]
           else
              (cond[],thenPart[]) -> IfThen -> IfE[]
          if)
       exit ifE[]
       #);
     pBracketedExp:
       (# E: ^exp; I: ^Invocation
       do (* pExp *) pInvocation  -> I[];
          I[] -> BracketedExp -> E[];
          L:
            (if lex.symb 
             // lex.symbols.comma then
                lex;
                pInvocation -> E.append;
                restart L
             // lex.symbols.rightBrack then
                lex
             else
                111 -> SyntaxError
            if);
       exit E[]
       #);
     
     parseSubText:
       (# xsyntaxerror:< 
            (# errorStream: ^stream
            do '!!!! syntax error'->putline;
               lex.errorStream[] -> errorStream[] -> putline;
               inner
            exit errorStream[]
            #);
          inn: ^text; (* the qbeta text to be parsed *)
          oldLex: ^Lexer;
          oldHasSyntaxError: @boolean;
          errs: ^Stream; ind: @integer
       enter inn[]
       do lex[] -> oldLex[]; 
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          hasSyntaxError -> oldHasSyntaxError;
          false -> hasSyntaxError;
          0 -> inn.setPos;
          lex;
          inner;
          (if hasSyntaxError then
              xsyntaxError -> errs[] (* check if this is ever used, 
                                      * including exit errors[] below
                                      *)
          if);
          oldHasSyntaxError or hasSyntaxError -> hasSyntaxError;          
          lex.hasLexError or oldLex.hasLexError -> oldLex.hasLexError;
          oldlex[] -> lex[]; 
       exit errs[]
       #);
     browserItem::
       (#
       do '\n**** browserItem: ' -> puttext; T[] -> putline;
          T[] -> parseSubText
          (#
          do '!!!! browserItem:not implemented'->putline
          #) 
       #);
     parseInv: parseSubText
       (# xsyntaxerror:: (# do 'syntax error' -> putline #);
          E: ^Invocation
       do pInvocation -> E[];
       exit E[]
       #);
     mkItems: parseSubText
       (# IS: ^Items
       do pItems -> IS[]
       exit IS[]
       #);
     parseObjectGeneratorText: parseSubText
       (# OG: ^ObjectGenerator
       do pObjectGenerator -> OG[]
       exit OG[]
       #);
     parseItemsText::
       (# ind: @integer
       do (if false then
              '**** parseItemsText: ' -> putline; inn[] -> putline;
          if);
          L:
            (#
            do inn[] -> mkItems
               (# xsyntaxerror::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               #) -> (errors[],IS[]);
               (if false then
                   '**** after parse: ' -> putline; IS.doPT -> putline;
               if)
            #)
       #);
     parseDeclTextX:: 
       (# 
       do '***parseDeclTextX: ' -> putline; inn[] -> putline;
          L:
            (# DIx: ^Decl
            do inn[] -> parseSubText
               (# xSyntaxError::
                    (#
                    do '!!!! Syntax errors: ' -> putline;
                       errorStream[] -> errors[];
                       errors[] -> putline;
                       leave L
                    #)
               do pDecl -> DIx[]
               exit DIx[]
               #) -> (errors[],DI[])
            #)
       #);
     parseDeclText: parseSubText
       (# DI: ^Decl
       do pDecl -> DI[];
       exit DI[]
       #);
     mkModuleItem::<
       (# DI: ^DataItem; M: ^Module; errs: ^stream; MI: ^ModuleItem;
       do 'mkModuleItem: ' -> putline; 
          name.copy -> itemT[];
          name.copy -> att[];
          (if kind
           // '/' then (* object module *)
              ': obj\n   dummy: var integer' -> itemT.append;
              ': /' -> att.puttext
           else (* pattern module - but not suppprted in qbeta *)
              ':\n   d: var integer' -> itemT;
              ':' -> att.put
          if);
          itemT[] -> putline;
          itemT[] -> parseDeclText -> (errs[],DI[]);
          DI.dopt -> putline;
          '\n!!!!! mkModuleItem: must be fixed! ' -> putline;
          (true,DI.sig[],DI.OG[]) -> Module -> M[];
          (true,name[],M[]) -> ModuleItem -> MI[] -> dcl[];
          (*DI.sig[] -> MI.sig[];*)
          (* pathToModule[] -> MI.dir[];*)
          moduleF[] -> MI.md.inFile[];  
          true -> MI.isParsed; (* needed? *)
          dcl[] -> M.father[];  (* needed? *)
       #); 
     mkDecl::
       (#
       do '\n**** parser:mkDeclY:' -> putline;  
          'kind: ' -> puttext; kind -> put; ' ' -> put; name[] -> putline;
          (if kind
           // ' ' then (* pattern *)
              ':\n   dummy: ? integer' -> name.puttext;
           // '@' then  (* object *)
              ': =\n   dummy: ? integer' -> name.puttext;
          if);
          name[] -> parseDeclText -> (errors[],dcl[]);          
       #);
     parseX_decl::
       (# dclx: ^Decl;
       do (*'*** parseX_decl:'->putline; in[] -> putline;*)
          in[] -> parseSubText
          (# 
          do pDecl -> dclX[]
          #) -> errors[];
          (if errors[] <> none then
              '\n!!!! parse errors: ' -> putline;
              errors[] -> putline
           else
              (*(if dclX[] = none then 'dclX:none'->putline
               else
                  'dclX: ' -> puttext; dclX.doPT -> putline
              if);
              (if dclX.sig[] = none then 'sig is none'->putline
               else
                  'sig: ' -> puttext; dclX.sig.doPT -> putline
              if);              
              (if dclX.sig.id[] =none then
                  'id is none ' -> putline
               else
                  dclX.sig.id[] -> putline
              if);*)
              dclX.sig.id[] -> name[];
              (if true
               // ('obj' -> (dclX.label).equal)
               // ('Module' -> (dclX.label).equal) then
                  kinds.objModule -> kind;
               else 
                  'Item is a "' -> errors[];
                  dclX.label -> errors.puttext;
                  '" - it must be an object of the form "obj: =? ..."' 
                    -> errors.puttext
              if)
              (*': /' -> skind[];*)
          if);
          dclX[] -> dcl[];
       #);
     pDirModuleX::
       (# 
       do (if false then
              '**** pDirModuleX: ' -> puttext; moduleDir[] -> putline;
              '**   path: '-> puttext; pathToDir.append -> putline;
          if);
          (*moduleDir[] -> path.push;*)
          pathToDir[] -> path.push;
          (pathToDir[],moduleDir[]) -> DirectoryComponents
          (# 
          do (if false then
                 '**   DirElm/current:\n' -> puttext; 
                 current[] -> putline;
             if);
             (current[],isAltExtension) -> pModule -> md[];
             (if false then
                 '**   Module: ' -> puttext;  md.sig.doPT -> putline;
             if)
          #);
          path.pop          
       #);
     scanTokens:
       (# inn: ^text; oldLex: ^Lexer
       enter inn[]
       do lex[] -> oldLex[];
          &lexer[] -> lex[];
          0 -> inn.setPos;
          inn[] -> lex.initWithText;
          true -> lex.isXbeta;
          false -> hasSyntaxError;
          loop:
            (if true then
                lex;
                inner;
                (if lex.symb <> lex.symbols.eos then restart Loop if)
            if);
          (if hasSyntaxError then
             (* xsyntaxError -> errs[] (* check if this is ever used, including
                                      * exit errors[] below
                                      *)
          if);
          oldlex[] -> lex[];
       #);
     handleReservedId::
       (#
       do inn.setpos;
          inn[] -> scanTokens
          (# 
          do 
             (if lex.symb 
              // lex.symbols.varVal
              // lex.symbols.constVal
              // lex.symbols.varRef
              // lex.symbols.constRef
              // lex.symbols.outArg 
              // lex.symbols.inArg 
              // lex.symbols.keyword
                 then
                 (lex.nextCh.posBeforeName,lex.nextCh.pos - 1)
                   -> theHandler
              // lex.symbols.fatComma
                 then
                 (if (1->lex.sym.inxGet) = ':' then
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 1) 
                       -> theHandler
                  else
                     (lex.nextCh.posBeforeName,lex.nextCh.pos - 2) 
                       -> theHandler
                 if)
             if);
       #)#);
                  
     hasSyntaxError: @boolean;
     SyntaxError:
       (# n: @integer
       enter n
       do '\nSyntax error: '-> puttext; n -> putint; 
          ' ' -> put; lex.symb -> lex.symbols.print;
          (if lex.fileName[] <> none then
              ' file:\n   ' -> puttext; lex.fileName[] -> putline
          if);
          3 -> lex.printlines;
          newline;

          true -> hasSyntaxError;
          inner;
          
          (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
          lex.oldPos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;

          lex.nextCh.pos -> lex.errorStream.putint; ' ' -> lex.errorStream.put;
          'Syntax error (' -> lex.errorStream.puttext;
          n -> lex.errorStream.putint;')' -> lex.errorStream.put;
          
          ' expected symbols: ' -> lex.errorStream.puttext;          
          '?' -> lex.errorStream.put; (* temporary *)
          lex.errorStream.newLine;
          n -> syntaxErrMsg -> lex.errorStream.putline;
          skip:
            (#
            do lex; 
               (if lex.symb = lex.symbols.eos then leave skip if);
               (if lex.symb = lex.symbols.semicolon then
                   (*lex*)
               else
                   restart skip
               if)
            #);
          (if true then
              lex.errorStream[] -> putline;              
           else
              (failureTrace,'Syntax error in:\n'->lex.fileName.prepend)  
                -> stop
          if)
        #);
     genTokenStream: superParser
       (# ind: @integer
       do Loop:
           (if true then 
               lex;
               (*lex.symb -> putint; ' ' -> put;*)
               (if lex.symb 
                // lex.symbols.begin then
                   newline;
                   (for i: (ind + 2 -> ind) repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                // lex.symbols.semicolon then
                   lex.symb -> lex.symbols.print; 
                   newline;
                   (for i: ind repeat ' ' -> put for)
                // lex.symbols.end then
                   newline;
                   (for i: ind repeat ' ' -> put for);
                   lex.symb -> lex.symbols.print; 
                   ind - 2 -> ind;
                   newline;
                   (for i: ind repeat ' ' -> put for);
                // lex.symbols.idf 
                // lex.symbols.const
                // lex.symbols.floatConst
                // lex.symbols.charSy
                // lex.symbols.string
                // lex.symbols.special 
                // lex.symbols.keyword 
                // lex.symbols.fatComma 
                // lex.symbols.property then
                   lex.sym[] -> puttext
                else
                   lex.symb -> lex.symbols.print; 
               if);
               ' ' -> put;
               (if lex.symb <> lex.symbols.eos then restart Loop if)
           if)
       #);

     topPath: ^text;
     onlyLex: @boolean;
     rootModule,
     main: ^Module;
     mainPT,mainPP,printHTMLfile: @boolean;
     altParser: @boolean
  do (if onlyLex then
         (FN[],altParser) -> genTokenStream
      else
         (* There is a mess with respect to compile being called from
          * the stand-alone compiler, qbeta or from qenv
          * From qenv the first call of compile differs from subsequent 
          * calls.
          * The first call from qenv parse all modules and builds their 
          * ASTs
          * Subsequent calls use exisiting AST's - i.e. no parsing
          * When en entity is text-edited in qenv, it is parsed and 
          * replaces the old version on the ASTs
          * 
          * Fullpath:false - called from qbeta
          *         : true - called from qenv
          * rootModule:false - called from qbeta or first call from qenv
          *            true  - subsequent calls from qenv
          * withPos: false - call from qbeta and used by lexer 
          *                  to print errormessages on stdout
          * withPos: true  - from qend and used by lexer to return 
          *                  String with
          *                  errors and positions of these in qenv buffer
          * A clean-up here is needed
          *)
         (if false then
             (if fullPath then
                 'fullPath:true ' -> puttext
              else 
                 'fullPath:false ' -> puttext
             if);
             (if withPos then
                 'withPos:true ' -> puttext
              else
                 'withPos:false ' -> puttext
             if);
             (if rootModule[] <> none then
                 'rootModule:not none'->putline
              else
                 'rootModule:none' -> putline
         if)if);
         
         (if rootModule[] = none  then 
             (* Called from qbeta stand-alone compiler or 
              * first compilation from qenv when starting qenv
              *)
             &lexer[] -> lex[]; 
             true -> lex.isXbeta;
             path.init;
             (fullPath,FN[]) -> locateWorld -> topPath[];
             (* Currenly we assume that BETAwolrd is using.xbeta syntax!*)
             (topPath[],false) -> pModule -> rootModule[];
             rootModule.handleDirModules (* all of BETAworld is parsed*)
             (# pDirModule::
                  (#
                  do (if false then
                         '**** pDirModule: ' -> puttext; 
                         moduleDir[] -> putline;
                     if);
                     moduleDir[] -> path.push;
                     (path.append,moduleDir[]) -> DirectoryComponents
                     (# 
                     do (if false and isAltExtension then
                            '**   DirElm:altExtension:\n ' -> puttext; 
                            current[] -> putline;
                        if);
                        (current[],isAltExtension) -> pModule -> md[];
                        (if false then
                            '**   Module: ' -> puttext;  
                            md.sig.doPT -> putline;
                        if)
                     #);
                     path.pop
                  #)
             #)
               -> main[];
          else
             (*'*** Parser called from qenv - thus no parsing'- putline;*)
             theM[] -> main[];
             rootModule.clear;
             main.clear
         if);
         (*(false,false,signature,ObjectGenerator) 
          * -> DataItem -> errorDecl[];*)
         &iModule[] -> iMain[];
         main[] -> iMain.M[];
         (*'**** rootModule: ' -> putline; rootModule.doPT -> putline; *)
         (if mainPT then
             '**** main: ' -> putline; main.doPT -> putline
         if);
         (if printHTMLfile then
             (# FNx: ^text; F: @file
             do FN[] -> FNx[];
                '.html' -> ((1,FN.length - 6) -> FN.sub).append -> FN[];
                FN[] -> F.name;
                F.openWrite;
                main.doHTML -> F.putline;
                F.close
             #);
         if);
         (if false then
             (# AST: ^ Node
             do main.copyAST -> AST[];
                '*** The AST copy:' -> putline;
                (*AST.doPP -> putline;*)
                AST.doPT -> putline;
                '---' -> putline;
         #)if);
         (if mainPP then
             main.doPP -> putline
         if);
         (*rootModule.doPP -> putline;*)
         lex.hasLexError or hasSyntaxError -> hasSyntaxError;
         (* hasSyntaxError:false => dont calle execute *)
         (if not hasSyntaxError then
             inner
         if)
     if)
  #)
