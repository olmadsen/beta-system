ORIGIN '~beta/basiclib/betaenv'; 
INCLUDE 'qvariants';
INCLUDE '../VM/objectcode'; 
BODY 'qgeneratorBody';
---lib:attributes---
traceArgOG: (# exit false #);
generator: variants
  (# traceModules: (# exit false #);
     noOGwarn: @boolean;
     Module::
       (# markForCodeGen::
            (#
               M: ^Module;
            do (if traceModules then
                   'MarkForCodeGen:module: ' -> puttext; 
                   sig.dopt -> putline;
               if);
               (if (encModule -> M[]) <> none then
                   M.markForCodeGen
               if);
               OG.markForCodeGen;
            #);
          Qgen:: 
            (# 
            do (if false  then
                   '**** Module:gen: ' -> puttext;  sig.dopt -> puttext;
                   ' newOff: '  ->  puttext; 
                   this(Module).newOff -> putint;
                   newline;
               if);
               cd.bcPos -> beginBCP;               
               (false,0,this(Module).NewOff) -> OG.Qgen;
               cd.bcPos -> endBCP               
            #);  
          genMI:
            (# useReturnValue: @boolean; superAdj,staticOff: @integer;
               mainPathModule: ^Module;
               isLocalMI: @boolean
            enter(useReturnValue,superAdj,staticOff)
            do (if isIncluded  then
                   (if traceModules then
                       '**   genMI:Module included: ' -> puttext; 
                       sig.doPT -> puttext;
                       ' staticOff:' -> puttext; staticOff -> putint;
                       newline
                   if);
                   cd.com(#do 'Module:genMI: '-> TT; sig.dopt->TQ #);
                   (if inMainPath then
                       (if false then
                           '**** inMainPath: ' -> puttext;
                           sig.dopt -> putline;
                       if);
                       this(Module)[] -> mainPathModule[]
                    else
                       (useReturnValue,superAdj,staticOff) -> Qgen;
                   if)
                else
                   (if traceModules then
                       '**** genMI:Module not included: ' -> puttext;
                       sig.doPT -> putline
               if)if)
            exit mainPathModule[]
            #);          
          getAdr::
            (#
            do true -> loadRec;
               0 -> Address -> A[];
               newOff -> A.off
            #);
          invoke::
            (#
            do cd.com(#do 'Module:invoke:adr<>none:'->TT; 
                        adr[] <> none -> BB  #);
               (if adr[] <> none then 
                   adr.load
                else
                   (sig.id[],NewOff) -> cd.rpushg
               if)
            #);
          findNextImp:: (# do bcp -> OG.IS.findNextImp -> impx[] #);
       #);
     ModuleItem::
       (# markForCodeGen:: 
            (#
            do (if tracemodules then
                   'MarkForCodeGen:moduleItem: isIncluded: ' -> puttext;
                   MD.isIncluded -> putBoolean; ' ' -> put;
                   MD.sig.dopt -> putline;
               if);
               (if MD.isIncluded then MD.markForCodeGen if)#);
          Qgen::
            (#
            do (if true then
                   (if MD.isIncluded then
                       (if traceModules then
                           '**** ModuleItem:included: ' -> puttext; 
                           sig.doPT -> putline;
                       if);
                       cd.com(#do 'ModuleItem:gen'-> TT; sig.dopt->TT #);
                       (if MD.inMainPath then
                           MD[] -> mainPathModule[]
                        else
                           (useReturnValue,superAdj,staticOff) -> MD.Qgen;
                       if)
                    else
                       (if traceModules then
                           'Module not included: ' -> puttext; 
                           sig.doPT -> putline
               if)if)if)
            #);

          getAdr::
            (#
            do A[] -> MD.getAdr -> (loadRec,A[])
            #);
          pushThis:: (# do cd.pushThis #);
          invoke:: (# do 'ModuleItem:invoke:'-> cd.comment; MD.invoke #);
          store:: (# do '\nModuleItem:store'->putline #);
          popReturn:: (# do '\nModuleItem:popReturn'->putline #);
          findNextImp:: (# do bcp -> md.findNextImp -> impx[] #);          
       #);
     newProperty::
       (# qgen::  
            (# MIlist: @
                 (# collect:
                      (#
                      do (theModule).OG.IS.scanAllDecls
                         (#
                         do (if currentDcl.isModuleItem then
                                (if false then
                                    '**   collect: ' -> puttext;
                                    currentDcl.sig.dopt -> putline;
                                if);
                                currentDcl[] -> add
                         if)#)
                         #);
                    add:
                      (# MI: ^ModuleItem
                      enter MI[]
                      do (if (top + 1 -> top) > L.range then
                             L.range -> L.extend;
                             done.range -> done.extend
                         if);
                         MI[] -> L[top][]
                      #);
                    scan:
                      (# current: ^ModuleItem
                      do (for i: top repeat
                              L[i][] -> current[];
                              inner scan
                         for)
                      #);
                    has: BooleanValue
                      (# M: ^Module
                      enter M[]
                      do L:
                           scan
                           (# i: @integer
                           do i + 1 -> i;
                              (if current.MD[] = M[] then
                                  true -> value;
                                  true -> done[i];
                                  leave L
                           if)#)
                      #);
                    gen:
                      (# MP: ^Module
                      do scan
                         (# i:@integer
                         do i + 1 -> i;
                            (if not done[i] then
                                (if false then
                                    '**   gen:MI: ' -> puttext; 
                                    current.sig.dopt -> putline;
                                if);
                                (true,superADj,staticOff) 
                                  -> current.MD.genMI
                                  -> MP[];
                                (if MP[]<>none then
                                    MP[]->mainPathModule[]
                                if)
                            if)
                         #);
                      #);
                    L: [8] ^ModuleItem; done: [8] @boolean; top: @integer
                 #);
               isLocalMI: @boolean
            do (if false then
                   '**** newProperty:qGen: ' -> puttext; dopt -> puttext;
                   ' in:module: ' -> puttext; 
                   (theModule).sig.dopt -> putline
               if);
               (if true
                // ('%requires' -> propId.T.equalNCS)
                // ('%module' -> propId.T.equalNCS) 
                // ('%modules' -> propId.T.equalNCS) then
                   (if (TheModule).requires.codeGenDone then
                       leave qGen 
                   if);
                   (if traceModules then
                       '**** newProperty:qGen:%module ' -> puttext; 
                       dopt -> puttext;
                       ' in:module: ' -> puttext; 
                       (theModule).sig.dopt -> putline
                   if);
                   MIlist.collect;
                   (theModule).requires.scan
                   (#
                   do (if current[] -> MIlist.has then
                          (if false then
                              '**   moduleProp:arg:in:MI:' -> puttext;
                              current.sig.dopt -> putline;
                          if);
                          (if current.inMainPath then
                              (if false then
                                  '**    module:inMainPath: ' -> puttext;
                                  current.sig.dopt -> putline;
                              if);
                              current[] -> mainPathModule[]
                              (* it seems thatnot all modules
                               * that should be on mainPath is catched
                               * by mainPathModule[]!?
                               *)
                           else
                              (true,0,0) -> current.qgen
                          if)
                      if)
                   #);
                   MIlist.gen;
                   true -> (theModule).requires.codeGenDone;
               if)
            #)
       #);
     DataItem::
       (* Cases
        *    C1: val integer(12)
        *    C2: val integer
        *    C3: obj Fool
        *    C4: obj Fool -- singular
        *       ...
        *    V1: var integer(12)
        *    V2: var integer
        *    V3: ref Fool
        *    V4: ref Fool -- singular
        *       ...
        *    X1: obj/val/var foo(e1,e2,e3) where foo returns a ref(T) or val(T)
        *)
       (# markForCodeGen::
            (# 
            do cd.com(#do 'DataItem:markForCodeGen:'->TT; sig.id[]->TQ;
                        ':descNo:'->TT; OG.IS.newDescNo -> II; 
                        ':OG.primNo:'->TT; OG.primno -> II;
                     #);    
               OG.markForCodeGen;
               (if false then OG.checkvirtualSuper if)
            #);
          Qgen:: 
            (# T: @text; OGqual: ^ObjectGenerator; org: ^Items
            do OG.getQual -> OGqual[]; (* is none for PersonLib !? *)
               cd.com(#
                     do 'DI:isConst:' -> TT; isConst -> BB;
                        ':isBasicValue:'->TT; OG.isBasicValue->BB;
                        ':primNo:'->TT; OG.primNo -> II;
                     #);
               cd.com(#
                     do 'OGqual:'-> TT; 
                        (if OGqual[] <> none then
                            (if OGqual.sig[] <> none then 
                                OGqual.sig.doPT -> TQ
                             else 'none'->TT if);
                            ':OGqual.isBasicValue:' -> TT; 
                            OGqual.isBasicValue -> BB;
                            ':OGqual.isValueObj:' -> TT; 
                            OGqual.isValueObj -> BB;
                         else
                            'none' -> TT
                        if)
                     #);
               (if isVirtualObject then
                   (*  '\***DataItem:qGen:virtual object: ' -> puttext;
                    dopt ->putline;*)
               if);
               (if true 
                // OG.isBasicPattern and not OG.isConstLiteral then
                   (* No OG.qGen for X: var/val integer
                    * Cf the discussion of #foo versus foo  *)
                   cd.com(#do 'DI:add:BP1: ' -> TT; sig.dopt -> TT #);
                // OG.isBasicValue then
                   (* C1,C2,V1,V2                
                    * X: val integer(7)
                    * X: var 7
                    * X: val a + b
                    *)
                   (if OG.isValueObj then 
                       (* OG is a ValueObject returning a Basic value 
                        * like integer
                        *    mkIntB: ... out V: var integer ...
                        * We shall thus not allocate a value obj, 
                        * but a plain integer
                        * the invocation of mkIntB shall be boxed
                        *)
                       (*'DataItem:ValueObj:'->putline; dopt -> putline; *)
                       (* If OG is valueObj then
                        * newOff = 0 does not work
                        *)
                       cd.com(#do 'DI:add:BP2: ' -> TT; sig.dopt -> TT #);
                       (true,0,0) -> OG.Qgen 
                    else (* when is newOff needed here? *)
                       cd.com(#do 'DI:add:BP3: ' -> TT; sig.dopt -> TT #);
                       (true,0,this(DataItem).NewOff) -> OG.Qgen;
                   if);
                   cd.com(#
                         do 'dataItem:store:basicValue:' -> TT;
                            'off:' -> TT; off -> II;
                            ' NewOff:' -> TT; NewOff -> II
                         #);
                   cd.pushThis;
                   (if OG.isFloat then
                       (sig.id[],this(DataItem).NewOff) -> cd.fstoreg
                    else
                       origin[] -> org[];
                       (if true then
                           (org.encOG.OGidWdNo,this(DataItem).NewOff) -> cd.storeg
                        else
                           (sig.id[],this(DataItem).NewOff) -> cd.storeg
                       if)
                   if)
                // (OG.primNo = String_prim) and isConst then
                   (* Like S: obj "hello"
                    * Old comment:
                    * Could be  V: obj elm where elm:< Object 
                    * but is this true ?
                    *)
                   cd.com(#do 'DI:add:BP3: ' -> TT; sig.dopt -> TT #);
                   (true,0,this(DataItem).NewOff) -> OG.Qgen;
                   cd.pushThis;
                   (if true then
                       origin[] -> org[];
                       (org.encOG.OGidWdNo,this(DataItem).NewOff) -> cd.rstoreg
                    else
                       (sig.id[],this(DataItem).NewOff) -> cd.rstoreg
                   if);
                // isConst or not OG.IS.isEmpty or isValue then
                   cd.com(#do 'DI:add:BP4: ' -> TT; sig.dopt -> TT #);
                   (* C3,C4,V4 *)
                   (* All objects/patterns being embedded must be handled by
                    * Alloc and gen since we must know the size *)
                   (* X: = Foo or 
                    * Singular T: = P{...} 
                    * C3,C4,V4 *)
                   cd.bcPos -> beginBCP;
                   (if isInArg then (* also outArg? *)
                       cd.com(#do 'inArg:' -> TT; doPT -> TT #);
                    else
                       (false,0,this(DataItem).NewOff) -> OG.Qgen;
                   if);
                   cd.bcPos -> endBCP;
                   (* else V3 - just a qualifcation; 
                    * see also the discussion of #foo versus foo *)
                   (* Could be S: ?elm where elm:< Object -- no code gen *)
               if)
            #);
          pushThis:: (# do cd.pushThis #);
          loadArgs::
            (#
            do cd.com(#do 'DataItem:loadArgs: ' -> TT; dopt -> TQ;
                     ' E: ' -> TT; E.doPT -> TQ  #);
               cd.com(#do E.args.dopt -> TT #);
               L:
               (if OG.IS.isEmpty then
                   (E[],superAdj,staticOff,CC[]) -> OG.super.ATd.loadargs;
                   E.args.scanArgs(#do true -> isResume #)
                else
                   (* primitive check for args being non empty! *)
                   E.args.scanArgs
                   (#do '\n!!!! DataItem:loadArgs:IS not empty! '->putline#)
               if)
            #);
          getAdr::
            (# gdb::
                 (#
                 do ',newOff:'->TT; newOff -> II; 
                    ',isValue:'->TT; isValue-> BB;
                    ',A.isValue:' -> TT; A.isValue -> BB
                 #);
               E: ^Exp; originIsValue: @boolean; ptn: ^Pattern; 
               UN,UNx: ^NewProperty;
               OGx: ^ObjectGenerator
            do cd.com(#do ' A:'->TT; A.print -> TT; ' '->TT; dopt->TT #);
               cd.com(#do 'value_prim:'->TT;OG.primNo = value_prim->BB #);

               (* OG.primNo = value_prim for handling _v: ?Value 
                * in integer, char and boolean *)
               
               (if OG.isBasicValue or isValue 
                   or (OG.primNo = value_prim) then
                   (if not A.isValue then
                       true ->  loadRec;
                       A.E[] -> E[]; A.originIsValue -> originIsValue;
                       0 -> Address -> A[]; 
                       E[] -> A.E[]; originIsValue -> A.originIsValue;
                       newOff -> A.off;
                       OG.isBasicValue 
                       or OG.isValueObj or (OG.primNo = value_prim)
                         -> A.isValue;
                       cd.com(#do 'BÅTX:'->TT; 
                                OG.super.ATD.OG.IS.newDescNo -> II;
                                ' OG.OGid: ' -> TT; 
                                OG.super.ATD.OG.OGid -> TT #);
                    else
                       (if A.off > 0 then
                           newOff - 1 + A.off -> A.off;
                        else
                           newOff -> A.off
                       if);
                       OG.isBasicValue 
                       or OG.isValueObj 
                       or (OG.primNo = value_prim)
                         -> A.isValue;
                       cd.com(#do 'BÅTY:'->TT #);
                   if);
                   (if A.isValue then   
                       OG.super.ATd.OG.IS.newDescNo -> A.valDescNo 
                   if);
                   cd.com(#do OG.dopt -> TT #);
                   (if ((OG.super.ATd[]->ptn[]) <> none)
                       and ptn.OG.IS.isEmpty then
                       (* MUST be FIXED: introduce getNewBasicProp*)
                       ptn.OG.super.ATd.OG.IS.newBasicProp.UNIT[] -> UN[];
                    else
                       ptn.OG.IS.newBasicProp.UNIT[] -> UN[];
                   if);
                   cd.com(# UN: ^NewProperty; ptn: ^Pattern
                         do 'before:floatTest: ' -> TT;
                            dopt -> TQ;
                            OG.label -> TT;
                            (if ptn[] <> none then
                                ptn.sig.dopt -> TT; 
                                (if ptn.OG.IS.isEmpty then
                                    ' IS.empty:'->TT
                                 else
                                    ' NOT IS.empty:'->TT
                                if);
                                (if UN[] <> none then UN.dopt -> TT; if)
                         if)#);
                   cd.com(#do A.print->TT #);
                   UN[] <> none -> A.isUnitVal;
                   cd.com(#do 'After:U*U:'->TT; A.print->TT #);
                   (if (OG.primNo = float_prim) or OG.isFloat then
                       cd.com(#
                             do 'getAdr:isfloat:A: ' -> TT; dopt -> TT;
                                ' A.isValue:'->TT; A.isValue -> BB
                             #);
                       true -> A.isFloat
                   if);
                else                   
                   true -> loadRec;
                   0 -> Address -> A[];
                   newOff -> A.off
               if)
            #);
          invoke::
            (* called when not receiver - i.e. value to be pushed *)
            (# gdb::(#do ' newOff:'-> TT; newOff -> II #);
               orgIsVal: @integer;
               org: ^Items;
               isResumeX: BooleanValue
                 (#
                 do (if E[] = none then 
                        (*'!!!! isResume: ' -> puttext; dopt -> putline;*)
                     else
                        L: E.args.scanArgs(#do true -> value; leave L #)
                    if)
                 #);
               vn,rn: @integer
            do (if isResume then
                   cd.com
                   (#do 'dataItem:invoke:hasArgs:DI: ' -> TT; dopt ->TQ; nl;
                      ' rec: '->TT;
                      (if rec[] <> none then rec.dopt ->TQ;
                          ' arg: ' -> TT; rec.args.dopt -> TQ if);
                      ' E: ' -> TT; E.dopt -> TQ;
                      ' lab: ' -> TT; E.label -> TQ;
                   #);
                   OG.IS.scanItemArgs -> (vn,rn);
                   (if false then
                       '**** isResume: ' -> puttext; dopt -> puttext;
                       ' ' -> put; vn -> putint; ' ' -> put; rn -> putint; 
                       '\n  rec: ' -> puttext; 
                       (if rec[] <> none then rec.dopt -> puttext;if);
                       ' E: ' -> puttext; E.dopt -> putline;
                   if);
                   (* Part of the adr of this(DI) is on the rstack  - thisObj
                    * and possible arguments are alos on thje stack
                    * we need to get the partial adr of this(DI) on the top
                    * to be able to execute adr.loadAdr
                    *)
                   (if rn > 0 then rn -> cd.rswap; if);
                   adr.loadAdr;
                   ('ResumeDI','D') -> cd.call;
                   cd.rpop;
                   leave invoke
               if);
               (if OG.isBasicValue or OG.isValueObj then 
                   (if (E[] <> none) then
                       (if (E.ATd.primNo <> cmpAndSwap_prim) then
                           (* May happen for V := 117 where := is assignment
                            * - no offset shall be pushed for V 
                            * since V is assigned afterwards
                            * For R ++ 117 offset for R should be pushed 
                            * since it is origin
                            *) 
                           (if true
                            // OG.isBasicValue 
                            // OG.primNo = value_prim then 
                               (* OG.primNo = value_prim for handling 
                                * _v: ?Value 
                                * in integer, char and boolean *)
                               adr.load
                            // OG.isValueObj then 
                               cd.com(#do '>LoadValue:isAdr:' -> TT;
                                        adr.isAdr -> BB; 
                                     #);
                               cd.com(#do 'Size:'->TT; objSize -> II;
                                        ',rec:'->TT; rec.dopt->TQ;',E:'->TT;
                                        E.dopt -> TQ; E.label -> TQ
                                     #);
                               cd.com(#do 'E.isCompositeValueObj: ' -> TT; 
                                        E.isCompositeValueObj -> BB #);
                               true -> adr.isAdr;
                               E.isCompositeValueObj 
                                 -> adr.isCompositeValueObj;
                               adr.load; 
                           if)
                        else
                           cd.com(#do 'invoke:cmpAndSwap:'->TT; off->II; 
                                    adr.print -> TT #);
                           adr.loadAdr;
                       if)
                    else
                       cd.com(#do '>:E=none' -> TT#);
                       (if adr[] <> none then 
                           adr.load
                        else
                           (if (OG.primNo = float_Prim) 
                               or OG.isUnitValueObj then
                               (sig.id[],NewOff) -> cd.fpushg
                            else
                               'push:A:' -> cd.comment;
                               origin[] -> org[];
                               (org.encOG.OGidwDno,NewOff) -> cd.pushg
                           if)
                       if)
                   if)
                else
                   cd.com(#do '>Object:unique:'->TT; OG.IS.isUnique->BB#);
                   (if adr[] <> none then 
                       adr.load
                    else
                       cd.com(# do '>adr=none'->TT #);
                       (if true then
                           (if org[] = none then
                               ('orgIsNone',NewOff) -> cd.rpushg
                            else
                               (org.encOG.OGidWdNo,NewOff) -> cd.rpushg
                           if)
                        else
                           (sig.id[],NewOff) -> cd.rpushg
               if)if)if)
            #);
          store::
            (* Called from Signature::StoreParameters *)
            (# gdb::(#do ',newOff:'->TT; newOff -> II;
                       ',isVirtualObject:' -> TT; isVirtualObject -> BB #);
               
               OGx: ^ObjectGenerator; var: ^Variant; 
            do (if true
                // OG.isBasicValue // OG.primNo = value_prim then 
                // OG.isValueObj then 
                   cd.com(# do '>StoreValue: ' -> TT;OG.dopt -> TQ#);
               if);

               (if true
                // OG.isBasicValue // OG.primNo = value_prim (*// OG.isUnitValueObj*) then 
                   (* OG.primNo = value_prim for handling _v: ?Value 
                    * in integer, char and boolean *)
                   cd.pushThis;
                   (if (OG.primno = float_prim) or OG.isUnitValueObj then
                       (sig.id[],NewOff) -> cd.fstoreg
                    else
                       (if true then
                           (OG.OGidWdNo,NewOff) -> cd.storeg
                        else
                           (sig.id[],NewOff) -> cd.storeg
                       if)
                   if)
                // OG.isValueObj then
                   (* is the order of src and dest objs on the stack correct? *)
                   (if true then
                       (# L1, L2: @labelHandler.label
                       do L1.new; L2. new;
                          (0,L1) -> cd.jmpFalse;
                          cd.pushThis;
                          newOff -> cd.pushConst;
                          (OG.objSize,0) -> cd.vassign;
                          L2 -> cd.jmp;
                          L1 -> cd.defLab;            
                          (if true then
                              (sig.id[],(OG.superPtn).new_DescNo,newOff - 1) 
                                -> cd.invokeVal;
                           else
                              (sig.id[],(OG.superPtn).OG.IS.newDescNo,newOff - 1) 
                                -> cd.invokeVal;
                          if);
                          L2 -> cd.defLab
                       #)
                    else
                       cd.pushThis;
                       (false,0,0) -> Qgen; 
                       newOff -> cd.pushConst;
                       (OG.objSize,0) -> cd.vassign;
                   if)
                else
                   cd.pushThis;
                   (if not noSwap then cd.rswap if); 
                   (* Could be S: ?elm where elm:< Object *)                   
                   (sig.id[],NewOff) -> cd.rstoreg
               if)
            #);
          popReturn::
            (#
            do (if OG.isBasicValue then 
                   cd.vpop
                else
                   (* could be S: ref elm where elm:< object*)
                   cd.rpop
               if)
            #)          
       #);
     Signature:: 
       (# markForCodegen::
            (#
            do (if encOG[] <> none then
                   (*'**** Signature:markForCodgen: ' -> puttext; 
                    dopt -> putline;*)
                   scanSons(#do current.markForCodeGen #);
               if)
            #);
          Qgen::
            (#
            do
            #)
       #);
     Arguments:: (##);
     ObjectCall::
       (# markForCodeGen::
            (# ptn: ^Pattern
            do (if not marked and ((primNo,sig[],IS[]) -> markPrimElse) then
                   true -> marked;
                   (if (super.last).ATd.isPattern then
                       (super.last).ATd[] -> ptn[];
                       (if ptn[] <> objectDecl[] then
                           cd.com(#do 'ObjCall:markSuper:'->TT; super.dopt->TQ #);
                           super.markForCodeGen; 
               if)if)if)
            #);
          classDef::
            (#
            do '**** ObjectCall:classDef: ' -> puttext; OGid-> puttext;
               ' ' -> put;
               IS.newDescno -> putint; newline;
            #);
          qGen::
            (#
            do cd.com(#do dopt -> TQ; ' OC:isCompositeValueObj: ' -> TT;
                        isCompositeValueObj -> BB #);
               (if ((super.last).ATd[] <> none) and not (super.last).ATd.isPattern then
                   (* does no completely undersatand what goes on here
                    * For INV = L2, we have to assign 
                    * For inv := L1 * L2, we cannot!
                    *)
                   isCompositeValueObj -> (super.last).isCompositeValueObj;
               if);
               (useReturnValue,superAdj,staticOff) -> super.Qgen
            #);
       #);
     markPrimElse: BooleanValue
       (# primNo: @integer; sig: ^Signature; IS: ^Items
       enter(primNo,sig[],IS[])
       <<SLOT doMarkPrim:doPart>> 
       #);
     transInArgs:
       (# theOG: ^ObjectGenerator; staticOff: @integer; T: ^text
       enter(theOG[],staticOff)
       do theOG.OGidWdNo -> T[]; 
          theOG.IS.scanItemArgsReverse
          (# DI: ^DataItem
          do cd.lcom(#do 'store arg: ' -> TT;
                       currentarg.dopt -> TT #);
             (if (currentArg[]->DI[]).isBasicValue then
                 (T[],DI.newOff) -> cd.storeX
              else
                 (T[],DI.newOff,false) -> cd.rstoreX
             if)
          #);
       #);
     goOriginAdr:
       (# super: ^Invocation; ptn: ^Pattern; rec,E,pRec: ^Exp; 
          A,recA: ^Address;
          loadRec,orgIsVal: @Boolean; BE: ^ BracketedExp; 
       enter super[]
       do cd.lcom(#do 'goOriginAdr: ' -> TT #);
          (if super.isImplSuper then
              cd.lcom(#do 'goOriginAdr:A: ' -> TT #);
              (if super.isSingularImplSuper then
                  (* skip - we have origin on the stack *)
               else
                  super.ATd[] -> ptn[];
                  (* TODO *)
              if)
           else
              cd.lcom(#do 'goOriginAdr:B: ' -> TT #);
              Address -> A[];
              super.scanSons
              (#
              do rec[] -> pRec[]; E[] -> rec[];
                 current[] -> E[];
                 cd.lcom(#do 'goOriginAdr:Bx:label: '->TT; E.label->TT #);
                 (if isFirst then
                     cd.lcom(#do 'goOriginAdr:B:E: '->TT; E.dopt -> TT #);
                     (if ('BracketedExp' -> (E.label).equalNCS) then
                         '\n!!! bracketedExp: ' -> puttext; 
                         E.dopt  -> putline;
                         (E[] -> BE[]).IV.scansons
                         (#
                         do 
                            current[]  ->  E[];
                            (if isFirst then
                                (0,none)
                                  ->E.loadOrigin->(rec[],E[],orgIsval);
                                A[] -> E.getAdr -> (loadRec,A[]);
                             else
                                A[] -> recA[] 
                                  -> E.getAdr -> (loadRec,A[]);
                                (if loadRec then
                                    cd.lcom(#do 'goOriginAdr:D:rec:'
                                                ->TT;
                                              rec.dopt -> TT #);
                                    (0,0,none) -> rec.loadArgs;
                                       (pRec[],E[],true,0,none
                                    ,recA[],false)
                                      -> rec.invoke;
                            if)if)
                         #)
                      else
                         (0,none) -> E.loadOrigin -> (rec[],E[],orgIsVal);
                         cd.lcom(#do 'goOriginAdr:B1: '->TT;E.label->TT#);
                         A[] -> E.getAdr -> (loadRec,A[]);
                     if);
                     cd.lcom(#do 'goOriginAdr:B2: ' -> TT #);
                     (* shall we check for originISValue? See computeAdr*)
                  else
                     cd.lcom(#do 'goOriginAdr:C: ' -> TT; E.dopt -> TT #);
                     A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                     (if loadRec then
                         cd.lcom(#do 'goOriginAdr:D:rec: ' -> TT; 
                                   rec.dopt -> TT #);
                         (0,0,none) -> rec.loadArgs;
                         (pRec[],E[],true,0,none,recA[],false)
                           -> rec.invoke;
                         cd.lcom(#do 'goOriginAdr:E: ' -> TT; #);
                     if)
                 if)
              #)             
          if)   
       exit E[]
       #);
     storeOrigins:
       (* Store origins defined for the main OG and super patterns:
        * P1: {...}, P2: P1{...}, P3: P2{...}, OG = P3{...}
        * mainOG = OG = P3{...}
        * thisOG = one of P3, P2, P1
        * We may skip store of origin for OGs with same originOff
        *)
       (# mainOG,thisOG,OGx: ^ObjectGenerator; ISx: ^items; 
          rec,E: ^Exp; A: ^Address;
          trace: (# exit false #);
          fArgs: [10] ^DataItem; top: @integer; DI: ^DataItem
       enter(mainOG[],thisOG[])
       do (if trace then
              '**** storeOrigins: ' -> puttext; thisOG.OGid -> puttext;
              ' originOff: ' -> puttext; thisOG.IS.newOriginOff -> putint;
          if);
          cd.lcom(#do 'storeOrigins:main: ' -> TT; mainOG.OGidWdNo->TT;
                    ' this: ' -> TT; thisOG.OGidWdNo -> TT;
                    ' originOff: ' -> TT; thisOG.IS.newOriginOff -> II
                 #);

          (if thisOG.IS.newOriginOff > 0 then
              (if thisOG.super.ATd[] <> none then
                  cd.lcom(# do 'rdup src' -> TT #);
                  (if true then -1 -> cd.rdouble if)
              if);
              (* rstack = [..., obj,callee], store obj in callee.origin *)
              (mainOG.OGidWdNo,thisOG.IS.newOriginOff
              ,thisOG.origin[] -> thisOG.IS.originisValue
              ) 
                -> cd.rstoreX;
              (* rstack = [..., callee]; ... *)
           else
              cd.lcom(#do 'no origin:newOriginOff=0' -> TT #)
          if);
          (if thisOG.super.ATd[] <> none then
              (if trace then
                  ' on: ' -> puttext; thisOG.super.on -> putint; newline;
                  thisOG.IS[] -> ISx[];
                  (for i: thisOG.super.on repeat 
                       ISx.origin[] -> ISx[];
                       '**   origin: ' -> puttext; 
                       (ISx.encOG->OGx[]).OGid -> putline
              for)if);
              cd.lcom(#do 'Before:computeAdr: ' -> TT; thisOG.OGid ->TT#);
              cd.stack.put;
              cd.rswap;
              thisOG.super[] -> goOriginAdr -> E[];
              cd.stack.put;
              (if E[] <> none then 
                  cd.lcom(#do 'before:E.loadArgs:' -> TT; E.dopt -> TT #);
                  (0,0,none) -> E.loadArgs;
                  (if (E.args[] <> none) and (E.args.noOfSons > 0) then
                      E.Atd.OG.IS.scanNonBoundItemArgs
                      (#
                      do (if currentArg.isDataItem then
                             cd.lcom(#do currentArg.dopt -> TT #);
                             currentArg[] -> fArgs[top + 1 -> top][]
                         if)
                      #);
                      (for i: top repeat
                           fArgs[top - i + 1][] -> DI[];
                           cd.rswap;
                           cd.rdouble;
                           (if DI.isBasicValue then
                               (mainOG.OGidWdNo,DI.newOff) -> cd.storeg
                            else
                               (mainOG.OGidWdNo,DI.newOff) -> cd.rstoreg
                           if);
                           cd.rswap
                  for)if)
               else
                 (* '**** E is none:main:\n' -> Puttext; 
                  main.dopt -> puthead;
                  ' this: ' -> puttext; thisOg.doPT -> putline*)
              if);

              cd.lcom(#do cd.stack.print -> TT #);
              cd.lcom(#do thisOG.super.ATd.OG.OGid -> TT; ' ' -> TT;
                        thisOG.super.ATd.OG.IS.newOriginOff -> II #);
              cd.rswap;
              (mainOG[],thisOG.super.ATd.OG[]) -> storeOrigins;
           else
              (if trace then newline if)
          if);
       #);
     storeArgs:
       (# T: ^text; theOG: ^ objectGenerator
       enter (T[],theOG[])
       do (if theOG.super.ATd[] <> none then
              (T[],theOG.super.ATd.OG[]) -> storeArgs
          if);
          theOG.IS.scanItemArgsReverse
          (# DI: ^DataItem
          do cd.lcom(#do 'store arg: ' -> TT;
                       currentarg.dopt -> TT #);
             (if (currentArg[]->DI[]).isBasicValue then
                 (T[],DI.newOff) -> cd.storeX
              else
                 (T[],DI.newOff,false) -> cd.rstoreX
             if)
          #)              
       #);
     callInvoke:
       (# theOG: ^ObjectGenerator; staticOff: @integer; fromStub: @boolean;
          T: ^text
       enter(theOG[],staticOff,fromStub)
       do cd.lcom(#do 'OGid:'->TT; theOG.OGid -> TT;
                    ' OGidWdNo: '-> TT; theOG.OGidWdNo -> TT;
                 #);
          (theOG.OGid,theOG.IS.newDescNo,theOG.IS.objSize,staticOff,true)
            -> cd.invoke
          (# topSuperId::
               (# superDesc: ^Items
               do (theOG.IS.topSuper->superDesc[]).encOG.OGidWdNo -> superId[];
                  superDesc.newDescNo -> superDescNo
               #);
             fArgs: [10] ^DataItem;  top: @integer; DI: ^DataItem
          do (* vStack = [..., possible V-args
              * rStack = [..., possible origin, possible R-args, callee
              *)
             theOG.OGidWdNo -> T[]; 
             (*'$' -> T.put; IS.newDescNo -> T.putint;*)
             (if false then
                 (T[],theOG[]) -> storeArgs
              else
                 (if true then
                     cd.lcom(#do 'store:args'->TT #);
                     theOG.IS.scanNonBoundItemArgs
                     (# 
                     do currentArg[] -> fArgs[top + 1 -> top][];
                        cd.lcom(#do 'arg:' -> TT; currentArg.dopt -> TT #)
                     #);
                     (for i:top repeat
                          fArgs[top - i +  1][] -> DI[];   
                          (if DI.isBasicValue then
                              (T[],DI.newOff) -> cd.storeX
                           else
                            (T[],DI.newOff,false) -> cd.rstoreX
                          if)
                     for)
                  else
                     (*theOG.IS.scanItemArgsReverse*)
                     theOG.IS.scanNonBoundItemArgs
                     (# DI: ^DataItem
                     do cd.lcom(#do 'store arg: "' -> TT;
                                  currentarg.dopt -> TT #);
                        (if (currentArg[]->DI[]).isBasicValue then
                            (T[],DI.newOff) -> cd.storeX
                         else
                            (T[],DI.newOff,false) -> cd.rstoreX
                        if)
                     #)
                 if)
             if);
             (* vStack = [...]
              * rStack = [..., possible origin, callee]
              *)
             (if false then
                 '\n**** invoke:stub ' -> puttext; T[] -> putline;
                 '** stack: ' -> puttext; cd.stack.print -> putline;
             if);
             (if not newFeature then
                 (theOG[],theOG[]) -> storeOrigins;
             if);
             cd.lcom(#do 'topSuper:' -> TT; 
                       (theOG.IS.topSuper).newDescNo -> II; ' '->TT;
                       (theOG.IS.topSuper).encOG.OGidWdNo -> TT
                    #)
          #);
          (if not fromStub then
              (theOG[],T[]) -> pushOut
          if)
       #);
     ObjectGenerator::
       (# isArgOfE: ^Exp;
          markForCodeGen:: 
            (# ptn: ^Pattern
            do (if not marked and ((primNo,sig[],IS[]) -> markPrimElse) 
                   then
                   (* Ex[] -> checkVirtualSuper;*)
                   (if (Ex[] -> isArgOfE[]) <> none then
                       (* enter Ex[] 
                        * Called from Invocation E1.E2.E3(f1,f2,f3)
                        * if one of f1,f2 and f3 is a (singular) OG and
                        * the formal arg is not a virtual.
                        * Then Ex[] = E3[]
                        * We should probably also handle possible 
                        * arguments of  E1 and E2.
                        * E3.origin is not this(OG) which omplies 
                        * that on does not count this(OG), but it must.
                        * We this have to add an extra goorigin for 
                        * attributes in Ex!
                        *)
                       (if traceArgOG then
                           '**** OG is an argument:\n' -> puttext; 
                           dopt -> puthead;
                           father.father.father.dopt -> puthead
                       if)
                   if);
                   (if false then
                       '**** markForCodegen: ' -> puttext; OGid -> puttext;
                       newline;
                   if);
                   true -> marked;
                   (if super[] = none then
                       '*** super is none: ' -> puttext;
                       dopt -> putline
                   if);
                   cd.com(#do 'OG:markForCodeGen:'-> TT; dopt -> TQ;nl;
                            'isObjectDesc:'->TT; isObjectDesc -> BB;
                            ' isObjectDescX:'->TT; isObjectDescX -> BB;
                            ' hasItems:'->TT; hasItems->BB; nl;
                            ' super.hasVirtualArgs:'->TT;
                            super.hasVirtualArgs -> BB;nl;
                            ' super.isPrimitive:'->TT;
                            super.isPrimitive->BB; nl;
                            ' (super.last).isPrimitive:'->TT; 
                            (if super.last <> none then
                                (super.last).isPrimitive->BB;
                             else
                                'none'-> TT
                            if);
                            nl;
                            super.dopt -> TQ;nl;
                            super.scanSons
                            (# E:^exp
                            do (current[]->E[]).dopt->TQ;
                               E.isPrimitive->BB; nl
                            #)
                         #);
                   (if not super.isEmpty then
                       (if (super.last).ATd[] = none then
                           '!!!! super.last.ATd is none: ' -> putline;
                           label -> putline; '--' -> putline;
                           dopt -> putline; 
                       if);
                       (if not (super.last).ATd.isPattern then
                           leave markForCodeGen
                       if);
                       (super.last).ATd[] -> ptn[];
                       (if ptn[] <> objectDecl[] then
                           cd.com
                           (#do 'OG:markSuper:'->TT ; super.dopt ->TQ #);
                           super.markForCodeGen; 
                   if)if);
                   (* For isObjectDesc, in:
                    * OG = S.exists({...}) && S.forAll({...}){}
                    * OG.super = INV = (S exists(...) && (S.forAll(...))
                    * exists has virtualArgs, and not isPrimitove.
                    * But && isPrimitive and thus isObjectDesc = false
                    * We thus try a revised version - see qchecker
                    *)
                   (if isObjectDesc then
                       cd.com(#do 'OG:markIS:'->TT; doPT -> TQ #);

                       (this(ObjectGenerator)[],NONE,computeVariant)
                         -> objTmpStack.add;
                       IS.markForCodeGen;
                    else
                       (* May happen for V:< Object, ... *)
                       cd.com
                       (#do 'not ObjDesc: '->TT; doPt -> TQ; 
                          ' IS.isEmpty: '->TT; IS.isEmpty -> BB; 
                       #);
               if)if)
            #);
          classDef::
            (# org:^Items; orgId: ^text; orgDescNo: @integer
            do (if marked then
                   (if false then
                       '**** OG:classDef: ' -> puttext;  OGid -> puttext;
                       ' '->put; Is.isEmpty -> putBoolean; ' ' -> put;
                       hasVirtualArgs -> putboolean;  ' '->put;
                       Is.newDescNo -> putint; newline;
                   if);
                   (if (not IS.isEmpty or hasVirtualArgs)
                       and (IS.newDescNo > 0) then
                       (if (origin[] -> org[]) <> none then
                           org.encOG.OGid -> orgID[];
                           org.newDescNo -> orgDescNo;
                           (if false and (org.encOG.primNo = string_prim) then
                               '**** String origin: ' -> puttext;
                               orgID[] -> putline;
                               'array' -> orgID[];
                               1 -> orgDescNo
                           if);
                           (if IS.newOriginOff = 0 then
                               none -> orgID[];
                               0 -> orgDescNo
                           if)
                        else
                           'Object' -> orgId[];
                           objectDecl.OG.OGid ->orgId[];
                           objectDecl.OG.IS.newDescNo -> orgDescNo;
                       if);                           
                       (OGid,IS.newDescNo,isValueObj,orgID[],orgDescNo)
                         -> cd.classDef
                       (#
                       do mkLLVMstruc
                          (# addRX:: (#do (off,OGid[]) -> addR #);
                             addVX:: (#do off -> addV #);
                             addAX:: (#do off -> addA #);
                          #)
                   #)if)
               if)
            #);
          computeVariant::
            (* OG.Qgen is called for a singular object
             * We thus only have one variant
             * This variant will propagate to superpatterns
             *)
            (# VarType:: Variant;
               V: ^Variant
            do (*'----computeVariant:'->putline; dopt -> putline; *)
               (if contextOG[] = none then 
                   this(ObjectGenerator)[] -> contextOG[] if);
               cd.com(#do 'ComputeVariant:A:' -> TT; OGid -> TQ #);
               cd.com(#do dopt -> TT #);
               Qvariants.new -> var[];                 
               
               (* this(OG) is not sufficient 
                * For 
                *    Lrecord.insert(Record(...))
                * we need Lrecord.OG
                *)
               (contextOG[],var[]) -> Qvariants.scanObjectRefs;
               (* We have a Variant of OG; 
                * if var.top = 0, there are no data-items depending on 
                * virtual Object (Later to be replaced by Any)
                *
                * Check that var[] does not already existt
                * var returned below may differ from var above *)
               Qvariants.checkIfTopIsNew -> V[];
               (if var[] = V[] then
                   cd.com(#do 'var is new:'->TT; 'top: '->TT; 
                            Qvariants.top->II;
                            'var.thisVarNo:'-> TT; var.thisVarNo -> II #);
                   
                   (var.thisVarNo,none) -> Qalloc;
                   
                   cd.com(#do 'computeVariant:newDescNo:'->TT; 
                            IS.newDescNo->II;
                            ' size: '-> TT; objSize -> II;
                            ' IS:'->TT; IS.doPT -> TQ #);
                else
                   cd.com(#do'var is not new:'->TT #);
                   V[] -> var[]
               if);
               (*Qvariants.print;*)
               cd.com(#do 'ComputeVariant:B: ' -> TT; OGid -> TQ #);
            #);
          Qgen::
            (* Qgen is only called for singular Objects and pushed on stack
             * For patterns OG is pushed on stack and genClass called later
             *)
            (# gdb:: 
                 (#
                 do 'OGid:' -> TT; OGid -> TQ;
                    (if IS.isEmpty then 
                        ' IS.isempty!' -> TT 
                     else
                        ' singular!' -> TT
                    if);
                    ' staticOff='-> TT; staticOff -> II;
                    ' descNo=' -> TT; IS.newDescno->II;
                    ' superAdj=' -> TT; superAdj -> II
                 #);
               printQoff:
                 (#
                 do (if trace then
                        IS.scanSons
                        (# I: ^Item; D: ^Decl
                        do  current[] -> I[];
                           (if I.isDecl then 
                               I[] -> D[];
                               D.qoff[1] -> putint; ' ' -> put; 
                               D.doPT -> putline
                    if)#)if)
                 #);
               name: ^text; head: @boolean;
               on,pn: @integer;
               E: ^Exp; OI: ^ObjectInvocation;
               var: ^Variant;
               trace: (# exit false #);
            do (if not genIsDone then
                   (if primNo = inner_prim then
                       (*'TRYING code gen for inner'->putline*)
                   if);
                   (* Check if code has been generated for this variant *)
                   true -> genIsDone;
                   super.last -> E[];                            
                   (if (E[] <> none) and (E## = objectInvocation##) then 
                       (if ((E[] ->  OI[]).ATD## = pattern##) then
                           cd.com
                           (# ptn: ^Pattern; 
                           do (E[] ->  OI[]).ATD[] -> ptn[];
                              'OG:gen:super:'->TT; ptn.sig.dopt -> TQ;
                              'superDescNo:' -> TT; ptn.OG.IS.newDescNo->II;
                              'super.OG.top:' -> 
                              TT; ptn.OG.Qvariants.top-> II;
                   #)if)if);
                   (* we have non-singular: foo or singular: foo{...} *)
                   (*computeVariant -> var[]; *)
                   
                   cd.bcPos -> beginBCP;
                   (if CC[] <> none then (* not used? *)
                       this(ObjectGenerator)[] -> CC.add -> CC[];
                   if);
                   (if hasVariants then
                       (*'\nOG.hasVariants:\n' -> puttext; dopt ->printhead;
                        Qvariants.print*)
                   if);
                   (if IS.isEmpty 
                       and not super.hasVirtualArgs 
                       or (super.isPrimitive and IS.isEmpty) then
                       (* Implies that super.OG is pushed on objTmpStack
                        * So should we pass the variant of this OG to Qgen?
                        *)
                       cd.com(#do 'OG:Qgen:IS.isEmpty!isCompositeValueObj:'
                                  -> TT;
                                isCompositeValueObj -> BB;
                                'superAdj: ' -> TT; superAdj -> II #);
                       (if ((super.last).ATd[] <> none) 
                           and not (super.last).ATd.isPattern then
                           (* does not completely understand 
                            * what goes on here
                            * For INV = L2, we have to assign 
                            * For inv := L1 * L2, we cannot!
                            *)
                           isCompositeValueObj 
                             -> (super.last).isCompositeValueObj;
                       if);
                       (useReturnValue,superAdj,staticOff) -> super.Qgen
                    else
                       (* Perhaps move check for virtuals to here!? *)
                       (* Singular object like R.foo{ }
                        * includes pattern invocations with 
                        * virtual arguments like %if .. %then% ... %else ...
                        *)
                       cd.com(#do 'OG:Qgen:IS is not empty:'->TT; #);
                       (if IS.globalRestrictionsInMain then
                           cd.com(#do 'globalRestrictionsInMain' -> TT #)
                        else                           
                           cd.pushThis; (* origin for a singular object *)
                           (* This is also the case for R.S.foo{ ... } *)
                       if);
                       (* Perhaps all patterns with more than one variant
                        * should be considered singular?
                        *)
                       (* Invoke the singular object *)
                       cd.com(#do 'before objTmpStack:add: '->TT;
                                IS.newDescNo -> II; ' ' -> TT; OGid ->TQ #);
                       (this(ObjectGenerator)[],staticOff,false) 
                         -> callInvoke;
                       L:
                         (if not useReturnValue then 
                             IS.scanAllItemDecls
                             (# DI: ^DataItem
                             do (if currentDcl.isOutArg then
                                    currentDcl[] -> DI[]; 
                                    DI.popReturn;
                                    leave L
                             if)#);
                             cd.rPop 
                         if)
                   if);
                   cd.bcPos -> endBCP;     
               if)
            #);
          pushReturnValues:
            (# ptn: ^Pattern; DI: ^DataItem
            do (if ((father[]->ptn[]).getReturnDecl -> DI[]) <> none then
                   (if false then
                       '**** pushReturnValues:Off:' -> puttext;
                       DI.newOff -> putint;
                       ' '  -> put; DI.doPT -> putline;
                   if);
                   (if not isValueObj then
                       cd.setThisStack
                   if);                   
                   (if DI.OG.isValueObj 
                       and not (DI.OG.primNo = integer_prim) 
                       and not (DI.OG.primNo = boolean_prim) 
                       and not (DI.OG.primNo = char_prim) 
                       and not (DI.OG.primNo = float_prim) 
                      (* and not DI.OG.isUnitValueObj*)
                       then
                       cd.pushThis;
                       DI.newOff -> cd.pushConst;
                       DI.OG.IS.newDescNo -> cd.pushConst
                    else
                       cd.pushThis;
                       DI.invoke
                   if)
                else 
                   (if isValueObj then
                    else
                       cd.setThisStack;
                       cd.pushThis
                   if)
               if)
            #);    
          pushRtnV:
            (# DI: ^DataItem
            enter DI[]
            do (if not isValueObj then
                   cd.setThisStack
               if);                   
               (if DI.OG.isValueObj 
                   and not (DI.OG.primNo = integer_prim) 
                   and not (DI.OG.primNo = boolean_prim) 
                   and not (DI.OG.primNo = char_prim) 
                   and not (DI.OG.primNo = float_prim) 
                   (* and not DI.OG.isUnitValueObj*)
                   then
                   cd.pushThis;
                   DI.newOff -> cd.pushConst;
                   DI.OG.IS.newDescNo -> cd.pushConst
                else
                   cd.pushThis;
                   DI.invoke
               if)
            #);          
          genClass::
            (# var: ^Variant
            enter var[] (* super has more arguments *)
            do (if hasVirtualObject then
                   (if traceGeneric3 then
                       '***** HasVirtualObject: ' -> putline; 
                       (if sig[] <> none then 
                           sig.doPT -> putline;
                        else
                           doPT -> putline;
                           display
               if)if)if);
               (* Move IS.genclass to here? *)
               (this(ObjectGenerator),CC[],var[]) -> IS.genClass
            #);
          XaddB: @ XaddBptn;
          XaddBptn::
            (# off: @integer; E: ^ObjectSpecification;

               copySuper:
                 (# ptn: ^Pattern
                 do (if super.ATd[] <> none then
                        super.ATd[] -> ptn[];
                        (*'copySuper:' ->putline; ptn.OG.XaddB.display;*)
                        (for i: ptn.OG.XaddB.top repeat 
                             (*ptn.OG.XaddB.offSets[i] -> putint; ' '-> put;
                              ptn.OG.XaddB.bindingType[i] -> putint; newline;
                              (if ptn.OG.XaddB.bindings[i][] <> none then
                              ptn.OG.XaddB.bindings[i].dopt -> putline;
                              else
                              'none' -> putline
                              if);*)
                             (if ptn.OG.XaddB.offsets[i] > 0 then
                                 (ptn.OG.XaddB.offsets[i]
                                 ,ptn.OG.XaddB.bindings[i][]) 
                                   -> XaddB
                                 (*else = 0: inner *)
                             if)
                        for)                             
                    if)
                 #);
               display:
                 (# T: ^Text
                 enter T[]
                 do (if top > 0 then
                        T[] -> puttext; 
                        '*** Bindings: descNo: ' -> puttext; 
                        IS.newDescNo(*descNo*) -> putint; newline;
                        (for i: top repeat
                             i -> putint; ':' -> put;
                             offsets[i] -> putint; ':'->put;
                             (if bindingType[i]
                              // 0 then '   inner: ' -> puttext;
                              // 1 then '   ref: ' -> putline
                              // 2 then '   value: ' -> putline;
                              else 
                                 '   ???' -> putline
                             if);
                             (if bindings[i][] <> none then
                                 bindings[i].doPT -> putline
                              else 
                                 'none'->putline
                             if)
                    for)if)
                 #)      
            enter(off,E[])
            do (if handleGeneric then
                   (if off <= 0 then
                       '\n*** XaddB: off <= 0: '-> puttext;
                       off -> putint; newline;
                       dopt -> putline;
                       E.doPT -> putline;
                       leave XaddB
                   if);
                   (if off > bindings.range then
                       (off + 2 - bindingType.range) -> bindingType.extend;
                       (off + 2 - bindings.range) -> bindings.extend;
                       (off + 2 - offsets.range) -> offsets.extend;
                   if);
                   (if off > top then off -> top if);
                   off -> offsets[off];
                   (*'Add:' -> puttext; E.doPT -> puttext; 
                    ' ' -> put; off -> putint;
                    ' ' -> put; E.primNo -> putint; newline;*)
                   (if E.primNo // integer_prim then 
                       (* '--value--'->putline;*)
                       2 -> bindingType[off]
                    else 
                       1 -> bindingType[off]
                   if);
                   E[] -> bindings[off][];
               if)
            #);
          mkLLVMstruc:
            (# emitLLVMdataItems:
                 (# OGx: ^ObjectGenerator; off: @integer
                 enter(OGx[],off)
                 do (*'**** ' -> puttext; OGx.OGid -> putline;*)
                    (if (OGx.super.ATd[] <> none) then
                        (OGx.super.ATd.OG[],off) -> emitLLVMdataItems
                    if);
                    OGx.IS.scanSons
                    (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
                    do (if current.isDataItem then
                           current[] -> DI[];
                           cd.com(#do DI.sig.dopt -> TT;
                                    ' Basic:' -> TT; DI.OG.isBasicValue->BB;
                                    ' val: ' -> TT; DI.isValue -> BB;
                                    ' valObj:' -> TT; DI.OG.isValueObj ->BB;
                                    ' Inx:' -> TT; DI.OG.IS.isIndexed -> BB;
                                 #);
                           (*'**   :emb: ' -> puttext; D
                            * I.sig.dopt -> puttext;
                           ' ' -> put; DI.newoff -> putint;
                           ' ' -> put; off -> putint; newline;*)
                           (if true
                            // DI.OG.IS.isIndexed then
                               DI.newOff + off -> addAX
                            // DI.OG.isBasicValue then 
                               DI.newOff + off-> addVX
                            // DI.isValue then
                               (DI.OG[],DI.newOff - 1) -> emitLLVMdataItems
                            else
                               (DI.newOff  + off,DI.OG.OGidWdNo) -> addRX
                           if)
                        else
                       if)
                    #)
                 #);
               addRX:<
                 (# off: @integer; OGid: ^text
                 enter(off,OGid[])
                 do (*'**** addRX: ' -> puttext; off -> putint;
                    ' ' -> put; OGid[] -> putline;*)
                    (if true or (offTop < off) then 
                        inner;
                        off -> offTop;
                     else
                        '\n!!! offTop >= off ' -> puttext;
                        offTop -> putint; ' ' -> put; off -> putint;
                        newline
                    if)
                 #);
               addVX:<
                 (# off: @integer
                 enter off
                 do (*'**** addVX: ' -> puttext; off -> putint; newline;*)
                    inner;
                    off -> offTop
                 #);
               addAX:<
                 (# off: @integer
                 enter off
                 do (*'**** addAX: ' -> puttext; off -> putint; newline;*)
                    inner;
                    off -> offTop
                 #);                 
               offTop: @integer; org: ^Items; 
               withDN:
                 (# T: ^text; dn: @integer
                 enter(T[],dn)
                 do '$' -> T.put; dn -> T.putint;
                 exit T[]
                 #);
               dn: @integer
            do (* Clean-up needed here
                * Must be recursive in super as is emitLLVMdataItems
                * Must handle more than one origin
                * Must skip origin for value objects
                *)
               (if (IS.superDesc[] <> none) 
                   and (IS.superDesc[] <> objectDecl.desc) then
                   (if false then
                       '**   super: ' -> puttext; 
                       IS.superDesc.encOG.OGid -> puttext; ' ' -> put;
                       IS.superDesc.sig.dopt -> puthead;
                       IS.superDesc.newOriginOff -> putint; newline;
                   if);
                   &IS.superDesc.encOG.mkLLVMstruc
                   (# addRX::
                        (#
                        do (off,OGid[]) -> this(mkLLVMstruc).addRX
                        #);
                      addVX::
                        (#
                        do off -> this(mkLLVMstruc).addVX
                        #);
                      addAX::
                        (#
                        do off -> this(mkLLVMstruc).addAX
                        #)
                   #);
               if);
               (if IS.newOriginOff <> 0 then 
                   (* some objects have no origin *)
                   origin[] -> org[];
                   (if org[] <> none then
                       (if org.encOG.primNo = ifthen_prim then
                           org.origin[] -> org[]
                       if);
                       (if (org.encOG.primNo = String_prim) then
                           (*'>>>>>> Origin:is:string: ' -> puttext;
                           org.encOG.OGidWdNo -> putline;*)
                           (*(IS.newOriginOff,'array$1') -> addRX;*)
                       if);
                       (IS.newOriginOff,org.encOG.OGidWdNo) -> addRX;
                       (if (origin[] -> IS.originIsValue) then
                           IS.newOriginOff + 1 -> addVX;
                           IS.newOriginOff + 2 -> addVX;
               if)if)if);
               IS.scanSons
               (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
               do (if current.isDataItem then
                      current[] -> DI[];
                      cd.com(#do DI.sig.dopt -> TT;
                               ' basic: ' -> TT; DI.OG.isBasicValue -> BB;
                               ' val: ' -> TT; DI.isValue -> BB;
                               ' valObj: ' -> TT; DI.OG.isValueObj -> BB;
                               ' Inx:' -> TT; DI.OG.IS.isIndexed -> BB;
                            #);
                      (if true
                       // DI.OG.IS.isPureIndexed then
                          DI.newOff -> addAX
                       // DI.OG.isBasicValue (* isBasicPattern? *) then 
                          DI.newOff -> addVX
                       // DI.isValue then
                          (*'*** embed value:' -> puttext; 
                          DI.sig.dopt -> putline;*)
                          (DI.OG[],DI.newOff - 1) -> emitLLVMdataItems;
                       else
                          (*'**** addRx: ' -> puttext; DI.newOff -> putint;
                          ' ' -> put; DI.sig.dopt -> putline;*)
                          (DI.newOff,DI.OG.OGidWdNo) -> addRX
                      if);
                   else 
                      (if current## 
                       // Module## then
                          current[] -> M[]; 
                          (if true then
                              'Module: '->puttext; moduleName -> puttext; 
                              ' ' -> put; M.newOff -> putint; newline;
                          if);
                          (M.newOff,M.OG.OGidWdNo(*moduleName*)) -> addRX
                       // ModuleItem## then
                          current[] -> MI[];
                          (if MI.MD.off > 0 then
                              (If false then
                                  'MI:'->puttext; 
                                  MI.MD. moduleName->puttext;
                                  ' ' -> put; 
                                  MI.MD.OG.OGidWdNo -> puttext;
                                  ' ' -> put;
                                  MI.MD.newOff -> putint;
                                  (*MI.MD.OG.IS.qDescNo[1] -> putint;*)
                                  newline;
                              if);
                              (MI.MD.newOff,MI.MD.OG.OGidWdNo(*moduleName*)) 
                                -> addRX
                  if)if)if)
               #);
               (*cd.typeInfo.print*)
            #);
          computeGCinfo:
            (#
            do (*'****compouteGCinfo: '->putline; dopt -> puthead;*)
               cd.addGCinfo
               (# rtnDI: ^DataItem
               do (if IS.newOriginOff <> 0 then (* some objects have no origin *)
                      IS.newOriginOff -> add;
                  if);
                  (* Code for checking references in Signature has been removed *)
                  (if (IS.superDesc[] <> none) and (IS.superDesc[] <> objectDecl.desc) then
                      (*'\nsuper: ' -> puttext; IS.superDesc.sig.dopt -> puthead;*)
                      (*(IS.superDesc.theObjectGenerator).computeGCinfo*)
                      IS.superDesc.encOG.computeGCinfo
                  if);
                  IS.scanSons
                  (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
                  do (if current.isDataItem then
                         current[] -> DI[];
                         (if DI.OG.isBasicValue or DI.isValue then
                          else
                             (*DI.sig.dopt->puttext; ':'->put; 
                              * DI.newOff->putint;newline;*)
                             DI.newOff -> add
                         if);
                      else 
                         (if current## 
                          // Module## then
                             current[] -> M[]; 
                             (*'Module: '->puttext; moduleName -> puttext; ' ' -> put;
                             M.newOff -> putint; newline;*)
                             M.newOff -> add
                          // ModuleItem## then
                             current[] -> MI[];
                             (if MI.MD.off > 0 then
                                 (*'MI:'->puttext; MI.MD. moduleName->puttext;' ' -> put;
                                 MI.MD.newOff -> putint; newline;*)
                                 MI.MD.newOff -> add
                     if)if)if)
                  #);
                  (*newline*)
               #);
            #);
          clear::< (# do false -> marked; inner #);

       #);
     items::
       (# markForCodeGen::
            (#
            do cd.com(#do 'items:markForCodeGen:'->TT; doPT -> TQ #);
               scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if current.isDataItem then
                      current.MarkForCodegen 
                   else
                      (if I.isDecl then
                          (if not I.isPattern or I.isVirtual or(I[] = StringDecl[]) then
                              (if I[] = StringDecl[] then
                                  cd.com(#do 'Items:markString'->TT; dopt->TT #)if);
                              current.MarkForCodeGen 
                          if)
                       else
                          cd.com(#do 'markItem:'->TT; current.doPT -> TQ; 
                                   current.label -> TT #);
                          current.MarkForCodeGen 
                      if)
                  if)
               #);
            #);
          isIndexed: booleanValue
            (#                               
            do (if primNo // String_prim // indexed_prim then
                   true -> value
                else
                   (if superDesc[] <> none then
                       superDesc.isIndexed -> value
                   if)
               if)
            #); 
          isPureIndexed: booleanValue
            (#                               
            do (if primNo = indexed_prim then
                   true -> value
                else
                   (if superDesc[] <> none then
                       superDesc.isPureIndexed -> value
                   if)
               if)
            #);
          genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; 
               super: ^Invocation;
               var: ^Variant;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
               OG: ^ObjectGenerator;
               genSuperClass:
                 (#
                 do (if (superDesc[] <> none) then
                        (* get the ptn decl for super: *)
                        superDesc.father.father -> ptn[]; 
                        (if superDesc.isPrimitive then
                            (if superDesc.primNo //object_prim //value_prim then
                             else
                                '**** superDesc.isPrimitive:'->puttext;
                                ptn.dopt -> puthead;
                                true -> superIsPrimitive
                        if)if);
                        (if (var[] <> none) and (var.thisVarNo > 0) then
                            (* we should find the corresponding var in 
                             * super; perhapsd use the same object?
                             *)
                            var[] 
                              -> ptn.OG.Qvariants.findSuperVar 
                              -> superVar[];
                        if);                        
                        (if (superVar[] <> none) and not superVar.genDone 
                            or 
                            (superVar[] = none) and not superDesc.done then
                            (* the actual variant being generated must be
                             * propagated to super possibly implying that 
                             * a new variant of super must be generated;
                             * we have actually propagated the actual var 
                             * to the super, so should the propagation 
                             * imply a codegen (on objTmpStack) or should 
                             * we do it here?
                             *)
                            cd.com(#do 'genClass:super:'->TT; N[]->TT; nl;
                                     super.dopt -> TQ;
                                  #);
                            (* we should clean-up below such that 
                             * genClass should not be duplicated here!?
                             **********************************)
                            (ptn.OG[],CC[],superVar[]) 
                              -> superDesc.genClass;
                            (* Perhaps vdtTableCopy below does not work
                             * if we have not called genClass!?
                             *)
                    if)if)
                 #);
               AllocateSuper:
                 (#
                 do (if true (* perhaps hasRealSuper *)
                     // (superDesc[] <> none) and not superDesc.isPrimitive
                     // (superDesc[] <> none) 
                        and 
                        ((superDesc.primNo = stringDecl.primNo) 
                        or (superDesc.primNo = immutable_prim)) then
                        (ptn.sig.id[],superDesc.newDescNo) -> cd.super;
                        superDesc.newDescNo -> cd.vdtTableCopy;
                        (if superDesc.innerInx > 0 then
                            (superDesc.innerInx,newDescno,true,'innerS')
                              -> cd.vdtTable;
                        if);
                        (* push super arguments *)
                        (if super.isImplSuper then
                            (if not (elimOrigin 
                                and globalRestrictionsInsuper) then
                                (if super.isSingularImplSuper then
                                    cd.pushThis;
                                   ('iOrigin',newOriginOff) -> cd.rpushg;
                                    (if (origin[] -> originIsValue) then
                                        cd.pushThis;
                                        (T[],newOriginOff + 1) -> cd.pushg;
                                        cd.pushThis;
                                        (T[],newOriginOff + 2) -> cd.pushg;
                                    if)
                                 else
                                    super.ATd[] -> ptn[]; 
                                    (* snorf3:< koks3.foo3
                                     * ...
                                     * snorf3 ::
                                     *    ...
                                     * ptn = snorf3:< koks3.foo3
                                     *)
                                    (# E,rec: ^Exp; A: ^Address
                                    do newOriginOff
                                         -> Address
                                         -> ptn.OG.super.computeAdr
                                       (#do cd.com(#do 'no:addOG'->TT #)#)
                                         -> (rec[],E[],A[]);
                            #)if)if)
                         else
                            (# E,rec: ^Exp; off: @integer; A: ^Address; 
                               addOG:
                                 (# OGx: ^ObjectSpecification; off: @integer
                                 do (if OG.isArgofE[] <> none then
                                        cd.com(#do 'addOG:'->TT #);
                                        (if traceArgOG then
                                            '**** OG inArgument: ' -> putline;
                                            OG.dopt -> puthead;
                                            '**   OG.isArgOfE:\n' -> puttext;
                                            OG.isArgOfE.dopt -> putline;
                                        if);
                                        (if OG.isArgOfE.father.father##
                                            = BracketedExp## then
                                            OG.isArgOfE.father.father.father[]
                                              -> OGx[];
                                         else
                                            OG.isArgOfE.father.father[] -> OGx[];
                                        if);
                                        OGx.IS.newOriginOff -> off;
                                        (* We do get ObjectCall and off = 0 
                                         * below!
                                         * OG.isArgOfE.enclosingObjectGenerator
                                         * and OG.isArgOfE.origin.father[]
                                         * do not work, since they return
                                         * the OG enclosing OGx.
                                         * Must be understood!?
                                         *)
                                        (if (OGx## = ObjectCall##)
                                            or (off = 0)  then
                                            '**** OG in:argument: ' -> puttext;
                                            OGx.label -> puttext; ' ' -> put;
                                            off -> putint; newline
                                        if);
                                        (if traceArgOG then
                                            OGx.dopt -> puthead;
                                            '**   originOff:'->puttext; 
                                           off->putint; newline;
                                        if);
                                        (if true and (off > 0) then
                                            ('ArgOGs',off) -> cd.rpushg;
                                        if)
                                    if)
                                 #)
                            do (if elimOrigin and globalRestrictionsInSuper then
                                   super.scanSons
                                   (#
                                   do current[] -> E[];
                                      (if not isLast then 
                                          E[] -> rec[] 
                                       else
                                          (if isFirst then 
                                              E[] -> rec[]
                                   if)if)#)
                                else 
                                  (* super is searched in the origin of 
                                   * this(OG); we must then have an 
                                   * additional goOrigin from this(OG);
                                   * this is handled by passing newOriginOff
                                   * as an argument of Address - superAdj;
                                   * adjustOrigin will generate this goOrigin
                                   * if superAdj > 0
                                   *)
                                  newOriginOff
                                    -> Address
                                    -> super.computeAdr(#do addOG #)
                                    -> (rec[],E[],A[]);
                                  cd.com
                                  (#do 'genClass:after:ComputeAdr:'-> TT; 
                                     E.doPT -> TQ; A.print -> TT #);
                              if);
                              (* What goes on here?
                               * Do we need staticOff below? *)
                              (if sig[] = none then
                                  cd.com(#do'super.sig:none:superAdj:'-> TT;
                                           newOriginOff -> II #);
                                  (newOriginOff,0,CC[]) -> E.loadArgs; 
                               else
                                  cd.com(#do'super.sig:not:none:superAdj:'->TT;
                                           - newOriginOff -> II #);
                                  (* go ON-1, use newOriginOff first time *)
                                  (- newOriginOff,0,CC[]) -> E.loadArgs; 
                              if);
                               (*'**** E.handleVargs: ' -> puttext; 
                                * E.dopt -> putline;*)
                               E.handleVargs
                           #);
                       if);
                       (if noOfRefArgsInSuper > 0 then 
                           noOfRefArgsInSuper -> cd.rswap 
                       if);
                       superDesc.newDescNo -> cd.toSuper;
                       cd.markEnterE; 
                    else
                       (if objectDecl.OG.IS[] <> this(Items)[] then
                           (1,newDescno,true,'innerM') -> cd.vdtTable;
                   if)if); 
                 #);
               BindVirtuals:
                 (# mkStubNameX:
                      (# T: ^text
                      do 'Vstub#' -> T[];
                         (if sig[] <> none then
                             sig.id[] -> id[] -> T.append;
                          else
                             'S' -> id[] -> T.append
                         if);
                         '#' -> T.put;    
                         OG.vDescNo -> T.putint;
                      exit T[]
                      #);
                    id: ^text; (* elim *)
                    handleVirtualDecl:
                      (# D: ^Pattern; OGx,OGs: ^ObjectSpecification; 
                         stubN: ^text; dNo: @integer;
                      enter(D[],OGx[])
                      do cd.com
                         (#do 'genClass:Virtual:' -> TT; D.sig.dopt->TT;
                            'newDescNo: '->TT; newDescNo -> II;
                            OGx.dopt -> TT; 
                            ' OGx.hasI: ' -> TT; OGx.hasItems -> BB;
                            ' off: ' -> TT; D.off -> II;
                         #); 
                         (if newVirtH then
                             (newDescNo,this(Items)[]) -> D.handleVirtualPtn; 
                             leave handleVirtualDecl;
                         if);
                         (*************** code below is not used ****)
                         (if OGx.nonSingularBinding then
                             cd.com(#do 'nonSingularBinding' -> TT #);
                             ObjectGenerator 
                               -> OGs[] -> QnewDesc -> dNo -> OGs.IS.QdescNo[1];
                             mkStubNameX -> stubN[];
                             cd.com
                             (#do 'vStub:' -> TT; id[] -> TT;
                                'newDescNo:' -> TT; newdescNo -> II;
                                'virt:' -> TT; D.sig.dopt -> TT;
                                'stubN:' -> TT; stubN[] -> TT;
                                'dNo:' -> TT; dNo -> II; 
                             #);
                             (* can ObjStubStack be used instead? *)
                             (stubN[],dNo,OGx[],this(Items)[]) 
                               -> genVstub;
                             (* check how genVstub relates to genStub as
                              * called from objStubStack.gen.
                              * This does not work: 
                              * (D[],'xStub',dNo,newDescNo,0,0) ->
                              * ObjStubStack.add;*)
                             (* The vdtTableAt here overrides the one 
                              * in HandleVirtArgument (check it)
                              * But HandleVirtArgument has been eliminated
                              * See handleV
                              *)
                             (D.off,dNo,newDescNo,D.sig.dopt) -> CD.vdtTableAt
                          else (* singular binding - amd vdt should be ok *)
                             cd.com(#do 'singularVirt:' -> TT;
                                      D.sig.dopt -> TT;  #);
                             D.sig.dopt -> stubN[]
                         if);
                         (OG.OGidWdNo,D.sig.dopt,D.off,dNo,newDescNo,stubN[])
                           -> cd.newVirtDefs
                      #);
                    ptn: ^Pattern;
                    E: ^Exp;
                    args: [6]^ObjectSpecification; top,i: @integer;
                 do (if (super.last -> E[]) = none then 
                        leave BindVirtuals
                    if);
                    (if (E.args[] <> none) and (E.args.noOfSons > 0)  then
                        (if false then
                            '**** E:' -> putline; E.dopt -> putline;
                            E.args[] <> none -> putboolean; ' ' -> put; 
                            E.args.noOfSons -> putint; newline;
                        if);
                        cd.com(#do 'Handle VB:'->TT; dopt -> TQ;
                                 'E:' -> TT; E.doPT -> TQ #);
                        E.args.scanArgs
                        (#
                        do (if (top+1 -> top) > args.range then 
                               args.range -> args.extend 
                           if);
                           current[] -> args[top][];
                        #);     
                        (if super.ATd[] <> none then
                            super.ATd.OG.IS.scanAllDecls
                            (# i: @integer
                            do (* Only some inargs may be virtual
                                * And not all virtuals are inargs
                                *)
                               (if currentDcl.isInarg then i + 1 -> i if);
                               (if (currentDcl.isVirtual) 
                                   and currentDcl.isInarg then
                                   (currentDcl[],args[i][]) 
                                     -> handleVirtualDecl
                    if)#)if)if);
                    (if sig[] <> none then
                        sig.scanSons
                        (# D: ^Decl
                        do (if current.isDecl then
                               current[] -> D[];
                               (if D.isVirtual then
                                   (D[],D.OG[]) -> handleVirtualDecl
                    if)if)#)if);
                    scanSons
                    (# I: ^Item; D: ^Decl
                    do current[] -> I[];
                       (if I.isDecl then 
                           I[] -> D[];
                           (if D.isVirtual then
                               (D[],D.OG[]) -> handleVirtualDecl 
                    if)if)#);
                    (*ObjStubStackX.gen;*)
                    newDescNo -> cd.endNewVirtDefs;
                 #);   
               mainPathModule: ^Module;     
               CC: ^CallChain; superVar: ^Variant;
               superIsPrimitive: @boolean;
               noOfRefArgsInSuper: @integer;
                 (*enter(N[],sig[],descNo,Super[],OG[],CC[],var[])*)
            enter(OG[],CC[],var[])
            do (* Is called with descNo = NewDescNo *)
               (* We must know the actual variant being generated for
                * The actual variant should have info about: 
                * actual descNo and actual storage layout 
                *)
               (* the following dataitems used to be arguments of genClass *)
               OG.OGid -> N[];
               OG.sig[] -> sig[];
               newDescNo -> descNo;
               OG.super[] -> super[];
               cd.com(#do 'GenClass:'->TT; N[] -> TT;':varNo = '-> TT;
                        (if (var[] <> none) then var.thisVarNo -> II if);
                     #);
               (if not OG.Qvariants.isEmpty then if);
               2 -> labelhandLer.labCount;               
               
               genSuperClass;
               
               var[] -> thisVar[];
               (if (var[] = none) and not done or 
                   (var[] <> none) and not var.genDone then
                   (if (var[] <> none) and done then
                       (* we must eliminate this case 
                        * there should always be var <> none *)
                       cd.com(#
                             do 'OBS! calling genClass for:' -> TT; N[] -> TT;
                                ':var<>none:Done:'->TT;  done->BB;
                                ':leave genClass' -> TT
                             #);
                       (* (dumpStack,'---') -> stop;*)
                       true -> var.genDone;
                       leave genclass
                   if);
                   (if var[] <> none then 
                       true -> var.genDone
                    else 
                       true -> done 
                   if);
                   
                   OG.XaddB.copySuper;
                   
                   (# org: ^items; originDescNo: @integer; orgId: ^text
                   do (if (origin[] -> org[]) <> none then
                          org.newDescNo -> originDescNo
                      if);
                      (if newFeature then
                          (if org[] <> none then 
                              org.encOG.OGid -> orgID[]
                           else
                              'Object' -> orgId[]
                          if);
                          (if false then
                              '**** class: ' -> puttext; N[] -> puttext;
                              ' origin: ' -> puttext;
                              orgID[] -> putline;
                          if)
                      if);
                      (if org[] <> none then 
                          org.encOG.OGid -> orgID[]
                       else
                          'Object' -> orgId[];
                           objectDecl.OG.OGid ->orgId[];
                           objectDecl.OG.IS.newDescNo -> originDescNo;
                      if);
                      (N[],newDescNo,false,(topSuper).newDescNo
                      ,newOriginOff,orgId[],originDescNo,encOG.isValueObj,false)
                        -> cd.class;
                   #);
                   (* thisObj = the new instance of this class 
                    * thisStack = caller
                    * Possible arguments on callerStack
                    *)
                   cd.bcPos -> beginBCP;
                   (if not emitLLVM then
                       cd.com(#do 'Store itemArgs' -> TT #);
                       scanItemArgsReverse(#do true -> currentArg.store #)
                   if);
                   (if globalRestrictionsInMain and elimOrigin then
                       (if traceNoGlobals then
                           cd.com(#do 'No globals,no origin'->TT; 
                                    dopt->TT; print #)
                       if)
                    else
                       (* if super has ref args, then these are on the stack
                        * and top one will be assigned to origin
                        *)
                       (if (noOfRefArgs -> noOfRefArgsInSuper) > 0 then
                           noOfRefArgsInSuper -> cd.rswap
                       if);
                       cd.tstOriginIsNone;
                       ('origin',newOriginOff) -> cd.rstore;
                       (if (origin[] -> originIsValue) then
                           ('origin.valueOff',NewOriginOff + 2) -> cd.store;
                           ('origin.valueOff',NewOriginOff + 1) -> cd.store;
                   if)if);
                   (if not OG.isValueObj then 
                       (if not ((superDesc[] <> none) 
                           and not superDesc.isPrimitive) then
                           true -> cd.allocEventQ
                   if)if);
                   
                   AllocateSuper;
                   
                   (if newDescNo = (markIncludes.topModule.desc).newDescno then
                       cd.pushThis;
                       cd.saveBETAworld
                   if);
                   (if isStringModule then cd.saveStringOrigin if);
                   (if (superDesc[] <> none) and not superDesc.isPrimitive  then
                    else (if not OG.isValueObj then cd.mvStack
                   if)if);
                   (if sig[] <> none then
                       (*(false,0,0) -> sig.Qgen *)
                   if);
                   scanSons
                   (# I: ^Item; MP: ^Module
                   do current[] -> I[];
                      (if true
                       // I.isDecl then
                          (if not I.isPattern or I.isVirtual then
                              (false,0,0) -> current.Qgen -> MP[];
                              (if MP[] <> none then
                                  MP[] -> mainPathModule[];
                              if)
                           else
                              (if I[] = StringDecl[] then
                                  (false,0,0) -> current.Qgen if) 
                          if)
                       // I.isNewProp then
                          (false,0,0) -> current.Qgen -> MP[];
                           (if MP[] <> none then
                               MP[] -> mainPathModule[];
                           if)
                   if)#);
                   (if mainPathModule[] <> none then
                       (*'gen:mainPathModule: ' -> puttext;
                        * mainPathModule.DI.OG.IS.newDescNo -> putint;  
                        * ' ' -> put;
                        * mainPathModule.DI.sig.dopt -> putline; *)
                       (false,0,0) -> mainPathModule.Qgen;
                       none -> mainPathModule[]
                   if);
                   (if innerInx > 0 then innerInx -> cd.innerA if);
                   (if (superDesc[] <> none) and not superDesc.isPrimitive then
                       'A' -> cd.rtnInner 
                    else
                       (if not OG.isValueObj then
                           (if doHasCode then 
                               1 -> cd.rtnEventQ 
                            else
                               0 -> cd.rtnEventQ 
                   if)if)if);
                   
                   (* Code for action part *)
                   (false 
                   ,not OG.isValueObj and 
                   not ((superDesc[] <> none) and not superDesc.isPrimitive )
                   ) -> cd.actions;
                   (if not OG.isValueObj then cd.mvStack if);
                   
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item; superHasNewInner: @boolean
                   do current[] -> I[];
                      (if not I.isDecl then 
                          cd.com(#do 'genclass:stmt:'->TT; current.doPT->TQ#);
                          (if isLast then
                              (if super.ATD[] <> none then
                                  super.ATd.OG.IS.newInner[] <> none
                                    -> superHasNewInner
                          if)if);
                          (superHasNewInner,0,0) -> current.Qgen 
                      if) 
                   #);
                   leaveLab -> cd.defLab;
                   (if (superDesc[] <> none) and not superDesc.isPrimitive then
                       'M' -> cd.rtnInner
                    else
                       (if not OG.isValueObj then 0 -> cd.rtnEventQ if);
                       cd.com(#do 'pushReturn: ' -> TT; 
                                (if sig[] <> none then sig.id[] -> TQ if)#);
                       L:
                         (if encOG.isValueObj then
                             (if sig[] <> none then
                                 encOG.pushReturnValues
                             if);
                             cd.rtnV
                          else
                             (if false (*not newOutGen*) then
                                 scanAllItemDecls
                                 (# 
                                 do (if currentDcl.isOutArg then
                                        currentDcl[] -> encOG.pushRtnV;
                                        leave L
                                 if)#)
                             if);
                             cd.setThisStack;
                             cd.pushThis
                         if);
                       'D' -> cd.rtn (* also for value object?  *)
                   if);
                   encOG.computeGCinfo;

                   (objSize,isIndexed,newBasicProp.OSDvisibility) 
                     -> CD.endClass;

                   cd.bcPos -> endBCP
               if);
               (if traceGeneric2 then encOG.XaddB.display if);

               (if innerInx > 0 then
                   (innerInx,0,true,'innerX') -> cd.vdtTable; 
               if);
               BindVirtuals;
               (if false then
                   '**** before:cd.mkLLVMvirtualDefs :' -> puttext; 
                   encOG.OGidWdNo -> puttext; ' ' -> put;
                   (*ptnKind -> putint; ' '-> put;*)
                   isEmpty -> putboolean; newline;
                   father.father.dopt -> puthead;
               if);
               cd.mkLLVMvirtualDefs
               (# vName::
                    (# OGx: ^ObjectGenerator; org: ^Items
                    do dn -> QnewDesc.getOD -> OGx[];
                       OGx.OGidWdNo -> vN[];
                       (if false then
                           '**   vName:dn: ' -> puttext; dn -> putint;
                           ' ' -> put; vN[] -> putline;
                           (*OGx.father.dopt -> puthead*)
                       if);
                       origin[] -> org[];
                       (if org[] <> none then 
                           org.encOG.OGidWdNo -> orgOfVN[];
                        else
                           'Object$0' -> orgOfVN[] (* to be fixed! *)
                       if);
                       (if false then
                           '**** vName: ' -> puttext; vN[] -> puttext;
                           ' origin: ' -> puttext; 
                           orgOfVN[] -> putline;
                       if)
               #)#);
               cd.lcom(#do 'ObjStubStackX:gen' -> TT #);
               ObjStubStackX.gen;
            #);
          goOrigin:
            (# on: @integer; NA: ^Apl; org: ^Items; T: ^text; 
               var: ^Variant;
               orgIsVal: @boolean; off: @integer
            enter(on,NA[])
            do (if on > 0 then
                   cd.com(#do 'goOrigin:on:' -> TT; on -> II #);
                   (if emitLLVM then
                       origin[] -> org[];
                       cd.com(#do org.encOG.primNo -> II; ' ' -> TT; 
                                org.encOG.dopt->TQ#);
                       (if org.encOG.primNo = ifthen_prim then
                           org.origin[] -> org[]
                       if);
                       org.encOG.OGidWdNo -> T[];
                       (*'goorigin: "'->puttext;
                       T[] -> putline;
                        *)
                       (*'$' -> T.put;
                       org.newDescNo -> T.putint*)
                    else
                       encOG.OGid -> T[]; ':origin' -> T.append;
                   if);

                   (* For each pattern in the origin chain, we must check
                    * whether or not the specific pattern has restrictions
                    * that are violated
                    *)
                   NA[] -> checkGlobals;
                   (* how do we with newAlloc ensure that code is generated
                    * for OGs in the origin chain?
                    *)
                   (if basicNo = ifthen_prim then
                       cd.com(#do 'goOrigin:Skip:ifThen' -> TT #);
                       (on,NA[]) 
                         -> (origin[]->org[]).goOrigin
                         -> (org[],orgIsVal)
                    else
                       (if encOG.IS.newOriginOff = 0 then 
                           (if false then
                               'OBS! Qalloc, originOff = 0: '
                                 -> putline;
                               '**   label: ' -> puttext; 
                               label -> putline;
                               '**   father.label: ' -> puttext;
                               father.label -> putline;
                               '**   father: ' -> putline;
                               father.dopt -> putline;
                               '**   father:' -> putline; 
                               father.dopp -> putline;
                               '**   encOG: '-> putline;
                               encOG.dopt -> putline;
                               '**** encOG.IS: ' -> putline;
                               encOG.IS.dopt -> putline;
                           if);
                           (* move to vvariants.bet*)
                           'OBS! Qalloc, originOff = 0 ' -> cd.comment;
                           encOG.computeVariant -> var[];
                       if);
                       cd.com(#do 'goOrigin:'-> TT; encOG.OGid-> TT; 
                                ':encOG.IS.newOriginOff:' -> TT;
                                encOG.IS.newOriginOff -> II; 
                                ':newOriginOff:'->TT; newOriginOff->II #);
                       cd.lcom
                       (#do 'goOriginL: ' -> TT; newOriginOff -> II;
                          ' ' -> TT; T[] -> TT; 
                       #);
                       (if false then 
                           '**** goOriginL:NA: ' -> puttext; 
                           NA.dopt -> putline;
                           newOriginOff -> putint; ' ' -> put;
                           label -> puttext; newline;
                           dopt -> puthead;
                       if);
                       cd.lcom(#do 'NA: ' -> TT; NA.dopt -> TT;
                                 ' ' -> TT;
                                 (NA.origin[]->org[]).encOG.OGidWdNo -> TT
                              #);
                       (NA.origin[]->org[]).encOG.OGidWdNo -> T[];
                       (if (origin[] -> originIsValue) then
                           cd.com(#do 'origin.valueOff:load ' -> TT; 
                                    newOriginOff + 1 -> II #);
                           cd.rdouble;
                           (T[],newOriginOff) -> cd.rpushg;
                           cd.rswap;
                           cd.rdouble;
                           (T[],newOriginOff + 1) -> cd.pushg;
                           (if false then
                               T[] -> puttext; ':'->put;
                               (origin[]->org[]).newDescNo -> putint;
                               newline;
                           if);
                           (T[],newOriginOff + 2) -> cd.pushg;
                           true -> orgIsVal
                        else
                           (T[],newOriginOff) -> cd.rpushg;
                       if);
                       (if (origin[] <> none) (*and (on > 1)*) then
                           (on - 1,NA[]) 
                             -> (origin[]->org[]).goOrigin
                             -> (org[],orgIsVal)
                       if)
                   if);
                   (if (encOG.isArgofE[] <> none) then
                       encOG.IS.newOriginOff -> off;
                       (if false then
                           '**** GoOrigin:OG inArgument: ' -> putline;
                           encOG.dopt -> puthead;
                           '**   of:'->putline; 
                           encOG.isArgofE.dopt -> puthead;
                           '**   originOff:'->puttext; off->putint;newline;
                       if);
                       ('ArgOG',off) -> cd.rpushg;
                       cd.com(#do 'ArgOG:'->TT; off->II #)
                   if);
                else
                   this(Items)[] -> org[]
               if);

            exit(org[],orgIsVal)
            #); 
          findNextImp::
            (#
            do L:
                 scanSons
                 (#
                 do (if (bcp -> current.findNextImp -> impx[]) <> none then
                        leave L
                 if)#);
            #)            
       #);
     Pattern::
       (# 
          markForCodegen::
            (#
            do cd.com(#do 'Pattern:markForCodeGen:' -> TT; dopt -> TQ#);
               sig.markForCodeGen;
               OG.markForCodeGen
            #);
          GeneralPattern::
            (# invoke:: (# <<SLOT GeneralPattern_invoke:doPart>> #);
            #);
          AssignmentPattern::
            (# invoke:: (# <<SLOT AssignMentPattern_invoke:doPart>> #);
            #);
          BreakPattern::
            (# invoke:: (# << SLOT BreakPatternInvoke:doPart>> #)
            #);
          IndexedPattern::
            (# invoke:: (# <<SLOT IndexPattern_invoke:doPart>> #);
            #);
          OtherPrimPattern:: 
            (# invoke:: (# <<SLOT OtherPrim_invoke:doPart>> #); 
               org: ^Items; Tlab,exitLab: @labelHandler.label;
            #);
          virtualDone: @boolean;
          handleVirtualPtn:
            (# encDno,dNo: @integer; stubN: ^text; encIS: ^Items; 
               OGs: ^ObjectGenerator; errs: ^Stream;
               dNoZero:
                 (# P: ^Pattern; T: ^text
                 do(* This is a hack - Qalloc is not always called
                    * Perhaps we need to call Qalloc on all 
                    * OGs being included!?
                    *)
                    'Vstub$' -> T[];
                    sig.dopt -> T.append;
                    ': { %id stub }' 
                      -> T.append
                      -> parseDeclText -> (errs[],P[]);
                    P.OG[] -> OGs[]; 
                    P.setUpOrigin;
                    P.check;
                    OGs[] -> QnewDesc -> dNo -> OGs.IS.QdescNo[1];
                    (if OG.vDescNo > 0 then
                        '!!!! OG.vDescNo > 0 :' -> puttext;
                        OG.vDescNo -> putint; ' ' -> put;
                        dNo -> putint; newline
                     else
                        dNo  -> OG.vDescNo;
                    if);
                    '$' -> OGs.sig.type.id.put;
                    dNo -> OGs.sig.type.id.putint;
                    (if false then
                        '**   dNo: ' -> puttext; dNo -> putint;
                        ' OG.vDescNo: ' -> puttext; 
                        OG.vDescNo -> putint;
                        newline;
                        P.doPt -> putline;
                    if)
                 #);
            enter(encDno,encIS[])
            do (if false then
                   '**** ptn:handleVirtualPtn: ' -> puttext; dopt -> putline;
                   '**   newDescNo: ' -> puttext; encDno -> putint;
                   ' off: ' -> puttext; off -> putint;
                   newline;
               if);
               (if virtualDone then
                   leave handleVirtualPtn
               if);
               true -> virtualDone;
               (if not OG.hasItems then 
                   (if false then
                       '**   not OG.hasItems: NS: ' -> puttext; 
                       OG.nonSingularBinding -> putboolean; newline;
                   if);
                   OG.vDescNo -> dno;
                   (if false then
                       '**** get:vDescNo: ' -> puttext; 
                       dno -> putint;
                       ' ' -> put; OG.OGid -> puttext; ' ' -> put;
                       OG.father.dopt  -> puthead;
                   if);
                   (if dNo = 0 then dNoZero if);
                   dno -> QnewDesc.getOD -> OGs[];
                   (sig[],OG[]) -> mkStubName -> stubN[];
                   (if false then
                       '**   vdt:addTo: ' -> puttext; 
                       cd.descs.current.descInx -> putint;
                       ' ' -> puttext; stubN[] -> puttext; ' '-> put;
                       dNo -> putint; newline;
                   if);
                   (off,dNo,false,stubN[]) -> CD.vdtTable;
                   (stubN[],dNo,OG[],encIS[]) -> ObjStubStackX.add;
                else
                   (if false then
                       '**   OG.hasItems: ' -> puttext; 
                   if);
                   (off,OG.IS.newDescNo,false,sig.dopt) -> cd.vdtTable
               if)
            #);
          Qgen::
            (# enclosingOG: ^ObjectGenerator;
               DN: @integer
            do (if not genIsDone then
                   true -> genIsDone;
                   (if OG.primNo
                    // 0 
                    // object_prim // value_prim
                    // string_prim 
                    // indexed_prim // immutable_prim then
                       (if newVirtH then leave qGen; if);
                       (if OG.IS.isExternal > 0 then leave Qgen if);
                       (if ptnKind 
                        // plainPtn then
                        // virtualPtn then
                           (if not OG.hasItems  then
                               cd.com(#do 'vdt:d: '-> TT; off -> II; 
                                        (OG.super.desc).newDescNo->II; #);
                               (* Qalloc moved to vvariant.bet *)
                               (off,(OG.super.desc).newDescNo,false,'notUsed') 
                                 -> cd.vdtTable;
                               (if traceGeneric then
                                   '*** Bind1: ' -> puttext;
                                   off -> putint; ' ' -> put; 
                                   (OG.super.desc).newDescNo -> putint; 
                                   newline;
                                   dopt -> putline;
                               if);
                            else
                               cd.com(#do 'vdt:e'-> TT;  #);
                               (off,OG.IS.newDescNo,false,'notUsed')
                                 -> cd.vdtTable;
                               (if traceGeneric then
                                   '*** Bind2: ' -> puttext;
                                   off -> putint; ' ' -> put; 
                                   OG.IS.newDescNo -> putint; newline
                               if)
                           if);   
                           (if father.father## = ObjectGenerator## then
                               (off,OG[])->(father.father[]->enclosingOG[]).XaddB
                            else                   
                               'Koks: '->puttext; father.father.label -> putline
                           if)
                        // furtherPtn // finalPtn then
                           (if OG.IS.isEmpty then 
                               OG.vDescNo -> DN;
                               cd.com
                               (#do 'vdtTable:off: ' -> TT; off -> II; 
                                  ' descNo: ' -> TT; DN -> II; 
                               #);
                            else
                               OG.IS.newDescNo -> DN;
                               cd.com(#do 'vdt:f:off:'-> TT; off -> II;
                                        'descNo:'->TT; DN->II #);
                               (off,DN,false,'notUsed') -> cd.vdtTable;
                           if);
                           (off, OG[])->(father.father[]-> enclosingOG[]).XaddB
               if)if)if)
            #);
          pushThis::
            (# T: @text
            do (if OG.primNo
                // 0 
                // value_prim  (* OBS - needed for a ptn being sub of Value
                                * otherwise execution fails since origin 
                                * is not loaded
                                * An explicit sub of Object also fails
                                *)
                // this_prim 
                // indexedGet_prim (* not tested*)
                // indexedPut_prim (* ditto *)
                // stringGet_prim 
                // indexed_prim  
                // immutable_prim then
                   cd.pushThis 
                else (* ugly *)
                   (if ptnKind // virtualPtn // furtherPtn // FinalPtn then
                       cd.pushThis 
                   if)
               if)
            #);
          loadArgs::
            (# gdb:: 
                 (# 
                 do 'E:' -> TT; E.doPT -> TQ;
                    ':descNo:' -> TT; OG.IS.newDescNo -> II;
                    ':top:' -> TT; OG.Qvariants.top -> II
                 #);
               handleNonVirtualArg:             
                 (# formalArg: ^DataItem; actualArg: ^ObjectSpecification;
                    superOG: ^ObjectGenerator;
                 enter(formalArg[],actualArg[])
                 do (* E is the exp with arguments actArgs 
                     * this(Pattern) = E.ATd
                     * formalArg is arg no. argInx of this(Pattern)
                     *)
                    cd.com(#do 'loadArgs:NonVirt:'->TT; E.doPT -> TQ; nl;
                             'ActArg: ' -> TT;actualArg.dopt->TQ;
                             'isValue: ' -> TT;  actualArg.isValueObj->BB;
                          #);
                    cd.com(#do
                             'formalArg.OG.isBasicValue:' -> TT;
                             formalArg.OG.isBasicValue -> BB;
                             ' formalArg.OG.isValueObj:' ->TT; 
                             formalArg.OG.isValueObj -> BB;nl;
                             ' formalArg.OG.isNonBasicValueObj:' -> TT;
                             formalArg.OG.isNonBasicValueObj -> BB
                          #);
                    (* The call of Qgen should perhaps have the receiver 
                     * as an argument!?
                     * Currenly we handle stuff af Qgen that depends on 
                     * the receiver
                     *)
                    0 -> staticOff;
                    (* we may mark actualArg as isUnitVal or float 
                     * depending on this ptn *)
                    (if primNo 
                     // vAssign_prim // rAssign_prim
                     // 112 (* float-* *) then
                        cd.com
                        (#do 'loadArgs:isPrim:assign,fmult: '->TT; 
                           primNo->II;E.dopt->TQ #);
                     else
                        cd.com
                        (#do 'loadArgs:not::assign:superAdj: '->TT; 
                           superAdj->II; 
                           ' ' -> TT; E.dopt->TQ #);
                        (* Perhaps we dont need both booleans below!? *)
                        formalArg.OG.isNonBasicValueObj 
                          -> actualArg.isCompositeValueObj;
                        
                        (if false then
                            '**** handleNVA:'
                            'formalArg.OG.isNonBasicValueObj: ' ->puttext;
                            formalArg.OG.isNonBasicValueObj -> putboolean;
                            ' ' -> putline; formalarg.dopt -> puthead;
                            actualArg.dopt -> puthead;
                        if);
                        (* actualArg is a composite valueObj,
                         * not a basic value
                         * and this(ptn) is not value assignment nor * !
                         * We do not know if it is a UnitValue
                         * ActualArg is a valueObj being an actual arg to 
                         * a ptn that is not assign, float-*, etc.
                         *)
                        cd.com(#do 'loadArgs:not:*: ' -> TT;
                                 'formalArgOf:' -> TT; E.doPT -> TQ;
                                 ' isCompositeValueObj:' -> TT;
                                 actualArg.isCompositeValueObj -> BB
                              #)
                    if);
                    
                    (true,superAdj,staticOff) -> actualArg.Qgen;
                    
                    cd.com(#do 'loadArgs:after:Qgen:' -> TT; E.doPT->TQ #);

                    (if actualArg.isNonBasicValueObj 
                        and actualArg.super.ATd.isDataItem then
                        (* actualArg is a data-item being 
                         * a (nonBasic?) ValueObj *)
                        cd.com(#do 'before:pushSize: ' -> TT;
                                 'actualArg.super.ATd.OG.isUnitValueObj:'
                                   -> TT;
                                 actualArg.super.ATd.OG.isUnitValueObj 
                                   -> BB; nl;
                                 ':actualArg.isCompositeValueObj:'->TT;
                                 actualArg.isCompositeValueObj -> BB;
                                 ' isAssign: ' -> TT; 
                                 primNo = vAssign_prim -> BB
                              #);
                        (if not actualArg.super.ATd.OG.isUnitValueObj 
                            or actualArg.isCompositeValueObj
                            then
                            (* composite valueObj or not a unitValue *)
                            (*11 -> cd.pushConst;*)
                            actualArg.objSize -> cd.pushValue;
                            (if (this(Pattern).primNo <> vAssign_prim) then
                                cd.com(#do 'pattern:loadArg:Value:dataItem:' -> TT #);
                                1 -> cd.pushConst
                            if)
                         else
                            cd.com(#do 'actualArg:UnitOne?:'-> TT; 
                                     actualArg.dopt-> TT #)
                        if)
                     else (* not NonBasicValueobj or not data-item *)
                        (if (this(Pattern).primNo = vAssign_prim) then
                            cd.com(#do 'vAssign:fArg:' -> TT; 
                                     formalArg.doPT -> TQ; #);
                            (if actualArg.super.ATd.isPattern then
                                (# srcDI: ^DataItem; ptn: ^Pattern
                                do cd.com(#do 'BINGO' -> TT #);
                                   (actualArg.super.ATd[] 
                                     -> ptn[]).getReturnDecl ->srcDI[];
                                   (if (srcDI[] <> none) 
                                       and srcDI.OG.isNonBasicValueObj
                                       then
                                       cd.com(#do 'loadArgs:assign:srcDI:rtnValueObj: '->TT;
                                                srcDI.sig.dopt -> TT #);
                                       srcDI.objSize -> cd.pushValue
                                    else cd.com(# do 'aaaa: ' -> TT; 
                                                  formalArg.dopt->TT #);
                                       (if formalArg.OG.isNonBasicValueObj 
                                           and (formalArg.OG.primNo <> value_prim) then
                                           cd.com(#do 'bbbb:isBasicV:'->TT;
                                                    formalArg.OG.isBasicValue -> BB
                                                 #);
                                           (if ptn.OG.primNo 
                                               = indexedGet_prim then 
                                               cd.com(# do 'ccc' -> TT #);
                                               srcDI.OG.objSize 
                                                 -> cd.pushValue
                            if)if)if)#)if)
                         else (* this pattern is not assignment *)
                            cd.com(#do 'formalArg:isPtn:' -> TT; 
                                     formalArg.doPT->TQ; 
                                     ':isBasicVal:'->TT; 
                                     formalArg.isBasicValue -> BB;
                                     ':valueObj:' -> TT; 
                                     formalArg.OG.isValueObj -> BB; nl;
                                     ':actArg:' ->  TT; 
                                     actualArg.dopt -> TQ;
                                     ':isBasicVal:' -> TT; 
                                     actualArg.isBasicValue -> BB 
                                  #);
                            (if formalArg.OG.isNonBasicValueObj 
                                and actualArg.isBasicValue then
                                (* in formalArg: var aValueObj 
                                 * actualArg is float or int bar(15"m") 
                                 * formalArg is a unit 
                                 * - tested by semchecker
                                 *)
                                (if actualArg.isInteger then cd.I2F if);
                                1 -> cd.pushConst
                             else
                                cd.com(#do actualArg.dopt -> TT;
                                         actualArg.label -> TT;
                                      #);
                                (if not actualArg.int2floatDone then
                                    formalArg[] 
                                      -> actualArg.checkNumberConvert
                                    (# I2F:: (#do cd.I2f #);
                                       F2I:: (# do cd.F2I #);
                                #)if);
                                (if formalArg.OG.isNonBasicValueObj 
                                    and not actualArg.isValueObj 
                                    then
                                    (* actualArg must be a pattern 
                                     * returning a value *)
                                    (*44 -> cd.pushConst;*)
                                    formalArg.objSize -> cd.pushValue;
                                    1 -> cd.pushConst
                                 else
                                    formalArg.OG.super.ATD.OG[] -> superOG[];                
                                    (if superOG.primNo = indexed_prim then
                                        (superOG[],CC[],superOG.computeVariant) 
                                          -> objTmpStack.add;
                                        cd.com(#do 'formalArg is indexed:'
                                                   ->TT;
                                                 formalArg.dopt -> TT; 
                                                 ' ' -> TT;
                                                 superOG.IS.newDescNo ->II;
                                                 nl;
                                                 actualArg.dopt -> TT;
                                                 ' ' -> TT; 
                                                 actualArg.label -> TT;
                                              #);
                                        cd.com(#
                                              do superOG.IS.newDescNo ->II;
                                                 formalArg.OG.super.ATd.dopt 
                                                   -> TT; 
                                              #);
                                        (if actualArg.bracketedListLength > 0 then
                                            actualArg.bracketedListLength 
                                              -> cd.pushConst;
                                            superOG.IS.newDescNo-> cd.mkVindexed
                                        if)
                                    if)
                    if)if)if)if);
                    cd.com(#do 'end:loadArgs:NonVirt:' -> TT; E.dopt -> TQ #);
                 #);
               actArgs: [6] ^ObjectSpecification; (* actual arguments *)
               top,argInx: @integer;
               enclosingOG: ^ObjectGenerator;
               var: ^Variant;
            do (* loadArgs is followed by invoke.
                * There are different invoke patterns for assignment,
                * general patterns, ...
                * Perhaps we should also have different loadArgs for 
                * assignment, general patterns, ...
               *)
               cd.com(#do 'isValueAssign: ' -> TT; 
                        E.ATd.primNo = vAssign_prim->BB #);
               (* OBS! In R1 := R2, := is vAssign_prim
                * We should use R1 :- R2 to get rAssign_prim
                *)
               (if OG.primNo 
                   (* Some of these are handled in invoke below
                    * May be moved to here*)
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   (* skip *)
                else 
                   E.args.scanArgs
                   (#
                   do (if (top+1 -> top) > actArgs.range then 
                          actArgs.range -> actArgs.extend 
                      if);
                      current[] -> actArgs[top][];
                   #);
                   (if OG.primNo = resume_prim then
                       cd.com(#do 'resume: ' -> TT; E.dopt -> TT; ' '->TT;
                                E.father.dopt -> TT#);
                   if);
                   scanArgs
                   (#
                   do argInx + 1 -> argInx;
                      (if argInx <= top then
                          (* can we do currentArg.LoadArg?
                           * And then perhaps special for virtual primitive
                           * and ptName? Virt is of course ptn *)
                          (if currentArg.isVirtual then
                              (* (currentArg[],actArgs[argInx][]) 
                               * -> handleVirtualArg
                               * See handleVargs instead
                               *)
                           else
                              (currentArg[],actArgs[argInx][]) 
                                -> handleNonVirtualArg
                          if)
                          (*else: E is a super as foo in foo{...} *)
                   if)#);
                   handleSuperArgs:
                     (if (argInx < top) and (OG.primNo <> resume_prim) then
                         '\n!!!! pattern:loadArgs:argInx<top:'
                           -> putline;
                         dopt -> putline;
                         (* a hack - need to scan arguments of super *)
                         argInx + 1 -> argInx;
                         (true,superAdj,staticOff) -> actArgs[argInx].Qgen;
                         restart handleSuperargs
                     if);
               if);
            #);
          load::
            (#
            do cd.com
               (#do 'Pattern:load:'->TT;OG.primNo->II; ' '->TT; dopt->TT #);
               (if OG.primNo
                // rAssign_prim
                // vAssign_prim then
                   '\n\n***** pattern:load:assign_prim: called A.store'
                     -> putline;
                   A.store
               if);
            #);
          getAdr::
            (# B: @boolean
            do cd.com(#do A.print -> TT #);
               (if isPrimitive then
                   true -> loadRec;
                else
                   true -> loadRec;
                   true -> A.isAdr
               if);
            #);
          invoke:: 
            (# 
            do cd.com(#do 'ptn:invoke: ' -> TT; useReturnValue -> BB#);
               (rec[],E[],useReturnValue,staticOff,CC[],adr[]) 
                 -> currentPtnKind.invoke 
            #);
          popReturn:
            (* perhaps this should be the same virtual as in dataItem!?
             * And do consider signature:popReturn
             *)
            (# D: ^Decl
            do (if (getReturnDecl -> D[]) <> none then
                   D.popReturn
                else 
                   cd.rpop
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);
          clear::< (# do false -> genIsDone; inner #);
          genIsDone: @boolean;
       #);
     Address: superAdr
       (* E = first exp in "R.S.Q", ie. E = "R" *)
       (# nameOfE_OG:
            (# D: ^Decl; org: ^Items
            do (if E[] <> none then
                   E.ATD[] -> D[];
                   (if false then
                       'nameOfE:' -> puttext; E.on -> putint;
                       ' ' -> put;
                       E.dopt -> putline;
                   if);
                   E.(*D.*)origin[]->org[]; 
                   (for i: E.on repeat org.origin[] -> org[] for);
                   (if false then org.encOG.dopt -> putline; if);
                   (if org.encOG.primNo = ifthen_prim then
                       org.origin[] -> org[]; 
                       (*':::'->putline; org.dopt -> putline;*)
                   if);
                   org.encOG.OGidWdNo -> T[];
                   (*T[] -> putline*)
                else
                   'EisNone' -> T[]
               if)
            exit T[]
            #);
          done: @boolean; T: ^text;
          load:: (* actually push value *)
            (#
            do (if isAdr then
                   loadAdr
                else
                   (if off > 0 then
                       cd.com(#do 'load:'->TT; this(Address).print -> TT #);
                       (if isValue then
                           (if originIsValue then
                               (if isFloat then
                                   ('',off) -> cd.fovpushg
                                else
                                   ('',off) -> cd.ovpushg
                               if)
                            else
                               cd.com(#do 'isFloat:B: '->TT; isFloat->BB #);
                               (if isFloat then
                                   ('',off) -> cd.fpushg
                                else
                                   '' -> T[];
                                   (if rec[] <> none then 
                                       rec.dopt -> T.append if);
                                   '/'-> T.put;
                                   (if E[] <>none then E.dopt->T.append if);
                                   (nameOfE_OG,off) -> cd.pushg
                               if)
                           if)
                        else
                           (if isUnique then
                               cd.com(#do 'address:load:isUnique' -> TT #);
                               cd.rdouble;
                               ('',off) -> cd.rpushg;
                               cd.rswap;
                               cd.pushNone;
                               cd.rswap;
                               ('kuk',off) -> cd.rstoreg
                            else
                               '' -> T[];
                               (if rec[] <> none then rec.dopt -> T.append if);
                               '/'-> T.put;
                               (if E[] <> none then E.dopt -> T.append if);
                               (nameOfE_OG,off) -> cd.rpushg
                           if)
               if)if)if)
            #);
          loadAdr::
            (#
            do (if off > 0 then
                   cd.com(#do 'loadAdr:'->TT; this(Address).print -> TT #);
                   (if isValue then
                       cd.com
                       (#do 'loadAdr:isValue:'-> TT; 
                          'originIsValue:'->TT; originIsValue -> BB;
                       #);
                       cd.com(# do 'isFloat:C: ' -> TT; isFloat -> BB;
                                ' isUnitVal: ' -> TT; isUnitVal -> BB;
                                ' isCompositeValueObj: ' -> TT; 
                                isCompositeValueObj->BB; 
                                (if E[] = none then ' E:"none"'->TT
                                 else
                                    ' E:"' -> TT;
                                    E.dopt -> TT; '"' -> TT
                                if);
                             #);
                       (if isUnitVal (*isFloat*) and not isCompositeValueObj then
                           (* isUnitVal should be enough, but is not!? *)
                           ('',off) -> cd.fpushg
                        else
                           (if originIsValue then
                               cd.swap;;
                               off - 1 -> cd.pushConst;
                               61 (*plus*) -> cd.op;
                               cd.swap
                            else
                               cd.com(#do 'DYT: '-> TT; descNo -> II #);
                               off -> cd.pushConst;
                               valDescNo -> cd.pushConst
                       if)if)
                    else
                       (nameOfE_OG,off) -> cd.rpushg
               if)if);
            #);
          store::
            (# mode: @integer
            do (if not done then
                   true -> done;
                   cd.com(#do 'store:'->TT; this(address).print->TT #);
                   (if off > 0 then
                       cd.com
                       (#
                       do 'isValue:' -> TT; isValue -> BB; 
                          ' isAdr:' -> TT; isAdr -> BB;
                          ' descNo: ' -> TT; descNo -> II   
                       #);
                       (if isValue then
                           (if isAdr then
                               (if descNo > 0 then
                                   cd.vpop;
                                   cd.saveAndSetThis;
                                   (* quite complex 1st arg, ex: E = P, where
                                    * P: var Point(0,0)
                                    * E.ATd.OG.super.last = Point(0,0) = X
                                    * X.ATd.OG = Point descriptor
                                    *)
                                   ((E.ATd.OG.super.last).ATd.OG.OGid
                                   ,descNo,off - 1) 
                                     -> cd.invokeVal;
                                   cd.restoreThis
                                else                                   
                                   (*(if srcIsVal then 1 -> mode if);
                                    (if destIsVal then mode + 2 -> mode if);*)
                                   (if originIsValue then 1 -> mode if);
                                   cd.com(#do 'Address:store::srcIsVal:'->TT; 
                                            srcIsVal -> BB;
                                            ' destIsVal:'->TT;originIsValue->BB;
                                            ' mode:' -> TT; mode -> II #);
                                   off -> cd.pushConst;
                                   (size,mode) -> cd.vassign
                               if)
                            else
                               (if originIsValue then
                                   cd.com(#do 'Address:store:originIsValue:'->TT #);
                                   (if isFloat then
                                       ('',off) -> cd.fovstoreg
                                    else
                                       ('',off) -> cd.ovstoreg
                                   if)
                                else
                                   cd.com(#do 'isFloat:D: ' -> TT; isFloat -> BB #);
                                   (if isUnitVal or isFloat then
                                       ('address:storeg',off) -> cd.fstoreg
                                    else
                                       (nameOfE_OG,off) -> cd.storeg
                                   if);
                           if)if)
                        else
                           cd.rswap;
                           (nameOfE_OG,off) -> cd.rstoreg
                       if)
               if)if)
            #);
          print::
            (# 
            do ':Adr:'-> T.append; 
               'off:'-> T.puttext; off -> T.putint;
               ' sz:'-> T.puttext; size -> T.putint;
               ' isF:' -> T.puttext; 
               (if isFloat then 'T'->T.putText else 'F'->T.puttext if);
               ' isUN:'->T.puttext; 
               (if isUnitVal then 'T'-> T.puttext else 'F'->T.puttext if);
               ' sprAdj:'->T.puttext; superAdj->T.putint;
               ' isUniq:'->T.puttext; 
               (if isUnique then 'T'->T.putText else 'F'->T.puttext if);
               T.newline;;
               ' isValue:' -> T.puttext; 
               (if isValue then 'T'-> T.puttext else 'F'->T.puttext if);
               ' orgIsVal:' -> T.puttext; 
               (if originIsValue then 'T'-> T.puttext
                else 'F'->T.puttext if);
               ':E:"'->T.puttext;
               (if E[] = none then 'none"'->T.puttext
                else
                   E.dopt -> T.puttext; '"' -> T.put
               if);
            #);
       enter superAdj
       exit this(Address)[]
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.on -> gorigin
        *    E1.pushOff
        *    E2.pushOff
        *    E3.invoke
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# markForCodeGen::
            (# ptn: ^Pattern; OGs: ^ObjectGenerator; E,rec: ^Exp;
               fArgIsVirtual: [6] @boolean; top: @integer;
            do cd.com(#do 'Invocation:markForCodeGen:'->TT; dopt -> TQ #);
               scanSons
               (#
               do current[] -> E[]; 
                  current.MarkForCodeGen;
                  (if not isLast then E[] -> rec[] 
                   else
                      (if isFirst then E[] -> rec[]
                  if)if);                  
                  (* We only scan args of last exp? 
                   * We may have r.foo(e1).bar(e2)
                   * Should be fixed!
                   *)
                  (if E.ATd.isPattern then
                      (if traceArgOG then
                          E.dopt -> putline; E.Atd.label -> putline;
                          '**** E.ATd: ' -> putline; E.ATd.dopt ->puthead
                      if);
                      (*0 -> top; ChemicalPlat fails if 0->top
                       * But what is going on here?
                       *)
                      E.ATd.OG.IS.scanItemArgs
                      (# 
                      do top + 1 -> top;
                         currentArg.isVirtual -> fArgIsVirtual[top];
                         (if traceArgOG then
                             '*** argNo:' -> puttext; top -> putint; 
                             ' ' ->put;
                             fArgIsVirtual[top] -> putboolean; newline;
                             currentArg.dopt -> puthead
                         if)
                      #);
                      (if (E[] <> none) and (E.args[] <> none) then
                          E.args.scanArgs
                          (# n: @integer; OGx: ^ObjectGenerator
                          do n + 1 -> n;
                             cd.com(#do 'arg:' -> TT; ' '-> TT; 
                                      current.dopt -> TQ #);
                             (if (E.ATd.primNo <> vassign_prim) 
                                 and current.isObjectGenerator then 
                                 (if not (current[] -> OGx[]).IS.isEmpty 
                                     or OGx.hasVirtualArgs
                                     then
                                     (if (*true or*) not fArgIsVirtual[n]
                                         then
                                         (if traceArgOG then
                                             '**** marking arg:label:'
                                               ->puttext; 
                                             current.label -> putline;
                                             current.dopt -> puthead;
                                             '**   of:E:label:'->putline;
                                             E.label -> putline;
                                             E.dopt -> puthead;
                                             '**   E.father.father.father:\n'
                                               ->puttext; 
                                             E.father.father.doPT 
                                               -> puthead;
                                         if);
                                         E[] -> current.markForCodeGen
                                      else
                                         current.markForCodeGen
                                     if);
                                  else
                                     current.markForCodeGen
                                 if)
                              else
                                 current.markForCodeGen
               if)#)if)if)#)
            #);       
          Qgen:: 
            (# gdb:: 
                 (# 
                 do ' useRtnV:'->TT; useReturnValue -> BB;
                    scanSons
                    (# ptn: ^Pattern; OI: ^ObjectInvocation
                    do (if (current## = ObjectInvocation##)
                           and 
                           ((current[] -> OI[]).ATD## = pattern##) then
                           OI.ATd[] -> ptn[];
                           ' descNo: ' -> TT; ptn.OG.IS.newDescNo -> II;
                           
                       if)
                    #)                                         
                 #);
               rec,E: ^Exp; T: ^Text;
               IVinx,IVlength: @integer; noOrigin: @boolean;
               needOrigin: booleanValue
                 (# IT: ^Items; Ex: ^Exp
                 do true -> value;
                    cd.com(#do 'needorigin:'-> TT; dopt -> TQ #);
                    scanSons
                    (#
                    do IVlength + 1 -> IVlength;
                       current[] -> E[]; 
                       (if E.ATd.isPattern and not E.isConstLiteral 
                           and (Ex[] = none) then 
                           E[] -> Ex[];
                           IVlength -> IVinx
                       if);
                       (* if-stmt below is superflouos?
                        * not clear why superflouos!?
                        * and what goes non here?
                        *)
                       (if not isLast then E[] -> rec[] 
                        else
                           (if isFirst then 
                               E[] -> rec[] -> Ex[];
                               IVlength -> IVinx                               
                       if)if)
                    #);
                    cd.com(#do 'needOrigin:E:'->TT; E.dopt -> TQ;
                             ' E.ATd:'-> TT; E.ATd.dopt -> TQ #);

                    (if not E.ATd.isPattern then (* DataItem *)
                        cd.com(#do 'needOrigin:dataItem:leave'->TT #);
                        leave needOrigin
                    if);
                    (if false then
                        E.ATd.desc -> IT[]; 
                        (if IT.globalRestrictionsInMain and elimOrigin then
                            cd.com(#do 'LoadOrign:no:loadOrigin: ' -> TT;
                                     IT.encOG.doPT -> TQ #);
                            false -> value
                         else
                            cd.com(#do 'doNeedOrigin:'->TT; E.dopt -> TQ #)
                        if);
                    if);
                    (if Ex[] = none then
                        'needOrigin: Ex is none: ' -> puttext; dopt -> putline;
                        leave needOrigin
                    if);
                    Ex[] -> E[];
                    Ex.ATd.desc -> IT[]; 
                    (if IT.globalRestrictionsInMain and elimOrigin then
                        cd.com(#do 'Ex!LoadOrign:no:loadOrigin: ' -> TT;
                                 IT.encOG.doPT -> TQ #);
                        (if value and false then
                            '!!! needOrigin:conflict:A: ' -> puttext; 
                            dopt -> puttext;
                            ' E: ' -> puttext; E.dopt -> puttext;
                            ' Ex: ' -> puttext; Ex.dopt -> putline
                        if);
                        false -> value;
                     else
                        (if not value then
                            '!!! needOrigin:conflict:B: ' -> puttext; 
                            dopt -> puttext;
                            ' E: ' -> puttext; E.dopt -> puttext;
                            ' Ex: ' -> puttext; Ex.dopt -> putline
                        if); 
                        cd.com(#do 'doNeedOrigin:Ex:'->TT; Ex.dopt -> TQ #)
                    if);
                    not value -> noOrigin
                 #);
               done: @boolean
            do (* for P1.X := P2.Y,
                * we need no origin for P1 (and X!?)
                * we need adress of P1 to be added address of X to get embedded
                * adr of X
                * In R.foo, if foo has globalRestrictions we shall not load adr of R
                * How about: R.S.T.Q ? Q globalRestrictions, or globals?
                *)
               cd.bcPos -> beginBCP;
               cd.com(#do 'Invocation:qgen:superAdj: '->TT; superAdj->II #);
               (* The code below is ugly - we should not test for 
                * BracketedExp, but just call a virtual method
                * Same for isConstant check
                * Also needOrigin must be cleaned up
                * Alltogether we should rewrite computeAdr to include
                * handling of constants, patterns with no origin 
                * and bracketedExp
                *)
               scanSons
               (# BE: ^BracketedExp
               do cd.com(#do 'checkFor:BE:'->TT; current.label->TT; 
                           ' '->TT; current.dopt -> TT #);
                  (if 'BracketedExp' -> (current.label).equalNCS then
                      current[] -> BE[];
                      (if BE.noOfSons > 1 then
                          cd.com(#do 'BE:sons: ' -> TT; BE.noOfSons -> II #);
                          (useReturnValue,superAdj,staticOff) -> BE.qgen;
                          true -> done;
               if)if)#);
               (if not done then
                   isConstant(# isConst:: (#do V -> cd.pushConst; true->done#)#)
               if);
               (if not done then
               (# A: ^Address; off,argNo: @integer; isResume: @boolean
               do (if needOrigin then
                      cd.com(#do 'IV:needOrigin;superAdj:'->TT; superAdj->II #);
                      superAdj
                        -> Address
                        -> computeAdr -> (rec[],E[],A[]);
                   else
                      cd.com(#do 'IV:no:needOrigin:E: ' -> TT; E.dopt -> TQ #);
                  if);
                  (if (E.ATd.primNo = vAssign_prim) and (A[] <> none) then 
                      A.off -> off 
                  if);
                  cd.com(#do 'IV:after:computeAdr:superAdj:'->TT; superAdj->II; 
                           (if A[] <>  none then A.print -> TT if); nl;
                           'rec: ' -> TT; rec.dopt -> TQ; 
                           'E: ' -> TT; E.dopt -> TQ;
                           'isValueAssign: ' -> TT;
                           E.ATd.primNo = vAssign_prim -> BB; 
                        #);
                  (* case bar(L1) where L1 is a unit
                   * we should not push L2.magnitude
                   * but push L1 as a valueObj
                   * For E = bar(L1), the load of L1 happens in E.loadArgs 
                   * For X := exp and foo(exp), E.loadArgs load exp
                   * E.invoke generates assigmnet for := and invocation for foo
                   *)
                  cd.com(#do'IV:before:loadArgs:superAdj='->TT; superAdj->II #);

                  (superAdj,off,CC[]) -> E.loadArgs -> isResume;

                  (if isResume and false then
                      '**** IV:isResume: ' -> puttext; dopt -> puttext;
                      ' rec: ' -> puttext;
                      (if rec[]<> none then rec.dopt -> puttext if);
                      ' E: ' -> puttext; E.dopt -> putline;
                  if);
                  cd.com(#do 'IV:after:loadArgsOf:' -> TT; E.dopt -> TQ;
                           (if A[] <> none then A.print -> TT if);
                        ' useRtnV: ' -> TT; useReturnValue -> BB
                        #);
                  (if false then
                      '**** IV:' ->puttext; dopt-> puttext;
                      ' ' -> put; E.dopt -> putline;
                      noOrigin -> putBoolean; ' ' -> put; IVinx -> putint;
                      ' ' -> put; IVlength -> putint; newline;
                  if);
                  (if noOrigin and (IVinx < IVlength) then
                      (* we come here if E does not need an origin
                       * For IV = I1.I2.,,,.In, E  = Ej, j = IVinx, n = IVlength
                       *)
                      (rec[],E[],true,staticOff,CC[],A[],isResume)
                        -> E.invoke
                   else
                      (rec[],E[],useReturnValue,staticOff,CC[],A[],isResume)
                        -> E.invoke;
                  if);
                  cd.com(#do 'FISK:' -> TT; E.dopt -> TQ; #);
                  (* if E does not need  an origin we have to call
                   * invoke for Ej+1,...,En
                   * But qGen,needOrigin,isConst,computeAdr must be rewritten!
                   *)
                  scanSons
                  (# found: @boolean; Ey: ^Exp;
                  do (if found then
                         cd.com(#do'invoke:tail: ' -> TT; current.dopt -> TQ #);
                         (superAdj,off,CC[]) -> (current[]->Ey[]).loadArgs;
                         (E[],current[],not isLast (*useReturnValue*)
                         ,staticOff,CC[],A[],false)
                           -> Ey.invoke;
                     if);
                     (if current[] = E[] then true -> found if);
                  #);
                  cd.com(#do 'invoke:after:E.invoke:' -> TT; E.dopt -> TQ #)
               #)if);
               cd.bcPos -> endBCP
            #);
          isConstant: BooleanValue
            (* Not good enough for 
             * V: obj 12; W: obj 87; X: obj V + W;
             * we dont push 12 for V, but 87 for W
             *)
            (# isConst:< (# V: @integer enter V do inner #);
               T: @text 
            do cd.com(#do 'isConstant: '->TT; label->TQ; ' '->TT; dopt->TQ #);
               L:
                 scanSons
                 (# E: ^Exp; DI: ^SuperDataItem
                 do current[] -> E[];
                    (if E.ATd.isDataItem (*or E.ATd.isModuleItem*) then
                        E.ATD[] -> DI[];
                        (if DI.isConst then
                            (if isLast then
                                (if DI.OG.isBasicValue then
                                    (if (DI.OG.super.last->E[]).isConstLiteral then
                                        DI.OG.super.dopt -> T.puttext;
                                        cd.com
                                        (#
                                        do 'const literal: ' -> TT;
                                           T[] -> TT;
                                           ' ' -> TT;
                                           (DI.OG.super.last).label -> TT
                                        #);
                                        T.setPos; T.getInt -> isConst
                                    if)
                                 else
                                    leave L
                            if)if)
                         else
                            cd.com(#do 'not const: ' -> TT; E.dopt -> TT; 
                                     DI.dopt->TT #);
                            leave L
                        if)
                     else
                        leave L
                    if)
                 #)
            #);
          computeAdr:
            (* R.S.foo(exp).Q
             * X := Y + (Z +117)
             * aLine.aPoint.X
             * (4) @if ascii.isLetter(ch1) || ascii.isDigit(ch2) :then ...
             *)
            (# A,recA: ^Address; E,rec,pRec: ^Exp; j: @integer; 
               loadRec,orgIsVal: @boolean; ptn: ^Pattern;
               superAdj: @ integer
            enter A[]
            do cd.com(#do 'computeAdr:A.superAdj:'->TT; A.superAdj->II;
                        dopt->TQ #);
               A.superAdj -> superAdj;
               (* for (4) above, A.superAdj may be non-zero when computing 
                * address of ascii.isLetter(ch1) || ascii.isDigit(ch2)
                * We must thus save A.superAdj to be used when calling 
                * rec.loadArgs below to load ch1.
                * If || ascii.isDigit(ch2) is not present, loadArgs is not 
                * called here but in IV:qGen
                *)
               scanSons
               (# org: ^Items
               do rec[] -> pRec[]; E[] -> rec[]; current[] -> E[];
                  cd.com
                  (#do 'computeAdr:'->TT; j+1->j->II; ':rec:'->TT; 
                     (if rec[]<> none then rec.dopt->TQ else 'none'->TQ if);
                     ' E:'->TT; E.dopt -> TQ;  
                     (if A.E[] <> none then ' A.E:' -> TT; A.E.dopt->TQ if);
                     nl; A.print -> TT;
                  #);
                  (if isFirst then
                      E[] -> rec[];
                      E.pushThis; (* why E? we should pushThis for thisObj!
                                   * So just cd.pushThis?
                                   *)
                      (if E.ATd.isPattern 
                          and (origin->org[]).encOG.isValueObj then  
                          (* origin is a value object;
                           * E is a pattern invoked in the mainpart
                           * of the value object;
                           * we thus must push an extended origin for E
                           * with holder ref, offset to value obj and
                           * descNo of the actual value pattern.
                           * The offset must be 1 (one) since the bytecodes
                           * pushg, etc adds the offset stored in 
                           * thisObj = holder
                           * We do not know the descNo of the value pattern
                           * here, since the actual value pattern may
                           * be a subpatttern of the one we are generating
                           * code for here.
                           * The actual descNo is saved by a subsequent 
                           * invokeVal nd pushed by a possible invoke
                           * or sendv
                           *)
                          cd.com(#do 'computeAdr:orgIsValue:'->TT; 
                                   E.dopt -> TQ  #);
                          cd.pushValId;
                          (* descNo supplied by invokeVal, invoke, sendv 
                           * as mentioned above 
                           *)
                      if);
                      (A.superAdj,none) 
                        -> E.loadOrigin -> (rec[],E[],orgIsVal);
                      (* we should ignore rec and E - defined above 
                       * And A.superAdj should be eliminated *)
                      inner computeAdr;
                      A[] -> E.getAdr -> (loadRec,A[]);
                      (* really getOffSet of E.ATd *)
                      cd.com(#do 'E.on:' -> TT; E.on -> II #);
                      (if (E.on > 0) or (A.superadj > 0) then
                          cd.com(#do 'beforeIsValueObj:E:'->TT; E.dopt->TQ;
                                   ' ATd:'->TT; E.ATd.dopt -> TQ;
                                #);
                          (E.ATd.enclosingObjectGenerator).isValueObj 
                            -> A.originIsValue
                          (* should probably be for each receiver in
                           * R.S.foo(exp).Q, i.e. R, S and foo
                           *)
                      if);
                      cd.com(#do 'computeAdr:isFirst:' -> TT; A.print->TT #)
                   else
                      (* mutex.cmpAndSwap 
                       * rec = mutex, cmpAndSwap = E
                       *)
                      (if (E.ATd.primNo <> rAssign_prim) 
                          and (E.ATd.primNo <> vAssign_prim) then
                          cd.com(#do 'E:notAssign:'->TT; E.dopt->TT #);
                          A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                          (* really getOffSet of E.ATd *)
                          (if E.ATd.isPattern then
                              E.ATd[] -> ptn[];
                              cd.com(#do 'ptn.isUnitValueObj:'->TT; 
                                       ptn.OG.isUnitValueObj -> BB;
                                       ' isFloat:E:' -> TT; 
                                       ptn.OG.isFloat -> BB #);
                              (if ptn.OG.isUnitValueObj 
                                  or ptn.OG.isFloat then
                                  (# UN: ^NewProperty
                                  do ptn.OG.getUnitProp -> UN[];
                                     (if (UN[] <> none) 
                                         and 
                                         ('%unit "U*U"' -> (UN.doPT).equal)
                                         then
                                         cd.com(#
                                               do 'Generic:unit:' -> TT;
                                                  UN.dopt -> TT; nl;
                                                  'ptn: ' -> TT;
                                                  ptn.dopt -> TQ; 
                                               #);
                                         false -> A.isUnitVal    
                                     if)
                                  #)
                               else
                                  (if true then 
                                      false -> A.isUnitVal 
                                   else false -> A.isFloat if)
                          if)if);
                          (if loadRec then
                              (* In R.foo, rec = R, E = foo
                               *    P.print, rec = P, E = print
                               *    R.S,      rec = R, E = S
                               * E is a pattern or dataItem 
                               * For ascii.isLetter(ch1) 
                               * || ascii.isDigit(ch2)
                               * see comment at the beginning of computeAdr
                               *)
                              cd.com(#do'computeAdr:loadArgs:superAdj:D:'->TT;
                                             superAdj -> II #);
                              (superAdj,0,none) -> rec.loadArgs;
                              (* Perhaps a combined invoke & getAdr *)
                              
                              (* A is the address of E - not of rec!!!!!! *)
                              
                              (pRec[],E[],true,0,none,recA[],false)
                                -> rec.invoke;
                          if);
                       else
                          cd.com(#do 'computeAdr:isAssign:rec: '-> TT; 
                                   rec.dopt -> TQ;
                                   ' E:' -> TT; E.dopt -> TQ #); 
                          cd.com(#do A.print -> TT #)
                      if)                 
                  if);
                  (if isLast then
                      cd.com(#do 'computeAdr:isLast:E: '->TT; E.dopt->TQ #)
                  if)
               #);
            exit(rec[],E[],A[])
            #);          
          loadOrigin:
            (# usereturnValue: @boolean;
               staticOff,superAdj: @integer;
               rec,E,nE: ^Exp; CC: ^CallChain;
            enter(useReturnValue,staticOff,superAdj,CC[])
            do cd.com(#do 'Invocation:loadOrigin:'-> TT; doPT->TT #);
               (* could rec be thisObject for first E1 in E1.E2.E3 ?*)
               (* Perhaps the other way around
                * e1 -> rec
                * rec -> e2.invoke
                * e2 -> rec
                * rec -> e3.invoke
                *)
               scanSons
               (# gdb: debug
                    (#
                    do 'Invocation:loadOrigin:scan: ' -> TT;
                       current.doPT -> TQ;
                    #);
                  T: ^ Text; hadAssign,orgIsVal: @boolean
               do current[] -> E[]; 
                  gdb;
                  (if isFirst then 
                      E.pushThis;
                      (superAdj,CC[]) -> E.loadOrigin -> (rec[],E[],orgIsVal)
                  if); 
                  (* For X: = { R:  = { ... q: ...} ... R.X }
                   * stack[top] = origin = X 
                   * add offset to R or push(ref(R))
                   *)
                  cd.com(#do 'loadOrigin:afterIsFirst:'-> TT; current.doPT -> TQ #);
                  (if not isLast then
                      E[] -> rec[];
                      (if (next -> nE[]).ATd.primNo <> rAssign_prim then
                          cd.com(#do'loadOrigin:loadArgs:superAdj:E:'->TT;
                                         superAdj -> II #);
                          (superAdj,staticOff,CC[]) -> E.loadArgs;
                          (rec[],nE[],true,staticOff,CC[],none,false) -> E.invoke
                       else
                          cd.com(#do 'loadOrigin:assign:'-> TT; #);
                          true -> hadAssign
                      if)
                   else
                      cd.com(#do 'loadOrigin:last:' -> TT; current.doPt -> TQ #);
                      (if hadAssign (*E.ATd.primNo = rAssign_prim *) then
                          cd.com(#do 'loadOrigin:last:assign:rec:'->TT; rec.dopt -> TT;
                                   ':E:' -> TT; E.doPT -> TT #);
                       else
                          cd.com(#do 'loadOrigin:last:NOTassign:rec:'->TT; rec.doPT -> TT;
                                   ':E:'->TT; E.doPT -> TT #);
                          (if not isFirst then
                              (rec[],rec[],true,staticOff,CC[],none,false)
                                -> rec.invoke
                  if)if)if)
               #);
               (* S.simple_bar.c1 := 'x'
                *     rec = c1, E = ':='
                *     No pushOff for c1 = rec, since E = ':='
                *     no loadAsReceiver for c1 = rec
                * S.simple_bar.c1 + 1
                *     rec = c1, E = ':='
                *     pushOff for c1 = rec, but empty action
                *     loadAssReceiver for c1, since simple
                * S.simple_bar.simple_fisk;
                *     rec = simple_bar, E = simple_fisk
                *     pushOff for simple_bar = rec
                *     loadAsReceiver for simple_bar, but empty action
                *)
            exit(rec[],E[])
            #);
          goInclude:<
            (*    %include Q.R
             *    ...
             *    %include S.T
             *    ...
             *    U
             * means: Q.R,S.T.U
             *)
            (# org: ^Items; onx: @integer; orgIsVal: @boolean;
               MI: ^ModuleItem; id: ^lexem; OI: ^ObjectInvocation; 
               originDone: @boolean
            enter(org[],onx)                       
            do cd.com(#do 'viaIncl:on:' -> TT; on -> II; dopt -> TT;
                        ' org:'->TT; org.dopt -> TQ; 
                     #);
               (if true then
                   (if (last-> OI[]).ptnId.viaIncl[] <> none then
                       cd.com(#do 'goInclude:furtherInclude' -> TT #);
                       (org[],on + 1) 
                         -> OI.ptnId.viaIncl.goInclude -> (org[],orgIsVal);
                       true -> originDone
                    else
                       cd.com(#do 'goInclude:endOfIncludeChain'->TT; #);
                   if);
                   scanSons
                   (# OI: ^ObjectInvocation
                   do current[] -> OI[];
                      (if isFirst and not originDone then
                          (onx + OI.on + 1,OI[]) 
                            -> org.goOrigin  -> (org[],orgIsVal);
                      if);
                      cd.com(#
                            do 'include:pushOff:' -> TT; 
                               (OI.ATd[]->MI[]).MD.newOff -> II; #);
                      (OI.ATd.sig.id[],(OI.ATd[]->MI[]).MD.newOff) -> cd.rpushg
                   #)
                else
                   (if (last-> OI[]).ptnId.viaIncl[] = none then
                       cd.com(#do 'goInclude:endOfIncludeChain'->TT; #);
                       (onx + on + 1,OI[]) -> org.goOrigin  -> (org[],orgIsVal);
                    else
                       cd.com(#do 'goInclude:furtherInclude' -> TT #);
                       (org[],on + 1) 
                         -> OI.ptnId.viaIncl.goInclude -> (org[],orgIsVal)
                   if);
                   ATd[] -> MI[];
                   (MI.MD.sig.id[],MI.MD.newOff) -> cd.rpushg
               if)
            exit(org[],orgIsVal)
            #);
       #);
     adjustOrigin:
       (# originOff: @integer; OGid: ^text
       enter(originOff,OGid[])
       do cd.com(#do 'AdjustOrigin:originOff:'  -> TT; originOff -> II #);
          (if (originOff > 0) then
              (OGid[],originOff) -> cd.rpushg
          if)
       #);
     ObjectInvocation::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# 
          markForCodeGen::
            (#
            do cd.com
               (#do 'ObjectInvocation:markForCodeGen:'-> TT; dopt -> TQ;
                        ' ATd:' ->TT; ATd.dopt -> TQ #); 
               ATd.markForCodeGen
            #);
          pushThis:: (# do ATd.pushThis #);
          getAdr::
            (# gdb:: 
                 (#do ':superAdj:'->TT; adr.superAdj->II; ':on:'->TT; on->II#);
               Ax: ^Address; OG: ^ObjectGenerator
            do (*superAdj -> A.superAdj;*)
               cd.com(#do 'OI:getAdr:KIKS:'->TT; adr.print-> TT#);
               adr[] -> Ax[];
               (if (on > 0) or (Ax.E[] = none) then
                   this(ObjectInvocation)[] -> Ax.E[];
                   (* tricky - in R.S.Q, R.on may be > 0, but S.on = Q.on = 0
                    * and the latter must not override on from R and E = R!
                    *)
               if);
               Ax[] -> ATd.getAdr -> (loadRec,adr[]);
               cd.com(#do 'OI:getAdr:KOKS:'->TT; adr.print-> TT#);
            #);
          loadOrigin::
            (# gdb::(# do ':on:'->TT; on -> II #);
               org: ^Items; T: @text; MI: ^ModuleItem
            do (if ATD.primNo
                // 0 
                // indexed_prim 
                // string_prim
                // stringGet_prim // indexedGet_prim
                // immutable_prim then 
                   (if superAdj < 0 then 
                       '**** superAdj < 0' -> puttext; dopt -> putline;
                       (if on > 0 then 
                           (- superAdj,'origin-x') -> AdjustOrigin;
                           (on - 1,this(ObjectInvocation)[]) 
                             -> (origin[]->org[]).goOrigin
                             -> (org[],orgIsVal)
                       if)
                    else
                       (superAdj,(origin[]->org[]).encOG.OGidWdNo)
                         -> AdjustOrigin;
                       (on,this(ObjectInvocation)[]) 
                         -> (origin[]->org[]).goOrigin
                         -> (org[],orgIsVal)
                   if);
                   (if ptnId.viaIncl[] <> none then
                      (org[],0) -> ptnId.viaIncl.goInclude
                   if)
                // this_prim then
                   (* Must check that argument is the name of an enclosing 
                    * object or the name of the superpattern of an
                    * enclosing object.
                    * For %this foo, ON = %this.origin, A.super.ON = foo.origin
                    *)

                   (superAdj,'origin-z') -> AdjustOrigin;
                   args.scanArgs(* only one argument in %this foo *)
                   (# A: ^ObjectSpecification
                   do current[] -> A[];
                      cd.com
                      (#do 'this_prim:'->TT; A.dopt -> TT;
                         ':super.on:'-> TT; A.super.ON -> II #);
                      (A.super.on - 1,this(ObjectInvocation)[])
                        -> (origin[]->org[]).goOrigin
                        -> (org[],orgIsVal)
                   #)
                // thisCore_prim then 
                   (* perhaps not in loadOrigin, but in execute/ATd.invoke *)
                   ('thisCore',thisCore_prim) -> cd.callPrim
                // thisCoreId_prim then
                   ('thisCoreId',thisCoreId_prim) -> cd.callPrim
               if);
               (* Actually rec = origin*n, E = this(OG) *)
               this(ObjectInvocation)[] -> E[] -> rec[]
            #);
          load::
            (#
            do cd.com
               (#do 'OI:load:'->TT; dopt->TT; ':unit: '->TT; unit.T[]->TT#);
               (rec[],A[]) -> ATd.load
            #);
          handleVargs::
            (# actArgs: [6] ^ObjectSpecification; (* actual arguments *)
               top: @integer; ptn: ^pattern; 
               enclosingOG: ^ObjectGenerator; OGx: ^ObjectSpecification;
               formalArg: ^Pattern; actualArg: ^ObjectSpecification; 
               descNo: @integer; 
               mkCom:
                 (# msg: ^text
                 enter msg[]
                 do cd.com
                    (#do msg[]->TT;  dopt -> TQ; nl;
                       'formalArg: '-> TT; formalArg.dopt -> TQ; nl;
                       'actualArg: '-> TT; actualArg.dopt -> TQ; nl;
                       formalArg.off -> II;
                       ' (actualArg.desc).newDescno: '->TT; descno ->II;
                       ' (OGx.desc).newDescNo: '->TT; (OGx.desc).newDescNo->II;
                       ' stubDescNo: '->TT; stubDescNo->II
                    #);
                 #);
            do (if (ATd[]->ptn[]).OG.primNo
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   leave handleVargs
               if);
               args.scanArgs
               (#
               do (if (top+1 -> top) > actArgs.range then 
                      actArgs.range -> actArgs.extend 
                  if);
                  current[] -> actArgs[top][];
               #);
               ptn.scanArgs
               (# argInx,dNo: @integer; stubN,OGidx: ^text; zero: @boolean
               do argInx + 1 -> argInx; 
                  (if (argInx <= top) and currentArg.isVirtual then
                      currentArg[] -> formalArg[];
                      actArgs[argInx][] -> actualArg[]; 
                      cd.com(#do 'args: ' -> TT; currentArg.dopt->TQ;  
                               actualArg.dopt->TQ ; ptnid.dopt -> TT; #);
                      (* can we do currentArg.LoadArg?
                       * And then perhaps special for virtual primitive
                       * and ptName? Virt is of course ptn *)
                      L:
                      (if currentArg.isVirtual then
                          currentArg[] -> formalArg[];
                          actArgs[argInx][] -> actualArg[];
                          (if newVirtH then
                              father.father[] -> OGx[];
                              (if false then
                                  '**** encOGx: ' -> puttext; 
                                  OGx.dopt -> putline;
                              if);
                              (if false and ((desc).primNo = indexed_prim) then 
                                  leave  L
                              if);
                              (if actualArg.IS.isEmpty then
                                  QnewDesc -> dNo;
                                  (none,actualArg[]) -> mkStubName -> stubN[];
                                  (if false then
                                      '**   bind: ' -> puttext; 
                                      StubN[] -> puttext;
                                      ' dNo: ' -> puttext; dNo -> putint; 
                                      ' off: '-> puttext;
                                      formalArg.off -> putint; 
                                      ' newDescNo: ' -> puttext;
                                      (OGx.desc).newDescNo -> putint; newline;
                                  if);
                                  (formalArg.off,dNo,(OGx.desc).newDescNo,'xx') 
                                    -> CD.vdtTableAt;
                                  (stubN[],dNo,actualArg[],OGx.IS[]) 
                                    -> objStubStackX.add
                               else
                                  (actualArg.desc).newDescno -> descNo;
                                  (if false then
                                      cd.com(#do 'arg:hasItems: ' -> TT #);
                                      '**   descNo: ' -> puttext; 
                                      descNo -> putint;
                                      ' (OGx.desc).newDescNo:' -> puttext;
                                      (OGx.desc).newDescNo -> putint; 
                                      ' OGx.IS.newDescNo: ' -> puttext;
                                      OGx.IS.newDescNo -> putint;
                                      ' ' -> put;
                                      (OGx.super.last).ATd.OG.IS.newDescNo 
                                        -> putint;
                                      newline;
                                      '**   ATd: '->putline;
                                      (OGx.super.last).ATd.dopt -> putline;
                                      '**   OGx: ' -> putline;
                                      OGx.dopt -> putline; '---' -> putline;
                                      (OGx.desc).encOG.dopt -> putline;
                                      true -> zero
                                  if);
                                  L:
                                    OGX.super.scanSons
                                    (# OI: ^ObjectInvocation
                                    do (if zero then current.dopt ->putline if);
                                       current[] -> OI[];
                                       (if zero then OI.args.dopt ->putline if);
                                       (if args[] = OI.args[] then
                                           (if zero then true -> putboolean;
                                               ' ' -> puttext
                                           if);
                                           OI.ATd.OG.IS.newDescNo -> dNo;
                                           OI.ATd.OG.OGid -> OGidx[];
                                           (if zero then 
                                               dNo -> putint;
                                               newline;
                                               OI.ATd.dopt -> putline
                                           if);
                                           leave L
                                       if)
                                    #);
                                  (if stubDescNo > 0 then
                                      (formalArg.off,descno,stubDescNo,'yy')
                                        -> cd.vdtTableAt;
                                   else
                                      (formalArg.off,descno
                                      ,(OGx.desc).newDescNo
                                      ,(actualArg.desc).encOG.OGid)
                                        -> cd.vdtTableAt;
                                  if)
                              if)
                           else
                              (if true
                               // (1 -> ptnId.T.inxGet) = '#' then
                                  '**** handleVargs: ' -> puttext; 
                                  ptnid.dopt -> putline;
                                  'handleVargs:#X: ' -> mkCom;
                                  father.father[] -> OGx[]; 
                                  (OGx.desc).newDescNo -> descNo;
                                  (if OGx.super.ATd[]<> none then
                                      OGx.super.ATd.OG.IS.newDescNo -> descNo 
                                  if);
                                  (formalArg.Off,actualArg.vDescNo,descNo,'qq')
                                    -> cd.vdtTableAt;
                                  (formalArg.Off,actualArg[])
                                    -> (OGx[]-> enclosingOG[]).XaddB;
                               // (desc).primNo = indexed_prim then 
                                  'handleVargs:Indexed:ignored: ' -> mkCom;
                               else
                                  '**** Vbingo: ' -> puttext; 
                                  stubDescNo -> putint;
                                  newline;
                                  (actualArg.desc).newDescno -> descNo;
                                  father.father[] -> OGx[]; 
                                  'handleVargs:X: ' -> mkCom;
                                  (if stubDescNo > 0 then
                                      (formalArg.off,descno,stubDescNo,'ww')
                                        -> cd.vdtTableAt;
                                   else 
                                      (formalArg.off,descno
                                      ,(OGx.desc).newDescNo,'ee')
                                    -> cd.vdtTableAt;
               if)if)if)if)if)#)
            #);
          invoke::
            (# gdb::
                 (#do ' rec:'->TT; 
                    (if rec[]=none then 'none'->TQ else rec.dopt -> TQ if)
                 #);
              
               ptn: ^pattern; stubDescNo: @integer
            do (* rec is a dataItem and there will thus be exactly 
                * one variant for its OG *)
               (if atd## 
                // pattern## then
                   atd[] -> ptn[];
                   cd.com(#do 'OI:invoke:isPtn:descNo'->TT; 
                            ptn.OG.IS.newdescno -> II #);
                // module## then
                   'module' -> cd.comment
                // moduleItem## then
                   'moduleItem' -> cd.comment
               if);
               (if (adr[] <> none) and (E.ATd[] <> none)  then
                   (if E.ATD.OG[] <> none then
                       E.ATd.OG.IS.isUnique -> adr.isUnique;          
                       cd.com(#do 'E.ATd: ' -> TT; E.ATd.sig.doPT -> TQ;
                                'unique: ' -> TT; 
                                E.ATd.OG.IS.isUnique -> BB #);
                    else
                       (* Probably E.ATd is a ModuleItem, 
                        * then OG is not define *)
                       (if not (E.ATd## = ModuleItem##) then
                           E[] -> warning
                           (# do 'E.ATd.OG is none: "' -> msg; 
                              E.dopt -> msg; 
                              '" E.ATd: "' -> msg; E.ATd.doPT -> msg; 
                              '"' -> msg #)
                   if)if);
                   cd.com(#do'adr:'->TT; (if adr[] <> none then 
                            adr.print->TT if)#);
                   E[] -> adr.E[]
               if);
               
               (if hasVirtualArgs then
                   (* we must use newVirtH here *)
                   (if true then
                       '**** oi:genStubv:'->putline; dopt -> puthead;
                       ' ' -> put; useReturnValue -> putBoolean; newline
                   if);
                   (ATd[],'',QnewDesc->stubDescNo,ATd.OG.IS.newDescNo,0,0)
                     -> ObjStubStack.add;
                   stubDescNo -> ATd.OG.vDescNo;
                   (* the code here does not seem to handle more than one arg *)
                   (if ATd.isPattern then stubDescNo -> handleVargs if);
                   ('stub',stubDescNo,4,0,false) ->  cd.invoke;
                   (if useReturnValue then
                       (ATd.OG[],'stub') -> pushOut
                   if);
                else cd.com
                   (#do 'HEST: '->TT; doPT -> TQ; 'E:' -> TT; E.dopt -> TQ;
                      ' rec:' -> TT; (if rec[] <> none then rec.dopt -> TQ if);
                      ' useRtnV:' -> TT; useReturnValue -> BB
                   #);
                   cd.com(#do (if adr[] = none then
                                  'adr:none' -> TT
                               else
                                  adr.print -> TT 
                         if)#);
                   (rec[],E[],useReturnValue,staticOff,CC[],adr[],isResume) 
                     -> ATd.invoke;
               if);
               cd.com
               (#do 'OI:invoke:'->TT; dopt->TT; ':unit: '->TT; unit.T[]->TT;
                  ' convFactor: ' -> TT; convFactor -> FF #);
               (if convFactor <> 0 then
                   convFactor -> cd.pushFloatConst;
                   112 -> cd.op
               if)
            #);
          loadArgs:: 
            (# gdb:: (# do 'staticOff:' -> TT; staticOff -> II #);
            do cd.com(#do'OI:loadArgs:superAdj:F:'->TT; superAdj -> II #);
               cd.com(#do 'args: ' -> TT; args.dopt -> TT;
                        args.scanArgs(#do ' hasArg: ' -> TT #); atd.label ->TT#);
               cd.com(#do dopt -> TT; ' ' -> TT; ATd.dopt -> TT #);
               (if ATd.primNo = resume_prim then
                   cd.com(#do 'OI:loadArgs:resume: ' -> TT; dopt -> TT #)
               if);
               (this(Exp)[],superAdj,staticOff,CC[]) -> ATd.loadArgs -> isResume
            #);
          bracketedListLength:: 
            (# 
            do (if ATd.OG.primNo // indexed_prim // dumpObj_prim then
                else
                   cd.com(#do 'OI:bracketedListLength: ' -> TT;
                            dopt -> TQ; ' ATd.OG.primNo: '-> TT;
                            ATd.OG.primNo -> II #);
                   1 -> value 
               if)
            #);
       #);    

     IfThen::
       (# markForCodeGen::
            (#
            do cond.markForCodeGen; thenPart.markForCodeGen;
            #);
          Qgen::
            (# Tlab, Flab, exitLab: @ LabelHandler.label
            do (if false then
                   '**** IfThenElse:Qgen ' -> puttext; dopt -> putline;
               if);
               (*118 -> cd.pushConst; cd.vPop;*)
               Tlab.new;
               Flab.new;
               exitLab.new;
               (true,0,staticOff) -> cond.Qgen;
               (Tlab,Flab) -> cd.jmpFalse;
               Tlab -> cd.defLab;
               (false,0,staticOff) -> thenPart.Qgen;
               Flab -> cd.defLab;
            #);
          invoke:: 
            (# 
            do (if false then
                   '**** IfThenElse:Invoke: ' -> putline;
               if);
               Qgen
            #)
       #);
     IfThenElse::
       (# markForCodeGen::
            (#
            do cond.markForCodeGen; 
               thenPart.markForCodeGen;
               elsePart.markForCodeGen;
            #);
          Qgen::
            (# Tlab, Flab, exitLab: @ LabelHandler.label
            do (if false then
                   '**** IfThenElse:Qgen ' -> puttext; dopt -> putline;
               if);
               117 -> cd.pushConst;
               cd.vPop;
               Tlab.new;
               Flab.new;
               exitLab.new;
               (true,0,staticOff) -> cond.Qgen;
               (Tlab,Flab) -> cd.jmpFalse;
               Tlab -> cd.defLab;
               (false,0,staticOff) -> thenPart.Qgen;
               exitLab -> cd.jmp;
               Flab -> cd.defLab;
               (false,0,staticOff) -> elsePart.Qgen;  
               exitLab -> cd.defLab
            #);
          invoke:: 
            (# 
            do (if false then
                   '**** IfThenElse:Invoke: ' -> putline;
               if);
               Qgen
            #)
       #);
     BracketedExp::
       (* a := b + (c * d)
        *     execute c * d
        * (foo).x
        *    loadOrigin foo
        * (foo(e1,e2)).x
        *    execute foo(e1,e29?
        * (%this P).suspend
        *     loadOrigin?
        * (E1)
        *    (E1).pushThis
        *    (E1).loadOrigin
        *    (E1).invoke
        *    rec -> E.invoke
        * (E1).E2
        *    
        * (R.S).foo
        * (R.bar(e1,e2,)).foo  
        * (ch = 'i') && (S <> none)
        * Do we always execute exp in (exp) and (exp).foo?
        * We should thus not just call load origin!?
        * What about (exp), (R.foo)
        * Look at gen: for (exp) we call loadOrigin and then execute
        *   for (exp).foo we call loadOrigin(exp) and then exe on foo
        *   but exe(exp) is not called
        *   How do we in loadOrigin ensure that exe(exp) is called when needed?
        * 
        * E1.(E2)
        * E1.(E2).E3
        *)
       (# markForCodeGen:: (#do IV.markForCodeGen #);
          Qgen:: 
            (# 
            do (* we dont come here 
                * but we do for indexed literal like (e1,e2,e3) *)
               (if false then
                   '**** BracketedExp:qgen:'->puttext; dopt -> putline;
               if);
               (if noOfSons = 1 then
                   (useReturnValue,superAdj,staticOff) -> IV.Qgen ;
                else
                   scanSons
                   (#do (useReturnValue,superAdj,staticOff) -> current.Qgen #)
               if)
            #);
          getAdr::
            (# rec,E: ^Exp
            do cd.com(#do 'BracketedExp:getAdr:'->TT;adr.print -> TT #);
               adr[] -> IV.computeAdr -> (rec[],E[],adr[]);
               cd.com(#do 'BracketedExp:getAdr:after:computeAdr:'->TT; 
                        adr.print->TT#);
               cd.com(#do'getAdr:loadArgs:superAdj:G:'->TT;
                              adr.superAdj -> II #);
               (adr.superAdj,0,none) -> E.loadArgs; 
               (* do we need staticOff here? *)
               (* (rec[],E[],true,0,0,none,adr[],false) -> E.invoke;*)
            #);
          pushThis:: 
            (* Skip, since loadOrigin below includes pushThis *)  
            (# #);
          loadOrigin:: 
            (# off: @integer; A: ^Address
            do (* OBS! useReturnValue, staticOff must be handled! *)
               superAdj -> Address -> IV.computeAdr -> (rec[],E[],A[]);
               cd.com(#do 'BE:loadOrigin:E:'->TT; E.doPT->TT #);
            #);
          loadArgs:: 
            (* Skip, since loadOrigin includes loadArgs *)              
            (# 
            do cd.com(#do 'BracketedExp:loadArgs: ' -> TT; dopt -> TT #);
            #);
          invoke::
            (# 
            do cd.com(#do 'Bracketed invoke: ' -> TT; dopt->TT #);
              (if noOfSons = 1 then
                   (useReturnValue,0,staticOff) -> IV.Qgen ;
               else
                  doPP -> putline;
                  scanSons
                   (#do (useReturnValue,0,staticOff) -> current.Qgen #)
               if)
            #)
       #);
     Const::
       (# Qgen:: (# do invoke #);
          getAdr::
            (# 
            do this(Const)[] -> adr.E[]
            #);
          invoke:: 
            (# V: @integer; F: @Real
            do T.setpos; T.getInt -> V;
               (if convFactor = 0 then
                   V -> cd.pushConst;
                else
                   V * convFactor -> cd.pushFloatConst;
                   (* Note that the type is now Float ! *)
               if)
            #);
          load:: (# do T.setpos; T.getReal -> cd.pushConst #);
          bracketedListLength:: (# do 1 -> value #);
       #);
     FloatConst::
       (# Qgen:: (# do invoke #);
          getAdr::
            (# 
            do this(FloatConst)[] -> adr.E[];(* 2 -> adr.size???*)
            #);
          invoke:: 
            (# 
            do (if false then               
                   '****invoke ' -> puttext; dopt -> putline;
                   ' unit: ' -> puttext; unit.T[] -> putline;
               if);
               T.setpos; T.getReal-> cd.pushFloatConst; 
               (if convFactor <> 0 then
                   convFactor -> cd.pushFloatConst;
                   112 -> cd.op
               if)
            #);
          load:: (#do invoke #);
          bracketedListLength:: 
            (# 
            do 1 -> value;
               '!!!! Float:bracketedListLength may not work! ' -> puttext;
               dopt -> putline
            #);
       #);
     CharObj::
       (# Qgen:: (* Never called? *) (# do invoke #);
          pushThis:: (##);
          getAdr::
            (# 
            do this(CharObj)[] -> adr.E[]
            #);
          invoke:: 
            (# ch: @char
            do (if T.length = 1 then
                   1 -> T.inxget -> cd.pushConst 
                else
                   (if 2 -> T.inxget -> ch
                    // 'n' then 10 -> cd.pushConst
                    // 't' then 9 -> cd.pushConst
                    // '\\' then '\\' -> cd.pushConst
                    // '\'' then '\'' -> cd.pushConst
                    else
                       'CharObj:Special symbol: ' -> puttext; ch -> putint;
                       ':' -> put; '"' -> put; ch -> put; '"' -> put;
                       newline;
                       ch -> cd.pushConst
                   if)
               if)
            #);
          bracketedListLength:: (# do 1 -> value #);
       #);
     getStringPlus:
       (# D: ^Decl
       do L:
            stringDecl.OG.IS.scanSons
            (# 
            do (if current.isDecl then
                   current[] -> D[];
                   (if ('+' -> D.sig.id.equal) then

                       D.markForCodeGen;
                       leave L
                   if)
               if)
            #)
       exit D[]
       #);
     StringObj::
       (# markForCodeGen:: (# do scanSons(#do current.markForCodeGen #)#);
          Qgen:: 
            (* Never called ? *)
            (# do 'String:gen:' ->puttext; doPT -> putline; invoke #);
          loadOrigin::
            (* In "hello".foo, "hello" plays the same role as R in R.foo,
             * i.e. we must generate a pushText "hello"
             * For an exp "Hello", 
             * loadOrigin then also generates a pushText "hello"
             * Invoke is called only for the last exp in R1.R2.exp 
             * and 'just store the string!
             *)
            (# 
            do cd.com(#do 'StringObj:loadOrigin:' -> TT; dopt->TT; #);
               (if not elimOrigin then 
                   (T[],0) -> cd.pushText; 
                   'StringObj:LoadOrigin:bingo: ' -> puttext; T[] -> putline 
               if);                
               this(StringObj)[] -> E[] -> rec[]
            #);
          getAdr:: (#do this(StringObj)[] -> adr.E[]; (*T[]->cd.pushText*)#);
          invoke:: 
            (# stringDescNo,n: @integer; (* no of embedded invocations in T*)
               start,end: [4] @integer; 
               prev: @integer;
               doAdd: @boolean;
               plusDecl: ^Pattern;
               getPlusRes:
                 (#
                 do L:
                      plusDecl.OG.IS.scanAllItemDecls
                      (# DI: ^DataItem
                      do (if currentDcl.isOutArg then
                             currentDcl[] -> DI[];
                             (if true
                              // DI.OG.isBasicValue then
                                 (T[],DI.newOff) -> cd.pushg;
                              // DI.OG.isValueObj then
                                 '**** out arg: ' -> puttext; DI.dopt ->putline;
                                 DI.newOff -> cd.pushConst
                              else
                                 (T[],DI.newOff) -> cd.rPushg;
                             if);
                           leave L
                      if)#)
                 #);
            do
               getStringPlus -> plusDecl[];
               (stringDecl.desc).newDescNo -> stringDescNo;
               T[] -> scanForBrace
               (# pos: @integer
               do (*'*** qgen got brace: ' -> puttext; inn[] -> putline;*)
                  n + 1 -> n;
                  first -> start[n];
                  last -> end[n];
                  (*first -> putint; ' ' -> put; last -> putint; newline;
                  (1,first - 1) -> T.sub -> puttext; '#' -> put;
                  (first,last) -> T.sub -> putline;*)
               #);
               scanSons
               (# S: ^Text; n: @integer; 
               do n + 1 -> n;
                  (prev + 1,start[n] - 1) -> T.sub -> S[];
                  (*cd.com(# do 'pushText: ' -> TT; S[] -> TQ #);*)

                  (S[],stringDescNo) -> cd.pushText;
                  (if doAdd then
                      (plusDecl.sig.id[],plusDecl.OG.getDescNo,
                      plusDecl.OG.IS.objSize,0,true) 
                        -> cd.invoke;
                      getPlusRes;
                  if);
                  (*cd.com(#do 'execute' -> TT;
                           (start[n],end[n]) -> T.sub -> TT #);
                   current.dopt  ->  cd.comment;*)
                  (true,0,0) -> current.Qgen;
                  (plusDecl.sig.id[],plusDecl.OG.getDescNo
                  ,plusDecl.OG.IS.objSize,0,true)
                    -> cd.invoke;
                  getPlusRes;
                  end[n] -> prev;
                  true  -> doAdd
               #);
               (*cd.com
               (#do 'pushText: ' -> TT; (prev + 1,T.length) -> T.sub -> TQ #);*)
               ((prev + 1,T.length) -> T.sub,stringDescNo)  -> cd.pushText;
               (if doAdd then                    
                   (plusDecl.sig.id[],plusDecl.OG.getDescNo
                   ,plusDecl.OG.IS.objSize,0,true) 
                     -> cd.invoke;
                   getPlusRes;
               if);
               (if not useReturnValue then cd.rPop if)
            #);
       #);
     pushOut:
       (# OGx: ^ObjectGenerator; id: ^text
       enter(OGx[],id[])
       do L:
            (if OGx.isValueObj then
                '**** pushOut:OG is value: ' -> puttext; 
                OGx.dopt -> putline;
             else
                OGx.IS.scanAllItemDecls
                (# DI: ^DataItem; 
                do (if currentDcl.isOutArg then
                       currentDcl[] -> DI[];
                       (if true
                        // DI.OG.isBasicValue then
                           (if DI.OG.isFloat then
                               (id[],DI.newOff) -> cd.fpushg;
                            else
                               (id[],DI.newOff) -> cd.pushg;
                           if)
                        // DI.OG.isValueObj then
                           DI.newOff -> cd.pushConst;
                           DI.OG.IS.newDescNo -> cd.pushConst
                        else
                           (id[],DI.newOff) -> cd.rPushg;
                       if);
                       leave L
                   if);
                   (* callee is on rtop of rStack *)
          #)if)
       #);
     genVstub:
       (# stubN,stubT: ^text; dNo: @integer; OG: ^ObjectSpecification;
          ptn: ^Pattern; encIS: ^Items;
          restartLab,leaveLab: @LabelHandler.label;
       enter(stubN[],dNo,OG[],encIS[])
       do (if false then
              '*** genVstub: ' -> puttext; stubN[] -> puttext; 
              ' dNo: ' -> puttext; dNo -> putint; newline;
              OG.dopt -> puthead; '----' -> putline;
              encIS.dopt -> puthead
          if);
          
          (stubN[],dNo,false,'Object',0) -> cd.classDef
          (#
          do (1,encIS.encOG.OGidWdNo) -> addR; (* origin for vStub *)
             (2,OG.OGidWdNo) -> addR(* to store ref to obj generated by stub *)
          #);
          
          objectDecl[] -> ptn[];
          
          (OG.OGidWdNo,OG.getDescNo,false,'Object',0) -> cd.classDef;
          
          (stubN[],dNo,false,ptn.OG.IS.newDescNo
          ,encIS.newOriginOff ,encIS.encOG.OGidWdNo,0,false,true) -> cd.class;
          
          labelHandler.init; 
          restartLab.new;
          leaveLab.new;
          restartLab -> cd.defLab;
          
          (* last arg is isValueObj, to be fixed!*)
          cd.com(#do 'Load origin:OG.isVirtualArg:'->TT; 
                   OG.isVirtualArg->BB #);
          
          (stubN[],dNo,encIS.encOG.OGid,encIS.newDescNo,OG.OGidWdNo) 
            -> cd.prepareStub -> stubT[];
          
          (if OG.isVirtualArg then
              (OG.super.on + 1,OG.super[]) -> encIS.goOrigin;
           else
              (if OG.super.ATd[] <> objectDecl[] then
                  (OG.super.on,OG.super[]) -> encIS.goOrigin;
          if)if);
          cd.com
          (#do 'OG.super.on/descNo:' -> TT; 
             OG.super.on->II; OG.getDescNo->II; #);
          (if true then
              (* arg 2 = staticOff,do we need it?*)
              (if OG.IS.isEmpty and not OG.super.hasVirtualArgs then
                  (OG.super.Atd.OG[],0,true) -> callInvoke
               else (* never happens! *)
                  (OG[],0,true) -> callInvoke
              if)
           else
              (encIS.sig.id[],OG.getDescNo,OG.IS.objSize,0,true)
                -> cd.invoke
          if);
          leaveLab -> cd.defLab;
          
          (* move refTo thisObj to caller stack
           * This rstoreg seems odd/wrong? WHy?
           * we seem to store  ref to thisObj in vStub
           * and the push it on the caller stack!?
           *)
          cd.pushThis;
          (stubT[],2) -> cd.rstoreg;
          cd.setThisStack;
          cd.pushThis;
          (stubT[],2) -> cd.rpushg;
          
          'D' -> cd.rtn;
          (3(*objSize*),false,encIS.newBasicProp.OSDvisibility) 
            -> cd.endClass;
          (* mkLLVMvirtualDefs for thisClass!
           * But a vStub has no virtuals, so superflous? *)
          cd.mkLLVMvirtualDefs
          (# vName::
               (#
               do '*** vStub: vName no binding' -> putline
               #)
          #);
          cd.com(#do 'vdt:a:dNo:'->TT; dNo -> II; 
                   ' newDescNo: '->TT; encIS.newDescNo->II
                #);
       #);
     genStub:
       (* do we need to generate and store an origin here as for genVstub? *)
       (# atD: ^Pattern; N: ^Text; 
          descNo,stubDescNo,superDescNo,originOff,originDescNo: @integer
       enter(atD[],N[],descNo,superDescNo,originOff,originDescNo)
       do ('Stub',descNo,false,ATd.OG.IS.newDescNo,1,'Object',originDescNo
          ,false,false) 
            -> cd.class;
          cd.com(#do Atd.dopt -> TQ #);
          ATd.OG.iS.newDescNo -> cd.vdtTableCopy;
          superDescNo -> cd.toSuper;
          'S' -> cd.rtnInner;
          (16,false,0) -> cd.endClass
       exit stubDescNo
       #);     
     mkStubName:
       (# sig: ^signature; OGx: ^ObjectSpecification; T,id: ^text
       enter(sig[],OGx[])
       do 'Vstub#' -> T[];
          (if sig[] <> none then
              sig.id[] -> id[] -> T.append;
           else
              'S' -> id[] -> T.append
          if);
          '#' -> T.put;    
          OGx.vDescNo -> T.putint;
          (*'**** mkStubName:B: ' -> puttext; T[] -> putline*)
       exit T[]
       #);
     ObjStubStackX: @
       (# add:
            (# gen:
                 (#
                 do (stubN[],dNo,OG[],encIS[]) -> genVstub;
                 #);
               stubN: ^text; dNo: @integer; OG: ^ObjectSpecification;
               encIS: ^Items;
            enter(stubN[],dNo,OG[],encIS[])
            do (if (top + 1 -> top) > OIS.range then
                   OIS.range -> OIS.extend
               if);
               this(add)[] -> OIS[top][];
            #);
          gen:
            (#
            do (for  i: top repeat
                    OIS[i].gen
               for);
               0 -> top
            #);
          OIS: [12] ^add; top: @integer
       #);
     ObjStubStack: @
       (# add:
            (# gen:
                 (#
                 do (atD[],N[],stubDescNo,superDescNo,originOff,originDescNo)
                    -> genStub
                 #);
               atD: ^Pattern; N: ^Text; 
               stubDescNo,superDescNo,originOff,originDescNo: @integer
            enter(atD[],N[],stubDescNo,superDescNo,originOff,originDescNo)
            do (if (top + 1 -> top) > OIS.range then
                   OIS.range -> OIS.extend
               if);
               this(add)[] -> OIS[top][];
            exit stubDescNo
            #);
          gen:
            (#
            do (for  i: top repeat
                    OIS[i].gen
               for)
            #);
          OIS: [12] ^add; top: @integer
       #);
     
     ObjTmpStack: @
       (# item: 
            (# OG: ^ObjectGenerator; 
               CC: ^CallChain; var: ^Variant
            enter(OG[],CC[],var[])
            exit this(item)[]
            #);
          add:
            (# OG: ^ObjectGenerator; 
               CC: ^CallChain; var: ^Variant
            enter(OG[],CC[],var[])
            do (if (top+1-> top) > OTL.range then 
                   OTL.range -> OTL.extend;
                   done.range -> done.extend
               if);
               (if false then
                   'ObjTmpStack:add: ' -> puttext; OG.ogID -> puttext;
                   ' ' -> put; OG.IS.newDescno ->putint; newline;
               if);
               (if OG[] = StringDecl.OG[] then
                   cd.lcom(#do ' String: ' -> TT; OG.IS.newDescNo -> II#);
               if);
               cd.com(# do 'ObjTmpStack:add:'->TT; 
                        (if var[] <> none then
                            ':genDone:'->TT; var.GenDone -> BB; ' '-> TT;
                        if);
                        (if OG.sig[] <> none then
                            OG.sig.doPT -> TQ; ':' -> TT;
                        if);
                        OG.doPT -> TQ;
                     #);
               (OG[],CC[],var[]) -> item -> OTL[top][];
               (* Does IS.newDescNo correspond to var? Probably no!?*)
            #);          
          next:
            (# inx: @integer; B: @boolean
            do 0 -> inx; false -> B;
               Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        cd.com(# do 'objTmpStack:next: ' -> TT;
                                 ' : done:'->TT; done[inx] -> BB;
                                 ' :var.genDone: ' -> TT;
                                 (if OTL[inx].var[] <> none then
                                     OTL[inx].var.genDone -> BB
                                 if)
                              #);
                        (if not OTL[inx].var.genDone then
                            cd.com(# do 'objTmpStack:next:genClass:' -> TT;
                                     OTL[inx].OG.IS.newdescno -> II; 
                                     ':top:' ->TT ;
                                     OTL[inx].OG.Qvariants.top -> II;
                                  #);
                            (OTL[inx].CC[],OTL[inx].var[]) 
                              -> OTL[inx].OG.genClass;
                        if);
                        restart Loop
                    if);
                 #)
            exit B
            #); 
          OTL: [10] ^Item; top: @integer;
          done: [10] @boolean
       #);
     markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^TopNode;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if false then
                       '\nModule: ' -> puttext; md.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).newDescNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   true -> md.markModule;
                   (if md.origin[] <> none then
                       md.NewOff -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genStubs:
       (# genMain:
            (# restartLab,leaveLab: @LabelHandler.label;  
            do ObjectGenerator -> QnewDesc -> mDescNo;
               ('main',mDescNo,false,1,0,'Object',0,false,false) -> cd.class;
               labelHandler.init; 
               restartLab.new;
               leaveLab.new;

               restartLab -> cd.defLab;
               cd.pushThis;
               (if false then
                   'TopModule: ' -> puttext;
                   markIncludes.topModule.sig.doPT -> putLine;
                   'Main: ' -> puttext; main.doPt -> putline
               if);
               ('BETAworld',(markIncludes.topModule.desc).newDescno
               ,(markIncludes.topModule.desc).objSize,0,true) 
                 -> cd.invoke
               (# topSuperId::
                    (#
                    do (markIncludes.topModule.desc).encOg.OGidWdNo 
                         -> superId[]
                    #)
               #);
               cd.stop; (* We should generate stop here and not in betaVM *)
               (* The objSize of main is set to 2 but perhaps not needed?
                * Was needed by qenv before an empty ObjectGenerator was 
                * generated for main *)
               leaveLab -> cd.defLab;
               'D' -> cd.rtn;
               (2,false,0) -> CD.endClass;
               
               (if markIncludes.main## <> Module## then
                   '\n\n***** Only Modules can be executed *****\n\n'
                     -> putline
               if)
            #);
          genThreadStub:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('ThreadStub',descNo,false,descNo,0,'Object',0,false,false) 
                 -> cd.class;
               (false,false) -> cd.actions;
               ('ThreadStub','D') -> cd.call;
               cd.stop;
               (1,false,0) -> CD.endClass;               
            #);
          genEventProcessor:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('EventProcessor',descNo,false,1,0,'Object',0,false,false) 
                 -> cd.class;
               cd.stop; (* we should generate stop here and not in betaVM *)
               (1,false,0) -> CD.endClass;               
            #);                   
       do genMain;
          (if not emitLLVM then 
              genEventProcessor;     
              genThreadStub;
          if);
       #);
     mDescNo: @integer;
     mainDescNo:: 
       (# 
       do mDescNo -> value (* ad hoc *);
       #);
     (* cd: @ObjectCode; moved to abstractSyntaxTree for debugging purposes *)
     runTimeDescs:: (# do descs[] -> rtDescs[] #);
     descs: ^RunTimeDescriptors;
     BC,BCllvm: @File;
     emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs: @boolean; ch: @integer
  do '**** GENERATOR ****' -> putline;      
     (if emitLLVM then
         newFeature -> cd.newFeature;     
         (FN[],'.ll') -> mkAuxName -> BC.name;
         ('tmp.xbeta','.ll') -> mkAuxName -> BCllvm.name;
         BCllvm.openWrite;
         (BCllvm[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs) -> cd.init;
      else
         (FN[],'..s') -> mkAuxName -> BC.name;
         (BC[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs) -> cd.init;
     if);
     BC.openWrite;
     'QBETA'-> cd.comment;
     
     labelHandler.init;
     0-> ObjTmpStack.top;
     main[] -> markIncludes;     

     (* Module::Qgen puts OG on ObjTmpStack *)
     (* rootModule = BETAworld must have descNo = 1 
      * - no longer the case *)
     (# ptn: ^Pattern; OGx: ^ObjectGenerator
     do rootModule.markForCodeGen;
        objectDecl.markForCodeGen;
        (* Pattern Object is special and not reached during a by-need scan
         * but must be allocated
         *)
        (*(objectDecl[] -> ptn[]).OG.computeVariant;*)
        (*true -> (ptn.OG[]->OGx[]).marked *)
     #);
     getStringPlus;
     rootModule.classDef;
     L:
       (# B: @ boolean
       do false -> B;
          ObjTmpStack.next or B -> B;
          (* Eliminate boolean and fix test for objTmpStack.isEmpty *)
          (if B then
              restart L 
          if)
       #);
     objStubStack.gen;
     genStubs;
     '**** REQUIRES ****' -> putline;
     rootModule.importRequires;
     rootModule.checkRequires;
     
     (if stringDecl[] <> none then
         (if (stringDecl.desc).newDescNo = 0 then
             rootModule[] 
               -> SemanticError(#do 'StringDecl.newDescNo = 0!' -> msg #)
          else
             (stringDecl.desc).newDescNo -> CD.descs.textDescNo
         if)
      else
         rootModule[] -> SemanticError(#do 'StringDecl not found!' 
                                           -> msg #)
     if);
     (*  (if StructureRefDesc[] <> none then
      *          StructureRefDesc.newDescNo -> CD.descs.structureRefDescNo
      *       else
      *          rootModule[] 
      *            -> SemanticError(#do 'StructureRefDesc not found!' 
      * -> msg #)
      *    if);
      *)
     
     cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)
     true -> descs.newAlloc;
     cd.close;
     (if emitLLVM then
         (*(0,fromBeginning) -> BCllvm.setpos;*)
         ';;; Start of LLVM\n' -> BC.puttext;
         BCllvm.close;
         BCllvm.openRead;
         (*CD.LLVMstructs[] -> BC.puttext;*)
         'target triple = "i686-pc-windows-cygnus"\n' -> BC.puttext;
         cd.typeInfo.printStructs;
         CD.LLVMstructs[] -> BC.puttext;
         'declare noalias i8* @malloc(i64)\n' -> BC.puttext;
         'declare noalias i32* @allocIndexed(i32,i32)\n' -> BC.puttext;
         'declare noalias i32 @arrayLength(i32*)\n' -> BC.puttext;
         'declare noalias i32* @allocString(i8*, i32)\n' -> BC.puttext;
         'declare i32 @puts(i8* nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @putCh(i32 nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @putHex(i32 nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @dumpHex(i32 nocapture, i32 nocapture) nounwind\n' 
         'declare void @notImpl(i32 nocapture) nounwind\n' 
           -> BC.puttext;
         
         copy:
           (if not BCllvm.eos then
               BCllvm.get -> ch;
               (if ch <> ascii.cr then ch -> BC.put; if);
               restart copy
           if);
         BCllvm.close
     if);
     BC.close
  #)

