ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qvariants';
INCLUDE '../VM/objectcode';
BODY 'qgeneratorBody';
---lib:attributes---
generator: variants
  (# traceModules: (# exit false #);
     Module::
       (# markForCodeGen::
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                    if)
                 exit M[]
                 #);
               M: ^Module;
            do DI.markForCodeGen;
               (if (encModule -> M[]) <> none then
                   M.markForCodeGen
               if)
            #);
          Qgen:: 
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                    if)
                 exit M[]
                 #);
               M: ^Module; var: ^Variant
            do (DI.sig.id[],newDesc.noOfDescs) -> cd.newComponent;
            #);       
          findNextImp:: (# do bcp -> DI.OG.IS.findNextImp -> impx[] #);
       #);
     ModuleItem::
       (# markForCodeGen:: (#do (if MD.isIncluded then MD.markForCodeGen if)#);
          Qgen::
            (#
            do (if MD.isIncluded then
                   (if traceModules then
                       'Module included: ' -> puttext; sig.doPT -> putline;
                   if);
                   ('ModuleItem:gen',sig.dopt) -> cd.com2;
                   (if MD.inMainPath then
                       MD[] -> mainPathModule[]
                    else
                       (useReturnValue,superAdj,staticOff) -> MD.DI.Qgen
                   if)
                else
                   (if traceModules then
                       'Module not included: ' -> puttext; sig.doPT -> putline
               if)if)
            #);
          getAdr::
            (#
            do A[] -> MD.DI.getAdr -> (loadRec,A[])
            #);
          pushThis:: (# do cd.pushThis #);
          invoke:: (# do 'ModuleItem:invoke:'-> cd.comment; MD.DI.invoke #);
          store:: (# do '\nModuleItem:store'->putline #);
          popReturn:: (# do '\nModuleItem:popReturn'->putline #);
          findNextImp:: (# do bcp -> md.findNextImp -> impx[] #);          
       #);
     DataItem::
       (* Cases
        *    C1: = integer(12)
        *    C2: = integer
        *    C3: = Fool
        *    C4: = Fool -- singular
        *       ...
        *    V1: ? integer(12)
        *    V2: ? integer
        *    V3: ? Fool
        *    V4: ? Fool -- singular
        *       ...
        *)
       (# markForCodeGen::
            (# 
            do cd.com(#do 'DataItem:markForCodeGen:'->T; sig.id[]->T;
                        ':descNo:'->T; OG.IS.newDescNo -> I; 
                        ':OG.primNo:'->T; OG.primno -> I; ' ' -> T;
                        ':'->T; doPT->T;
                     #);    
               OG.markForCodeGen
            #);
          Qgen:: 
            (# gdb:: (##);
               T: @text
            do (if isVirtualObject then
                   (*  '\***DataItem:qGen:virtual object: ' -> puttext;
                    dopt ->putline;*)
               if);
               (if true 
                // OG.isSimpleValue then
                   (* C1,C2,V1,V2 *)
                   (if true 
                    // 'FunctionOI' -> ((OG.super.last).label).equal
                    // 'BinaryOI' -> ((OG.super.last).label).equal
                    // 'ConstLiteral' -> ((OG.super.last).label).equal
                    // 'String:' -> ((OG.super.last).label).equal
                       then
                       (* pretty ad hoc - to handle 
                        * X: = integer(7)
                        * X: ? 7
                        * X: = a + b
                        * and avoid calling OG.Qgen for 
                        * X: = integer
                        * Cf the discussion of #foo versus foo 
                        *)
                       (true,0,this(DataItem).NewOff) -> OG.Qgen;
                       cd.pushThis;
                       'dataitem:store:B' -> cd.comment;
                       'off: ' -> T.puttext; off -> T.putint;
                       ' NewOff: ' -> T.puttext; NewOff -> T.putint;
                       T[] -> CD.comment;
                       (sig.id[],this(DataItem).NewOff) -> cd.storeg
                   if);
                // (OG.primNo = String_prim) and isConst then
                   (* Could be  V: = elm where elm:< Object *)
                   (true,0,this(DataItem).NewOff) -> OG.Qgen;
                   cd.pushThis;
                   (sig.id[],this(DataItem).NewOff) -> cd.rstoreg
                else
                   (* C3,C4,V3,V4 *)
                   (* All obbjects/patterns being embedded must be handled by
                    * Alloc and gen aince we must know the size *)
                   (if isConst or not OG.IS.isEmpty or isValue then
                       (* X: = Foo or 
                        * Singular T: = P{...} 
                        * C3,C4,V4 *)
                       (if origin[] <> none then 
                           cd.bcPos -> beginBCP;
                           cd.com
                           (# ptn: ^pattern; E: ^Exp; OI: ^ObjectInvocation
                           do 'DataItem:gen:'-> T; sig.id[] -> T;
                              OG.super.last -> E[];
                              (if E## = objectInvocation## then 
                                  (if ((E[] ->  OI[]).ATD## = pattern##) then
                                      (E[] ->  OI[]).ATD[] -> ptn[];
                                      ' superDescNo: ' -> T; ptn.OG.IS.newDescNo -> I;
                                      ' top: ' -> T; ptn.OG.Qvariants.top -> I;
                           if)if)#);
                           (false,0,this(DataItem).NewOff) -> OG.Qgen;
                           cd.bcPos -> endBCP;
                        else 
                           (* A module object - why special handling? 
                            * Apparenly cd.bcPos is not defined here!?
                            *)
                           cd.com(#do 'dataItem:gen:PG.IS.isEmpty:'-> T; sig.id[] -> T#)
                       if);
                       (if isValue then 
                           (if traceEmbedding then
                               '**** Embed value: size: ' -> puttext;
                               (if not OG.IS.isEmpty then
                                   OG.IS.qsize[1 (*OG.IS.thisVar.thisVarNo*)] 
                                     -> putint; 
                                else
                                   (# ptn: ^pattern
                                   do OG.super.ATd[] -> ptn[];
                                      ptn.OG.IS.qsize[1 (*OG.IS.thisVar.thisVarNo*)] 
                                        -> putint;
                                   #)
                               if);
                               ' at:' -> puttext; newOff -> putint; ' ' -> put;
                               dopt -> putline;
                       if)if);
                       (* else V3 - just a qualifcation; 
                        * see also the discussion of #foo versus foo *)
                       (* Could be S: ?elm where elm:< Object -- no code gen *)
                   if)
               if)
            #);
          pushThis:: (# do cd.pushThis #);
          getAdr::
            (# E: ^Exp; originIsValue: @boolean
            do cd.com(#do 'DI:getAdr:newOff:'->T; newOff -> I; ':isValue:'->T; isValue-> B #);
               cd.com(#do 'A.isValue:' -> T; A.isValue -> B #);
               cd.com(#do A.print -> T; ' '  -> T; dopt -> T #);
               (if OG.isSimpleValue or isValue then
                   (if not A.isValue then
                       true ->  loadRec;
                       A.E[] -> E[]; A.originIsValue -> originIsValue;
                       0 -> Address -> A[]; 
                       E[] -> A.E[]; originIsValue -> A.originIsValue;
                       newOff -> A.off;
                       OG.isSimpleValue or OG.isValue -> A.isValue
                    else
                       (if A.off > 0 then
                           newOff - 1 + A.off -> A.off;
                        else
                           newOff -> A.off
                       if);
                       OG.isSimpleValue or OG.isValue -> A.isValue
                   if)
                else                   
                   true -> loadRec;
                   0 -> Address -> A[];
                   newOff -> A.off
               if)
            #);
          invoke::
            (* called when not receiver - i.e. value to be pushed *)
            (# gdb:: (##)
            do (if OG.isSimpleValue or OG.isValue then 
                   cd.com(#do 'DI:invoke:simpleValue;off:' -> T; newoff -> I #);
                   (if (E[] <> none) then
                       cd.com(#do 'DI:invoke:E_not_none'->T #);
                       (if (E.ATd.primNo <> cmpAndSwap_prim) then
                           (* May happen for V := 117 where := is assignment 
                            * - no offset shall be pushed for V 
                            * since V is assigned afterwards
                            * For R ++ 117 offset for R should be pushed 
                            * since it is origin
                            *) 
                           cd.com(#do 'DI:invoke:adr<>none:call:load:' -> T; 
                                    adr.print -> T #);
                           adr.load
                        else
                           off -> cd.pushConst
                       if)
                    else
                       cd.com(#do 'DI:invoke:E=none' -> T#);
                       (if adr[] <> none then 
                           adr.load
                        else
                           (sig.id[],NewOff) -> cd.pushg
                       if)
                   if)
                else
                   cd.com(#do 'DI:invoke:E_is_none'->T #);
                   (* Could be S: ? elm where elm:< Object *)
                   cd.com(#do 'DI:invoke:off:' -> T; newoff -> I #);
                   (if adr[] <> none then 
                       adr.load
                    else
                       (* '\n***DI:Invoke:adr=none:'->puttext;
                        * sig.dopt -> putline;
                        *)
                       (if E[] <> none then E.dopt->putline; if);
                       (sig.id[],NewOff) -> cd.rpushg
                   if)
               if)
            #);
          store::
            (* Called from Signature::StoreParameters *)
            (# OGx: ^ObjectGenerator; var: ^Variant
            do cd.com(#do 'dataitem:store:' -> T; ':off:'-> T; newOff -> I;
                        (if isVirtualObject then ':isVirtualObject:' -> T if);
                        ' "'->T; dopt -> T; '"' -> T
                     #);
               (if OG.isSimpleValue then 
                   (sig.id[],NewOff) -> cd.storeg
                else
                   (if not noSwap then cd.rswap if); 
                   (* Could be S: ?elm where elm:< Object *)                   
                   (sig.id[],NewOff) -> cd.rstoreg
               if)
            #);
          popReturn::
            (#
            do (if OG.isSimpleValue then 
                   cd.vpop
                else
                   (* could be S. ?elm where elm:< object*)
                   cd.rpop
               if)
            #)          
       #);
     Signature::
       (# Qgen::
            (# 
            do (* TST/RemoteExp fails at      
                *    Bar(ch + 2).foo(ch + 2).print
                * if we call args.gen
                *)
               (false,0,0) -> args.Qgen
            #); 
          storeParameters:
            (#
            do scanArgsReverse
               (# D: ^Decl
               do (if not (currentPar[] -> D[]).isVirtual then
                      cd.pushThis;                      
                      true -> currentPar.store
                  if)
               #)
            #);
          pushReturnValues:
            (#
            do (if not (theObjectGenerator).isValue then
                   cd.setThisStack
               if);
               (if val[] <> none then
                   val.scanSons
                   (# D: ^Decl
                   do current[] -> D[];
                      cd.pushThis;
                      D.invoke
                   #)
                else
                   cd.pushThis;
               if)
            #);
          popReturn:
            (# 
            do (if val[] <> none then
                   val.scanSons
                   (# D: ^Decl
                   do (current[] -> D[]).popReturn
                   #)
                else
                   cd.rpop
               if)
            #);
          getReturn:
            (* Quite similar to semchecker:signature:getQual, 
             * which return an objectGenerator.
             * getReturn returns a Decl
             * May be unified!?
             *)
            (# D: ^Decl; ptn: ^Pattern
            do (if val[] <> none then 
                   val.scanSons
                   (#
                   do current[] -> D[]
                   #)
                else 
                   father[] -> ptn[];
                   (if (ptn.OG.superPtn -> ptn[]) <> none then 
                       ptn.sig.getReturn -> D[]
               if)if)
            exit D[]
            #)
       #);
     Arguments::
       (# Qgen::
            (#
            do scanArgs
               (#
               do (if traceGeneric then
                      current.doPT -> putline;
                      current.label -> putline;
                  if);
                  (false,0,0) -> current.Qgen 
               #)
            #);
       #);
     ObjectGenerator::
       (# marked: @boolean;
          markForCodeGen::
            (# markPrimElse: BooleanValue(# <<SLOT doMarkPrim:doPart>> #);
               OGs: ^ObjectGenerator; ptn: ^Pattern
            do (if not marked and markPrimElse then
                   true -> marked;
                   cd.com(#do 'OG:markForCodeGen:'-> T; dopt -> T; #);
                   (if (super[] <> none) and not super.isEmpty then
                       (if not (super.last).ATd.isPattern then
                           leave markForCodeGen
                       if);
                       (super.last).ATd[] -> ptn[];
                       (if ptn[] <> objectDecl[] then
                           cd.com(#do 'OG:markSuper:'->T ; super.dopt -> T #);
                           super.markForCodeGen; 
                   if)if);
                   (if isObjectDesc then
                       cd.com(#do 'OG:markIS:'->T; doPT -> T #);
                       IS.markForCodeGen;
                       (OGid,sig[],this(ObjectGenerator)[],super[],NONE,computeVariant)
                         -> objTmpStack.add;
                    else
                       cd.com(#do 'IS.isEmpty:'->T; doPt -> T #);
               if)if)
            #);
          computeVariant:
            (* OG.Qgen is called for a singular object
             * We thus only have one variant
             * This variant will propagate to superpatterns
             *)
            (# contextOG: ^ObjectGenerator;
               var,V: ^Variant
            enter contextOG[]
            do (*'----computeVariant:'->putline; dopt -> putline; *)
               (if contextOG[] = none then 
                   this(ObjectGenerator)[] -> contextOG[] if);
               cd.com(#do 'ComputeVariant:A:' -> T; OGid -> T #);
               Qvariants.new -> var[];                 
               
               (* this(OG) is not sufficient 
                * For 
                *    Lrecord.insert(Record(...))
                * we need Lrecord.OG
                *)
               (contextOG[],var[]) -> Qvariants.scanObjectRefs;
               (* We have a Variant of OG; 
                * if var.top = 0, there are no data-items depending on 
                * virtual Object (Later to be replaced by Any)
                *
                * Check that var[] does not already existt
                * var returned below may differ from var above *)
               Qvariants.checkIfTopIsNew -> V[];
               (if var[] = V[] then
                   cd.com(#do 'var is new:'->T; 'top: '-> T; Qvariants.top -> I;
                            'var.thisVarNo:'-> T; var.thisVarNo -> I #);
                   (var.thisVarNo,none) -> Qalloc;
                   cd.com(#do 'computeVariant:newDescNo:'->T; IS.newDescNo -> I;
                            'IS:'->T; IS.doPT -> T #);
                else
                   cd.com(#do'var is not new:'->T #);
                   V[] -> var[]
               if);
               (*Qvariants.print;*)
               cd.com(#do 'ComputeVariant:B:' -> T; OGid -> T #);
            exit var[]
            #);        
          Qgen::
            (* Qgen is only called for singular Objects and pushed on stack
             * For patterns OG is pushed on stack and later genClass is called
             *)
            (# gdb:: 
                 (#
                 do OGid -> lx.puttext; ' '-> lx.put; dopt -> lx.puttext;
                    ' :super: ' -> lx.puttext; super.label -> lx.puttext;
                    ': '->lx.puttext;
                    super.doPT -> lx.puttext;
                    (if IS.isEmpty then 
                        '\n\t   IS-empty: ' -> lx.puttext 
                     else
                        '\n\t   singular:' -> lx.puttext
                    if);
                    'staticOff: '-> lx.puttext; staticOff -> lx.putint;
                    ' descNo: ' -> lx.puttext; IS.newDescno->lx.putint;
                    ' top:'->lx.puttext; Qvariants.top -> lx.putint
                 #);
               printQoff:
                 (#
                 do (if trace then
                        IS.scanSons
                        (# I: ^Item; D: ^Decl
                        do  current[] -> I[];
                           (if I.isDecl then 
                               I[] -> D[];
                               D.qoff[1] -> putint; ' ' -> put; D.doPT -> putline
                    if)#)if)
                 #);
               name: ^text; head: @boolean; Px: ^OGpath;
               on,pn: @integer;
               var: ^Variant;
               trace: (# exit false #);
            do (if not genIsDone then
                   (if primNo = inner_prim then
                       (*'TRYING code gen for inner'->putline*)
                   if);
                   (* Check if code has been generated for this variant *)
                   true -> genIsDone;
                   cd.com
                   (# ptn: ^Pattern; OI: ^ObjectInvocation; E: ^Exp
                   do 'ObjectGenerator:Qgen:OGid:' -> T; OGid -> T; 
                      ':doPT:'-> T; dopt -> T;
                      'IS.descNo:' -> T; IS.newDescNo -> I;
                      'OG.top:'->T; Qvariants.top->I;
                      super.last -> E[];                            
                      (if (E[] <> none) and (E## = objectInvocation##) then 
                          (if ((E[] ->  OI[]).ATD## = pattern##) then
                              (E[] ->  OI[]).ATD[] -> ptn[];
                              'super:'->T; ptn.sig.dopt -> T;
                              'superDescNo:' -> T; ptn.OG.IS.newDescNo -> I;
                              'super.OG.top:' -> T; ptn.OG.Qvariants.top -> I;
                      if)if)
                   #);
                   (* we may have 
                    * non-singular: foo
                    * Singular:     foo{...}
                    *)
                   (*computeVariant -> var[]; *)
                   
                   cd.bcPos -> beginBCP;
                   (if CC[] <> none then (* not used? *)
                       this(ObjectGenerator)[] -> CC.add -> CC[];
                   if);
                   (if hasVariants then
                       (*'\nOG.hasVariants:\n' -> puttext; dopt -> printhead;
                        Qvariants.print*)
                   if);
                   (if IS.isEmpty 
                       and not super.hasVirtualArgs 
                       or (super.isBasic and IS.isEmpty) then
                       (* Implies that super.OG is pushed on objTmpStack
                        * So should we pass the variant of this OG to Qgen?
                        *)
                       cd.com(#do 'OG:Qgen:IS.isEmpty:' -> T;#);
                       (useReturnValue,superAdj,staticOff) -> super.Qgen
                    else
                       (* Perhaps move check for virtuals to here!? *)
                                (* Singular object like R.foo{ }
                                 * includes pattern invocations with 
                                 * virtual arguments like %if .. %then% ... %else ...
                                 *)
                       cd.com(#do 'OG:Qgen:IS is not empty:'->T; #);
                       cd.pushThis; (* origin for a singular object *)
                                (* This is also the case for R.S.foo{ ... } *)
                       
                       (* Perhaps all patterns with more than one variant
                        * should be considered singular?
                        *)
                       (* Invoke the singular object *)
                       cd.com(#do 'before objTmpStack:add: '->T;
                                IS.newDescNo -> I; ' ' -> T; OGid -> T #);
                       (OGid,IS.newDescNo,staticOff,true) -> cd.invoke; 
                       (if not useReturnValue then cd.rpop if);
                   if);
                   cd.bcPos -> endBCP;     
               if)
            #);
          genClass::
            (# var: ^Variant
            enter var[] (* super has more arguments *)
            do (if hasVirtualObject then
                   (if traceGeneric3 then
                       '***** HasVirtualObject: ' -> putline; 
                       (if sig[] <> none then 
                           sig.doPT -> putline;
                        else
                           doPT -> putline;
                           display
               if)if)if);
               (* Move IS.genclass to here? *)
               (N[],sig[],IS.newDescNo,super[],this(ObjectGenerator),CC[],var[])
                 -> IS.genClass
            #);
          XaddB: @
            (# off: @integer; E: ^ObjectGenerator;
               offsets: [2] @integer;
               bindingType: [2] @integer; (* 0: inner; 1: ref; 2: value *)
               bindings: [2] ^ObjectGenerator;
               top: @integer;
               copySuper:
                 (# ptn: ^Pattern
                 do (if (super[] <> none) and (super.ATd[] <> none) then
                        super.ATd[] -> ptn[];
                        (*'copySuper:' ->putline; ptn.OG.XaddB.display;*)
                        (for i: ptn.OG.XaddB.top repeat 
                             (*ptn.OG.XaddB.offSets[i] -> putint; ' '-> put;
                              ptn.OG.XaddB.bindingType[i] -> putint; newline;
                              (if ptn.OG.XaddB.bindings[i][] <> none then
                              ptn.OG.XaddB.bindings[i].dopt -> putline;
                              else
                              'none' -> putline
                              if);*)
                             (if ptn.OG.XaddB.offsets[i] > 0 then
                                 (ptn.OG.XaddB.offsets[i]
                                 ,ptn.OG.XaddB.bindings[i][]) 
                                   -> XaddB
                                 (*else = 0: inner *)
                             if)
                        for)                             
                    if)
                 #);
               display:
                 (# T: ^Text
                 enter T[]
                 do (if top > 0 then
                        T[] -> puttext; 
                        '*** Bindings: descNo: ' -> puttext; 
                        IS.newDescNo(*descNo*) -> putint; newline;
                        (for i: top repeat
                             i -> putint; ':' -> put;
                             offsets[i] -> putint; ':'->put;
                             (if bindingType[i]
                              // 0 then '   inner: ' -> puttext;
                              // 1 then '   ref: ' -> putline
                              // 2 then '   value: ' -> putline;
                              else 
                                 '   ???' -> putline
                             if);
                             (if bindings[i][] <> none then
                                 bindings[i].doPT -> putline
                              else 
                                 'none'->putline
                             if)
                    for)if)
                 #)      
            enter(off,E[])
            do (if handleGeneric then
                   (if off <= 0 then
                       '\n*** XaddB: off <= 0: '-> puttext;
                       off -> putint; newline;
                       dopt -> putline;
                       E.doPT -> putline;
                       leave XaddB
                   if);
                   (if off > bindings.range then
                       (off + 2 - bindingType.range) -> bindingType.extend;
                       (off + 2 - bindings.range) -> bindings.extend;
                       (off + 2 - offsets.range) -> offsets.extend;
                   if);
                   (if off > top then off -> top if);
                   off -> offsets[off];
                   (*'Add:' -> puttext; E.doPT -> puttext; 
                    ' ' -> put; off -> putint;
                    ' ' -> put; E.primNo -> putint; newline;*)
                   (if E.primNo // integer_prim then 
                       (* '--value--'->putline;*)
                       2 -> bindingType[off]
                    else 
                       1 -> bindingType[off]
                   if);
                   E[] -> bindings[off][];
               if)
            #)
       #);
     items::
       (# markForCodeGen::
            (#
            do cd.com(#do 'items:markForCodeGen:'->T; doPT -> T; #);
               scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if current.isDataItem then
                      current.MarkForCodegen 
                   else
                      (if I.isDecl then
                          (if not I.isPattern or I.isVirtual or(I[] = StringDecl[]) then
                              (if I[] = StringDecl[] then
                                  cd.com(#do 'Items:markString'->T; dopt->T #)if);
                              current.MarkForCodeGen 
                          if)
                       else
                          cd.com(#do 'markItem:"'->T; current.doPT -> T; '":'->T;
                                   current.label -> T #);
                          current.MarkForCodeGen 
                      if)
                  if)
               #);
            #);
          genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; super: ^Invocation;
               var: ^Variant;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
               enclosingOG,OG: ^ObjectGenerator;
               BindVirtuals:
                 (# handleDecl:
                      (# mkStubName:
                           (# T: ^text
                           do 'Vstub#' -> T[];
                              (if sig[] <> none then
                                  sig.id[] -> id[] -> T.append;
                               else
                                  'S' -> id[] -> T.append
                              if);
                              '#' -> T.put;    
                              OG.vDescNo -> T.putint;
                           exit T[]
                           #);
                         D: ^Decl; OG: ^ObjectGenerator; ptn: ^Pattern;
                         id: ^text; dNo: @integer; var: ^Variant
                      enter(D[],OG[])
                      do (if D.isVirtual then
                             (if OG.nonVirtualBinding (*OG.vDescNo > 0*) then
                                 QnewDesc -> dNo;
                                 cd.com(#do 'genClass:BindVirtuals:descNo:'
                                            -> T;
                                          dNo -> I
                                       #);
                                 objectDecl[] -> ptn[];
                                 (mkStubName,dNo,false,ptn.OG.IS.newDescNo,newOriginOff) 
                                   -> cd.class;
                                 'Load origin' -> cd.comment;
                                 (if OG.isVirtualArg then
                                     (OG.super.on + 1,OG.super[]) -> goOrigin;
                                  else
                                     (OG.super.on,OG.super[]) -> goOrigin;
                                 if);
                                 cd.com
                                 (#do 'OG.super.on/descNo:' -> T; OG.super.on->I; 
                                    OG.getDescNo->I #);
                                 (id[],OG.getDescNo,0,true) -> cd.invoke;
                                 'D' -> cd.rtn;
                                 (* The vdtTableAt here overrides the one in 
                                  * HandleVirtArgument (check it)
                                  *)
                                 cd.com(#do 'vdt:a'-> T #);
                                 (D.off,dNo,newDescNo) -> CD.vdtTableAt
                         if)if)
                      #);
                    ptn: ^Pattern;
                    E: ^Exp;
                    args: [6]^ObjectGenerator; top,i: @integer;
                 do (if super[] <> none then
                        super.scanSons(# do current[] -> E[] #);
                        (if E[] = none then 
                            (*'e is none' ->putline; dopt -> putline;*)
                            leave BindVirtuals
                        if);
                        (*'*** Handle VB: '->puttext; dopt -> putline;*)
                        (* 'E: ' -> puttext; E.doPT -> putline;*)
                        (if E.args[] <> none then
                            E.args.scanArgs
                            (#
                            do (if (top+1 -> top) > args.range then 
                                   args.range -> args.extend 
                               if);
                               current[] -> args[top][];
                            #);     
                            (if super.ATd[] <> none then
                                super.ATd[] -> ptn[];
                                (* 'ptn: ' -> puttext; ptn.dopt -> putline;*)
                                (if ptn.OG.sig[] <> none then
                                    ptn.OG.sig.scanArgs
                                    (# i: @integer
                                    do i + 1 -> i;
                                       (currentArg[],args[i][]) -> handleDecl 
                                    #)                                
                        if)if)if)
                    if);
                    scanSons
                    (# I: ^Item; D: ^Decl; ptn: ^Pattern
                    do current[] -> I[];
                       (if I.isDecl then 
                           I[] -> D[];
                           (if D.isVirtual then
                               D[] -> ptn[];
                               (I[],ptn.OG[]) -> handleDecl 
                       if)if)
                    #)
                 #);               
               mainPathModule: ^Module;     
               CC: ^CallChain; superVar: ^Variant
            enter(N[],sig[],descNo,Super[],OG[],CC[],var[])
            do (* Is called with descNo = NewDescNo *)
               (* We must know the actual variant being generated for
                * The actual variant should have info about: 
                * actual descNo and actual storage layout 
                *)
               cd.com(#do '****GenClass:'->T; N[] -> T;
                        (if (var[] <> none) then
                            ' :varNo = '-> T; var.thisVarNo -> I;
                         else
                            ':var is none' -> T
                        if);
                     #);
               (if not OG.Qvariants.isEmpty then
                   (* '\n***** GenClass,N: ' -> puttext; 
                    N[] -> printNotNone; newline;
                    (if sig[] <> none then sig.doPT -> puttext; if);
                    ' varNo = ' -> puttext;
                    (if var[] <> none then var.thisVarNo -> putint if);
                    ' genDone = '->puttext;
                    (if var.genDone then 'True ' -> puttext if);
                    newline;
                    OG.Qvariants.print;*)
               if);
               (if (superDesc[] <> none) then
                   (* get the ptn decl for super: *)
                   superDesc.father.father -> ptn[]; 
                   (*'\n*** OBS! genClass:super: ' -> puttext;
                    ptn.sig.id[] -> putline;*)
                   (if (var[] <> none) then
                       (if var.thisVarNo > 0 then
                           (*'\n>>> genClass for ' -> puttext; N[] ->printNotNone;
                            ' varNo = ' -> puttext;
                            var.thisVarNo -> putint; *)
                           (* we should find the corresponding var in super 
                            * perhaps we should use the same object?
                            *)
                           var[] -> ptn.OG.Qvariants.findSuperVar -> superVar[];

                           (*(if superVar[] <> none then
                            '\n>>> superVarNo: ' -> puttext;
                            supervar.thisvarNo -> putint; 
                            ' genDone='->puttext;
                            (if superVar.genDone then 'True' -> puttext if);
                            else
                            'SuperVar is none'->puttext
                            if);
                            newline;
                            dopt -> printHead      *)                  
                       if);
                    else
                       (* '\n>>> genClass for ' -> puttext; 
                        N[] -> printNotNone; 
                        ' (var = none)\n' -> putline;
                        dopt -> printHead;*)
                   if);

                   (if (superVar[] <> none) and not superVar.genDone 
                       or 
                       (superVar[] = none) and not superDesc.done then
                       (* the actual variant beging generated here must be
                        * propagated to super possibly implying that a new
                        * variant of super must be generated;
                        * we have actually propagated the actual var to the
                        * super, so should the propagation imply a 
                        * codegen (on objTmpStack) or should we do it here?
                        *)
                       (* Should be done in Variants::QAlloc *)
                       (*'\n***genClass:super: '->puttext;
                        ptn.sig.id[]->puttext;
                        ' varNo:'->puttext; 
                        
                        (if superVar[] <> none then
                        superVar.thisVarNo -> putint
                        else
                        '++none++' -> puttext
                        if);
                        ' descNo:'->puttext;
                        (for i: ptn.OG.IS.QdescNo.range repeat
                        ' ' -> put;
                        ptn.OG.IS.QdescNo[i] -> putint;
                        
                        for);*)
                       
                       (if ((superVar[]  <> none) and
                           (superDesc.QdescNo[superVar.thisVarNo] = 0)) or
                           (superDesc.newDescNo = 0) then 
                           (*':alloc:\n'->puttext;*)
                           'OBS! Qalloc:??'-> cd.comment;
                           (if superVar[] <> none then
                               (superVar.thisVarNo,none) -> ptn.OG.Qalloc
                            else
                               ptn.OG.computeVariant -> var[];
                           if);
                        else
                           (*newline;*)
                       if);
                       
                       (ptn.sig.id[],ptn.sig[]
                       ,superdesc.newDescNo
                       ,ptn.OG.super[]
                       ,ptn.OG[],CC[]
                       ,superVar[]) 
                         -> superDesc.genClass;
                       (* Perhaps vdtTableCopy below does not work
                        * if we have not called genClass!?
                        *)
               if)if);
               (*(if true 
                // (var[] = none) then done -> printBoolean 
                // var[] <> none then var.genDone -> printBoolean
                if);*)
               var[] -> thisVar[];
               (if (var[] = none) and not done or 
                   (var[] <> none) and not var.genDone then
                   (if (var[] <> none) and done then
                       (* we must eliminate this case 
                        * there should always be var <> none *)
                       cd.com(#
                             do 'OBS! calling genClass for:' -> T; N[] -> T;
                                ':var<>none:Done:'->T;  done->B;
                                ':leave genClass' -> T
                             #);
                       (* (dumpStack,'---') -> stop;*)
                       true -> var.genDone;
                       leave genclass
                   if);
                   (if var[] <> none then 
                       cd.com
                       (#
                       do 'GenClass:'->T; N[] -> T; ':true -> var.genDone' -> T #);
                       true -> var.genDone
                    else 
                       true -> done 
                   if);
                   
                   OG.XaddB.copySuper;

                   (N[],newDescNo,false,(topSuper).newDescNo,qsize[thisVar.thisVarNo]) -> cd.class;
                   (* thisObj = the new instance of this class 
                    * thisStack = caller
                    * Possible arguments on callerStack
                    *)
                   cd.bcPos -> beginBCP;
                   (* store parameters + origin *)
                   (if sig[] <> none then sig.storeParameters if);
                   (*'GenClass,items, ' -> puttext; N[] -> puttext;
                    ' ' -> put; newOriginOff -> putint; newline;*)
                   (if noGlobals and elimOrigin  then
                       (if traceNoGlobals then
                           '*** No globals-do not store origin' -> putline;
                           'do not store origin'->cd.comment;
                           dopt -> putline;
                       if)
                       (*cd.rPop*)
                    else                   
                       ('origin',newOriginOff) -> cd.rstore;
                       (if (origin[] -> originIsValue) then
                           cd.com(#do 'origin.valueOff:store:' -> T;
                                    NewOriginOff + 1 -> I; #);
                           ('originOff',NewOriginOff + 1) -> cd.store
                       if)
                   if);
                   not doHasCode -> cd.allocEventQ;
                   
                   (if (superDesc[] <> none) and not superDesc.isBasic
                       or (superDesc[] <> none) 
                       and ((superDesc.primNo = stringDecl.primNo) 
                       or (superDesc.primNo = immutable_prim)) then
                       (ptn.sig.id[],superDesc.newDescNo)  -> cd.super; 
                       cd.com(#do 'vdt:b'-> T #);
                       superDesc.newDescNo -> cd.vdtTableCopy;
                       (if superDesc.innerInx > 0 then
                           cd.com(#
                                 do 'vdt:c:innerInx: '-> T; 
                                    superDesc.innerInx -> I;
                                    ' descNo: ' -> T; newDescno -> I 
                                 #);
                           (superDesc.innerInx,newDescno) -> cd.vdtTable;
                           true -> hasSuperAndInner
                       if);
                       (* push super arguments *)
                       
                       (if super.isImplSuper then
                           (if elimOrigin and noGlobalsInsuper then
                            else
                               (if super.isSingularImplSuper then
                                   cd.pushThis;
                                   ('iOrigin',newOriginOff) -> cd.rpushg;
                                   (if (origin[] -> originIsValue) then
                                       (*'***Super:iOrigin isValue:'->puttext; dopt->putline;*)
                                       cd.pushThis;
                                       (T[],newOriginOff + 1) -> cd.pushg;
                                   if)
                                else
                                   super.ATd[] -> ptn[];
                                   origin[] -> vSuperDesc[]; (* find desc enclosing vDcl *)
                                   (for i: super.pn repeat
                                        vSuperDesc.superDesc[] -> vSuperDesc[]
                                   for);
                                   cd.pushThis;
                                   ('origin',newOriginOff) -> cd.rpushg;
                                   (if (origin[] -> originIsValue) then
                                       (*'***Super:origin isValue:'->puttext; dopt->putline;*)
                                       cd.pushThis;
                                       (T[],newOriginOff + 1) -> cd.pushg;
                                   if);
                                   (* No arguments for super, so no
                                    * - newOriginOff for loadArgs as below
                                    *)
                                   (ptn.OG.super.on,none) -> vSuperDesc.goOrigin
                           if)if)
                        else
                           (# E,rec: ^Exp; off: @integer; 
                              A: ^Address; caCalled: @boolean
                           do (*'GenItems:' -> puttext;
                               super.doPT -> puttext;
                               ' newOriginOff:'->puttext;
                               newOriginOff -> putint; 
                               ' super.on: ' -> puttext;
                               super.on -> putint; newline;*)
                              (if elimOrigin and noGlobalsInSuper then
                                  super.scanSons
                                  (#
                                  do current[] -> E[];
                                     (if not isLast then E[] -> rec[] 
                                      else
                                         (if isFirst then E[] -> rec[]
                                     if)if)
                                  #)
                               else 
                                  true -> caCalled;
                                  newOriginOff
                                    -> Address
                                    -> super.computeAdr
                                    -> (rec[],E[],A[]);
                                  cd.com
                                  (#do 'genClass:after:ComputeAdr:'-> T; 
                                     'E:"' -> T; E.doPT -> T; '"'->T;
                                     A.print -> T #);
                              if);
                              (if sig[] = none then
                                  'Super:sig none'->cd.comment;
                                  (newOriginOff,CC[]) -> E.loadArgs; 
                               else
                                  'Super:sig not none'->cd.comment;
                                  (* go ON - 1 
                                   * but use newOriginOff first time
                                   *)
                                  (- newOriginOff,CC[]) -> E.loadArgs; 
                              if);
                           #);
                       if);
                       superDesc.newDescNo -> cd.toSuper;
                       cd.markEnterE;  
                   if); 
                   (if newDescNo = (markIncludes.topModule.desc).newDescno then
                       cd.pushThis;
                       cd.saveBETAworld
                   if);
                   (if (superDesc[] <> none) and not superDesc.isBasic  then
                    else cd.mvStack
                   if);
                   (if sig[] <> none then
                       (false,0,0) -> sig.Qgen
                   if);
                   scanSons
                   (# I: ^Item; MP: ^Module
                   do current[] -> I[];
                      (if I.isDecl then
                          (if not I.isPattern or I.isVirtual then
                              (false,0,0) -> current.Qgen -> MP[];
                              (if MP[] <> none then
                                  MP[] -> mainPathModule[];
                              if)
                           else
                              (if I[] = StringDecl[] then
                                  (false,0,0) -> current.Qgen if) 
                   if)if)#);
                   (if mainPathModule[] <> none then
                       (false,0,0) -> mainPathModule.DI.Qgen
                   if);
                   (if innerInx > 0 then innerInx -> cd.innerA if);
                   (if (superDesc[] <> none) and not superDesc.isBasic then
                       cd.rtnInner 
                    else
                       (if doHasCode then 
                           1 -> cd.rtnEventQ 
                        else
                           0 -> cd.rtnEventQ 
                       if)
                   if);
                   
                   (* Code for action part *)
                   (false,doHasCode) -> cd.actions;
                   (*restartLab.new;
                    leaveLab.new;*)
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item; 
                   do current[] -> I[];
                      (if not I.isDecl then 
                          cd.com(#do 'genclass:Qgen:stmt:'-> T; current.doPT ->T#);
                          (false,0,0) -> current.Qgen 
                      if) 
                   #);
                   leaveLab -> cd.defLab;
                   (* we must push return values *)
                   (* push return value 
                    * - for DataItem: R: @Foo
                    *   Foo should return (this(Foo)
                    *   perhaps default?
                    * - otherwise push variables in -> 
                    *)
                   (if (superDesc[] <> none) and not superDesc.isBasic then
                       cd.rtnInner
                    else
                       0 -> cd.rtnEventQ;
                       cd.com(#
                             do 'OG:pushReturn:' -> T; 
                                (if sig[] = none then '-none-'->T
                                 else
                                sig.id[] -> T if)#);
                       (if sig[] <> none then 
                           sig.pushReturnValues 
                        else
                           (* ad hoc *)
                           cd.setThisStack;
                           cd.pushThis
                       if);
                       (if (theObjectGenerator).isValue then 
                           cd.rtnV
                        else
                           'D' -> cd.rtn
                       if)
                   if);
                   (vsize,rsize,1) -> CD.endClass;
                   cd.bcPos -> endBCP
               if);
               (if traceGeneric2 then
                   (father[] -> enclosingOG[]).XaddB.display
               if);
               BindVirtuals
            #);
          goOrigin:
            (# on: @integer; NA: ^Apl; org: ^Items; T: ^text; var: ^Variant
            enter(on,NA[])
            do (if on > 0 then
                   OT.OGid -> T[]; ':origin' -> T.append;
                   (* For each pattern in the origin chain, we must check
                    * whether or not the specific pattern has restrictions
                    * that are violated
                    *)
                   NA[] -> checkGlobals;
                   (* how do we with newAlloc ensure that code is generated for
                    * OGs in the origin chain?
                    *)
                   (if basicNo = ifthen_prim then
                       (on,NA[]) -> (origin[]->org[]).goOrigin -> org[]
                    else
                       (if OT.IS.newOriginOff = 0 then 
                           (*father.dopt -> putline;*)
                           (* move to vvariants.bet'*)
                           'OBS! Qalloc, originOff = 0 ' -> cd.comment;
                           OT.computeVariant -> var[];
                       if);
                       cd.com(#do 'goOrigin:'-> T; OT.OGid-> T; 
                                OT.IS.newOriginOff -> I; newOriginOff -> I #);

                       (if (origin[] -> originIsValue) then
                           cd.com(#do 'origin.valueOff:load ' -> T; newOriginOff + 1 -> I #);
                           cd.rdouble;
                           (T[],newOriginOff) -> cd.rpushg;
                           cd.rswap;
                           (T[],newOriginOff + 1) -> cd.pushg;
                        else
                           (T[],newOriginOff) -> cd.rpushg;
                       if);
                       (if origin[] <> none then
                           (on - 1,NA[]) -> (origin[]->org[]).goOrigin -> org[]
                        else
                           'Origin is none: ' -> puttext; on -> putint; newline
                       if)
                   if)
                else
                   this(Items)[] -> org[]
               if)
            exit org[]
            #); 
          hasSuperAndInner: @Boolean;

          findNextImp::
            (#
            do L:
                 scanSons
                 (#
                 do (if (bcp -> current.findNextImp -> impx[]) <> none then
                        leave L
                 if)#);
            #)            
       #);
     Pattern::
       (# genIsDone: @boolean;
          markForCodegen::
            (#
            do cd.com(#do 'Pattern:markForCodeGen:' -> T; ; dopt -> T;#);
               OG.markForCodeGen
            #);
          GeneralPattern::
            (# doPrimElse: 
                 BooleanValue(# exNo: @integer; <<SLOT doPrimElse:doPart>> #);
               invoke:: (#<<SLOT GeneralPattern_invoke:doPart>> #);
            #);
          AssignmentPattern::
            (# invoke:: (# <<SLOT AssignMentPattern_invoke:doPart>> #);
            #);
          BreakPattern::
            (# invoke:: (# << SLOT BreakPatternInvoke:doPart>> #)
            #);
          IndexedPattern::
            (# invoke:: (# <<SLOT IndexPattern_invoke:doPart>> #);
            #);
          OtherPrimPattern:: 
            (# invoke:: (#  <<SLOT OtherPrim_invoke:doPart>> #); 
               org: ^Items; exitLab: @labelHandler.label;  
               exNo: @integer;
            #);
          Qgen::
            (# gdb:: (# #);
               enclosingOG: ^ObjectGenerator;
               DN: @integer
            do (if not genIsDone then
                   true -> genIsDone;
                   (if OG.primNo
                    // 0 
                    // object_prim // value_prim
                    // string_prim 
                    // indexed_prim // immutable_prim then
                       (if OG.IS.isExternal > 0 then leave Qgen if);
                       (if ptnKind 
                        // plainPtn then
                        // virtualPtn then
                           (if not OG.hasItems  then
                               cd.com(#do 'vdt:d'-> T #);
                               (* Qalloc moved to vvariant.bet *)
                               (off,(OG.super.desc).newDescNo) -> cd.vdtTable;
                               (if traceGeneric then
                                   '*** Bind1: ' -> puttext;
                                   off -> putint; ' ' -> put; 
                                   (OG.super.desc).newDescNo -> putint; newline;
                                   dopt -> putline;
                               if);
                            else
                               cd.com(#do 'vdt:e'-> T #);
                               (off,OG.IS.newDescNo) -> cd.vdtTable;
                               (if traceGeneric then
                                   '*** Bind2: ' -> puttext;
                                   off -> putint; ' ' -> put; 
                                   OG.IS.newDescNo -> putint; newline
                               if)
                           if);   
                           (if father.father##
                            // ObjectGenerator## then
                               (off, OG[]) 
                                 -> (father.father[]-> enclosingOG[]).XaddB
                            // Signature## then
                               (# ptn: ^pattern
                               do (off, OG[]) 
                                    -> (father.father.father[]-> ptn[]).OG.XaddB
                               #)
                            else                           
                               'Koks'->putline;
                               father.father.label -> putline
                           if)
                        // furtherPtn // finalPtn then
                           (if OG.IS.isEmpty then 
                               OG.vDescNo -> DN;
                               cd.com
                               (#do 'vdtTable: off: ' -> T;
                                  off -> I; ' descNo: ' -> T; DN -> I; 
                               #);
                            else
                               OG.IS.newDescNo -> DN;
                               cd.com(#do 'vdt:f:'-> T; DN -> I;
                                        'getDescNo:' -> T; OG.getDescNo -> I #);
                               (off,DN) -> cd.vdtTable;
                           if);
                           (if traceGeneric then
                               '*** Bind3: ' -> puttext;
                               off -> putint; ' ' -> put; 
                               OG.IS.newDescNo -> putint; newline ;
                               dopt -> putline
                           if);
                           (off, OG[]) -> (father.father[]-> enclosingOG[]).XaddB
                       if);
               if)if)
            #);
          pushThis:: 
            (# gdb:: (# #); T: @text
            do (if OG.primNo
                // 0 
                // value_prim  (* OBS - needed for a ptn being sub of Value
                                * otherwise execution fails since origin 
                                * is not loaded
                                * An explicit sub of Object also fails
                                *)
                // this_prim 
                // indexedGet_prim (* not tested*)
                // indexedPut_prim (* ditto *)
                // stringGet_prim 
                // indexed_prim 
                // immutable_prim then
                   cd.pushThis 
                else (* ugly *)
                   (if ptnKind // virtualPtn // furtherPtn // FinalPtn then
                       cd.pushThis 
                   if)
               if)
            #);
          loadArgs::
            (# gdb:: (# do sig.doPT -> lx.puttext; 
                        ' E: ' -> lx.puttext;
                        E.doPT -> lx.puttext;
                        ' descNo: ' -> lx.puttext; OG.IS.newDescNo -> lx.putint;
                        ' top: ' -> lx.puttext; OG.Qvariants.top -> lx.putint
                     #);
               actArgs: [6]^ObjectGenerator; (* actaul arguments *)
               top,i: @integer;
               enclosingOG: ^ObjectGenerator;
               var: ^Variant
            do (if OG.primNo 
                   (* Some of these are handled in invoke below
                    * May be moved to here*)
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   (* skip *)
                else
                   E.args.scanArgs
                   (#
                   do (if (top+1 -> top) > actArgs.range then 
                          actArgs.range -> actArgs.extend 
                      if);
                      current[] -> actArgs[top][];
                   #);
                   (* we also need to scan possible arguments of super *)
                   sig.scanArgs
                   (* we also need to scan possible arguments of super *)
                   (# Ex: ^Exp; OI: ^ObjectInvocation;
                      OG: ^ObjectGenerator; name: ^text; descNo: @integer;
                      ptn: ^Pattern
                   do i + 1 -> i;
                      (* can we do currentArg.LoadArg?
                       * And then perhaps special for virtuals primitive
                       * and ptName? Virt is of course ptn *)
                      (* 'Arg: ' -> puttext; D.doPT -> putline;
                       * args[i].doPT -> putline;args[i].primno -> putint; 
                       * ' ' -> put; (args[i].desc).primno -> putint; 
                       * (if args[i].isSimpleValue then 'S' -> put if);
                       * newline;*)
                      handleVirtArg:
                        (if currentArg.isVirtual then
                            (if primNo = indexed_prim then
                                leave handleVirtArg
                            if);
                            L:
                              actArgs[i].super.scanSons
                            (#do current[] -> Ex[]; leave L #);
                            (if (Ex[] <> none) and (Ex.isObjectInvocation) then
                                Ex[] -> OI[];
                                (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                    OI.ATd[] -> ptn[];
                                    (actArgs[i].desc).newDescNo -> descNo; 
                                    
                                    (* descNo: ' -> puttext; 
                                     * descNo -> putint; ' ' ->put;
                                     * OI.ATd.primNo -> putint; ' ' -> put;
                                     * OG.super.primNo -> putint
                                     * newline;
                                     *)                                     
                                    (* Perhaps OG below is enclosingOG as
                                     * also used below?
                                     * need OG.descNo for VDT *)
                                    E.father.father[] -> OG[]; 
                                    
                                    (* '>>>> ArgBinding: ' -> puttext;
                                     args[i].getDescNo -> putint; ' ' -> put;
                                     args[i].doPT -> puttext;
                                     ' :vDescNo: ' -> puttext;
                                     args[i].vDescNo -> putint; newline;*)
                                    (* May be (always?) overwritten in
                                     * generation og vStub in 
                                     * BindVirtuals::handleDecl
                                     *)
                                    (# inx: @integer
                                    do i -> inx;
                                       cd.com(#
                                             do 'vdt:g'-> T;
                                                actArgs[inx].vDescNo -> I;
                                                (OG.desc).newDescNo -> I
                                    #)#);
                                    (currentArg.Off,actArgs[i].vDescNo,(OG.desc).newDescNo) 
                                      -> cd.vdtTableAt;
                                    (if traceGeneric then
                                        '*** Bind4: ' -> puttext;
                                        currentArg.doPT -> putline;
                                        currentArg.Off -> putint; ' descNo: ' -> puttext; 
                                        (OG.desc).newDescNo -> putint; 
                                        ' primno: ' -> puttext;
                                        actArgs[i].primno -> putint;
                                        newline
                                    if);
                                    (currentArg.Off, actArgs[i][])
                                      -> (E.father.father[]-> enclosingOG[])
                                    .XaddB;
                                    leave handleVirtArg
                                if);
                            if);   
                            (if (E.desc).primNo = indexed_prim then 
                                (* We ignore bindings of elm in Indexed *)
                                leave handleVirtArg
                             else
                                (if actArgs[i].primNo = integer_prim then
                                    '\n*** Virtual bound to integer in\n\n\t'
                                      ->puttext;
                                    E.doPT -> putline;
                                    '\n    is ignored by the compiler\n' 
                                      -> putline;
                                    leave handleVirtArg
                                if);
                            if);                              
                            (* Perhaps always computeVariant -> var
                             * we need descNo to compute name so
                             * cannot be part of tmpStack.add *)
                            currentArg.sig.id.copy -> name[];
                            '#SB#' -> name.append;
                            (actArgs[i].desc).newDescno -> descNo -> name.putint;
                            (# inx: @integer
                            do i -> inx;
                               cd.com(# og: ^ObjectGenerator
                                     do 'handleVirtArg:' -> T; name[] -> T;
                                        'actArgs['->T; inx -> I; ']'-> T;
                                        actArgs[inx].dopt -> T;
                                        actArgs[inx].label -> T;
                                        'argDescNo:'->T; descNo -> I;
                                        'E:'->T; E.dopt -> T; '::'->T;
                                        E.father.father.dopt -> T; '::'->T;
                                        ((E.father.father-> OG[]).desc).newdescno -> I;
                                        OG.label -> T
                                     #);
                            #);
                            
                            E.father.father[] -> OG[]; (* need OG.descNo for VDT *)
                            (*'\n vdtTableAt: ' -> puttext; 
                             currentArg.Off -> putint; ' ' -> put;
                             descNo -> putint; ' ' -> put;
                             (OG.desc).newDescNo -> putint; newline;
                             OG.doPT -> putline;
                             currentArg.sig.doPT -> putline;*)
                            cd.com(#
                                  do 'vdt:h:argDescNo:'-> T; descno -> I;
                                     'OG.descNo:' -> T;
                                     (OG.desc).newDescNo -> I;
                                     OG.doPT ->T
                                  #);
                            (currentArg.off,descno,(OG.desc).newDescNo) -> cd.vdtTableAt;
                            (if traceGeneric then
                                '*** Bind5: ' -> puttext; 
                                currentArg.off -> putint; ' ' -> put;
                                (OG.desc).newDescNo -> putint; newline;
                                actArgs[i].doPT -> putline;
                            if);
                            (currentArg.off, OG[]) 
                              -> (father.father[]-> enclosingOG[]).XaddB
                         else
                            (if i > top then
                                (* Either to few arguments or Super as in
                                 *    foo{ ... }
                                 * where foo has arguments - to be fixed! *)
                             else(# j: @integer do i -> j;
                                    cd.com(#do 'loadArgs:X:'->T; 
                                    actArgs[j].dopt->T #)#);
                                (true,superAdj,0) -> actArgs[i].Qgen
                            if)
                   if)#);
                   handleSuperArgs:
                     (if i < top then 
                         (* a hack - need to scan arguments of super *)
                         i + 1 -> i;
                         (true,superAdj,0) -> actArgs[i].Qgen;
                         restart handleSuperargs
                     if)
               if)
            #);
          load::
            (#
            do cd.com(#do 'Pattern:load:'->T;OG.primNo -> I; ' '->T; dopt -> T;   #);
               (if OG.primNo
                // assign_prim then
                   '\n\n***** pattern:load:assign_prim: called A.store'->putline;
                   A.store
               if);
            #);
          getAdr::
            (# B: @boolean
            do cd.com(#do A.print -> T #);
               (if isBasic then
                   true -> loadRec;
                else
                   true -> loadRec;
                   true -> A.isAdr
               if);
            #);
          invoke:: 
            (# 
            do (rec[],E[],useReturnValue,staticOff,CC[],adr[]) 
                 -> currentPtnKind.invoke 
            #);
          popReturn:
            (* perhaps this should be the same virtual as in dataItem!?
             * And do consider signature:popReturn
             *)
            (# D: ^Decl
            do (if (sig.getReturn -> D[]) <> none then
                   D.popReturn
                else 
                   cd.rpop
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);   
       #);
     Address: superAdr
       (* E = first exp in "R.S.Q", ie. E = "R" *)
       (# done: @boolean;
          load::
            (#
            do (if isAdr then
                   loadAdr
                else
                   (if off > 0 then
                       cd.com(#do 'load:'->T; this(Address).print -> T #);
                       (if isValue then
                           (if originIsValue then
                               ('',off) -> cd.ovpushg
                            else
                               ('',off) -> cd.pushg
                           if)
                        else
                           ('',off) -> cd.rpushg
               if)if)if)
            #);
          loadAdr::
            (#
            do (if off > 0 then
                   cd.com(#do 'loadAdr:'->T; this(Address).print -> T #);
                   (if isValue then
                       cd.com
                       (#do 'loadAdr:isValue:'-> T; 
                          'originIsValue:'->T; originIsValue -> B#);
                       (if originIsValue then
                           off - 1 -> cd.pushConst;
                           61 (*plus*) -> cd.op
                        else
                           off -> cd.addOff;
                       if)
                       (*('',off) -> cd.pushg*)
                    else
                       ('',off) -> cd.rpushg
               if)if);
            #);
          store::
            (#
            do (if not done then
                   true -> done;
                   cd.com(#do 'store:'->T; this(address).print->T #);
                   (if off > 0 then
                       (if isValue then
                           (if originIsValue then
                               cd.com(#do 'Address:store:originIsValue:'->T #);
                               ('',off) -> cd.ovstoreg
                            else
                               ('',off) -> cd.storeg
                           if)
                        else
                           (* OBS! must check if rswap sometimes is not needed
                            * apparently noswap = true when storing arguments;
                            * See store arguments
                            *)
                           (if true then cd.rswap if);
                           ('',off) -> cd.rstoreg
                       if)
               if)if)
            #);
          print::
            (# 
            do ':Address:E:"'-> T.append; 
               (if E[] = none then 'none'->T.puttext
                else
                   E.dopt -> T.puttext 
               if);
               '"off:'-> T.puttext; off -> T.putint;
               ' superAdj:'->T.puttext; superAdj->T.putint;
               ' isValue:' -> T.puttext; 
               (if isValue then 'True'-> T.puttext else 'False'->T.puttext if);
               ' originIsValue:' -> T.puttext; 
               (if originIsValue then 'True'-> T.puttext else 'False'->T.puttext if);
            #);
       enter superAdj
       exit this(Address)[]
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.on -> gorigin
        *    E1.pushOff
        *    E2.pushOff
        *    E3.invoke
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# markForCodeGen::
            (# ptn: ^Pattern; OGs: ^ObjectGenerator; E,rec: ^Exp
            do cd.com(#do 'Invocation:markForCodeGen:'->T; dopt -> T;#);
               scanSons
               (#
               do current[] -> E[]; 
                  current.MarkForCodeGen;
                  (if not isLast then E[] -> rec[] 
                   else
                      (if isFirst then E[] -> rec[]
                  if)if)
               #);
               (if (E[] <> none) and (E.args[] <> none) then
                   E.args.scanArgs
                   (#
                   do cd.com(#do 'arg:' -> T; ' '-> T; current.dopt -> T#);
                      current.markForCodeGen
               #)if)
            #);
          
          Qgen:: 
            (# gdb:: (# 
                     do scanSons(# ptn: ^Pattern; OI: ^ObjectInvocation
                                do (if (current## = ObjectInvocation##)
                                       and 
                                       ((current[] -> OI[]).ATD## = pattern##) then
                                       OI.ATd[] -> ptn[];
                                       ' descNo: ' -> lx.puttext;
                                       ptn.OG.IS.newDescNo -> lx.putint;
                                       ' top: ' -> lx.puttext;
                                       PTN.OG.Qvariants.top -> lx.putint
                                   if)
                                #)                                         
                     #);
               rec,E: ^Exp; T: ^Text;
               needOrigin: booleanValue
                 (# IT: ^Items
                 do true -> value;
                    cd.com(#do 'needorigin:'-> T; dopt -> T #);
                    scanSons
                    (#
                    do current[] -> E[]; 
                       (if not isLast then E[] -> rec[] 
                        else
                           (if isFirst then E[] -> rec[]
                       if)if)
                    #);
                    cd.com(#do 'needOrigin:E:"'->T; E.dopt -> T; 
                             '" E.ATd:"'-> T; E.atd.dopt -> T; '"'->T #);
                    (if not E.ATd.isPattern then (* DataItem *)
                        cd.com(#do 'needOrigin:datItem:leave'->T #);
                        leave needOrigin
                    if);
                    E.ATd.desc -> IT[]; 
                    (if IT.noGlobals and elimOrigin then
                        cd.com(#do 'LoadOrign:no:loadOrigin: ' -> T;
                                 (IT.theObjectGenerator).doPT -> T #);
                        false -> value
                    if)
                 #);
            do (*'Invocation:Qgen:' -> puttext; dopt -> putline;*)
               (* for P1.X := P2.Y,
                * we need no origin for P1 (and X!?)
                * we need adress of P1 to be added address of X to get embedded
                * adr of X
                * In R.foo, of fo has noGloblas we shall not load adr of R
                * How about: R.S.T.Q ? Q noGlobals, or globals?
                *)
               cd.bcPos -> beginBCP;
               (# A: ^Address
               do (if needOrigin then
                      superAdj
                        -> Address
                        -> computeAdr -> (rec[],E[],A[]);
                  if);
                  cd.com(#do 'Invoke:after:computeAdr:superAdj:'->T; 
                           superAdj-> I;
                           (if A[] <>  none then A.print -> T if)#);
                  cd.com(#do 'rec:label:"'-> T;
                           (if rec[]<> none then 
                               rec.label -> T; '" "'->T;
                           rec.doPT -> T; '"' -> T if)#);
                  (superAdj,CC[]) -> E.loadArgs;
                  cd.com(#do 'Invoke:after:loadArgs:'->T; ':E:'->T; E.dopt -> T;#);
                  (rec[],E[],useReturnValue,staticOff,CC[],A[]) 
                    -> E.invoke;
               #);
               cd.bcPos -> endBCP
            #);
          computeAdr:
            (* R.S.foo(exp).Q
             * X := Y + (Z +117)
             * aLine.aPoint.X
             *)
            (# A,recA: ^Address; E,rec,pRec: ^Exp; j: @integer; loadRec: @boolean
            enter A[]
            do 
               scanSons
               (#
               do rec[] -> pRec[];
                  E[] -> rec[];
                  current[] -> E[];                  
                  cd.com
                  (#do 'computeAdr:'->T; j+1->j->I; ':rec:"'->T; 
                     (if rec[]<> none then rec.dopt-> T else 'none'->T if);
                     '" E:"'->T; E.dopt -> T; '"'->T; A.print -> T
                  #);
                  (if isFirst then
                      E[] -> rec[];
                      E.pushThis;
                      (* E.loadOrigin - we must do this also for values *)

                      (A.superAdj,none) -> E.loadOrigin -> (rec[],E[]);
                      (* we should ignore rec and E - defined above 
                       * And A.superAdj should be eliminated *)
                      A[] -> E.getAdr -> (loadRec,A[]);
                      (* really getOffSet of E.ATd *)
                      (if (E.on > 0) or (A.superadj > 0) then
                          (E.ATd.enclosingObjectGenerator).isValue 
                            -> A.originIsValue
                          (* should probably be for each receiver in
                           * R.S.foo(exp).Q, i.e. R, S and foo
                           *)
                      if);                      
                   else
                      (* mutex.cmpAndSwap 
                       * rec = mutex, cmpAndSwap = E
                       *)
                      (if (E.ATd.primNo <> assign_prim) 
                          and (E.ATd.primNo <> vAssign_prim) then
                          cd.com(#do 'E:notAssign:"'->T; E.dopt->T; '"'->T#);
                          A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                          (if loadRec then
                              (* In R.foo, rec = R, E = foo
                               *    P.print, rec = P, E = print
                               *    R.S,      rec = R, E = S
                               * E is a pattern or dataItem 
                               *)
                              (A.superAdj,none) -> rec.loadArgs;
                              (* Perhaps a combined invoke & getAdr *)
                              
                              (* A is the address of E - not of rec!!!!!!! *)
                              
                              (pRec[],E[],true,0,none,recA[]) -> rec.invoke;
                          if);
                          (* really getOffSet of E.ATd *)
                       else
                          cd.com(#do 'E:isAssign:'-> T; E.dopt -> T#); 
                      if);                      
                  if);
               #);
            exit(rec[],E[],A[])
            #);          
          loadOrigin:
            (# usereturnValue: @boolean;
               staticOff,superAdj: @integer;
               rec,E,nE: ^Exp; CC: ^CallChain;
            enter(useReturnValue,staticOff,superAdj,CC[])
            do ('Invocation:loadOrigin:',doPT) -> cd.com2;
               (* could rec be thisObject for first E1 in E1.E2.E3 ?*)
               (* Perhaps the other way around
                * e1 -> rec
                * rec -> e2.invoke
                * e2 -> rec
                * rec -> e3.invoke
                *)
               scanSons
               (# gdb:
                    (# T: ^text
                    do 'Invocation:loadOrigin:scan: ' -> T[];
                       current.doPT -> T.puttext;
                       T[] -> cd.comment;
                    #);
                  T: ^ Text; hadAssign: @boolean
               do current[] -> E[]; 
                  gdb;
                  (if isFirst then 
                      E.pushThis;
                      (superAdj,CC[]) -> E.loadOrigin -> (rec[],E[])
                  if); 
                      (* For X: = { R:  = { ... q: ...} ... R.X }
                       * stack[top] = origin = X 
                       * add offset to R or push(ref(R))
                       *)
                  cd.com(#do 'loadOrigin:afterIsFirst:'-> T; ' ' -> T;
                           ' ' -> T; current.doPT -> T #);
                  (if not isLast then
                      E[] -> rec[];
                      (if (next -> nE[]).ATd.primNo <> assign_prim then
                          (superAdj,CC[]) -> E.loadArgs;
                          (rec[],nE[],true,staticOff,CC[],none) -> E.invoke
                       else
                          cd.com(#do 'loadOrigin:assign:'-> T; #);
                          true -> hadAssign
                      if)
                   else
                      cd.com(#do 'loadOrigin:last:"' -> T;
                               current.doPt -> T; '"'->T  #);
                      (if hadAssign (*E.ATd.primNo = assign_prim *) then
                          cd.com(#do 'loadOrigin:last:assign:rec:'->T; rec.dopt -> T;
                                   ':E:' -> T; E.doPT -> T #);
                       else
                          cd.com(#do 'loadOrigin:last:NOTassign:rec:'->T; rec.doPT -> T;
                                   ':E:'->T; E.doPT -> T #);
                          (if not isFirst then
                              (rec[],rec[],true,staticOff,CC[],none) -> rec.invoke
                          if)
                      if)
                  if);
               #);
               (* S.simple_bar.c1 := 'x'
                *     rec = c1, E = ':='
                *     No pushOff for c1 = rec, since E = ':='
                *     no loadAsReceiver for c1 = rec
                * S.simple_bar.c1 + 1
                *     rec = c1, E = ':='
                *     pushOff for c1 = rec, but empty action
                *     loadAssReceiver for c1, since simple
                * S.simple_bar.simple_fisk
                *     rec = simple_bar, E = simple_fisk
                *     pushOff for simple_bar = rec
                *     loadAsReceiver for simple_bar, but empty action
                *)
            exit(rec[],E[])
            #);
       #);
     adjustOrigin:
       (# originOff: @integer
       enter originOff
       do ('AdjustOrigin:',originOff->int2text) -> cd.com2;
          (if (originOff > 0) then
              ('origin',originOff) -> cd.rpushg
          if)
       #);
     ObjectInvocation::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# markForCodeGen::
            (#
            do cd.com(#do 'ObjectInvocation:markForCodeGen:'-> T; dopt -> T;
                        ATd.dopt -> T #); 
               ATd.markForCodeGen
            #);
          pushThis:: (# do ATd.pushThis #);
          getAdr::
            (# gdb:: 
                 (#do ':superAdj:'->TT; adr.superAdj->TI; ':on:'->TT; on->TI#);
               Ax: ^Address
            do (*superAdj -> A.superAdj;*)
               adr[] -> Ax[];
               (if (on > 0) or (Ax.E[] = none) then
                   this(ObjectInvocation)[] -> Ax.E[];
                   (* tricky - in R.S.Q, R.on may be > 0, but S.on = Q.on = 0
                    * and the latter must not override on from R and E = R!
                    *)
               if);
               cd.com(#do 'OI:getAdr:after:On:'->T; on -> I; Ax.print -> T #);
               Ax[] -> ATd.getAdr -> (loadRec,adr[]);
               cd.com(#do 'OI:getAdr:after:ATd.getAdr:'->T; Ax.print -> T #);
            #);
          loadOrigin::
            (# gdb:: (# #);
               org: ^Items;
               T: @text
            do (if ATD.primNo
                // 0 
                // indexed_prim 
                // string_prim
                // stringGet_prim // indexedGet_prim
                // immutable_prim then 
                   (if superAdj < 0 then 
                       (if on > 0 then 
                           - superAdj -> AdjustOrigin;
                           (on - 1,this(ObjectInvocation)[]) 
                             -> (origin[]->org[]).goOrigin
                       if)
                    else
                       superAdj -> AdjustOrigin;
                       (on,this(ObjectInvocation)[]) -> (origin[]->org[]).goOrigin
                   if)
                // this_prim then
                   (* Must check that argument is the name of an enclosing 
                    * object or the name of the superpattern of an
                    * enclosing object.
                    * For %this foo, ON = %this.origin, A.super.ON = foo.origin
                    *)
                   superAdj -> AdjustOrigin;
                   args.scanArgs(* only one argument in %this foo *)
                   (# A: ^ObjectGenerator
                   do current[] -> A[];
                      (A.super.on - 1,this(ObjectInvocation)[])
                        -> (origin[]->org[]).goOrigin; 
                   #)
                // thisCore_prim then 
                   (* perhaps not in loadOrigin, but in execute/ATd.invoke *)
                   ('thisCore',thisCore_prim) -> cd.callPrim
               if);
               (* Actually rec = origin*n, E = this(OG) *)
               this(ObjectInvocation)[] -> E[] -> rec[]
            #);
          load::
            (#
            do cd.com(#do 'OI:load:'-> T; dopt -> T #);
               (rec[],A[]) -> ATd.load
            #);
          invoke::
            (#ptn: ^pattern
            do cd.com
               (#do 'OI:invoke:rec:' -> T; 
                  (if rec[] = none then 'none'->T else rec.dopt -> T if);
                  ' E:'->T; (if E[] = none then 'none'-> T else E.dopt -> T if)#);
               (* rec is a dataItem and there will thus be exactly one
                * variant for its OG
                *)
               (if atd## 
                // pattern## then
                   atd[] -> ptn[];
                   cd.com(#do 'OI:invoke:top:'->T; ptn.OG.Qvariants.top -> I;
                            'descNo:'->T; ptn.OG.IS.newdescno -> I #);
                // module## then
                   'OI:invoke:module' -> cd.comment
                // moduleItem## then
                   'OI:invoke:moduleItem' -> cd.comment
               if);
               cd.com(#do 'OI:invoke:adr:'-> T; (if adr[] <> none then adr.print -> T if)#);
               
               (rec[],E[],useReturnValue,staticOff,CC[],adr[]) -> ATd.invoke
            #);
          loadArgs:: 
            (#
            do (this(Exp)[],superAdj,CC[]) -> ATd.loadArgs
            #);
       #);       
     BracketedExp::
       (* a := b + (c * d)
        *     execute c * d
        * (foo).x
        *    loadOrigin foo
        * (foo(e1,e2)).x
        *    execute foo(e1,e29?
        * (%this P).suspend
        *     loadOrigin?
        * (E1)
        *    (E1).pushThis
        *    (E1).loadOrigin
        *    (E1).invoke
        *    rec -> E.invoke
        * (E1).E2
        *    
        * (R.S).foo
        * (R.bar(e1,e2,)).foo  
        * (ch = 'i') && (S <> none)
        * Do we always execute exp in (exp) and (exp).foo?
        * We should thus not just call load origin!?
        * What about (exp), (R.foo)
        * Look at gen: for (exp) we call loadOrigin and then execute
        *   for (exp).foo we call loadOrigin(exp) and then exe on foo
        *   but exe(exp) is not called
        *   How do we in loadOrigin ensure that exe(exp) is called when needed?
        * 
        * E1.(E2)
        * E1.(E2).E3
        *)
       (# markForCodeGen:: (#do IV.markForCodeGen #);
          Qgen:: 
            (# gdb:: (# do doPT -> lx.puttext #);
            do (* we dont come here *)
               (useReturnValue,superAdj,staticOff) -> IV.Qgen 
            #);
          getAdr::
            (# rec,E: ^Exp
            do cd.com(#do 'BracketedExp:getAdr:'->T;adr.print -> T 
                     #);
               adr[] -> IV.computeAdr -> (rec[],E[],adr[]);
               cd.com(#do 'BracketedExp:getAdr:after:computeAdr:'->T; adr.print->T#);
               (adr.superAdj,none) -> E.loadArgs;
               (* (rec[],E[],true,0,0,none,adr[]) -> E.invoke;*)
            #);
          pushThis:: 
            (* Skip, since loadOrigin below includes pushThis *)  
            (# #);
          loadOrigin:: 
            (# off: @integer; A: ^Address
            do (* OBS! useReturnValue, staticOff must be handled! *)
               superAdj -> Address -> IV.computeAdr -> (rec[],E[],A[]);
               ('BE:loadOrigin:E:',E.doPT) -> cd.com2;
            #);
          loadArgs:: 
            (* Skip, since loadOrigin includes loadArgs *)              
            (# #);
          invoke::(# #)
       #);
     Const::
       (# Qgen:: (# do invoke #);
          getAdr::
            (# gdb::(# do dopt -> lx.append #);
            do this(Const)[] -> adr.E[]
            #);
          invoke:: (# do T.setpos; T.getInt -> cd.pushConst #);
          load:: (# do T.setpos; T.getInt -> cd.pushConst #);
       #);
     CharObj::
       (# Qgen:: (* Never called? *) (# do invoke #);
          pushThis:: (# gdb::(# do doPt -> lx.append #)#);
          getAdr::
            (# gdb::(# do dopt -> lx.append #);
            do this(CharObj)[] -> adr.E[]
            #);
          invoke:: 
            (# gdb::(#do doPt -> lx.append #);
               ch: @char
            do (if T.length = 1 then
                   1 -> T.inxget -> cd.pushConst 
                else
                   (if 2 -> T.inxget -> ch
                    // 'n' then 10 -> cd.pushConst
                    else
                       'CharObj:Special symbol: ' -> puttext; ch -> putint;
                       ':' -> put; '"' -> put; ch -> put; '"' -> put;
                       newline;
                       ch -> cd.pushConst
                   if)
               if)
            #);
       #);
     StringObj::
       (# Qgen:: 
            (* Never called ? *)
            (# do 'String:gen:' ->puttext; doPT -> putline; invoke #);
          loadOrigin::
            (* In "hello".foo, "hello" plays the same role as R in R.foo,
             * i.e. we must generate a pushText "hello"
             * For an exp "Hello", 
             * loadOrigin then also generates a pushText "hello"
             * Invoke is called only for the last exp in R1.R2.exp 
             * and 'just store the string!
             *)
            (# 
            do cd.com(#do 'StringObj:loadOrigin:' -> T; dopt->T; #);
               (if not elimOrigin then T[] -> cd.pushText if);                
               this(StringObj)[] -> E[] -> rec[]
            #);
          getAdr:: (# do this(StringObj)[] -> adr.E[]; (*T[] -> cd.pushText*) #);
          invoke:: 
            (# 
            do (if elimOrigin then T[] -> cd.pushText if);
               (if not useReturnValue then cd.rPop if)
            #);
       #);
     ObjTmpStack: @
       (# item: 
            (# N: ^text; sig: ^Signature; OT: ^ObjectGenerator; super: ^Invocation;
               CC: ^CallChain; var: ^Variant
            enter(N[],sig[],OT[],super[],CC[],var[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; sig: ^Signature; 
               OT: ^ObjectGenerator; super: ^Invocation; 
               CC: ^CallChain; var: ^Variant
            enter(N[],sig[],OT[],super[],CC[],var[])
            do (if (top+1-> top) > OTL.range then 
                   OTL.range -> OTL.extend;;
                   done.range -> done.extend
               if);
               cd.com(#
                     do 'ObjTmpStack:add:'->T; N[] -> T;
                        (if var[] <> none then
                            ':genDone:'->T; var.GenDone -> B;
                        if);
                     #);
               (N[],sig[],OT[],super[],CC[],var[]) -> item -> OTL[top][];
               (* Does IS.newDescNo correspond to var? Probably no!?*)
            #);          
          next:
            (# inx: @integer; B: @boolean
            do 0 -> inx; false -> B;
               Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        cd.com(#
                              do 'objTmpStack:next: ' -> T;
                                 OTL[inx].N[] ->T; 
                                 ' : done:'->T; done[inx] -> B;
                                 ' :var.genDone: ' -> T;
                                 (if OTL[inx].var[] <> none then
                                     OTL[inx].var.genDone -> B
                                 if)
                              #);
                        (if not OTL[inx].var.genDone then
                            cd.com(#
                                  do 'objTmpStack:next:C: ' -> T;
                                     OTL[inx].N[] -> T;':descNo:' -> T; 
                                     OTL[inx].OT.IS.newdescno -> I; 
                                     ':top:' ->T ;
                                     OTL[inx].OT.Qvariants.top -> I;
                                  #);
                            (OTL[inx].N[],OTL[inx].sig[],OTL[inx].super[]
                            ,OTL[inx].CC[],OTL[inx].var[]) 
                              -> OTL[inx].OT.genClass;
                        if);
                        restart Loop
                    if);
                 #)
            exit B
            #); 
          OTL: [10] ^Item; top: @integer;
          done: [10] @boolean
       #);
     markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^TopNode;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if false then
                       '\nModule: ' -> puttext; md.DI.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).newDescNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   true -> md.mark;
                   (if md.origin[] <> none then
                       md.DI.NewOff -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genStubs:
       (# genMain:
            (# 
            do ('main',QnewDesc -> mDescNo,false,1,0) -> cd.class;
               cd.pushThis;
               (if false then
                   'TopModule: ' -> puttext;
                   markIncludes.topModule.DI.sig.doPT -> putLine;
                   'Main: ' -> puttext; main.doPt -> putline
               if);
               ('BETAworld',(markIncludes.topModule.desc).newDescno,0,true) 
                 -> cd.invoke;
               cd.stop; (* We should generate stop here and not in betaVM *)
               (0,0,0) -> CD.endClass;
               
               (if markIncludes.main## <> Module## then
                   '\n\n***** Only Modules can be executed *****\n\n'
                     -> putline
               if)
            #);
          genThreadStub:
            (# descNo: @integer;
            do QnewDesc -> descNo;
               ('ThreadStub',descNo,false,descNo,0) -> cd.class;
               (false,false) -> cd.actions;
               ('ThreadStub','D') -> cd.call;
               cd.stop
            #);
          genEventProcessor:
            (#
            do ('EventProcessor',QnewDesc,false,1,0) -> cd.class;
               cd.stop (* we should generate stop here and not in betaVM *)
            #);                   
       do genMain;
          genEventProcessor;     
          genThreadStub;
       #);
     mDescNo: @integer;
     mainDescNo:: 
       (# 
       do mDescNo -> value (* ad hoc *);
       #);
     (* cd: @ObjectCode; moved to abstractSyntaxTree for debugging purposes *)
     runTimeDescs:: (# do descs[] -> rtDescs[] #);
     descs: ^RunTimeDescriptors;
     BC: @File;
  do '**** GENERATOR ****' -> putline;     
     (FN[],'..s') -> mkAuxName -> BC.name;
     BC.openWrite;
     BC[] -> cd.init;
     'QBETA'-> cd.comment;
     
     labelHandler.init;
     0-> ObjTmpStack.top;
     main[] -> markIncludes;
     

     (*  Module::Qgen puts OG on ObjTmpStack *)
     (* rootModule = BETAworld must have descNo = 1 - no longer the case *)
     (# ptn: ^Pattern
     do rootModule.markForCodeGen;
        (* Pattern Object is special and not reached during a by-need scan
         * but must be allocated
         *)
        (objectDecl[] -> ptn[]).OG.computeVariant;
     #);
     
     L:
       (# B: @ boolean
       do false -> B;
          ObjTmpStack.next or B -> B;
          (* Eliminate boolean and fix test for objTmpStack.isEmpty *)
          (if B then
              restart L 
          if)
       #);
     genStubs;
     
     (if stringDecl[] <> none then
         (stringDecl.desc).newDescNo -> CD.descs.textDescNo
      else
         rootModule[] -> SemanticError(#do 'StringDecl not found!' -> msg #)
     if);
     (*  (if StructureRefDesc[] <> none then
      *          StructureRefDesc.newDescNo -> CD.descs.structureRefDescNo
      *       else
      *          rootModule[] 
      *            -> SemanticError(#do 'StructureRefDesc not found!' -> msg #)
      *    if);
      *)
     
     cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)
     
     cd.close;
     BC.close
  #)

