ORIGIN '~beta/basiclib/betaenv'; 
INCLUDE 'qvariants';
INCLUDE '../VM/objectcode';
BODY 'qgeneratorBody';
---lib:attributes---
generator: variants
  (# traceModules: (# exit false #);
     Module::
       (# markForCodeGen::
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                    if)
                 exit M[]
                 #);
               M: ^Module;
            do (if traceModules then
                   'MarkForCodeGen:module: ' -> puttext; DI.sig.dopt -> putline;
               if);
               DI.markForCodeGen;
               (if (encModule -> M[]) <> none then
                   M.markForCodeGen
               if)
            #);
          Qgen:: 
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                    if)
                 exit M[]
                 #);
               M: ^Module; var: ^Variant
            do (DI.sig.id[],newDesc.noOfDescs) -> cd.newComponent;
            #);       
          findNextImp:: (# do bcp -> DI.OG.IS.findNextImp -> impx[] #);
       #);
     ModuleItem::
       (# markForCodeGen:: 
            (#
            do (if tracemodules then
                   'MarkForCodeGen:moduleItem: isIncluded: ' -> puttext;
                   MD.isIncluded -> putBoolean; ' ' -> put;
                   MD.DI.sig.dopt -> putline;
               if);
               (if MD.isIncluded then MD.markForCodeGen if)#);
          Qgen::
            (#
            do (if MD.isIncluded then
                   (if traceModules then
                       'Module included: ' -> puttext; sig.doPT -> putline;
                   if);
                   ('ModuleItem:gen',sig.dopt) -> cd.com2;
                   (if MD.inMainPath then
                       MD[] -> mainPathModule[]
                    else
                       (useReturnValue,superAdj,staticOff) -> MD.DI.Qgen;
                   if)
                else
                   (if traceModules then
                       'Module not included: ' -> puttext; sig.doPT -> putline
               if)if)
            #);
          getAdr::
            (#
            do A[] -> MD.DI.getAdr -> (loadRec,A[])
            #);
          pushThis:: (# do cd.pushThis #);
          invoke:: (# do 'ModuleItem:invoke:'-> cd.comment; MD.DI.invoke #);
          store:: (# do '\nModuleItem:store'->putline #);
          popReturn:: (# do '\nModuleItem:popReturn'->putline #);
          findNextImp:: (# do bcp -> md.findNextImp -> impx[] #);          
       #);
     DataItem::
       (* Cases
        *    C1: val integer(12)
        *    C2: val integer
        *    C3: obj Fool
        *    C4: obj Fool -- singular
        *       ...
        *    V1: var integer(12)
        *    V2: var integer
        *    V3: ref Fool
        *    V4: ref Fool -- singular
        *       ...
        *    X1: obj/val/var foo(e1,e2,e3) where foo returns a ref(T) or val(T)
        *)
       (# markForCodeGen::
            (# 
            do cd.com(#do 'DataItem:markForCodeGen:'->TT; sig.id[]->TT;
                        ':descNo:'->TT; OG.IS.newDescNo -> II; 
                        ':OG.primNo:'->TT; OG.primno -> II;
                     #);    
               OG.markForCodeGen
            #);
          Qgen:: 
            (# T: @text; OGqual: ^ObjectGenerator
            do OG.getQual -> OGqual[];
               cd.com(#
                     do 'isConst:' -> TT; isConst -> BB;
                        ':isBasicValue:'->TT; OG.isBasicValue->BB;
                        ':primNo:'->TT; OG.primNo -> II;
                     #);
               cd.com(#
                     do 'OGqual:'-> TT; 
                        (if OGqual.sig[] <> none then OGqual.sig.doPT -> TT 
                         else 'none'->TT if);
                        ':OGqual.isBasicValue:' -> TT; OGqual.isBasicValue -> BB;
                        ':OGqual.isValueObj:' -> TT; OGqual.isValueObj -> BB;
                     #);
               (if isVirtualObject then
                   (*  '\***DataItem:qGen:virtual object: ' -> puttext;
                    dopt ->putline;*)
               if);
               (if true 
                // OG.isBasicPattern and not OG.isConstLiteral then
                   (* No OG.qGen for X: var/val integer
                    * Cf the discussion of #foo versus foo  *)
                // OG.isBasicValue then
                   (* C1,C2,V1,V2                
                    * X: val integer(7)
                    * X: var 7
                    * X: val a + b
                    *)
                   (if OG.isValueObj then 
                       (* OG is a ValueObject returning a Basic value like integer
                        *    mkIntB: ... out V: var integer ...
                        * We shall thus not allocate a value obj, 
                        * but a plain integer
                        * the invocation of mkIntB shall be boxed
                        *)
                       (*'DataItem:ValueObj:'->putline; dopt -> putline; *)
                       (* If OG is valueObj then
                        * newOff = 0 does not work
                        *)
                       (true,0,0) -> OG.Qgen 
                    else (* when is newOff needed here? *)
                       (true,0,this(DataItem).NewOff) -> OG.Qgen;
                   if);
                   cd.com(#
                         do 'dataItem:store:basicValue:' -> TT;
                            'off:' -> TT; off -> II;
                            ' NewOff:' -> TT; NewOff -> II
                         #);
                   cd.pushThis;                       
                   (sig.id[],this(DataItem).NewOff) -> cd.storeg
                // (OG.primNo = String_prim) and isConst then
                   (* Like S: obj "hello"
                    * Old comment:
                    * Could be  V: obj elm where elm:< Object 
                    * but is this true ?
                    *)
                   (true,0,this(DataItem).NewOff) -> OG.Qgen;
                   cd.pushThis;
                   (sig.id[],this(DataItem).NewOff) -> cd.rstoreg
                // isConst or not OG.IS.isEmpty or isValue then
                   (* C3,C4,V4 *)
                   (* All objects/patterns being embedded must be handled by
                    * Alloc and gen since we must know the size *)
                   (* X: = Foo or 
                    * Singular T: = P{...} 
                    * C3,C4,V4 *)
                   cd.bcPos -> beginBCP;
                   (if isInArg then (* also outArg? *)
                       cd.com(#do 'inArg:' -> TT; doPT -> TT #);
                    else
                       (false,0,this(DataItem).NewOff) -> OG.Qgen;
                   if);
                   cd.bcPos -> endBCP;
                   (* else V3 - just a qualifcation; 
                    * see also the discussion of #foo versus foo *)
                   (* Could be S: ?elm where elm:< Object -- no code gen *)
               if)
            #);
          pushThis:: (# do cd.pushThis #);
          getAdr::
            (# gdb::
                 (#
                 do ',newOff:'->TT; newOff -> II; ',isValue:'->TT; isValue-> BB;
                    ',A.isValue:' -> TT; A.isValue -> BB
                 #);
               E: ^Exp; originIsValue: @boolean
            do cd.com(#do ' A:'->TT; A.print -> TT; ' '  -> TT; dopt -> TT #);
               cd.com(#do 'value_prim:' -> TT;  OG.primNo = value_prim -> BB #);

               (* OG.primNo = value_prim for handling _v: ?Value 
                * in integer, char and boolean *)
               
               (if OG.isBasicValue or isValue or (OG.primNo = value_prim) then
                   (if not A.isValue then
                       true ->  loadRec;
                       A.E[] -> E[]; A.originIsValue -> originIsValue;
                       0 -> Address -> A[]; 
                       E[] -> A.E[]; originIsValue -> A.originIsValue;
                       newOff -> A.off;
                       OG.isBasicValue 
                       or OG.isValueObj or (OG.primNo = value_prim)
                         -> A.isValue;
                    else
                       (if A.off > 0 then
                           newOff - 1 + A.off -> A.off;
                        else
                           newOff -> A.off
                       if);
                       OG.isBasicValue 
                       or OG.isValueObj or (OG.primNo = value_prim)
                         -> A.isValue
                   if);
                   (if OG.primNo = float_prim then
                       (if false then 
                           '*** dataItem:X:getAdr:float:' -> puttext; dopt -> puttext;
                           ' A.isValue:'->puttext; A.isValue -> putboolean; newline;
                       if);
                       true -> A.isFloat
                   if);
                else                   
                   true -> loadRec;
                   0 -> Address -> A[];
                   newOff -> A.off
               if)
            #);
          invoke::
            (* called when not receiver - i.e. value to be pushed *)
            (# gdb::(#do ' newOff:'-> TT; newOff -> II #);
               orgIsVal: @integer
            do (if OG.isBasicValue or OG.isValueObj then 
                   (if (E[] <> none) then
                       (if (E.ATd.primNo <> cmpAndSwap_prim) then
                           (* May happen for V := 117 where := is assignment 
                            * - no offset shall be pushed for V 
                            * since V is assigned afterwards
                            * For R ++ 117 offset for R should be pushed 
                            * since it is origin
                            *) 
                           (if true
                            // OG.isBasicValue // OG.primNo = value_prim then 
                               (* OG.primNo = value_prim for handling _v: ?Value 
                                * in integer, char and boolean *)
                               adr.load
                            // OG.isValueObj then 
                               cd.com(#do '>LoadValue:isAdr:' -> TT;
                                        adr.isAdr -> BB; ',Size:'->TT; objSize -> II;
                                        ',rec:'->TT; rec.dopt -> TQ; ',E:' -> TT;
                                        E.dopt -> TQ;
                                     #);
                               true -> adr.isAdr;
                               adr.load;      
                               (*
                               (if (origin[] -> OG.IS.originIsValue) then
                                   cd.com(#do 'pushValue:OrgIsVal:'->TT; dopt -> TQ;
                                            ',size:'->TT; objSize -> II #);
                                   1 -> orgIsVal;
                                else
                                   cd.com(#do 'pushValue:'-> TT; dopt -> TQ;
                                            ',size:'->TT; objSize -> II #)
                               if);*)
                           if)
                        else
                           cd.com(#do
                                    'invoke:cmpAndSwap:'->TT; off->II;
                                    adr.print -> TT #);
                           (if true then
                               adr.loadAdr
                            else
                               off -> cd.pushConst
                           if)
                       if)
                    else
                       cd.com(#do '>:E=none' -> TT#);
                       (if adr[] <> none then 
                           adr.load
                        else
                           (sig.id[],NewOff) -> cd.pushg
                       if)
                   if)
                else
                   cd.com(#do '>Object:'->TT #);
                   (if adr[] <> none then 
                       adr.load
                    else
                       cd.com(# do '>adr=none'->TT #);
                       (sig.id[],NewOff) -> cd.rpushg
                   if)
               if)
            #);
          store::
            (* Called from Signature::StoreParameters *)
            (# gdb::(#do ',newOff:'->TT; newOff -> II;
                       ',isVirtualObject:' -> TT; isVirtualObject -> BB #);
               
               OGx: ^ObjectGenerator; var: ^Variant; 
            do (if true
                // OG.isBasicValue // OG.primNo = value_prim then 
                // OG.isValueObj then 
                   cd.com(# do '>StoreValue: ' -> TT;OG.dopt -> TQ#);
               if);

               (if true
                // OG.isBasicValue // OG.primNo = value_prim then 
                   (* OG.primNo = value_prim for handling _v: ?Value 
                    * in integer, char and boolean *)
                   cd.pushThis;
                   (sig.id[],NewOff) -> cd.storeg
                // OG.isValueObj then
                   (* is the order of src and dest objs on the stack correct? *)
                   (if true then
                       (# L1, L2: @labelHandler.label
                       do L1.new; L2. new;
                          L1 -> cd.jmpFalse;
                          cd.pushThis;
                          newOff -> cd.addOff;
                          (OG.objSize,0) -> cd.vassign;
                          L2 -> cd.jmp;
                          L1 -> cd.defLab;            
                          (if true then
                              (sig.id[],(OG.superPtn).new_DescNo,newOff - 1) 
                                -> cd.invokeVal;
                           else
                              (sig.id[],(OG.superPtn).OG.IS.newDescNo,newOff - 1) 
                                -> cd.invokeVal;
                          if);
                          L2 -> cd.defLab
                       #)
                    else
                       cd.pushThis;
                       (false,0,0) -> Qgen; 
                       newOff -> cd.addOff;
                       (OG.objSize,0) -> cd.vassign;
                   if)
                else
                   cd.pushThis;
                   (if not noSwap then cd.rswap if); 
                   (* Could be S: ?elm where elm:< Object *)                   
                   (sig.id[],NewOff) -> cd.rstoreg
               if)
            #);
          popReturn::
            (#
            do (if OG.isBasicValue then 
                   cd.vpop
                else
                   (* could be S. ?elm where elm:< object*)
                   cd.rpop
               if)
            #)          
       #);
     Signature::
       (# Qgen::
            (# 
            do (* TST/RemoteExp fails at      
                *    Bar(ch + 2).foo(ch + 2).print
                * if we call args.gen
                *)
               (false,0,0) -> args.Qgen
            #); 
          storeParameters:
            (#
            do scanArgsReverse
               (# D: ^Decl
               do (if not (currentPar[] -> D[]).isVirtual then
                      (*cd.pushThis;*)
                      true -> currentPar.store
                  if)
               #)
            #);
          pushReturnValues:
            (# ptn: ^Pattern; DI: ^DataItem
            do 
               (if (getReturnDecl -> DI[]) <> none then
                   (if false then
                       '**** pushReturnValues:Off:' -> puttext;
                       DI.newOff -> putint;
                       ' '  -> put; DI.doPT -> putline;
                   if);
                   (if not (theObjectGenerator).isValueObj then
                       cd.setThisStack
                   if);                   
                   (if DI.OG.isValueObj 
                       and not (DI.OG.primNo = integer_prim) 
                       and not (DI.OG.primNo = boolean_prim) 
                       and not (DI.OG.primNo = char_prim) 
                       and not (DI.OG.primNo = float_prim) 
                       then
                       cd.pushThis;
                       DI.newOff -> cd.pushConst;
                    else
                       cd.pushThis;
                       DI.invoke
                   if)
                else 
                   (if (theObjectGenerator).isValueObj then
                    else
                       cd.setThisStack;
                       cd.pushThis
                   if)
               if)
            #);
          popReturn:
            (# 
            do (if val[] <> none then
                   val.scanSons
                   (# D: ^Decl
                   do (current[] -> D[]).popReturn
                   #)
                else
                   cd.rpop
               if)
            #);
       #);
     Arguments::
       (# Qgen::
            (#
            do (*scanArgs
               (#
               do (if traceGeneric then
                      current.doPT -> putline;
                      current.label -> putline;
                  if);
                  (false,0,0) -> current.Qgen 
               #)*)
            #);
       #);
     ObjectGenerator::
       (# markForCodeGen::
            (# markPrimElse: BooleanValue(# <<SLOT doMarkPrim:doPart>> #);
               OGs: ^ObjectGenerator; ptn: ^Pattern
            do (if not marked and markPrimElse then
                   true -> marked;
                   cd.com(#do 'OG:markForCodeGen:'-> TT; dopt -> TT; #);
                   (if not super.isEmpty then
                       (if not (super.last).ATd.isPattern then
                           leave markForCodeGen
                       if);
                       (super.last).ATd[] -> ptn[];
                       (if ptn[] <> objectDecl[] then
                           cd.com
                           (#do 'OG:markSuper:'->TT ; super.dopt -> TT #);
                           super.markForCodeGen; 
                   if)if);
                   (if isObjectDesc then
                       cd.com(#do 'OG:markIS:'->TT; doPT -> TT #);
                       IS.markForCodeGen;                          
                       (this(ObjectGenerator)[],NONE,computeVariant)
                             -> objTmpStack.add;
                    else
                       cd.com(#do 'IS.isEmpty:'->TT; doPt -> TT #);
               if)if)
            #);
          computeVariant:
            (* OG.Qgen is called for a singular object
             * We thus only have one variant
             * This variant will propagate to superpatterns
             *)
            (# contextOG: ^ObjectGenerator;
               var,V: ^Variant
            enter contextOG[]
            do (*'----computeVariant:'->putline; dopt -> putline; *)
               (if contextOG[] = none then 
                   this(ObjectGenerator)[] -> contextOG[] if);
               cd.com(#do 'ComputeVariant:A:' -> TT; OGid -> TT #);
               Qvariants.new -> var[];                 
               
               (* this(OG) is not sufficient 
                * For 
                *    Lrecord.insert(Record(...))
                * we need Lrecord.OG
                *)
               (contextOG[],var[]) -> Qvariants.scanObjectRefs;
               (* We have a Variant of OG; 
                * if var.top = 0, there are no data-items depending on 
                * virtual Object (Later to be replaced by Any)
                *
                * Check that var[] does not already existt
                * var returned below may differ from var above *)
               Qvariants.checkIfTopIsNew -> V[];
               (if var[] = V[] then
                   cd.com(#do 'var is new:'->TT; 'top: '-> TT; Qvariants.top -> II;
                            'var.thisVarNo:'-> TT; var.thisVarNo -> II #);
                   (var.thisVarNo,none) -> Qalloc;
                   cd.com(#do 'computeVariant:newDescNo:'->TT; IS.newDescNo -> II;
                            'IS:'->TT; IS.doPT -> TT #);
                else
                   cd.com(#do'var is not new:'->TT #);
                   V[] -> var[]
               if);
               (*Qvariants.print;*)
               cd.com(#do 'ComputeVariant:B:' -> TT; OGid -> TT #);
            exit var[]
            #);        
          Qgen::
            (* Qgen is only called for singular Objects and pushed on stack
             * For patterns OG is pushed on stack and later genClass is called
             *)
            (# gdb:: 
                 (#
                 do OGid -> TQ;
                    (if IS.isEmpty then 
                        'IS.isempty: ' -> TT 
                     else
                        'singular:' -> TT
                    if);
                    'staticOff: '-> TT; staticOff -> II;
                    ' descNo: ' -> TT; IS.newDescno->II;
                    ' top:'->TT; Qvariants.top -> II
                 #);
               printQoff:
                 (#
                 do (if trace then
                        IS.scanSons
                        (# I: ^Item; D: ^Decl
                        do  current[] -> I[];
                           (if I.isDecl then 
                               I[] -> D[];
                               D.qoff[1] -> putint; ' ' -> put; D.doPT -> putline
                    if)#)if)
                 #);
               name: ^text; head: @boolean; Px: ^OGpath;
               on,pn: @integer;
               var: ^Variant;
               trace: (# exit false #);
            do (if not genIsDone then
                   (if primNo = inner_prim then
                       (*'TRYING code gen for inner'->putline*)
                   if);
                   (* Check if code has been generated for this variant *)
                   true -> genIsDone;
                   cd.com
                   (# ptn: ^Pattern; OI: ^ObjectInvocation; E: ^Exp
                   do 'ObjectGenerator:gen:' -> TT;
                      'IS.descNo:' -> TT; IS.newDescNo -> II;
                      'OG.top:'->TT; Qvariants.top->II;
                      super.last -> E[];                            
                      (if (E[] <> none) and (E## = objectInvocation##) then 
                          (if ((E[] ->  OI[]).ATD## = pattern##) then
                              (E[] ->  OI[]).ATD[] -> ptn[];
                              'super:'->TT; ptn.sig.dopt -> TQ;
                              'superDescNo:' -> TT; ptn.OG.IS.newDescNo -> II;
                              'super.OG.top:' -> TT; ptn.OG.Qvariants.top -> II;
                      if)if)
                   #);
                   (* we have non-singular: foo or singular: foo{...} *)
                   (*computeVariant -> var[]; *)
                   
                   cd.bcPos -> beginBCP;
                   (if CC[] <> none then (* not used? *)
                       this(ObjectGenerator)[] -> CC.add -> CC[];
                   if);
                   (if hasVariants then
                       (*'\nOG.hasVariants:\n' -> puttext; dopt -> printhead;
                        Qvariants.print*)
                   if);
                   (if IS.isEmpty 
                       and not super.hasVirtualArgs 
                       or (super.isPrimitive and IS.isEmpty) then
                       (* Implies that super.OG is pushed on objTmpStack
                        * So should we pass the variant of this OG to Qgen?
                        *)
                       cd.com(#do 'OG:Qgen:IS.isEmpty:' -> TT;#);
                       (useReturnValue,superAdj,staticOff) -> super.Qgen
                    else
                       (* Perhaps move check for virtuals to here!? *)
                       (* Singular object like R.foo{ }
                        * includes pattern invocations with 
                        * virtual arguments like %if .. %then% ... %else ...
                        *)
                       cd.com(#do 'OG:Qgen:IS is not empty:'->TT; #);
                       (if IS.noGlobals then
                           cd.com(#do 'noGlobals' -> TT #)
                        else                           
                           cd.pushThis; (* origin for a singular object *)
                           (* This is also the case for R.S.foo{ ... } *)
                       if);
                       (* Perhaps all patterns with more than one variant
                        * should be considered singular?
                        *)
                       (* Invoke the singular object *)
                       cd.com(#do 'before objTmpStack:add: '->TT;
                                IS.newDescNo -> II; ' ' -> TT; OGid -> TT #);
                       (OGid,IS.newDescNo,staticOff,true) -> cd.invoke; 
                       (if not useReturnValue then cd.rpop if);
                   if);
                   cd.bcPos -> endBCP;     
               if)
            #);
          genClass::
            (# var: ^Variant
            enter var[] (* super has more arguments *)
            do (if hasVirtualObject then
                   (if traceGeneric3 then
                       '***** HasVirtualObject: ' -> putline; 
                       (if sig[] <> none then 
                           sig.doPT -> putline;
                        else
                           doPT -> putline;
                           display
               if)if)if);
               (* Move IS.genclass to here? *)
               (this(ObjectGenerator),CC[],var[]) -> IS.genClass
            #);
          XaddB: @
            (# off: @integer; E: ^ObjectGenerator;
               offsets: [2] @integer;
               bindingType: [2] @integer; (* 0: inner; 1: ref; 2: value *)
               bindings: [2] ^ObjectGenerator;
               top: @integer;
               copySuper:
                 (# ptn: ^Pattern
                 do (if super.ATd[] <> none then
                        super.ATd[] -> ptn[];
                        (*'copySuper:' ->putline; ptn.OG.XaddB.display;*)
                        (for i: ptn.OG.XaddB.top repeat 
                             (*ptn.OG.XaddB.offSets[i] -> putint; ' '-> put;
                              ptn.OG.XaddB.bindingType[i] -> putint; newline;
                              (if ptn.OG.XaddB.bindings[i][] <> none then
                              ptn.OG.XaddB.bindings[i].dopt -> putline;
                              else
                              'none' -> putline
                              if);*)
                             (if ptn.OG.XaddB.offsets[i] > 0 then
                                 (ptn.OG.XaddB.offsets[i]
                                 ,ptn.OG.XaddB.bindings[i][]) 
                                   -> XaddB
                                 (*else = 0: inner *)
                             if)
                        for)                             
                    if)
                 #);
               display:
                 (# T: ^Text
                 enter T[]
                 do (if top > 0 then
                        T[] -> puttext; 
                        '*** Bindings: descNo: ' -> puttext; 
                        IS.newDescNo(*descNo*) -> putint; newline;
                        (for i: top repeat
                             i -> putint; ':' -> put;
                             offsets[i] -> putint; ':'->put;
                             (if bindingType[i]
                              // 0 then '   inner: ' -> puttext;
                              // 1 then '   ref: ' -> putline
                              // 2 then '   value: ' -> putline;
                              else 
                                 '   ???' -> putline
                             if);
                             (if bindings[i][] <> none then
                                 bindings[i].doPT -> putline
                              else 
                                 'none'->putline
                             if)
                    for)if)
                 #)      
            enter(off,E[])
            do (if handleGeneric then
                   (if off <= 0 then
                       '\n*** XaddB: off <= 0: '-> puttext;
                       off -> putint; newline;
                       dopt -> putline;
                       E.doPT -> putline;
                       leave XaddB
                   if);
                   (if off > bindings.range then
                       (off + 2 - bindingType.range) -> bindingType.extend;
                       (off + 2 - bindings.range) -> bindings.extend;
                       (off + 2 - offsets.range) -> offsets.extend;
                   if);
                   (if off > top then off -> top if);
                   off -> offsets[off];
                   (*'Add:' -> puttext; E.doPT -> puttext; 
                    ' ' -> put; off -> putint;
                    ' ' -> put; E.primNo -> putint; newline;*)
                   (if E.primNo // integer_prim then 
                       (* '--value--'->putline;*)
                       2 -> bindingType[off]
                    else 
                       1 -> bindingType[off]
                   if);
                   E[] -> bindings[off][];
               if)
            #);
          returnsThis: BooleanValue
            (# qual: ^ObjectGenerator
            do sig.getQual -> qual[];
               (*  '\n*** returnsThis: ' -> puttext;
                *  (if sig[] <> none then sig.dopt -> putline else newline if);
                *  qual.dopt -> putline;
                *)
               (this(ObjectGenerator)[] -> qual.inSuper) -> value;
               (*(if value then 'true' -> putline else 'false' -> putline if)*)
            #);
          computeGCinfo:
            (#
            do (*'***ComputeGCinfo:' -> puttext;
               (if sig[] <> none then sig.dopt -> putline else '#S#' -> putline if);*)
               cd.addGCinfo
               (# rtnDI: ^DataItem
               do (if IS.newOriginOff <> 0 then (* some objects have no origin *)
                      IS.newOriginOff -> add;
                  if);
                  (if sig[] <> none then
                      sig.scanArgs
                      (# DI: ^DataItem
                      do (if currentArg.isDataItem then
                             currentArg[] -> DI[];
                             (if DI.OG.isBasicValue or DI.isValue then
                              else
                                 (*'*** Got Ref arg: ' -> puttext; 
                                  * sig.dopt -> puttext;
                                  * ' : ' -> puttext; di.dopt -> putline;*)
                                 DI.newOff -> add
                         if)if)
                      #);
                      (if sig.val[] <> none then 
                          sig.val.scanSons(# do current[] -> rtnDI[] #);
                          (if rtnDI.OG.isBasicValue or rtnDI.isValue then
                           else
                              (*'*** Got Ref return arg: ' -> puttext; 
                              * sig.dopt -> puttext;
                              * ' : ' -> puttext; rtnDI.dopt -> putline;*)
                              rtnDI.newOff -> add                          
                      if)if)if);
                  (if (IS.superDesc[] <> none) and (IS.superDesc[] <> objectDecl.desc) then
                      (*'\nsuper: ' -> puttext; IS.superDesc.sig.dopt -> putline;*)
                      (IS.superDesc.theObjectGenerator).computeGCinfo
                  if);
                  IS.scanSons
                  (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
                  do (if current.isDataItem then
                         current[] -> DI[];
                         (if DI.OG.isBasicValue or DI.isValue then
                          else
                             (*DI.sig.dopt -> puttext; ':'->put;*)
                             DI.newOff -> add
                         if);
                      else 
                         (if current## 
                          // Module## then
                             current[] -> M[]; 
                            (* 'Module: '->puttext; moduleName -> puttext; ' ' -> put;*)
                             M.DI.newOff -> add
                          // ModuleItem## then
                             current[] -> MI[];
                             (if MI.MD.DI.off > 0 then
                                 (*'MI:'->puttext; MI.MD. moduleName->puttext;' ' -> put;*)
                                 MI.MD.DI.newOff -> add
                     if)if)if)
                  #);
                  (*newline*)
               #);
            #);
          clear::< (# do false -> marked; inner #);
          marked: @boolean;
       #);
     items::
       (# markForCodeGen::
            (#
            do cd.com(#do 'items:markForCodeGen:'->TT; doPT -> TT; #);
               scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if current.isDataItem then
                      current.MarkForCodegen 
                   else
                      (if I.isDecl then
                          (if not I.isPattern or I.isVirtual or(I[] = StringDecl[]) then
                              (if I[] = StringDecl[] then
                                  cd.com(#do 'Items:markString'->TT; dopt->TT #)if);
                              current.MarkForCodeGen 
                          if)
                       else
                          cd.com(#do 'markItem:'->TT; current.doPT -> TQ; 
                                   current.label -> TT #);
                          current.MarkForCodeGen 
                      if)
                  if)
               #);
            #);
          isIndexed: booleanValue
            (#                               
            do (if primNo // String_prim // indexed_prim then
                   true -> value
                else
                   (if superDesc[] <> none then
                       superDesc.isIndexed -> value
                   if)
               if)
            #);
          genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; super: ^Invocation;
               var: ^Variant;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
               enclosingOG,OG: ^ObjectGenerator;
               BindVirtuals:
                 (# handleDecl:
                      (# mkStubName:
                           (# T: ^text
                           do 'Vstub#' -> T[];
                              (if sig[] <> none then
                                  sig.id[] -> id[] -> T.append;
                               else
                                  'S' -> id[] -> T.append
                              if);
                              '#' -> T.put;    
                              OG.vDescNo -> T.putint;
                           exit T[]
                           #);
                         D: ^Decl; OG: ^ObjectGenerator; ptn: ^Pattern;
                         id: ^text; dNo: @integer; var: ^Variant
                      enter(D[],OG[])
                      do (if D.isVirtual then
                             cd.com(#do 'Virtual' -> TT #);
                             (if OG.nonVirtualBinding (*OG.vDescNo > 0*) then
                                 QnewDesc -> dNo;
                                 cd.com(#do 'genClass:BindVirtuals:descNo:'
                                            -> TT;
                                          dNo -> II
                                       #);
                                 objectDecl[] -> ptn[];
                                 (mkStubName,dNo,false,ptn.OG.IS.newDescNo
                                 ,newOriginOff,0) 
                                   -> cd.class;
                                 cd.com(#
                                       do 'Load origin:OG.isVirtualArg:' -> TT;
                                          OG.isVirtualArg -> BB #);
                                 (if OG.isVirtualArg then
                                     (OG.super.on + 1,OG.super[]) -> goOrigin;
                                  else
                                     (OG.super.on,OG.super[]) -> goOrigin;
                                 if);
                                 cd.com
                                 (#do 'OG.super.on/descNo:' -> TT; OG.super.on->I; 
                                    OG.getDescNo->I #);
                                 (id[],OG.getDescNo,0,true) -> cd.invoke;
                                 'D' -> cd.rtn;
                                 (* The vdtTableAt here overrides the one in 
                                  * HandleVirtArgument (check it)
                                  *)
                                 (objSize,false,props.OSDvisibility) 
                                   -> cd.endClass;
                                 cd.com(#do 'vdt:a'-> TT #);
                                 (D.off,dNo,newDescNo) -> CD.vdtTableAt
                         if)if)
                      #);
                    ptn: ^Pattern;
                    E: ^Exp;
                    args: [6]^ObjectGenerator; top,i: @integer;
                 do (if (super.last -> E[]) = none then 
                        (*'e is none' ->putline; dopt -> putline;*)
                        leave BindVirtuals
                    if);

                    (if E.args[] <> none then
                        cd.com(#do 'Handle VB: '->TT; dopt -> TQ;
                                 'E: ' -> TT; E.doPT -> TQ #);
                        E.args.scanArgs
                        (#
                        do (if (top+1 -> top) > args.range then 
                               args.range -> args.extend 
                           if);
                           current[] -> args[top][];
                        #);     
                        (if super.ATd[] <> none then
                            super.ATd[] -> ptn[];
                            (if ptn.OG.sig.length > 0 then (*[] <> none then*)
                                ptn.OG.sig.scanArgs
                                (# i: @integer
                                do i + 1 -> i;
                                   (currentArg[],args[i][]) -> handleDecl 
                                #)
                             else
                                ptn.OG.IS.scanAllDecls
                                (# i: @integer
                                do (* Only some inargs ,ay be virtual
                                    * And not all virtuals are inargs
                                    *)
                                   (if currentDcl.isInarg then
                                       i + 1 -> i;
                                   if);
                                   (if (currentDcl.isVirtual) 
                                       and currentDcl.isInarg then
                                       (currentDcl[],args[i][]) -> handleDecl
                                if)#)
                    if)if)if);
                    scanSons
                    (# I: ^Item; D: ^Decl; ptn: ^Pattern
                    do current[] -> I[];
                       (if I.isDecl then 
                           I[] -> D[];
                           (if D.isVirtual then
                               D[] -> ptn[];
                               (I[],ptn.OG[]) -> handleDecl 
                       if)if)
                    #)
                 #);   
               mainPathModule: ^Module;     
               CC: ^CallChain; superVar: ^Variant
                 (*enter(N[],sig[],descNo,Super[],OG[],CC[],var[])*)
            enter(OG[],CC[],var[])
            do (* Is called with descNo = NewDescNo *)
               (* We must know the actual variant being generated for
                * The actual variant should have info about: 
                * actual descNo and actual storage layout 
                *)
               (* the following dataitems used to be argumenst of genClass *)
               OG.OGid -> N[];
               OG.sig[] -> sig[];
               newDescNo -> descNo;
               OG.super[] -> super[];
               
               cd.com(#do '****GenClass:'->TT; N[] -> TT;
                        (if (var[] <> none) then
                            ' :varNo = '-> TT; var.thisVarNo -> II;
                         else
                            ':var is none' -> TT
                        if);
                     #);
               (if not OG.Qvariants.isEmpty then
                   (* '\n***** GenClass,N: ' -> puttext; 
                    N[] -> printNotNone; newline;
                    (if sig[] <> none then sig.doPT -> puttext; if);
                    ' varNo = ' -> puttext;
                    (if var[] <> none then var.thisVarNo -> putint if);
                    ' genDone = '->puttext;
                    (if var.genDone then 'True ' -> puttext if);
                    newline;
                    OG.Qvariants.print;*)
               if);
               2 -> labelhandLer.labCount;               
               (if (superDesc[] <> none) then
                   (* get the ptn decl for super: *)
                   superDesc.father.father -> ptn[]; 
                   (*'\n*** OBS! genClass:super: ' -> puttext;
                    ptn.sig.id[] -> putline;*)
                   (if (var[] <> none) then
                       (if var.thisVarNo > 0 then
                           (*'\n>>> genClass for ' -> puttext; N[] ->printNotNone;
                            ' varNo = ' -> puttext;
                            var.thisVarNo -> putint; *)
                           (* we should find the corresponding var in super 
                            * perhaps we should use the same object?
                            *)
                           var[] -> ptn.OG.Qvariants.findSuperVar -> superVar[];

                           (*(if superVar[] <> none then
                            '\n>>> superVarNo: ' -> puttext;
                            supervar.thisvarNo -> putint; 
                            ' genDone='->puttext;
                            (if superVar.genDone then 'True' -> puttext if);
                            else
                            'SuperVar is none'->puttext
                            if);
                            newline;
                            dopt -> printHead      *)               
                       if);
                    else
                       (* '\n>>> genClass for ' -> puttext; 
                        N[] -> printNotNone; 
                        ' (var = none)\n' -> putline;
                        dopt -> printHead;*)
                   if);

                   (if (superVar[] <> none) and not superVar.genDone 
                       or 
                       (superVar[] = none) and not superDesc.done then
                       (* the actual variant beging generated here must be
                        * propagated to super possibly implying that a new
                        * variant of super must be generated;
                        * we have actually propagated the actual var to the
                        * super, so should the propagation imply a 
                        * codegen (on objTmpStack) or should we do it here?
                        *)
                       (ptn.OG[],CC[],superVar[]) -> superDesc.genClass;
                       (* Perhaps vdtTableCopy below does not work
                        * if we have not called genClass!?
                        *)
               if)if);
               (*(if true 
                // (var[] = none) then done -> printBoolean 
                // var[] <> none then var.genDone -> printBoolean
                if);*)
               var[] -> thisVar[];
               (if (var[] = none) and not done or 
                   (var[] <> none) and not var.genDone then
                   (if (var[] <> none) and done then
                       (* we must eliminate this case 
                        * there should always be var <> none *)
                       cd.com(#
                             do 'OBS! calling genClass for:' -> TT; N[] -> TT;
                                ':var<>none:Done:'->TT;  done->BB;
                                ':leave genClass' -> TT
                             #);
                       (* (dumpStack,'---') -> stop;*)
                       true -> var.genDone;
                       leave genclass
                   if);
                   (if var[] <> none then 
                       cd.com
                       (#
                       do 'GenClass:'->TT; N[] -> TT; 
                          ':true -> var.genDone' -> TT #);
                       true -> var.genDone
                    else 
                       true -> done 
                   if);
                   
                   OG.XaddB.copySuper;
                   (# org: ^items; originDescNo: @integer
                   do (if (origin[] -> org[]) <> none then
                          org.newDescNo -> originDescNo
                      if);
                      (N[],newDescNo,false,(topSuper).newDescNo,newOriginOff
                      , originDescNo)
                        -> cd.class;
                   #);
                   (* thisObj = the new instance of this class 
                    * thisStack = caller
                    * Possible arguments on callerStack
                    *)
                   cd.bcPos -> beginBCP;
                   (* store parameters + origin *)
                   (if (sig[] <> none) 
                       and (sig.args.length > 0) 
                       and not sig.args.isNewKeyWord then 
                       (* '*** sig:'->puttext; sig.dopt -> puttext;
                        ' length:'->puttext; sig.args.length -> putint;
                        NEWLINE;
                        *)
                       sig.storeParameters 
                    else
                       cd.com(#do 'try itemArgs' -> TT #);
                       scanItemArgsReverse
                       (#
                       do true -> currentArg.store; 
                          (*'*** store: '->puttext; currentArg.doPT -> putline*)
                       #)                       
                   if);
                   (*'GenClass,items, ' -> puttext; N[] -> puttext;
                    ' ' -> put; newOriginOff -> putint; newline;*)
                   (if noGlobals and elimOrigin  then
                       (if traceNoGlobals then
                           '*** No globals-do not store origin' -> putline;
                           'do not store origin'->cd.comment;
                           dopt -> putline;
                       if)
                       (*cd.rPop*)
                    else                   
                       cd.tstOriginIsNone;
                       ('origin',newOriginOff) -> cd.rstore;
                       (if (origin[] -> originIsValue) then
                           cd.com(#do 'origin.valueOff:store:' -> TT;
                                    NewOriginOff + 1 -> II; #);
                           ('originOff',NewOriginOff + 1) -> cd.store
                       if)
                   if);
                   (if not OG.isValueObj then 
                       (if not ((superDesc[] <> none) and not superDesc.isPrimitive) then
                           true -> cd.allocEventQ
                   if)if);
                   
                   (if (superDesc[] <> none) and not superDesc.isPrimitive
                       or (superDesc[] <> none) 
                       and ((superDesc.primNo = stringDecl.primNo) 
                       or (superDesc.primNo = immutable_prim)) then
                       (ptn.sig.id[],superDesc.newDescNo)  -> cd.super; 
                       cd.com(#do 'vdt:b'-> TT #);
                       superDesc.newDescNo -> cd.vdtTableCopy;
                       (if superDesc.innerInx > 0 then
                           cd.com(#
                                 do 'vdt:c:innerInx: '-> TT; 
                                    superDesc.innerInx -> II;
                                    ' descNo: ' -> TT; newDescno -> II 
                                 #);
                           (superDesc.innerInx,newDescno) -> cd.vdtTable;
                           true -> hasSuperAndInner
                       if);
                       (* push super arguments *)
                       
                       (if super.isImplSuper then
                           (if elimOrigin and noGlobalsInsuper then
                            else
                               (if super.isSingularImplSuper then
                                   cd.pushThis;
                                   ('iOrigin',newOriginOff) -> cd.rpushg;
                                   (if (origin[] -> originIsValue) then
                                       (*'***Super:iOrigin isValue:'->puttext; dopt->putline;*)
                                       cd.pushThis;
                                       (T[],newOriginOff + 1) -> cd.pushg;
                                   if)
                                else
                                   super.ATd[] -> ptn[];
                                   origin[] -> vSuperDesc[]; (* find desc enclosing vDcl *)
                                   (for i: super.pn repeat
                                        vSuperDesc.superDesc[] -> vSuperDesc[]
                                   for);
                                   cd.pushThis;
                                   ('origin',newOriginOff) -> cd.rpushg;
                                   (if (origin[] -> originIsValue) then
                                       (*'***Super:origin isValue:'->puttext; dopt->putline;*)
                                       cd.pushThis;
                                       (T[],newOriginOff + 1) -> cd.pushg;
                                   if);
                                   (* No arguments for super, so no
                                    * - newOriginOff for loadArgs as below
                                    *)
                                   (ptn.OG.super.on,none) -> vSuperDesc.goOrigin
                           if)if)
                        else
                           (# E,rec: ^Exp; off: @integer; 
                              A: ^Address; caCalled: @boolean
                           do (*'GenItems:' -> puttext;
                               super.doPT -> puttext;
                               ' newOriginOff:'->puttext;
                               newOriginOff -> putint; 
                               ' super.on: ' -> puttext;
                               super.on -> putint; newline;*)
                              (if elimOrigin and noGlobalsInSuper then
                                  super.scanSons
                                  (#
                                  do current[] -> E[];
                                     (if not isLast then E[] -> rec[] 
                                      else
                                         (if isFirst then E[] -> rec[]
                                     if)if)
                                  #)
                               else 
                                  true -> caCalled;
                                  newOriginOff
                                    -> Address
                                    -> super.computeAdr
                                    -> (rec[],E[],A[]);
                                  cd.com
                                  (#do 'genClass:after:ComputeAdr:'-> TT; 
                                     E.doPT -> TQ; A.print -> TT #);
                              if);
                              (if sig[] = none then
                                  'Super:sig none'->cd.comment;
                                  (* do we need staticOff beloe? *)
                                  (newOriginOff,0,CC[]) -> E.loadArgs; 
                               else
                                  'Super:sig not none'->cd.comment;
                                  (* go ON - 1 
                                   * but use newOriginOff first time
                                   *)
                                  (* do we need staticOff beloe? *)
                                  (- newOriginOff,0,CC[]) -> E.loadArgs; 
                              if);
                           #);
                       if);
                       superDesc.newDescNo -> cd.toSuper;
                       cd.markEnterE;  
                   if); 
                   (if newDescNo = (markIncludes.topModule.desc).newDescno then
                       cd.pushThis;
                       cd.saveBETAworld
                   if);
                   (if isStringModule then cd.saveStringOrigin if);
                   (if (superDesc[] <> none) and not superDesc.isPrimitive  then
                    else 
                       (if not OG.isValueObj then
                           cd.mvStack
                       if)
                   if);
                   (if sig[] <> none then
                       (false,0,0) -> sig.Qgen
                
                   if);
                   scanSons
                   (# I: ^Item; MP: ^Module
                   do current[] -> I[];
                      (if I.isDecl then
                          (if not I.isPattern or I.isVirtual then
                              (false,0,0) -> current.Qgen -> MP[];
                              (if MP[] <> none then
                                  MP[] -> mainPathModule[];
                              if)
                           else
                              (if I[] = StringDecl[] then
                                  (false,0,0) -> current.Qgen if) 
                   if)if)#);
                   (if mainPathModule[] <> none then
                       (*'gen:mainPathModule: ' -> puttext;
                        * mainPathModule.DI.OG.IS.newDescNo -> putint;  
                        * ' ' -> put;
                        * mainPathModule.DI.sig.dopt -> putline; *)
                       (false,0,0) -> mainPathModule.DI.Qgen
                   if);
                   (if innerInx > 0 then innerInx -> cd.innerA if);
                   (if (superDesc[] <> none) and not superDesc.isPrimitive then
                       cd.rtnInner 
                    else
                       (if not OG.isValueObj then
                           (if doHasCode then 
                               1 -> cd.rtnEventQ 
                            else
                               0 -> cd.rtnEventQ 
                   if)if)if);
                   
                   (* Code for action part *)
                   (if false then
                       (false,false) -> cd.actions
                    else
                       (false
                       ,not OG.isValueObj and 
                       not ((superDesc[] <> none) and not superDesc.isPrimitive )
                       ) -> cd.actions;
                       (if not OG.isValueObj then cd.mvStack if);
                   if);
                   
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item; 
                   do current[] -> I[];
                      (if not I.isDecl then 
                          cd.com(#do 'genclass:Qgen:stmt:'-> TT; current.doPT ->TQ #);
                          (false,0,0) -> current.Qgen 
                      if) 
                   #);
                   leaveLab -> cd.defLab;
                   (* we must push return values *)
                   (* push return value 
                    * - for DataItem: R: @Foo
                    *   Foo should return (this(Foo)
                    *   perhaps default?
                    * - otherwise push variables in -> 
                    *)
                   (if (superDesc[] <> none) and not superDesc.isPrimitive then
                       cd.rtnInner
                    else
                       (if not OG.isValueObj then 0 -> cd.rtnEventQ if);
                       cd.com(#do 'OG:pushReturn:' -> TT; 
                                (if sig[] = none then 'none'->TQ
                                 else sig.id[] -> TQ if)#);
                       (if (theObjectGenerator).isValueObj then 
                           (if sig[] <> none then
                               sig.pushReturnValues
                           if);
                           cd.rtnV
                        else
                           (if sig[] <> none then 
                               sig.pushReturnValues 
                            else
                               (* ad hoc *)
                               cd.setThisStack;
                               cd.pushThis
                           if);
                           'D' -> cd.rtn
                       if)
                   if);
                   (theObjectGenerator).computeGCinfo;

                   (objSize,isIndexed,props.OSDvisibility) -> CD.endClass;

                   cd.bcPos -> endBCP
               if);
               (if traceGeneric2 then
                   (father[] -> enclosingOG[]).XaddB.display
               if);
               BindVirtuals
            #);
          goOrigin:
            (# on: @integer; NA: ^Apl; org: ^Items; T: ^text; var: ^Variant;
               orgIsVal: @boolean
            enter(on,NA[])
            do (if on > 0 then
                   cd.com(#do 'goOrigin:A:' -> TT; on -> II #);
                   OT.OGid -> T[]; ':origin' -> T.append;
                   (* For each pattern in the origin chain, we must check
                    * whether or not the specific pattern has restrictions
                    * that are violated
                    *)
                   NA[] -> checkGlobals;
                   (* how do we with newAlloc ensure that code is generated for
                    * OGs in the origin chain?
                    *)
                   (if basicNo = ifthen_prim then
                       cd.com(#do 'goOrigin:Skip:ifThen' -> TT #);
                       (on,NA[]) -> (origin[]->org[]).goOrigin -> (org[],orgIsVal)
                    else
                       (if OT.IS.newOriginOff = 0 then 
                           (*father.dopt -> putline;*)
                           (* move to vvariants.bet'*)
                           'OBS! Qalloc, originOff = 0 ' -> cd.comment;
                           OT.computeVariant -> var[];
                       if);
                       cd.com(#do 'goOrigin:'-> TT; OT.OGid-> TT; 
                                ':OT.IS.newOriginOff:' -> TT;
                                OT.IS.newOriginOff -> II; 
                                ':newOriginOff:' -> TT; newOriginOff -> II #);

                       (if (origin[] -> originIsValue) then
                           cd.com(#do 'origin.valueOff:load ' -> TT; newOriginOff + 1 -> II #);
                           cd.rdouble;
                           (T[],newOriginOff) -> cd.rpushg;
                           cd.rswap;
                           (T[],newOriginOff + 1) -> cd.pushg;
                           true -> orgIsVal
                        else
                           (T[],newOriginOff) -> cd.rpushg;
                       if);
                       (if (origin[] <> none) (*and (on > 1)*) then
                           (on - 1,NA[]) -> (origin[]->org[]).goOrigin -> (org[],orgIsVal)
                       if)
                   if)
                else
                   this(Items)[] -> org[]
               if)
            exit(org[],orgIsVal)
            #); 
          hasSuperAndInner: @Boolean;

          findNextImp::
            (#
            do L:
                 scanSons
                 (#
                 do (if (bcp -> current.findNextImp -> impx[]) <> none then
                        leave L
                 if)#);
            #)            
       #);
     Pattern::
       (# 
          markForCodegen::
            (#
            do cd.com(#do 'Pattern:markForCodeGen:' -> TT; ; dopt -> TT;#);
               OG.markForCodeGen
            #);
          GeneralPattern::
            (# invoke:: (# <<SLOT GeneralPattern_invoke:doPart>> #);
            #);
          AssignmentPattern::
            (# invoke:: (# <<SLOT AssignMentPattern_invoke:doPart>> #);
            #);
          BreakPattern::
            (# invoke:: (# << SLOT BreakPatternInvoke:doPart>> #)
            #);
          IndexedPattern::
            (# invoke:: (# <<SLOT IndexPattern_invoke:doPart>> #);
            #);
          OtherPrimPattern:: 
            (# invoke:: (# <<SLOT OtherPrim_invoke:doPart>> #); 
               org: ^Items; exitLab: @labelHandler.label;
            #);
          Qgen::
            (# enclosingOG: ^ObjectGenerator;
               DN: @integer
            do (if not genIsDone then
                   true -> genIsDone;
                   (if OG.primNo
                    // 0 
                    // object_prim // value_prim
                    // string_prim 
                    // indexed_prim // immutable_prim then
                       (if OG.IS.isExternal > 0 then leave Qgen if);
                       (if ptnKind 
                        // plainPtn then
                        // virtualPtn then
                           (if not OG.hasItems  then
                               cd.com(#do 'vdt:d'-> TT #);
                               (* Qalloc moved to vvariant.bet *)
                               (off,(OG.super.desc).newDescNo) -> cd.vdtTable;
                               (if traceGeneric then
                                   '*** Bind1: ' -> puttext;
                                   off -> putint; ' ' -> put; 
                                   (OG.super.desc).newDescNo -> putint; newline;
                                   dopt -> putline;
                               if);
                            else
                               cd.com(#do 'vdt:e'-> TT #);
                               (off,OG.IS.newDescNo) -> cd.vdtTable;
                               (if traceGeneric then
                                   '*** Bind2: ' -> puttext;
                                   off -> putint; ' ' -> put; 
                                   OG.IS.newDescNo -> putint; newline
                               if)
                           if);   
                           (if father.father##
                            // ObjectGenerator## then
                               (off, OG[]) 
                                 -> (father.father[]-> enclosingOG[]).XaddB
                            // Signature## then
                               (# ptn: ^pattern
                               do (off, OG[]) 
                                    -> (father.father.father[]-> ptn[]).OG.XaddB
                               #)
                            else                   
                               'Koks'->putline;
                               father.father.label -> putline
                           if)
                        // furtherPtn // finalPtn then
                           (if OG.IS.isEmpty then 
                               OG.vDescNo -> DN;
                               cd.com
                               (#do 'vdtTable: off: ' -> TT;
                                  off -> II; ' descNo: ' -> TT; DN -> II; 
                               #);
                            else
                               OG.IS.newDescNo -> DN;
                               cd.com(#do 'vdt:f:'-> TT; DN -> II;
                                        'getDescNo:' -> TT; OG.getDescNo -> II #);
                               (off,DN) -> cd.vdtTable;
                           if);
                           (if traceGeneric then
                               '*** Bind3: ' -> puttext;
                               off -> putint; ' ' -> put; 
                               OG.IS.newDescNo -> putint; newline ;
                               dopt -> putline
                           if);
                           (off, OG[]) -> (father.father[]-> enclosingOG[]).XaddB
                       if);
               if)if)
            #);
          pushThis::
            (# T: @text
            do (if OG.primNo
                // 0 
                // value_prim  (* OBS - needed for a ptn being sub of Value
                                * otherwise execution fails since origin 
                                * is not loaded
                                * An explicit sub of Object also fails
                                *)
                // this_prim 
                // indexedGet_prim (* not tested*)
                // indexedPut_prim (* ditto *)
                // stringGet_prim 
                // indexed_prim  
                // immutable_prim then
                   cd.pushThis 
                else (* ugly *)
                   (if ptnKind // virtualPtn // furtherPtn // FinalPtn then
                       cd.pushThis 
                   if)
               if)
            #);
          loadArgs::
            (# gdb:: 
                 (# 
                 do 'E:' -> TT; E.doPT -> TQ;
                    ':descNo:' -> TT; OG.IS.newDescNo -> II;
                    ':top:' -> TT; OG.Qvariants.top -> II
                 #);
               handleVirtualArg:
                 (# Ex: ^Exp; OI: ^ObjectInvocation; 
                    name: ^text; descNo: @integer;
                    ptn: ^Pattern;
                    currentArg: ^Decl; argInx: @integer
                 enter(currentArg[],argInx)
                 do (if primNo = indexed_prim then
                        leave handleVirtualArg
                    if);
                    handleVirtArg: 
                      (# OGx: ^ObjectGenerator
                      do L:
                           actArgs[argInx].super.scanSons
                         (#do current[] -> Ex[]; leave L #);
                         (if (Ex[] <> none) and (Ex.isObjectInvocation) then
                             Ex[] -> OI[];
                             (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                 OI.ATd[] -> ptn[];
                                 (actArgs[argInx].desc).newDescNo -> descNo; 
                                    
                                 (* Perhaps OGx below is enclosingOG as
                                  * also used below? Need OGx.descNo for VDT *)
                                 E.father.father[] -> OGx[]; 

                                 (* May be (always?) overwritten in
                                  * generation og vStub in 
                                  * BindVirtuals::handleDecl
                                  *)
                                 (currentArg.Off
                                 ,actArgs[argInx].vDescNo,(OGx.desc).newDescNo) 
                                   -> cd.vdtTableAt;
                                 (currentArg.Off, actArgs[argInx][])
                                   -> (E.father.father[]-> enclosingOG[]).XaddB;
                                 leave handleVirtArg
                         if)if); 

                         (if (E.desc).primNo = indexed_prim then 
                             (* We ignore bindings of elm in Indexed *)
                             leave handleVirtArg
                          else
                             (if actArgs[argInx].primNo = integer_prim then
                                 '\n*** Virtual bound to integer in\n\n\t'
                                   -> puttext;
                                 E.doPT -> putline;
                                 '\n    is ignored by the compiler\n' 
                                   -> putline;
                                 leave handleVirtArg
                         if)if);
                         (* Perhaps always computeVariant -> var
                          * we need descNo to compute name so
                          * cannot be part of tmpStack.add *)
                         currentArg.sig.id.copy -> name[];
                         '#SB#' -> name.append;
                         (actArgs[argInx].desc).newDescno 
                           -> descNo -> name.putint;

                         E.father.father[] -> OGx[]; 
 
                         (currentArg.off,descno,(OGx.desc).newDescNo) 
                           -> cd.vdtTableAt;

                         (currentArg.off, OGx[]) 
                           -> (father.father[]-> enclosingOG[]).XaddB;
                      #);
                 #);
               handleNonVirtualArg:
                 (# formalArg: ^DataItem; (* Never at pattern og virtual here!? *)
                    argInx: @integer; DI: ^DataItem
                 enter(formalArg[],argInx)
                 do (if argInx > top then
                       (* 'argInx > top: ' -> puttext; 
                        argInx -> putint; ' ' -> put; top -> putint; ' ' -> put;
                        formalArg.doPt -> putline;
                        *)
                        (* Probably Super as in
                         *    foo{ ... }
                         * where foo has arguments - to be fixed! *)
                     else
                        cd.com
                        (#do 'loadArgs:NonVirt:'->TT; actArgs[argInx].dopt->TQ;
                           ' isValue: ' -> TT;  actArgs[argInx].isValueObj->BB
                        #);
                        (* The call of Qgen should perhaps have the receiver
                         * as an argument!? Currenly we handle stuff af Qgen
                         * that depends on the receiver
                         *)
                        0 -> staticOff;
                        (true,superAdj,staticOff) -> actArgs[argInx].Qgen;
                        
                        (* The code below needs a clean-up with repect to
                         * formal/actual arg being basicValue, valueObj 
                         * or material
                         * And whether or not this(pattern) is vassign,
                         * valueObj or material obj
                         *)
                        (if actArgs[argInx].isValueObj 
                            and actArgs[argInx].super.ATd.isDataItem 
                            and not actArgs[argInx].isBasicValue
                            then
                            cd.com(#do 'before:pushValue' -> TT; #);
                            actArgs[argInx].objSize -> cd.pushValue;
                            (if (this(Pattern).primNo <> vAssign_prim) then
                                cd.com
                                (#do 'pattern:loadArg:Value:dataItem:' -> TT #);
                                1 -> cd.pushConst
                            if)
                         else
                            (if (this(Pattern).primNo = vAssign_prim) then
                                (if actArgs[argInx].isValueObj 
                                    and actArgs[argInx].super.ATd.isPattern
                                    then
                                    cd.com
                                    (#do 'ptn:after:loadArgs:vassign:formalArg:'
                                         -> TT;
                                       actArgs[argInx].dopt -> TQ #);
                                if)
                             else
                                cd.com(#
                                      do 'ptn:after:loadArgs:argInx:' -> TT; 
                                         argInx -> II;
                                         ':isBasicVal:'->TT; 
                                         formalArg.isBasicValue -> BB;
                                         ':valueObj:' -> TT; 
                                         formalArg.isValue -> BB;
                                      #);
                                cd.com(#
                                      do ':formalArg:' -> TT; formalArg.doPT->TQ
                                      #);
                                cd.com(#
                                      do ':actArg:' ->  TT;
                                         actArgs[argInx].dopt -> TQ
                                      #);
                                (if formalArg.OG.isValueObj 
                                    and not formalArg.isBasicValue 
                                    and not actArgs[argInx].isValueObj 
                                    then
                                    (* actArgs[argInx] must be a pattern
                                     * returning a value *)
                                    formalArg.objSize -> cd.pushValue;
                                    1 -> cd.pushConst
                                if)
                            if)
                        if)
                    if)
                 #);
               actArgs: [6]^ObjectGenerator; (* actual arguments *)
               top,argInx: @integer;
               enclosingOG: ^ObjectGenerator;
               var: ^Variant;
            do cd.com(#do 'isValueAssign: ' -> TT; 
                        E.ATd.primNo = vAssign_prim->BB #);
               
               (if OG.primNo 
                   (* Some of these are handled in invoke below
                    * May be moved to here*)
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   (* skip *)
                else
                   E.args.scanArgs
                   (#
                   do (if (top+1 -> top) > actArgs.range then 
                          actArgs.range -> actArgs.extend 
                      if);
                      current[] -> actArgs[top][];
                   #);
                   scanArgs
                   (#
                   do argInx + 1 -> argInx; 
                      (* can we do currentArg.LoadArg?
                       * And then perhaps special for virtuals primitive
                       * and ptName? Virt is of course ptn *)
                      (if currentArg.isVirtual then
                          (currentArg[],argInx) -> handleVirtualArg;
                       else
                          (currentArg[],argInx) -> handleNonVirtualArg
                      if);
                   #);
                   handleSuperArgs:
                     (if argInx < top then 'QQQ' -> putline;
                         (* a hack - need to scan arguments of super *)
                         argInx + 1 -> argInx;
                         (true,superAdj,staticOff) -> actArgs[argInx].Qgen;
                         restart handleSuperargs
                     if);
               if);
            #);
          load::
            (#
            do cd.com
               (#do 'Pattern:load:'->TT;OG.primNo->II; ' '->TT; dopt->TT #);
               (if OG.primNo
                // rAssign_prim
                // vAssign_prim then
                   '\n\n***** pattern:load:assign_prim: called A.store'
                     -> putline;
                   A.store
               if);
            #);
          getAdr::
            (# B: @boolean
            do cd.com(#do A.print -> TT #);
               (if isPrimitive then
                   true -> loadRec;
                else
                   true -> loadRec;
                   true -> A.isAdr
               if);
            #);
          invoke:: 
            (# 
            do (rec[],E[],useReturnValue,staticOff,CC[],adr[]) 
                 -> currentPtnKind.invoke 
            #);
          popReturn:
            (* perhaps this should be the same virtual as in dataItem!?
             * And do consider signature:popReturn
             *)
            (# D: ^Decl
            do (if (sig.getReturnDecl -> D[]) <> none then
                   D.popReturn
                else 
                   cd.rpop
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);
          clear::< (# do false -> genIsDone; inner #);
          genIsDone: @boolean;
       #);
     Address: superAdr
       (* E = first exp in "R.S.Q", ie. E = "R" *)
       (# done: @boolean;
          load::
            (#
            do (if isAdr then
                   loadAdr
                else
                   (if off > 0 then
                       cd.com(#do 'load:'->TT; this(Address).print -> TT #);
                       (if isValue then
                           (if originIsValue then
                               ('',off) -> cd.ovpushg
                            else
                               cd.com(#do 'isFloat: ' -> TT; isFloat -> BB #);
                               (if isFloat then
                                   ('',off) -> cd.fpushg
                                else
                                   ('',off) -> cd.pushg
                               if)
                           if)
                        else

                           ('',off) -> cd.rpushg
               if)if)if)
            #);
          loadAdr::
            (#
            do (if off > 0 then
                   cd.com(#do 'loadAdr:'->TT; this(Address).print -> TT #);
                   (if isValue then
                       cd.com
                       (#do 'loadAdr:isValue:'-> TT; 
                          'originIsValue:'->TT; originIsValue -> BB#);
                       (if originIsValue then
                           off - 1 -> cd.pushConst;
                           61 (*plus*) -> cd.op
                        else
                           off -> cd.addOff;
                       if);
                    else
                       ('',off) -> cd.rpushg
               if)if);
            #);
          store::
            (# mode: @integer
            do (if not done then
                   true -> done;
                   cd.com(#do 'store:'->TT; this(address).print->TT #);
                   (if off > 0 then
                       (if isValue then
                           (if isAdr then
                               (if descNo > 0 then
                                   cd.vpop;
                                   cd.saveAndSetThis;
                                   ('IV',descNo,off - 1) -> cd.invokeVal;
                                   cd.restoreThis
                                else                                   
                                   (*(if srcIsVal then 1 -> mode if);
                                    (if destIsVal then mode + 2 -> mode if);*)
                                   (if originIsValue then 1 -> mode if);
                                   cd.com(#do 'Address:store::srcIsVal:'->TT; 
                                            srcIsVal -> BB;
                                            ' destIsVal:' -> TT; originIsValue -> BB;
                                         ' mode:' -> TT; mode -> II #);
                                   off -> cd.addOff;
                                   (size,mode) -> cd.vassign
                               if)
                            else
                               (if originIsValue then
                                   cd.com(#do 'Address:store:originIsValue:'->TT #);
                                   ('',off) -> cd.ovstoreg
                                else
                                   cd.com(#do 'isFloat: ' -> TT; isFloat -> BB #);
                                   (if isFloat then
                                       ('address:storeg',off) -> cd.fstoreg
                                    else
                                       ('address:storeg',off) -> cd.storeg
                                   if);
                           if)if)
                        else
                           (* OBS! must check if rswap sometimes is not needed
                            * apparently noswap = true when storing arguments;
                            * See store arguments
                            *)
                           (if true then cd.rswap if);
                           ('',off) -> cd.rstoreg
                       if)
               if)if)
            #);
          print::
            (# 
            do ':Address:E:"'-> T.append; 
               (if E[] = none then 'none'->T.puttext
                else
                   E.dopt -> T.puttext 
               if);
               '"off:'-> T.puttext; off -> T.putint;
               ' size:'-> T.puttext; size -> T.putint;
               ' superAdj:'->T.puttext; superAdj->T.putint;
               ' isValue:' -> T.puttext; 
               (if isValue then 'True'-> T.puttext else 'False'->T.puttext if);
               ' originIsValue:' -> T.puttext; 
               (if originIsValue then 'True'-> T.puttext
                else 'False'->T.puttext if);
            #);
       enter superAdj
       exit this(Address)[]
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.on -> gorigin
        *    E1.pushOff
        *    E2.pushOff
        *    E3.invoke
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# markForCodeGen::
            (# ptn: ^Pattern; OGs: ^ObjectGenerator; E,rec: ^Exp
            do cd.com(#do 'Invocation:markForCodeGen:'->TT; dopt -> TT;#);
               scanSons
               (#
               do current[] -> E[]; 
                  current.MarkForCodeGen;
                  (if not isLast then E[] -> rec[] 
                   else
                      (if isFirst then E[] -> rec[]
                  if)if)
               #);
               (if (E[] <> none) and (E.args[] <> none) then
                   E.args.scanArgs
                   (#
                   do cd.com(#do 'arg:' -> TT; ' '-> TT; current.dopt -> TT#);
                      current.markForCodeGen
               #)if)
            #);          
          Qgen:: 
            (# gdb:: 
                 (# 
                 do scanSons
                    (# ptn: ^Pattern; OI: ^ObjectInvocation
                    do (if (current## = ObjectInvocation##)
                           and 
                           ((current[] -> OI[]).ATD## = pattern##) then
                           OI.ATd[] -> ptn[];
                           ' descNo: ' -> TT;
                           ptn.OG.IS.newDescNo -> II;
                           ' top: ' -> TT;
                           PTN.OG.Qvariants.top -> II
                       if)
                    #)                                         
                 #);
               rec,E: ^Exp; T: ^Text;
               needOrigin: booleanValue
                 (# IT: ^Items
                 do true -> value;
                    cd.com(#do 'needorigin:'-> TT; dopt -> TQ #);
                    scanSons
                    (#
                    do current[] -> E[]; 
                       (if not isLast then E[] -> rec[] 
                        else
                           (if isFirst then E[] -> rec[]
                       if)if)
                    #);
                    cd.com(#do 'needOrigin:E:'->TT; E.dopt -> TQ; 
                             ' E.ATd:'-> TT; E.atd.dopt -> TQ #);
                    (if not E.ATd.isPattern then (* DataItem *)
                        cd.com(#do 'needOrigin:datItem:leave'->TT #);
                        leave needOrigin
                    if);
                    E.ATd.desc -> IT[]; 
                    (if IT.noGlobals and elimOrigin then
                        cd.com(#do 'LoadOrign:no:loadOrigin: ' -> TT;
                                 (IT.theObjectGenerator).doPT -> TQ #);
                        false -> value
                    if)
                 #);
            do (*'Invocation:Qgen:' -> puttext; dopt -> putline;*)
               (* for P1.X := P2.Y,
                * we need no origin for P1 (and X!?)
                * we need adress of P1 to be added address of X to get embedded
                * adr of X
                * In R.foo, of fo has noGloblas we shall not load adr of R
                * How about: R.S.T.Q ? Q noGlobals, or globals?
                *)
               cd.bcPos -> beginBCP;
               (# A: ^Address; off: @integer
               do (if needOrigin then
                      superAdj
                        -> Address
                        -> computeAdr -> (rec[],E[],A[]);
                  if);
                  (if (E.ATd.primNo = vAssign_prim) and (A[] <> none) then 
                      A.off -> off if);
                  cd.com(#do 'OI:after:computeAdr:superAdj:'->TT; 
                           superAdj-> II; 
                           (if A[] <>  none then A.print -> TT if)#);
                  cd.com(#do 'rec: ' -> TT; rec.dopt -> TQ;
                           'E: ' -> TT; E.dopt -> TQ;
                           'isValueAssign: ' -> TT;
                           E.ATd.primNo = vAssign_prim -> BB; 
                        #);

                  (superAdj,off,CC[]) -> E.loadArgs;
                  cd.com(#do 'OI:after:loadArgs:E:'->TT; E.dopt -> TQ #);
                  (rec[],E[],useReturnValue,staticOff,CC[],A[]) 
                    -> E.invoke;
               #);
               cd.bcPos -> endBCP
            #);
          computeAdr:
            (* R.S.foo(exp).Q
             * X := Y + (Z +117)
             * aLine.aPoint.X
             *)
            (# A,recA: ^Address; E,rec,pRec: ^Exp; j: @integer; 
               loadRec,orgIsVal: @boolean
            enter A[]
            do 
               scanSons
               (#
               do rec[] -> pRec[];
                  E[] -> rec[];
                  current[] -> E[];                  
                  cd.com
                  (#do 'computeAdr:'->TT; j+1->j->II; ':rec:'->TT; 
                     (if rec[]<> none then rec.dopt-> TQ else 'none'->TQ if);
                     ' E:'->TT; E.dopt -> TQ;  A.print -> TT
                  #);
                  (if isFirst then
                      E[] -> rec[];
                      E.pushThis;
                      (* E.loadOrigin - we must do this also for values *)

                      (A.superAdj,none) -> E.loadOrigin -> (rec[],E[],orgIsVal);
                      (* we should ignore rec and E - defined above 
                       * And A.superAdj should be eliminated *)
                      A[] -> E.getAdr -> (loadRec,A[]);
                      (* really getOffSet of E.ATd *)
                      (if (E.on > 0) or (A.superadj > 0) then
                          (E.ATd.enclosingObjectGenerator).isValueObj 
                            -> A.originIsValue
                          (* should probably be for each receiver in
                           * R.S.foo(exp).Q, i.e. R, S and foo
                           *)
                      if);                      
                   else
                      (* mutex.cmpAndSwap 
                       * rec = mutex, cmpAndSwap = E
                       *)
                      (if (E.ATd.primNo <> rAssign_prim) 
                          and (E.ATd.primNo <> vAssign_prim) then
                          cd.com(#do 'E:notAssign:'->TT; E.dopt->TT #);
                          A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                          (if loadRec then
                              (* In R.foo, rec = R, E = foo
                               *    P.print, rec = P, E = print
                               *    R.S,      rec = R, E = S
                               * E is a pattern or dataItem 
                               *)
                              (A.superAdj,0,none) -> rec.loadArgs;
                              (* Perhaps a combined invoke & getAdr *)
                              
                              (* A is the address of E - not of rec!!!!!!! *)
                              
                              (pRec[],E[],true,0,none,recA[]) -> rec.invoke;
                          if);
                          (* really getOffSet of E.ATd *)
                       else
                          cd.com(#do 'E:isAssign:'-> TT; E.dopt -> TT#); 
                      if);                      
                  if);
               #);
            exit(rec[],E[],A[])
            #);          
          loadOrigin:
            (# usereturnValue: @boolean;
               staticOff,superAdj: @integer;
               rec,E,nE: ^Exp; CC: ^CallChain;
            enter(useReturnValue,staticOff,superAdj,CC[])
            do ('Invocation:loadOrigin:',doPT) -> cd.com2;
               (* could rec be thisObject for first E1 in E1.E2.E3 ?*)
               (* Perhaps the other way around
                * e1 -> rec
                * rec -> e2.invoke
                * e2 -> rec
                * rec -> e3.invoke
                *)
               scanSons
               (# gdb: debug
                    (#
                    do 'Invocation:loadOrigin:scan: ' -> TT;
                       current.doPT -> TQ;
                    #);
                  T: ^ Text; hadAssign,orgIsVal: @boolean
               do current[] -> E[]; 
                  gdb;
                  (if isFirst then 
                      E.pushThis;
                      (superAdj,CC[]) -> E.loadOrigin -> (rec[],E[],orgIsVal)
                  if); 
                      (* For X: = { R:  = { ... q: ...} ... R.X }
                       * stack[top] = origin = X 
                       * add offset to R or push(ref(R))
                       *)
                  cd.com(#do 'loadOrigin:afterIsFirst:'-> TT; current.doPT -> TQ #);
                  (if not isLast then
                      E[] -> rec[];
                      (if (next -> nE[]).ATd.primNo <> rAssign_prim then
                          (superAdj,staticOff,CC[]) -> E.loadArgs;
                          (rec[],nE[],true,staticOff,CC[],none) -> E.invoke
                       else
                          cd.com(#do 'loadOrigin:assign:'-> TT; #);
                          true -> hadAssign
                      if)
                   else
                      cd.com(#do 'loadOrigin:last:' -> TT; current.doPt -> TQ #);
                      (if hadAssign (*E.ATd.primNo = rAssign_prim *) then
                          cd.com(#do 'loadOrigin:last:assign:rec:'->TT; rec.dopt -> TT;
                                   ':E:' -> TT; E.doPT -> TT #);
                       else
                          cd.com(#do 'loadOrigin:last:NOTassign:rec:'->TT; rec.doPT -> TT;
                                   ':E:'->TT; E.doPT -> TT #);
                          (if not isFirst then
                              (rec[],rec[],true,staticOff,CC[],none) -> rec.invoke
                          if)
                      if)
                  if);
               #);
               (* S.simple_bar.c1 := 'x'
                *     rec = c1, E = ':='
                *     No pushOff for c1 = rec, since E = ':='
                *     no loadAsReceiver for c1 = rec
                * S.simple_bar.c1 + 1
                *     rec = c1, E = ':='
                *     pushOff for c1 = rec, but empty action
                *     loadAssReceiver for c1, since simple
                * S.simple_bar.simple_fisk;
                *     rec = simple_bar, E = simple_fisk
                *     pushOff for simple_bar = rec
                *     loadAsReceiver for simple_bar, but empty action
                *)
            exit(rec[],E[])
            #);
          goInclude:<
            (# org: ^Items; onx: @integer; orgIsVal: @boolean;
               MI: ^ModuleItem; id: ^lexem; OI: ^ObjectInvocation
            enter(org[],onx)                       
            do cd.com(#do 'viaIncl:on:' -> TT;dopt -> TQ;
                        'org:'->TT; org.dopt -> TQ
                     #);
               (if (last-> OI[]).ptnId.viaIncl[] = none then
                   cd.com(#do 'goInclude:endOfIncludeChain'->TT; #);
                   (onx + on + 1,OI[])
                     -> org.goOrigin  -> (org[],orgIsVal);
                else
                   cd.com(#do 'goInclude:furtherInclude' -> TT #);
                   (org[],on + 1) 
                     -> OI.ptnId.viaIncl.goInclude -> (org[],orgIsVal)
               if);
               ATd[] -> MI[];
               (MI.MD.DI.sig.id[],MI.MD.DI.newOff) -> cd.rpushg
            exit(org[],orgIsVal)
            #);
       #);
     adjustOrigin:
       (# originOff: @integer
       enter originOff
       do ('AdjustOrigin:',originOff->int2text) -> cd.com2;
          (if (originOff > 0) then
              ('origin',originOff) -> cd.rpushg
          if)
       #);
     ObjectInvocation::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# 
          markForCodeGen::
            (#
            do cd.com
               (#do 'ObjectInvocation:markForCodeGen:'-> TT; dopt -> TT;
                        ' ATd:' ->TT; ATd.dopt -> TT #); 
               ATd.markForCodeGen
            #);
          pushThis:: (# do ATd.pushThis #);
          getAdr::
            (# gdb:: 
                 (#do ':superAdj:'->TT; adr.superAdj->II; ':on:'->TT; on->II#);
               Ax: ^Address
            do (*superAdj -> A.superAdj;*)
               adr[] -> Ax[];
               (if (on > 0) or (Ax.E[] = none) then
                   this(ObjectInvocation)[] -> Ax.E[];
                   (* tricky - in R.S.Q, R.on may be > 0, but S.on = Q.on = 0
                    * and the latter must not override on from R and E = R!
                    *)
               if);
               Ax[] -> ATd.getAdr -> (loadRec,adr[])
            #);
          loadOrigin::
            (# gdb::(# do ':on:'->TT; on -> II #);
               org: ^Items; T: @text; MI: ^ModuleItem
            do (if ATD.primNo
                // 0 
                // indexed_prim 
                // string_prim
                // stringGet_prim // indexedGet_prim
                // immutable_prim then 
                   (if superAdj < 0 then 
                       (if on > 0 then 
                           - superAdj -> AdjustOrigin;
                           (on - 1,this(ObjectInvocation)[]) 
                             -> (origin[]->org[]).goOrigin
                             -> (org[],orgIsVal)
                       if)
                    else
                       superAdj -> AdjustOrigin;
                       (on,this(ObjectInvocation)[]) 
                         -> (origin[]->org[]).goOrigin
                         -> (org[],orgIsVal)
                   if);
                   (if ptnId.viaIncl[] <> none then
                      (org[],0) -> ptnId.viaIncl.goInclude
                   if)
                // this_prim then
                   (* Must check that argument is the name of an enclosing 
                    * object or the name of the superpattern of an
                    * enclosing object.
                    * For %this foo, ON = %this.origin, A.super.ON = foo.origin
                    *)

                   superAdj -> AdjustOrigin;
                   args.scanArgs(* only one argument in %this foo *)
                   (# A: ^ObjectGenerator
                   do current[] -> A[];
                      cd.com
                      (#do 'this_prim:'->TT; A.dopt -> TT;
                         ':super.on:'-> TT; A.super.ON -> II #);
                      (A.super.on - 1,this(ObjectInvocation)[])
                        -> (origin[]->org[]).goOrigin
                        -> (org[],orgIsVal)
                   #)
                // thisCore_prim then 
                   (* perhaps not in loadOrigin, but in execute/ATd.invoke *)
                   ('thisCore',thisCore_prim) -> cd.callPrim
                // thisCoreId_prim then
                   ('thisCoreId',thisCoreId_prim) -> cd.callPrim
               if);
               (* Actually rec = origin*n, E = this(OG) *)
               this(ObjectInvocation)[] -> E[] -> rec[]
            #);
          load::
            (#
            do cd.com(#do 'OI:load:'-> TT; dopt -> TT #);
               (rec[],A[]) -> ATd.load
            #);
          invoke::
            (# gdb::
                 (#do ' rec:'->TT; 
                    (if rec[]=none then 'none'->TQ else rec.dopt -> TQ if)
                 #);
               ptn: ^pattern
            do (* rec is a dataItem and there will thus be exactly 
                * one variant for its OG *)
               (if atd## 
                // pattern## then
                   atd[] -> ptn[];
                   cd.com(#do '>top:'->TT; ptn.OG.Qvariants.top -> II;
                            'descNo:'->TT; ptn.OG.IS.newdescno -> II #);
                // module## then
                   '>module' -> cd.comment
                // moduleItem## then
                   '>moduleItem' -> cd.comment
               if);
               cd.com(#do '>adr:'->TT; (if adr[] <> none then adr.print->TT if)#);
               (rec[],E[],useReturnValue,staticOff,CC[],adr[]) -> ATd.invoke
            #);
          loadArgs:: 
            (# gdb:: (# do 'staticOff:' -> TT; staticOff -> II #);
            do (this(Exp)[],superAdj,staticOff,CC[]) -> ATd.loadArgs
            #);
       #);       
     BracketedExp::
       (* a := b + (c * d)
        *     execute c * d
        * (foo).x
        *    loadOrigin foo
        * (foo(e1,e2)).x
        *    execute foo(e1,e29?
        * (%this P).suspend
        *     loadOrigin?
        * (E1)
        *    (E1).pushThis
        *    (E1).loadOrigin
        *    (E1).invoke
        *    rec -> E.invoke
        * (E1).E2
        *    
        * (R.S).foo
        * (R.bar(e1,e2,)).foo  
        * (ch = 'i') && (S <> none)
        * Do we always execute exp in (exp) and (exp).foo?
        * We should thus not just call load origin!?
        * What about (exp), (R.foo)
        * Look at gen: for (exp) we call loadOrigin and then execute
        *   for (exp).foo we call loadOrigin(exp) and then exe on foo
        *   but exe(exp) is not called
        *   How do we in loadOrigin ensure that exe(exp) is called when needed?
        * 
        * E1.(E2)
        * E1.(E2).E3
        *)
       (# markForCodeGen:: (#do IV.markForCodeGen #);
          Qgen:: 
            (# 
            do (* we dont come here *)
               (useReturnValue,superAdj,staticOff) -> IV.Qgen 
            #);
          getAdr::
            (# rec,E: ^Exp
            do cd.com(#do 'BracketedExp:getAdr:'->TT;adr.print -> TT 
                     #);
               adr[] -> IV.computeAdr -> (rec[],E[],adr[]);
               cd.com(#do 'BracketedExp:getAdr:after:computeAdr:'->TT; adr.print->TT#);
               (adr.superAdj,0,none) -> E.loadArgs; (* do we need staticOff here? *)
               (* (rec[],E[],true,0,0,none,adr[]) -> E.invoke;*)
            #);
          pushThis:: 
            (* Skip, since loadOrigin below includes pushThis *)  
            (# #);
          loadOrigin:: 
            (# off: @integer; A: ^Address
            do (* OBS! useReturnValue, staticOff must be handled! *)
               superAdj -> Address -> IV.computeAdr -> (rec[],E[],A[]);
               ('BE:loadOrigin:E:',E.doPT) -> cd.com2;
            #);
          loadArgs:: 
            (* Skip, since loadOrigin includes loadArgs *)              
            (# #);
          invoke::(# #)
       #);
     Const::
       (# Qgen:: (# do invoke #);
          getAdr::
            (# 
            do this(Const)[] -> adr.E[]
            #);
          invoke:: (# do T.setpos; T.getReal -> cd.pushConst #);
          load:: (# do T.setpos; T.getReal -> cd.pushConst #);
       #);
     FloatConst::
       (# Qgen:: (# do invoke #);
          getAdr::
            (# 
            do this(FloatConst)[] -> adr.E[];(* 2 -> adr.size???*)
            #);
          invoke:: (# do T.setpos; T.getReal-> cd.pushFloatConst #);
          load:: (# do T.setpos; T.getReal -> cd.pushFloatConst #);
       #);
     CharObj::
       (# Qgen:: (* Never called? *) (# do invoke #);
          pushThis:: (##);
          getAdr::
            (# 
            do this(CharObj)[] -> adr.E[]
            #);
          invoke:: 
            (# ch: @char
            do (if T.length = 1 then
                   1 -> T.inxget -> cd.pushConst 
                else
                   (if 2 -> T.inxget -> ch
                    // 'n' then 10 -> cd.pushConst
                    // 't' then 9 -> cd.pushConst
                    else
                       'CharObj:Special symbol: ' -> puttext; ch -> putint;
                       ':' -> put; '"' -> put; ch -> put; '"' -> put;
                       newline;
                       ch -> cd.pushConst
                   if)
               if)
            #);
       #);
     getStringPlus:
       (# D: ^Decl
       do L:
            stringDecl.OG.IS.scanSons
            (# 
            do (if current.isDecl then
                   current[] -> D[];
                   (if ('+' -> D.sig.id.equal) then

                       D.markForCodeGen;
                       leave L
                   if)
               if)
            #)
       exit D[]
       #);
     StringObj::
       (# markForCodeGen:: (# do scanSons(#do current.markForCodeGen #)#);
          Qgen:: 
            (* Never called ? *)
            (# do 'String:gen:' ->puttext; doPT -> putline; invoke #);
          loadOrigin::
            (* In "hello".foo, "hello" plays the same role as R in R.foo,
             * i.e. we must generate a pushText "hello"
             * For an exp "Hello", 
             * loadOrigin then also generates a pushText "hello"
             * Invoke is called only for the last exp in R1.R2.exp 
             * and 'just store the string!
             *)
            (# 
            do cd.com(#do 'StringObj:loadOrigin:' -> TT; dopt->TT; #);
               (if not elimOrigin then T[] -> cd.pushText; 'bingo: ' -> puttext; T[] -> putline if);                
               this(StringObj)[] -> E[] -> rec[]
            #);
          getAdr:: (# do this(StringObj)[] -> adr.E[]; (*T[]->cd.pushText*) #);
          invoke:: 
            (# n: @integer ; (* no of embbedded invocations in T *)
               start,end: [4]@integer; 
               prev: @integer;
               doAdd: @boolean;
               plusDecl: ^Pattern
            do (*doPP -> putline;*)
               (if false then
                   (if elimOrigin then T[] -> cd.pushText if);
               if);
               (*cd.com(#do 'Find embedded code' -> TT #);*)
               getStringPlus -> plusDecl[];
               (*
               plusDecl.OG.getDescNo -> putint; newline;
               plusDecl.dopt -> putline; *)
               T[] -> scanForBrace
               (# pos: @integer
               do (*'*** qgen got brace: ' -> puttext; inn[] -> putline;*)
                  n + 1 -> n;
                  first -> start[n];
                  last -> end[n];
                  (*first -> putint; ' ' -> put; last -> putint; newline;
                  (1,first - 1) -> T.sub -> puttext; '#' -> put;
                  (first,last) -> T.sub -> putline;*)
               #);
               scanSons
               (# S: ^Text; n: @integer; 
               do n + 1 -> n;
                  (prev + 1,start[n] - 1) -> T.sub -> S[];
                  (*cd.com(# do 'pushText: ' -> TT; S[] -> TQ #);*)

                  S[] -> cd.pushText;
                  (if doAdd then
                      (plusDecl.sig.id[],plusDecl.OG.getDescNo,0,true) 
                        -> cd.invoke;
                  if);
                  (*cd.com(#do 'execute' -> TT;
                           (start[n],end[n]) -> T.sub -> TT #);
                   current.dopt  ->  cd.comment;*)
                  (true,0,0) -> current.Qgen;
                  (plusDecl.sig.id[],plusDecl.OG.getDescNo,0,true) -> cd.invoke;
                  end[n] -> prev;
                  true  -> doAdd
               #);
               (*cd.com
               (#do 'pushText: ' -> TT; (prev + 1,T.length) -> T.sub -> TQ #);*)
               (prev + 1,T.length) -> T.sub -> cd.pushText;
               (if doAdd then 
                   
                   (plusDecl.sig.id[],plusDecl.OG.getDescNo,0,true) 
                     -> cd.invoke;

               if);
               (if not useReturnValue then cd.rPop if)
            #);
       #);
     ObjTmpStack: @
       (# item: 
            (# OG: ^ObjectGenerator; 
               CC: ^CallChain; var: ^Variant
            enter(OG[],CC[],var[])
            exit this(item)[]
            #);
          add:
            (# OG: ^ObjectGenerator; 
               CC: ^CallChain; var: ^Variant
            enter(OG[],CC[],var[])
            do (if (top+1-> top) > OTL.range then 
                   OTL.range -> OTL.extend;
                   done.range -> done.extend
               if);
               cd.com(#
                     do 'ObjTmpStack:add:'->TT; 
                        (if var[] <> none then
                            ':genDone:'->TT; var.GenDone -> BB; ' '-> TT;
                        if);
                        (if OG.sig[] <> none then
                            OG.sig.doPT -> TT; ':' -> TT;
                        if);
                        OG.doPT -> TT;
                     #);
               (OG[],CC[],var[]) -> item -> OTL[top][];
               (* Does IS.newDescNo correspond to var? Probably no!?*)
            #);          
          next:
            (# inx: @integer; B: @boolean
            do 0 -> inx; false -> B;
               Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        cd.com(#
                              do 'objTmpStack:next: ' -> TT;
                                 ' : done:'->TT; done[inx] -> BB;
                                 ' :var.genDone: ' -> TT;
                                 (if OTL[inx].var[] <> none then
                                     OTL[inx].var.genDone -> BB
                                 if)
                              #);
                        (if not OTL[inx].var.genDone then
                            cd.com(#
                                  do 'objTmpStack:next:C: ' -> TT;
                                     OTL[inx].OG.IS.newdescno -> II; 
                                     ':top:' ->TT ;
                                     OTL[inx].OG.Qvariants.top -> II;
                                  #);
                            
                            (OTL[inx].CC[],OTL[inx].var[]) 
                              -> OTL[inx].OG.genClass;
                        if);
                        restart Loop
                    if);
                 #)
            exit B
            #); 
          OTL: [10] ^Item; top: @integer;
          done: [10] @boolean
       #);
     markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^TopNode;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if false then
                       '\nModule: ' -> puttext; md.DI.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).newDescNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   true -> md.mark;
                   (if md.origin[] <> none then
                       md.DI.NewOff -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genStubs:
       (# genMain:
            (# 
            do ObjectGenerator -> QnewDesc -> mDescNo;
               ('main',mDescNo,false,1,0,0) -> cd.class;
               cd.pushThis;
               (if false then
                   'TopModule: ' -> puttext;
                   markIncludes.topModule.DI.sig.doPT -> putLine;
                   'Main: ' -> puttext; main.doPt -> putline
               if);
               ('BETAworld',(markIncludes.topModule.desc).newDescno,0,true) 
                 -> cd.invoke;
               cd.stop; (* We should generate stop here and not in betaVM *)
               (* The objSize of main is set to 2 but perhaps not needed?
                * Was needed by qenv before an empty ObjectGenerator was 
                * generated for main *)
               (2,false,0) -> CD.endClass;
               
               (if markIncludes.main## <> Module## then
                   '\n\n***** Only Modules can be executed *****\n\n'
                     -> putline
               if)
            #);
          genThreadStub:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('ThreadStub',descNo,false,descNo,0,0) -> cd.class;
               (false,false) -> cd.actions;
               ('ThreadStub','D') -> cd.call;
               cd.stop;
               (1,false,0) -> CD.endClass;               
            #);
          genEventProcessor:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('EventProcessor',descNo,false,1,0,0) -> cd.class;
               cd.stop; (* we should generate stop here and not in betaVM *)
               (1,false,0) -> CD.endClass;               
            #);                   
       do genMain;
          genEventProcessor;     
          genThreadStub;
       #);
     mDescNo: @integer;
     mainDescNo:: 
       (# 
       do mDescNo -> value (* ad hoc *);
       #);
     (* cd: @ObjectCode; moved to abstractSyntaxTree for debugging purposes *)
     runTimeDescs:: (# do descs[] -> rtDescs[] #);
     descs: ^RunTimeDescriptors;
     BC: @File;
  do '**** GENERATOR ****' -> putline;     
     (FN[],'..s') -> mkAuxName -> BC.name;
     BC.openWrite;
     BC[] -> cd.init;
     'QBETA'-> cd.comment;
     
     labelHandler.init;
     0-> ObjTmpStack.top;
     main[] -> markIncludes;
     

     (*  Module::Qgen puts OG on ObjTmpStack *)
     (* rootModule = BETAworld must have descNo = 1 - no longer the case *)
     (# ptn: ^Pattern
     do rootModule.markForCodeGen;
        (* Pattern Object is special and not reached during a by-need scan
         * but must be allocated
         *)
        (objectDecl[] -> ptn[]).OG.computeVariant;
     #);
     
     L:
       (# B: @ boolean
       do false -> B;
          ObjTmpStack.next or B -> B;
          (* Eliminate boolean and fix test for objTmpStack.isEmpty *)
          (if B then
              restart L 
          if)
       #);
     genStubs;
     
     (if stringDecl[] <> none then
         (if (stringDecl.desc).newDescNo = 0 then
             rootModule[] -> SemanticError(#do 'StringDecl.descNo = 0!' -> msg #)
          else
             (stringDecl.desc).newDescNo -> CD.descs.textDescNo
         if)
      else
         rootModule[] -> SemanticError(#do 'StringDecl not found!' -> msg #)
     if);
     (*  (if StructureRefDesc[] <> none then
      *          StructureRefDesc.newDescNo -> CD.descs.structureRefDescNo
      *       else
      *          rootModule[] 
      *            -> SemanticError(#do 'StructureRefDesc not found!' -> msg #)
      *    if);
      *)
     
     cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)
     true -> descs.newAlloc;
     cd.close;
     BC.close
  #)

