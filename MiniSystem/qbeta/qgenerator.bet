ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qsemchecker';
INCLUDE '../miniCompiler/objectcode'
---lib:attributes---
generator: semchecker
  (# traceModules: (# exit false #);
     MkCom: 
       (# t1,t2: ^text enter (t1[],t2[]) do t2[] -> T1.append -> cd.comment #);
     
     Module::
       (# gen::
            (#
            do ('Comp',newDesc.noOfDescs) -> cd.newComponent;
               SO.gen;
            #);
          findNextImp:: (# do bcp -> SO.OG.IS.findNextImp -> impx[] #);
       #);
     ModuleItem::
       (# gen::
            (#
            do (if MD.isIncluded then
                   ('ModuleItem:gen',sig.dopt) -> cd.com2;
                   (useReturnValue,superAdj,staticOff) -> MD.SO.gen
                else
                   (if traceModules then
                       'Module not included: ' -> puttext; sig.doPT -> putline
               if)if)
            #);
          pushThis:: (# do cd.pushThis #);
          invoke:: (# do MD.SO.invoke #);
          store:: (# do '\nModuleItem:store'->putline #);
          popReturn:: (# do '\nModuleItem:popReturn'->putline #);
          findNextImp:: (# do bcp -> md.findNextImp -> impx[] #);          
       #);
     DataItem::
       (* Cases
        *    C1: = integer(12)
        *    C2: = integer
        *    C3: = Fool
        *    C4: = Fool -- singular
        *       ...
        *    V1: ? integer(12)
        *    V2: ? integer
        *    V3: ? Fool
        *    V4: ? Fool -- singular
        *       ...
        *)
       (# gen::
            (# gdb:: (# do sig.doPT -> lx.puttext #);
            do (if true 
                // OG.isSimpleValue then
                   (* C1,C2,V1,V2 *)
                   (if true 
                    // 'Function' -> ((OG.super.last).label).equal
                    // 'Binary' -> ((OG.super.last).label).equal
                    // 'Const:' -> ((OG.super.last).label).equal
                    // 'String:' -> ((OG.super.last).label).equal
                       then
                       (* pretty ad hoc - to handle 
                        * X: = integer(7)
                        * X: ? 7
                        * X: = a + b
                        * and avoid calling OG.gen for 
                        * X: = integer
                        * Cf the discussion of #foo versus foo 
                        *)
                       (true,0,this(DataItem).off) -> OG.gen;
                       cd.pushThis;
                       (sig.id[],this(DataItem).off) -> cd.storeg
                   if);
                // (OG.primNo = String_prim) and isConst then
                   (true,0,this(DataItem).off) -> OG.gen;
                   cd.pushThis;
                   (sig.id[],this(DataItem).off) -> cd.rstoreg
                else
                   (* C3,C4,V3,V4 *)
                   (if isConst or not OG.IS.isEmpty then
                       (* C3,C4,V4 *)
                       (if origin[] <> none then 
                           cd.bcPos -> beginBCP;
                           (false,0,this(DataItem).off) -> OG.gen;
                           cd.bcPos -> endBCP;
                        else 
                           (* A module object - why special handling? 
                            * Apparenly cd.bcPos is not defined here!?
                            *)
                           (if not OG.IS.isEmpty then
                               (sig.id[],none,OG[],OG.super[]) -> ObjTmpStack.add
                           if)   
                       if) 
                       (* else V3 - just a qualifcation 
                        * -cf the discussion of #foo versus foo *)
                   if)
               if)
            #);
          pushThis:: (# gdb:: (#do sig.id[] -> lx.puttext #)do cd.pushThis #);
          invoke::
            (* called when not receiver - i.e. value to be pushed *)
            (# gdb:: (#do sig.id[] -> lx.puttext #)
            do (if OG.isSimpleValue then 
                   (if (E[] <> none) then
                       (if (E.ATd.primNo <> cmpAndSwap_prim) then
                           (* May happen for V := 117 where := is assignment 
                            * - no offset shall be pushed for V 
                            * since V is assigned afterwards
                            * For R ++ 117 offset for R should be pushed 
                            * since it is origin
                            *) 
                           (sig.id[],off) -> cd.pushg
                        else
                           off -> cd.pushConst
                       if)
                    else
                       (sig.id[],off) -> cd.pushg                           
                   if)
                else
                   (sig.id[],off) -> cd.rpushg
               if)
            #);
          store::
            (* Called from Signature::StoreParameters *)
            (# 
            do (if OG.isSimpleValue then 
                   (sig.id[],off) -> cd.storeg
                else
                   (if not noSwap then cd.rswap if); 
                   (sig.id[],off) -> cd.rstoreg
               if)
            #);
          popReturn::
            (#
            do (if OG.isSimpleValue then 
                   cd.vpop
                else
                   cd.rpop
               if)
            #)          
       #);
     Signature::
       (# 
          storeParameters:
            (#
            do (*cd.setThisStack;*)
               (* 'storeParameters: ' -> puttext;*)
               scanParametersReverse
               (# D: ^Decl
               do (*currentPar.dopt -> puttext; ' ' -> put;*)
                  (if not (currentPar[] -> D[]).isVirtual then
                      cd.pushThis;
                      true -> currentPar.store
                  if)
               #)
            #);
          pushReturnValues:
            (#
            do (if val[] <> none then
                   cd.setThisStack;
                   val.scanSons
                   (# D: ^Decl
                   do current[] -> D[];
                      cd.pushThis;
                      D.invoke
                   #)
                else
                   cd.setThisStack;
                   cd.pushThis;
               if)
            #);
          popReturn:
            (# 
            do (if val[] <> none then
                   val.scanSons
                   (# D: ^Decl
                   do (current[] -> D[]).popReturn
                   #)
                else
                   cd.rpop
               if)
            #)
       #);
     ObjectGenerator::
       (# gen::
            (# gdb:: 
                 (#
                 do 'super: ' -> lx.puttext; super.doPT -> lx.puttext;
                    (if IS.isEmpty then 
                        ':IS-empty: ' -> lx.puttext 
                     else
                        ':singular:' -> lx.puttext
                    if);
                    'staticOff: '-> lx.puttext; staticOff -> lx.putint
                 #);
               name: ^text
            do cd.bcPos -> beginBCP;
               (if IS.isEmpty 
                   and not super.hasVirtualArgs 
                   or (super.isBasic and IS.isEmpty) then
                   (* check this - called when R.foo *)
                   (useReturnValue,superAdj,staticOff) -> super.gen
                else
                   (* This also includes pattern invocations with 
                    * virtual arguments * like %if .. %then% ... %else ...
                    *)
                   (* called when R.foo{ } *)
                   cd.pushThis; (* origin for a singular object *)
                   (if singularName[] <> none then
                       singularName[] -> name[]
                    else
                       (if super.ATd[] = none then 
                           '' -> name[]
                        else
                           Super.ATd.sig.id.copy -> name[]
                       if);
                       '#S#' -> name.append;
                       IS.descNo -> name.putint;
                   if);
                   (* missing load args ?
                    * See genclass which may load the argumenst
                    *)
                   (name[],IS.descno,staticOff,true) -> cd.invoke;

                   (if not useReturnValue  then cd.rpop if);
                   
                   (name[],none,this(ObjectGenerator)[],super[]) -> ObjTmpStack.add
               if);
               cd.bcPos -> endBCP;
            #);
          genClass::
            (#
            do (N[],sig[],IS.descNo,super[]) -> IS.genClass
            #)
       #);
     PatternId::
       (# gen::
            (# gdb:: (# do doPT -> lx.puttext #);
            do (useReturnValue,superAdj,staticOff) -> IV.gen
            #)
       #);
     items::
       (# genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; super: ^Invocation;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
               nd: ^Node
            enter(N[],sig[],descNo,Super[])
            do (*'GenClass: ' -> puttext; doPT -> putline;*)
               (if (superDesc[] <> none) then
                   superDesc.father.father -> nd[];
                   nd[] -> ptn[];
                   (if not superDesc.done then
                       (# 
                       do (ptn.sig.id[],ptn.sig[],superdesc.descNo,ptn.OD.super[]) 
                            -> superDesc.genClass
                       #)
               if)if);
               (if not done then
                   true -> done;
                   (N[],descNo,false, (topSuper).descNo,originOff) -> cd.class;
                   (* thisObj = the new instance of this class 
                    * thisStack = caller
                    * Possible arguments on callerStack
                    *)
                   cd.bcPos -> beginBCP;
                   (* store parameters + origin *)
                   (if sig[] <> none then sig.storeParameters if);
                   ('origin',originOff) -> cd.rstore;
                   not doHasCode -> cd.allocEventQ;
                   
                   (if (superDesc[] <> none) and not superDesc.isBasic
                       or (superDesc[] <> none) and (superDesc.primNo = stringDecl.primNo) then
                       (ptn.sig.id[],superDesc.descNo)  -> cd.super; 
                       superDesc.descNo -> cd.vdtTableCopy;
                       (if superDesc.innerInx > 0 then
                           (superDesc.innerInx,descno) -> cd.vdtTable;
                           true -> hasSuperAndInner
                       if);
                       (* push super arguments *)
                       
                       (if superApl.isImplSuper then
                           (if superApl.isSingularImplSuper then
                               cd.pushThis;
                               ('iOrigin',originOff) -> cd.rpushg
                            else
                               superApl.ATd[] -> ptn[];
                               origin[] -> vSuperDesc[]; (* find desc enclosing vDcl *)
                               (for i: superApl.pn repeat
                                    vSuperDesc.superDesc[] -> vSuperDesc[]
                               for);
                               cd.pushThis;
                               ('origin',originOff) -> cd.rpushg; 
                               ptn.OD.super.on -> vSuperDesc.goOrigin
                           if)                                   
                        else
                           (# E,rec: ^Exp
                           do 
                              (true,0,originOff) -> Super.loadOrigin -> (rec[],E[]);
                              originOff -> E.loadArgs;
                           #);
                       if);
                       superDesc.descNo -> cd.toSuper;
                       cd.markEnterE;  
                   if); 
                   (if descNo = 1 then
                       cd.pushThis;
                       cd.saveBETAworld
                   if);
                   (if (superDesc[] <> none) and not superDesc.isBasic  then
                    else cd.mvStack
                   if);
                   scanSons
                   (# I: ^Item
                   do current[] -> I[];
                      (if I.isDecl then (false,0,0) -> current.gen if) 
                   #);
                   (if innerInx > 0 then innerInx -> cd.innerA if);
                   (if (superDesc[] <> none) and not superDesc.isBasic  then
                       cd.rtnInner 
                    else
                       (if doHasCode then 
                           1 -> cd.rtnEventQ 
                        else
                           0 -> cd.rtnEventQ 
                       if)
                   if);
                   
                   (* Code for action part *)
                   (false,doHasCode) -> cd.actions;
                   restartLab.new;
                   leaveLab.new;
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item; 
                   do current[] -> I[];
                      (if not I.isDecl then (false,0,0) -> current.gen if) 
                   #);
                   leaveLab -> cd.defLab;
                   (* we must push return values *)
                   (* push return value 
                    * - for DataItem: R: @Foo
                    *   Foo should return (this(Foo)
                    *   perhaps default?
                    * - otherwise push variables in -> 
                    *)
                   (if (superDesc[] <> none) and not superDesc.isBasic then
                    else
                       0 -> cd.rtnEventQ;
                       (if sig[] <> none then 
                           sig.pushReturnValues 
                        else
                           (* ad hoc *)
                           cd.setThisStack;
                           cd.pushThis
                   if)if);

                   (if (superDesc[] <> none) and not superDesc.isBasic then
                       cd.rtnInner
                    else
                       (*0 -> cd.rtnEventQ;*)
                       'D' -> cd.rtn;
                   if);
                   (vsize,rsize,1) -> CD.endClass;
                   cd.bcPos -> endBCP
               if)
            #);
          goOrigin:
            (# on: @integer; org: ^Items
            enter on
            do (if on > 0 then
                   (if basicNo = ifthen_prim then
                       on  -> (origin[]->org[]).goOrigin -> org[]
                    else
                       ('origin',originOff) -> cd.rpushg;
                       on - 1 -> (origin[]->org[]).goOrigin -> org[]
                   if)
                else
                   this(Items)[] -> org[]
               if)
            exit org[]
            #); 
          hasSuperAndInner: @Boolean;
          restartLab,leaveLab: @LabelHandler.label;

          findNextImp::
            (#
            do L:
                 scanSons
                 (#
                 do (if (bcp -> current.findNextImp -> impx[]) <> none then
                        leave L
                 if)#);
            #)            
       #);
     Pattern::
       (#  gen:: 
            (# gdb:: (# do sig.dopt -> lx.puttext #)
            do (if OD.primNo
                // 0 // string_prim // indexed_prim then
                   (if OD.IS.isExternal > 0 then
                       'Pattern:gen: ' -> puttext; OD.primNo -> putint; ' ' -> put;
                       doPT->putline;
                       leave gen 
                   if);
                   (if ptnKind 
                    // plainPtn then
                       (sig.id[],sig[],OD[],OD.super[]) -> objTmpStack.add 
                    // virtualPtn then
                       (if OD.IS.isEmpty then
                           (off,(OD.super.desc).descNo) -> cd.vdtTable
                        else
                           (sig.id[],sig[],OD[],OD.super[]) -> objTmpStack.add;
                           (off,OD.IS.descNo) -> cd.vdtTable
                       if)                            
                    // furtherPtn // finalPtn then
                       (sig.id[],sig[],OD[],OD.super[]) -> objTmpStack.add;
                       (off,OD.IS.descNo) -> cd.vdtTable
                   if)
                // resume_prim then
                   ('Resume','D') -> cd.call;                   
               if)
            #);
          pushThis:: 
            (# gdb:: (# do sig.dopt -> lx.puttext #); T: @text
            do (if OD.primNo
                // 0 
                // this_prim 
                // indexedGet_prim (* not tested*)
                // indexedGet_prim (* ditto *)
                // stringGet_prim 
                // indexed_prim then
                   cd.pushThis 
                else (* ugly *)
                   (if ptnKind // virtualPtn // furtherPtn // FinalPtn then
                       cd.pushThis 
                   if)
               if)
            #);
          loadArgs::
            (# gdb:: (# do sig.doPT -> lx.puttext; E.doPT -> lx.puttext #);
               args: [6]^ObjectGenerator; top: @integer;
            do (if OD.primNo = 0 then
                   E.args.scanArgs
                   (#
                   do (if (top+1 -> top) > args.range then 
                          args.range -> args.extend 
                      if);
                      current[] -> args[top][];
                   #);
                   (if sig.args[] <> none then 
                       sig.args.scanArgs
                       (# D: ^Decl; i: @integer; 
                          OG: ^ObjectGenerator; name: ^text; descNo: @integer
                       do i + 1 -> i; 
                          current[] -> D[]; 
                          (if D.isVirtual then
                              D.sig.id.copy -> name[];
                              '#SB#' -> name.append;
                              (args[i].desc).descno -> descNo -> name.putint;
                              (name[],none,args[i][],args[i].super[]) 
                                -> ObjTmpStack.add;
                              E.father.father[] -> OG[]; (* need OG.descNo for VDT *)
                              (D.off,descno,(OG.desc).descNo) -> cd.vdtTableAt
                           else
                              (true,superAdj,0) -> args[i].gen
               if)#)if)if)
            #);
          invoke::
            (# gdb:: (# do sig.doPT -> lx.puttext #);
               org: ^Items; exitLab: @labelHandler.label;
               args: [6]^ObjectGenerator; top: @integer;
               hasVirtualArgs: @boolean;
               doBreak:
                 (# OD: ^Items; 
                    primNo,ON: @integer
                 enter primNo
                 do E.args.scanSons
                    (# isArg: @boolean; Ex : ^ObjectGenerator; 
                    do (if isArg then
                           current[] -> Ex[];
                           Ex.super.on -> ON;
                       if);
                       noT isarg -> isarg
                    #);
                    E.origin[] -> OD[];
                    (for i: ON - 1 repeat 
                         (if OD.basicNo = ifthen_prim then OD.origin[] -> OD[] if);
                         OD.origin[] -> OD[] 
                    for);
                    (if OD.basicNo = ifthen_prim then OD.origin[] -> OD[] if);

                    (if primNo
                     // restart_prim then 
                        (if ON = 1 then
                            OD.restartLab -> cd.jmp
                         else
                            (ON - 1, OD.restartLab) -> cd.break
                        if)
                     // leave_prim then 
                        (if ON = 1 then
                            OD.leaveLab -> cd.jmp
                         else
                            (ON - 1, OD.leaveLab) -> cd.break
                        if)
                    if)
                 #);   
               exNo: @integer
            do (if OD.primNo
                // assign_prim then
                   rec.ATd.store;                   
                // ifthen_prim then
                   exitLab.new;                   
                   E.args.scanSons
                   (# N: @integer
                   do N + 1 -> N;
                      (if N
                       // 1 // 3 then
                       // 2 then 
                          (true,0,staticOff) -> current.gen;
                          exitlab -> cd.jmpFalse;
                       // 4 then
                          current.gen;
                          exitLab -> cd.defLab;
                       else
                          'invoke:%if%then: too many arguments' -> putline;
                          E.doPt -> putline
                      if)
                   #); 
                // restart_Prim then 
                   restart_Prim -> doBreak
                // leave_Prim then 
                   leave_Prim -> doBreak                   
                // inner_prim then
                   (if E.args.length > 0 then
                       E.args.scanArgs
                       (# A: ^ObjectGenerator; org: ^Items
                       do current[] -> A[]; 
                          cd.pushThis;
                          A.super.on - 1 -> (E.origin[]->org[]).goOrigin -> org[]; 
                          org.innerInx -> cd.innerP; 
                          cd.rpopThisObj
                       #)
                    else
                       E.origin[] -> org[];
                       org.innerInx -> cd.innerx; 
                   if)
                // indexedPut_prim then
                   (* scan args and push index and element *)
                   E.args.scanSons(#do (true,0,staticOff) -> current.gen #);
                   ('inx',1) -> cd.xstoreg
                // indexedGet_prim // stringGet_prim then
                   E.args.scanSons(#do (true,0,staticOff) -> current.gen #);
                   ('inx',1) -> cd.xpushg
                // none_prim then 
                   cd.pushNone
                // suspend_prim then
                   cd.suspendd
                // resume_prim then
                   ('Resume','D') -> cd.call;
                   cd.rpop
                // disable_prim then
                   ('disable',disable_prim) -> cd.callPrim
                // enable_prim then  
                   ('enable',enable_prim) -> cd.callPrim   
                // put_prim then 
                   ('put',OD.primNo) -> cd.Callprim
                // attach_prim then
                   ('attach',OD.primNo) -> cd.callPrim;
                   cd.rPop;
                // cmpAndSwap_prim then
                   (# I: ^Invocation
                   do E.father -> I[];
                      L:
                        I.scanSons
                        (# R: ^Exp
                        do current[] -> R[];
                           cd.swap;
                           ('cmpAndSwap',OD.primNo ) -> cd.callPrim;
                           leave L
                        #)
                   #)
                // fork_prim then
                   ('fork',OD.primNo ) -> cd.callPrim
                // sleep_prim then
                   ('sleep',OD.primNo ) -> cd.callPrim;
                // indexed_prim then
                   (*100 -> cd.pushConst; -- range - pushed as argument *)
                   0 -> cd.pushConst;   (* isRindexed *)
                   OD.IS.rsize -> cd.pushConst; (* dinx *)
                   ('StaticRep',OD.IS.descNo,false (*OD.isRindexed*),true) 
                     -> cd.allocIndexed;
                   cd.pushThis;
                   ('indexed',staticOff) -> cd.rstoreg              
                // asString_prim then
                   ('asString',primNo) -> cd.callPrim
                // thisCore_prim then
                else
                   (if (sig.type ## = Sig.Unary##) and (OD.primNo = 65) then
                       'Unary: ' -> puttext; OD.primNo -> putint;
                       ' ' -> put; sig.doPT -> putline;
                   if);
                   (if (sig.type ## = Sig.Binary##) and (OD.primNo > 0) 
                       or 
                       (sig.type ## = Sig.Unary##) and (OD.primNo = 65) then
                       OD.primNo -> cd.op
                    else     
                       (if (OD.IS.isExternal -> exNo) > 0 then
                           'External: ' -> putline; doPT -> putline;
                           (sig.id[],exNo) -> cd.invokeExternal
                        else
                           (if ptnKind // virtualPtn // furtherPtn // finalPtn then
                               (sig.id[],off) -> cd.sendVirtual
                            else
                               (if not isBasicPtn then
                                   (sig.id[],OD.IS.descno,staticOff,not OD.IS.doHasCode) 
                                     -> cd.invoke;
                               if)
                       if)if);
                       (if not useReturnValue then sig.popReturn if)
               if)if)
            #);     
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);   
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.on -> gorigin
        *    E1.pushOff
        *    E2.pushOff
        *    E3.invoke
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# gen:: 
            (# gdb:: (# do doPT -> lx.puttext #);
               rec,E: ^Exp; T: ^Text
            do cd.bcPos -> beginBCP;
               (useReturnValue,staticOff,superAdj) -> loadOrigin -> (rec[],E[]);
               superAdj -> E.loadArgs;
               (rec[],E[],useReturnValue,staticOff) -> E.invoke;
               cd.bcPos -> endBCP
            #);
          loadOrigin:
            (# usereturnValue: @boolean;
               staticOff,superAdj: @integer;
               rec,E,nE: ^Exp;
            enter(useReturnValue,staticOff,superAdj)
            do ('Invocation:loadOrigin:',doPT) -> cd.com2;
               (* could rec be thisObject for first E1 in E1.E2.E3 ?*)
               (* Perhaps the other way around
                * e1 -> rec
                * rec -> e2.invoke
                * e2 -> rec
                * rec -> e3.invoke
                *)
               scanSons
               (# gdb:
                    (# T: ^text
                    do 'Invocation:loadOrigin:scan: ' -> T[];
                       current.doPT -> T.puttext;
                       T[] -> cd.comment;
                    #);
                  T: ^ Text
               do current[] -> E[]; 
                  gdb;
                  (if isFirst then 
                      E.pushThis;
                      superAdj -> E.loadOrigin -> (rec[],E[])
                  if); 
                  (*superAdj -> E.loadArgs;*)
                  (if not isLast then
                      E[] -> rec[];
                      (if (next -> nE[]).ATd.primNo <> assign_prim then
                          'next not assign: ' -> T[]; (next).doP -> T.puttext;
                          ' :E: ' -> T.puttext; E.doPT -> T.puttext; 
                          T[] -> cd.comment;
                          superAdj -> E.loadArgs;
                          (rec[],nE[],true,staticOff) -> E.invoke
                      if)
                  if)
               #);
               (* S.simple_bar.c1 := 'x'
                *     rec = c1, E = ':='
                *     No pushOff for c1 = rec, since E = ':='
                *     no loadAsReceiver for c1 = rec
                * S.simple_bar.c1 + 1
                *     rec = c1, E = ':='
                *     pushOff for c1 = rec, but empty action
                *     loadAssReceiver for c1, since simple
                * S.simple_bar.simple_fisk
                *     rec = simple_bar, E = simple_fisk
                *     pushOff for simple_bar = rec
                *     loadAsReceiver for simple_bar, but empty action
                *)
            exit(rec[],E[])
            #);
       #);
     adjustOrigin:
       (# originOff: @integer
       enter originOff
       do ('AdjustOrigin:',originOff->int2text) -> cd.com2;
          (if originOff > 0 then
              ('origin',originOff) -> cd.rpushg
          if)
       #);
     ObjectInvocation::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# pushThis:: 
            (# do cd.bcPos -> beginBCP; ATd.pushThis #);;
          loadOrigin::
            (# gdb:: (# do doPT -> lx.puttext #);
               org: ^Items
            do (if ATD.primNo
                // 0 
                // indexed_prim 
                // string_prim
                // stringGet_prim // indexedGet_prim then 
                   superAdj -> AdjustOrigin;
                   on -> (origin[]->org[]).goOrigin; 
                // this_prim then
                   (* Must check that argument is the name of an enclosing 
                    * object or the name of the superpattern of an
                    * enclosing object.
                    * For %this foo, ON = %this.origin, A.super.ON = foo.origin
                    *)
                   superAdj -> AdjustOrigin;
                   args.scanArgs(* only one argument in %this foo *)
                   (# A: ^ObjectGenerator
                   do current[] -> A[];
                      A.super.on - 1 -> (origin[]->org[]).goOrigin; 
                   #)
                // thisCore_prim then 
                   (* perhaps not in loadOrigin, but in execute/ATd.invoke *)
                   ('thisCore',thisCore_prim) -> cd.callPrim
               if);
               this(ObjectInvocation)[] -> E[] -> rec[]
            #);
          invoke::
            (#
            do (rec[],E[],useReturnValue,staticOff) -> ATd.invoke
            #);
          loadArgs:: 
            (#
            do (if (type ## = KeyWord##) then
                   (this(Exp)[],superAdj) -> ATd.loadArgs
                else
                   args.scanSons(# do (true,superAdj,0) -> current.gen #) 
               if)
            #);
       #);       
     BracketedExp::
       (* a := b + (c * d)
        *     execute c * d
        * (foo).x
        *    loadOrigin foo
        * (foo(e1,e2)).x
        *    execute foo(e1,e29?
        * (%this P).suspend
        *     loadOrigin?
        * (E1)
        *    (E1).pushThis
        *    (E1).loadOrigin
        *    (E1).invoke
        *    rec -> E.invoke
        * (E1).E2
        *    
        * (R.S).foo
        * (R.bar(e1,e2,)).foo  
        * (ch = 'i') && (S <> none)
        * Do we always execute exp in (exp) and (exp).foo?
        * We should thus not just call load origin!?
        * What about (exp), (R.foo)
        * Look at gen: for (exp) we call loadOrigin and then execute
        *   for (exp).foo we call loadOrigin(exp) and then exe on foo
        *   but exe(exp) is not called
        *   How do we in loadOrigin ensure that exe(exp) is called when needed?
        * 
        * E1.(E2)
        * E1.(E2).E3
        *)
       (# gen:: 
            (# gdb:: (# do doPT -> lx.puttext #);
            do (* we dont come here *)
               (useReturnValue,superAdj,staticOff) -> IV.gen 
            #);
          pushThis:: 
            (* Skip, since loadOrigin below includes pushThis *)  
            (# #);
          loadOrigin:: 
            (# gdb:: (# do doPT -> lx.puttext #)
            do (* OBS! useReturnValue, staticOff must be handled! *)
               (false,0,superAdj)  -> IV.loadOrigin -> (rec[],E[]);
               ('BE:loadOrigin:E:',E.doPT) -> cd.com2;
            #);
          loadArgs:: 
            (* Skip, since loadOrigin includes loadArgs *)              
            (# #);
       #);
     Const::
       (# gen:: (# do invoke #);
          invoke:: (# do T.setpos; T.getInt -> cd.pushConst #);
       #);
     CharObj::
       (# gen:: (* Never called? *) (# do invoke #);
          invoke:: 
            (# ch: @char
            do (if T.length = 1 then
                   1 -> T.inxget -> cd.pushConst 
                else
                   (if 2 -> T.inxget -> ch
                    // 'n' then 10 -> cd.pushConst
                    else
                       'CharObj:Special symbol: ' -> puttext; ch -> putint;
                       ':' -> put; '"' -> put; ch -> put; '"' -> put;
                       newline;
                       ch -> cd.pushConst
                   if)
               if)
            #);
       #);
     StringObj::
       (# gen:: 
            (* Never called ? *)
            (# do 'String:gen:' ->puttext; doPT -> putline; invoke #);
          loadOrigin::
            (* In "hello".foo, "hello" plays the same role as R in R.foo,
             * i.e. we must generate a pushText "hello"
             * For an exp "Hello", 
             * loadOrigin then also generates a pushText "hello"
             * Invoke is called only for the last exp in R1.R2.exp 
             * and 'just store the string!
             *)
            (# 
            do (*'StringObj:loadOrigin:' -> puttext; dopt->putline; *)
               T[] -> cd.pushText ; 
               this(StringObj)[] -> E[] -> rec[];
            #);
          invoke:: (# #);
       #);
     ObjTmpStack: @
       (# item: 
            (# N: ^text; sig: ^Signature; OT: ^ObjectGenerator; super: ^Invocation
            enter(N[],sig[],OT[],super[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; sig: ^Signature; OT: ^ObjectGenerator; super: ^Invocation
            enter(N[],sig[],OT[],super[])
            do (if (top+1-> top) > OTL.range then OTL.range -> OTL.extend if);
               (N[],sig[],OT[],super[]) -> item -> OTL[top][]
            #);          
          next:
            (# inx: @integer
            do Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        (OTL[inx].N[],OTL[inx].sig[],OTL[inx].super[]) -> OTL[inx].OT.genClass;
                        restart Loop
                    if);
                 #)
            #); 
          OTL: [10] ^Item; top: @integer;
       #);
     labelHandler: @
       (# labCount: @integer;
          label:
            (# labNo: @integer;
               new: (# do  labCount + 1 -> labCount -> labNo #);
            enter labNo
            exit labNo
            #);
          init: (# do 0 -> labCount #);
       #);
     markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^TopNode;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if false then
                       '\nModule: ' -> puttext; md.SO.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).descNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   md.mark;
                   (if md.origin[] <> none then
                       md.SO.off -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genStubs:
       (# genMain:
            (# descno: @integer
            do ('main',newDesc,false,1,0) -> cd.class;
               cd.pushThis;
               (if false then
                   'TopModule: ' -> puttext;
                   markIncludes.topModule.SO.sig.doPT -> putLine;
                   'Main: ' -> puttext; main.doPt -> putline
               if);
               ('BETAworld',(markIncludes.topModule.desc).descno,0,true) 
                 -> cd.invoke;
               cd.stop; (* We should generate stop here and not in betaVM *)
               (0,0,0) -> CD.endClass;
               
               (if markIncludes.main## <> Module## then
                   '\n\n***** Only Modules can be executed *****\n\n'
                     -> putline
               if)
            #);
          genThreadStub:
            (# descNo: @integer;
            do newDesc -> descNo;
               ('ThreadStub',descNo,false,descNo,0) -> cd.class;
               (false,false) -> cd.actions;
               ('ThreadStub','D') -> cd.call;
               cd.stop
            #);
          genEventProcessor:
            (#
            do ('EventProcessor',newDesc,false,1,0) -> cd.class;
               cd.stop (* we should generate stop here and not in betaVM *)
            #);                   
       do genMain;
          genEventProcessor;     
          genThreadStub;
       #);

     mainDescNo:: (# do newDesc.noOfDescs - 2 -> value (* ad hoc *) #);
     (* cd: @ObjectCode; moved to abstractSyntaxTree for debugging purposes *)
     runTimeDescs:: (# do descs[] -> rtDescs[] #);
     descs: ^RunTimeDescriptors;
     BC: @File;
  do '**** GENERATOR ****' -> putline;     
     (FN[],'..s') -> mkAuxName -> BC.name;
     BC.openWrite;
     BC[] -> cd.init;
     'QBETA'-> cd.comment;
         
     labelHandler.init;
     0-> ObjTmpStack.top;
     main[] -> markIncludes;

     rootModule.gen;

     ObjTmpStack.next;
         
     genStubs;
     
     (if stringDecl[] <> none then
         (*'String descNo: ' -> puttext; (stringDecl.desc).descNo -> putint; 
          * ' primNo: ' -> puttext; stringDecl.primNo -> putint; newline;
          *)
         (stringDecl.desc).descNo -> CD.descs.textDescNo
      else
         rootModule[] -> SemanticError(#do 'StringDecl not found!' -> msg #)
     if);
     (*  (if StructureRefDesc[] <> none then
      *          StructureRefDesc.descNo -> CD.descs.structureRefDescNo
      *       else
      *          rootModule[] 
      *            -> SemanticError(#do 'StructureRefDesc not found!' -> msg #)
      *    if);
      *)
     
     cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)    
         
     cd.close;
     BC.close
  #)

