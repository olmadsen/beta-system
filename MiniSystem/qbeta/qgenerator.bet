ORIGIN '~beta/basiclib/betaenv'; 
INCLUDE 'qcodegenmarker';
INCLUDE '../VM/objectcode'; 
BODY 'qgeneratorBody';
---lib:attributes---
generator: codeGenMarker
  (# noOGwarn: @boolean;
     Module::
       (# codeGenDone: @Boolean;
          gen:: 
            (# 
            do (if false  then
                   '**** Module:gen: ' -> puttext;  sig.dopt -> puttext;
                   ' newOff: '  ->  puttext; 
                   this(Module).newOff -> putint;
                   newline;
               if);
               (if not codeGenDone then
                   cd.bcPos -> beginBCP;     
                   (if nameListInDcl then
                       (false,0,(this(Module).sig.names.firstDecl).NewOff)
                         -> OG.gen;
                    else
                       (false,0,this(Module).NewOff) -> OG.gen;
                   if);
                   cd.bcPos -> endBCP;
                   true -> codeGenDone
               if)
            #);  
          actionPos::
            (#
            do '**** Module:actionPos: '->puttext; 
               OG.IS.beginPos->putint;
               newline
            #);
          genMI:
            (# useRtnVal: @boolean; superAdj,staticOff: @integer;
               mainPathModule: ^Module;
               isLocalMI: @boolean
            enter(useRtnVal,superAdj,staticOff)
            do (if isIncluded  then
                   (if traceModules then
                       '**   genMI:Module included: ' -> puttext; 
                       sig.doPT -> puttext;
                       ' staticOff:' -> puttext; staticOff -> putint;
                       newline
                   if);
                   cTracer(#do 'Module:genMI: '-> TT; sig.dopt->TQ #);
                   (if inMainPath then
                       (if false then
                           '**** inMainPath: ' -> puttext;
                           sig.dopt -> putline;
                       if);
                       this(Module)[] -> mainPathModule[]
                    else
                       (useRtnVal,superAdj,staticOff) -> gen;
                   if)
                else
                   (if traceModules then
                       '**** genMI:Module not included: ' -> puttext;
                       sig.doPT -> putline
               if)if)
            exit mainPathModule[]
            #);          
          getAdr::
            (#
            do true -> loadRec;
               0 -> Address -> A[];
               newOff -> A.off
            #); 
          getNewOff::(#do newOff -> off #);
          loadAccessor::
            (#
            do fcTracer(#do 'Module:loadAccessor:'->TT; sig.dopt->TL #);
               (sig.id[],newOff) -> cd.rpushg
            #);
          newInvoke::
            (#
            do fcTracer(#do 'Module:invoke:newOff:'->TT; newOff -> II #);
               (if nameListInDcl then
                   (* Assuming only one var in a module decl *)
                   (sig.id[],(sig.names.firstDecl).newOff) -> cd.rpushg
                else
                   (sig.id[],newOff) -> cd.rpushg
               if)
            #);
          findNextImp:: (# do bcp -> OG.IS.findNextImp -> impx[] #);
          clear ::< (#do false -> codeGenDone; inner #)
       #);
     ModuleItem::
       (# gen::
            (#
            do (if MD.isIncluded then
                   (if traceModules then
                       '**** ModuleItem:included: ' -> puttext; 
                       sig.doPT -> putline;
                   if);
                   cTracer(#do 'ModuleItem:gen'-> TT; sig.dopt->TT #);
                   (if MD.inMainPath then
                       MD[] -> mainPathModule[]
                    else
                       (useRtnVal,superAdj,staticOff) -> MD.gen;
                   if)
                else
                   (if traceModules then
                       'Module not included: ' -> puttext; 
                       sig.doPT -> putline
               if)if)
            #);
          getAdr::
            (#
            do A[] -> MD.getAdr -> (loadRec,A[])
            #);
          getNewOff:: (#do MD.getNewOff -> off #);
          pushThis:: (# do cd.pushThis #);
          loadAccessor::
            (#
            do fcTracer(#do 'MI:loadAccessor:'->TT; sig.dopt->TL #);
               (rec[],valueOff,next[]) -> MD.loadAccessor
            #);
          newInvoke:: 
            (#
            do fcTracer(#do 'ModuleItem:invoke:'->TT #);
               (rec[],E[],useRtnVal,valueOff,staticOff,isAdr,none)
                 -> MD.newInvoke 
            #);
          store:: (# do '\nModuleItem:store'->putline #);
          popReturn:: (# do '\nModuleItem:popReturn'->putline #);
          findNextImp:: (# do bcp -> md.findNextImp -> impx[] #);          
       #);
     newProperty::
       (# gen::  
            (* Code for ModuleItems must be generated in the order they
             * appear in %requires, %visible, %module(s) props
             *)
            (# MIlist: @
                 (* Keep track of all ModuleItems in this(Items) *)
                 (# collect:
                      (* collect all ModuleItems of this(Items) *)
                      (#
                      do (theModule).OG.IS.scanAllDecls
                         (#
                         do (if currentDcl.isModuleItem then
                                (if false then
                                    '**   collect: ' -> puttext;
                                    currentDcl.sig.dopt -> putline;
                                if);
                                currentDcl[] -> add
                         if)#)
                      #);
                    add:
                      (# MI: ^ModuleItem
                      enter MI[]
                      do (if (top + 1 -> top) > L.range then
                             L.range -> L.extend;
                             done.range -> done.extend
                         if);
                         MI[] -> L[top][]
                      #);
                    scan:
                      (# current: ^ModuleItem
                      do (for i: top repeat
                              L[i][] -> current[];
                              inner scan
                         for)
                      #);
                    has: BooleanValue
                      (# M: ^Module
                      enter M[]
                      do L:
                           scan
                           (# i: @integer
                           do i + 1 -> i;
                              (if current.MD[] = M[] then
                                  true -> value;
                                  true -> done[i];
                                  leave L
                           if)#)
                      #);
                    gen:
                      (* Generate code for all ModuleItems in this(Items) *)
                      (# MP: ^Module
                      do scan
                         (# i:@integer
                         do i + 1 -> i;
                            (if not done[i] then
                                (if false then
                                    '**   gen:MI: ' -> puttext; 
                                    current.sig.dopt -> putline;
                                if);
                                (true,superADj,staticOff) 
                                  -> current.MD.genMI
                                  -> MP[];
                                (if MP[]<>none then
                                    MP[]->mainPathModule[]
                         if)if)#)
                      #);
                    L: [8] ^ModuleItem; done: [8] @boolean; top: @integer
                 #);
               isLocalMI: @boolean
            do (if false then
                   '**** newProperty:gen: ' -> puttext; dopt -> puttext;
                   ' in:module: ' -> puttext; 
                   (theModule).sig.dopt -> putline
               if);
               (if true
                // ('%requires' -> propId.T.equalNCS)
                // ('%visible' -> propId.T.equalNCS)
                // ('%module' -> propId.T.equalNCS) 
                // ('%modules' -> propId.T.equalNCS) then
                   (if (TheModule).requires.codeGenDone then
                       leave gen 
                   if);
                   (if traceModules then
                       '**** newProperty:gen:%module ' -> puttext; 
                       dopt -> puttext;
                       ' in:module: ' -> puttext; 
                       (theModule).sig.dopt -> putline
                   if);
                   MIlist.collect; 
                   (theModule).requires.scan
                   (#
                   do (if current[] -> MIlist.has then
                          (if false then
                              '**   moduleProp:arg:in:MI:' -> puttext;
                              current.sig.dopt -> putline;
                          if);
                          (if current.inMainPath then
                              (if false then
                                  '**    module:inMainPath: ' -> puttext;
                                  current.sig.dopt -> putline;
                              if);
                              current[] -> mainPathModule[]
                              (* it seems that not all modules
                               * that should be on mainPath is catched
                               * by mainPathModule[]!?
                               *)
                           else
                              (true,0,0) -> current.gen
                   if)if)#);
                   MIlist.gen;
                   true -> (theModule).requires.codeGenDone;
            if)#)
       #);
     storeDecls:
       (* a primitive value, V,  is on the vstack;
        * thisObj is on the rstack;
        * forEach nameDecl, N, store V in N.off
        *)
       (# sig: ^Signature; OGx: ^ObjectGenerator
       enter(sig[],OGx[])
       do cTracer(#do'storeDecls:'->TT; sig.dopt -> TQ #);
          sig.names.scan
          (# i: @integer
          do i + 1 -> i; 
             (if (sig.names.noOfSons > 1) 
                 and (i < sig.names.noOfSons) then 
                 cd.double
             if);
             (if i > 1 then cd.pushThis if);
             (OGx.OGidWdNo,current.NewOff) -> cd.storeg;
          #)
       #);
     storeRefDecls:
       (* a primitive value, V,  is on the vstack;
        * thisObj is on the rstack;
        * forEach nameDecl, N, store V in N.off
        *)
       (# sig: ^Signature; OGx: ^ObjectGenerator
       enter(sig[],OGx[])
       do sig.names.scan
          (# i: @integer
          do i + 1 -> i; 
             (if (sig.names.noOfSons > 1) 
                 and (i < sig.names.noOfSons) then 
                 cd.rdouble
             if);
             (if i > 1 then cd.pushThis if);
             (sig.id[],current.newOff) -> cd.rstoreg
          #)
       #);
     storeRealDecls:
       (* a primitive value, V,  is on the vstack;
        * thisObj is on the rstack;
        * forEach nameDecl, N, store V in N.off
        *)
       (# sig: ^Signature; OGx: ^ObjectGenerator
       enter(sig[],OGx[])
       do sig.names.scan
          (# i: @integer
          do i + 1 -> i; 
             (if (sig.names.noOfSons > 1) 
                 and (i < sig.names.noOfSons) then 
                 cd.double; '!!!! DI:storeRealDecls:need:fdouble'->putline;
             if);
             (if i > 1 then cd.pushThis if);
             (sig.id[],current.NewOff) -> cd.fstoreg
          #)
       #);
     DataItem::
       (* Cases
        *    C1: val integer(12)
        *    C2: val integer
        *    C3: obj Fool
        *    C4: obj Fool -- singular
        *       ...
        *    V1: var integer(12)
        *    V2: var integer
        *    V3: ref Fool
        *    V4: ref Fool -- singular
        *       ...
        *    X1: obj/val/var foo(e1,e2,e3) where foo returns a ref(T) or val(T)
        *)
       (# gen:: 
            (# trace1: 
                 (#
                 do fcTracer
                    (#
                    do 'DI:gen:' -> TT; doPT -> TL;
                       'DI:isConst:' -> TT; isConst -> BB;
                       'isBasicValue:'->TT; OG.isBasicValue->BB;
                       'primNo:'->TT; OG.primNo -> II;
                 #)#);
               T: @text; org: ^Items; D: ^DataItem; rtnOff: @integer
            do trace1;
               (if true 
                // OG.isBasicPattern and not OG.isConstLiteral then
                   (* No OG.gen for X: var/val integer
                    * Cf the discussion of #foo versus foo  *)
                   fcTracer(#do 'DI:gen:primitiveType:'->TT; sig.dopt->TT #);
                // OG.isBasicValue then 
                   (* C1,C2,V1,V2                
                    * X: val integer(7)
                    * X: var 7
                    * X: val a + b
                    *)
                   (if OG.isValueObj then 
                       (* OG is a ValueObject returning a Basic value 
                        * like integer
                        *    mkIntB: ... out V: var integer ...
                        * We shall thus not allocate a value obj, 
                        * but a plain integer
                        * the invocation of mkIntB shall be boxed
                        *)
                       (* If OG is valueObj then
                        * newOff = 0 does not work
                        *)
                       fcTracer(#do 'DI:valueObj:' -> TT; sig.dopt -> TT #);
                       (true,0,0) -> OG.gen 
                    else (* when is newOff needed here? *)
                       cTracer(#do 'DI:add:BP3: ' -> TT; sig.dopt -> TT #);
                       (if nameListInDcl then
                           (true,0,(this(DataItem).sig.names.firstDecl).NewOff) 
                             -> OG.gen;
                        else
                           (true,0,this(DataItem).NewOff) -> OG.gen;
                   if)if);
                   fcTracer
                   (#do 'DI:store:basicValue:' -> TT; 
                      'off:' -> TT; off -> II; 'NewOff:' -> TT; NewOff -> II
                         #);
                   cd.pushThis;
                   (if OG.isFloat then
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeRealDecls
                        else
                           (sig.id[],this(DataItem).NewOff) -> cd.fstoreg
                       if)
                    else
                       origin[] -> org[];
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeDecls
                        else
                           (sig.id[],this(DataItem).NewOff) -> cd.storeg
                   if)if)
                // (OG.primNo = String_prim) and isConst then
                   (* Like S: obj "hello"
                    * Old comment:
                    * Could be  V: obj elm where elm:< Object 
                    * but is this true ?
                    *)
                   fcTracer(#do 'DI:add:BP3: ' -> TT; sig.dopt -> TT #);
                   (true,0,this(DataItem).NewOff) -> OG.gen;
                   cd.pushThis;
                   (if true then
                       origin[] -> org[];
                       (if nameListInDcl then
                           (org.encOG.OGidWdNo,(sig.names.firstDecl).NewOff) 
                             -> cd.rstoreg
                        else
                           (org.encOG.OGidWdNo,this(DataItem).NewOff) -> cd.rstoreg
                       if)
                    else
                       (sig.id[],this(DataItem).NewOff) -> cd.rstoreg
                   if);
                // (OG.primNo = String_prim) and (not isInArg) then
                   fcTracer(#do 'DI:StringVar' -> TT; dopt -> TQ #);
                   ('',(stringDecl.desc).newDescNo) -> cd.pushText;
                   cd.pushThis;
                   (sig.id[],this(DataItem).NewOff) -> cd.rstoreg
                // isConst or not OG.IS.isEmpty or isValue then
                   (* isConst: obj, val, isValue: val, var *)
                   fcTracer(#do 'DI:isConst:' -> TT; sig.dopt -> TT #);
                   (* C3,C4,V4 *)
                   (* All objects/patterns being embedded must be handled by
                    * Alloc and gen since we must know the size *)
                   (* X: = Foo or 
                    * Singular T: = P{...} 
                    * C3,C4,V4 *)
                   cd.bcPos -> beginBCP;
                   (if isInArg then (* also outArg? *)
                       fcTracer(#do 'inArg:' -> TT; doPT -> TT #);
                    else
                       (if (OG.primNo = String_prim) then
                           fcTracer(#do 'DI:String:'->TT; dopt -> TQ;
                                    'off:'->TT; newOff -> II;
                                 #);
                        else
                           (* X: obj T;  -- return this(T)
                            *    invoke must store ref in X.off
                            *    useRtnVal = false ==> rpop
                            * X: obj T; -- T has out parameter
                            *    same as next case
                            * X: obj T.init(e) -- return this(init)
                            *    ref(init) on top of rStack
                            *    rpush ref(init).outDecl
                            *    pushThis
                            *    rstore ref(init).outDecl in X.off
                            * What about
                            *    T: {out R: ref T; ...; R := this(T)}
                            *    should be handled like (1) above
                            *)
                           (if (OG.getReturnDecl -> D[]) <> none then
                               (true,0,0) -> OG.gen;
                               (OG.getQual,'RTN') -> pushOut -> rtnOff;;
                               fcTracer(#do'DI:after:pushOut:'->TT;rtnOff->II#);
                               cd.pushThis;
                               (if nameListInDcl then
                                   ('RTN',(sig.names.firstDecl).NewOff) 
                                     -> cd.rstoreg
                                else
                                   ('RTN',this(DataItem).NewOff) -> cd.rstoreg
                               if)
                            else
                               fcTracer
                               (#do 'DI:off:'->TT;this(DataItem).NewOff -> II;
                                  'this:'->TT; dopt->TL; nl;
                               #);
                               (if nameListInDcl then
                                   fcTracer
                                   (#do 'DI:off:'->TT;
                                      (sig.names.firstDecl).NewOff->II;
                                      (sig.names.firstDecl).dopt->TL
                                   #);
                                   (false,0,(sig.names.firstDecl).NewOff) 
                                     -> OG.gen;
                                else
                                   (false,0,this(DataItem).NewOff) -> OG.gen;
                   if)if)if)if);
                   cd.bcPos -> endBCP;
                   (* else V3 - just a qualifcation; 
                    * see also the discussion of #foo versus foo *)
                   (* Could be S: ?elm where elm:< Object -- no code gen *)
               if)
            #);
          pushThis:: (# do cd.pushThis #);
          loadArgs::
            (# gdb::
                 (#
                 do '>E:'->TT; E.doPT -> TQ; E.args.dopt -> TT 
                 #);
            do L:
                 (if OG.IS.isEmpty then
                     (E[],superAdj,staticOff) -> (OG.super.ATd.asDecl).loadargs;
                  else
                     (* primitive check for args being non empty! *)
                     E.args.scanArgs
                     (#do '\n!!!! DataItem:loadArgs:IS not empty! '->putline#)
                 if)
            #);
          getAdr::
            (# gdb::
                 (#
                 do '>newOff:'->TT; newOff -> II; 
                    ',isValue:'->TT; isValue-> BB;
                    OG.isBasicValue -> BB; isValue -> BB;
                    OG.isValueObj -> BB; 
                    ':value_prim:'->TT ;OG.primNo = value_prim->BB;
                    ':A:'->TT; A.toString -> TT;
                 #);
               E: ^Exp; originIsValue: @boolean; ptn: ^Pattern; 
               UN,UNx: ^NewProperty;
               OGx: ^ObjectGenerator; 
               OGsx: ^OGSequence
            do (* OG.primNo = value_prim for handling _v: var Value 
                * in integer, char and boolean *)
               (if (OG.isBasicValue or OG.isValueObj) 
                   or (OG.primNo = value_prim) then
                   (if not A.isValue then
                       true ->  loadRec;
                       A.E[] -> E[]; A.originIsValue -> originIsValue;
                       0 -> Address -> A[]; 
                       E[] -> A.E[]; originIsValue -> A.originIsValue;
                       newOff -> A.off;
                       OG.isBasicValue 
                       or OG.isValueObj or (OG.primNo = value_prim)
                         -> A.isValue; 
                    else
                       (if nameListInDcl then
                           (* there emay be more than one name in names! *)
                           (if A.off > 0 then
                               (sig.names.firstDecl).newOff - 1 + A.off 
                                 -> A.off;
                            else
                               (sig.names.firstDecl).newOff -> A.off
                           if)
                        else
                           (if A.off > 0 then
                               newOff - 1 + A.off -> A.off;
                            else
                               newOff -> A.off
                       if)if);
                       OG.isBasicValue or OG.isValueObj 
                       or (OG.primNo = value_prim)
                         -> A.isValue;
                   if);
                   (if A.isValue then   
                       (OG.super.ATd.asDecl).OG.IS.newDescNo -> A.valDescNo 
                   if);
                   cTracer(#do 'DI:OG:'->TT; OG.dopt -> TT #);
                   (if (OG.super.ATd[] <> none)
                       and (OG.super.ATd.asDecl->ptn[]).OG.IS.isEmpty then
                       (* MUST be FIXED: introduce getNewBasicProp*)
                       (ptn.OG.super.ATd.asDecl).OG.IS.newBasicProp.UNIT[] 
                         -> UN[];
                    else
                       ptn.OG.IS.newBasicProp.UNIT[] -> UN[];
                   if);
                   cTracer(# UN: ^NewProperty; ptn: ^Pattern
                         do 'before:floatTest: ' -> TT;
                            dopt -> TQ;
                            OG.label -> TT;
                            (if ptn[] <> none then
                                ptn.sig.dopt -> TT; 
                                (if ptn.OG.IS.isEmpty then
                                    ' IS.empty:'->TT
                                 else
                                    ' NOT IS.empty:'->TT
                                if);
                                (if UN[] <> none then UN.dopt -> TT; if)
                         if)#);
                   cTracer(#do A.toString->TT #);
                   UN[] <> none -> A.isUnitVal;
                   cTracer(#do 'After:U*U:'->TT; A.toString->TT #);
                   (if (OG.primNo = float_prim) or OG.isFloat then
                       cTracer(#
                             do 'getAdr:isfloat:A: ' -> TT; dopt -> TT;
                                ' A.isValue:'->TT; A.isValue -> BB
                             #);
                       true -> A.isFloat
                   if);
                else                   
                   true -> loadRec;
                   0 -> Address -> A[];
                    (if nameListInDcl then
                        (* there may be more than one name in names! *)
                        (sig.names.firstDecl).newOff -> A.off
                     else
                        newOff -> A.off
               if)if)
            #);
          getNewOff:: (#do newOff -> off #);
          loadAccessor::
            (# accessCmpAndSwap:
                 (#
                 do fcTracer
                    (#do 'DI:loadAccessor:cmpAndSwap:'->TT; dopt -> TL;
                       ('next:',next[]) -> PT(#do next.dopt -> TL #)#);
                    newOff -> cd.pushconst
                 #);
               accessPrimitive:
                 (#
                 do fcTracer
                    (#do 'DI:loadAccesor:loadPrimitive:'->TT; sig.dopt->TL;
                       (*'isAdr:' -> TT; isAdr->BB;
                       'valueOff:'->TT; valueOff -> II*)
                    #);
                    (if valueOff > 0 then valueOff - 1 -> valueOff if);
                    (if OG.isFloat then
                        (if (rec[] = none)
                            and (origin.ogOfScope).isValueObj then
                            ('newInvoke',newOff + valueOff) -> cd.fvpushg
                         else
                            ('newInvoke',newOff + valueOff) -> cd.fpushg
                        if);
                     else (* integer, boolean, char *)
                        (if (rec[] = none) 
                            and (origin.ogOfScope).isValueObj then
                            ('newInvoke',newOff + valueOff) -> cd.vpushg
                         else
                            ('newInvoke',newOff + valueOff) -> cd.pushg
                    if)if)
                 #);
               accessUnitValueObj:
                 (* Situation:
                  * U * e,         next = '* e', * primitivePattern
                  *                push U
                  * U . magnitude, next = magnitude, primitiveDI
                  *                no push, add U.off to magnitude.off
                  * U . print,     next = print, non-primitive pattern
                  *                no push
                  *)
                 (# nextDcl:  ^Decl
                 do fcTracer(#do 'DI:loadAccessor:accessUnitValueObj:NOT'->TT;
                               sig.dopt->TL #);
                    next.ATd.asDecl -> nextDcl[];
                    (if true
                     // nextDcl.isBasicValue and nextDcl.isPattern then
                         ('newInvoke',newOff (*+ valueOff*)) -> cd.fpushg;
                    if)
                 #);
               accessValueObj:
                 (# dn: @integer; ITx:  ^Items
                 do fcTracer(#do 'DI:loadAccessor:accessValObj:'->TT;
                               sig.dopt->TL #);
                    (if (origin[] -> ITx[]).primNo
                     // vEq_prim // vLE_prim then
                        ('newInvoke',newOff) -> cd.rpushg
                     else
                        (if true (*isAdr*) then
                           (* ('newInvoke',newOff) -> cd.rpushg*)
                         else
                            (if OG.IS.isEmpty then
                                (OG.super.ATd.asDecl).OG.IS.newDescNo -> dn
                             else
                                OG.IS.newDescNo -> dn
                            if);
                            (newOff,OG.objSize,dn) -> cd.pushValue;
                    if)if)
                 #);
               accessObj:
                 (#
                 do fctracer(#do 'DI:loadAccessor:Obj:'->TT;dopt->TL #);
                    ('newInvoke',NewOff) -> cd.rpushg
                 #)
               
            do fcTracer(#do 'DI:loadAccessor:'->TT; sig.dopt->TL #);
               (if true 
                // OG.isBasicValue 
                // OG.primNo = value_prim then
                   (if ((next.ATd.asDecl).primNo = cmpAndSwap_prim) then
                       accessCmpAndSwap
                    else
                       accessPrimitive
                   if)
                // OG.isUnitValueObj then
                   accessUnitValueObj
                // OG.isValueObj then
                   accessValueObj
                else
                   accessObj
               if)
            #);
          newInvoke::
            (# invokeCmpAndSwap:
                 (* Is obsolete: handled by loadAccessor *)
                 (#
                 do fcTracer
                    (#do 'DI:newInvoke:cmpAndSwap:'->TT; dopt -> TL;
                       ('next:',next[]) -> PT(#do next.dopt -> TL #)#);
                    newOff -> cd.pushconst
                 #);
               loadPrimitive:
                 (#
                 do fcTracer
                    (#do 'DI:newInvoke:loadPrimitive:'->TT; sig.dopt->TL;
                       'isAdr:' -> TT; isAdr->BB;
                       'valueOff:'->TT; valueOff -> II
                    #);
                    (if isAdr and not isBasicValue then
                        (* valueOff may be > 0 !? *)
                        ('newInvoke',newOff) -> cd.rpushg
                     else
                        (if OG.isFloat then
                            (if (rec[] = none)
                                and (origin.ogOfScope).isValueObj then
                                ('newInvoke',newOff + valueOff) -> cd.fvpushg
                             else
                                ('newInvoke',newOff + valueOff) -> cd.fpushg
                            if);
                         else (* integer, boolean, char *)
                            (if (rec[] = none) 
                                and (origin.ogOfScope).isValueObj then
                                ('newInvoke',newOff + valueOff) -> cd.vpushg
                             else
                                ('newInvoke',newOff + valueOff) -> cd.pushg
                    if)if)if)
                 #);
               invokeUnitValueObj:
                 (#
                 do fcTracer
                    (#do 'DI:invokeUnitValueObj:'->TT; dopt->TT; 'isAdr:'->TT; isAdr->BB #);
                    (if not isAdr or 
                        (next[] <> none) and (next.ATd.asDecl).OG.isBasicValue then
                        ('newInvoke',newOff (*+ valueOff*)) -> cd.fpushg
                    if)
                 #);
               invokeValueObj:
                 (# dn: @integer; ITx:  ^Items
                 do fcTracer
                    (#do 'DI:newInvoke:invokeValueObj:'->TT; dopt->TL;
                       'E.ATd:'->TT; E.ATd.dopt -> TL;
                       'isAdr:'->TT; isAdr->BB;
                       'primNo:'->TT; OG.primNo->II;
                       origin[] -> ITx[];
                       ITx.primNo -> II
                    #);
                    (if (origin[] -> ITx[]).primNo
                     // vEq_prim // vLE_prim then
                        loadPrimitive
                     else
                        (if isAdr then
                           (* ('newInvoke',newOff) -> cd.rpushg*)
                         else
                            (if OG.IS.isEmpty then
                                (OG.super.ATd.asDecl).OG.IS.newDescNo -> dn
                             else
                                OG.IS.newDescNo -> dn
                            if);
                            (newOff,OG.objSize,dn) -> cd.pushValue;
                    if)if)
                 #);
               loadObj:
                 (#
                 do fctracer(#do 'DI:newInvoke:loadObj:'->TT;dopt->TL #);
                    ('newInvoke',NewOff + valueOff) -> cd.rpushg
                 #)
            do fcTracer
               (#do 'DI:newInvoke:'->TT; dopt->TL; ('off:',off)->TI;
                  ('valueOff:',valueOff)->TI; 'E:'->TT; E.dopt -> TL;
                  ('next:',next[])->PT(#do next.dopt->TL #);
                  'isAdr:'->TT; isAdr->BB #); 
               (if isAdr then
                   pfcTracer(#do 'DI:newInvoke:isAdr=TRUE:'->TT; dopt->TL; #)
               if);
               (if valueOff > 0 then valueOff - 1 -> valueOff if);
               (if true 
                // OG.isBasicValue 
                // OG.primNo = value_prim then
                   (if (next[] <> none) and
                       ((next.ATd.asDecl).primNo = cmpAndSwap_prim) then
                       invokeCmpAndSwap   
                    else
                       loadPrimitive
                   if)
                // OG.isUnitValueObj then
                   invokeUnitValueObj
                // OG.isValueObj then
                   invokeValueObj
                else
                   loadObj
               if)
            #);

          newStore:
            (# checkForI2F:
                 (* assuming this(DI) is not int *)
                 (#
                 do (if rightQual[] <> none (* should be *) then
                        fcTracer
                        (#do (rightQual.primNo <> float_prim)
                           and not rightQual.isUnitValueObj->BB;
                           (rightQual.primNo <> float_prim)->BB;
                           not rightQual.isUnitValueObj->BB;
                           rightQual.dopt->TL
                        #);
                        (* can we just use not right.isFloat?
                         * must include unitValueObj
                         *)
                        (if (rightQual.primNo <> float_prim)
                            and (not rightQual.isUnitValueObj
                            or right.isConstLiteral and not right.isFloat) then
                            cd.I2F
                        if)
                     else
                        fcTracer(#do 'I2F:rightQual:none:'->TT; dopt -> TL #);
                        (if ptn[] <> none then
                            (if ptn.OG.primNo <> float_prim then
                                cd.I2F
                    if)if)if)
                 #);
               checkForF2I:
                 (* assuming this(DI) is not float *)
                 (#
                 do (if rightQual[] <> none (* should be *) then
                        (if rightQual.primNo = float_prim then
                            cd.F2I
                        if)
                     else
                        fcTracer(#do 'F2I:rightQual:none:'->TT; dopt -> TL #);
                        (if ptn[] <> none then
                            (if ptn.OG.primNo = float_prim then
                                cd.F2I
                    if)if)if)
                 #);
               valueOff,mode: @integer; isNotRemote,originIsValueObj: @Boolean;
               dstE,firstDstE: ^Exp; ptn: ^Pattern; 
               right,rightQual: ^ObjectGenerator;
               (* we think: ptn.OG = rightQual - so elim ptn *)
            enter(valueOff,isNotRemote,dstE[],ptn[],rightQual[],right[])
            do fcTracer
               (#do 'DI:newStore:'->TT; sig.dopt->TL;
                  ('off:',newOff)->TI; ('valueOff:',valueOff)->TI;
                  'dstE:'->TT; dstE.dopt->TL;
                  'isNotRemote:'->TT; isNotRemote->BB;
                  'originIsValueObj:'->TT;
                  this(DataItem).origin.encOG.isValueObj -> BB;
                  ('rightQual:',rightQual[]) -> PT
                  (#do 'isUnitValueObj:'->TT; OG.isUnitValueObj-> BB;
                     'rightQual:primNo:'->TT; rightQual.primNo->II;
                     'rightQual.isUnitValueObj:'->TT;
                     rightQual.isUnitValueObj->BB;
               #)#);
               (*not isNotRemote and*) this(DataItem).origin.encOG.isValueObj
                 -> originIsValueObj;
               fcTracer(#do 'originIsValueObj:'->TT; originIsValueObj->BB #);
               (if valueOff > 0 then valueOff - 1 -> valueOff if);
               (if true 
                // OG.isBasicValue 
                // OG.isUnitValueObj
                // OG.primNo = value_prim then
                   (if OG.isUnitValueObj then 0 -> valueOff if); (* hack! *)
                   L: dstE.scanSons(#do current[]->firstDstE[]; leave L #);
                   (if (OG.primno = float_prim) or OG.isUnitValueObj then
                       fcTracer
                       (#do 'firstDstE:'->TT; firstDstE.doPT->TL; 
                          'firstDstE.isValueObj:'->TT;
                          firstDstE.ATd.origin.encOG.isValueObj->BB #);
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeRealDecls
                        else
                           (if firstDstE.ATd.origin.encOG.isValueObj
                               (*this(DataItem).origin.encOG.isValueObj*) then
                               fcTracer
                               (#do 'DI.origin.encOG.OG.isValueObj'->TT #);
                               (OG.OGidWdNo,newOff + valueOff) -> cd.fvstoreg
                            else
                               fcTracer
                               (#do 'di:newSTore:X:'->TT;dopt->TL;
                                  ('ptn:',ptn[])->PT(#do ptn.dopt->TL #)#);
                               (sig.id[],newOff + valueOff) -> cd.fstoreg
                       if)if)
                    else
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeDecls
                        else
                           (if not isNotRemote and 
                               this(DataItem).origin.encOG.isValueObj then
                               cTracer(#do'DI.origin.encOG.OG.isValueObj'->TT#);
                               (OG.OGidWdNo,newOff + valueOff) -> cd.vstoreg
                            else
                               (OG.OGidWdNo,newOff + valueOff) -> cd.storeg
                   if)if)if)
                // OG.isValueObj then
                   fcTracer(#do 'DI:newStore:valueObj:'->TT;dopt->TL #);
                   (* Two situations
                    *   P1 := Point(5,6)   ptn[] <> none
                    *   P1 := P2
                    * should be handled in a more clean way
                    *)
                   (if ptn[] <> none then
                       fcTracer(#do 'DI.newStore:valuePtn:'->TT #);
                       (*cd.vpop;*)
                       cd.saveAndSetThis;
                       (sig.id[],ptn.OG.IS.newDescNo,newOff - 1,inValueObj)
                         -> cd.invokeVal;
                       cd.rpop;
                       cd.restoreThis
                    else
                       (if originIsValueObj then 1 -> mode if);
                       (newOff(*+ valueOff*),OG.objSize,mode) -> cd.vassign
                   if)
                // OG.primNo = indexed_prim then
                   fcTracer
                   (#do 'DI:newStore:indexed:'->TT; dopt->TL; 
                      'right:'->TT; right.dopt->TL
                   #);
                   (if right.bracketedListElement > 0 then
                       right.bracketedListElement -> cd.pushConst;
                       (OG.super.ATd.asDecl).OG.IS.newDescNo -> cd.mkVindexed
                   if);
                   cd.rswap;
                   (sig.dopt,newOff) -> cd.rstoreg
                //  OG.primNo = rindexed_prim then
                   fcTracer
                   (#do 'DI:newStore:rIndexed:'->TT; dopt->TL; 
                      'right:'->TT; right.dopt->TL
                   #);
                   (if right.bracketedListElement > 0 then
                       right.bracketedListElement -> cd.pushConst;
                       (OG.super.ATd.asDecl).OG.IS.newDescNo -> cd.mkVindexed
                   if);
                   cd.rswap;
                   (sig.dopt,newOff) -> cd.rstoreg
                else (* including OG.primNo = string_prim then*)
                   fcTracer(#do 'DI:newStore:ref/String:'->TT; dopt -> TL #);
                   (if originIsValueObj then
                       fcTracer(#do 'DI:newStore:no:rvstoreg:'->TT; dopt->TL#);
                       (*(OG.OGidWdNo,newOff + valueOff) -> cd.rvstoreg*)
                    else
                       cd.rswap;
                       (OG.OGidWdNo,newOff + valueOff) -> cd.rstoreg
               if)if)
            #); 
          store::
            (# gdb::
                 (#do '>newOff:'->TT; newOff -> II;
                       ',isVirtualObject:' -> TT; isVirtualObject -> BB;
                       ' isValueObj:'->TT; OG.isValueObj -> BB
                    #);
               OGx: ^ObjectGenerator; org:  ^Scope
            do cTracer(#do 'DI:store:' -> TT; sig.dopt-> TQ #);
               (if true
                // OG.isBasicValue // OG.primNo = value_prim 
                   (*// OG.isUnitValueObj*) then 
                   (* OG.primNo = value_prim for handling _v: ?Value 
                    * in integer, char and boolean *)
                   cd.pushThis;
                   (if (OG.primno = float_prim) or OG.isUnitValueObj then
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeRealDecls
                        else
                           (if (*false and*) withValueProxy and 
                               this(DataItem).origin.encOG.isValueObj then
                               cTracer(#do'DI.origin.encOG.OG.isValueObj'->TT#);
                               (OG.OGidWdNo,NewOff) -> cd.fvstoreg
                            else
                               (sig.id[],NewOff) -> cd.fstoreg
                       if)if)
                    else
                       (if true then
                           (if nameListInDcl then
                               (sig[],OG[]) -> storeDecls
                            else
                               (if withValueProxy and 
                                   this(DataItem).origin.encOG.isValueObj then
                                   cTracer(#do 'DI.origin.encOG.OG.isValueObj'->TT#);
                                   (OG.OGidWdNo,NewOff) -> cd.vstoreg
                                else
                                   (OG.OGidWdNo,NewOff) -> cd.storeg
                           if)if)
                        else
                           (sig.id[],NewOff) -> cd.storeg
                   if)if)
                // OG.isValueObj then
                   (* is the order of src and dest objs on the stack correct? *)
                   (# L1, L2: @labelHandler.label; out: ^text; 
                      E: ^Invocation; OGs: ^OGsequence;
                      qual: ^objectGenerator
                   do L1.new; L2. new;
                      (0,L1) -> cd.jmpFalse;
                      cd.pushThis;
                      (if false then
                          (if nameListInDcl then
                              (sig.names.firstDecl).off -> cd.pushConst;
                           else
                              newOff -> cd.pushConst;
                      if)if);
                      (if false then
                          (* attemtp to handle Cvalue with 
                           * in V: var ThisValue
                           * but does not work, since we dont know the
                           * size of thisValue
                           *)
                          '**** bingo:'->puttext; og.objsize->putint; 
                          ' ' -> PUT; OG.dopt -> putheadN;
                          '**   DI:'->puttext; dopt ->putheadN;
                          (if OG.IS.isEmpty then
                              '**** OG.IS.isEmpty: ' -> puttext;
                              OG.super.dopt -> putline;
                          if);
                          '**   mainIS:'->puttext; mainIS.dopt -> putheadN;
                      if);
                      sig.dopt -> parseInv->(out[],E[]);
                      mainIS[] -> E.father[];
                      mainIS[] -> E.setUpOrigin;
                      (none,mainIS[],mainIs[],true) -> E.check;
                      (mainIS.encOG,true
                      ,(mainIS.encOG,false,none) -> OGsequence)
                        -> E.getVqual 
                        -> (OGs[],qual[]);
                      fcTracer(#do 'vassign:B:' -> TT; sig.dopt->TT;
                                'off:'->TT; newOff -> II;
                                'size:'->TT; objSize -> II; 'mode: 0' -> TT
                             #);
                      (newOff,OG.objSize,0) -> cd.vassign;
                      L2 -> cd.jmp;
                      L1 -> cd.defLab;   
                      (if true then
                          (if nameListInDcl then
                              (sig.id[],(OG.superPtn).new_DescNo,
                              (sig.names.firstDecl).newOff - 1,inValueObj)
                                -> cd.invokeVal;
                           else
                              (sig.id[],(OG.superPtn).new_DescNo,newOff - 1
                              ,inValueObj)
                                -> cd.invokeVal;
                          if);
                          (if withValueProxy then cd.rpop if);
                       else
                          (sig.id[],(OG.superPtn).OG.IS.newDescNo,newOff - 1
                          ,inValueObj)
                            -> cd.invokeVal;
                      if);
                      L2 -> cd.defLab
                   #)
                else
                   cd.pushThis;
                   (if not noSwap then cd.rswap if); 
                   (* Could be S: ?elm where elm:< Object *) 
                   (if nameListInDcl then
                       (sig[],OG[]) -> storeRefDecls
                    else
                       (sig.id[],NewOff) -> cd.rstoreg
               if)if)
            #);
          popReturn::
            (#
            do (if OG.isBasicValue then 
                   cd.vpop
                else
                   (* could be S: ref elm where elm:< object*)
                   cd.rpop
            if)#)          
       #);
     NameDecl::
       (# loadArgs::
            (#
            do '**** NameDecl:loadArgs:'->puttext; dopt -> putline;
               (E[],superAdj,staticOff) -> ATd.loadArgs
            #);
          getAdr::
            (#
            do (*'**** NameDecl:getAdr:'->puttext; dopt -> putline;*)
               A[] -> ATd.getAdr -> (loadRec,A[]);
               (if A.off = 0 then off -> A.off if)
            #);
          getNewOff:: (#do '!!! NameDecl:getNewOff:not implemented'->putline #);
          newInvoke::
            (#
            do '**** NameDecl:newInvoke:'->puttext; dopt -> putline;
               (rec[],E[],useRtnVal,staticOff,valueOff,isAdr,next[]) 
                 -> ATd.newInvoke
            #)
       #);
     Signature:: (##);
     Arguments:: (##);
     AssignmentStatement::
       (# checkI2F2I:
            (#
            do fcTracer
               (#do 'checkI2F2I:'->TT; dopt->TL;
                  'left.isFloat:'->TT; left.isFloat->BB;
                  'right.isFloat:'->TT; right.isFloat->BB;
                  right.isPrimitiveIntWithFloatArg->BB;
                  'left.isFloat:X:'->TT; left.isFloat->BB;
               #);
               (if left.isFloat then
                   (if not right.isFloat then cd.I2F if);
                else 
                   (if right.isFloat or right.isPrimitiveIntWithFloatArg then
                       cd.F2I
            if)if)#);  
          checkUnitConv:
            (# dstBV,srcBV: ^BaseVector
            do left[]->getBaseVector -> dstBV[];
               right[]->getBaseVector->srcBV[];
               (if srcBV.convFactor <> dstBV.convFactor then
                   '**** unit:convFactor:differ:'->dumpt;
                   dopt -> dumpTN;
                   dstBV.asSymbols->dumpT;
                   srcBV.asSymbols->dumpTN;
                   (if srcBV.convFactor <> 1.0 then
                       srcBV.convFactor -> cd.pushFloatConst;
                       112 (* fmult *) -> cd.op
                   if);
            if)#);
          gen::
            (# MP:  ^Module;
               leftE: ^Exp; leftDI,DI:  ^DataItem; valueOff,rvOff: @integer;
               isNotRemote: @Boolean; D: ^Decl; ptn: ^Pattern
            do fcTracer(#do 'handleAssign:'->TT; dopt -> TL #);
               cd.bcPos -> beginBCP;
               (false,0 (*superAdj*),0,false) 
                 -> left.handleINV 
                 -> (leftE[],valueOff,isNotRemote);
               fcTracer(#do 'handleAssign:after:left:'->TT; dopt -> TL;
                       'leftE:'->TT; leftE.dopt->TL #);
               (true,0,0) -> right.gen -> (mp[],rvOff);
               fcTracer
               (#do 'handleAssign:after:right:'->TT; dopt->TL; #);
               leftE.ATd.asDecl -> leftDI[];
               (* Three situations
                *   P1 := Point(5,6)   ptn[] <> none
                *   P1 := P2
                *   P1 := mkPoint(e1,e2) - returns a Point
                * should be handled in a more clean way
                * Case (1) is handled by passing D[] to newStore below
                * Case (3) is handled by pushValue below
                * (3) and perhaps (1) should perhaps be handler by gen above!?
                *)
               (if (right.super.ATd.asDecl -> D[]).isPattern then 
                   (if D.OG.isValueObj and not D.OG.isBasicValue then
                       fcTracer(#do 'right:isPattern:valueObj:'->TT;dopt->TL #);
                    else
                       (D[]->ptn[]).getReturnDecl -> D[];
                       (if D[] <> none then
                           fcTracer
                           (#do 'right:isPTN:not:valueObj:'->TT; D.dopt -> TL#);
                           (if (D[]->DI[]).OG.isValueobj 
                               and not D.OG.isBasicValue then
                               (D.newOff,D.OG.objSize,D.OG.IS.newDescNo) 
                                 -> cd.pushValue
                           if);
                           none -> D[]
                   if)if)
                else
                   none -> D[]
               if);
               checkI2F2I;
               checkUnitConv;
               fcTracer
               (# OGs:  ^OGsequence; qual: ^ObjectGenerator;
               do 'Assign:end:'->TT; dopt->TL; 
                  'isNotRemote:'->TT; isNotRemote-> BB;
                  ('qual:',theSrcQual[])->PT(# do theSrcQual.doPT->TL #);
                  ('D:',D[])->PT(#do D.dopt -> TL #)
               #);
               (valueOff,isNotRemote,left[],D[],theSrcQual[],right[])
                 -> leftDI.newStore
            #);
       #);
     ObjectCall::
       (# classDef::
            (#
            do '**** ObjectCall:classDef: ' -> puttext; OGid-> puttext;
               ' ' -> put;
               IS.newDescno -> putint; newline;
            #);
          gen::
            (#
            do cTracer(#do dopt -> TQ; ' OC:isCompositeValueObj: ' -> TT;
                        isCompositeValueObj -> BB #);
               (if ((super.last).ATd[] <> none) 
                   and not ((super.last).ATd.asDecl).isPattern then
                   (* does no completely undersatand what goes on here
                    * For INV = L2, we have to assign 
                    * For inv := L1 * L2, we cannot!
                    *)
                   isCompositeValueObj -> (super.last).isCompositeValueObj;
               if);
               (useRtnVal,superAdj,staticOff) -> super.gen
            #);
       #);

     transInArgs:
       (# theOG: ^ObjectGenerator; staticOff: @integer; T: ^text
       enter(theOG[],staticOff)
       do theOG.OGidWdNo -> T[]; 
          theOG.IS.scanItemArgsReverse
          (# DI: ^DataItem
          do cd.lcom(#do 'store:arg: ' -> TT; currentarg.dopt -> TT #);
             (if (currentArg[]->DI[]).isBasicValue then
                 (T[],DI.newOff) -> cd.storeX
              else
                 (T[],DI.newOff,false) -> cd.rstoreX
          if)#);
       #);
     goOriginAdr:
       (# super: ^Invocation; ptn: ^Pattern; rec,E,pRec: ^Exp; 
          A,recA: ^Address;
          loadRec,orgIsVal: @Boolean; BE: ^ BracketedExp; 
       enter super[]
       do cd.lcom(#do 'goOriginAdr: ' -> TT; super.dopt -> TQ; #);
          (if super.isImplSuper then
              cd.lcom(#do 'goOriginAdr:isImplSuper:' -> TT #);
              (if super.isSingularImplSuper then
                  (* super = V:< A{...};skip - we have origin on the stack *)
               else
                  (* super = V:< A
                   * Binding has the form V::< { ... }
                   * Should be handled as if binding was: V::< A{ ... }
                   * as in the else-part below
                   *)
                  super.ATd.asDecl -> ptn[];
                  (* TODO *)
                  cd.lcom(#do '!!!TODO:goOriginAdr:super:not:implSingular:'->TT;
                            'super:' -> TT; super.dopt -> TQ; nl;
                            'super.father:' -> TL; super.father.dopt -> TQ; 
                            'ptn:' -> TT; ptn.dopt -> TQ; print  #);
              if)
           else
              cd.lcom(#do 'goOriginAdr:not:isImplSuper:' -> TT #);
              Address -> A[];
              super.scanSons
              (#
              do rec[] -> pRec[]; E[] -> rec[];
                 current[] -> E[];
                 (if isFirst then
                     cd.lcom(#do 'goOriginAdr:isFirst: '->TT; E.dopt -> TT #);
                     (if ('BracketedExp' -> (E.label).equalNCS) then
                         '\n!!! bracketedExp: ' -> puttext; 
                         E.dopt  -> putline;
                         (E[] -> BE[]).IV.scansons
                         (#
                         do current[]  ->  E[];
                            (if isFirst then
                                0 -> E.loadOrigin->(rec[],E[],orgIsval);
                                A[] -> E.getAdr -> (loadRec,A[]);
                             else
                                A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                                (if loadRec then
                                    cd.lcom(#do 'goOriginAdr:D:rec:' ->TT;
                                              rec.dopt -> TT #);
                                    (0,0) -> rec.loadArgs;
                                    (pRec[],E[],true,0,0,false,none)
                                      -> rec.newInvoke;
                         if)if)#)
                      else
                         cd.lcom(#do 'before:E.loadOrigin:'->TT; E.dopt->TQ#);
                         0 -> E.loadOrigin -> (rec[],E[],orgIsVal);
                         A[] -> E.getAdr -> (loadRec,A[]);
                     if);
                     (* shall we check for originIsValue? See computeAdr*)
                  else
                     cd.lcom(#do 'goOriginAdr:not:isFirst:'->TT; E.dopt->TT #);
                     A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                     (if loadRec then
                         cd.lcom(#do 'goOriginAdr:D:rec:' ->TT; rec.dopt->TT #);
                         (0,0) -> rec.loadArgs;
                         (pRec[],E[],true,0,0,false,none) -> rec.newInvoke;
                         cd.lcom(#do 'goOriginAdr:E: ' -> TT; #);
          if)if)#)if)   
       exit E[]
       #);
     storeOrigins:
       (* Store origins defined for the main OG and super patterns:
        * P1: {...}, P2: P1{...}, P3: P2{...}, OG = P3{...}
        * mainOG = OG = P3{...}
        * thisOG = one of P3, P2, P1
        * We may skip store of origin for OGs with same originOff
        *)
       (# mainOG,thisOG,OGx: ^ObjectGenerator; ISx: ^items; 
          rec,E: ^Exp; A: ^Address;
          trace: (# exit false #);
          fArgs: [10] ^DataItem; top: @integer; DI: ^DataItem;
          fromVDTalloc,orgIsVal: @boolean
       enter(mainOG[],thisOG[],fromVDTalloc)
       do (if thisOG.IS.newOriginOff > 0 then
              (if thisOG.super.ATd[] <> none then  -1 -> cd.rdouble if);
              (if fromVDTalloc and 
                  (thisOG.origin[] -> thisOG.IS.originisValue -> orgIsVal) then
                  cd.lcom(#do 'OBS! we need the correct off'-> TT;
                            'of value object in holder object'->TT; #);
                  4 -> cd.pushConst;
                  4 -> cd.pushConst;
              if);
              (* rstack = [..., obj,callee], store obj in callee.origin *)
              (* mainOG.OGidWdNO is the type callee
               * if vStub, then the type may be the vStub type 
               * We should check for this and bitcast
               *)
              (if emitLLVM then
                  mainOG.OGidWdNo -> cd.fixTypeOfBinding
              if);
              (mainOG.OGidWdNo,thisOG.IS.newOriginOff
              ,thisOG.origin[] -> thisOG.IS.originisValue
              ) -> cd.rstoreX;
              (* rstack = [..., callee]; ... *)
           else
              cd.lcom(#do 'no:origin:newOriginOff=0' -> TT #)
          if);
          (if thisOG.super.ATd[] <> none then
              thisOG.IS[] -> ISx[];
              cd.stack.put;
              cd.rswap;
              thisOG.super[] -> goOriginAdr -> E[];
              cd.stack.put;
              (if E[] <> none then 
                  (if cd.thisClassDescNo = thisOG.IS.newDescNo then
                      (thisOG.IS.newOriginOff,0) -> E.loadArgs;
                   else
                      (0,0) -> E.loadArgs;
                  if);
                  (if not fromVDTalloc 
                      and (E.args[] <> none) and (E.args.noOfSons > 0) then
                      (E.Atd.asDecl).OG.IS.scanNonBoundItemArgs
                      (#
                      do (if currentArg.isDataItem then
                             cd.lcom(#do currentArg.dopt -> TT #);
                             currentArg[] -> fArgs[top + 1 -> top][]
                         if)
                      #);
                      (for i: top repeat
                           fArgs[top - i + 1][] -> DI[];
                           fcTracer(#do 'kuk:storeArgs:'-> TT;DI.sig.dopt->TQ #);
                           cd.rswap;
                           cd.rdouble;
                           (if DI.isBasicValue then
                               (if nameListInDcl then
                                   (DI.sig[],mainOG[]) -> storeDecls
                                else
                                   (mainOG.OGidWdNo,DI.newOff) -> cd.storeg
                               if)
                            else
                               (mainOG.OGidWdNo,DI.newOff) -> cd.rstoreg
                           if);
                           cd.rswap
                  for)if)
               else
                 (* '**** E is none:main:\n' -> Puttext; 
                  main.dopt -> puthead;
                  ' this: ' -> puttext; thisOg.doPT -> putline*)
              if);
              (mainOG[],thisOG.super.ATd.OG[],fromVDTalloc) -> storeOrigins;
           else
              (if trace then newline if)
          if);
       #);
     storeArgs:
       (# T: ^text; theOG: ^ objectGenerator
       enter (T[],theOG[])
       do (if theOG.super.ATd[] <> none then
              (T[],(theOG.super.ATd.asDecl).OG[]) -> storeArgs
          if);
          cTracer(#do 'storeArgs:' -> TT; theOG.OGid -> TQ #);
          theOG.IS.scanItemArgsReverse
          (# DI: ^DataItem
          do (if (currentArg[]->DI[]).isBasicValue then
                 (T[],DI.newOff) -> cd.storeX
              else
                 (T[],DI.newOff,false) -> cd.rstoreX
          if)#)              
       #);
     callInvoke:
       (# theOG: ^ObjectGenerator; staticOff: @integer; fromStub: @boolean;
          T: ^text; rtnOff: @integer
       enter(theOG[],staticOff,fromStub)
       do (theOG.OGid,theOG.IS.newDescNo,theOG.IS.objSize,staticOff,theOG.isObj)
            -> cd.invoke
          (# topSuperId::
               (# superDesc: ^Items
               do (theOG.IS.topSuper->superDesc[]).encOG.OGidWdNo -> superId[];
                  superDesc.newDescNo -> superDescNo
               #);
             fArgs: [10] ^DataItem;  top: @integer; DI: ^DataItem
          do (* vStack = [..., possible V-args
              * rStack = [..., possible origin, possible R-args, callee
              *)
             theOG.OGidWdNo -> T[]; 
             (*'$' -> T.put; IS.newDescNo -> T.putint;*)
             (if false then
                 (T[],theOG[]) -> storeArgs
              else
                 cTracer(#do 'callInvoke:store:args'->TT #);
                 theOG.IS.scanNonBoundItemArgs
                 (# 
                 do currentArg[] -> fArgs[top + 1 -> top][];
                    cTracer(#do 'arg:' -> TT; currentArg.dopt -> TT #)
                 #);
                 (for i:top repeat
                      fArgs[top - i + 1][] -> DI[];   
                      (if DI.isBasicValue then
                          (T[],DI.newOff) -> cd.storeX
                       else
                          (T[],DI.newOff,false) -> cd.rstoreX
             if)for)if);
             cTracer(#do 'after:store:args:top:'-> TT; top->II  #);
             (* vStack = [...]
              * rStack = [..., possible origin, callee]
              *)
             (if not newFeature then
                 (theOG[],theOG[],false) -> storeOrigins;
             if);
          #);
          (if not fromStub then 
              (theOG[],T[]) -> pushOut -> rtnOff;
              fcTracer(#do 'callInvoke:after:pushOut:'->TT; rtnOff->II #);
          if)
       exit rtnOff
       #);
     ObjectGenerator::
       (# 
          actionPos::
            (#
            do '**** OG:actionPos: '->puttext; 
               IS.beginPos->putint;
               newline
            #);
          classDef::
            (# org:^Items; orgId: ^text; orgDescNo: @integer
            do (if marked then
                   (if (not IS.isEmpty or hasVirtualArgs)
                       and (IS.newDescNo > 0) then
                       (if (origin[] -> org[]) <> none then
                           org.encOG.OGid -> orgID[];
                           org.newDescNo -> orgDescNo;
                           (if IS.newOriginOff = 0 then
                               none -> orgID[];
                               0 -> orgDescNo
                           if)
                        else
                           'Object' -> orgId[];
                           objectDecl.OG.OGid ->orgId[];
                           objectDecl.OG.IS.newDescNo -> orgDescNo;
                       if);                           
                       (OGid,IS.newDescNo,isValueObj,orgID[],orgDescNo)
                         -> cd.classDef
                       (#
                       do mkLLVMstruc
                          (# addRX:: 
                               (#
                               do (if false then
                                      '**** addRX:addR:'->puttext; off->putint;
                                      ' ' -> put; OGid[] -> putline;
                                  if);
                                  (off,OGid[]) -> addR 
                               #);
                             addVX:: (#do off -> addV #);
                             addAX:: (#do off -> addA #);
               #)#)if)if)
            #);
          gen::
            (* gen is only called for singular Objects and pushed on stack
             * For patterns OG is pushed on stack and genClass called later
             *)
            (# gdb::
                 (#
                 do '>OGid:' -> TT; OGid -> TQ;
                    (if IS.isEmpty then 
                        ' IS.isempty!' -> TT 
                     else
                        ' singular!' -> TT
                    if);
                    ' staticOff='-> TT; staticOff -> II;
                    ' descNo=' -> TT; IS.newDescno->II;
                    ' superAdj=' -> TT; superAdj -> II
                 #);
               printQoff:
                 (#
                 do (if trace then
                        IS.scanSons
                        (# I: ^Item; D: ^Decl
                        do  current[] -> I[];
                           (if I.isDecl then 
                               I[] -> D[];
                               D.qoff[1] -> putint; ' ' -> put; 
                               D.doPT -> putline
                    if)#)if)
                 #);
               name: ^text; head: @boolean;
               on,pn: @integer;
               E: ^Exp; OI: ^ObjectInvocation;
               mp:  ^Module; rtnOff,vOff: @integer;
               trace: (# exit false #);
            do (if not genIsDone or true then
                   cTracer(#do 'OG:gen:'->TT; dopt -> TL #);
                   true -> genIsDone;
                   super.last -> E[];   
                   (if ('???' -> (E.label).equal) and IS.isEmpty then
                       '!!!! OG:gen: is empty ' -> putline;
                       doPP -> putline;
                       leave gen
                   if);
                   (* we have non-singular: foo or singular: foo{...} *)
                   
                   cd.bcPos -> beginBCP;
                   (if IS.isEmpty 
                       and not super.hasVirtualArgs 
                       or (super.isPrimitive and IS.isEmpty) then
                       (* Implies that super.OG is pushed on objTmpStack *)
                       (if ((super.last).ATd[] <> none) 
                           and not ((super.last).ATd.asDecl).isPattern then
                           (* does not completely understand 
                            * what goes on here
                            * For INV = L2, we have to assign 
                            * For inv := L1 * L2, we cannot!
                            *)
                           isCompositeValueObj 
                             -> (super.last).isCompositeValueObj;
                       if);
                       fcTracer(#do 'OG:before:super.gen:'->TT;super.dopt->TQ#);
                       (useRtnVal,superAdj,staticOff) 
                         -> super.gen
                         -> (mp[],valueOff);
                    else
                       (* Perhaps move check for virtuals to here!? *)
                       (* Singular object like R.foo{ }
                        * includes pattern invocations with 
                        * virtual arguments like %if .. %then% ... %else ...
                        *)
                       (if not IS.globalRestrictionsInMain then
                           cd.pushThis; (* origin for a singular object *)
                           (* This is also the case for R.S.foo{ ... } *)
                       if);
                       (* Invoke the singular object *)
                       fcTracer(#do 'before objTmpStack:add: '->TT;
                                IS.newDescNo -> II; ' ' -> TT; OGid ->TQ #);
                       (this(ObjectGenerator)[],staticOff,false) 
                         -> callInvoke
                         -> rtnOff;
                       (if true then
                           rtnOff -> valueOff
                       if);
                       L:
                         (if not useRtnVal then 
                             IS.scanAllItemDecls
                             (# DI: ^DataItem
                             do (if currentDcl.isOutArg then
                                    currentDcl[] -> DI[]; 
                                    DI.popReturn;
                                    leave L
                             if)#);
                             cd.rPop 
                   if)if);
                   fcTracer
                   (#do 'OG:gen:end:valueOff'->TT; valueOff->II #);
                   cd.bcPos -> endBCP;     
               if)
            #);
          newStub::
            (# OGxx: ^ObjectGenerator; errs: ^Stream; dNo: @integer
            do '{}' -> parseObjectGeneratorText -> (errs[],OGxx[]);
               OGxx[] -> QnewDesc -> dNo -> OGxx.IS.QdescNo[1];
                           
               (*dNo -> stubDescNo;*)
            #);
          mkVirtualBinding::
            (* make this(OG) a binding of the virtual ptn in encIS
             * with offSet = off
             *)
            (# dNoZero:
                 (# P: ^Pattern; T: ^text; errs: ^Stream; OGs: ^ObjectGenerator;
                 do(* This is a hack - Qalloc is not always called
                    * Perhaps we need to call Qalloc on all 
                    * OGs being included!?
                    *)
                    '**** mkVirtualBinding:dNoZero: ' -> puttext; 
                    sig.dopt -> putline;
                    father.dopt -> putline; '---' ->putline;
                    father.father.dopt -> putline;
                    
                    '' -> T[];
                    sig.dopt -> T.append;
                    ': { %id stub }' 
                      -> T.append
                      -> parseDeclText -> (errs[],P[]);
                    P.OG[] -> OGs[]; 
                    P.setUpOrigin;
                    P.check;
                    OGs[] -> QnewDesc -> dNo -> OGs.IS.QdescNo[1];
                    (if vDescNo > 0 then
                        '!!!! OG.vDescNo > 0 :' -> puttext;
                        vDescNo -> putint; ' ' -> put;
                        dNo -> putint; newline
                     else
                        dNo  -> vDescNo;
                    if);
                    (*'$' -> OGs.sig.type.id.put;
                    do -> OGs.sig.type.id.putint;*)
                    (if false then
                        '**   dNo: ' -> puttext; dNo -> putint;
                        ' vDescNo: ' -> puttext; 
                        vDescNo -> putint;
                        newline;
                        P.doPt -> putline;
                    if)
                 #);
               dNo: @integer; 
               stubN,stubS: ^text; errs: ^Stream; OGxx: ^ObjectGenerator
               (*encIS: ^Items; off: @integer
            enter(false[],off)*)
            do (if false then
                   '**** mkVirtualBinding: "' -> puttext; OGID -> puttext;
                   '" off: ' -> puttext; off -> putint;
                   '  vDescNo:'->dumpT; vDescNo->dumpI;
                   label -> dumpT; father.label -> dumpT; 
                   father.father.label -> dumpT;
                   ' in: ' -> putline;
                   encIS.dopt -> putHead;
               if);
               (if virtualDone then
                   '**** mkVirtualBinding:virtualDone:' -> putline;
                   leave mkVirtualBinding
               if);
               true -> virtualDone;
               L:
               (if not hasItems then 
                   (* not hasItems ==> nonSingularBinding
                    * Like fool(#Ko), elm::< Record, etc. *)
                   (if encIS.hasGlobals then
                       (if false then
                           '**** hasGlobals:A: ' -> puttext;  
                           ' vDescNo: ' -> puttext;
                           vDescNo -> putint; newline;
                           doPT -> putHeadN;
                           encIS.dopt -> putHeadN; 
                       if);
                       leave L
                   if);
                   vDescNo -> dNo;
                   (if dNo = 0 then (* never happens? *) dNoZero if);
                   (sig[],this(ObjectGenerator)[]) 
                     -> mkStubName -> (stubN[],stubS[]);
                   (if false then
                       '**   vdt:addTo: ' -> puttext; 
                       cd.descs.current.descInx -> putint;
                       ' ' -> puttext; stubN[] -> puttext; ' '-> put;
                       dNo -> putint; newline;
                   if);
                   (off,dNo,false,stubS[]) -> cd.vdtTable;
                   (if false then
                       '**** Vstub:add: ' -> puttext; OGidWdNo -> puttext;
                       ' vDescNo: ' -> puttext; vDescNo -> putint;
                       ' dNo:' -> puttext; dNo -> putint;
                       ' orgOff:' ->  puttext; IS.newOriginOff ->putint; 
                       newline; father.doPT -> putline;
                   if);
                   (stubN[],dNo,this(ObjectGenerator)[],encIS[]) 
                     -> ObjStubStackX.add;
                else
                   (if false then
                       '**   hasItems:off: ' -> puttext; off -> putint; 
                       ' IS.newDescNo: ' -> puttext;
                       IS.newDescNo -> putint; newline;
                   if);
                   (off,IS.newDescNo,false,OGid(*sig.dopt*)) -> cd.vdtTable
               if);
            #);
          virtualDone: @Boolean;
          pushReturnValues:
            (# ptn: ^Pattern; DI: ^DataItem
            do (if ((father[]->ptn[]).getReturnDecl -> DI[]) <> none then
                   fcTracer
                   (#do
                       'OG:pushReturnValues:Off:' -> TT;
                       DI.newOff -> II; DI.doPT -> TT;
                   #);
                   (if not isValueObj then
                       cd.setThisStack
                   if);                   
                   (if DI.OG.isValueObj 
                       and not (DI.OG.primNo = integer_prim) 
                       and not (DI.OG.primNo = boolean_prim) 
                       and not (DI.OG.primNo = char_prim) 
                       and not (DI.OG.primNo = float_prim) 
                      (* and not DI.OG.isUnitValueObj*)
                       then
                       cd.pushThis;
                       fcTracer(#do 'pushReturn:valOff:descNo:'->TT #);
                       (if not withValueProxy then
                           DI.newOff -> cd.pushConst;
                           DI.OG.IS.newDescNo -> cd.pushConst
                       if)
                    else
                       cd.pushThis;
                       Di.newInvoke (*DI.invoke*)
                   if)
                else 
                   (if isValueObj then
                    else
                       cd.setThisStack;
                       cd.pushThis
               if)if)
            #);         
          genClass::
            (#
            do (if hasVirtualObject then
                   (if traceGeneric3 then
                       '***** HasVirtualObject: ' -> putline; 
                       (if sig[] <> none then 
                           sig.doPT -> putline;
                        else
                           doPT -> putline;
                           display
               if)if)if);
               (* Move IS.genclass to here? *)
               (if false and (primNo > 0) then
                   '****genclass: isPrimitive: ' -> puttext;
                   OGid -> putline
               else
                   this(ObjectGenerator) -> IS.genClass
               if)
            #);
          
          mkLLVMstruc:
            (# emitLLVMdataItems:
                 (# OGx: ^ObjectGenerator; off: @integer
                 enter(OGx[],off)
                 do (if false then
                        '**** mkLLVMstruc:emitLLVMdataItems:' -> puttext;
                        OGx.OGid -> putline;
                    if);
                    (if (OGx.super.ATd[] <> none) then
                        (*'**   go:super:'->putline;*)
                        ((OGx.super.ATd.asDecl).OG[],off) -> emitLLVMdataItems;
                        (*'**   end:super:'->putline;*)
                    if);
                    OGx.IS.scanSons
                    (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
                    do (if current.isDataItem then
                           current[] -> DI[];
                           cTracer(#do DI.sig.dopt -> TT;
                                    ' Basic:' -> TT; DI.OG.isBasicValue->BB;
                                    ' val: ' -> TT; DI.isValue -> BB;
                                    ' valObj:' -> TT; DI.OG.isValueObj ->BB;
                                    ' Inx:' -> TT; DI.OG.IS.isIndexed -> BB;
                                 #);
                           (if false then
                               '**   :emb: ' -> puttext; DI.sig.dopt -> puttext;
                               ' ' -> put; DI.newoff -> putint;
                               ' ' -> put; off -> putint; newline;
                           if);
                           (if true
                            // DI.OG.IS.isIndexed then
                               DI.newOff + off -> addAX
                            // DI.OG.isBasicValue then 
                               DI.newOff + off-> addVX
                            // DI.isValue then
                               (DI.OG[],DI.newOff - 1) -> emitLLVMdataItems
                            else
                               (DI.newOff  + off,DI.OG.OGidWdNo) -> addRX
                           if)
                       if)
                    #);
                    (if false then
                        '**   mkLLVMstruc:emitLLVMdataItems:end:'->putline
                    if)
                 #);
               addRX:<
                 (# msg:
                      (#
                      do '**** addRXw: ' -> puttext; off -> putint;
                         ' ' -> put; OGid[] -> putline;
                      #);
                    off: @integer; OGid: ^text
                 enter(off,OGid[])
                 do (*msg;*)
                    (if (offTop < off) then 
                        inner;
                        off -> offTop;
                     else
                        (* This happen when origin has been added in a super *)
                        (if false then
                            msg;
                            '!!! offTop >= off ' -> puttext;
                            offTop -> putint; ' ' -> put; off -> putint;
                            newline;
                    if)if)
                 #);
               addVX:<
                 (# off: @integer
                 enter off
                 do (*'**** addVX: ' -> puttext; off -> putint; newline;*)
                    inner;
                    off -> offTop
                 #);
               addAX:<
                 (# off: @integer
                 enter off
                 do (*'**** addAX: ' -> puttext; off -> putint; newline;*)
                    inner;
                    off -> offTop
                 #);                 
               offTop: @integer; org: ^Items; 
               withDN:
                 (# T: ^text; dn: @integer
                 enter(T[],dn)
                 do '$' -> T.put; dn -> T.putint;
                 exit T[]
                 #);
               dn: @integer
            do (if false then
                   '**** mkLLVMstruc: ' -> puttext; dopt -> puthead;
                   cd.typeInfo.print;
               if);
               (* Clean-up needed here
                * Must be recursive in super as is emitLLVMdataItems
                * Must handle more than one origin
                * Must skip origin for value objects
                *)
               (if (IS.superDesc[] <> none) 
                   and (IS.superDesc[] <> objectDecl.desc) then
                   (if false then
                       '**   super: ' -> puttext; 
                       IS.superDesc.encOG.OGid -> puttext; ' ' -> put;
                       IS.superDesc.newOriginOff -> putint; ' ' -> put;
                       IS.superDesc.sig.dopt -> puthead;
                   if);
                   &IS.superDesc.encOG.mkLLVMstruc
                   (# addRX::
                        (#
                        do (off,OGid[]) -> this(mkLLVMstruc).addRX
                        #);
                      addVX::
                        (#
                        do off -> this(mkLLVMstruc).addVX
                        #);
                      addAX::
                        (#
                        do off -> this(mkLLVMstruc).addAX
                        #)
                   #);
               if);
               (if IS.newOriginOff <> 0 then 
                   (* some objects have no origin *)
                   origin[] -> org[];
                   (if org[] <> none then
                       (if false then
                           '**** origin: '->puttext;
                           org.encOG.OGidWdNo -> puttext; ' ' -> put;
                           IS.newOriginOff -> putint;
                           newline;
                       if);
                       (IS.newOriginOff,org.encOG.OGidWdNo) -> addRX;
                       (if (origin[] -> IS.originIsValue) then
                           IS.newOriginOff + 1 -> addVX;
                           IS.newOriginOff + 2 -> addVX;
                       if)
                    else
                       (IS.newOriginOff,objectDecl.OG.OGidWdNo) -> addRX;
               if)if);
               (if sig[] <> none then
                   sig.scanSons
                   (# DI: ^DataItem;
                   do (if current.isDataItem then
                          current[] -> DI[];
                          (if true
                           // DI.OG.isBasicValue (* isBasicPattern? *) then 
                              DI.newOff -> addVX
                           else
                              '**** signature:DI:not catched!' -> putline
                      if)if)
                   #);
               if);
               IS.scanSons
               (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
               do (if current.isDataItem then
                      current[] -> DI[];
                      cTracer(#do DI.sig.dopt -> TT;
                               ' basic: ' -> TT; DI.OG.isBasicValue -> BB;
                               ' val: ' -> TT; DI.isValue -> BB;
                               ' valObj: ' -> TT; DI.OG.isValueObj -> BB;
                               ' Inx:' -> TT; DI.OG.IS.isIndexed -> BB; print
                            #);
                      (if true
                       // DI.OG.IS.isPureIndexed then
                          DI.newOff -> addAX
                       // DI.OG.isBasicValue (* isBasicPattern? *) then 
                          DI.newOff -> addVX
                       // DI.isValue then
                          (*'*** embed value:' -> puttext; 
                          DI.sig.dopt -> putline;*)
                          (DI.OG[],DI.newOff - 1) -> emitLLVMdataItems;
                       else
                          (if false then
                              '**** addRXq: ' -> puttext; DI.newOff -> putint;
                              ' ' -> put; DI.sig.dopt -> putline;
                          if);
                          (DI.newOff,DI.OG.OGidWdNo) -> addRX
                      if);
                   else 
                      (if current## 
                       // Module## then
                          current[] -> M[]; 
                          (if true then
                              'Module: '->puttext; moduleName -> puttext; 
                              ' ' -> put; M.newOff -> putint; newline;
                          if);
                          (M.newOff,M.OG.OGidWdNo(*moduleName*)) -> addRX
                       // ModuleItem## then
                          current[] -> MI[];
                          (if MI.MD.off > 0 then
                              (If false then
                                  'MI:'->puttext; 
                                  MI.MD. moduleName->puttext;
                                  ' ' -> put; 
                                  MI.MD.OG.OGidWdNo -> puttext;
                                  ' ' -> put;
                                  MI.MD.newOff -> putint;
                                  (*MI.MD.OG.IS.qDescNo[1] -> putint;*)
                                  newline;
                              if);
                              (MI.MD.newOff,MI.MD.OG.OGidWdNo(*moduleName*)) 
                                -> addRX
                  if)if)if)
               #);
               (if false then
                   cd.typeInfo.print;
                   '**** mkLLVMstruc:end: ' -> puttext; dopt -> puthead;
               if)
            #);
          computeGCinfo:
            (# 
            do (*'****compouteGCinfo: '->putline; dopt -> puthead;*)
               cd.addGCinfo
               (# rtnDI: ^DataItem
               do (if IS.newOriginOff <> 0 then (* some objects have no origin*)
                      IS.newOriginOff -> add;
                  if);
                  (* Code for checking refs in Signature has been removed *)
                  (if (IS.superDesc[] <> none) 
                      and (IS.superDesc[] <> objectDecl.desc) then
                      (*'\nsuper: ' ->puttext; IS.superDesc.sig.dopt->puthead;*)
                      (*(IS.superDesc.theObjectGenerator).computeGCinfo*)
                      IS.superDesc.encOG.computeGCinfo
                  if);
                  IS.scanSons
                  (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem;
                     doAdd:
                       (# D: ^Decl
                       enter D[]
                       do (if nameListInDcL then
                              D.sig.names.scan
                              (#
                              do (if false then
                                     D.sig.dopt -> puttext; ':'->put;
                                     current.off->putint; newline;
                                     current.off -> add (* OBS! after if! *)
                                 if)
                              #)
                           else
                              D.newOff -> add
                          if)
                       #)
                  do (if current.isDataItem then
                         current[] -> DI[];
                         (if DI.OG.isBasicValue or DI.isValue then
                          else
                             (*DI.sig.dopt->puttext; ':'->put; 
                              * DI.newOff->putint;newline;*)
                             DI[] -> doAdd
                         if);
                      else 
                         (if current## 
                          // Module## then
                             current[] -> M[]; 
                             (*'Module: '->puttext; moduleName -> puttext;
                              * ' ' -> put; M.newOff -> putint; newline;*)
                             M[] -> doAdd
                          // ModuleItem## then
                             current[] -> MI[];
                             (if MI.MD.off > 0 then
                                 (*'MI:'->puttext; MI.MD. moduleName->puttext;
                                  * ' ' -> put; MI.MD.newOff->putint; newline;*)
                                 MI.MD[] -> doAdd
                     if)if)if)
                  #);
                  (*newline*)
               #);
            #);
          clear::< (# do false -> marked -> virtualDone; inner #);
       #);
     inValueObj: @boolean; (* true if generating code for a value object *)
     items::
       (# actPos: @integer;
          actionBCPos::
            (#
            do (if false then
                   '**** IS:actionPos: '->puttext; 
                   actPos->putint; ' '-> put; newDescNo -> putint;
                   newline;
               if);
               actPos -> BC;
               newDescNo -> dNo
            #);
          isIndexed: booleanValue
            (#                               
            do (if primNo // String_prim // indexed_prim // rIndexed_prim then
                   true -> value
                else
                   (if superDesc[] <> none then
                       superDesc.isIndexed -> value
               if)if)
            #); 
          isPureIndexed: booleanValue
            (#                               
            do (if primNo // indexed_prim // rIndexed_prim then
                   true -> value
                else
                   (if superDesc[] <> none then
                       superDesc.isPureIndexed -> value
               if)if)
            #);
          codeGenDone: @boolean;
          genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; 
               super: ^Invocation;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
               OG: ^ObjectGenerator;
               genSuperClass:
                 (#
                 do (if (superDesc[] <> none) then
                        superDesc.father.father -> ptn[]; 
                        encOG[] ->  superDesc.genClass;
                    if)
                 #);
               mkClassDef:
                 (# org: ^items; originDescNo: @integer; orgId: ^text
                 do (if (origin[] -> org[]) <> none then
                        org.encOG.OGid -> orgID[];
                        org.newDescNo -> originDescNo;
                     else
                        objectDecl.OG.OGid ->orgId[];
                        objectDecl.OG.IS.newDescNo -> originDescNo;
                    if);
                    (N[],newDescNo,false,(topSuper).newDescNo
                    ,newOriginOff,orgId[],originDescNo,encOG.isValueObj,false)
                      -> cd.class;
                    (* Copy vdt and literals; this must be done after
                     * cd.class is executed, sine eval of arguments in super
                     * may conatin strings being added to Literals
                     *)
                    (if this(Items)[] -> hasRealSuper then
                        superDesc.newDescNo -> cd.vdtTableCopy;
                        (if superDesc.innerInx > 0 then
                            (superDesc.innerInx,newDescno,true,'innerS') 
                              -> cd.vdtTable
                    if)if)
                 #);
               handleArgumentsAndOrigin:
                 (* mainIS was introduced in order to handle virtual
                  * valueObjs as in eq (=) for Cvalue, but does not work;
                  * we dont know the size of in V: var thisValue
                  *)
                 (# mainIS,theIS: ^Items; vArgsInSuper: @integer
                 enter(mainIS[],theIS[])
                 do (mainIS[],theIS[]) -> storeArguments -> vArgsInSuper;
                    (mainIS[],theIS[]) -> StoreOrigin;
                    (theIS[],vArgsInSuper) -> AllocateSuper;
                    (if theIS[] -> hasRealSuper then
                        cTracer(#do 'hArgOrg:super:' -> TT; 
                                 theIS.superDesc.encOG.OGid -> TT
                              #);
                        (mainIS[],theIS.superDesc[]) -> handleArgumentsAndOrigin
                    if)
                 #);               
               StoreArguments:
                 (# mainIS,theIS: ^Items; N: @integer; org: ^Items;
                    emit:
                      (#
                      do '**** StoreArguments:origin:isValueObj:'->puttext;
                         theIS.encOg.dopt -> putheadn;
                      #);
                    isVeq: @boolean
                 enter(mainIS[],theIS[])
                 do (if not emitLLVM then
                        cTracer(#do 'Store itemArgs:' -> TT; dopt->TL #);
                        (* Should this be scanNonBoundItemArgs?
                         ' No! Only onbound args in theIS, since we 
                         * visit IS of all superpatterns
                         *)
                        (if primNo
                         // vEq_prim // vLE_prim then true -> isVeq
                            (*'**** vEq: '->puttext; theIS.dopt -> putheadN;*)
                        if);
                        (*'**** theIS:'->puttext; theIS.dopt->putheadn;
                         * '**   args:'->putline;
                         *)
                        theIS.scanItemArgsReverse
                        (# qual: ^ObjectGenerator; OGSx: ^OGsequence;
                           isString: @boolean
                        do cTracer(#do currentArg.dopt -> TT;
                                     currentArg.OG.primNo -> II
                                  #);
                           false -> isString;
                           (if ((currentArg.OG.primNo = this_prim) or
                               (currentArg.OG.primNo = string_prim))
                               then
                               (mainIS.encOG[],false
                               ,(mainIS.encOG[],false,none)->OGsequence)
                                 -> currentArg. getVqual
                                 -> (OGSx[],qual[]);
                               qual.primNo = String_prim -> isString
                           if);
                           (if false and isVeq then 
                               currentArg.dopt->putline; 
                               cTracer(#do 'vEq:store:'->TT; 
                                        currentArg.dopt -> TQ #)
                           if);
                           (if isString then
                               (* we may have a ref arg on the stack
                                * - so use shiftUp
                                *)
                               (*cd.rswap;*)
                               cd.pushThis; (* we store this 
                                             * should be ref on stack
                                             *)
                               (currentArg.sig.dopt,currentArg.newOff)
                               -> cd.rstoreg
                            else
                               (true,mainIS[]) -> currentArg.store
                           if)
                        #);
                        (if (theIS.origin[]<>none)
                            and (theIS.origin->org[]).encOG.isValueObj then
                            true -> theIS.scanNonBoundItemArgs
                            (# DI: ^DataItem
                            do (if false and currentArg.isDataItem then
                                   (if false and (N = 0) then emit if);
                                   currentArg[]  -> DI[];
                                   (if true 
                                    // DI.OG.isBasicValue then
                                       N + 1 -> N;
                                    // DI.OG.isValueObj then
                                       N +  DI.OG.objSize + 1 -> N
                                    else
                                       '???' ->putline
                                   if);
                                   (if false then
                                       '**   objSize: ' -> puttext;
                                       DI.OG.objSize -> putint;
                                       ' basicValue: ' -> puttext;
                                       DI.OG.isBasicValue -> putboolean;
                                       ' valueObj: '-> puttext;
                                       DI.OG.isValueObj -> putboolean;
                                       ' ' -> put;
                                       currentArg.dopt -> putline;
                                   if);
                                   (# out: ^text; E: ^Invocation;
                                      OGs: ^OGsequence; qual: ^ObjectGenerator
                                   do DI.sig.dopt -> parseInv->(out[],E[]);
                                      theIS[] -> E.father[];
                                      theIS[] -> E.setUpOrigin;
                                      (none,theIS[],theIs[],true) -> E.check;
                                      (theIS.encOG,true
                                      ,(theIS.encOG,false,none) ->OGsequence)
                                        -> E.getVqual
                                        -> (OGs[],qual[]);
                                      (if false then
                                          E.dopt->putline;
                                          qual.doPT -> puthead;
                                          qual.objSize -> putint; 
                                          ' valueObj: ' -> puttext;
                                          qual.isValueObj -> putboolean;
                                          newline;
                                      if);
                                      qual.objSize -> N;
                                      (if qual.isValueObj then N + 1 -> N  if)
                                   #);
                               if)
                            #);
                            (if N > 0 then
                                (*N -> putint; newline; *)
                                N + 1 -> cd.vShiftUp;
                                N + 1 -> cd.vShiftUp;
                    if)if)if)
                 exit N
                 #);
               StoreOrigin:
                 (# mainIS,theIS: ^Items; org: ^Items
                 enter(mainIS[],theIS[])
                 do (if theIS.globalRestrictionsInMain then
                        (if traceNoGlobals then
                            cTracer(#do 'NoNlobals,noOrigin'->TT;theIS.dopt->TT#)
                        if)
                     else
                        cTracer(#do 'Store:Origin:'->TT;
                                 (if (mainIS.origin[]->org[]) <> none then
                                 org.primNo->II if)#);
                        (if ((theIS.noOfRefArgsInSuper -> rArgsInSuper) > 0)
                            (*or 
                            ((mainIS.origin[]->org[]) <> none)
                            and (org.primNo = String_prim)*)
                            then
                            (* if super has ref args, 
                             * then these are on the stack above origin
                             * Here S = origin and x,y,z are 3 ref args
                             * rShift moves S to top of rStack
                             * ------------      ------------
                             * |...|S|x|y|z  ==> |...|x|y|z|S
                             * ------------      ------------
                             *)                           
                            rArgsInSuper -> cd.rShiftUp
                        if);
                        cd.tstOriginIsNone;
                        ('origin',theIS.newOriginOff) -> cd.rstore;
                        (if false and (theIS.newDescNo = 78) then
                            '**** StoreOrigin:before:originISValue:'->putline;
                            dopt -> puthead
                        if);
                        (if not withValueProxy and
                            (theIS.origin[] -> originIsValue)
                            and (mainIS.origin[] -> originIsvalue) then
                            ('origin.valueOff',theIS.NewOriginOff + 2) 
                              -> cd.store;
                            ('origin.valueOff',theIS.NewOriginOff + 1) 
                              -> cd.store;
                   if)if)
                 #);
               prepareSuper:
                 (*************** only for main.super: factor out *)
                 (#
                 do (ptn.sig.id[],superDesc.newDescNo) -> cd.super;
                 #);
               addOG:
                 (# OGx: ^ObjectSpecification; off: @integer
                 do (if OG.isArgofE[] <> none then
                        cTracer(#do 'addOG:'->TT #);
                        (if traceArgOG then
                            '**** OG inArgument: ' -> putline;
                            OG.dopt -> puthead;
                            '**   OG.isArgOfE:\n' -> puttext;
                            OG.isArgOfE.dopt -> putline;
                        if);
                        (if OG.isArgOfE.father.father##
                            = BracketedExp## then
                            OG.isArgOfE.father.father.father[]
                              -> OGx[];
                         else
                            OG.isArgOfE.father.father[] -> OGx[];
                        if);
                        OGx.IS.newOriginOff -> off;
                        (* We do get ObjectCall and off = 0 below!
                         * OG.isArgOfE.enclosingObjectGenerator and 
                         * OG.isArgOfE.origin.father[] do not work, 
                         * since they return the OG enclosing OGx.
                         * Must be understood!?
                         *)
                        (if (OGx## = ObjectCall##)
                            or (off = 0)  then
                            '**** OG in:argument: ' -> puttext;
                            OGx.label -> puttext; ' ' -> put;
                            off -> putint; newline;
                            OGx.dopt -> putheadN
                        if);
                        (if traceArgOG then
                            OGx.dopt -> puthead;
                            '**   originOff:'->puttext; 
                            off->putint; newline;
                        if);
                        (if (off > 0) then
                            (if nameListInDcl then
                                ('ArgOGs',(sig.names.firstDecl).off) 
                                  -> cd.rpushg;
                             else
                                ('ArgOGs',off) -> cd.rpushg;
                    if)if)if)
                 #);               
               AllocateSuper: 
                 (# pushAddress:
                      (* super is searched in the origin of 
                       * this(OG); we must then have an 
                       * additional goOrigin from this(OG);
                       * this is handled by passing newOriginOff
                       * as an argument of Address - superAdj;
                       * adjustOrigin will generate this goOrigin
                       * if superAdj > 0
                       *)
                      (# super: ^Invocation; E,rec: ^Exp; A: ^Address;
                         valueOff: @integer; isNotRemote: @Boolean
                      enter super[]
                      do (if globalRestrictionsInSuper then
                             super.last -> E[]
                          else
                             fcTracer
                             (#do 'genClass:before:super.handleInv:'-> TT; 
                                super.doPT -> TL; #);
                             (false,theIS.newOriginOff,0,false) 
                               -> super.handleInv 
                               -> (E[],valueOff,isNotRemote);
                             valueOff -> (&Address[] -> A[]).off;
                             fcTracer
                             (#do 'genClass:after:super.handleInv:'-> TT; 
                                super.doPT->TL; 'E:'->TT; E.dopt->TL #)
                         if)
                      exit E[]
                      #);
                    handleSuperArgs:
                      (# theIS: ^Items; E: ^Exp
                      enter(theIS[],E[])
                      do cTracer(#do 'handleSuperArgs:E:'->TT; E.dopt->TQ;
                                  'theIS:'->TT; theIS.dopt->TL #);
                         (* What does sig[] = none imply? 
                          * and does it make a difference if
                          * +/- theIS.newOriginOff is used?
                          *)
                         (if theIS.sig[] = none then
                             cTracer(#do'super.sig:none:superAdj:'-> TT;
                                      newOriginOff -> II #);
                             (theIS.newOriginOff,0) -> E.loadArgs; 
                          else
                             cTracer(#do'super.sig:not:none:superAdj:'->TT;
                                      - newOriginOff -> II #);
                             (* go ON-1, use newOriginOff first time *)
                             (- theIS.newOriginOff,0) -> E.loadArgs;
                         if);
                         (******* handle virtual args of super ***)
                         E.handleVargs;
                      #);
                    theIS: ^Items; E: ^Exp; vArgsInSuper,off: @integer; 
                 enter(theIS[],vArgsInSuper)
                 do (if not theIS.encOG.isValueObj then 
                        (if not ((theIS.superDesc[] <> none) 
                            and not theIS.superDesc.isPrimitive) then
                            theIS.encOG.isObj -> cd.allocEventQ
                    if)if);
                    (if theIS[] -> hasRealSuper then
                        prepareSuper;
                        cTracer(#do 'push:super.origin:'->TT #);
                        (********* push super.origin *)
                        (if theIS.super.isImplSuper then
                            (if not theIS.globalRestrictionsInsuper then
                                (if theIS.super.isSingularImplSuper then
                                    cTracer(#do'isSingularImplSuper:'->TT#);
                                    cd.pushThis;
                                    ('iOrigin',theIS.newOriginOff) -> cd.rpushg;
                                    (if not withValueProxy and
                                        (theIS.origin[] -> originIsValue) then
                                        cd.pushThis;
                                        (T[],theIS.newOriginOff + 1) 
                                          -> cd.pushg;
                                        cd.pushThis;
                                        (T[],theIS.newOriginOff + 2)
                                          -> cd.pushg;
                                    if);
                                    (* For implicit super we may have
                                     * snorf::< {...}
                                     * we thus create an empty Exp
                                     *)
                                    Exp -> E[] 
                                 else
                                    cTracer(#do'isNonSingularImplSuper:'->TT#);
                                    theIS.super.ATd.asDecl -> ptn[]; 
                                    (* snorf:< foo    or
                                     * snorf:< koks.foo
                                     * ...
                                     * snorf ::
                                     *    ...
                                     * ptn = snorf:< foo or snorf:< koks.foo
                                     *)
                                    ptn.OG.super[] -> pushAddress -> E[];
                            if)if)
                         else
                            theIS.super[] -> pushAddress -> E[];
                        if);
                        (if vArgsInSuper > 0 then
                            vArgsInSuper + 1 -> cd.vShiftDown;
                            vArgsInSuper + 1 -> cd.vShiftDown;
                        if);
                        (if E[] = none then
			     (*'!!!! E is none'->putline*)
                        else
                           (theIS[],E[]) -> handleSuperArgs;
                        if);
                        (if rArgsInSuper > 0 then 
                            (* Reverse of rShiftUp as described above
                             * See rShift in VM/objectImage
                             *)
                           rArgsInSuper -> cd.rShiftDown
                        if);
                     else
                        (if objectDecl.OG.IS[] <> theIS[] then
                            (1,theIS.newDescno,true,'innerM') -> cd.vdtTable;
                    if)if)
                 #);
               checkIfBetaWorldOrStringModule:
                 (#
                 do (if newDescNo = (markIncludes.topModule.desc).newDescno then
                        cd.pushThis;
                        cd.saveBETAworld
                    if);
                    (if isStringModule then cd.saveStringOrigin if);;
                 #);
               mvStack:
                 (#
                 do (if (superDesc[] <> none) and not superDesc.isPrimitive then
                     else 
                        (if withValueProxy or not OG.isValueObj then 
                            cd.mvStack
                    if)if)
                 #);
               genAttributes:
                 (# theIS: ^Items; vOff: @integer
                 enter theIS[]
                 do (if (theIS[] -> hasRealSuper)
                        and (theIS.superDesc[] <> objectDecl.desc) then
                        theIS.superDesc[] -> genAttributes
                    if);
                    theIS.scanSons
                    (# I: ^Item; MP: ^Module
                    do current[] -> I[];
                       (if true
                        // I.isDecl and (I## <> LabelDecl##) then
                           (if not I.isPattern or I.isVirtual then
                               (false,0,0) -> current.gen -> (MP[],vOff);
                               (if MP[] <> none then
                                   MP[] -> mainPathModule[];
                               if)
                            else
                               (if I[] = StringDecl[] then
                                   (false,0,0) -> current.gen if) 
                           if)
                        // I.isNewProp then
                           (false,0,0) -> current.gen -> (MP[],vOff);
                           (if MP[] <> none then
                               MP[] -> mainPathModule[];
                           if)
                    if)#);
                    (if mainPathModule[] <> none then
                        (false,0,0) -> mainPathModule.gen;
                        none -> mainPathModule[]
                    if)
                 #);
               genActionPart:
                 (#
                 do (not OG.isValueObj and 
                    not ((superDesc[] <> none) and not superDesc.isPrimitive )
                    ) -> cd.actions;
                   (if withValueProxy or not OG.isValueObj then cd.mvStack if);
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item; superHasNewInner: @boolean
                   do current[] -> I[];
                      (if not I.isDecl or (I## = LabelDecl##) then 
                          cTracer(#do 'genclass:stmt:'->TT; current.doPT->TL#);
                          (if actPos = 0 then cd.BCpos -> actPos if);
                          (if isLast then
                              (if super.ATd[] <> none then
                                  (super.ATd.asDecl).OG.IS.newInner[] <> none
                                    -> superHasNewInner
                          if)if);
                          (superHasNewInner,0,0) -> current.gen 
                   if)#);
                   leaveLab -> cd.defLab;
                   (if (superDesc[] <> none) and not superDesc.isPrimitive then
                       'M' -> cd.rtnInner
                    else
                       cTracer(#do 'pushReturn: ' -> TT; 
                                (if sig[] <> none then sig.id[] -> TQ if)#);
                       (if not withValueProxy and encOG.isValueObj then
                           (* OBS! A value object has no out-parameters
                            * The whole object is copied in asignment
                            * So hwat does "out V: var integer" mean?
                            * Perhaps we should allow it?
                            *)
                           (if sig[] <> none then
                               (* use pushOut instead *)
                               encOG.pushReturnValues
                           if);
                           cd.rtnV
                        else
                           cd.setThisStack;
                           cd.pushThis
                       if);
                       'D' -> cd.rtn (* also for value object?  *)
                   if)
                 #);
               BindVirtuals:
                 (# E: ^Exp;
                    args: [6]^ObjectGenerator(*Specification*); top,i: @integer;
                 do (if (super.last -> E[]) = none then 
                        leave BindVirtuals
                    if);
                    (if (E.args[] <> none) and (E.args.noOfSons > 0)  then
                        cTracer(#do 'Handle VB:'->TT; dopt -> TL;
                                 'E:' -> TT; E.doPT -> TQ #);
                        E.args.scanArgs
                        (#
                        do (if (top+1 -> top) > args.range then 
                               args.range -> args.extend 
                           if);
                           current[] -> args[top][];
                        #);
                        (if super.ATd[] <> none then
                            (* bind possible virtuals in arguments to super *)
                            (super.ATd.asDecl).OG.IS.scanAllDecls
                            (# i: @integer; P: ^Pattern; off: @integer
                            do (* Only some inargs may be virtual
                                * And not all virtuals are inargs
                                *)
                               (if currentDcl.isInarg then 
                                   i + 1 -> i;
                                   (if (currentDcl.isVirtual)  then
                                       currentDcl[] -> P[];
                                       (if false then
                                           P.dopt -> putline;
                                           '---'->putline;
                                           args[i].doPT -> putline;
                                           ' args[i].hasItems:' -> puttext;
                                           args[i].hasItems -> putboolean;
                                           ' args[i].vDescNo:' -> puttext;
                                           args[i].vDescNo -> putint;
                                           ' P.OG.vDescNo:' -> puttext;
                                           P.OG.vDescNo -> putint;
                                           ' P.off:' -> puttext;
                                           P.off -> putint;
                                           '\n==='->putline;
                                       if);
                                       (if nameListInDcl then
                                           (P.sig.names.firstDecl).off-> off;
                                           (this(Items)[],off) 
                                             -> args[i].mkVirtualbinding
                                        else
                                           (this(Items)[],P.off)
                                             -> args[i].mkVirtualbinding
                    if)if)if)#)if)if);
                    (* bind virtuals defined in Signature *)
                    (if sig[] <> none then
                        sig.paramItems.scanSons
                        (# D: ^Decl; P: ^Pattern
                        do (if current.isDecl then
                               current[] -> D[];
                               (if D.isVirtual then
                                   D[] -> P[];
                                   (if nameListInDcl then
                                       (this(Items)[]
                                       ,(P.sig.names.firstDecl).off)
                                         -> P.OG.mkVirtualbinding
                                    else
                                       (this(Items)[],P.off) 
                                         -> P.OG.mkVirtualBinding 
                    if)if)if)#)if);
                    (* Bind virtuals defined/bound in mainpart *)
                    scanSons
                    (# I: ^Item; P: ^Pattern
                    do current[] -> I[];
                       (if I.isVirtual then
                           I[]->P[];
                           (if nameListInDcl then
                               (this(Items)[]
                               ,(P.sig.names.firstDecl).off)
                                 -> P.OG.mkVirtualbinding
                            else
                               (this(Items)[],P.off) -> P.OG.mkVirtualBinding
                    if)if)#);
                    newDescNo -> cd.endNewVirtDefs;
                 #);  
               handleLLVMvirtuaDefs:
                 (#
                 do cd.mkLLVMvirtualDefs
                    (# handleOrigins::
                         (#
                         do cd.lcom(#do 'handleOrigins:NEW:'->TT; OG.OGid->TT#);
                            (if (OG.IS.newOriginOff > 0) then
                                (if OG.primNo 
                                 // object_prim then
                                 else
                                    (OG[],OG[],true) -> storeOrigins;
                                    cd.lcom(#do 'handleOrigins:END: ' -> TT #)
                         if)if)#);
                       vName::
                         (# OGx: ^ObjectGenerator; org: ^Items
                         do dn -> QnewDesc.getOD -> OGx[];
                            (if OGx.super[] = none then
                                (if false then
                                    'handleLLVMvirtualDefs:supIsNone:'->putline;
                                    dn -> putint; newline;
                                    OGx.dopp -> putline;
                                    OG.dopt -> puthead;
                                if);
                                'emptyOG'->vN[]
                             else
                                (if false then
                                    '**** vName:'->puttext; 
                                    OGx.OGidWdNo -> puttext;
                                    ' ' -> put; OG.vDescNo -> putint;
                                    ' ' -> put; OGx.vDescNo -> putint;
                                if);
                                OGx.OGidWdNo -> vN[];
                            if);
                            origin[] -> org[];
                            (if org[] <> none then 
                                org.encOG.OGidWdNo -> orgOfVN[];
                                (if false then
                                    '**   origin:'->puttext; 
                                    orgOfVN[] -> puttext; ' ' ->put;
                                    org.encOG.vDescNo -> putint;
                                    newline;
                                if)
                             else
                                'Object$0' -> orgOfVN[] (* to be fixed! *)
                    if)#)#)
                 #);
               mainPathModule: ^Module;     
               rArgsInSuper: @integer;
            enter OG[]
            do (* Is called with descNo = NewDescNo *)
               (* the following dataitems used to be arguments of genClass *)
               OG.OGid -> N[]; OG.sig[] -> sig[]; newDescNo -> descNo;
               OG.super[] -> super[];
               OG.isValueObj -> inValueObj;
               
               cTracer
               (#
               do 'Items:GenClass:'->TT; N[]->TT; 'descNo:'->TT; descNo->II;
                  'isValue:'->TT; OG.isValueObj -> BB
               #);
               
               2 -> labelhandLer.labCount;
               genSuperClass;
               
               (if (primNo = vEq_Prim) or (primNo = vLE_prim) then
                   (*'**** got:vEq: ' -> puttext; primNo -> putint; ',' -> put;
                   (if (super[] <> none) and (super.ATd[] <> none) then
                       (super.ATd.asDecl).primNo -> putint;
                   if);
                   newline;*)
                   5 -> qsize[1] (* do we need this?*)
               if);
                    
               (if (superDesc[] <> none) 
                   and (super[] <> none) 
                   and (super.ATd[] <> none)
		   and (((super.ATd.asDecl).primNo = vEq_prim)
                   or ((super.ATd.asDecl).primNo = vLE_prim)) then
                   cTracer(#do 'got:sub:vEq: ' ->TT; 
                             (if (super[] <> none) and (super.ATd[] <> none)
                                 then
                                 super.ATd.primNo -> II
                             if);
                             ' isValueObj: ' -> TT; encOG.isValueObj -> BB;
                             qsize[1] -> II
                          #);
                   qsize[1] + 5 -> qsize[1]; (* needed? *)
                   encOG.reAlloc;
               if);

               (if not codeGenDone then
                   true -> codeGenDone;
                   mkClassDef;
                   (* thisObj = the new instance of this class 
                    * thisStack = caller
                    * Possible arguments on callerStack = thisStack
                    *)
                   cd.bcPos -> beginBCP;
                   
                   (this(Items)[],this(Items)[]) ->handleArgumentsAndOrigin;
                   checkIfBetaWorldOrStringModule;
                   mvStack;
                   (if sig[] <> none then (*(false,0,0) -> sig.gen*) if);
                   (* genAttributes for possible super - recursively *)
                   cd.markEnterE; 
                   this(Items)[] -> genAttributes;
                   (* goSuper *)
                   (if (this(Items)[] -> hasRealSuper) then
                       (if superDesc.primNo // vEq_prim // vLE_prim then
 		        else
                           (* Value::Eq (=) has no code and possible *)
                           1 -> cd.rtnAlloc;
                           (realTopSuper).newDescNo -> cd.toSuper
                       if)
                    else
		       (if withValueProxy or 
                           not this(Items).encOG.isValueObj then
                           1 -> cd.rtnAlloc
		   if)if);
                   genActionPart;
                   encOG.computeGCinfo;
                   (objSize,isIndexed,newBasicProp.visibility) 
                     -> cd.endClass;
                   cd.bcPos -> endBCP;
                   (if innerInx > 0 then
                       (innerInx,0,true,'innerX') -> cd.vdtTable; 
                   if);
                   BindVirtuals;
                   handleLLVMvirtuaDefs;                   
                   cd.lcom(#do 'ObjStubStackX:gen' -> TT #);
                   ObjStubStackX.gen;
               if);
            #);
          goOrigin:
            (# on: @integer; NA: ^Apl; org: ^Items; scp: ^Scope; T: ^text; 
               orgIsVal: @boolean; off: @integer
            enter(on,NA[])
            do (if on > 0 then
                   fcTracer(#do 'items:goOrigin:encOG:'->TT; encOG.OGid->TQ;
                             'on:'-> TT; on->II; 'isValueObj:'->TT; 
                             encOG.isValueObj -> BB; nl;
                             'origin:'->TT; origin.encOG.OGid->TT;
                             'origin:isValueObj:'->TT; 
                             origin.encOG.isValueObj -> BB;
                          #);
                   NA[] -> checkGlobalsViolations;
                   (if encOG.IS.newOriginOff = 0 then 
                       fcTracer(#do '!!!! encOG.IS.newOriginOff = 0:'->TT #);
                       fcTracer(#do (if sig[] <> none then sig.dopt -> TQ
                               else dopt -> TL if)#);
                       fcTracer(#do encOG.dopt -> TL #);
                       encOG.dopt -> putheadN;
                   if);
                   (if true then
                       encOG.OGidWdNo -> T[];
                    else                   
                       ((NA.origin[]->scp[]).OGofScope).OGidWdNo -> T[];
                   if);
                   (if not withValueProxy and (origin[] -> originIsValue) and
                       not ((origin[]->org[]).encOG.primNo = string_prim) then
                       fcTracer(#do 'goOrigin:originIsValue ' -> TT; #);
                       (if not withValueProxy then
                           cd.rdouble;
                           (T[],newOriginOff) -> cd.rpushg;
                           cd.rswap;
                           cd.rdouble;
                           (T[],newOriginOff + 1) -> cd.pushg;
                           (T[],newOriginOff + 2) -> cd.pushg;
                        else
                           fcTracer(#do'FIX:goOrigin:composite:valueProxy'->TT#)
                       if);
                       true -> orgIsVal
                    else
                       (if newOriginOff = 0 then
                           fcTracer(#do 'newOriginOff=0:'->TT; T[] -> TQ #);
                           (T[],(encOG.origin[]->org[]).newOriginOff) 
                             -> cd.rpushg;
                        else
                           (T[],newOriginOff) -> cd.rpushg;
                       if)
                   if);
                   (if (origin[] <> none) (*and (on > 1)*) then
                       (on - 1,NA[]) 
                         -> (origin[]->org[]).goOrigin
                         -> (org[],orgIsVal);
                   if);
                   (if (encOG.isArgofE[] <> none) then
                       encOG.IS.newOriginOff -> off;
                       (if false then
                           '**** GoOrigin:OG inArgument: ' -> putline;
                           encOG.dopt -> puthead;
                           '**   of:'->putline; 
                           encOG.isArgofE.dopt -> puthead;
                           '**   originOff:'->puttext; off->putint;newline;
                       if);
                       ('ArgOG',off) -> cd.rpushg;
                       fcTracer(#do 'ArgOG:'->TT; off->II #)
                   if);
                else
                   this(Items)[] -> org[]
               if)
            exit(org[],orgIsVal)
            #); 
          findNextImp::
            (#
            do L:
                 scanSons
                 (#
                 do (if (bcp -> current.findNextImp -> impx[]) <> none then
                        leave L
                 if)#);
            #);
          clear::< (# do false -> done -> codeGenDone #)
       #);
     Pattern::
       (# GeneralPattern::
            (# newInvoke:: (# <<SLOT GeneralPattern_newInvoke:doPart>> #);
            #);
          BreakPattern::
            (# newInvoke:: (# << SLOT BreakPattern_NewInvoke:doPart>> #);
            #);
          IndexedPattern::
            (# newInvoke:: (# <<SLOT IndexPattern_newInvoke:doPart>> #);
            #);
          OtherPrimPattern:: 
            (# newInvoke:: (# <<SLOT OtherPrim_newInvoke:doPart>> #); 
               org: ^Items; Tlab,exitLab: @labelHandler.label;
            #);
          virtualDone: @boolean;
          isPtnWithOrigin::
            (#
            do (if OG.IS.isEmpty then
                   (OG.super.last).isPtnWithOrigin -> value
                else
                   not (OG.IS.globalRestrictionsInMain 
                   and not OG.IS.inVirtualPtn)
                     -> value
               if)
            #);
          gen:: (##);
          pushThis::
            (# T: @text
            do (if OG.primNo
                // 0 
                // value_prim  (* OBS - needed for a ptn being sub of Value
                                * otherwise execution fails since origin 
                                * is not loaded
                                * An explicit sub of Object also fails
                                *)
                // this_prim 
                // indexedGet_prim (* not tested*)
                // indexedPut_prim (* ditto *)
                // stringGet_prim 
                // indexed_prim  
                // rIndexed_prim
                // immutable_prim then
                   cd.pushThis 
                else (* ugly *)
                   (if ptnKind // virtualPtn // furtherPtn // FinalPtn then
                       cd.pushThis 
                   if)
               if)
            #);
          loadArgs::
            (# gdb:: 
                 (# 
                 do '>E:' -> TT; E.doPT -> TQ;
                    ':descNo:' -> TT; OG.IS.newDescNo -> II;
                 #);
               handleNonVirtualArg:             
                 (# mkCom:
                      (# ch: @char
                      enter ch
                      do cTracer
                         (#do 'pushValue:'->TT; ch -> CC; 
                            ': off:' -> TT; valueOff -> II;
                            'size:' -> TT; formalArg.objSize -> II;
                            formalArg.OG.super.ATd.OG.IS.newDescNo -> II;
                            formalArg.dopt -> TT;
                         #);            
                      #);
                    formalArg: ^DataItem; actualArg: ^ObjectSpecification;
                    superOG: ^ObjectGenerator; mp:  ^Module;
                    valueOff: @integer
                 enter(formalArg[],actualArg[])
                 do (* E is the exp with arguments actArgs 
                     * this(Pattern) = E.ATd
                     * formalArg is arg no. argInx of this(Pattern)
                     *)
                    fcTracer(#do 'NonVirt:'->TT; E.doPT -> TL; E.label->TL;
                               'ActArg:' -> TT;actualArg.dopt->TQ;
                               'isValue:' -> TT;  actualArg.isValueObj->BB;
                               'formalArg:'->TT; formalArg.doPT->TL
                          #);
                    fcTracer(#do 'formalArg.OG.isBasicValue:' -> TT;
                             formalArg.OG.isBasicValue -> BB;
                             ' formalArg.OG.isValueObj:' ->TT; 
                             formalArg.OG.isValueObj -> BB;nl;
                             ' formalArg.OG.isNonBasicValueObj:' -> TT;
                             formalArg.OG.isNonBasicValueObj -> BB
                          #);
                    (* The call of gen should perhaps have the receiver 
                     * as an argument!?
                     * Currenly we handle stuff af gen that depends on 
                     * the receiver
                     *)
                    0 -> staticOff;
                    (* we may mark actualArg as isUnitVal or float 
                     * depending on this ptn *)
                    (if primNo 
                     // 112 (* float-* *) then
                        cTracer
                        (#do 'loadArgs:isPrim:assign,fmult: '->TT; 
                           primNo->II;E.dopt->TQ #);
                     else 
                        (* Perhaps we dont need both booleans below!? *)
                        formalArg.OG.isNonBasicValueObj 
                          -> actualArg.isCompositeValueObj;
                         
                        (* actualArg is a composite valueObj,
                         * not a basic value
                         * and this(ptn) is not value assignment nor * !
                         * We do not know if it is a UnitValue
                         * ActualArg is a valueObj being an actual arg to 
                         * a ptn that is not assign, float-*, etc.
                         *)
                        fcTracer(#do 'loadArgs:not:*: ' -> TT;
                                 'formalArgOf:' -> TT; E.doPT -> TQ;
                                 ' isCompositeValueObj:' -> TT;
                                 actualArg.isCompositeValueObj -> BB
                              #)
                    if);
                    (true,superAdj,staticOff) 
                      -> actualArg.gen 
                      -> (mp[],valueOff);
                    (if actualArg.isNonBasicValueObj 
                        and (actualArg.super.ATd.asDecl).isDataItem then
                        (* actualArg is a data-item being 
                         * a (nonBasic?) ValueObj *)
                        fcTracer
                        (#do 'before:pushSize: ' -> TT;
                           'actualArg.super.ATd.OG.isUnitValueObj:' -> TT;
                           actualArg.super.ATd.OG.isUnitValueObj -> BB; nl;
                           ':actualArg.isCompositeValueObj:'->TT;
                           actualArg.isCompositeValueObj -> BB;
                        #);
                        (if not (actualArg.super.ATd.asDecl).OG.isUnitValueObj 
                            or actualArg.isCompositeValueObj
                            then
                            fcTracer
                            (#do 'composite:valueObj:or:not:unitValue '->TT #);
                            'C' -> mkCom;
                            1 -> cd.pushConst
                         else
                            fcTracer(#do 'actualArg:UnitOne?:'-> TT; 
                                       actualArg.dopt-> TT #)
                        if);
                        fcTracer
                        (#do 'loadArgs:before:isPrimitiveIntWithFloatArg:'->TT;
                           dopt -> TL;
                           'isBasicPattern:' -> TT; isBasicPattern->BB;
                           'isPrimitive:'->TT; isPrimitive->BB;
                           'OG.super:'->TT; OG.super.dopt -> TL;
                           ('OG.super.ATd:',OG.super.ATd[])->PT
                           (#do OG.super.ATd.dopt->TL #)
                        #);
                                   
                        (if not isPrimitive then
                            formalArg[] -> actualArg.isIntForFloatArg
                            (# I2F:: (#do cd.I2F #);
                               F2I:: (#do cd.F2I #)
                            #)
                        if);
                     else (* not NonBasicValueobj or not data-item *)
                        (if true     
                         // (this(Pattern).primNo = vEq_prim)
			 // (this(Pattern).primNo = vLE_prim) then
                            fcTracer(#do 'vEq:'->TT; #);
                         else (* this pattern is not assignment *)
                            (* OBS! seems that actualArg is pattern *)
                            fcTracer
                            (#do 'actualArg:isPtn:' -> TT;
                               (actualArg.super.ATd.asDecl).isPattern -> BB;
                               'formalArg:isPtn:' -> TT; formalArg.doPT->TQ; 
                               ':isBasicVal:'->TT; 
                                     formalArg.isBasicValue -> BB;
                                     ':valueObj:' -> TT; 
                                     formalArg.OG.isValueObj -> BB; nl;
                                     ':actArg:' ->  TT; 
                                     actualArg.dopt -> TQ;
                                     ':isBasicVal:' -> TT; 
                                     actualArg.isBasicValue -> BB 
                                  #);
                            (if formalArg.OG.isNonBasicValueObj 
                                and actualArg.isBasicValue then
                                (* in formalArg: var aValueObj 
                                 * actualArg is float or int bar(15"m") 
                                 * formalArg is a unit 
                                 * - tested by semchecker
                                 *)
                                fcTracer
                                (#
                                do 'case:A:'->TT; actualArg.dopt->Tq;
                                   'form:isNonBasicValueObj:'->TT;
                                   formalArg.OG.isNonBasicValueObj ->BB;
                                   'act:isBasicValue:'->TT;
                                   actualArg.isBasicValue ->BB;
                                #);
                                (if actualArg.isInteger then cd.I2F if);
                                1 -> cd.pushConst
                             else
                                fcTracer(#do 'case:B:'->TT; actualArg.dopt->TT;
                                         actualArg.label -> TT;
                                         formalArg.OG.primNo -> II;
                                         actualArg.primno->II;
                                         (actualArg.desc).encOG.primNo -> II;
                                         formalArg.OG.isNonBasicValueObj ->BB;
                                           actualArg.isValueObj ->BB;
                                           'valueOff:'->TT; valueOff->II
                                        #);
                                (if not isBasicPattern then
                                    formalArg[] -> actualArg.isIntForFloatArg
                                    (# I2F:: (#do cd.I2F #);
                                       F2I:: (#do (*cd.F2I*) #)
                                #)if);
                                (if formalArg.OG.isNonBasicValueObj 
                                    and not actualArg.isValueObj 
                                    then
                                    (* actualArg must be a pattern 
                                     * returning a value *)
                                    (*44 -> cd.pushConst;*)
                                    (if ((actualArg.desc).encOG.primNo
                                        = String_prim) then
                                        cTracer(#do 'string:'->TT; 
                                                  formalArg.dopt-> TT #);
                                     else
                                        'D' -> mkCom;
                                        (if valueOff = 0  then
                                            pfcTracer
                                            (#do 'valueOff=0:'->TT; doPT->TT#);
                                            (0,formalArg.objSize,0)
                                              -> cd.pushValue;
                                         else
                                            (valueOff,formalArg.objSize
                                            ,formalArg.OG.super.ATd.OG.IS.newDescNo 
                                            )
                                              -> cd.pushValue;
                                        if);
                                        1 -> cd.pushConst
                                    if);
                                 else
                                    (# isValueArgOfIndexedPut: @boolean;
                                       D: ^Decl
                                    do (if (primNo = indexedPut_prim)
                                           and 
                                           (actualArg.super.ATd.asDecl->D[])
                                           .isPattern then
                                           D.OG.isValueObj and
                                           not D.OG.isBasicValue
                                             -> isValueArgOfIndexedPut
                                       if);
                                       (if isValueArgOfIndexedPut then
                                           fcTracer
                                           (#do 'isValueArgOfIndexedPut:'
                                                ->TT;
                                              isValueArgOfIndexedPut->BB;
                                              'primNo:'->TT; OG.primNo->II;
                                              actualArg.dopt -> TL;
                                       #)if);
                                       (if (formalArg.OG.super.ATd.asDecl)
                                           .OG.isValueObj 
                                           and 
                                           not (formalArg.OG.super.ATd.asDecl)
                                           .isBasicValue  
                                           or isValueArgOfIndexedPut
                                           then
                                           0 -> cd.pushConst
                                    if)#);
                                    (formalArg.OG.super.ATD.asDecl).OG[] 
                                      -> superOG[];
                                    (if superOG.primNo 
                                     // indexed_prim
                                     // rIndexed_prim then
                                        superOG[] -> objTmpStack.add;
                                        cTracer(#do 'formalArg is indexed:'->TT;
                                                 formalArg.dopt -> TT; ' ' ->TT;
                                                 superOG.IS.newDescNo ->II; nl;
                                                 actualArg.dopt -> TT; ' '->TT;
                                                 actualArg.label -> TT;
                                              #);
                                        fcTracer(#
                                              do superOG.IS.newDescNo ->II;
                                                 formalArg.OG.super.ATd.dopt->TL
                                              #);
                                        (if (actualArg.bracketedListElement > 0)
                                            then
                                            actualArg.bracketedListElement 
                                              -> cd.pushConst;
                                            (if superOG.IS.primNo
                                                =  rIndexed_prim then
                                                superOG.IS.newDescNo 
                                                  -> cd.mkRindexed
                                             else
                                                superOG.IS.newDescNo 
                                                  -> cd.mkVindexed
                    if)if)if)(*if)*)if)if)if)if);
                    fcTracer(#do 'end:loadArgs:NonVirt:' -> TT; E.dopt -> TQ #);
                 #);
               actArgs: [6] ^ObjectSpecification; (* actual arguments *)
               top,argInx: @integer;
               enclosingOG: ^ObjectGenerator;
            do (* loadArgs is followed by invoke.
                * There are different invoke patterns for assignment,
                * general patterns, ...
                * Perhaps we should also have different loadArgs for 
                * assignment, general patterns, ...
               *)
               (if OG.primNo 
                   (* Some of these are handled in invoke below
                    * May be moved to here*)
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   (* skip *)
                else 
                   cTracer(#do 'ptn:loadArgs:E:'->TT; E.dopt->TL #);
                   cTracer(#do 'args:'->TT; E.args.dopt->TL #);
                   E.args.scanArgs
                   (#
                   do (if (top+1 -> top) > actArgs.range then 
                          actArgs.range -> actArgs.extend 
                      if);
                      current[] -> actArgs[top][];
                      cTracer(#do 'E:'->TT;  current.label -> TQ; current.dopt->TT#);
                   #);
                   scanArgs
                   (#
                   do argInx + 1 -> argInx; 
                      (if argInx <= top then
                          (* can we do currentArg.LoadArg?
                           * And then perhaps special for virtual primitive
                           * and ptName? Virt is of course ptn *)
                          (if currentArg.isVirtual then
                              (* (currentArg[],actArgs[argInx][]) 
                               * -> handleVirtualArg
                               * See handleVargs instead
                               *)
                           else 
                              cTracer(#do 'E.arg:'->TT; currentArg.label -> TQ;
                                        currentArg.dopt -> TT #);
                              (currentArg[],actArgs[argInx][]) 
                                -> handleNonVirtualArg
                          if)
                          (*else: E is a super as foo in foo{...} *)
                   if)#);
                   handleSuperArgs:
                     (if (argInx < top) and (OG.primNo <> resume_prim) then
                         '\n!!!! pattern:loadArgs:argInx<top:'
                           -> putline;
                         dopt -> putline;
                         (* a hack - need to scan arguments of super *)
                         argInx + 1 -> argInx;
                         (true,superAdj,staticOff) -> actArgs[argInx].gen;
                         restart handleSuperargs
               if)if);
            #);
          load::
            (#
            do cTracer
               (#do 'Pattern:load:???'->TT;OG.primNo->II; ' '->TT; dopt->TT #)
            #);
          getAdr::
            (# B: @boolean
            do cTracer(#do A.toString -> TT #);
               (if isPrimitive then
                   true -> loadRec;
                else
                   true -> loadRec;
                   true -> A.isAdr
               if);
            #);
         loadAccessor::
            (#
            do fcTracer(#do 'PTN:loadAccessor:'->TT; sig.dopt->TL #);
               (rec[],valueOff) -> currentPtnKind.loadAccessor
            #);
          newInvoke::
            (#
            do fcTracer(#do 'ptn:newInvoke:'->TT; sig.dopt -> TL;
                       'staticOff:'->TT; staticOff->II #);
               (rec[],E[],useRtnVal,valueOff,staticOff,isAdr) 
                 -> currentPtnKind.newInvoke 
            #);
          popReturn:
            (* perhaps this should be the same virtual as in dataItem!?
             * And do consider signature:popReturn
             *)
            (# D: ^Decl
            do (if (getReturnDecl -> D[]) <> none then
                   D.popReturn
                else 
                   cd.rpop
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);
          clear::< (# do false -> genIsDone; inner #);
          genIsDone: @boolean;
       #);
     Address: superAdr
       (* E = first exp in "R.S.Q", ie. E = "R" *)
       (# nameOfE_OG:
            (# D: ^Decl; org: ^Items
            do (if E[] <> none then
                   E.ATd.asDecl -> D[];
                   E.origin[]->org[]; 
                   (for i: E.on repeat org.origin[] -> org[] for);
                   org.encOG.OGidWdNo -> T[];
                else
                   'EisNone' -> T[]
               if)
            exit T[]
            #);
          done: @boolean; T: ^text;
          load:: (* actually push value *)
            (# isNotRemote: @Boolean
            do (if isAdr then
                   loadAdr
                else
                   (if off > 0 then
                       (rec[] = none) or (rec[] = E[]) -> isNotRemote;
                       fcTracer
                       (#do 'load:'->TT; this(Address).toString -> TT;
                            'isNotRemote:'-> TT; isNotRemote -> BB
                       #);
                       cTracer(# do 'isCompositeValueObj:'->TT;
                                 isCompositeValueObj -> BB;
                                 'E:'->TT; E.dopt -> TQ;
                                 E.ATd.dopt -> TL;
                                 E.ATd.OG.isValueObj -> BB;
                              #);
                       cTracer
                       (#do 'E.ATd.isValueObj:'->TT;
                          (E.ATd.ORIGIN.ogOfScope).isValueObj -> BB;
                          'rec:' -> TT;
                          (if rec[] = none then
                              'none'->TQ
                           else
                              rec.dopt -> TQ
                          if);
                       #);
                       (if isValue then (* primitive or valueObj *)
                           (if originIsValue or
                               (E.ATd.origin.ogOfScope).isValueObj
                               and isNotRemote
                               and withValueProxy then
                               (if isFloat then
                                   fcTracer
                                   (#do 'load:isValue:E:'->TT;E.doPT -> TQ;
                                      'originIsValue:'->TT; originIsValue -> BB;
                                      'E.ATd:isValueObj:'->TT;
                                      (E.ATd.origin.ogOfScope).isValueObj -> BB
                                   #);
                                   fcTracer
                                   (#do 'E.ATd:'->TT; E.ATd.dopt -> TL; nl;
                                      'E.ATd.origin:'->TT;
                                      E.ATd.origin.dopt -> TL; nl;
                                      '(E.ATd.origin.ogOfScope):'->TT; 
                                      (E.ATd.origin.ogOfScope).dopt->TL
                                   #);
                                   (* A:
                                    *    Avalue: Value
                                    *       X: var Float/Unit
                                    *       F(X)
                                    * B:
                                    *    Avalue: Value
                                    *       X: var Float/Unit
                                    *    anObj:
                                    *       F(X)
                                    *)
                                   (if withValueProxy then
                                       (nameOfE_OG,off) -> cd.fvpushg;
                                    else
                                       ('',off) -> cd.fovpushg
                                   if)
                                else
                                   (if withValueProxy then
                                       (*'valueProxy:'->dumptN;*)
                                       (if not originIsValue then
                                           (* we are in 
                                            * (1) a valueObj: mainpart
                                            *     accessing attribute liek X
                                            * (2) an object with a value Obj
                                            *    P1: var Point
                                            *    accessing P1.Y
                                            *)
                                           (if (rec[] <> none)
                                               and (rec[] <> E[]) then (* (2) *)
                                               cTracer
                                               (#
                                               do 'ObjWithValObj:rec:'->TT;
                                                  (if rec[] <> none then
                                                      rec.dopt -> TQ;
                                                      rec.ATd.off -> II;
                                                   else
                                                      'none'->TT
                                                  if);
                                                  'E:'->TT;E.dopt -> TQ;off -> II
                                               #);
                                               (nameOfE_OG,off) -> cd.pushg;
                                            else
                                               cTracer(#do 'koks:A:'->TT #);
                                               (nameOfE_OG,off) -> cd.vpushg;
                                           if)
                                        else
                                           (* isValue & originIsValue 
                                            * must use cd.vpushg
                                            *)
                                           cTracer(#do 'koks:C:'->TT #);
                                           (nameOfE_OG,off) -> cd.vpushg
                                       if)
                                    else
                                       ('',off) -> cd.ovpushg
                               if)if)
                            else
                               (if isFloat then
                                   ('',off) -> cd.fpushg
                                else
                                   (* problem here!*)
                                   (nameOfE_OG,off) -> cd.pushg;
                               if)
                           if)
                        else
                           (if isUnique then
                               cTracer(#do 'address:load:isUnique' -> TT #);
                               cd.rdouble;
                               ('',off) -> cd.rpushg;
                               cd.rswap;
                               cd.pushNone;
                               cd.rswap;
                               ('kuk',off) -> cd.rstoreg
                            else
                               '' -> T[];
                               (if rec[] <> none then rec.dopt -> T.append if);
                               '/'-> T.put;
                               (if E[] <> none then E.dopt -> T.append if);
                               (nameOfE_OG,off) -> cd.rpushg
                           if)
                       if)
                    else
                       '**** Address:load:off = 0 ' -> puttext; 
                       E.label -> dumpT;
                       (if E[] <> none then E.dopt -> putline else newline if);
                       cTracer(#
                              do 'Address:load:off = 0 '->TT;
                                 (if E[] <> none then E.dopt-> TQ if)
                              #)
               if)if)
            #);
          loadAdr::
            (#    
            do fcTracer(#do 'Address:loadAdr:'->TT;this(Address).toString->TT #);
               (if off > 0 then
                   (if isValue then
                       fcTracer(#do 'loadAdr:isValue:'->TT #);
                       (if isUnitVal and not isCompositeValueObj then
                           (* isUnitVal should be enough, but is not!? *)
                           fcTracer(#do 'loadAdr:isValue:isUnitVal'->TT #);
                           ('',off) -> cd.fpushg
                        else
                           (if originIsValue then
                               fcTracer(#do'loadAdr:isValue:originIsValue'->TT#);
                                (if not withValueProxy then
                                    cd.swap;
                                    off - 1 -> cd.pushConst;
                                    61 (*plus*) -> cd.op;
                                    cd.swap
                                 else
                                    fcTracer
                                    (#do'FIX:composite:valueProxy:B:'->TT#);
                                if)
                            else
                               fcTracer
                               (#do'loadAdr:isValue:originIsPlain'->TT;
                                  E.dopt -> TL;
                                  'cmpAndSwap:'->TT;
                                  (E.ATd.asDecl).primNo = cmpAndSwap_prim -> BB;
                                  ('rec:',rec[]) -> PT
                               #);
                               (if withValueProxy then
                                   (if (E.ATd.asDecl).primNo = cmpAndSwap_prim
                                       then
                                       off -> cd.pushConst;
                                   if)
                                else
                                   off -> cd.pushConst;
                                   valDescNo -> cd.pushConst
                       if)if)if)
                    else
                       (nameOfE_OG,off) -> cd.rpushg
                   if)
                else
                   (if false then
                       '**** Address:loadAdr:off = 0 ' -> puttext; 
                       E.label -> dumpT;
                       (if E[] <> none then E.dopt -> putline else newline if);
                   if);
                   cTracer(#do 'Address:loadAdr:off = 0 '->TT;
                             (if E[] <> none then E.dopt-> TQ if)#)
               if)
            #);
          store::
            (# mode: @integer
            do (if not done then
                   true -> done;
                   cTracer(#do 'store:'->TT; this(address).toString->TT #);
                   (if off > 0 then
                       cTracer
                       (#do 'isValue:' -> TT; isValue -> BB; 
                          ' isAdr:' -> TT; isAdr -> BB;
                          ' descNo: ' -> TT; descNo -> II;
                       #);
                       (if isValue then
                           (if isAdr then
                               (if descNo > 0 then
                                   (if ((E.Atd.asDecl).OG.primNo = String_prim)
                                       then
                                       cd.rswap;
                                       (nameOfE_OG,off) -> cd.rstoreg
                                    else
                                       cd.vpop;
                                       cd.saveAndSetThis;
                                       (* quite complex 1st arg, 
                                        * ex: E = P, where
                                        * P: var Point(0,0)
                                        * E.ATd.OG.super.last = Point(0,0) = X
                                        * X.ATd.OG = Point descriptor
                                        *)
                                       ((((E.ATd.asDecl).OG.super.last)
                                          .ATd.asDecl).OG.OGid
                                       ,descNo,off - 1
                                       ,inValueObj)
                                         -> cd.invokeVal;
                                       (if withValueProxy then cd.rpop if);
                                       cd.restoreThis
                                   if)
                                else
                                   (if ((E.Atd.asDecl).OG.primNo = String_prim)
                                       then
                                       cd.rswap;
                                       (nameOfE_OG,off) -> cd.rstoreg
                                    else
                                       (if originIsValue then 1 -> mode if);
                                       cTracer
                                       (#do 'Address:store::srcIsVal:'->TT; 
                                          srcIsVal -> BB;
                                          ' destIsVal:'->TT;originIsValue->BB;
                                          ' mode:' -> TT; mode -> II 
                                       #);
                                       fcTracer
                                       (#do 'vassign:A:'->TT; E.dopt->TQ;
                                          'off:'->TT; off -> II;
                                          'size:'->TT; size -> II;
                                          'mode:'->TT; mode -> II
                                       #);
                                       (off,size,mode) -> cd.vassign
                               if)if)
                            else
                               (if originIsValue then
                                   cTracer(#do'Address:store:originIsVal:'->TT#);
                                   (if withValueProxy then
                                       (if isFloat then
                                           ('',off) -> cd.fvstoreg
                                        else
                                           ('',off) -> cd.vstoreg
                                       if)
                                    else
                                       (if isFloat then
                                           ('',off) -> cd.fovstoreg
                                        else
                                           ('',off) -> cd.ovstoreg
                                   if)if)
                                else
                                   cTracer(#do 'isFloat:D: '->TT; isFloat->BB #);
                                   (if isUnitVal or isFloat then
                                       ('address:storeg',off) -> cd.fstoreg
                                    else
                                       (nameOfE_OG,off) -> cd.storeg
                           if)if)if)
                        else
                           (*(if isAdr then loadAdr if);*)
                           cd.rswap;
                           (nameOfE_OG,off) -> cd.rstoreg
                   if)if)
                else
                   '**** Address:store:off = 0 ' -> puttext; 
                   cTracer(#do 'Address:store:off = 0 ' -> TT #);
                   (if E[] <> none then E.dopt -> putline else newline if);    
               if)
            #);
          toString::
            (# 
            do ':Adr:'-> T.append; 
               'off:'-> T.puttext; off -> T.putint;
               ' size:'-> T.puttext; size -> T.putint;
               ' isFloat:' -> T.puttext; 
               (if isFloat then 'T'->T.putText else 'F'->T.puttext if);
               ' isUnitVal:'->T.puttext; 
               (if isUnitVal then 'T'-> T.puttext else 'F'->T.puttext if);
               ' superAdj:'->T.puttext; superAdj->T.putint;
               ' isUnique:'->T.puttext; 
               (if isUnique then 'T'->T.putText else 'F'->T.puttext if);
               ' isValue:' -> T.puttext; 
               (if isValue then 'T'-> T.puttext else 'F'->T.puttext if);
               ' originIsValue:' -> T.puttext; 
               (if originIsValue then 'T'-> T.puttext
                else 'F'->T.puttext if);
               ':E:"'->T.puttext;
               (if E[] = none then 'none"'->T.puttext
                else
                   E.dopt -> T.puttext; '"' -> T.put
               if);
               ':rec:'->T.puttext;
               (if rec[] = none then '-'->T.put else rec.dopt->T.puttext if);
            #);
       enter superAdj
       exit this(Address)[]
       #);
                    
     checkInt2IntWithUnitArg: booleanValue
       (* Apparently we have a binary method mapping and int to an int,
        * but not sure where and how this is checked!?
        * E is the method and may e.g. be '* arg'
        * arg may be int, float or UnitValueObj
        * Receiver, rec may be int, float or other
        * If arg is UnitValueObj and rec is int, true is returned,
        * probably implying a cd.I2F
        *)
       (# rec,E: ^Exp; OGx: ^ObjectGenerator
       enter(rec[],E[])
       do (if rec[] <> none then
              fcTracer
              (#do 'checkInt2IntWithUnitArg:E:'->TT; E.doPT->TL;
                 E.isPrimitiveIntWithFloatArg -> BB;
                 rec.isFloat -> BB;
              #);
              E.isPrimitiveIntWithFloatArg and not rec.isFloat -> value
          if)
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.on -> gorigin
        *    E1.pushOff
        *    E2.pushOff
        *    E3.invoke
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# checkOrigins:
            (* m1: var Length.Meter
             * m1.print
             * path(m1) o path(Length) o nest(Meter)
             * origins(print) = origins(Length) O nest(Meter)
             * print.origin = Meter, Meter.origin = Length
             * P: var R1.R2.R3.PPP
             * P.msg
             * P isA PPP
             * PPP.origin = R3.ATd, R3.origin = R2.origin, R2.origin = R1.ATd
             * X: var TTT
             * X.foo
             * X isA TTT
             * TTT.origin = encloser(TTT)
             *)
            (# emitCode,hasValueObj: @boolean; T: ^Text;
               getMax:
                 (# E: ^Exp; m: @integer; ISx: ^Items
                 enter E[]
                 do E.ATd.OG.IS.maxOn -> m;
                    E.ATd.OG.IS[] -> ISx[];
                    L:
                      (if ISx.superDesc[] <> none then
                          ISx.superDesc[] -> ISx[];
                          (if ISx.maxOn > m then ISx.maxOn -> m if);
                          restart L
                      if)
                 exit m
                 #)
            enter emitCode
            do 'Start: '->T[]; dopt->T.putline;
               scanSons
               (# E: ^Exp; org: ^Scope
               do current[] -> E[];
                  (if true
                   // isFirst then
                      'first: '->T.puttext; E.doPT -> T.putline;
                      (E[],emitCode) -> declOrigin -> (hasValueObj,T.puttext)
                   // isLast then
                      'last: "' -> T.puttext; E.dopt -> T.puttext;
                      (if E.ATd.isPattern  then
                          '" isPattern maxOn: '->T.puttext;
                          E[] -> getMax -> T.putint; T.newline;
                          E.ATd.dopt -> T.puttext
                      if);
                   else
                      'nest: ' -> T.puttext; E.dopt -> T.putline;
                      (if emitCode then
                          cTracer(#do 'pushOff'->TT; E.ATd.newOff -> II #)
                      if)
                  if)
               #)
            exit(hasValueObj,T[])
            #);
          declOrigin:
            (* m1: var Length.Meter
             * m2: obj T{ ... }
             *)
            (# E: ^Exp; emitCode: @ Boolean;
               OG: ^ObjectGenerator; hasValueObj: @boolean; T: @Text;
            enter(E[],emitCode)
            do 'declOrigin: ' -> T.puttext;
               E.ATd.OG[] -> OG[]; OG.OGid->T.putline;
               (if emitCode then
                   cTracer(#do 'pushThis'->TT #);
                   cTracer(#do 'goOrigin'->TT; E.on -> II #);
                   cTracer(#do 'pushOff'->TT; E.ATd.newOff -> II #);
               if);
               (if OG.IS.isEmpty then
                   OG.super.scanSons
                   (# E: ^Exp
                   do current[] -> E[];
                      (if isFirst then
                          'origin:first: "'->T.puttext; E.dopt->T.puttext;
                          (if emitCode then
                              cTracer(#do 'goOrigin'->TT; E.on -> II;  #);
                              cd.rdouble;
                              0->E.loadOrigin;
                              cTracer(#do 'pushOff'->TT; E.ATd.newOff -> II #);
                              (E.dopt,E.ATd.newOff) -> cd.rpushg
                          if)
                       else
                          'origin:next: "'->T.puttext; E.dopt->T.puttext;
                          (if not isLast and emitCode then
                              cTracer(#do 'pushOff'->TT; E.ATd.newOff -> II #);
                      if)if);
                      (if E.ATd.OG.isValueObj and not E.ATd.OG.isBasicValue then
                          '" isValueObj:true ' -> T.putline;
                          true -> hasValueObj
                       else
                          '" isValueObj:false ' -> T.putline
                   if)#)
                else
                   'singular: ' -> T.putline; 
               if)
            exit(hasValueObj,T[])
            #);
          findOrigins:
            (# hasValueObj: @boolean; T,S: ^Text; org: ^Scope; orgx: ^Items;
               E: ^Exp
            enter E[]
            do '**   FO: ' -> T[]; E.dopt->T.putline;         
               (if '???'->(E.label).equal then
                   leave findOrigins 
               if);
               (if E.ATd.OG.isValueObj then
                   ' this:true'->T.putline
                else
                   ' this:false'->T.putline
               if);
               (if E.on > 0 then
                   '**** findOrigins: '->T.puttext; E.dopt -> T.puttext;
                   ' on: '->T.puttext; on -> T.putint; 
                   T.newline;
                   E.origin[] -> org[];
                   (if org[] <> none then
                   L:
                     (for i: E.on + 1 repeat
                          org.encOG.OGid -> T.puttext; 
                          (if org.encOG.isValueObj then 
                              ' True '-> T.puttext; 
                              true -> hasValueObj
                           else
                              ' False '->T.puttext
                          if);
                          (if org.isItems then
                              (org[]->orgx[]).newOriginOff->T.putint; T.newline;
                          if);
                          (if (org.origin[] -> org[]) = none then
                              leave L
                          if)
                   for)if);
                else
                   '**** local: '->T.puttext; E.dopt->T.putline;
                   (if E.ATd.OG.super[] <> none then
                       E.Atd.OG.super.checkOrigins -> (hasValueObj,S[]);
                       S[] -> T.append;
                    else
                       'none'->T.putline
                   if)
               if);
            exit(hasValueObj,T[])
            #);
          checkOriginsII:
            (# T: @Text
            do (* M1.print(17) *)
               scanSons
               (# E: ^Exp
               do current[] -> E[];
                  (if not isLast then
                      E.doPT -> T.append; 
                      ':'->T.put; 
                      E[] -> getOrigin -> T.append
                   else
                      'last:' -> T.append; E.dopt -> T.append
                  if);
               #) 
            exit T[]
            #);
          getOrigin:
            (* M: var Length.Meter
             * M.print(17)
             *)
            (# E: ^Exp; OGx: ^ObjectGenerator; T: @Text
            enter E[]
            do (* E = M1 *)
               E.ATd.OG[] -> OGx[]; (* OGx = Length.Meter *)
               
               (if OGx.IS.isEmpty then                   
                   OGx.super.scanSons
                   (#
                   do current[] -> E[];
                      ';'->T.put; 
                      (if not isLast then
                          E.dopt -> T.append;
                       else
                          'last;' -> T.append; E.dopt -> T.append 
                      if);
                      (if E.ATd.OG.isValueObj and not E.ATd.OG.isBasicValue then
                          ';isValueObj ' -> T.putline;
                          (* no proxy here
                           * cTracer
                           * (#do 'CreateProxyQ:'->TT; E.ATd.sig.dopt->TQ#);
                           *)
                      if)
                   #)
                else
                   ';singular;'->T.append; 
                   OGx.OGid -> T.append
               if);
            exit T[]
            #);
          newInvoke:: (* not used! *)
            (#
            do pfcTracer(#do 'Invocation:newInvoke:'->TT; dopt -> TQ #);
               scanSons(#do (true,0,0) -> gen #);
            #);
          isConst: BooleanValue
            (* E = C in V := C where C: val 117
             * E = 117 in C: val 117
             *)
            (# E: ^Exp; DI: ^SuperDataItem; cst: @integer
            enter E[]
            do fcTracer(#do 'isConst:'->TT; E.doPT->TL;
                          E.label -> TL; (E.ATd.asDecl).dopt -> TL;
                          E.bracketedListElement-> II #);
               (if true 
                // E.bracketedListElement > 1 then
                // E.isConstLiteral then
                   fcTracer
                   (#do 'isConstLiteral:'-> TT; E.dopt->TL #);
                   true -> value;
                   E.pushConst -> cst;
                // (E.ATd.asDecl).isDataItem  then
                   E.ATd.asDecl -> DI[];
                   fcTracer
                   (#do 'isConst:DI:'-> TT; DI.dopt->TL #);
                   (if DI.isConst and DI.OG.isBasicValue 
                       and DI.OG.isValueObj then
                       (* we need to test for isValueObj since we may still
                        * have X: obj V + W where V: obj 12, W: obj 87
                        * We should perphaps forbid that, but depends on whether
                        * we unify obj/ref and var/val
                        *)
                       fcTracer
                       (#do 'isConst:DI:isConst'-> TT; DI.dopt->TL #);
                       true -> value;
                       DI.pushConst -> cst;
               if)if);
               (if value then
                   fcTracer(#do 'isConst:cst:true:'->TT; E.doPT->TL; cst->II #);
               if)
            #);
          handleInv:
            (# loadOriginII:
                 (# E: ^Exp;
                 enter E[]
                 do fcTracer(#do 'loadOriginII:'->TT; E.dopt-> TL#);
                    E.pushThis;
                    superAdj -> E.loadOrigin -> (rec[],E[],orgIsVal);
                 #);
               getTypeAsOG:
                 (# recX,Ex: ^Exp; typeAsOG,OGx: ^ObjectGenerator; OI:  ^exp;
                    ExDecl,D: ^Decl; ArrayDecl: ^Items; superRec: ^Invocation;
                    dn,off: @integer; originIsValueObj: @boolean
                 enter(recx[],Ex[])
                 do Ex.ATd.asDecl -> ExDecl[];
                    ExDecl.OG[] -> typeAsOG[];
                    Ex[] -> recDeclInValueObj -> originIsValueObj;
                    (if typeAsOG.primNo > 0 then
                        (if exDecl.primNo
                         // indexedGet_prim then
                            fcTracer
                            (#do 'getTypeAsOG:indexedGet:'->TT; Ex.dopt -> TL;
                               ('recx:',recx[])->PT
                               (#do recx.dopt->TL; recx.ATd.dopt -> TL #); 
                            #);
                            (if recx[] <> none then
                                recx.ATd.OG.super[] -> superRec[];
                                superRec.scanSons(#do current[] -> OI[] #);
                                OI.args.scanargs(#do current[]-> typeAsOG[] #);
                                typeAsOG.super.ATd.OG[] -> typeAsOG[];
                                0 (*(recx.ATD.asDecl).newoff*) -> off
                            if)
                         // indexedPut_prim then
                         else
                            'BOB: '->dumpT; Ex.dopt -> dumpTN
                        if)
                     else
                        (Ex.ATd.asDecl).OG[] -> typeAsOG[];
                        typeAsOG.IS.newDescNo -> dn; (* IS.isEmpty? *)
                        (if (typeAsOG.getReturnDecl -> D[]) <> none then
                            fcTracer
                            (#do 'getTypeAsOG:hasReturn:'->TT; D.dopt->TL #);
                            D.OG[] -> typeAsOG[];
                        if);
                        (if typeAsOG.IS.isEmpty then
                            typeAsOG.super.ATd.OG[] -> typeAsOG[];
                        if);
                        (if D[] <> none then
                            D.newOff -> off;
                            (Ex.ATd.asDecl).OG.isValueObj -> originIsValueObj
                         else
                            typeAsOG.IS.newDescNo -> dn;
                            (Ex.ATd.asDecl).newOff -> off;
                    if)if);
                    fcTracer
                    (#do 'typeAsOG:'->TT; typeAsOG.OGid->TL;
                       'descNo:'->TT; typeAsOG.IS.newDescNo -> II;
                       'size:'->TT; typeAsOG.objSize -> II;
                       'off:'->TT; off->II; typeAsOG.dopt -> TL 
                    #);
                 exit(typeAsOG[],dn,off,originIsValueObj)
                 #);
               recDeclInValueObj: BooleanValue
                 (# rec: ^Exp;
                 enter rec[]
                 do L: rec.ATd.OG.super.scanSons
                      (* super = Invocation = R1.R2.R3.E *)
                      (# Ey: ^Exp
                      do (current[]->Ey[]).origin.encOG.isValueObj
                           -> value;
                         (* only check R1 ? probably no! *)
                         leave L
                 #)#);
               checkForProxy:
                 (* rstack[rtop] = adr(E) *)
                 (# pRec,rec,E: ^Exp;  dNo,off: @integer; 
                    typeAsOG: ^ObjectGenerator
                 enter(pRec[],rec[],E[])
                 do fcTracer
                    (#do 'checkForProxy:E:'->TT; E.dopt->TL;
                       'isBasicValue:'->TT;(E.ATd.asDecl).OG.isBasicValue->BB;
                       'origin.isValueObj:'->TT;
                       (E.ATd.asDecl).origin.encOG.isValueObj -> BB;
                       'staticOff:'->TT; staticOff->II; 
                       ('rec:',rec[])->PT(#do rec.dopt->TL #);
                    #);
                    (* staticOff = 0 => INV in DataItem 
                     * rec = none 
                     *)
                    (if (staticOff = 0) 
                        and not (E.ATd.asDecl).OG.isBasicValue
                        and (E.ATd.asDecl).origin.encOG.isValueObj
                        then
                        (if (rec[] <> none) 
                            and not (rec.ATd.asDecl).OG.isBasicValue then
                            (prec[],rec[]) 
                              -> getTypeAsOG 
                              -> (typeAsOG[],dNo,off,originIsValueObj);
                            cd.rdouble;
                            fcTracer
                            (#do 'rec:'->TT; rec.dopt -> TL;
                               'rec.origin:'->TT; rec.origin.dopt -> TL; 
                               'E:'->TT; E.dopt->TL; 'descNo:'->TT; dNo->II;
                            #);
                            (if originIsValueObj  then
                                fcTracer
                                (#do 'originIsValueObj:'->TT;rec.dopt->TL#);
                                true -> originIsValueObj
                             else
                                (* the next is probably not ok in general *)
                                fcTracer(#do 'rec.ATd:'->TT;rec.ATd.dopt->TL#);
                                rec.ATd.OG.super.scanSons
                                (# Ex: ^Exp
                                do current[]-> E[];
                                   fctracer(#do 'E:'->TT; E.dopt -> TL;#);
                                   (if isFirst then
                                       E.loadOrigin;
                                   if);
                                   (if not isLast then
                                       fcTracer(#do 'E:'->TT;E.dopt->TL;
                                               'off:'->TT; E.getNewoff->II #);
                                       ('E', E.getNewOff) -> cd.rpushg
                            if)#)if);
                            (dNo,off - 1,false,originIsValueObj)
                              -> cd.mkValueProxy
                         else
                            (* probably a method invocation in an object, 
                             * which is not a value object; I think!?
                             *)
                            fcTracer
                            (#do 'checkForProxy:rec=None:localInvocation?'->TT;
                               dopt -> TL; 'E:'->TT; E.dopt -> TL;
                               ('rec:',rec[])-> PT(#do rec.dopt -> TL #)#)
                 if)if)#);               
               updateOffset:
                 (# D: ^Decl; ptn:  ^Pattern
                 do fcTracer(#do 'updateOffset:'->TT; E.dopt->TL;
                               'E.ATd:'->TT; E.ATd.dopt -> TL #);
                    (if (E.ATd.asDecl->D[]).isPattern then
                        (if ((D[]->ptn[]).OG.getReturnDecl -> D[]) <> none then
                            (if D.OG.isValueObj and not D.OG.isBasicValue then
                                fcTracer(#do'updateOffset:D:'->TT;D.dopt->TL#);
                                D.newOff -> valueOff;
                 if)if)if)#);
               checkI2F2I:
                 (# ix: @integer; next: ^Exp; 
                 enter ix
                 do fcTracer(#do 'checkI2F2I:'->TT; E.dopt->TL; #);
                    (if ix < exps.range then
                        exps[ix + 1][] -> next[];
                        fctracer
                        (#do 'next:'->TT; next.dopt->TL;next.ATd.OG.primno->II;
                           next.isFloat->BB #);
                        (if next.isFloat then
                            cd.I2F
                 if)if)#);
               next:
                 (* we need to pass the next exp to newInvoke fo
                  *    mutex.cmpAndSwap(1)
                  * we shall push mutex.off and not load its value
                  * This is a bit clumsy
                  *)
                 (# ix:@integer; succ: ^Exp
                 enter ix
                 do fcTracer
                    (#do 'loadPath:next:'->TT; ix->II; exps.range->II #);
                    (if ix < exps.range then exps[ix + 1][] -> succ[] if)
                 exit succ[]
                 #);
               scanInv: 
                 (# start,end,ix: @integer;  E,rec,pRec: ^Exp;
                 enter(start,end)
                 do fcTracer
                    (#do 'scanInv:'->TT; dopt->TL; 
                       start->II; end->II; exps.range->II #);
                    (if start > 0 then 
                        exps[start][] -> E[] (* becomes rec below *) 
                    if);
                    (for i: end - start repeat
                         start + i -> ix;
                         rec[] -> pRec[]; E[] -> rec[]; exps[ix][] -> E[];
                         inner scanInv;
                    for)
                 #);
               loadAccessor: 
                 (* R1.R2.R3 := e
                  * loadAccessor(R1.R2.R3) = pushThis, push R1.off, push R2.off
                  * R1.R2.P
                  * loadAccessor(R1.R2.P) = pushThis, push R1.off, push R2.off
                  * R3.loadAccessor: push R3.off
                  * In v * w, where v: primitive, v.loadAccessor: push v (value)
                  *)
                 (# start,end,ix: @integer; 
                 enter(start,end)
                 do fcTracer
                    (#do 'loadAccessor:'->TT; doPT->TL; start->II; end->II#);
                    (if start = 0 then 
                        exps[1][] -> loadOriginII 
                    if);
                    (start,end) -> scanInv
                    (#
                    do (if E.ATd.isPattern then
                           fcTracer
                           (#do 'loadAccessor:X:'->TT; E.doPT->TL; 
                              ('rec:',rec[])->PT(#do rec.dopt->TL #)#);
                           (if rec[] <> none then
                               (if E.isPrimitiveIntWithFloatArg
                                   and not rec.isFloat then
                                   cd.I2F
                           if)if);

                           (superAdj,0) -> E.loadArgs;
                           (pRec[],rec[],E[]) -> checkForProxy;
                           (rec[],E[],true,valueOff,staticOff,false
                           ,ix->next)
                             -> E.newInvoke;
                        else
                           fcTracer
                           (#do 'loadAccessor:Y:'->TT; E.doPT->TL; 
                              ('rec:',rec[])->PT(#do rec.dopt->TL #)#);
                           (rec[],valueOff,ix->next) -> E.loadAccessor
                 if)#)#);
               doInvoke: 
                 (# start,end: @integer;
                 enter(start,end)
                 do fcTracer
                    (#do 'doInvoke:'->TT; doPT->TL; start->II; end->II;
                       'useRtnVal:'-> TT; useRtnVal->BB #);
                    (start,end) -> scanInv
                    (#
                    do fcTracer
                       (#do 'doInvoke:X:'->TT; E.doPT->TL; start->II; end->II;
                          ix->II;('prec:',prec[])->PT(#do prec.dopt->TL #);
                          ('rec:',rec[])->PT(#do rec.dopt->TL #);
                       #);
                    
                       (pRec[],rec[],E[]) -> checkForProxy;
                       
                       fcTracer(#do 'kuk:X:'->TT; E.dopt->TL #);
                       (if rec[] <> none then
                           (if E.isPrimitiveIntWithFloatArg
                               and not rec.isFloat then
                               cd.I2F
                       if)if);
                       fcTracer(#do 'koks:Y:'->TT; E.dopt->TL #);

                       (superAdj,0) -> E.loadArgs;
                       (rec[],E[],useRtnVal,valueOff,staticOff,false,ix->next)
                         -> E.newInvoke;
                 #)#);
               E,rec,pRec: ^Exp; exps: [1] ^Exp;
               superAdj,staticOff,lastIx,valueOff: @integer;
               isValueObj,doLoad,orgIsVal,loadRec,isNotRemote: @boolean;
               useRtnVal,wasConst,originIsValueObj,doNeedOrigin,isCst: @Boolean;
            enter(useRtnVal,superAdj,staticOff,doLoad)
            do fcTracer
               (#do'handleInv:'->TT;doPT->TL;'staticOff:'->TT;staticOff->II;
                  'doLoad:'->TT; doLoad->BB;
                  'useRtnVal:'->TT; useRtnVal->BB
               #);
               cd.bcPos -> beginBCP;
               getExps -> exps[];
               (for i: exps.range repeat
                    rec[] -> pRec[]; E[] -> rec[]; exps[i][] -> E[];
                    fcTracer(#do 'handleInvII:elm:'->TT; E.doPT ->TL #);
                    false -> isCst;
                    (if true
                     // E -> isConst then
                        (* pushC E  previous path is not loaded 
                         * R1.R2.C, C + E1 * E2
                         *)
                        i  -> lastIx; true -> isCst
                     // (i < exps.range) and E.isStringLiteral then
                        fcTracer(#do 'doLoadII:i<range:StringLiteral:'->TT;
                                   E.dopt->TL#);
                        (rec[],E[],true,valueOff,staticOff,true,none) 
                          -> E.newInvoke;
                        i -> lastIx
                     // (i < exps.range) and E.ATd.isPattern 
                        (*E.isPtnWithOrigin*) then
                        fcTracer(#do 'doLoadII:i<range:'->TT; E.dopt->TL#);
                        (if E.isPtnWithOrigin then
                            fcTracer
                            (#do 'E.isPtnWithOrigin:'->TT;E.dopt->TL#);
                            (lastIx,i) -> loadAccessor;
                         else
                            (* Must invoke pattern with NO origin *)
                            (i - 1,i) -> doInvoke
                        if);
                        i -> lastIx
                     else
                        (if (E.ATd.asDecl).OG.isValueObj 
                            and not (E.ATd.asDecl).OG.isBasicValue then
                            valueOff + (E.ATd.asDecl).newOff -> valueOff;
                            (i = 1) or isNotRemote -> isNotRemote;
                         else
                            updateOffSet
                    if)if);
                    
                    (if (i = exps.range) and not isCst then
                        fcTracer
                        (#do 'doLoadII:i=range:'->TT; E.dopt->TL;
                           E.isPtnWithOrigin -> BB;
                           (E.ATd.asDecl).isPattern -> BB;
                           E.label -> TL;
                           'useRtnVal:'->TT; usertnVal->BB
                        #);
                        (if true
                         // E.isPtnWithOrigin  
                         // not (E.ATd.asDecl).isPattern then 
                            (if (E.bracketedListElement <= 1) then
                                (lastIx,i - 1) -> loadAccessor;
                        if)if);
                        (if doLoad then
                            (i - 1,i) -> doInvoke
               if)if)for);
               cd.bcPos -> endBCP               
            exit(E[],valueOff,isNotRemote)
            #);
          gen:: 
            (# Ex: ^Exp; isNotRemote: @Boolean;
            do (* for P1.X := P2.Y,
                * we need no origin for P1 (and X!?)
                * we need adress of P1 to be added address of X to get embedded
                * adr of X
                * In R.foo, if foo has globalRestrictions we shall not 
                * load adr of R
                * How about: R.S.T.Q ? Q globalRestrictions, or globals?
                *)
               (useRtnVal,superAdj,staticOff,true) 
                 -> handleInv
                 -> (Ex[],valueOff,isNotRemote);
               
               fcTracer(#do 'INV:gen:end:'->TT; dopt->TL; valueOff->II #);
                   
               (* this is a temporary solution - OI adr.off is used by
                * pushValue in handleNonVirtualArg - gen should probably
                * return valueOff instead of OI adr
                *)
            #);
          loadArgs::
            (#
            do fcTracer(#do 'Invocation:loadArgs:'->TT; doPT -> TQ #)
            #);
          isConstant: BooleanValue
            (* Not good enough for 
             * V: obj 12; W: obj 87; X: obj V + W;
             * we dont push 12 for V, but 87 for W
             *)
            (# T: @text; cst: @integer
            do cTracer(#do 'isConstant:'->TT; label->TQ; dopt->TQ #);
               L:
                 scanSons
                 (# E: ^Exp; DI: ^SuperDataItem
                 do current[] -> E[];
                    (if (E.ATd.asDecl).isDataItem (*or E.ATd.isModuleItem*) then
                        E.ATd.asDecl -> DI[];
                        (if DI.isConst then
                            (if isLast then
                                (if DI.OG.isBasicValue then
                                    (if (DI.OG.super.last->E[]).isConstLiteral then
                                        (if true then
                                            DI.pushConst -> cst;
                                            cTracer
                                            (#do 'constLiteral:'->TT; cst->II #);
                                         else
                                            DI.OG.super.dopt -> T.puttext;
                                            cTracer
                                            (#
                                            do 'const literal: ' -> TT;
                                               T[] -> TT;
                                               ' ' -> TT;
                                               (DI.OG.super.last).label -> TT
                                            #);
                                            T.setPos; 
                                            T.getInt -> cd.pushConst;
                                        if);
                                        true -> value
                                    if)
                                 else
                                    leave L
                            if)if)
                         else
                            cTracer(#do 'notConst:'->TT;E.dopt->TT;DI.dopt->TT#);
                            leave L
                        if)
                     else
                        leave L
                 if)#)
            #);
          loadOrigin:
            (# useRtnVal: @boolean;
               staticOff,superAdj: @integer;
               rec,E,nE: ^Exp;
            enter(useRtnVal,staticOff,superAdj)
            do pfcTracer(#do 'DO we come here? INV:loadOrigin:'->TT; doPT->TT#);
               (* could rec be thisObject for first E1 in E1.E2.E3 ?*)
               (* Perhaps the other way around
                * e1 -> rec
                * rec -> e2.invoke
                * e2 -> rec
                * rec -> e3.invoke
                *)
               scanSons
               (# gdb: debug
                    (#
                    do 'Invocation:loadOrigin:scan: ' -> TT;
                       current.doPT -> TL;
                    #);
                  T: ^ Text; orgIsVal: @boolean
               do current[] -> E[]; 
                  gdb;
                  (if isFirst then 
                      E.pushThis;
                      (superAdj) -> E.loadOrigin -> (rec[],E[],orgIsVal)
                  if); 
                  (* For X: = { R:  = { ... q: ...} ... R.X }
                   * stack[top] = origin = X 
                   * add offset to R or push(ref(R))
                   *)
                  cTracer(#do 'loadOrigin:afterIsFirst:'->TT;current.doPT->TQ#);
                  (if not isLast then
                      E[] -> rec[];
                      cTracer(#do'loadOrigin:loadArgs:superAdj:E:'->TT;
                                superAdj -> II #);
                      (superAdj,staticOff) -> E.loadArgs;
                      (rec[],nE[],true,staticOff,0,false,none) ->E.newInvoke
                   else
                      cTracer(#do 'loadOrigin:last:' -> TT; current.doPt ->TQ;
                               'rec:'->TT; rec.doPT -> TT; 
                               ':E:'->TT; E.doPT -> TT #);
                      (if not isFirst then
                          (rec[],rec[],true,staticOff,0,false,none)
                            -> rec.newInvoke
               if)if)#);
               (* S.simple_bar.c1 := 'x'
                *     rec = c1, E = ':='
                *     No pushOff for c1 = rec, since E = ':='
                *     no loadAsReceiver for c1 = rec
                * S.simple_bar.c1 + 1
                *     rec = c1, E = ':='
                *     pushOff for c1 = rec, but empty action
                *     loadAssReceiver for c1, since simple
                * S.simple_bar.simple_fisk;
                *     rec = simple_bar, E = simple_fisk
                *     pushOff for simple_bar = rec
                *     loadAsReceiver for simple_bar, but empty action
                *)
            exit(rec[],E[])
            #);
          goInclude:<
            (*    %include Q.R
             *    ...
             *    %include S.T
             *    ...
             *    U
             * means: Q.R,S.T.U
             *)
            (# org: ^Items; onx: @integer; orgIsVal: @boolean;
               MI: ^ModuleItem; OI: ^ObjectInvocation; ATdx: ^Decl
            enter(org[],onx)                       
            do cTracer(#do 'IV:viaIncl:on:' -> TT; on -> II; dopt -> TQ;
                        ' org:'->TT; org.dopt -> TL; 
                     #);
               scanSons
               (#
               do current[] -> OI[];
                  cTracer(#do 'viaIncl:son:isFirst:'->TT; isFirst->BB;
                           'viaIncl<>none:'->TT; OI.ptnId.viaIncl[] <> none->BB;
                           current.dopt -> TQ;
                        #);
                  (if isFirst then
                      (if OI.ptnId.viaIncl[] <> none then
                          (org[],on + 1) 
                            -> OI.ptnId.viaIncl.goInclude 
                            -> (org[],orgIsVal)
                       else
                          (onx + OI.on + 1,OI[]) 
                            -> org.goOrigin  -> (org[],orgIsVal);
                  if)if);
                  OI.ATd.asDecl -> ATdx[];
                  (if nameListInDcl then
                      (ATdx.sig.id[],
                      ((ATdx[]->MI[]).MD.sig.names.firstDecl).newOff) 
                        -> cd.rpushg
                   else
                      (ATdx.sig.id[],(ATdx[]->MI[]).MD.newOff) -> cd.rpushg
                  if)
               #)
            exit(org[],orgIsVal)
            #);
       #);
     adjustOrigin:
       (# originOff: @integer; OGid: ^text
       enter(originOff,OGid[])
       do (if (originOff > 0) then
              cTracer(#do 'AdjustOrigin:originOff:'  -> TT; originOff -> II #);
              (OGid[],originOff) -> cd.rpushg
          if)
       #);
     ObjectInvocation::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# pushThis:: (# do (ATd.asDecl).pushThis #);
          isPtnWithOrigin:: (# do ATd.isPtnWithOrigin -> value #);
          getAdr::
            (# gdb:: 
                 (# DI: ^DataItem
                 do '>ATd.off:'->TT;
                    (if ATd.isDataitem then
                        (ATd[]->DI[]).newOff -> II
                     else
                        '0 (isPtn)'->TT
                    if);
                    ':on:'->TT; on->II;
                    ':superAdj:'->TT; adr.superAdj->II;
                    ATd.dopt -> TL; adr.toString->TT
                 #);
               isVeqDI: BooleanValue
                 (# org: ^Items; eOG: ^ObjectGenerator
                 enter org[]
                 do (if org.superDesc[] <> none then
                        ((org.superDesc.primNo = vEq_prim) 
                          or (org.superDesc.primNo = vLE_prim))
                         and (ATd.asDecl).isDataitem
                          -> value
                    if)
                 #);
               getOIqual:
                 (* IV = this(OI).father = R1.R2...Rn
		  * this(OI)= Ri for some i
                  * Compute R1.R2...Ri
		  * It might be more efficient if qual and OGSx are
		  * parameters/returns of getAdr
                  *)
                 (# IV: ^Exp(*Invocation*); qual: ^ObjectGenerator;
                    OGsx: ^OGsequence; 
                 do father[] -> IV[];
                    (if traceGetVqual then
                        '**** OI:getOIqual: "'->puttext; dopt -> puttext;
                        '" IV:"' -> puttext; IV.dopt -> puttext;
                        '"\n**   origin.encOG: '->puttext;
                        origin.encOG.dopt -> putheadN;
                    if);
                    (origin.encOG -> qual[],false,none)
                      -> OGsequence -> OGSx[];
                    L:
         	       IV.scanSons
                       (#
                       do (qual[],not isFirst,OGSx[])
		             -> current.getVqual -> (OGSx[],qual[]);
			  (if current[] = this(ObjectInvocation)[] then
			      leave L
                        if)#);
                 exit qual[]
                 #);                  
               Ax: ^Address; OG: ^ObjectGenerator; DI: ^DataItem;
               qual: ^ObjectGenerator; T: ^Text
            do getOIqual -> qual[];
               (if origin.isItems
                   and (origin.origin.encOG.primNo = String_prim)
                   or ((qual.primNo = String_prim))
		   (* can we elim the first or-clause? *)
                   then
                   cTracer
                   (#do 'PING:String'->TT; origin.encOG.primNo -> II;
                      origin.encOG.dopt ->TT #);
                   L:
                     (if (origin[]->isVeqDI) or (qual.primNo = String_prim) then
                       cTracer(#do'BOBS:ATd:'->TT; ATd.dopt->TQ; #);
                       (if (ATd.asDecl).isDataItem 
                           and ((ATd.asDecl->DI[]).newOff = 2) then
                           DI.dopt -> T[];
                           (if not ('in Veq: var this(Value)' ->T.equalNCS) then
                               cTracer(#do 'Is not: in Veq: var this(Value)'
                                          ->TT #);
                               leave L
                           if);
		          (* newOff = 2 is a dirty hack
			   * we should test if DI = in Veq: var this(Value);
                           * we do that now, but still a hack
			   *)
                           cTracer(#do 'String:vEq: '->TT; dopt -> TQ;
                                    'off: ' -> TT; (ATd[]->DI[]).newOff -> II;
                                    'ATd:'->TT; ATd.dopt -> TL;
                                 #);
                           DI.newOff ->  adr.off;
                           false -> adr.isValue;
                           true -> adr.isAdr;
                           leave getAdr
               if)if)if);
               adr[] -> Ax[];
               (if (on > 0) or (Ax.E[] = none) then
                   this(ObjectInvocation)[] -> Ax.E[];
                   (* tricky - in R.S.Q, R.on may be > 0, but S.on = Q.on = 0
                    * and the latter must not override on from R and E = R!
                    *)
               if);
               (* here we should check if we can elim asDecl in the call
                * of this OI:getAdr!
                *)
               (if nameListInDcl 
                   and (Atd.sig[] <> none) 
                   and (ATd.sig.names[] <> none) 
                   and (ATd.sig.names.firstDecl <> none) then
                   Ax[] -> (ATd.sig.names.firstDecl).getAdr -> (loadRec,adr[]);
                else
                   Ax[] -> ATd.getAdr -> (loadRec,adr[]);
               if);
            #);
          getNewOff:: (# do ATd.getNewOff -> off #);
          loadOrigin::
            (# gdb::
                 (#
                 do '>on:'->TT; on -> II; ' superAdj:'->TT; superAdj->II;
                    ' isValueObj:'->TT; ATd.OG.isValueObj->BB
                 #);
               org: ^Items; T: @text; MI: ^ModuleItem;  orig: ^Scope
            do (if (ATD.asDecl).primNo
                // 0 
                // indexed_prim 
                // rIndexed_prim
                // string_prim
                // stringGet_prim // indexedGet_prim
                // immutable_prim then
                   ATd.origin[] -> orig[];
                   (if orig.isItems then orig[] -> org[] if);
                   (# hasValueObj: @boolean; T: ^Text
                   do (if on > 0 then
                          (if false then
                              '**** loadOrigin: '->T[]; dopt -> T.puttext;
                              ' on: '->T.puttext; on -> T.putint; 
                              T.newline;
                              origin[] -> org[];
                              (for i: on + 1 repeat
                                   org.encOG.OGid -> T.puttext; 
                                   (if org.encOG.isValueObj then 
                                       ' True '-> T.puttext; 
                                       true -> hasValueObj
                                    else
                                       ' False '->T.puttext
                                   if);
                                   org.newOriginOff -> T.putint; T.newline;
                                   org.origin[] -> org[]
                              for);
                              (if hasValueObj then
                                  T[] -> putline
                   if)if)if)#);     
                   (if superAdj < 0 then 
                       cTracer(#do 'superAdj:A'->TT #);
                       (if on >= 0 then (* OBS! Used to be on > 0, but if on=0,
                                         * we still need to adjust origin! *)
                           cTracer(#do 'superAdj:B'->TT #);
                           (if (on = 0) and (ATd.asDecl).isParameter then
                               cTracer(#do 'superAdj:C'->TT #);
                            else
                               cTracer(#do 'superAdj:D'->TT #);
                               (-superAdj,'origin-x') -> AdjustOrigin;
                           if);
                           (on - 1,this(ObjectInvocation)[]) 
                             -> (origin[]->org[]).goOrigin
                             -> (org[],orgIsVal)
                       if)
                    else
                       cTracer(#do 'superAdj:E'->TT #);
                       (superAdj,(origin[]->org[]).encOG.OGidWdNo)
                         -> AdjustOrigin;
                       (on,this(ObjectInvocation)[]) 
                         -> (origin[]->org[]).goOrigin
                         -> (org[],orgIsVal)
                   if);
                   (if ptnId.viaIncl[] <> none then
                      (org[],0) -> ptnId.viaIncl.goInclude
                   if)
                // this_prim then
                   (* Must check that argument is the name of an enclosing 
                    * object or the name of the superpattern of an
                    * enclosing object.
                    * For %this foo, ON = %this.origin, A.super.ON = foo.origin
                    *)
                   (superAdj,'origin-z') -> AdjustOrigin;
                   args.scanArgs(* only one argument in %this foo *)
                   (# A: ^ObjectSpecification
                   do current[] -> A[];
                      cTracer
                      (#do 'this_prim:'->TT; A.dopt -> TT;
                         ':super.on:'-> TT; A.super.ON -> II #);
                      (A.super.on - 1,this(ObjectInvocation)[])
                        -> (origin[]->org[]).goOrigin
                        -> (org[],orgIsVal)
                   #)
                // thisCore_prim then 
                   (* perhaps not in loadOrigin, but in execute/ATd.invoke *)
                   ('thisCore',thisCore_prim) -> cd.callPrim
                // thisCoreId_prim then
                   ('thisCoreId',thisCoreId_prim) -> cd.callPrim
               if);
               (* Actually rec = origin*n, E = this(OG) *)
               this(ObjectInvocation)[] -> E[] -> rec[]
            #);
          load::
            (#
            do cTracer
               (#do 'OI:load:'->TT; dopt->TT; ':unit: '->TT; unit.T[]->TT#);
               (rec[],A[]) -> (ATd.asDecl).load
            #);
          handleVargs::
            (# actArgs: [6] ^ObjectSpecification; (* actual arguments *)
               top: @integer; ptn: ^pattern; 
               enclosingOG: ^ObjectGenerator; OGx: ^ObjectSpecification;
               formalArg: ^Pattern; actualArg: ^ObjectSpecification; 
               descNo: @integer; 
               mkCom:
                 (# msg: ^text
                 enter msg[]
                 do cTracer
                    (#do msg[]->TT;  dopt -> TL; nl;
                       'formalArg: '-> TT; formalArg.dopt -> TQ; nl;
                       'actualArg: '-> TT; actualArg.dopt -> TQ; nl;
                       formalArg.off -> II;
                       ' (actualArg.desc).newDescno: '->TT; descno ->II;
                       ' (OGx.desc).newDescNo: '->TT; (OGx.desc).newDescNo->II;
                    #);
                 #);
            do (if ((ATd.asDecl)->ptn[]).OG.primNo
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   leave handleVargs
               if);
               args.scanArgs
               (#
               do (if (top+1 -> top) > actArgs.range then 
                      actArgs.range -> actArgs.extend 
                  if);
                  current[] -> actArgs[top][];
               #);
               ptn.scanArgs
               (# argInx,dNo: @integer; stubN,stubS,OGidx: ^text; zero: @boolean
               do argInx + 1 -> argInx; 
                  (if (argInx <= top) and currentArg.isVirtual then
                      currentArg[] -> formalArg[];
                      actArgs[argInx][] -> actualArg[]; 
                      cTracer(#do 'args: ' -> TT; currentArg.dopt->TQ;  
                               actualArg.dopt->TQ ; ptnid.dopt -> TT; #);
                      (* can we do currentArg.LoadArg?
                       * And then perhaps special for virtual primitive
                       * and ptName? Virt is of course ptn *)
                      L:
                        (if currentArg.isVirtual then
                            currentArg[] -> formalArg[];
                            actArgs[argInx][] -> actualArg[];
                            (if true then
                                enclosingObjectGenerator -> OGx[]
                             else
                                father.father[] -> OGx[];
                            if);
                            (if OGx.IS.hasGlobals then
                                (if false then
                                    '**** hasGlobals:C: ' -> puttext;  
                                    ' vDescNo: ' -> puttext;
                                    actualArg.vDescNo -> putint; newline;
                                    doPT -> putHeadN;
                                    '**** encOGx: ' -> puttext; 
                                    OGx.dopt -> putHeadN; 
                                if);
                                leave L
                            if);
                            (if actualArg.IS.isEmpty then
                              actualArg.vDescNo -> dNo;
                              (none,actualArg[]) 
                                -> mkStubName -> (stubN[],stubS[]);
                              (if false then
                                  '**   bind: ' -> puttext; 
                                  StubN[] -> puttext;
                                  ' dNo: ' -> puttext; dNo -> putint; 
                                  ' off: '-> puttext;
                                  formalArg.off -> putint; 
                                  ' newDescNo: ' -> puttext;
                                  (OGx.desc).newDescNo -> putint; newline;
                              if);
                              (formalArg.off,dNo,(OGx.desc).newDescNo,'xx')
                                  -> CD.vdtTableAt;
                              (stubN[],dNo,actualArg[],OGx.IS[]) 
                                  -> objStubStackX.add;
                             else
                              (actualArg.desc).newDescno -> descNo;
                              (if false then
                                  cTracer(#do 'arg:hasItems: ' -> TT #);
                                  '**   descNo: ' -> puttext; 
                                  descNo -> putint;
                                  ' (OGx.desc).newDescNo:' -> puttext;
                                  (OGx.desc).newDescNo -> putint; 
                                  ' OGx.IS.newDescNo: ' -> puttext;
                                  OGx.IS.newDescNo -> putint;
                                  ' ' -> put;
                                  (OGx.super.last).ATd.OG.IS.newDescNo 
                                    -> putint;
                                  newline;
                                  '**   ATd: '->putline;
                                  (OGx.super.last).ATd.dopt -> putline;
                                  '**   OGx: ' -> putline;
                                  OGx.dopt -> putline; '---' -> putline;
                                  (OGx.desc).encOG.dopt -> putline;
                                  true -> zero
                              if);
                              L:
                                OGX.super.scanExps
                                (# OI: ^ObjectInvocation
                                do (if zero then current.dopt ->putline if);
                                   current[] -> OI[];
                                   (if zero then OI.args.dopt ->putline if);
                                   (if args[] = OI.args[] then
                                       (if zero then true -> putboolean;
                                           ' ' -> puttext
                                       if);
                                       (OI.ATd.asDecl).OG.IS.newDescNo -> dNo;
                                       (OI.ATd.asDecl).OG.OGid -> OGidx[];
                                       (if zero then 
                                           dNo -> putint;
                                           newline;
                                           OI.ATd.dopt -> putline
                                       if);
                                       leave L
                                if)#);
                              (if stubDescNo > 0 then
                                  (formalArg.off,descno,stubDescNo,'yy')
                                    -> cd.vdtTableAt;
                               else
                                  (formalArg.off,descno
                                  ,(OGx.desc).newDescNo
                                  ,(actualArg.desc).encOG.OGid)
                                    -> cd.vdtTableAt;
               if)if)if)if)#)
            #);
         loadAccessor::
            (#
            do fcTracer(#do 'OI:loadAccessor:'->TT; dopt->TL #);
               (rec[],valueOff,next[]) -> ATd.loadAccessor
            #);
          newInvoke::
            (# stubDescNo,rtnOff: @integer
            do fcTracer(#do 'OI:newInvoke:'->TT; doPT -> TL #);    
               (if hasVirtualArgs then
                   (* the code here should be in gPTN:newinvoke,
                    * but we then need to move handleVargs there too
                    *)
                   pfcTracer
                   (#do 'OI:newInvoke:NonVirtual:hasVirtualArgs:'->TT; 
                      dopt->TL #);                   
                   (ATd.asDecl,'',QnewDesc->stubDescNo,
                   (ATd.asDecl).OG.IS.newDescNo,0,0)
                     -> ObjStubStack.add;
                   stubDescNo -> handleVargs;
                   ('stub',stubDescNo,4,0,false) ->  cd.invoke; 
                   (if useRtnVal then
                       ((ATd.asDecl).OG[],'stub') -> pushOut -> rtnOff;
                       fcTracer(#do 'OI:after:pushOut:'->TT; rtnOff->II #);
                   if);
                else
                   (rec[],E[],useRtnVal,valueOff,staticOff,isAdr,next[]) 
                     -> ATd.newInvoke
               if);
            #);
          loadArgs:: 
            (# gdb:: 
                 (#
                 do '>staticOff:' -> TT; staticOff -> II; ' '->TT;
                    ATd.dopt -> TL; ' superAdj:'->TT; superAdj -> II;
                    args.scanArgs(#do 'arg:'->TT; current.dopt -> TL #)
                 #)
            do (this(Exp)[],superAdj,staticOff) -> (ATd.asDecl).loadArgs
            #);
          adjustEmbodied::
            (* if this OI is accesed throuh an embodied object, then push
             * the address of the embodied object to get its address
             *)
            (# OI: ^ObjectInvocation
            do (if isEmbodied then
                   cTracer(#do 'OI:adjustEmbodied:'->TT; isEmbodied -> BB; 
                             theEmbodied.dopt->TQ; theEmbodied.newOff -> II #);
                   ('embody',theEmbodied.newOff) -> cd.rpushg
               if)
            #);
          bracketedListElement:: 
            (* Used by generator for assigment to Indexed/Rindexed
             * to check whether or not source is a an Indexed object
             * or a list of elements
             * R: ref Indexed
             * S: ref Indexed
             * R := S     return zero (0)
             * R := (...,foo,...) where foo = this(OI) return one (1)
             *)
            (# D: ^Decl 
            do (if (ATd.asDecl).OG.primNo 
                // indexed_prim // rIndexed_prim // dumpObj_prim then
                else
                   (if ((ATd.asDecl).OG.getReturnDecl-> D[]) <> none then
                       (if D.OG.primNo
                        // indexed_prim // rIndexed_prim // dumpObj_prim then
                           leave bracketedListElement
                   if)if);
                   cTracer(#do 'OI:bracketedListElement: ' -> TT;
                            dopt -> TQ; ' ATd.OG.primNo: '-> TT;
                            ATd.OG.primNo -> II;
                            'return:'->TT;
                            (*((ATd.asDecl).OG.getReturnDecl).dopt -> TT*)
                         #);
                   1 -> value 
       if)#)#);    
     LabelDecl::
       (# gen::
            (#
            do cd.bcPos -> beginBCP;
               (false,0,0) -> OG.gen;
               cd.bcPos -> endBCP;               
            #)
       #);
     IfThen::
       (# gen::
            (# Tlab, Flab, exitLab: @ LabelHandler.label
            do (if false then
                   '**** IfThen:gen ' -> puttext; dopt -> putline;
               if);
               (*118 -> cd.pushConst; cd.vPop;*)
               Tlab.new;
               Flab.new;
               exitLab.new;
               (true,0,staticOff) -> cond.gen;
               (Tlab,Flab) -> cd.jmpFalse;
               Tlab -> cd.defLab;
               (false,0,staticOff) -> thenPart.gen;
               Flab -> cd.defLab;
            #);
         loadAccessor::
            (#
            do pfcTracer(#do 'IfThen:loadAccessor:'->TT; dopt->TL #)
            #);

          newInvoke::
            (#
            do fcTracer(#do 'IfThen:newInvoke:'->TT; dopt -> TL #);
               gen
            #)
       #);
     IfThenElse::
       (# gen::
            (# Tlab, Flab, exitLab: @ LabelHandler.label
            do (if false then
                   '**** IfThenElse:gen ' -> puttext; dopt -> putline;
               if);
               Tlab.new;
               Flab.new;
               exitLab.new;
               (true,0,staticOff) -> cond.gen;
               (Tlab,Flab) -> cd.jmpFalse;
               Tlab -> cd.defLab;
               (false,0,staticOff) -> thenPart.gen;
               exitLab -> cd.jmp;
               Flab -> cd.defLab;
               (false,0,staticOff) -> elsePart.gen;  
               exitLab -> cd.defLab
            #);
         loadAccessor::
            (#
            do pfcTracer(#do 'IfThenElse:loadAccessor:'->TT; dopt->TL #)
            #);
          newInvoke::
            (#
            do fcTracer(#do 'IfThenElse:newInvoke:'->TT; dopt -> TL #);
               gen
            #)
       #);
     BinaryExp::
       (# trace: (#exit false #);
          unitOfRightArg: BooleanValue
            (# rU: ^text; n: @integer; OGx: ^ObjectGenerator
            do L:
                 M.args.scanArgs
                 (#
                 do n + 1 -> n;
                    (if n = 1 then
                        current.getExpUnit -> rU[];
                        (*current.label -> dumptN;*)
                        (if current.isObjectGenerator then
                            current[] -> OGx[];
                            (* OGx.isUnitValueObj -> putboolean; newline;*)
                            OGx.isUnitValueObj or OGx.isFloat -> value
                        if)
                     else
                        leave L
                 if)#)
            #);
          checkI2F:
            (# lU: ^text
            do leftRec.getExpUnit -> lU[];
               (if lU[] <> none then
                   (if true
                    // '#I'->lU.equal then
                       cTracer(#do 'left:#I' -> TT; dopt->TQ #);
                       (if unitOfRightArg then
                           cTracer(#do 'left:#I2F' -> TT;#);
                           (* true-> putBoolean; newline;*)
                           cd.I2F
                       if)                            
                    // '#F'->lU.equal then
                       (if false then
                           '!!!! checkI2F:' -> dumpT; dopt -> dumpT;
                           ' lU:'->dumpT; lU[] -> dumpT;
                           'not handled'->dumpTN
               if)if)if)
            #);
          gen:: 
            (# A,Madr: ^Address; MP: ^Module; vOff: @integer
            do (if trace then
                   '**** BinaryExp:gen: ' -> puttext; dopt -> putline;
               if);
               fcTracer(#do 'BinaryExp:gen:'->TT; dopt->TQ#);               
               (true,0,0) -> leftRec.gen -> (MP[],vOff(*A[]*));
               fcTracer(#do 'BinaryExp:gen:before:loadargs'->TT; dopt->TQ#);
               fcTracer(#do 'A:'->TT; (if A[] <> none then A.toString -> TT if)#);
               (M[],superAdj,staticOff) -> (M.ATd.asDecl).loadArgs;
               (* Address->A[]; (* ??? *)
               (M[],M[],true,staticOff,0,false,none) -> M.newInvoke;(*->Madr[]*)
               fcTracer(#do 'BinaryExp:gen:before:end'->TT; dopt->TQ#);
               fcTracer(#do 'Madr:'->TT; 
                         (if Madr[] <> none then Madr.toString -> TT if)#)
            #);
          loadOrigin::
            (#
            do (if trace then
                   '**** BinaryExp:loadOrigin:empty:' -> puttext; doPT->putline
               if);
               fcTracer(#do 'BinaryExp:loadOrigin:empty:'->TT; dopt->TQ;
                      'superAdj:'->TT; superAdj->II #);
            #);
          loadArgs::
            (*  V := BE where BE = this(BE)
             *  V := e1 + e2, thrm(BE) e1 + e2
             *)
            (# MP: ^Module; A: ^Address; valueOff: @integer
            do (if trace then
                   '**** BinaryExp:loadArgs: ' -> puttext; doPT -> putline;
               if);
               fcTracer(#do 'BinaryExp:loadArgs:'->TT; dopt->TL;
                         'superAdj:'->TT; superAdj->II #);
               (true,superAdj,0) -> leftRec.gen ->(MP[],valueOff(*A[]*));
               
               checkI2F;
               fcTracer(#do 'BinaryExp:loadArgs:after:leftRec.gen:'->TT;
                         (if A[] <> none then A.toString -> TT if)#);
               (M[],superAdj,staticOff) -> (M.ATd.asDecl).loadArgs;
               fcTracer(#do 'BinaryExp:loadArgs:end:'-> TT;
                         (if A[] <> none then A.toString -> TT if)#);
            #);
          bracketedListElement:: (#do 1 -> value #);
          loadAccessor::
            (#
            do fcTracer(#do 'BinaryExp:loadAccessor:'->TT; dopt->TL #)
            #);
          newInvoke:: 
            (#do fcTracer(#do 'BinaryExp:newInvoke:missing'->TT; dopt->TL #)
            #)
       #);
     UnaryExp::
       (# gen::
            (#
            do (if false then
                   'UnaryExp:gen'->dumpT; dopt -> dumpTN;
               if);
               (* this is not really understood! *)
               loadArgs
            #);
          loadOrigin::
            (#
            do (if false then
                   'UnaryExp:loadOrigin:'->dumpT; dopt -> dumpTN;
               if)
            #);
          loadArgs::
            (#
            do (if false then
                   'UnaryExp:loadArgs:'->dumpT; dopt -> dumpTN;
               if);
               cTracer(#do 'UnaryExp:loadArgs:'-> TT; dopt->TQ #);
               (true,superAdj,0) -> trm.gen;
               cTracer(#do 'UnaryExp:loadArgs:after:'-> TT; dopt->TQ #);
               (if true 
                // '!' -> op.T.equal then
                   not_prim -> cd.op
                // '-' -> op.T.equal then
                   (if theQual.primNo
                    // integer_prim then
                       cd.uMinus 
                    // float_prim then
                       137 (*fUnaryMinus*)  -> cd.op;
                   if)
                // '+' -> op.T.equal then
               if)
            #);
          bracketedListElement:: (#do 1 -> value #)          
       #);
     BracketedExp::
       (* a := b + (c * d)
        *     execute c * d
        * (foo).x
        *    loadOrigin foo
        * (foo(e1,e2)).x
        *    execute foo(e1,e29?
        * (%this P).suspend
        *     loadOrigin?
        * (E1)
        *    (E1).pushThis
        *    (E1).loadOrigin
        *    (E1).invoke
        *    rec -> E.invoke
        * (E1).E2
        *    
        * (R.S).foo
        * (R.bar(e1,e2,)).foo  
        * (ch = 'i') && (S <> none)
        * Do we always execute exp in (exp) and (exp).foo?
        * We should thus not just call load origin!?
        * What about (exp), (R.foo)
        * Look at gen: for (exp) we call loadOrigin and then execute
        *   for (exp).foo we call loadOrigin(exp) and then exe on foo
        *   but exe(exp) is not called
        *   How do we in loadOrigin ensure that exe(exp) is called when needed?
        * 
        * E1.(E2)
        * E1.(E2).E3
        *)
       (# gen:: 
            (#
            do (* we dont come here 
                * but we do for indexed literal like (e1,e2,e3) *)
               fcTracer(#do 'BracketedExp:gen:'->TT; doPT->TL #);
               (if noOfSons = 1 then
                   (useRtnVal,superAdj,staticOff) -> IV.gen ;
                else
                   scanSons
                   (#
                   do (useRtnVal,superAdj,staticOff) -> current.gen 
                   #);
               if)
            #);
          getAdr::
            (# rec,E: ^Exp
            do pfcTracer
               (#do '!!!! Should not com here:'->TT; nl;
                  'BracketedExp:getAdr:'->TT; dopt -> TL; #)
            #);
          pushThis:: 
            (* Skip, since loadOrigin below includes pushThis *)  
            (# #);
          loadOrigin:: 
            (# off: @integer; A: ^Address
            do pfcTracer(#do 'bracketedExp:loadOrigin:'->TT; dopt->TL #);
            #);
          loadArgs:: 
            (* Skip, since loadOrigin includes loadArgs *)              
            (# 
            do fcTracer(#do 'BracketedExp:loadArgs: ' -> TT; dopt -> TT #);
            #);
          newInvoke::
            (#
            do fcTracer(#do 'Bracketed newInvoke: ' -> TT; dopt->TT;
                           'useRtnVal:'->TT; useRtnVal-> BB;
                           'staticOff:'->TT; staticOff->II #);
               (if noOfSons = 1 then
                   (useRtnVal,0,staticOff) -> IV.gen
                else
                   scanSons
                   (#
                   do (useRtnVal,0,staticOff) -> current.gen
            #)if)#)
       #);
     Const::
       (# gen:: (# do newInvoke #);
          getAdr::
            (# 
            do this(Const)[] -> adr.E[]
            #);
          load:: (# do T.setpos; T.getReal -> cd.pushConst #);
          bracketedListElement:: (# do 1 -> value #);          
          pushConst::
            (#
            do T.setPos; 
               T.getInt -> value -> cd.pushConst
            #)
       #);
     FloatConst::
       (# gen:: (# do newInvoke #);
          getAdr::
            (# 
            do this(FloatConst)[] -> adr.E[];(* 2 -> adr.size???*)
            #);
          newInvoke:: 
            (# 
            do (if false then               
                   '****newInvoke ' -> puttext; dopt -> putline;
                   ' unit: ' -> puttext; unit.T[] -> putline;
               if);
               T.setpos; T.getReal-> cd.pushFloatConst; 
               (if convFactor <> 0 then
                   convFactor -> cd.pushFloatConst;
                   112 -> cd.op
            if)#);
          load:: (#do newInvoke #);
          bracketedListElement:: 
            (# 
            do 1 -> value;
               fcTracer(#do 'Float:bracketedListElement may not work!'->TT;
                          dopt -> TL #)
            #);
          pushConst::
            (# F: @Real
            do T.setPos; 
               T.getReal -> F -> cd.pushFloatConst;
               F -> value (* is truncated to integer *)
            #)
       #);
     CharObj::
       (# gen:: (* Never called? *) (# do newInvoke #);
          pushThis:: (##);
          getAdr:: (#do this(CharObj)[] -> adr.E[] #);
         loadAccessor::
            (#
            do fcTracer(#do 'CharObj:loadAccessor:'->TT; T[]->TL #)
            #);
          newInvoke:: 
            (# ch: @char
            do (if T.length = 1 then
                   1 -> T.inxget -> cd.pushConst 
                else
                   (if 2 -> T.inxget -> ch
                    // 'n' then 10 -> cd.pushConst
                    // 't' then 9 -> cd.pushConst
                    // '\\' then '\\' -> cd.pushConst
                    // '\'' then '\'' -> cd.pushConst
                    else
                       'CharObj:Special symbol: ' -> puttext; ch -> putint;
                       ':' -> put; '"' -> put; ch -> put; '"' -> put;
                       newline;
                       ch -> cd.pushConst
               if)if)
            #);
          bracketedListElement:: (# do 1 -> value #);
          pushConst:: 
            (#
            do 1 -> T.inxGet -> value -> cd.pushConst
            #);

       #);
     getStringPlus:
       (# D: ^Decl
       do L:
            stringDecl.OG.IS.scanSons
            (# 
            do (if current.isDecl then
                   current[] -> D[];
                   (if ('+' -> D.sig.id.equal) then
                       D.markForCodeGen;
                       leave L
            if)if)#)
       exit D[]
       #);
     StringObj::
       (# gen:: 
            (* Never called ? *)
            (# do 'StringObj:gen:' ->puttext; doPT -> putline; newInvoke #);
          loadOrigin::
            (* In "hello".foo, "hello" plays the same role as R in R.foo,
             * i.e. we must generate a pushText "hello"
             * For an exp "Hello", 
             * loadOrigin then also generates a pushText "hello"
             * Invoke is called only for the last exp in R1.R2.exp 
             * and 'just store the string!
             *)
            (# 
            do fcTracer(#do 'StringObj:loadOrigin:' -> TT; dopt->TT; #);
               this(StringObj)[] -> E[] -> rec[]
            #);
          getAdr:: (#do this(StringObj)[] -> adr.E[]; (*T[]->cd.pushText*)#);
          newInvoke:: 
            (# stringDescNo,n: @integer; (* no of embedded invocations in T*)
               start,end: [4] @integer; 
               prev: @integer;
               doAdd: @boolean;
               plusDecl: ^Pattern;
               getPlusRes:
                 (#
                 do L:
                      plusDecl.OG.IS.scanAllItemDecls
                      (# DI: ^DataItem
                      do (if currentDcl.isOutArg then
                             currentDcl[] -> DI[];
                             (if true
                              // DI.OG.isBasicValue then
                                 (if nameListInDcl then
                                     (T[],(DI.sig.names.firstDecl).newOff) 
                                       -> cd.pushg;
                                  else
                                     (T[],DI.newOff) -> cd.pushg;
                                 if)
                              // DI.OG.isValueObj then
                                 '**** out arg: ' -> puttext; DI.dopt ->putline;
                                 DI.newOff -> cd.pushConst
                              else
                                 (if nameListInDcl then
                                     (T[],(DI.sig.names.firstDecl).newOff) 
                                       -> cd.rPushg;
                                  else
                                     (T[],DI.newOff) -> cd.rPushg;
                                 if)
                             if);
                           leave L
                 if)#)#)
            do getStringPlus -> plusDecl[];
               (stringDecl.desc).newDescNo -> stringDescNo;
               T[] -> scanForBrace
               (# pos: @integer
               do (*'*** gen got brace: ' -> puttext; inn[] -> putline;*)
                  n + 1 -> n;
                  first -> start[n];
                  last -> end[n];
                  (*first -> putint; ' ' -> put; last -> putint; newline;
                  (1,first - 1) -> T.sub -> puttext; '#' -> put;
                  (first,last) -> T.sub -> putline;*)
               #);
               scanSons
               (# S: ^Text; n: @integer; 
               do n + 1 -> n;
                  (prev + 1,start[n] - 1) -> T.sub -> S[];

                  (S[],stringDescNo) -> cd.pushText;
                  (if doAdd then
                      (plusDecl.sig.id[],plusDecl.OG.getDescNo,
                      plusDecl.OG.IS.objSize,0,true) 
                        -> cd.invoke;
                      getPlusRes;
                  if);
                  (true,0,0) -> current.gen;
                  (plusDecl.sig.id[],plusDecl.OG.getDescNo
                  ,plusDecl.OG.IS.objSize,0,true)
                    -> cd.invoke;
                  getPlusRes;
                  end[n] -> prev;
                  true  -> doAdd
               #);
               (*cTracer
               (#do 'pushText: ' -> TT; (prev + 1,T.length) -> T.sub -> TQ #);*)
               ((prev + 1,T.length) -> T.sub,stringDescNo)  -> cd.pushText;
               (if doAdd then                    
                   (plusDecl.sig.id[],plusDecl.OG.getDescNo
                   ,plusDecl.OG.IS.objSize,0,true) 
                     -> cd.invoke;
                   getPlusRes;
               if);
               (if not useRtnVal then cTracer(#do 'Kuk'-> TT #); cd.rPop if)
            #);
         loadAccessor::
            (#
            do fcTracer(#do 'StringObj:loadAccessor:'->TT; T[]->TL #);
               (none,none,true,0,0,false,none) -> newInvoke
            #);
          pushConst::
            (#
            do fcTracer(#do 'StringObj:pushConst'->TT; T[] -> TT #);
               (none,none,true,0,0,false,none) -> newInvoke
            #)
       #);
     Slot::<
       (# gen::
            (#
            do (if traceSlots then
                   '**** Slot:gen: ' -> puttext; id[] -> putline
               if);
               (* must handle Decls as well as Stmts - two pass? *)
               slotItems.scanSons(#do (false,0,0) -> current.gen #)
            #)
       #);
     pushOut:
       (# OGx: ^ObjectGenerator; id: ^text;
          pushReturn:
            (# DI: ^DataItem
            enter DI[]
            do fcTracer(#do 'global:pushOut:'->TT; DI.sig.dopt->TT;
                         'off:'->TT; DI.newOff -> II #);
               (if true
                // DI.OG.isBasicValue then
                   (if DI.OG.isFloat then
                       (if nameListInDcl then
                           (id[],(DI.sig.names.firstDecl).newOff) 
                             -> cd.fpushg
                        else
                           (id[],DI.newOff) -> cd.fpushg;
                       if)
                    else
                       (if nameListInDcl then
                           (* Assuming only one var in an out DI *)
                           (id[],(DI.sig.names.firstDecl).newOff) 
                             -> cd.pushg;
                        else (if (DI.OG.super <> none) and
                               ((DI.OG.super.last).ATd.OG.primNo = string_prim)
                               then
                               (id[],3) -> cd.pushg;
                            else
                               (id[],DI.newOff) -> cd.pushg;
                           if)
                   if)if)
                // DI.OG.isValueObj then
                   (if not withValueProxy then
                       (if nameListInDcl then
                           (DI.sig.names.firstDecl).newOff -> cd.pushConst;
                        else
                           DI.newOff -> cd.pushConst;
                       if);
                       DI.OG.IS.newDescNo -> cd.pushConst
                   if)
                else
                   (if nameListInDcl then
                       (id[],(DI.sig.names.firstDecl).newOff)
                         -> cd.rPushg;
                    else
                       (id[],DI.newOff) -> cd.rPushg;
               if)if);
               DI.newOff -> rtnOff
            #);
          DI: ^Decl; rtnOff: @integer
       enter(OGx[],id[])
       do (if OGx.isValueObj then
              fcTracer(#do 'pushOut:OG.isValueObj:NOT handled!OGx:'->TT;
                          OGx.dopt ->TL; 'id:'->TT; id[]->TT #)
           else
              -1 -> rtnOff;              
              (if (OGx.getReturnDecl -> DI[]) <> none then 
                  DI[] -> pushReturn
                  (*Apparenly pushOut is called even if no returnDecl*)
          if)if)
       exit rtnOff
       #);
     genVstub:
       (# stubN,stubT: ^text; dNo: @integer; OG: ^ObjectSpecification;
          ptn: ^Pattern; encIS: ^Items;
          restartLab,leaveLab: @LabelHandler.label;
          inSuper,inMain,inSub: @boolean
       enter(stubN[],dNo,OG[],encIS[])
       do OG.IS.checkGlobalAccess -> (inSuper,inMain,inSub);
          (if false then
              '*** genVstub:' -> puttext; stubN[] -> puttext; 
              ' dNo:' -> puttext; dNo -> putint; 
              ' originOff:' ->  puttext; encIS.newOriginOff->putint; 
              ' isValueObj:' -> dumpT; OG.isValueObj -> putBoolean;
              ' globalRestrictions:'-> dumpT;
              inSuper or inMain -> putBoolean;
              newline;
              OG.dopt -> puthead;
              encIS.dopt -> putheadN
          if);
          (if false and OG.isValueObj then
              '!!!! genVstub:valueObj: '->puttext;
              OG.dopt -> putheadN;
          if);
          (stubN[],dNo,false,'Object',0) -> cd.classDef
          (#
          do (1,encIS.encOG.OGidWdNo) -> addR; (* origin for vStub *)
             (2,OG.OGidWdNo) -> addR(* to store ref to obj generated by stub *)
          #);
          
          objectDecl[] -> ptn[];
          
          (OG.OGidWdNo,OG.getDescNo,false,'Object',0) -> cd.classDef;
          
          (stubN[],dNo,false,ptn.OG.IS.newDescNo
          ,encIS.newOriginOff ,encIS.encOG.OGidWdNo,encIS.newDescNo,false,true)
            -> cd.class;
          
          (* last arg is isValueObj, to be fixed!*)
          cTracer(#do 'Load origin:OG.isVirtualArg:'->TT; 
                   OG.isVirtualArg->BB #);
          
          (stubN[],dNo,encIS.encOG.OGid,encIS.newDescNo,OG.OGidWdNo) 
            -> cd.prepareStub -> stubT[];
          (if not OG.isValueObj and not (inSuper or inMain) then
              (if OG.isVirtualArg then
                  (OG.super.on + 1,OG.super[]) -> encIS.goOrigin;
               else
                  (if OG.super.ATd.asDecl <> objectDecl[] then
                      (OG.super.on,OG.super[]) -> encIS.goOrigin;
          if)if)if);
          cTracer
          (#do 'OG.super.on/descNo:' -> TT; 
             OG.super.on->II; OG.getDescNo->II; #);
          (if true then
              (* arg 2 = staticOff,do we need it?*)
              (if not emitLLVM then
                  (if OG.IS.isEmpty and not OG.super.hasVirtualArgs then
                      ((OG.super.ATd.asDecl).OG[],0,true) -> callInvoke
                   else (* never happens! *)
                      (OG[],0,true) -> callInvoke
              if)if)
           else
              (encIS.sig.id[],OG.getDescNo,OG.IS.objSize,0,true)
                -> cd.invoke
          if);
          
          (* move refTo thisObj to caller stack
           * This rstoreg seems odd/wrong? WHy?
           * we seem to store  ref to thisObj in vStub
           * and the push it on the caller stack!?
           *)
          cd.pushThis;
          (stubT[],2) -> cd.rstoreg;
          cd.setThisStack;
          cd.pushThis;
          (stubT[],2) -> cd.rpushg;
          
          'D' -> cd.rtn;
          (3(*objSize*),false,encIS.newBasicProp.visibility) 
            -> cd.endClass;
          (* mkLLVMvirtualDefs for thisClass!
           * But a vStub has no virtuals, so superflous? NO! mkVdtAlloc *)
          cd.mkLLVMvirtualDefs
          (# vName:: (#do '*** vStub: vName no binding' -> putline #);
             handleOrigins::
               (# E: ^Exp;
               do (if false then
                      '**** Vstub handleOrigins: ' -> puttext; stubN[]->puttext;
                      ' ' -> put; OG.OGidWdNo -> puttext;
                      ' ' -> put; OG.super.dopt -> puttext; newline;
                  if);
                  cd.lcom(#do 'Vstub:handleOrigins:NEW:' -> TT; stubN[] -> TT; 
                            OG.super.ATd.OG.doPT-> TT #);
                  cd.stack.put;
                  cd.rswap;
                  cd.stack.put;
                  OG.super[] -> goOriginAdr -> E[];
                  (* store possible argumenst of E *)
                  cd.rswap;
                  (OG[],(OG.super.ATd.asDecl).OG[],true) -> storeOrigins;
                  cd.lcom(#do 'Vstub:handleOrigins:END: ' -> TT #)
               #)
          #);
          cTracer(#do 'vdt:a:dNo:'->TT; dNo -> II; 
                   ' newDescNo: '->TT; encIS.newDescNo->II
                #);
       #);
     genStub:
       (* do we need to generate and store an origin here as for genVstub? *)
       (# atD: ^Pattern; N: ^Text; 
          descNo,stubDescNo,superDescNo,originOff,originDescNo: @integer
       enter(atD[],N[],descNo,superDescNo,originOff,originDescNo)
       do ('Stub',descNo,false,ATd.OG.IS.newDescNo,1,'Object',originDescNo
          ,false,false) 
            -> cd.class;
          cTracer(#do Atd.dopt -> TL #);
          ATd.OG.iS.newDescNo -> cd.vdtTableCopy;
          cd.tstOriginIsNone;
          ('sorigin',1) -> cd.rstore;
          (* OBS! we assume that originOff = 1 for super!
           * This needs to be validated!
           *)
          superDescNo -> cd.toSuper;
          'S' -> cd.rtnInner;
          (16,false,0) -> cd.endClass
       exit stubDescNo
       #);     
     mkStubName:
       (# sig: ^signature; OGx: ^ObjectSpecification; T,S: ^text
       enter(sig[],OGx[])
       do '' -> T[];
          (if sig[] <> none then
              sig.id.copy -> S[]
           else
              'S' -> S[]
          if);
          '#' -> S.put;    
          OGx.vDescNo -> S.putint;
          S[] -> T.append;
          (if false then
              '**** mkStubName:B: ' -> puttext; T[] -> puttext;
              ' ' -> put; S[] -> putline
          if)
       exit(T[],S[])
       #);
     ObjStubStackX: @
       (# add:
            (# gen:
                 (#
                 do (stubN[],dNo,OG[],encIS[]) -> genVstub;
                 #);
               stubN: ^text; dNo: @integer; OG: ^ObjectSpecification;
               encIS: ^Items;
            enter(stubN[],dNo,OG[],encIS[])
            do (for i: top repeat
                    (if dNo = OIS[i].dNo then
                        (if false then
                            '**** double vStub:'->dumpT;; stubN[] -> puttext; 
                            'dNo:'-> dumpT; dNo -> putint; newline;
                        if);
                        leave add
               if)for);
               (if (top + 1 -> top) > OIS.range then
                   OIS.range -> OIS.extend
               if);
               this(add)[] -> OIS[top][];
            #);
          gen:
            (#
            do (for  i: top repeat
                    OIS[i].gen
               for);
               0 -> top
            #);
          OIS: [12] ^add; top: @integer
       #);
     ObjStubStack: @
       (# add:
            (# gen:
                 (#
                 do (atD[],N[],stubDescNo,superDescNo,originOff,originDescNo)
                    -> genStub
                 #);
               atD: ^Pattern; N: ^Text; 
               stubDescNo,superDescNo,originOff,originDescNo: @integer
            enter(atD[],N[],stubDescNo,superDescNo,originOff,originDescNo)
            do (if (top + 1 -> top) > OIS.range then
                   OIS.range -> OIS.extend
               if);
               (if false then
                   '**** objStubStack.add: ' -> puttext; N[] -> puttext;
                   ' ' -> put; stubDescNo -> putint; atD.dopt -> putheadN;
               if);
               this(add)[] -> OIS[top][];
            exit stubDescNo
            #);
          gen:
            (#
            do (for  i: top repeat
                    OIS[i].gen
               for)
            #);
          OIS: [12] ^add; top: @integer
       #);
     
     ObjTmpStackClass::
       (# item: 
            (# OG: ^ObjectGenerator;
            enter OG[]
            exit this(item)[]
            #);
          add::
            (# 
            do (if (top+1-> top) > OTL.range then 
                   OTL.range -> OTL.extend;
                   done.range -> done.extend
               if);
               (if false then
                   'ObjTmpStack:add: ' -> puttext; OG.ogID -> puttext;
                   ' ' -> put; OG.IS.newDescno ->putint; newline;
               if);
               (if OG[] = StringDecl.OG[] then
                   cd.lcom(#do ' String: ' -> TT; OG.IS.newDescNo -> II#);
               if);
               cTracer(# do 'ObjTmpStack:add:'->TT;(if OG.sig[] <> none then
                            OG.sig.doPT -> TQ; ':' -> TT;
                        if);
                        OG.doPT -> TL;
                     #);
               OG[] -> item -> OTL[top][];
               (* Does IS.newDescNo correspond to var? Probably no!?*)
            #);                   
          next:
            (# inx: @integer; B: @boolean
            do 0 -> inx; false -> B;
               Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        cTracer(# do 'objTmpStack:next: ' -> TT;
                                 ' : done:'->TT; done[inx] -> BB;
                              #);
                        (if not OTL[inx].OG.IS.codeGenDone then
                            cTracer(# do 'objTmpStack:next:genClass:' -> TT;
                                     OTL[inx].OG.IS.newdescno -> II; 
                                  #);
                            OTL[inx].OG.genClass;
                        if);
                        restart Loop
                    if);
                 #)
            exit B
            #); 
          OTL: [10] ^Item; top: @integer;
          done: [10] @boolean
       #);       

     markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^TopNode;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if trace then
                       '\nModule: ' -> puttext; md.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).newDescNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   true -> md.markModule;
                   (if md.origin[] <> none then
                       md.NewOff -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genStubs:
       (# genValueProxy:
            (# OGx: ^ObjectGenerator; dN: @integer;
            do (Invocation,Items) 
                 -> ObjectGenerator 
                 -> OGx[]
                 -> QnewDesc 
                 -> dN 
                 -> OGx.IS.qDescNo[1];
               ('valProx',dN,false, 1,1,'Object',0,false,false) -> cd.class;
               dN -> valueProxyDescNo;
               (4,false,0) -> cd.endClass
            #);
          genMain:
            (# restartLab,leaveLab: @LabelHandler.label;  
            do (Invocation,Items) -> ObjectGenerator -> QnewDesc -> mDescNo;
               ('VM',mDescNo,false,1,0,'Object',0,false,false) -> cd.class;
               labelHandler.init; 
               restartLab.new;
               leaveLab.new;

               restartLab -> cd.defLab;
               cd.pushThis;
               (if false then
                   'TopModule: ' -> puttext;
                   markIncludes.topModule.sig.doPT -> putLine;
                   'Main: ' -> puttext; main.doPt -> putline
               if);
               ('BETAworld',(markIncludes.topModule.desc).newDescno
               ,(markIncludes.topModule.desc).objSize,0,true) 
                 -> cd.invoke
               (# topSuperId::
                    (#
                    do (markIncludes.topModule.desc).encOg.OGidWdNo 
                         -> superId[]
                    #)
               #);
               cd.stop; (* We should generate stop here and not in betaVM *)
               (* The objSize of main is set to 2 but perhaps not needed?
                * Was needed by qenv before an empty ObjectGenerator was 
                * generated for main *)
               leaveLab -> cd.defLab;
               'D' -> cd.rtn;
               (2,false,0) -> CD.endClass;
               
               (if markIncludes.main## <> Module## then
                   '\n\n***** Only Modules can be executed *****\n\n'
                     -> putline
               if)
            #);
          genThreadStub:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('ThreadStub',descNo,false,descNo,0,'Object',0,false,false) 
                 -> cd.class;
               false -> cd.actions;
               ('ThreadStub','D') -> cd.call;
               cd.stop;
               (1,false,0) -> CD.endClass;               
            #);
          genEventProcessor:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('EventProcessor',descNo,false,1,0,'Object',0,false,false) 
                 -> cd.class;
               cd.stop; (* we should generate stop here and not in betaVM *)
               (1,false,0) -> CD.endClass;               
            #);
       do genValueProxy;
          (* OBS! genMain; genEventProcessor; genThreadStub
           * MUST come in this order, since interpreter_c assumes
           * that threadStubDescNo = mainDescNo + 2;
           * it calls  mainDescNo = getMainDescInx();  
           * mainDescNo is packed in the image; 
           * threadStubNo SHOULD also be packed in the image
           *)
          genMain;          
          (if not emitLLVM then 
              genEventProcessor;     
              genThreadStub;
          if);
       #);
     valueProxyDescNo,
     mDescNo: @integer;
     mainDescNo:: 
       (# 
       do mDescNo -> value (* ad hoc *);
       #);
     (* cd: @ObjectCode; moved to abstractSyntaxTree for debugging purposes *)
     runTimeDescs:: (# do descs[] -> rtDescs[] #);
     descs: ^RunTimeDescriptors;
     BC,BCllvm: @File;
     emitLLVM,traceLLVMcalls,dumpLLVMobjs: @boolean; ch: @integer;
     ind: @integer;
     emitBC:
     (# N: ^TopNode;
        indent:
	(#
	do (for i: ind repeat ' ' -> put for);
	#)
     enter N[]
     do indent;
        '['->put; N.beginBCP -> putint; ','->put; N.endBCP -> putint; ']'->put;
        newline;
        N.scanSons
	(#
	do indent;
	   current.dopt -> putline;
	   ind +  3 -> ind;
	   current[] -> emitBC;
	   ind - 3 -> ind
        #)
     #);
  do (if verbose then '**** GENERATOR ****' -> putline if);
     (if emitLLVM then
         newFeature -> cd.newFeature;     
         (FN[],'.ll') -> mkAuxName -> BC.name;
         ('tmp.xbeta','.ll') -> mkAuxName -> BCllvm.name;
         BCllvm.openWrite;
         (BCllvm[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs) -> cd.init;
      else
         (FN[],'..s') -> mkAuxName -> BC.name;
         (BC[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs) -> cd.init;
     if);
     BC.openWrite;
     cTracer(#do'QBETA'-> TT #);
     labelHandler.init;
     0-> ObjTmpStack.top;
     main[] -> markIncludes;     

     (* Module::gen puts OG on ObjTmpStack *)
     (* rootModule = BETAworld must have descNo = 1 
      * - no longer the case *)
     (# ptn: ^Pattern; OGx: ^ObjectGenerator
     do (*'**** rootModule.markForCodeGen'->putline;*)
        rootModule.markForCodeGen;
        objectDecl.markForCodeGen;
        (* Pattern Object is special and not reached during a by-need scan
         * but must be allocated
         *)
        (*true -> (ptn.OG[]->OGx[]).marked *)
     #);
     getStringPlus;
     rootModule.classDef;
     L:
       (# B: @ boolean
       do false -> B;
          ObjTmpStack.next or B -> B;
          (* Eliminate boolean and fix test for objTmpStack.isEmpty *)
          (if B then
              restart L 
          if)
       #);
     objStubStack.gen;
     genStubs;
     (if verbose then '**** REQUIRES ****' -> putline if);
     rootModule.importRequires;
     (if not locateWorld.aMiniBetaModule then
         rootModule.checkRequires;
     if);
     
     (if stringDecl[] <> none then
         (if (stringDecl.desc).newDescNo = 0 then
             rootModule[] 
               -> SemanticError(#do 'StringDecl.newDescNo = 0!' -> msg #)
          else
             (stringDecl.desc).newDescNo -> CD.descs.textDescNo
         if)
      else
         rootModule[] -> SemanticError(#do 'StringDecl not found!' 
                                           -> msg #)
     if);
     (*  (if StructureRefDesc[] <> none then
      *          StructureRefDesc.newDescNo -> CD.descs.structureRefDescNo
      *       else
      *          rootModule[] 
      *            -> SemanticError(#do 'StructureRefDesc not found!' 
      * -> msg #)
      *    if);
      *)
     
     cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)
     true -> descs.newAlloc;
     cd.close;
     (if false and mainPT then
         '**** main: ' -> putline; main.doPT -> putline
     if);
     (if emitLLVM then
         (*(0,fromBeginning) -> BCllvm.setpos;*)
         ';;; Start of LLVM\n' -> BC.puttext;
         BCllvm.close;
         BCllvm.openRead;
         (*CD.LLVMstructs[] -> BC.puttext;*)
         'target triple = "i686-pc-windows-cygnus"\n' -> BC.puttext;
         cd.typeInfo.printStructs;
         CD.LLVMstructs[] -> BC.puttext;
         'declare noalias i8* @malloc(i64)\n' -> BC.puttext;
         'declare noalias i32* @allocIndexed(i32,i32)\n' -> BC.puttext;
         'declare noalias i32 @arrayLength(i32*)\n' -> BC.puttext;
         'declare noalias i32* @allocString(i8*, i32)\n' -> BC.puttext;
         'declare i32 @puts(i8* nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @putCh(i32 nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @putHex(i32 nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @dumpHex(i32 nocapture, i32 nocapture) nounwind\n' 
         'declare void @notImpl(i32 nocapture) nounwind\n' 
           -> BC.puttext;
         
         copy:
           (if not BCllvm.eos then
               BCllvm.get -> ch;
               (if ch <> ascii.cr then ch -> BC.put; if);
               restart copy
           if);
         BCllvm.close
     if);
     (*true -> PTwithBCP;
     main.dopt -> putline;*)
     BC.close
  #)

