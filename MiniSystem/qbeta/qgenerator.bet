ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE '../miniCompiler/objectcode'
---lib:attributes---
generator: checker
  (# traceModules: (# exit true #);
     MkCom: 
       (# t1,t2: ^text enter (t1[],t2[]) do t2[] -> T1.append -> cd.comment #);
     
    Module::
       (# gen::
            (#
            do ('Comp',newDesc.noOfDescs) -> cd.newComponent;
               SO.gen;
               (*this(Module)[] -> main[];*)
            #);
       #);
     ModuleItem::
       (# gen::
            (#
            do (if MD.isIncluded then
                   ('ModuleItem:gen',sig.dopt) -> cd.com2;
                   MD.SO.gen
                else
                   (if traceModules then
                       'Module not included: ' -> puttext; sig.doPT -> putline
               if)if)
            #);
          pushThis:: (# do cd.pushThis #);
          loadAdr::
            (# 
            do 'MI:loadAdr: ' -> puttext; sig.doPT -> putline;
               MD.SO.loadAdr;
            #)
       #);
     StaticObject::
       (# gen::
            (# T: @text
            do (if not OG.IV.isBasic then 
                   'StaticObject is not Basic' -> cd.comment;
                   sig.doPt -> cd.comment;
                   (if origin[] <> none then 
                       (*cd.pushThis;*)
                       OG.IS.descNo -> T.putint;
                       ('staticObject: alloc: ',T[]) -> cd.com2; 
                       true -> OG.gen;
                       (*cd.rswap;*)
                       cd.pushThis;
                       (sig.id[],this(StaticObject).off) -> cd.rstoreg;
                    else 
                       (* A module object *)
                       (if not OG.IS.isEmpty then
                           (sig.id[],none,OG[],OG.IV[]) ->  ObjTmpStack.add
                       if)   
                   if)
               if)
            #);
          pushThis:: 
            (# 
            do cd.pushThis;
               (* Probably wrong to goOrigin here!
                * Here is the declaration
                *    R: @ Foo
                * 
                * R is Accessed at another place
                *     ... R - we should go Origin from here
                * So no pushThis here!
                * Same for UnaryPatttern, etc
                *)
               (if org[] <> none then
                   on -> org.goOrigin
               if)
            #);
          loadAdr:: 
            (* Called when Receiver 
             * R: @ Foo or R: @ Foo{...} -> push R = adr of object
             * X: @integer -> no action
             *)
            (# 
            do (if not OG.IV.isBasic then 
                   ('StaticObject:loadADr: ',sig.dopt) -> cd.com2;
                   (sig.id[],this(StaticObject).off) -> cd.rpushg
               if)
            #);
          load::
            (* called when not receiver - i.e. value to be pushed *)
            (#
            do (if OG.IV.isBasic then 
                   (sig.id[],off) -> cd.pushg
                else
                   (sig.id[],off) -> cd.rpushg
               if)
            #);
          pushOff::
            (#
            do  (if OG.IV.isBasic then 
                    '\n!!! StaticObj:LoadOff called for simple: ' -> puttext;
                    dopt -> putline;
                   (sig.id[],off) -> cd.pushg
                else
                   (sig.id[],off) -> cd.rpushg
               if)
            #);
          store::
             (* Called from Signature::StoreParameters
             *)
            (#
            do (* 'StaticObject:store: '->putline;*)
               (if OG.IV.isBasic then 
                   (sig.id[],off) -> cd.store
                else
                   (sig.id[],off) -> cd.rstore
               if)
            #);
          swapr::
            (#
            do (if not OG.IV.isBasic then
                   CD.rswap
               if)
            #)
       #);
     DynamicObject::
       (# gen:: (# do #);
          pushThis:: (# do cd.pushThis #);
          loadAdr:: 
            (# 
            do 'DynObj:loadAdr' -> cd.comment;
               (sig.id[],this(DynamicObject).off) -> cd.rpushg 
            #);
          load:: 
            (# 
            do 'DynObj:load' -> cd.comment;
               (sig.id[],this(DynamicObject).off) -> cd.rpushg
            #);
          store:: (# do (sig.id[],off) -> cd.rstore #);
          swapr:: (# do cd.rswap #)
       #);
     Signature::
       (# 
          storeParameters:
            (#
            do (*cd.setThisStack;*)
              (* 'storeParameters: ' -> puttext;*)
               scanParametersReverse
               (#
               do (*currentPar.dopt -> puttext; ' ' -> put;*)
                  currentPar.store
               #)
            #);
          pushReturnValues:
            (#
            do (if val[] <> none then
                   cd.setThisStack;
                   val.scanSons
                   (# D: ^Decl
                   do current[] -> D[];
                      cd.pushThis;
                      D.load
                   #)
                else
                   (* pushThis? 
                    * Or add default val - perhaps special This-decl*)
               if)
            #)
       #);
     ObjectGeneration::
       (# gen::
            (# name: ^text
           do (*('OG: ',OI.inv.compoundSymb[]) -> MkCom;*)
               (*IS.inv.ATd.doPT -> putline*)
               (if IS.isEmpty and not IV.hasVirtualArgs or IV.isBasic then
                   (* check this - called when R.foo *)
                   isStaticObj -> IV.gen
                else
                   (* called when R.foo{ } *)
                   (if IV.hasVirtualArgs then
                       'ObjectGeneration:gen:hasVirtualArgs: ' -> putline;
                       IV.doPT -> putline;
                       'descNo: ' -> puttext; IS.descNo -> putint; newline;
                       'SuperDesc: ' -> puttext; IS.superDesc.doPT -> putline;
                       'Super.descNo: ' -> puttext;
                       IS.superDesc.descNo -> putint; newline;
                       IS.superDesc.doPT -> putline
                   if);
                   (*IV.loadOrigin; *)
                   cd.pushThis; (* origin for a singular object *)
                   (if singularName[] <> none then
                       singularName[] -> name[]
                    else
                       'Singular#' -> name[];
                       IS.descNo -> name.putint;
                   if);
                   (name[],IS.descno,true) -> cd.alloc;
                   (if not isStaticObj  then cd.rpop if);
                   (name[],none,this(ObjectTemplate)[],IV[]) -> ObjTmpStack.add
               if)
            #);
          genClass::
            (#
            do (N[],sig[],IS.descNo,super[]) -> IS.genClass
            #)
       #);
     PatternId::
       (# gen::
            (#
            do 'PatternId:gen: ' -> puttext; dopt ->putline;
               IV.gen
            #)
       #);
     ObjectDesc::
       (#
          genClass::
            (# (*N: ^text; sig: ^Signature
            enter(N[],sig[])*)
            do (N[],sig[],IS.descNo,super[]) -> IS.genClass
            #)
       #);
     items::
       (# genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; super: ^Invocation;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
           
            enter(N[],sig[],descNo,Super[])
            do (*'GenClass: ' -> puttext; N[] -> putline;*)
               (if (superDesc[] <> none) then
                   superDesc.father.father -> ptn[];
                   (if not superDesc.done then
                   (* 'HasSuper: ' -> puttext; *)
                   (* super is always a pattern - I think!*)
                   (# 
                   do 
                      (ptn.sig.id[],ptn.sig[],superdesc.descNo,ptn.OD.superPI.IV[]) 
                        -> superDesc.genClass
                   #)
               if)if);
               (if not done then
                   true -> done;
                   (N[],descNo,false, (topSuper).descNo,originOff) -> cd.class;
                   (* thisObj = thisStack = the new instance of this class 
                    * thisObj.top = thisStack.top = origin 
                    * Possible arguments on callerStack
                    *)
                   (if superDesc[] <> none then
                       (ptn.sig.id[],superDesc.descNo)  -> cd.super; 
                       superDesc.descNo -> cd.vdtTableCopy;
                       (if superDesc.innerInx > 0 then
                           (superDesc.innerInx,descno) -> cd.vdtTable;
                           true -> hasSuperAndInner
                       if);   
                       (if not superApl.isThisBlockLevel or
                           (superApl.isImplSuper and not superApl.isSingularImplSuper)
                           then
                           '\n*** Load super origin: on: ' -> puttext;
                           super.on -> putint; ' pn:' -> puttext; 
                           superApl.pn ->putint;
                           ' Super: ' -> puttext; super.dopt -> putline;
                           'This: ' -> putLine;
                           doP -> putline;                           
                           ('origin',originOff) -> cd.rstore; 
                           (* origin popped from thisObj=thisStack *)
                           (if superApl.isImplSuper and not superApl.isSingularImplSuper then
                               ' implicit non Singular super: pn:' -> puttext; 
                               superApl.pn -> putint;
                               ' on:' -> puttext; superApl.on -> putint; 
                               ' superAPL.ATd.on:' -> puttext; 
                               superApl.ATd[] -> ptn[];
                               ptn.OD.superPI.on -> putint; 
                               ' this: ' -> putLine;
                               doP -> putline;
                               origin[] -> vSuperDesc[]; (* find desc enclosing vDcl *)
                               (for i: superApl.pn repeat
                                    vSuperDesc.superDesc[] -> vSuperDesc[]
                               for);
                               'vSuperDesc: ' -> putline;
                               (0,true) -> vSuperDesc.doP -> putline;
                               cd.pushThis;
                               ('origin',originOff) -> cd.rpushg; 
                               ptn.OD.superPI.on -> vSuperDesc.goOrigin
                            else
                               'Not Implicit:' -> puttext; 
                               (* foo: bar ...   -- bar at another block level
                                *                -- go origin bar.ON
                                * foo: R.bar ... -- push adr of R
                                *)
                               (if superApl.length 
                                // 0 then 'ERROR! Should be implicit' -> putline
                                // 1 then 'Single' -> putline;
                                   (*super.loadOrigin*)
                                   cd.pushThis;
                                   superApl.on + 1 -> goOrigin;
                                else
                                   'remote' -> putline;
                                   (* R.S.foo { ... }
                                    * 
                                    * cd.pushThis 
                                    * R.on + 1 -> encDesc.goOrigin - as for single
                                    * add S.off
                                    *)
                                   cd.pushThis;
                                   ('origin',originOff) -> cd.rpush;
                                   super.loadOrigin
                               if)
                           if)
                           (* origin of super pushed on thisObj = this Stack *)
                       if);                           
                    else
                       ('origin',originOff) -> cd.rstore;
                       (* origin popped from thisObj=thisStack *)
                   if);
                   
                   cd.setThisStack;
                   (if sig[] <> none then sig.storeParameters if);
                   (*cd.setThisStack;*)
                   'super.gen: push arguments' -> cd.comment;
                   super.scanSons 
                   (# E: ^Exp do current[] -> E[]; E.loadArgs #);
                   cd.mvStack;
                   
                   (if superDesc[] <> none then 
                       (* used to be (topSuper).descNo *)
                       (*cd.mvStack;*)
                       superDesc.descNo -> cd.topSuper;
                   if);
                   
                   (* code for allocation part *)
                   cd.markEnterE;  
                   (if (sig[] <> none) and (sig.args[] <> none) then
                       sig.args.scanArgs
                       (# D: ^Decl;
                       do current[] -> D[];
                          (*'Sig: ' -> puttext; D.doPT -> putline;*)
                          (if D.isVirtual then
                              D.gen
                          if)
                   #)if);
                   scanSons
                   (# I: ^Item
                   do current[] -> I[];
                      (if I.isDecl then current.gen if) 
                   #);
                   (if innerInx > 0 then innerInx -> cd.innerA if);
                   (if superDesc[] <> none  then cd.rtnInner if);
                   
                   (* Code for action part *)
                   false -> cd.actions;
                   restartLab.new;
                   leaveLab.new;
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item
                   do current[] -> I[];
                      (if not I.isDecl then current.gen if) 
                   #);
                   (* push return value 
                    * - for staticObject: R: @Foo
                    *   Foo should return (this(Foo)
                    *   perhaps default?
                    * - otherwise push variables in -> 
                    *)
                   (if sig[] <> none then 
                       sig.pushReturnValues 
                    else
                       (* puhsThis?*)
                   if);
                   leaveLab -> cd.defLab;
                   (if superDesc[] <> none then
                       cd.rtnInner
                    else
                       'D' -> cd.rtn;
                   if);
                   (vsize,rsize,1) -> CD.endClass     
               if)
            #);
          goOrigin:
            (# on: @integer; org: ^Items
            enter on
            do (if on > 0 then
                   ('origin',originOff) -> cd.rpushg;
                   on - 1 -> (origin[]->org[]).goOrigin
               if)
            #); 
          hasSuperAndInner: @Boolean;
          restartLab,leaveLab: @LabelHandler.label
       #);
     UnaryPattern::
       (# gen:: (# do (sig.id[],sig[],OD[],OD.superPI.IV[]) -> objTmpStack.add #);
          pushThis:: 
            (# 
            do cd.pushThis;
               (if org[] <> none then
                   (* only if false in Unary::pushThis *)
                   on -> org.goOrigin
               if)
            #);
          loadAdr::
            (#
            do ('UnaryPattern:loadAdr: ',sig.doPT) -> cd.com2;
               (*cd.pushThis;*)
            #);
          load::
            (#
            do ('UnaryPattern:load: ',sig.doPT) -> cd.com2; 
               (sig.id[],OD.IS.descno,true) -> cd.alloc;
               (if not isStaticObj then
                   cd.rpop;
                   (* reconsider if return values *)
               if);
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);   
       #);
     BasicUnaryPattern::
       (# load2::
            (# org: ^Items
            do (if OD.IS.props.basicProp.primNo
                // inner_prim then
                   'INNER'-> cd.comment;
                   E.origin[] -> org[];
                   org.innerInx -> cd.innerx;
                   true -> done
               if);
            #)
       #);
     VirtualPattern::
       (# gen::
            (#
            do 'Gen Virtual: ' -> puttext; sig.doPT -> putline;
               (if OD.IS.isEmpty then
                   'Empty virtualPTN: ' -> putline;
                   (off,(OD.superPI.desc).descNo) -> cd.vdtTable
                else
                   (sig.id[],sig[],OD[],OD.superPI.IV[]) -> objTmpStack.add;
                   (off,OD.IS.descNo) -> cd.vdtTable
               if)
            #);
          pushThis:: 
            (# 
            do cd.pushThis;
               (if org[] <> none then
                   (* only if false in Unary::pushThis *)
                   on -> org.goOrigin
               if)
            #);
          loadAdr::
            (#
            do ('VirtualPtn:loadAdr: ',sig.doPT) -> cd.com2;
               (*cd.pushThis;*)
            #);
          load::
            (#
            do ('VirtualPtn:load: ',sig.doPT) -> cd.com2; 
               (sig.id[],off) -> cd.sendVirtual;
               (if not isStaticObj then
                   cd.rpop;
                   (* reconsider if return values *)
               if);
            #);
          store::
            (#
            do 'VirtualPattern:store: '->puttext; doPT -> putline;
            #);          
       #);
     FinalPattern::
       (# gen::
            (#
            do (sig.id[],sig[],OD[],OD.superPI.IV[]) -> objTmpStack.add;
               (off,OD.IS.descNo) -> cd.vdtTable
            #);
          pushThis:: 
            (# 
            do cd.pushThis;
               (if org[] <> none then
                   (* only if false in Unary::pushThis *)
                   on -> org.goOrigin
               if)
            #);
          loadAdr::
            (#
            do ('VirtualPtn:loadAdr: ',sig.doPT) -> cd.com2;
               (*cd.pushThis;*)
            #);
          load::
            (#
            do (*'Load Final: ' -> puttext; doPt -> putline;*)
               ('FinalPtn:load: ',sig.doPT) -> cd.com2; 
               (sig.id[],off) -> cd.sendVirtual;
               (if not isStaticObj then
                   cd.rpop;
                   (* reconsider if return values *)
               if);
            #);
          store::
            (#
            do 'FinalPattern:store: '->puttext; doPT -> putline;
            #);          
       #);
          
     BinaryPattern::
       (# gen:: (# do (sig.id[],sig[],OD[],OD.superPI.IV[]) -> objTmpStack.add #);
          loadAdr::
            (#
            do 'BinaryPattern:loadAdr: '->puttext; sig.doPT -> putline;
            #);
          load::
            (#
            do ('BinaryPattern:load: ',sig.doPT) -> cd.com2;
               (sig.id[],OD.IS.descno,true) -> cd.alloc;
               (if not isStaticObj then
                   cd.rpop; (* depend on the return type *)
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #); 
       #);
     BasicBinaryPattern::
       (# load:: 
            (# 
            do OD.IS.props.basicProp.primno -> cd.op 
            #);
       #);
     FunctionalPattern::
       (# gen:: (# do (sig.id[],sig[],OD[],OD.superPI.IV[]) -> objTmpStack.add #);
          pushThis:: (# do cd.pushThis #);
          loadAdr:: (# #);
          load:: 
            (# 
            do ('FunctionalPattern:load: ',sig.doPT) -> cd.com2;
               (sig.id[],OD.IS.descno,true) -> cd.alloc;
               (if not isStaticObj then
                   cd.rpop;
                   (* reconsider if return values *)
               if);
            #);
       #);
     BasicFunctionalPattern::
       (# load:: (# do ('put',OD.IS.props.basicProp.primNo) -> cd.Callprim #);
       #);
     KeyWordPattern::
       (# gen:: (# do (sig.id[],sig[],OD[],OD.superPI.IV[]) -> objTmpStack.add #);
          pushThis:: (# do cd.pushThis #);
          loadAdr:: 
            (# args: [6]^ObjectGeneration; top: @integer;
            do (*'KeyWordPattern:loadAdr: ' -> puttext; sig.doPT -> putline;*)
               E.scanSons
               (# isArg: @boolean
               do (if isArg then
                      (*'Actual arg: ' -> puttext; current.doPT -> putline;*)
                      (if (top+1 -> top) > args.range then 
                          args.range -> args.extend 
                      if);
                      current[] -> args[top][]
                  if);
                  not isArg -> isArg                  
               #);
               sig.args.scanArgs
               (# D: ^Decl; i: @integer; OG: ^ObjectGeneration; name: ^text
               do i + 1 -> i;
                  current[] -> D[]; 
                  (*D.doPt -> putline;
                  args[i].dopt -> putline;*)
                  (if D.isVirtual then
                      'SingularBinding#' -> name[];
                      (args[i].desc).descno -> name.putint;
                      (* (args[i].desc).doPT -> putline;
                      (args[i].desc).descno -> putint;newline;*)
                      E.father.father[] -> OG[]; 
                      (* 'Binding: ' -> putline; args[i].doPT -> putline;*)
                      (name[],none,args[i][],args[i].IV[]) -> ObjTmpStack.add;
                      
                      (*(OG.desc).descNo -> putint; newline;*)
                      
                      (D.off,(args[i].desc).descno,(OG.desc).descNo) -> cd.vdtTableAt
                   else
                      args[i].gen
                  if);
               #);
            #);
          load:: 
            (# 
            do (if not isStaticObj then
                   (sig.id[],OD.IS.descno,true) -> cd.alloc 
               if)
            #);    
          load2::
            (# args: [6]^ObjectGeneration; top: @integer;
               hasVirtualArgs: @boolean
            do 'KWP:load2: ' -> puttext; sig.dopt -> putline;
               E.scanSons
               (# isArg: @boolean
               do (if isArg then
                      (*'Actual arg: ' -> puttext;
                      current.doPT -> putline;*)
                      (if (top+1 -> top) > args.range then 
                          args.range -> args.extend 
                      if);
                      current[] -> args[top][]
                  if);
                  not isArg -> isArg                  
               #);
               sig.args.scanArgs
               (# D: ^Decl; i: @integer
               do i + 1 -> i;
                  current[] -> D[]; D.doPt -> putline;
                  (if D.isVirtual then
                      true -> hasVirtualArgs
                   else
                      args[i].gen
                  if);
               #);
               (if hasVirtualArgs then 
                   '\n>>> Has Virtual arguments'->putline;
                  (* father.father[] -> OG[];
                    ('KeyWord',none,OG[],OG.IV[]) -> ObjTmpStack.add*)
                else
                   (if not isStaticObj then

                       (sig.id[],OD.IS.descno,true) -> cd.alloc 
                   if)
               if);

            #)
       #);
     BasicKeyWordPattern::
       (# load:: 
            (# exitLab: @labelHandler.label
            do (if OD.IS.props.basicProp.primNo
                // ifthen_prim then
                   exitLab.new;
                   1111 -> cd.pushConst;                   
                   exitlab -> cd.jmpFalse;
                   2222 -> cd.pushConst;
                   exitLab -> cd.defLab
               if)
            #);
          load2::
            (# exitLab: @labelHandler.label
            do (if OD.IS.props.basicProp.primNo
                // ifthen_prim then
                   exitLab.new;                   
                   E.scanSons
                   (# N: @integer
                   do N + 1 -> N;
                      (if N
                       // 1 // 3 then
                       // 2 then 
                          current.gen;
                          exitlab -> cd.jmpFalse;
                       // 4 then
                          current.gen;
                          exitLab -> cd.defLab;
                       else
                          'load2:%if%then: too many arguments' -> putline;
                          E.doPt -> putline
                      if)
                   #);
                   true -> done;
               if);
            #)
       #);            
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.loadAdr
        *    E2.loadAdr
        *    E3.execute
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# gen:: 
            (* Should call loadOrigin and then execute *)
            (# first: @boolean; rec,E: ^Exp;
            do (if false then
                   (* not testet *)
                   cd.pushThis; (* what if empty?*)
                   loadOrigin -> (rec[],E[]);
                   (rec[],isStaticObj) -> E.execute
                else
                   true -> first;
                   scanSons
                   (# E: ^Exp; rec: ^Exp
                   do current[] -> E[];
                      (if first then E.pushThis if);
                      (if not isLast then 
                          E.loadAdr 
                       else
                          (rec[],isStaticObj) -> E.execute
                      if);
                      E[] -> rec[];
                  false -> first
                   #)
               if)
            #);
          loadOrigin:
            (# superAdj: @integer;
               rec,E: ^Exp;
            enter superAdj
            do scanSons
               (# 
               do current[] -> E[];
                  (if isFirst then E.loadOrigin if); 
                  (if not isLast then E.pushOff if);
                  E[] -> rec[]
               #)
            exit(rec[],E[])
            #);
       #);
     Unary::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# pushThis:: 
            (# T: @text; org: ^Items
            do (if false then
                   (origin[],on) -> ATd.pushThis;
                else
                   (if ATd## <> BasicUnaryPattern## then
                       cd.pushThis;
                       'Unary:GoOrigin: ' -> T; on -> T.putint; T[] -> cd.comment;
                       origin[]-> org[];
                       on -> org.goOrigin
                   if)
               if)
            #); 
          loadAdr:: 
            (# T: @text;
            do 'GoOrigin: ' -> T; on -> T.putint; T[] -> cd.comment;
               ATd.loadAdr 
            #);
          loadOrigin::
            (# org: ^Items
            do on -> (origin[]->org[]).goOrigin;               
            #);
          pushOff:: (# do ATd.pushOff #);
          execute:: 
            (# 
            do (if ((this(Exp)[],isStaticObj) -> ATd.load2) then
                else
                   isStaticObj -> ATd.load
               if)
            #);
       #);
     Binary::
       (# pushThis:: 
            (# org: ^Items
            do ('Binary:pushThis: ',doPT) -> MkCom;
               (if true then
                   cd.pushThis;
                   on -> (origin[]->org[]).goOrigin
                else
                   ATd.pushThis 
               if)
            #);
          loadAdr:: 
            (# 
            do ('Binary:loadAdr:', dopt) -> MkCom;
               ATd.doPT -> cd.comment;
               ATd.loadAdr;
               (* execute *)
            #);
          loadArgs:: (# do argument.gen #);
          execute::
            (#
            do (if isAssign then 
                   argument.gen;
                   ('var',rec.ATd.off) -> cd.storeg
                else
                   (if rec.ATd.isBasic then 
                       isStaticObj -> rec.ATd.load
                   if);
                   loadArgs;
                   isStaticObj -> ATd.load
               if)
            #)
       #);
     Function::
       (# pushThis:: 
            (# org: ^Items
            do ('Function:pushThis: ',doPT) -> MkCom;
               (if ATD.isPrim = 0 then 
                   cd.pushThis;
                   on -> (origin[]->org[]).goOrigin
                (*else
                   ATd.pushThis *)
               if) 
            #);
          loadAdr:: (# do ATd.loadAdr #);
          loadArgs:: 
            (# first: @boolean
            do true -> first;               
               scanSons
               (# E: ^Exp; I: ^Invocation; OG: ^ObjectGeneration
               do (if not first then 
                      current.gen;
                      (if current## <= objectGeneration## then 
                          current[] -> OG[];
                          OG.IV.swapr
                       else
                          '\n!!! Function: NOT OGV: ' -> puttext; 
                          current.dopt -> putline;
                          current.PP -> putline
                      if)
                  if);
                  false -> first
               #);
            #);
          execute::
            (# first: @boolean
            do (*ATd.loadAdr;*)
               true -> first;               
               loadArgs;
               (if ATd[] = none then 
                   'none' -> putline
                else
                   isStaticObj -> ATd.load
               if)
            #)          
       #);
     KeyWord::
       (# pushThis:: 
            (# org: ^Items
            do 'KeyWord:pushThis: ' -> puttext; dopt ->putline;
              (if ATD.isPrim = 0 then 
                   cd.pushThis;
                   on -> (origin[]->org[]).goOrigin
                (*else
                   ATd.pushThis *)
              if) 
            #);
          loadAdr:: 
            (# 
            do 'KeyWord:loadAdr: ' -> puttext; dopt->putline; 
               this(Exp)[] -> ATd.loadAdr;
               (*execute*)
            #);
          loadArgs::
            (# isArg: @boolean
            do scanSons
               (#
               do (if isArg then
                      current.gen
                  if);
                  not isArg -> isArg
               #);
            #);               
          execute::
            (# doBreak:
                 (# OD: ^Items; E : ^ObjectGeneration; on: @integer;
                    primNo: @integer
                 enter primNo
                 do scanSons
                    (# isArg: @boolean
                    do current.doP -> puttext;  ' ' -> put; 
                       (if isArg then
                           current[] -> E[];
                           E.IV.on -> on;
                           on -> putint; ' ' -> put 
                       if);
                       noT isarg -> isarg
                    #);
                    ' on:' -> puttext; on -> putint; newline;
                    origin[] -> OD[];
                    (for i: ON - 1 repeat OD.origin[] -> OD[] for);
                    OD.doP -> putline;
                    ' descNo:' -> puttext; OD.descNo -> putint;
                    (if primNo
                     // restart_prim then (on - 1, OD.restartLab) -> cd.break
                     // leave_prim then (on - 1, OD.leaveLab) -> cd.break
                    if)
                 #);
            do (*'KeyWord:execute: ' -> puttext; doPt -> putline;*)
               (if ATd.isPrim
                // restart_Prim then
                   'Restart: ' -> puttext; restart_Prim -> doBreak
                // leave_Prim then 
                   'Leave: ' -> puttext; leave_Prim -> doBreak
                else
                   (if ((this(Exp)[],isStaticObj) -> ATd.load2) then
                       (* just a hack - load2 shall replace load *)
                    else
                       loadArgs;
                       isStaticObj -> ATd.load;
               if)if)
            #);
       #);
     Const::
       (# execute:: (# do T.setpos; T.getInt -> cd.pushConst #);
       #);
     ObjTmpStack: @
       (# item: 
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate; super: ^Invocation
            enter(N[],sig[],OT[],super[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; sig: ^Signature; OT: ^ObjectTemplate; super: ^Invocation
            enter(N[],sig[],OT[],super[])
            do (if (top+1-> top) > OTL.range then OTL.range -> OTL.extend if);
                   (N[],sig[],OT[],super[]) -> item -> OTL[top][]
            #);          
          next:
            (# inx: @integer
            do Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        (OTL[inx].N[],OTL[inx].sig[],OTL[inx].super[]) -> OTL[inx].OT.genClass;
                        restart Loop
                    if);
                 #)
            #); 
          OTL: [10] ^Item; top: @integer;
       #);
     labelHandler: @
       (# labCount: @integer;
          label:
            (# labNo: @integer;
               new: (# do  labCount + 1 -> labCount -> labNo #);
            enter labNo
            exit labNo
            #);
          init: (# do 0 -> labCount #);
       #);
      markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^node;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if false then
                       '\nModule: ' -> puttext; md.SO.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).descNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   md.mark;
                   (if md.origin[] <> none then
                       md.SO.off -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genMain:
       (# descno: @integer
       do ('main',newDesc,false,1,0) -> cd.class;
          cd.pushThis;
          (if false then
              'TopModule: ' -> puttext;
              markIncludes.topModule.SO.sig.doPT -> putLine;
              'Main: ' -> puttext; main.doPt -> putline
           if);
          ('BETAworld',(markIncludes.topModule.desc).descno,true) -> cd.alloc;
          cd.stop; (* We should generate stop here and not in betaVM *)
          (0,0,0) -> CD.endClass;
          
          (if markIncludes.main## <> Module## then
              '\n\n***** Only Modules can be executed *****\n\n'
                -> putline
          if)
       #);
     genEventProcessor:
       (#
       do ('EventProcessor',newDesc,false,1,0) -> cd.class;
          cd.stop (* we should generate stop here and not in betaVM *)
       #);
     
     mainDescNo: (# exit newDesc.noOfDescs -1 (*- 2*) (* ad hoc *) #);
     cd: @ObjectCode;
     descs: ^RunTimeDescriptors;
     BC: ^File;
  enter BC[]
  do 'GENERATOR' -> putline;
     (if true then
         BC.openWrite;
         BC[] -> cd.init;
         'QBETA'-> cd.comment;
         
         labelHandler.init;

         main[] -> markIncludes;

         rootModule.gen;

         ObjTmpStack.next;
         
         genMain;
         genEventProcessor;     
         
         cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)    
         
         cd.close;
         BC.close
     if)
  #)

