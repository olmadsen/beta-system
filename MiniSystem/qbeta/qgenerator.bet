ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qvariants';
INCLUDE '../VM/objectcode';
BODY 'qgeneratorBody'
---lib:attributes---
generator: variants
  (# traceModules: (# exit false #);
     useMarkForCodeGen: (# exit true #);

     Module::
       (# markForCodeGen::
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                    if)
                 exit M[]
                 #);
               M: ^Module;
            do DI.markForCodeGen;
               (if (encModule -> M[]) <> none then
                   M.markForCodeGen
               if)
            #);
          Qgen:: 
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                    if)
                 exit M[]
                 #);
               M: ^Module; var: ^Variant
            do (DI.sig.id[],newDesc.noOfDescs) -> cd.newComponent;
               (if not useMarkForCodeGen then
                   (if not DI.OG.IS.isEmpty then
                       DI.OG.computeVariant -> var[];
                       (if (encModule -> M[]) <> none then
                           M.Qgen
                       if);
                       (DI.sig.id[],none,DI.OG[],DI.OG.super[],none,var[])
                         -> ObjTmpStack.add;
               if)if)
            #);       
          findNextImp:: (# do bcp -> DI.OG.IS.findNextImp -> impx[] #);
       #);
     ModuleItem::
       (# markForCodeGen:: (#do (if MD.isIncluded then MD.markForCodeGen if)#);
          Qgen::
            (#
            do (if MD.isIncluded then
                   (if traceModules then
                       'Module included: ' -> puttext; sig.doPT -> putline;
                   if);
                   ('ModuleItem:gen',sig.dopt) -> cd.com2;
                    (if MD.inMainPath then
                        MD[] -> mainPathModule[]
                     else
                        (useReturnValue,superAdj,staticOff) -> MD.DI.Qgen
                    if)
                else
                   (if traceModules then
                       'Module not included: ' -> puttext; sig.doPT -> putline
               if)if)
            #);
          pushThis:: (# do cd.pushThis #);
          invoke:: (# do 'ModuleItem:invoke:'-> cd.comment; MD.DI.invoke #);
          store:: (# do '\nModuleItem:store'->putline #);
          popReturn:: (# do '\nModuleItem:popReturn'->putline #);
          findNextImp:: (# do bcp -> md.findNextImp -> impx[] #);          
       #);
     DataItem::
       (* Cases
        *    C1: = integer(12)
        *    C2: = integer
        *    C3: = Fool
        *    C4: = Fool -- singular
        *       ...
        *    V1: ? integer(12)
        *    V2: ? integer
        *    V3: ? Fool
        *    V4: ? Fool -- singular
        *       ...
        *)
       (# markForCodeGen::
            (# 
            do cd.com(#do 'DataItem:markForCodeGen:'->T; sig.id[]->T;
                        ':descNo:'->T; OG.IS.newDescNo -> I; 
                        ':OG.primNo:'->T; OG.primno -> I; ' ' -> T;
                        ':'->T; doPT->T;
                     #);    
               OG.markForCodeGen
            #);
          Qgen:: 
            (# gdb:: (# do sig.id[] -> lx.puttext #);
               T: @text
            do (if isVirtualObject then
                 (*  '\***DataItem:qGen:virtual object: ' -> puttext;
                   dopt ->putline;*)
               if);
               (if true 
                // OG.isSimpleValue then
                   (* C1,C2,V1,V2 *)
                   (if true 
                    // 'Function' -> ((OG.super.last).label).equal
                    // 'Binary' -> ((OG.super.last).label).equal
                    // 'Const:' -> ((OG.super.last).label).equal
                    // 'String:' -> ((OG.super.last).label).equal
                       then
                       (* pretty ad hoc - to handle 
                        * X: = integer(7)
                        * X: ? 7
                        * X: = a + b
                        * and avoid calling OG.Qgen for 
                        * X: = integer
                        * Cf the discussion of #foo versus foo 
                        *)
                       (true,0,this(DataItem).NewOff) -> OG.Qgen;
                       cd.pushThis;
                       'dataitem:store:B' -> cd.comment;
                       'off: ' -> T.puttext; off -> T.putint;
                       ' NewOff: ' -> T.puttext; NewOff -> T.putint;
                       T[] -> CD.comment;
                       (sig.id[],this(DataItem).NewOff) -> cd.storeg
                   if);
                // (OG.primNo = String_prim) and isConst then
                   (* Could be  V: = elm where elm:< Object *)
                   (true,0,this(DataItem).NewOff) -> OG.Qgen;
                   cd.pushThis;
                   (sig.id[],this(DataItem).NewOff) -> cd.rstoreg
                else
                   (* C3,C4,V3,V4 *)
                   (* All obbjects/patterns being embedded must be handled by
                    * Alloc and gen aince we must know the size *)
                   (if isConst or not OG.IS.isEmpty or isValue then
                       (* X: = Foo or 
                       (* Singular T: = P{...} *)
                       (* C3,C4,V4 *)
                       (if origin[] <> none then 
                           cd.bcPos -> beginBCP;
                           cd.com
                           (# ptn: ^pattern; E: ^Exp; OI: ^ObjectInvocation
                           do 'DataItem:gen:'-> T; sig.id[] -> T;
                              OG.super.last -> E[];
                              (if E## = objectInvocation## then 
                                  (if ((E[] ->  OI[]).ATD## = pattern##) then
                                      (E[] ->  OI[]).ATD[] -> ptn[];
                                      ' superDescNo: ' -> T; ptn.OG.IS.newDescNo -> I;
                                      ' top: ' -> T; ptn.OG.Qvariants.top -> I;
                           if)if)#);
                           (if isArg then 
                               '\nGot arg: ' -> puttext; dopt -> putline 
                            else
                               (false,0,this(DataItem).NewOff) -> OG.Qgen
                           if);                           
                           cd.bcPos -> endBCP;
                        else 
                           (* A module object - why special handling? 
                            * Apparenly cd.bcPos is not defined here!?
                            *)
                           (if not OG.IS.isEmpty then
                               (if not useMarkForCodeGen then
                                   (sig.id[],none,OG[],OG.super[],none,OG.computeVariant) 
                                     -> ObjTmpStack.add
                               if)
                            else
                               cd.com(#do 'dataItem:gen:PG.IS.isEmpty:'-> T; sig.id[] -> T#)
                           if)   
                       if);
                       (if isValue then 
                           '**** Embed value: size: ' -> puttext; 
                           (if not OG.IS.isEmpty then
                               'S' -> put; ' '->put;
                               OG.IS.qsize[1 (*OG.IS.thisVar.thisVarNo*)] -> putint; 
                            else
                               (# ptn: ^pattern
                               do 'P'->put;  ' '->put;
                                  OG.super.ATd[] -> ptn[];
                                  ptn.OG.IS.qsize[1 (*OG.IS.thisVar.thisVarNo*)] -> putint;
                                  newline;
                                  (*ptn.dopt -> putline;*)
                               #)
                           if);
                           ' ' -> put;
                           dopt -> putline;
                       if);
                       (* else V3 - just a qualifcation; 
                        * see also the discussion of #foo versus foo *)
                       (* Could be S: ?elm where elm:< Object -- no code gen *)
                   if)
               if)
            #);
          pushThis:: (# gdb:: (#do sig.id[] -> lx.puttext #)do cd.pushThis #);
          invoke::
            (* called when not receiver - i.e. value to be pushed *)
            (# gdb:: (#do sig.id[] -> lx.puttext #)
            do (if isVirtualObject then
                   '***DataItem:invoke:isVirtualObject: ' -> puttext;
                   dopt -> putline
               if);
               (if newoff = 0 then
                   '***** newoff = 0 ' -> puttext; dopt ->putline
               if);
               (if OG.isSimpleValue then 
                   (if (E[] <> none) then
                       (if (E.ATd.primNo <> cmpAndSwap_prim) then
                           (* May happen for V := 117 where := is assignment 
                            * - no offset shall be pushed for V 
                            * since V is assigned afterwards
                            * For R ++ 117 offset for R should be pushed 
                            * since it is origin
                            *) 
                           (sig.id[],NewOff) -> cd.pushg
                        else
                           off -> cd.pushConst
                       if)
                    else
                       (sig.id[],NewOff) -> cd.pushg
                   if)
                else
                   (* Could be S: ? elm where elm:< Object *)
                   (if (CC[] <> none) and (isVirtualObject) and false then
                       'DI:invoke: ' -> puttext; dopt -> putline;
                       OG.super.ATd[] -> CC.ValueOrObject
                   if);
                   cd.com(#do 'DI:invoke:off:' -> T; newoff -> I #);
                   (sig.id[],NewOff) -> cd.rpushg
               if)
            #);
          store::
            (* Called from Signature::StoreParameters *)
            (# OGx: ^ObjectGenerator; var: ^Variant
            do cd.com(#do 'dataitem:store:' -> T;
                        (if isVirtualObject then
                            'isVirtualObject:' -> T;
                            dopt -> T
                     if)#);
               (if newAlloc and 
                   (father.father## = ObjectGenerator##) and
                   ((father.father[] -> OGx[]).IS.newDescNo = 0) then
                   'OBS! descNo = 0' -> cd.comment;
                   (if true then
                       OGx.computeVariant -> var[]
                    else
                       (1,none) -> OGx.Qalloc
                   if)
               if);
               (if OG.isSimpleValue then 
                   (sig.id[],NewOff) -> cd.storeg
                else
                   (if not noSwap then cd.rswap if); 
                   (* Could be S. ?elm where elm:< Object *)                   
                   (sig.id[],NewOff) -> cd.rstoreg
               if)
            #);
          popReturn::
            (#
            do (if OG.isSimpleValue then 
                   cd.vpop
                else
                   (* could be S. ?elm where elm:< object*)
                   cd.rpop
               if)
            #)          
       #);
     Signature::
       (# Qgen::
            (# 
            do (* TST/RemoteExp fails at      
                *    Bar(ch + 2).foo(ch + 2).print
                * if we call args.gen
                *)
               (false,0,0) -> args.Qgen
            #); 
          storeParameters:
            (#
            do scanArgsReverse
               (# D: ^Decl
               do (if not (currentPar[] -> D[]).isVirtual then
                      cd.pushThis;
                      true -> currentPar.store
                  if)
               #)
            #);
          pushReturnValues:
            (#
            do (if val[] <> none then
                   cd.setThisStack;
                   val.scanSons
                   (# D: ^Decl
                   do current[] -> D[];
                      cd.pushThis;
                      D.invoke
                   #)
                else
                   cd.setThisStack;
                   cd.pushThis;
               if)
            #);
          popReturn:
            (# 
            do (if val[] <> none then
                   val.scanSons
                   (# D: ^Decl
                   do (current[] -> D[]).popReturn
                   #)
                else
                   cd.rpop
               if)
            #);
          getReturn:
            (* Quite similar to semchecker:signature:getQual, 
             * which return an objectGenerator.
             * getReturn returns a Decl
             * May be unified!?
             *)
            (# D: ^Decl; ptn: ^Pattern
            do (if val[] <> none then 
                   val.scanSons
                   (#
                   do current[] -> D[]
                   #)
                else 
                   father[] -> ptn[];
                   (if (ptn.OG.superPtn -> ptn[]) <> none then 
                       ptn.sig.getReturn -> D[]
               if)if)
            exit D[]
            #)
       #);
     Arguments::
       (# Qgen::
            (#
            do scanArgs
               (#
               do (if traceGeneric then
                      current.doPT -> putline;
                      current.label -> putline;
                  if);
                  (false,0,0) -> current.Qgen 
               #)
            #);
       #);
     ObjectGenerator::
       (# marked: @boolean;
          markForCodeGen::
            (# markPrimElse: BooleanValue(# <<SLOT doMarkPrim:doPart>> #);
               OGs: ^ObjectGenerator; ptn: ^Pattern
            do (if not marked and markPrimElse then
                   true -> marked;
                   cd.com(#do 'OG:markForCodeGen:'-> T; dopt -> T; #);
                   (if (super[] <> none) and not super.isEmpty 
                       and ((super.last).ATd[] <> none) then
                       (if not (super.last).ATd.isPattern then
                           leave markForCodeGen
                       if);
                       (super.last).ATd[] -> ptn[];
                       (if ptn[] <> objectDecl[] then
                           cd.com(#do 'OG:markSuper:'->T ; super.dopt -> T #);
                           super.markForCodeGen; 
                   if)if);
                   (if isObjectDesc then
                       cd.com(#do 'OG:markIS:'->T; doPT -> T #);
                       IS.markForCodeGen;
                       (OGid,sig[],this(ObjectGenerator)[],super[],NONE,computeVariant)
                         -> objTmpStack.add;
                    else
                       cd.com(#do 'IS.isEmpty:'->T; doPt -> T #);
               if)if)
            #);
          computeVariant:
            (* OG.Qgen is called for a singular object
             * We thus only have one variant
             * This variant will propagate to superpatterns
             *)
            (# contextOG: ^ObjectGenerator;
               var,V: ^Variant
            enter contextOG[]
            do (*'----computeVariant:'->putline; dopt -> putline; *)
               (if contextOG[] = none then 
                   this(ObjectGenerator)[] -> contextOG[] if);
               cd.com(#do 'ComputeVariant:A:' -> T; OGid -> T #);
               Qvariants.new -> var[];                 
                   
               (* this(OG) is not sufficient 
                * For 
                *    Lrecord.insert(Record(...))
                * we need Lrecord.OG
                *)
               (contextOG[],var[]) -> Qvariants.scanObjectRefs;
               (* We have a Variant of OG; 
                * if var.top = 0, there are no data-items depending on 
                * virtual Object (Later to be replaced by Any)
                *
                * Check that var[] does not already existt
                * var returned below may differ from var above *)
               Qvariants.checkIfTopIsNew -> V[];
               (if var[] = V[] then
                   cd.com(#do 'var is new:'->T; 'top: '-> T; Qvariants.top -> I;
                            'var.thisVarNo:'-> T; var.thisVarNo -> I #);
                   (var.thisVarNo,none) -> Qalloc;
                   cd.com(#do 'computeVariant:newDescNo:'->T; IS.newDescNo -> I;
                            'IS:'->T; IS.doPT -> T #);
                else
                   cd.com(#do'var is not new:'->T #);
                   V[] -> var[]
               if);
               (*Qvariants.print;*)
               cd.com(#do 'ComputeVariant:B:' -> T; OGid -> T #);
            exit var[]
            #);        
          Qgen::
            (* Qgen is only called for singular Objects and pushed on stack
             * For patterns OG is pushed on stack and later genClass is called
             *)
            (# gdb:: 
                 (#
                 do OGid -> lx.puttext; ' '-> lx.put; dopt -> lx.puttext;
                    ' :super: ' -> lx.puttext; super.label -> lx.puttext;
                    ': '->lx.puttext;
                    super.doPT -> lx.puttext;
                    (if IS.isEmpty then 
                        '\n\t   IS-empty: ' -> lx.puttext 
                     else
                        '\n\t   singular:' -> lx.puttext
                    if);
                    'staticOff: '-> lx.puttext; staticOff -> lx.putint;
                    ' descNo: ' -> lx.puttext; IS.newDescno->lx.putint;
                    ' top:'->lx.puttext; Qvariants.top -> lx.putint
                 #);
               printQoff:
                 (#
                 do (if trace then
                        IS.scanSons
                        (# I: ^Item; D: ^Decl
                        do  current[] -> I[];
                           (if I.isDecl then 
                               I[] -> D[];
                               D.qoff[1] -> putint; ' ' -> put; D.doPT -> putline
                           if)#)if)
                 #);
               name: ^text; head: @boolean; Px: ^OGpath;
               on,pn: @integer;
               var: ^Variant;
               trace: (# exit false #);
            do (if not genIsDone then
                   (if primNo = inner_prim then
                       (*'TRYING code gen for inner'->putline*)
                   if);
                   (* Check if code has been generated for this variant *)
                   true -> genIsDone;
                   cd.com
                   (# ptn: ^Pattern; OI: ^ObjectInvocation; E: ^Exp
                   do 'ObjectGenerator:Qgen:OGid:' -> T; OGid -> T; 
                      ':doPT:'-> T; dopt -> T;
                      'IS.descNo:' -> T; IS.newDescNo -> I;
                      'OG.top:'->T; Qvariants.top->I;
                      super.last -> E[];                            
                      (if (E[] <> none) and (E## = objectInvocation##) then 
                          (if ((E[] ->  OI[]).ATD## = pattern##) then
                              (E[] ->  OI[]).ATD[] -> ptn[];
                              'super:'->T; ptn.sig.dopt -> T;
                              'superDescNo:' -> T; ptn.OG.IS.newDescNo -> I;
                              'super.OG.top:' -> T; ptn.OG.Qvariants.top -> I;
                      if)if)
                   #);
                   (* we may have 
                    * non-singular: foo
                    * Singular:     foo{...}
                    *)
                   (*computeVariant -> var[]; *)
                   
                   cd.bcPos -> beginBCP;
                   (if CC[] <> none then (* not used? *)
                       this(ObjectGenerator)[] -> CC.add -> CC[];
                   if);
                   (if hasVariants then
                       (*'\nOG.hasVariants:\n' -> puttext; dopt -> printhead;
                       Qvariants.print*)
                   if);
                   (if IS.isEmpty 
                       and not super.hasVirtualArgs 
                       or (super.isBasic and IS.isEmpty) then
                       (* Implies that super.OG is pushed on objTmpStack
                        * So should we pass the variant of this OG to Qgen?
                        *)
                       cd.com(#do 'OG:Qgen:IS.isEmpty:' -> T;#);
                       (useReturnValue,superAdj,staticOff) -> super.Qgen
                    else
                       (* Perhaps move check for virtuals to here!? *)
                       (* Singular object like R.foo{ }
                        * includes pattern invocations with 
                        * virtual arguments like %if .. %then% ... %else ...
                        *)
                       cd.com(#do 'OG:Qgen:IS is not empty:'->T; #);
                       cd.pushThis; (* origin for a singular object *)
                       (* This is also the case for R.S.foo{ ... } *)
                       
                       (* Perhaps all patterns with more than one variant
                        * should be considered singular?
                        *)
                       (* Invoke the singular object *)
                       (if not newAlloc then
                           (OGid,IS.newDescNo,staticOff,true) -> cd.invoke;
                           (if not useReturnValue then cd.rpop if);
                       if);
                       
                       cd.com(#do 'before objTmpStack:add: '->T;
                                IS.newDescNo -> I; ' ' -> T; OGid -> T #);
                       (if not useMarkForCodeGen then
                           computeVariant -> var[];
                           (OGid,none,this(ObjectGenerator)[],super[],CC[],var[])
                         -> ObjTmpStack.add;
                       if);
                       (if newAlloc then
                           (OGid,IS.newDescNo,staticOff,true) -> cd.invoke; 
                           (if not useReturnValue then cd.rpop if);
                       if)
                   if);
                   cd.bcPos -> endBCP;     
               if)
            #);
          genClass::
            (# var: ^Variant
            enter var[] (* super has more arguments *)
            do (if hasVirtualObject then
                   (if traceGeneric3 then
                       '***** HasVirtualObject: ' -> putline; 
                       (if sig[] <> none then 
                           sig.doPT -> putline;
                        else
                           doPT -> putline;
                           display
               if)if)if);
               (* Move IS.genclass to here? *)
               (N[],sig[],IS.newDescNo,super[],this(ObjectGenerator),CC[],var[])
                 -> IS.genClass
            #);
          XaddB: @
            (# off: @integer; E: ^ObjectGenerator;
               offsets: [2] @integer;
               bindingType: [2] @integer; (* 0: inner; 1: ref; 2: value *)
               bindings: [2] ^ObjectGenerator;
               top: @integer;
               copySuper:
                 (# ptn: ^Pattern
                 do (if (super[] <> none) and (super.ATd[] <> none) then
                        super.ATd[] -> ptn[];
                        (*'copySuper:' ->putline; ptn.OG.XaddB.display;*)
                        (for i: ptn.OG.XaddB.top repeat 
                             (*ptn.OG.XaddB.offSets[i] -> putint; ' '-> put;
                              ptn.OG.XaddB.bindingType[i] -> putint; newline;
                             (if ptn.OG.XaddB.bindings[i][] <> none then
                                 ptn.OG.XaddB.bindings[i].dopt -> putline;
                              else
                                 'none' -> putline
                             if);*)
                             (if ptn.OG.XaddB.offsets[i] > 0 then
                                 (ptn.OG.XaddB.offsets[i]
                                 ,ptn.OG.XaddB.bindings[i][]) 
                                   -> XaddB
                                 (*else = 0: inner *)
                             if)
                        for)                             
                    if)
                 #);
               display:
                 (# T: ^Text
                 enter T[]
                 do (if top > 0 then
                        T[] -> puttext; 
                        '*** Bindings: descNo: ' -> puttext; 
                        IS.newDescNo(*descNo*) -> putint; newline;
                        (for i: top repeat
                             i -> putint; ':' -> put;
                             offsets[i] -> putint; ':'->put;
                             (if bindingType[i]
                              // 0 then '   inner: ' -> puttext;
                              // 1 then '   ref: ' -> putline
                              // 2 then '   value: ' -> putline;
                              else 
                                 '   ???' -> putline
                             if);
                             (if bindings[i][] <> none then
                                 bindings[i].doPT -> putline
                              else 
                                 'none'->putline
                             if)
                    for)if)
                 #)      
            enter(off,E[])
            do (if handleGeneric then
                   (if off <= 0 then
                       '\n*** XaddB: off <= 0: '-> puttext;
                       off -> putint; newline;
                       dopt -> putline;
                       E.doPT -> putline;
                       leave XaddB
                   if);
                   (if off > bindings.range then
                       (off + 2 - bindingType.range) -> bindingType.extend;
                       (off + 2 - bindings.range) -> bindings.extend;
                       (off + 2 - offsets.range) -> offsets.extend;
                   if);
                   (if off > top then off -> top if);
                   off -> offsets[off];
                   (*'Add:' -> puttext; E.doPT -> puttext; 
                    ' ' -> put; off -> putint;
                    ' ' -> put; E.primNo -> putint; newline;*)
                   (if E.primNo // integer_prim then 
                       (* '--value--'->putline;*)
                       2 -> bindingType[off]
                    else 
                       1 -> bindingType[off]
                   if);
                   E[] -> bindings[off][];
               if)
            #)
       #);
     items::
       (# markForCodeGen::
            (#
            do cd.com(#do 'items:markForCodeGen:'->T; doPT -> T; #);
               scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if current.isDataItem then
                      current.MarkForCodegen 
                   else
                      (if I.isDecl then
                          (if not I.isPattern or I.isVirtual or(I[] = StringDecl[]) then
                              (if I[] = StringDecl[] then
                                  cd.com(#do 'Items:markString'->T; dopt->T #)if);
                              current.MarkForCodeGen 
                          if)
                       else
                          cd.com(#do 'markItem:"'->T; current.doPT -> T; '":'->T;
                                current.label -> T #);
                          current.MarkForCodeGen 
                      if)
                   if)
               #);
            #);
          genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; super: ^Invocation;
               var: ^Variant;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
               enclosingOG,OG: ^ObjectGenerator;
               BindVirtuals:
                 (# handleDecl:
                      (# mkStubName:
                           (# T: ^text
                           do 'Vstub#' -> T[];
                              (if sig[] <> none then
                                  sig.id[] -> id[] -> T.append;
                               else
                                  'S' -> id[] -> T.append
                              if);
                              '#' -> T.put;    
                              OG.vDescNo -> T.putint;
                           exit T[]
                           #);
                         D: ^Decl; OG: ^ObjectGenerator; ptn: ^Pattern;
                         id: ^text; dNo: @integer; var: ^Variant
                      enter(D[],OG[])
                      do (if D.isVirtual then
                             (if OG.nonVirtualBinding (*OG.vDescNo > 0*) then
                                 (if newAlloc then
                                     QnewDesc -> dNo
                                  else
                                     newDesc -> dNo
                                 if);
                                 cd.com(#do 'genClass:BindVirtuals:descNo:'
                                            -> T;
                                          dNo -> I
                                       #);
                                 objectDecl[] -> ptn[];
                                 (mkStubName,dNo,false,ptn.OG.IS.newDescNo,newOriginOff) 
                                   -> cd.class;
                                 'Load origin' -> cd.comment;
                                 (if OG.isVirtualArg then
                                     (OG.super.on + 1,OG.super[]) -> goOrigin;
                                  else
                                     (OG.super.on,OG.super[]) -> goOrigin;
                                 if);
                                 cd.com
                                 (#do 'OG.super.on/descNo:' -> T; OG.super.on->I; 
                                    OG.getDescNo->I #);
                                 (if OG.getDescNo = 0 then
                                     (* move to vvariants.bet *)
                                     (# ptn: ^Pattern
                                     do OG.super.ATd[] -> ptn[];
                                        'OBS! genclass:virtual descNo = 0' -> cd.comment;
                                        (if true then
                                            OG.computeVariant -> var[]
                                         else
                                            (1,none) -> ptn.OG.Qalloc;
                                        if);
                                        OG.getDescNo -> putint; newline
                                     #);
                                 if);
                                 (id[],OG.getDescNo,0,true) -> cd.invoke;
                                 'D' -> cd.rtn;
                                 (* The vdtTableAt here overrides the one in 
                                  * HandleVirtArgument (check it)
                                  *)
                                 cd.com(#do 'vdt:a'-> T #);
                                 (D.off,dNo,newDescNo) -> CD.vdtTableAt
                          if)if)
                      #);
                    ptn: ^Pattern;
                    E: ^Exp;
                    args: [6]^ObjectGenerator; top,i: @integer;
                 do (if super[] <> none then
                        super.scanSons(# do current[] -> E[] #);
                        (if E[] = none then 
                            (*'e is none' ->putline; dopt -> putline;*)
                            leave BindVirtuals
                        if);
                        (*'*** Handle VB: '->puttext; dopt -> putline;*)
                        (* 'E: ' -> puttext; E.doPT -> putline;*)
                        (if E.args[] <> none then
                            E.args.scanArgs
                            (#
                            do (if (top+1 -> top) > args.range then 
                                   args.range -> args.extend 
                               if);
                               current[] -> args[top][];
                            #);     
                            (if super.ATd[] <> none then
                                super.ATd[] -> ptn[];
                                (* 'ptn: ' -> puttext; ptn.dopt -> putline;*)
                            (if ptn.OG.sig[] <> none then
                                ptn.OG.sig.scanArgs
                                (# i: @integer
                                do i + 1 -> i;
                                   (currentArg[],args[i][]) -> handleDecl 
                                #)                                
                        if)if)if)
                    if);
                    scanSons
                    (# I: ^Item; D: ^Decl; ptn: ^Pattern
                    do current[] -> I[];
                       (if I.isDecl then 
                           I[] -> D[];
                           (if D.isVirtual then
                               D[] -> ptn[];
                               (I[],ptn.OG[]) -> handleDecl 
                       if)if)
                    #)
                 #);               
               mainPathModule: ^Module;     
               CC: ^CallChain; superVar: ^Variant
            enter(N[],sig[],descNo,Super[],OG[],CC[],var[])
            do (* Is called with descNo = NewDescNo *)
               (* We must know the actual variant being generated for
                * The actual variant should have info about: 
                * actual descNo and actual storage layout 
                *)
               cd.com(#
                     do 'GenClass:'->T; N[] -> T;
                        (if (var[] <> none) then
                            ' :varNo = '-> T; var.thisVarNo -> I;
                         else
                            ':var is none' -> T
                        if);
                     #);

               (if not OG.Qvariants.isEmpty then
                  (* '\n***** GenClass,N: ' -> puttext; 
                   N[] -> printNotNone; newline;
                   (if sig[] <> none then sig.doPT -> puttext; if);
                   ' varNo = ' -> puttext;
                   (if var[] <> none then var.thisVarNo -> putint if);
                   ' genDone = '->puttext;
                   (if var.genDone then 'True ' -> puttext if);
                   newline;
                   OG.Qvariants.print;*)
               if);
               (if (superDesc[] <> none) then
                   (* get the ptn decl for super: *)
                   superDesc.father.father -> ptn[]; 
                   (*'\n*** OBS! genClass:super: ' -> puttext;
                   ptn.sig.id[] -> putline;*)
                   (if (var[] <> none) then
                       (if var.thisVarNo > 0 then
                           (*'\n>>> genClass for ' -> puttext; N[] ->printNotNone;
                           ' varNo = ' -> puttext;
                           var.thisVarNo -> putint; *)
                           (* we should find the corresponding var in super 
                            * perhaps we should use the same object?
                            *)
                           var[] -> ptn.OG.Qvariants.findSuperVar -> superVar[];

                           (*(if superVar[] <> none then
                               '\n>>> superVarNo: ' -> puttext;
                               supervar.thisvarNo -> putint; 
                               ' genDone='->puttext;
                               (if superVar.genDone then 'True' -> puttext if);
                            else
                               'SuperVar is none'->puttext
                           if);
                           newline;
                           dopt -> printHead      *)                  
                       if);
                    else
                      (* '\n>>> genClass for ' -> puttext; 
                       N[] -> printNotNone; 
                       ' (var = none)\n' -> putline;
                       dopt -> printHead;*)
                   if);

                   (if (superVar[] <> none) and not superVar.genDone 
                       or 
                       (superVar[] = none) and not superDesc.done then
                       (* the actual variant beging generated here must be
                        * propagated to super possibly implying that a new
                        * variant of super must be generated;
                        * we have actually propagated the actual var to the
                        * super, so should the propagation imply a 
                        * codegen (on objTmpStack) or should we do it here?
                        *)
                       (if newAlloc then
                           (* Should be done in Variants::QAlloc *)
                           (*'\n***genClass:super: '->puttext;
                           ptn.sig.id[]->puttext;
                           ' varNo:'->puttext; 
                           
                           (if superVar[] <> none then
                               superVar.thisVarNo -> putint
                            else
                               '++none++' -> puttext
                           if);
                           ' descNo:'->puttext;
                           (for i: ptn.OG.IS.QdescNo.range repeat
                                ' ' -> put;
                                ptn.OG.IS.QdescNo[i] -> putint;
                                
                           for);*)
                           
                           (if ((superVar[]  <> none) and
                               (superDesc.QdescNo[superVar.thisVarNo] = 0)) or
                               (superDesc.newDescNo = 0) then 
                               (*':alloc:\n'->puttext;*)
                               'OBS! Qalloc:??'-> cd.comment;
                               (if superVar[] <> none then
                                   (superVar.thisVarNo,none) -> ptn.OG.Qalloc
                                else
                                   (if true then
                                       ptn.OG.computeVariant -> var[]
                                    else
                                       (1,none) -> ptn.OG.Qalloc;
                                   if)
                               if);
                            else
                               (*newline;*)
                           if);

                           (ptn.sig.id[],ptn.sig[]
                           ,superdesc.newDescNo
                           ,ptn.OG.super[]
                           ,ptn.OG[],CC[]
                           ,superVar[]) 
                             -> superDesc.genClass;
                           (* Perhaps vdtTableCopy below does not work
                            * if we have not called genClass!?
                            *)
                        else
                           (ptn.sig.id[],ptn.sig[]
                           ,superdesc.newDescNo(*descNo*)
                           ,ptn.OG.super[]
                           ,ptn.OG[],CC[],var[]) 
                             -> superDesc.genClass
               if)if)if);
               (*(if true 
                // (var[] = none) then done -> printBoolean 
                // var[] <> none then var.genDone -> printBoolean
                if);*)
               (if (var[] -> thisVar[]) <> none then
                   (if newDescNo = 0 then
                       ('\n\n!!! OBS! var.newDescNo = 0 ',N[],' varNo: ') -> putTextL;
                       (if var[] <> none then
                           var.ThisVarNo -> putint; newline;
                           (var.thisVarNo,none) -> OG.Qalloc;
                           ' newDescNo: ' -> puttext;
                           newDescNo -> putint; newline;
                           var.print;
                       if);
                       'dopt: '->puttext; label -> putline; father.label -> putline;
                       father.dopp-> putline;
                       father.father.dopp-> putline;
                       father.father.dopt -> putline;
                       (dumpStack,'---') -> stop;
               if)if);
               
               (if (var[] = none) and not done or 
                   (var[] <> none) and not var.genDone then
                   (if (var[] <> none) and done then
                       (* we must eliminate this case 
                        * there should always be var <> none *)
                       cd.com(#
                             do 'OBS! calling genClass for:' -> T; N[] -> T;
                                ':var<>none:Done:'->T;  done->B;
                                ':leave genClass' -> T
                             #);
                       (* (dumpStack,'---') -> stop;*)
                       true -> var.genDone;
                       leave genclass
                   if);
                   (if var[] <> none then 
                       cd.com
                       (#
                       do 'GenClass:'->T; N[] -> T; ':true -> var.genDone' -> T #);
                       true -> var.genDone
                    else 
                       true -> done 
                   if);
                   
                   OG.XaddB.copySuper;

                   (N[],newDescNo,false,(topSuper).newDescNo,qsize[thisVar.thisVarNo]) -> cd.class;
                   (* thisObj = the new instance of this class 
                    * thisStack = caller
                    * Possible arguments on callerStack
                    *)
                   cd.bcPos -> beginBCP;
                   (* store parameters + origin *)
                   (if sig[] <> none then sig.storeParameters if);
                   (*'GenClass,items, ' -> puttext; N[] -> puttext;
                    ' ' -> put; newOriginOff -> putint; newline;*)
                   (if noGlobals and elimOrigin  then
                       (if traceNoGlobals then
                           '*** No globals-do not store origin' -> putline;
                           'do not store origin'->cd.comment;
                           dopt -> putline;
                       if)
                       (*cd.rPop*)
                    else                   
                       ('origin',newOriginOff) -> cd.rstore;
                   if);
                   not doHasCode -> cd.allocEventQ;
                   
                   (if (superDesc[] <> none) and not superDesc.isBasic
                       or (superDesc[] <> none) 
                       and ((superDesc.primNo = stringDecl.primNo) 
                       or (superDesc.primNo = immutable_prim)) then
                       (ptn.sig.id[],superDesc.newDescNo)  -> cd.super; 
                       cd.com(#do 'vdt:b'-> T #);
                       superDesc.newDescNo -> cd.vdtTableCopy;
                       (if superDesc.innerInx > 0 then
                           cd.com(#
                                 do 'vdt:c:innerInx: '-> T; 
                                    superDesc.innerInx -> I;
                                    ' descNo: ' -> T; newDescno -> I 
                                 #);
                           (superDesc.innerInx,newDescno) -> cd.vdtTable;
                           true -> hasSuperAndInner
                       if);
                       (* push super arguments *)
                       
                       (if super.isImplSuper then
                           (if elimOrigin and noGlobalsInsuper then
                            else
                               (if super.isSingularImplSuper then
                                   cd.pushThis;
                                   ('iOrigin',newOriginOff) -> cd.rpushg
                                else
                                   super.ATd[] -> ptn[];
                                   origin[] -> vSuperDesc[]; (* find desc enclosing vDcl *)
                                   (for i: super.pn repeat
                                        vSuperDesc.superDesc[] -> vSuperDesc[]
                                   for);
                                   cd.pushThis;
                                   ('origin',newOriginOff) -> cd.rpushg;
                                   (* No arguments for super, so no
                                    * - newOriginOff for loadArgs as below
                                    *)
                                   (ptn.OG.super.on,none) -> vSuperDesc.goOrigin
                           if)if)
                        else
                           (# E,rec: ^Exp
                           do (*'GenItems:' -> puttext;
                              super.doPT -> puttext;
                              ' newOriginOff:'->puttext;
                              newOriginOff -> putint; 
                              ' super.on: ' -> puttext;
                               super.on -> putint; newline;*)
                              (if elimOrigin and noGlobalsInSuper then
                                  super.scanSons
                                  (#
                                  do current[] -> E[];
                                     (if not isLast then E[] -> rec[] 
                                      else
                                         (if isFirst then E[] -> rec[]
                                     if)if)
                                  #)
                               else 
                                  (true,0,newOriginOff,CC[]) -> Super.loadOrigin 
                                    -> (rec[],E[])
                              if);
                              (if sig[] = none then
                                  'Super:sig none'->cd.comment;
                                  (newOriginOff,CC[]) -> E.loadArgs; 
                               else
                                  'Super:sig not none'->cd.comment;
                                  (* go ON - 1 
                                   * but use newOriginOff first time
                                   *)
                                  (- newOriginOff,CC[]) -> E.loadArgs; 
                              if);
                           #);
                       if);
                       superDesc.newDescNo -> cd.toSuper;
                       cd.markEnterE;  
                   if); 
                   (if newDescNo = (markIncludes.topModule.desc).newDescno then
                       cd.pushThis;
                       cd.saveBETAworld
                   if);
                   (if (superDesc[] <> none) and not superDesc.isBasic  then
                    else cd.mvStack
                   if);
                   (if sig[] <> none then
                       (false,0,0) -> sig.Qgen
                   if);
                   scanSons
                   (# I: ^Item; MP: ^Module
                   do current[] -> I[];
                      (if I.isDecl then
                          (if not I.isPattern or I.isVirtual then
                              (false,0,0) -> current.Qgen -> MP[];
                              (if MP[] <> none then
                                  MP[] -> mainPathModule[];
                              if)
                           else
                              (if I[] = StringDecl[] then
                                  (false,0,0) -> current.Qgen if) 
                   if)if)#);
                   (if mainPathModule[] <> none then
                       (false,0,0) -> mainPathModule.DI.Qgen
                   if);
                   (if innerInx > 0 then innerInx -> cd.innerA if);
                   (if (superDesc[] <> none) and not superDesc.isBasic then
                       cd.rtnInner 
                    else
                       (if doHasCode then 
                           1 -> cd.rtnEventQ 
                        else
                           0 -> cd.rtnEventQ 
                       if)
                   if);
                   
                   (* Code for action part *)
                   (false,doHasCode) -> cd.actions;
                   (*restartLab.new;
                   leaveLab.new;*)
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item; 
                   do current[] -> I[];
                      (if not I.isDecl then 
                          cd.com(#do 'genclass:Qgen:stmt:'-> T; current.doPT ->T#);
                          (false,0,0) -> current.Qgen 
                      if) 
                   #);
                   leaveLab -> cd.defLab;
                   (* we must push return values *)
                   (* push return value 
                    * - for DataItem: R: @Foo
                    *   Foo should return (this(Foo)
                    *   perhaps default?
                    * - otherwise push variables in -> 
                    *)
                   (if (superDesc[] <> none) and not superDesc.isBasic then
                       cd.rtnInner
                    else
                       0 -> cd.rtnEventQ;
                       cd.com(#
                             do 'OG:pushReturn:' -> T; 
                                (if sig[] = none then '-none-'->T
                                 else
                                    sig.id[] -> T if)#);
                       (if sig[] <> none then 
                           sig.pushReturnValues 
                        else
                           (* ad hoc *)
                           cd.setThisStack;
                           cd.pushThis
                       if);
                       'D' -> cd.rtn;
                   if);
                   (vsize,rsize,1) -> CD.endClass;
                   cd.bcPos -> endBCP
               if);
               (if traceGeneric2 then
                   (father[] -> enclosingOG[]).XaddB.display
               if);
               BindVirtuals
            #);
          goOrigin:
            (# on: @integer; NA: ^Apl; org: ^Items; T: ^text; var: ^Variant
            enter(on,NA[])
            do (if on > 0 then
                   OT.OGid -> T[]; ':origin' -> T.append;
                   (* For each pattern in the origin chain, we must check
                    * whether or not the specific pattern has restrictions
                    * that are violated
                    *)
                   NA[] -> checkGlobals;
                   (* how do we with newAlloc ensure that code is generated for
                    * OGs in the origin chain?
                    *)
                   (if basicNo = ifthen_prim then
                       (on,NA[])  -> (origin[]->org[]).goOrigin -> org[]
                    else
                       (if OT.IS.newOriginOff = 0 then 
                           (*father.dopt -> putline;*)
                           (* move to vvariants.bet'*)
                           'OBS! Qalloc, originOff = 0 ' -> cd.comment;
                           (if true then
                               OT.computeVariant -> var[]
                            else
                               (1,none) -> OT.Qalloc
                           if)
                       if);
                       cd.com(#do 'goOrigin:'-> T; OT.OGid-> T; 
                                OT.IS.newOriginOff -> I; newOriginOff -> I #);
                       (T[],newOriginOff) -> cd.rpushg;
                       (if origin[] <> none then
                           (on - 1,NA[]) -> (origin[]->org[]).goOrigin -> org[]
                        else
                           'Origin is none: ' -> puttext; on -> putint; newline
                       if)
                   if)
                else
                   this(Items)[] -> org[]
               if)
            exit org[]
            #); 
          hasSuperAndInner: @Boolean;

          findNextImp::
            (#
            do L:
                 scanSons
                 (#
                 do (if (bcp -> current.findNextImp -> impx[]) <> none then
                        leave L
                 if)#);
            #)            
       #);
     Pattern::
       (# genIsDone: @boolean;
          markForCodegen::
            (#
            do cd.com(#do 'Pattern:markForCodeGen:' -> T; ; dopt -> T;#);
               OG.markForCodeGen
            #);
          Qgen::
            (# gdb:: (# do sig.dopt -> lx.puttext #);
               enclosingOG: ^ObjectGenerator;
               DN: @integer
             do (if not genIsDone then
                    true -> genIsDone;
                    (if OG.primNo
                     // 0 
                     // object_prim // value_prim
                     // string_prim 
                     // indexed_prim // immutable_prim then
                        (if OG.IS.isExternal > 0 then leave Qgen if);
                        (if ptnKind 
                         // plainPtn then
                            (if not useMarkForCodeGen then
                                (sig.id[],sig[],OG[],OG.super[],CC[],OG.computeVariant)
                                  -> objTmpStack.add;             
                            if)
                         // virtualPtn then
                            (if not OG.hasItems  then
                                cd.com(#do 'vdt:d'-> T #);
                                (* Qalloc moved to vvariant.bet *)
                                (off,(OG.super.desc).newDescNo) -> cd.vdtTable;
                                (if traceGeneric then
                                    '*** Bind1: ' -> puttext;
                                    off -> putint; ' ' -> put; 
                                    (OG.super.desc).newDescNo -> putint; newline;
                                    dopt -> putline;
                                if);
                             else
                                (if not useMarkForCodeGen then
                                    (sig.id[],sig[],OG[],OG.super[],CC[],OG.computeVariant)
                                      -> objTmpStack.add;
                                if);
                                cd.com(#do 'vdt:e'-> T #);
                                (if OG.IS.newDescNo = 0 then
                                    'OG.IS.newDescNo = 0' -> cd.comment;
                                if);
                                (off,OG.IS.newDescNo) -> cd.vdtTable;
                                (if traceGeneric then
                                    '*** Bind2: ' -> puttext;
                                    off -> putint; ' ' -> put; 
                                    OG.IS.newDescNo -> putint; newline
                                if)
                            if);   
                            (if father.father##
                             // ObjectGenerator## then
                                (off, OG[]) 
                                  -> (father.father[]-> enclosingOG[]).XaddB
                             // Signature## then
                                (# ptn: ^pattern
                                do (off, OG[]) 
                                     -> (father.father.father[]-> ptn[]).OG.XaddB
                                #)
                             else                           
                                'Koks'->putline;
                                father.father.label -> putline
                            if)
                         // furtherPtn // finalPtn then
                            (if OG.IS.isEmpty then 
                                OG.vDescNo -> DN;
                                cd.com
                                (#do 'vdtTable: off: ' -> T;
                                   off -> I; ' descNo: ' -> T; DN -> I; 
                                #);
                             else
                                (if not useMarkForCodeGen then
                                    (sig.id[],sig[],OG[],OG.super[],CC[],OG.computeVariant) 
                                      -> objTmpStack.add;
                                if);
                                (if true then
                                    OG.IS.newDescNo -> DN
                                 else
                                    OG.getDescNo -> DN;
                                if);
                                cd.com(#do 'vdt:f:'-> T; DN -> I;
                                           'getDescNo:' -> T; OG.getDescNo -> I #);
                                (off,DN) -> cd.vdtTable;
                            if);
                            (* cd.com(#do 'vdt:F'-> T #);
                             * (off,DN) -> cd.vdtTable;
                             *)
                            (if traceGeneric then
                                '*** Bind3: ' -> puttext;
                                off -> putint; ' ' -> put; 
                                OG.IS.newDescNo -> putint; newline ;
                                dopt -> putline
                            if);
                            (off, OG[]) -> (father.father[]-> enclosingOG[]).XaddB
                        if);
                        
                        (*// resume_prim then
                         ('Resume','D') -> cd.call;  *)
                if)if)
            #);
          pushThis:: 
            (# gdb:: (# do sig.dopt -> lx.puttext #); T: @text
            do (if OG.primNo
                // 0 
                // value_prim  (* OBS - needed for a ptn being sub of Value
                                * otherwise execution fails since origin 
                                * is not loaded
                                * An explicit sub of Object also fails
                                *)
                // this_prim 
                // indexedGet_prim (* not tested*)
                // indexedPut_prim (* ditto *)
                // stringGet_prim 
                // indexed_prim 
                // immutable_prim then
                   cd.pushThis 
                else (* ugly *)
                   (if ptnKind // virtualPtn // furtherPtn // FinalPtn then
                       cd.pushThis 
                   if)
               if)
            #);
          loadArgs::
            (# gdb:: (# do sig.doPT -> lx.puttext; 
                        ' E: ' -> lx.puttext;
                        E.doPT -> lx.puttext;
                        ' descNo: ' -> lx.puttext; OG.IS.newDescNo -> lx.putint;
                        ' top: ' -> lx.puttext; OG.Qvariants.top -> lx.putint
                     #);
               actArgs: [6]^ObjectGenerator; (* actaul arguments *)
               top,i: @integer;
               enclosingOG: ^ObjectGenerator;
               var: ^Variant
            do (if OG.primNo 
                   (* Some of these are handled in invoke below
                    * May be moved to here*)
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   (* skip *)
                else
                   E.args.scanArgs
                   (#
                   do (if (top+1 -> top) > actArgs.range then 
                          actArgs.range -> actArgs.extend 
                      if);
                      current[] -> actArgs[top][];
                   #);
                   (* we also need to scan possible arguments of super *)
                   sig.scanArgs
                   (* we also need to scan possible arguments of super *)
                   (# Ex: ^Exp; OI: ^ObjectInvocation;
                      OG: ^ObjectGenerator; name: ^text; descNo: @integer;
                      ptn: ^Pattern
                   do i + 1 -> i;
                      (* can we do currentArg.LoadArg?
                       * And then perhaps special for virtuals primitive
                       * and ptName? Virt is of course ptn *)
                      (* 'Arg: ' -> puttext; D.doPT -> putline;
                       * args[i].doPT -> putline;args[i].primno -> putint; 
                       * ' ' -> put; (args[i].desc).primno -> putint; 
                       * (if args[i].isSimpleValue then 'S' -> put if);
                       * newline;*)
                      handleVirtArg:
                        (if currentArg.isVirtual then
                            (if primNo = indexed_prim then
                                leave handleVirtArg
                            if);
                            L:
                              actArgs[i].super.scanSons
                               (#do current[] -> Ex[]; leave L #);
                            (if (Ex[] <> none) and (Ex.isObjectInvocation) then
                                Ex[] -> OI[];
                                (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                    OI.ATd[] -> ptn[];
                                    (if not useMarkForCodeGen then
                                        (ptn.sig.id[],none,ptn.OG[]
                                        ,ptn.OG.super[],none
                                        ,ptn.OG.computeVariant) 
                                          -> ObjTmpStack.add;
                                    if);
                                    
                                    (actArgs[i].desc).newDescNo -> descNo; 
                                    
                                    (* descNo: ' -> puttext; 
                                     * descNo -> putint; ' ' ->put;
                                     * OI.ATd.primNo -> putint; ' ' -> put;
                                     * OG.super.primNo -> putint
                                     * newline;
                                     *)                                     
                                    (* Perhaps OG below is enclosingOG as
                                     * also used below?
                                     * need OG.descNo for VDT *)
                                    E.father.father[] -> OG[]; 
                                    
                                    (* '>>>> ArgBinding: ' -> puttext;
                                     args[i].getDescNo -> putint; ' ' -> put;
                                     args[i].doPT -> puttext;
                                     ' :vDescNo: ' -> puttext;
                                     args[i].vDescNo -> putint; newline;*)
                                    (* May be (always?) overwritten in
                                     * generation og vStub in 
                                     * BindVirtuals::handleDecl
                                     *)
                                    (# inx: @integer
                                    do i -> inx;
                                    cd.com(#
                                          do 'vdt:g'-> T;
                                             actArgs[inx].vDescNo -> I;
                                             (OG.desc).newDescNo -> I
                                          #)#);
                                    (currentArg.Off,actArgs[i].vDescNo,(OG.desc).newDescNo) 
                                      -> cd.vdtTableAt;
                                    (if traceGeneric then
                                        '*** Bind4: ' -> puttext;
                                        currentArg.doPT -> putline;
                                        currentArg.Off -> putint; ' descNo: ' -> puttext; 
                                        (OG.desc).newDescNo -> putint; 
                                        ' primno: ' -> puttext;
                                        actArgs[i].primno -> putint;
                                        newline
                                    if);
                                    (currentArg.Off, actArgs[i][])
                                     -> (E.father.father[]-> enclosingOG[])
                                    .XaddB;
                                    leave handleVirtArg
                                if);
                            if);   
                            (if (E.desc).primNo = indexed_prim then 
                                (* We ignore bindings of elm in Indexed *)
                                leave handleVirtArg
                             else
                                (if actArgs[i].primNo = integer_prim then
                                    '\n*** Virtual bound to integer in\n\n\t'
                                      ->puttext;
                                    E.doPT -> putline;
                                    '\n    is ignored by the compiler\n' 
                                      -> putline;
                                    leave handleVirtArg
                                if);
                            if);                              
                            (* Perhaps always computeVariant -> var
                             * we need descNo to compute name so
                             * cannot be part of tmpStack.add *)
                            (if actArgs[i].IS.newDescNo = 0 then
                                'OBS-x! Qalloc - descNo = 0' -> cd.comment;
                                (if true then
                                    actArgs[i].computeVariant -> var[]
                                 else
                                    (1,none) -> actArgs[i].Qalloc
                                if)
                            if); 
                            currentArg.sig.id.copy -> name[];
                            '#SB#' -> name.append;
                            (actArgs[i].desc).newDescno -> descNo -> name.putint;
                            (# inx: @integer
                            do i -> inx;
                               cd.com(# og: ^ObjectGenerator
                                     do 'handleVirtArg:' -> T; name[] -> T;
                                        'actArgs['->T; inx -> I; ']'-> T;
                                        actArgs[inx].dopt -> T;
                                        actArgs[inx].label -> T;
                                        'argDescNo:'->T; descNo -> I;
                                        'E:'->T; E.dopt -> T; '::'->T;
                                        E.father.father.dopt -> T; '::'->T;
                                        ((E.father.father-> OG[]).desc).newdescno -> I;
                                     OG.label -> T
                                  #);
                            #);
                              
                            (if (descNo = 0) or (actArgs[i].IS.newDescNo = 0) then
                                '\n\n*** Fatal error: descNo = ' -> puttext;
                                descNo -> putint; 
                                ' actArgs[i].IS.newDescNo = ' -> puttext;
                                actArgs[i].IS.newDescNo -> putint; newline;
                                actArgs[i].doPT -> putline;
                                currentArg.doPT -> putline;
                                newline;
                            if);
                            (if not useMarkForCodeGen then
                                (if var[] = none then
                                    E.father.father[] -> OG[];
                                    (name[],none,actArgs[i][],actArgs[i].super[],CC[],OG.computeVariant)
                                      -> ObjTmpStack.add
                                 else
                                    (name[],none,actArgs[i][],actArgs[i].super[],CC[],var[])
                                      -> ObjTmpStack.add;
                            if)if);
                            E.father.father[] -> OG[]; (* need OG.descNo for VDT *)
                            (*'\n vdtTableAt: ' -> puttext; 
                             currentArg.Off -> putint; ' ' -> put;
                             descNo -> putint; ' ' -> put;
                             (OG.desc).newDescNo -> putint; newline;
                             OG.doPT -> putline;
                             currentArg.sig.doPT -> putline;*)
                            cd.com(#
                                  do 'vdt:h:argDescNo:'-> T; descno -> I;
                                     'OG.descNo:' -> T;
                                     (OG.desc).newDescNo -> I;
                                     OG.doPT ->T
                                  #);
                            (currentArg.off,descno,(OG.desc).newDescNo) -> cd.vdtTableAt;
                            (if traceGeneric then
                                '*** Bind5: ' -> puttext; 
                                currentArg.off -> putint; ' ' -> put;
                                (OG.desc).newDescNo -> putint; newline;
                                actArgs[i].doPT -> putline;
                            if);
                            (currentArg.off, OG[]) 
                              -> (father.father[]-> enclosingOG[]).XaddB
                         else
                            (if i > top then
                                (* Either to few arguments or Super as in
                                 *    foo{ ... }
                                 * where foo has arguments - to be fixed! *)
                             else
                                (true,superAdj,0) -> actArgs[i].Qgen
                            if)
                   if)#);
                   handleSuperArgs:
                     (if i < top then 
                         (* a hack - need to scan arguments of super *)
                         i + 1 -> i;
                         (true,superAdj,0) -> actArgs[i].Qgen;
                         restart handleSuperargs
                   if)
               if)
            #);
          invoke::
            (# gdb:: (# do sig.doPT -> lx.puttext; 
                        ' descNo: ' -> lx.puttext; OG.IS.newDescNo -> lx.putint;
                        ' top: ' -> lx.puttext; OG.Qvariants.top -> lx.putint 
                     #);
               org: ^Items; exitLab: @labelHandler.label;               
               doBreak:
                 (# IS: ^Items; Ex : ^ObjectGenerator; 
                    primNo,ON: @integer
                 enter primNo
                 do E.args.scanArgs(# do current[] -> Ex[]#);
                    Ex.super.on -> ON;
                    (* We assume ON > 0 as in
                     *    L: = { ... }
                     * but perhaps not the case in
                     *    cycle{ ... }
                     *)
                    ON - 1 -> (E.origin[] -> IS[]).toOrigin -> IS[];
                    (if primNo
                     // restart_prim then 
                        (if ON = 1 then
                            IS.restartLab -> cd.jmp
                         else
                            (ON - 1, IS.restartLab,IS.newDescNo) -> cd.break 
                        if)
                     // leave_prim then 
                        (if ON = 1 then
                            IS.leaveLab -> cd.jmp
                         else
                            (ON - 1, IS.leaveLab,IS.newDescNo) -> cd.break
                        if)
                    if)
                 #);   
               doPrimElse: BooleanValue(#<<SLOT doPrimElse:doPart>> #);
               exNo: @integer; N:^ Node; di: ^DataItem; var: ^Variant
            do cd.com(#
                     do' Pattern:invoke:'->T; OG.OGid->T #);
               (*(if not OG.IS.isEmpty then
                   (OG.OGid,OG.sig[],OG[],OG.super[],CC[],none) -> ObjTmpStack.add;
                if);*)
               (if doPrimElse then
                   (* Cases: E is an invocation of a pattern as in E, rec.E, R.rec.E, .
                    * (a)The receiver, rec, may be a constant or variable dataItem
                    * (For a variable DI, we forbid assigment etc if virtual Object)
                    * We have rec.E, like Lrecord.insert(...)
                    * rec may have virtual bindings that qualify data-items in E
                    * E is an invocation of this(Pattern)
                    * Find out if a new variant of this(Pattern) is needed
                    * In List example insert is local to List
                    * (b)The receiver may be a pattern as in Foo(...).bar(...)
                    * (a) We may mark OG as having virtual Object: 
                    * OG (insert) has probably no variants since local to List
                    * We have to create a new variant based on the bindings 
                    * in rec (Lrecord)
                    * For each virtual Object ref, or DI there is a variant
                    * with the corresponding bindings in the reciver
                    * Note we may need to consider the whole invocation list
                    * R.S.foo(...) R and S may have bindings
                    *)
                   cd.com(#do'Pattern:invoke:descNo:'->T; OG.is.newDescNo -> I;
                            ' top:' -> T; OG.Qvariants.top -> I
                         #);
                   (* We must understand the differences between
                    * computeVariant and computeVariantX and the different 
                    * situations below where computeVarints(X) is called
                    *)
                   (if rec[] = E[] then
                       (if not useMarkForCodeGen then
                           (OG.OGid,OG.sig[],OG[],OG.super[],CC[]
                           ,OG.Qvariants.computeVariantX)
                             -> ObjTmpStack.add
                       if)
                    else                
                       (if not useMarkForCodeGen then
                           (OG.OGid,OG.sig[],OG[],OG.super[],CC[],OG.computeVariant)
                             -> ObjTmpStack.add;
                       if);
                       (if rec.ATd## = dataItem## then 
                           (* if receiver is constant, then only one variant *)
                           rec.ATd[] -> OG.Qvariants.computeVariantX
                           (# H:: (# do head #);
                              head: @
                                (# done: @boolean
                                do (if not done then
                                       true -> done;
                                       ('\n***pattern:invoke:rec: '
                                       ,rec.dopt,' . ',E.dopt,'\n'
                                       ,OG.dopt,'\n')
                                         -> putTextL;
                                   if);
                                #);
                           #) -> var[];
                           (if var[] <> none then
                              (* var.print;
                               OG.Qvariants.print*)
                           if)
                        else 
                           (* Receiver and rec.ATd is module 
                            * or pattern (as in foo(e).bar) 
                            * but receiver is actually the return 
                            * value of foo *)
                           OG.Qvariants.computeVariantX -> var[];
                           cd.com(#do 'Rec:module or pattern:'-> T; sig.id[] -> T;
                                    ' descNo: ' -> T; OG.IS.newDescNo -> I;
                                    ' top: ' -> T; OG.Qvariants.top -> I; OG.dopt->T
                             #);
                   if)if);
                   cd.com(#do 'pattern:invoke:rec:' -> T; rec.dopt -> T #);
                   (if ptnKind // virtualPtn // furtherPtn // finalPtn then
                       (sig.id[],off) -> cd.sendVirtual
                    else 
                       (if not isBasicPtn then 
                           (if var[] <> none then 
                               (if OG.IS.newDescNo = 0 then
                                   'OBS! Qalloc-X' -> cd.comment;
                                   (var.thisVarNo,none) -> OG.Qalloc;
                               if);
                               cd.com(#do 'invoke:var not none'->T;
                                        OG.IS.newDescno -> I #);
                               (sig.id[],OG.IS.newDescno,staticOff
                               ,not OG.IS.doHasCode) 
                                 -> cd.invoke;                               
                            else 
                               (*'---var is none: descNo:'->puttext;
                                * OG.IS.newDescNo -> putint; newline;
                                * OG.IS.newDescNo does not corresp. to var *)
                               (if OG.IS.newDescNo = 0 then
                                   '\n*** newDescNo=0:Y' -> putline;
                                   (* Why does OG.Qalloc work here and not 
                                    * for vStub above?*)
                                   'OBS! Qalloc-Y'->cd.comment;
                                   (if var[] <> none then 'Bingo'->putline;
                                       (var.thisVarNo,none) -> OG.Qalloc
                                    else
                                       (1,none) -> OG.Qalloc
                                   if);
                               if);
                               cd.com
                               (#
                               do 'Ptn:Invoke:' -> T; OG.IS.newDescno -> I
                               #);
                               (sig.id[],OG.IS.newDescno,staticOff,not OG.IS.doHasCode) 
                                 -> cd.invoke
                       if)if)
                   if);
                   (if not useReturnValue then popReturn if);
               if)
            #);
          popReturn:
            (* perhaps this should be the same virtual as in dataItem!?
             * And do consider signature:popReturn
             *)
            (# D: ^Decl
            do (if (sig.getReturn -> D[]) <> none then
                   D.popReturn
                else 
                   cd.rpop
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);   
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.on -> gorigin
        *    E1.pushOff
        *    E2.pushOff
        *    E3.invoke
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# markForCodeGen::
            (# ptn: ^Pattern; OGs: ^ObjectGenerator; E,rec: ^Exp
            do cd.com(#do 'Invocation:markForCodeGen:'->T; dopt -> T;#);
               scanSons
               (#
               do current[] -> E[]; 
                  current.MarkForCodeGen;
                  (if not isLast then E[] -> rec[] 
                   else
                      (if isFirst then E[] -> rec[]
                  if)if)
               #);
               (if (E[] <> none) and (E.args[] <> none) then
                   E.args.scanArgs
                   (#
                   do cd.com(#do 'arg:' -> T; ' '-> T; current.dopt -> T#);
                      current.markForCodeGen
               #)if)
            #);
          Qgen:: 
            (# gdb:: (# do doPT -> lx.puttext;(*
                        scanSons(# ptn: ^Pattern; OI: ^ObjectInvocation
                                do (if (current## = ObjectInvocation##)
                                       and 
                                       ((current[] -> OI[]).ATD## = pattern##) then
                                       OI.ATd[] -> ptn[];
                                       ' descNo: ' -> lx.puttext;
                                       ptn.OG.IS.newDescNo -> lx.putint;
                                       ' top: ' -> lx.puttext;
                                       PTN.OG.Qvariants.top -> lx.putint
                                   if)
                                #)*)
                                         
                     #);
               rec,E: ^Exp; T: ^Text;
               needOrigin: booleanValue
                 (# IT: ^Items
                 do true -> value;
                    'needorigin:'->cd.comment;
                    scanSons
                    (#
                    do current[] -> E[]; 
                       (if not isLast then E[] -> rec[] 
                        else
                           (if isFirst then E[] -> rec[]
                       if)if)
                    #);
                    cd.com(#do 'E:'->T; E.dopt -> T; E.atd.dopt -> T;  #);
                    (if not E.ATd.isPattern then
                        (* '>>>>>dataitem: '->puttext; E.dopt->putline;*)
                        leave needOrigin
                    if);
                    E.ATd.desc -> IT[]; 
                    (if IT.noGlobals and elimOrigin then
                        '***LoadOrign:no:loadOrigin: ' -> cd.comment;;
                        (IT.theObjectGenerator).doPT -> cd.comment;
                        false -> value
                    if)
                 #);
            do (*'Invocation:Qgen:' -> puttext; dopt -> putline;*)
               cd.bcPos -> beginBCP;
               (if needOrigin then
                   (useReturnValue,staticOff,superAdj,CC[]) 
                     -> loadOrigin 
                     -> (rec[],E[])
               if);               
               (superAdj,CC[]) -> E.loadArgs;
               (rec[],E[],useReturnValue,staticOff,CC[]) -> E.invoke;
               cd.bcPos -> endBCP
            #);
          loadOrigin:
            (# usereturnValue: @boolean;
               staticOff,superAdj: @integer;
               rec,E,nE: ^Exp; CC: ^CallChain
            enter(useReturnValue,staticOff,superAdj,CC[])
            do ('Invocation:loadOrigin:',doPT) -> cd.com2;
               (* could rec be thisObject for first E1 in E1.E2.E3 ?*)
               (* Perhaps the other way around
                * e1 -> rec
                * rec -> e2.invoke
                * e2 -> rec
                * rec -> e3.invoke
                *)
               scanSons
               (# gdb:
                    (# T: ^text
                    do 'Invocation:loadOrigin:scan: ' -> T[];
                       current.doPT -> T.puttext;
                       T[] -> cd.comment;
                    #);
                  T: ^ Text
               do current[] -> E[]; 
                  gdb;
                  (if isFirst then 
                      E.pushThis;
                      (superAdj,CC[]) -> E.loadOrigin -> (rec[],E[])
                  if); 
                  cd.com(#do 'Invocation:loadOrigin:rec:'->T;
                           rec.dopt->T; ':E:'->T; E.dopt -> T #);
                  (if not isLast then
                      E[] -> rec[];
                      cd.com(#do 'next:'->T; (next).dopt -> T;
                               (next -> nE[]).ATd[] = none -> B;
                            #);
                      (if (next -> nE[]).ATd.primNo <> assign_prim then
                          cd.com
                          (#do 'next not assign:' -> T; (next).doP -> T;
                             ':E: ' -> T; E.doPT -> T #);
                          (superAdj,CC[]) -> E.loadArgs;
                          (rec[],nE[],true,staticOff,CC[]) -> E.invoke
                      if)
                  if)
               #);
               (* S.simple_bar.c1 := 'x'
                *     rec = c1, E = ':='
                *     No pushOff for c1 = rec, since E = ':='
                *     no loadAsReceiver for c1 = rec
                * S.simple_bar.c1 + 1
                *     rec = c1, E = ':='
                *     pushOff for c1 = rec, but empty action
                *     loadAssReceiver for c1, since simple
                * S.simple_bar.simple_fisk
                *     rec = simple_bar, E = simple_fisk
                *     pushOff for simple_bar = rec
                *     loadAsReceiver for simple_bar, but empty action
                *)
            exit(rec[],E[])
            #);
       #);
     adjustOrigin:
       (# originOff: @integer
       enter originOff
       do ('AdjustOrigin:',originOff->int2text) -> cd.com2;
          (if (originOff > 0) then
              ('origin',originOff) -> cd.rpushg
          if)
       #);
     ObjectInvocation::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# markForCodeGen::
            (#
            do cd.com(#do 'ObjectInvocation:markForCodeGen:'-> T; dopt -> T;
                        ATd.dopt -> T #); 
               ATd.markForCodeGen
            #);
          pushThis:: (#do cd.bcPos -> beginBCP; ATd.pushThis #);
          loadOrigin::
            (# gdb:: (# do doPT -> lx.puttext #);
               org: ^Items;
               T: @text
            do (if ATD.primNo
                // 0 
                // indexed_prim 
                // string_prim
                // stringGet_prim // indexedGet_prim
                // immutable_prim then 
                   'on : ' -> T.puttext; on -> T.putint; T[] -> cd.comment;
                   (if superAdj < 0 then 'superAdj < 0'->cd.comment;
                       (if on > 0 then 
                           - superAdj -> AdjustOrigin;
                           (on - 1,this(ObjectInvocation)[]) 
                             -> (origin[]->org[]).goOrigin
                       if)
                    else
                       superAdj -> AdjustOrigin;
                       (on,this(ObjectInvocation)[]) -> (origin[]->org[]).goOrigin
                   if)
                // this_prim then
                   (* Must check that argument is the name of an enclosing 
                    * object or the name of the superpattern of an
                    * enclosing object.
                    * For %this foo, ON = %this.origin, A.super.ON = foo.origin
                    *)
                   superAdj -> AdjustOrigin;
                   args.scanArgs(* only one argument in %this foo *)
                   (# A: ^ObjectGenerator
                   do current[] -> A[];
                      (A.super.on - 1,this(ObjectInvocation)[])
                        -> (origin[]->org[]).goOrigin; 
                   #)
                // thisCore_prim then 
                   (* perhaps not in loadOrigin, but in execute/ATd.invoke *)
                   ('thisCore',thisCore_prim) -> cd.callPrim
               if);
               (* Actually rec = origin*n, E = this(OG) *)
               this(ObjectInvocation)[] -> E[] -> rec[]
            #);
          invoke::
            (#ptn: ^pattern
            do cd.com
               (#do 'OI:invoke:rec:' -> T; rec.dopt -> T;' E:'->T; E.dopt -> T #);
               (* rec is a dataItem and there will thus be exactly one
                * variant for its OG
                *)
               (if atd## 
                // pattern## then
                   atd[] -> ptn[];
                   cd.com(#do 'OI:invoke:top:'->T; ptn.OG.Qvariants.top -> I;
                            'descNo:'->T; ptn.OG.IS.newdescno -> I #);
                // module## then
                   'OI:invoke:module' -> cd.comment
                // moduleItem## then
                   'OI:invoke:moduleItem' -> cd.comment
               if);

               (rec[],E[],useReturnValue,staticOff,CC[]) -> ATd.invoke
            #);
          loadArgs:: 
            (#
            do (this(Exp)[],superAdj,CC[]) -> ATd.loadArgs
            #);
       #);       
     BracketedExp::
       (* a := b + (c * d)
        *     execute c * d
        * (foo).x
        *    loadOrigin foo
        * (foo(e1,e2)).x
        *    execute foo(e1,e29?
        * (%this P).suspend
        *     loadOrigin?
        * (E1)
        *    (E1).pushThis
        *    (E1).loadOrigin
        *    (E1).invoke
        *    rec -> E.invoke
        * (E1).E2
        *    
        * (R.S).foo
        * (R.bar(e1,e2,)).foo  
        * (ch = 'i') && (S <> none)
        * Do we always execute exp in (exp) and (exp).foo?
        * We should thus not just call load origin!?
        * What about (exp), (R.foo)
        * Look at gen: for (exp) we call loadOrigin and then execute
        *   for (exp).foo we call loadOrigin(exp) and then exe on foo
        *   but exe(exp) is not called
        *   How do we in loadOrigin ensure that exe(exp) is called when needed?
        * 
        * E1.(E2)
        * E1.(E2).E3
        *)
       (# markForCodeGen::
            (#
            do IV.markForCodeGen
            #);
          Qgen:: 
            (# gdb:: (# do doPT -> lx.puttext #);
            do (* we dont come here *)
               (useReturnValue,superAdj,staticOff) -> IV.Qgen 
            #);
          pushThis:: 
            (* Skip, since loadOrigin below includes pushThis *)  
            (# #);
          loadOrigin:: 
            (# gdb:: (# do doPT -> lx.puttext #)
            do (* OBS! useReturnValue, staticOff must be handled! *)
               (false,0,superAdj,CC[])  -> IV.loadOrigin -> (rec[],E[]);
               ('BE:loadOrigin:E:',E.doPT) -> cd.com2;
            #);
          loadArgs:: 
            (* Skip, since loadOrigin includes loadArgs *)              
            (# #);
       #);
     Const::
       (# Qgen:: (# do invoke #);
          invoke:: (# do T.setpos; T.getInt -> cd.pushConst #);
       #);
     CharObj::
       (# Qgen:: (* Never called? *) (# do invoke #);
          invoke:: 
            (# ch: @char
            do (if T.length = 1 then
                   1 -> T.inxget -> cd.pushConst 
                else
                   (if 2 -> T.inxget -> ch
                    // 'n' then 10 -> cd.pushConst
                    else
                       'CharObj:Special symbol: ' -> puttext; ch -> putint;
                       ':' -> put; '"' -> put; ch -> put; '"' -> put;
                       newline;
                       ch -> cd.pushConst
                   if)
               if)
            #);
       #);
     StringObj::
       (# Qgen:: 
            (* Never called ? *)
            (# do 'String:gen:' ->puttext; doPT -> putline; invoke #);
          loadOrigin::
            (* In "hello".foo, "hello" plays the same role as R in R.foo,
             * i.e. we must generate a pushText "hello"
             * For an exp "Hello", 
             * loadOrigin then also generates a pushText "hello"
             * Invoke is called only for the last exp in R1.R2.exp 
             * and 'just store the string!
             *)
            (# 
            do cd.com(#do 'StringObj:loadOrigin:' -> T; dopt->T; #);
               (if not elimOrigin then T[] -> cd.pushText if);                
               this(StringObj)[] -> E[] -> rec[]
            #);
          invoke:: 
            (# 
            do (if elimOrigin then T[] -> cd.pushText if);
               (if not useReturnValue then cd.rPop if)
            #);
       #);
     ObjTmpStack: @
       (# item: 
            (# N: ^text; sig: ^Signature; OT: ^ObjectGenerator; super: ^Invocation;
               CC: ^CallChain; var: ^Variant
            enter(N[],sig[],OT[],super[],CC[],var[])
            exit this(item)[]
            #);
          add:
            (# N: ^text; sig: ^Signature; 
               OT: ^ObjectGenerator; super: ^Invocation; 
               CC: ^CallChain; var: ^Variant
            enter(N[],sig[],OT[],super[],CC[],var[])
            do (if (top+1-> top) > OTL.range then 
                   OTL.range -> OTL.extend;;
                   done.range -> done.extend
               if);
               (if OT.primNo = inner_prim then
                   'OBJT:add inner'->putline;
                   (dumpStack,'inner') -> stop
               if);
               cd.com(#
                     do 'ObjTmpStack:add:'->T; N[] -> T;
                        (if var[] <> none then
                            ':genDone:'->T; var.GenDone -> B;
                        if);
                     #);
               (if var[] = none then
                   '************** objTmpStack:var:is none'->putline;
                   OT.doPT -> putline;
                   (dumpStack,'---') -> stop
               if);
               (N[],sig[],OT[],super[],CC[],var[]) -> item -> OTL[top][];
               (* Does IS.newDescNo correspond to var? Probably no!?*)
               (if newAlloc and (OT.IS.newDescNo = 0) then
                   'ObjTmpStack: Qalloc'->cd.comment;
                   (if var[] <> none then
                       (*' varNo: ' -> puttext; var.thisVarNo -> putint;*)
                       (var.thisVarNo,none) -> OT.Qalloc;
                    else
                       '\n\n*** OBS! objTmpStack:add: var is none' -> putline;
                       OT.dopt -> putline;
                       OT.father.dopt->putline; 
                       newline;
                       (1,none) -> OT.Qalloc
                   if);
                   (if (OT.IS.newDescno = 0) then
                       (*'\n\n*** OBS! no descNo allocated for:'->putline;
                       OT.dopt -> putline;
                       OT.father.dopt->putline;
                       newline;*)
                   iF);
               if);
              (* newline;*)
            #);          
          next:
            (# inx: @integer; B: @boolean
            do 0 -> inx; false -> B;
               (*'next: ' -> puttext; top -> putint; *)
               Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        cd.com(#
                              do 'objTmpStack:next: ' -> T;
                                 OTL[inx].N[] ->T; 
                                 ' : done:'->T; done[inx] -> B;
                                 ' :var.genDone: ' -> T;
                                 (if OTL[inx].var[] <> none then
                                     OTL[inx].var.genDone -> B
                                 if)
                              #);
                        (if OTL[inx].var[] = none then  
                            '\n*** objTmpStack:next:A:var is none ' -> puttext;
                            OTL[inx].N[] -> putline;
                            (*OTL[inx].OT.doPT -> printhead;*)

                            (if not done[inx] then 
                                true -> B;             
                                (* just a tmp test since var may be none 
                                 * - must be fixed *)

                                true -> done[inx];
                                (OTL[inx].N[],OTL[inx].sig[],OTL[inx].super[]
                                ,OTL[inx].CC[],OTL[inx].var[]) 
                                  -> OTL[inx].OT.genClass;
                            if);
                         else
                            (if not OTL[inx].var.genDone then
                                cd.com(#
                                      do 'objTmpStack:next:C: ' -> T;
                                         OTL[inx].N[] -> T;':descNo:' -> T; 
                                         OTL[inx].OT.IS.newdescno -> I; 
                                         ':top:' ->T ;
                                         OTL[inx].OT.Qvariants.top -> I;
                                      #);
                                (if OTL[inx].OT.IS.newdescno = 0 then
                                 else
                                    (OTL[inx].N[],OTL[inx].sig[],OTL[inx].super[]
                                    ,OTL[inx].CC[],OTL[inx].var[]) 
                                      -> OTL[inx].OT.genClass;
                            if)if)
                        if);
                        restart Loop
                    if);
                 #)
            exit B
            #); 
          OTL: [10] ^Item; top: @integer;
          done: [10] @boolean
       #);
    (* labelHandler: @
       (# labCount: @integer;
          label:
            (# labNo: @integer;
               new: (# do  labCount + 1 -> labCount -> labNo #);
            enter labNo
            exit labNo
            #);
          init: (# do 0 -> labCount #);
       #);*)
     markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^TopNode;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if false then
                       '\nModule: ' -> puttext; md.DI.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).newDescNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   true -> md.mark;
                   (if md.origin[] <> none then
                       md.DI.NewOff -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genStubs:
       (# genMain:
            (# 
            do (if newAlloc then
                   ('main',QnewDesc -> mDescNo,false,1,0) -> cd.class;
                else
                   ('main',newDesc,false,1,0) -> cd.class;
               if);
               cd.pushThis;
               (if false then
                   'TopModule: ' -> puttext;
                   markIncludes.topModule.DI.sig.doPT -> putLine;
                   'Main: ' -> puttext; main.doPt -> putline
               if);
               ('BETAworld',(markIncludes.topModule.desc).newDescno,0,true) 
                 -> cd.invoke;
               cd.stop; (* We should generate stop here and not in betaVM *)
               (0,0,0) -> CD.endClass;
               
               (if markIncludes.main## <> Module## then
                   '\n\n***** Only Modules can be executed *****\n\n'
                     -> putline
               if)
            #);
          genThreadStub:
            (# descNo: @integer;
            do (if newAlloc then
                   QnewDesc -> descNo
                else
                   newDesc -> descNo
               if);
               ('ThreadStub',descNo,false,descNo,0) -> cd.class;
               (false,false) -> cd.actions;
               ('ThreadStub','D') -> cd.call;
               cd.stop
            #);
          genEventProcessor:
            (#
            do ('EventProcessor',QnewDesc,false,1,0) -> cd.class;
               cd.stop (* we should generate stop here and not in betaVM *)
            #);                   
       do genMain;
          genEventProcessor;     
          genThreadStub;
       #);
     mDescNo: @integer;
     mainDescNo:: 
       (# 
       do (if newAlloc then
              mDescNo -> value (* ad hoc *);
           else
              newDesc.noOfDescs - 2 -> value (* ad hoc *) 
          if)
       #);
     (* cd: @ObjectCode; moved to abstractSyntaxTree for debugging purposes *)
     runTimeDescs:: (# do descs[] -> rtDescs[] #);
     descs: ^RunTimeDescriptors;
     BC: @File;
  do '**** GENERATOR ****' -> putline;     
     (FN[],'..s') -> mkAuxName -> BC.name;
     BC.openWrite;
     BC[] -> cd.init;
     'QBETA'-> cd.comment;
     
     newAlloc -> cd.descs.newAlloc;
     
     labelHandler.init;
     0-> ObjTmpStack.top;
     main[] -> markIncludes;
     

     (*  Module::Qgen puts OG on ObjTmpStack *)
     (if newAlloc then 
         (* rootModule = BETAworld must have descNo = 1 *)
         (# ptn: ^Pattern
         do (if useMarkForCodeGen then
                rootModule.markForCodeGen
             else
                rootModule.DI.OG.computeVariant;
            if);
            (* Pattern Object is special and not reached during a by-need scan
             * but must be allocated
             *)
            (objectDecl[] -> ptn[]).OG.computeVariant;
         #);
      else
         (1,none) -> rootModule.Qalloc;
     if);
     
     (if not useMarkForCodeGen then
         main.Qgen
     if);
     L:
       (# B: @ boolean
       do false -> B;
          ObjTmpStack.next or B -> B;
          (* Eliminate boolean and fix test for objTmpStack.isEmpty *)
          (if B then
              restart L 
          if)
       #);
     genStubs;
     
     (if stringDecl[] <> none then
         (stringDecl.desc).newDescNo -> CD.descs.textDescNo
      else
         rootModule[] -> SemanticError(#do 'StringDecl not found!' -> msg #)
     if);
     (*  (if StructureRefDesc[] <> none then
      *          StructureRefDesc.newDescNo -> CD.descs.structureRefDescNo
      *       else
      *          rootModule[] 
      *            -> SemanticError(#do 'StructureRefDesc not found!' -> msg #)
      *    if);
      *)
     
     cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)
     
     cd.close;
     BC.close
  #)

