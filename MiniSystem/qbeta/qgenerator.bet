ORIGIN '~beta/basiclib/betaenv'; 
INCLUDE 'qcodegenmarker';
INCLUDE '../VM/objectcode'; 
BODY 'qgeneratorBody';
---lib:attributes---
generator: codeGenMarker
  (# withValueProxy, noOGwarn: @boolean;
     Module::
       (# codeGenDone: @Boolean;
          gen:: 
            (# 
            do (if false  then
                   '**** Module:gen: ' -> puttext;  sig.dopt -> puttext;
                   ' newOff: '  ->  puttext; 
                   this(Module).newOff -> putint;
                   newline;
               if);
               (if not codeGenDone then
                   cd.bcPos -> beginBCP;     
                   (if nameListInDcl then
                       (false,0,(this(Module).sig.names.firstDecl).NewOff)
                         -> OG.gen;
                    else
                       (false,0,this(Module).NewOff) -> OG.gen;
                   if);
                   cd.bcPos -> endBCP;
                   true -> codeGenDone
               if)
            #);  
          genMI:
            (# useRtnVal: @boolean; superAdj,staticOff: @integer;
               mainPathModule: ^Module;
               isLocalMI: @boolean
            enter(useRtnVal,superAdj,staticOff)
            do (if isIncluded  then
                   (if traceModules then
                       '**   genMI:Module included: ' -> puttext; 
                       sig.doPT -> puttext;
                       ' staticOff:' -> puttext; staticOff -> putint;
                       newline
                   if);
                   cd.com(#do 'Module:genMI: '-> TT; sig.dopt->TQ #);
                   (if inMainPath then
                       (if false then
                           '**** inMainPath: ' -> puttext;
                           sig.dopt -> putline;
                       if);
                       this(Module)[] -> mainPathModule[]
                    else
                       (useRtnVal,superAdj,staticOff) -> gen;
                   if)
                else
                   (if traceModules then
                       '**** genMI:Module not included: ' -> puttext;
                       sig.doPT -> putline
               if)if)
            exit mainPathModule[]
            #);          
          getAdr::
            (#
            do true -> loadRec;
               0 -> Address -> A[];
               newOff -> A.off
            #);
          invoke::
            (#
            do cd.com(#do 'Module:invoke:adr<>none:'->TT; 
                        adr[] <> none -> BB  #);
               (if adr[] <> none then 
                   22 -> cd.pushConst;
                   adr.load
                else
                   (if nameListInDcl then
                       (* Assuming only one var in a module decl *)
                       (sig.id[],(sig.names.firstDecl).NewOff) -> cd.rpushg
                    else
                       (sig.id[],NewOff) -> cd.rpushg
               if)if)
            #);
          findNextImp:: (# do bcp -> OG.IS.findNextImp -> impx[] #);
          clear ::< (#do false -> codeGenDone; inner #)
       #);
     ModuleItem::
       (# gen::
            (#
            do (if MD.isIncluded then
                   (if traceModules then
                       '**** ModuleItem:included: ' -> puttext; 
                       sig.doPT -> putline;
                   if);
                   cd.com(#do 'ModuleItem:gen'-> TT; sig.dopt->TT #);
                   (if MD.inMainPath then
                       MD[] -> mainPathModule[]
                    else
                       (useRtnVal,superAdj,staticOff) -> MD.gen;
                   if)
                else
                   (if traceModules then
                       'Module not included: ' -> puttext; 
                       sig.doPT -> putline
               if)if)
            #);
          getAdr::
            (#
            do A[] -> MD.getAdr -> (loadRec,A[])
            #);
          pushThis:: (# do cd.pushThis #);
          invoke:: (# do cd.com(#do 'ModuleItem:invoke:'->TT #); MD.invoke #);
          store:: (# do '\nModuleItem:store'->putline #);
          popReturn:: (# do '\nModuleItem:popReturn'->putline #);
          findNextImp:: (# do bcp -> md.findNextImp -> impx[] #);          
       #);
     newProperty::
       (# gen::  
            (* Code for ModuleItems must be generated in the order they
             * appear in %requires, %visible, %module(s) props
             *)
            (# MIlist: @
                 (* Keep track of all ModuleItems in this(Items) *)
                 (# collect:
                      (* collect all ModuleItems of this(Items) *)
                      (#
                      do (theModule).OG.IS.scanAllDecls
                         (#
                         do (if currentDcl.isModuleItem then
                                (if false then
                                    '**   collect: ' -> puttext;
                                    currentDcl.sig.dopt -> putline;
                                if);
                                currentDcl[] -> add
                         if)#)
                      #);
                    add:
                      (# MI: ^ModuleItem
                      enter MI[]
                      do (if (top + 1 -> top) > L.range then
                             L.range -> L.extend;
                             done.range -> done.extend
                         if);
                         MI[] -> L[top][]
                      #);
                    scan:
                      (# current: ^ModuleItem
                      do (for i: top repeat
                              L[i][] -> current[];
                              inner scan
                         for)
                      #);
                    has: BooleanValue
                      (# M: ^Module
                      enter M[]
                      do L:
                           scan
                           (# i: @integer
                           do i + 1 -> i;
                              (if current.MD[] = M[] then
                                  true -> value;
                                  true -> done[i];
                                  leave L
                           if)#)
                      #);
                    gen:
                      (* Generate code for all ModuleItems in this(Items) *)
                      (# MP: ^Module
                      do scan
                         (# i:@integer
                         do i + 1 -> i;
                            (if not done[i] then
                                (if false then
                                    '**   gen:MI: ' -> puttext; 
                                    current.sig.dopt -> putline;
                                if);
                                (true,superADj,staticOff) 
                                  -> current.MD.genMI
                                  -> MP[];
                                (if MP[]<>none then
                                    MP[]->mainPathModule[]
                         if)if)#)
                      #);
                    L: [8] ^ModuleItem; done: [8] @boolean; top: @integer
                 #);
               isLocalMI: @boolean
            do (if false then
                   '**** newProperty:gen: ' -> puttext; dopt -> puttext;
                   ' in:module: ' -> puttext; 
                   (theModule).sig.dopt -> putline
               if);
               (if true
                // ('%requires' -> propId.T.equalNCS)
                // ('%visible' -> propId.T.equalNCS)
                // ('%module' -> propId.T.equalNCS) 
                // ('%modules' -> propId.T.equalNCS) then
                   (if (TheModule).requires.codeGenDone then
                       leave gen 
                   if);
                   (if traceModules then
                       '**** newProperty:gen:%module ' -> puttext; 
                       dopt -> puttext;
                       ' in:module: ' -> puttext; 
                       (theModule).sig.dopt -> putline
                   if);
                   MIlist.collect; 
                   (theModule).requires.scan
                   (#
                   do (if current[] -> MIlist.has then
                          (if false then
                              '**   moduleProp:arg:in:MI:' -> puttext;
                              current.sig.dopt -> putline;
                          if);
                          (if current.inMainPath then
                              (if false then
                                  '**    module:inMainPath: ' -> puttext;
                                  current.sig.dopt -> putline;
                              if);
                              current[] -> mainPathModule[]
                              (* it seems that not all modules
                               * that should be on mainPath is catched
                               * by mainPathModule[]!?
                               *)
                           else
                              (true,0,0) -> current.gen
                   if)if)#);
                   MIlist.gen;
                   true -> (theModule).requires.codeGenDone;
            if)#)
       #);
     storeDecls:
       (* a primitive value, V,  is on the vstack;
        * thisObj is on the rstack;
        * forEach nameDecl, N, store V in N.off
        *)
       (# sig: ^Signature; OGx: ^ObjectGenerator
       enter(sig[],OGx[])
       do sig.names.scan
          (# i: @integer
          do i + 1 -> i; 
             (if (sig.names.noOfSons > 1) 
                 and (i < sig.names.noOfSons) then 
                 cd.double
             if);
             (if i > 1 then cd.pushThis if);
             (OGx.OGidWdNo,current.NewOff) -> cd.storeg;
          #)
       #);
     storeRefDecls:
       (* a primitive value, V,  is on the vstack;
        * thisObj is on the rstack;
        * forEach nameDecl, N, store V in N.off
        *)
       (# sig: ^Signature; OGx: ^ObjectGenerator
       enter(sig[],OGx[])
       do sig.names.scan
          (# i: @integer
          do i + 1 -> i; 
             (if (sig.names.noOfSons > 1) 
                 and (i < sig.names.noOfSons) then 
                 cd.rdouble
             if);
             (if i > 1 then cd.pushThis if);
             (sig.id[],current.newOff) -> cd.rstoreg
          #)
       #);
     storeRealDecls:
       (* a primitive value, V,  is on the vstack;
        * thisObj is on the rstack;
        * forEach nameDecl, N, store V in N.off
        *)
       (# sig: ^Signature; OGx: ^ObjectGenerator
       enter(sig[],OGx[])
       do sig.names.scan
          (# i: @integer
          do i + 1 -> i; 
             (if (sig.names.noOfSons > 1) 
                 and (i < sig.names.noOfSons) then 
                 cd.double; '!!!! DI:storeRealDecls:need:fdouble'->putline;
             if);
             (if i > 1 then cd.pushThis if);
             (sig.id[],current.NewOff) -> cd.fstoreg
          #)
       #);
     DataItem::
       (* Cases
        *    C1: val integer(12)
        *    C2: val integer
        *    C3: obj Fool
        *    C4: obj Fool -- singular
        *       ...
        *    V1: var integer(12)
        *    V2: var integer
        *    V3: ref Fool
        *    V4: ref Fool -- singular
        *       ...
        *    X1: obj/val/var foo(e1,e2,e3) where foo returns a ref(T) or val(T)
        *)
       (# gen:: 
            (# trace1: 
                 (#
                 do cd.com
                    (#
                    do 'DI:gen:' -> TT; doPT -> TQ;
                       'DI:isConst:' -> TT; isConst -> BB;
                       ':isBasicValue:'->TT; OG.isBasicValue->BB;
                       ':primNo:'->TT; OG.primNo -> II;
                 #)#);
               T: @text; org: ^Items; D: ^DataItem
            do trace1;
               (if true 
                // OG.isBasicPattern and not OG.isConstLiteral then
                   (* No OG.gen for X: var/val integer
                    * Cf the discussion of #foo versus foo  *)
                   cd.com(#do 'DI:add:BP1: ' -> TT; sig.dopt -> TT #);
                // OG.isBasicValue then 
                   (* C1,C2,V1,V2                
                    * X: val integer(7)
                    * X: var 7
                    * X: val a + b
                    *)
                   (if OG.isValueObj then 
                       (* OG is a ValueObject returning a Basic value 
                        * like integer
                        *    mkIntB: ... out V: var integer ...
                        * We shall thus not allocate a value obj, 
                        * but a plain integer
                        * the invocation of mkIntB shall be boxed
                        *)
                       (* If OG is valueObj then
                        * newOff = 0 does not work
                        *)
                       cd.com(#do 'DI:add:BP2: ' -> TT; sig.dopt -> TT #);
                       (true,0,0) -> OG.gen 
                    else (* when is newOff needed here? *)
                       cd.com(#do 'DI:add:BP3: ' -> TT; sig.dopt -> TT #);
                       (if nameListInDcl then
                           (true,0,(this(DataItem).sig.names.firstDecl).NewOff) 
                             -> OG.gen;
                        else
                           (true,0,this(DataItem).NewOff) -> OG.gen;
                   if)if);
                   cd.com(#
                         do 'dataItem:store:basicValue:' -> TT;
                            'off:' -> TT; off -> II;
                            ' NewOff:' -> TT; NewOff -> II
                         #);
                   cd.pushThis;
                   (if OG.isFloat then
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeRealDecls
                        else
                           (sig.id[],this(DataItem).NewOff) -> cd.fstoreg
                       if)
                    else
                       origin[] -> org[];
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeDecls
                        else
                           (sig.id[],this(DataItem).NewOff) -> cd.storeg
                   if)if)
                // (OG.primNo = String_prim) and isConst then
                   (* Like S: obj "hello"
                    * Old comment:
                    * Could be  V: obj elm where elm:< Object 
                    * but is this true ?
                    *)
                   cd.com(#do 'DI:add:BP3: ' -> TT; sig.dopt -> TT #);
                   (true,0,this(DataItem).NewOff) -> OG.gen;
                   cd.pushThis;
                   (if true then
                       origin[] -> org[];
                       (if nameListInDcl then
                           (org.encOG.OGidWdNo,(sig.names.firstDecl).NewOff) 
                             -> cd.rstoreg
                        else
                           (org.encOG.OGidWdNo,this(DataItem).NewOff) -> cd.rstoreg
                       if)
                    else
                       (sig.id[],this(DataItem).NewOff) -> cd.rstoreg
                   if);
                // isConst or not OG.IS.isEmpty or isValue then
                   cd.com(#do 'DI:add:BP4: ' -> TT; sig.dopt -> TT #);
                   (* C3,C4,V4 *)
                   (* All objects/patterns being embedded must be handled by
                    * Alloc and gen since we must know the size *)
                   (* X: = Foo or 
                    * Singular T: = P{...} 
                    * C3,C4,V4 *)
                   cd.bcPos -> beginBCP;
                   (if isInArg then (* also outArg? *)
                       cd.com(#do 'inArg:' -> TT; doPT -> TT #);
                    else
                       (if stringAsVal and (OG.primNo = String_prim) then
                           cd.com(#do 'DI:String:'->TT; dopt -> TQ;
                                    'off:'->TT; newOff -> II;
                                 #);
                        else
                           (* X: obj T;  -- return this(T)
                            *    invoke must store ref in X.off
                            *    useRtnVal = false ==> rpop
                            * X: obj T; -- T has out parameter
                            *    same as next case
                            * X: obj T.init(e) -- return this(init)
                            *    ref(init) on top of rStack
                            *    rpush ref(init).outDecl
                            *    pushThis
                            *    rstore ref(init).outDecl in X.off
                            * What about
                            *    T: {out R: ref T; ...; R := this(T)}
                            *    should be handled like (1) above
                            *)
                           (if (OG.getReturnDecl -> D[]) <> none then
                               (if false then
                                   '**** DI: ' -> puttext; dopt -> puthead;
                                   '**   out: ' -> puttext; D.dopt -> putline;
                               if);
                               (true,0,0) -> OG.gen;
                               (OG.getQual,'RTN') -> pushOut;
                               cd.pushThis;
                               (if nameListInDcl then
                                   ('RTN',(sig.names.firstDecl).NewOff) 
                                     -> cd.rstoreg
                                else
                                   ('RTN',this(DataItem).NewOff) -> cd.rstoreg
                               if)
                            else
                               (if false then
                                   '**** DI: ' -> puttext; 
                                   this(DataItem).NewOff -> putint; ' ' -> put;
                                   (sig.names.firstDecl).NewOff->dumpI;
                                   sig.dopt -> dumpTN
                               if);
                               (if nameListInDcl then
                                   (false,0,(sig.names.firstDecl).NewOff) 
                                     -> OG.gen;
                                else
                                   (false,0,this(DataItem).NewOff) -> OG.gen;
                   if)if)if)if);
                   cd.bcPos -> endBCP;
                   (* else V3 - just a qualifcation; 
                    * see also the discussion of #foo versus foo *)
                   (* Could be S: ?elm where elm:< Object -- no code gen *)
               if)
            #);
          pushThis:: (# do cd.pushThis #);
          loadArgs::
            (# gdb::
                 (#
                 do '>E:'->TT; E.doPT -> TQ; E.args.dopt -> TT 
                 #);
            do L:
                 (if OG.IS.isEmpty then
                     (E[],superAdj,staticOff) 
                       -> (OG.super.ATd.asDecl).loadargs;
                  else
                     (* primitive check for args being non empty! *)
                     E.args.scanArgs
                     (#do '\n!!!! DataItem:loadArgs:IS not empty! '->putline#)
                 if)
            #);
          getAdr::
            (# gdb::
                 (#
                 do '>newOff:'->TT; newOff -> II; 
                    ',isValue:'->TT; isValue-> BB;
                    OG.isBasicValue -> BB; isValue -> BB;
                    OG.isValueObj -> BB; 
                    ':value_prim:'->TT ;OG.primNo = value_prim->BB;
                    ':A:'->TT; A.print -> TT; 
                 #);
               E: ^Exp; originIsValue: @boolean; ptn: ^Pattern; 
               UN,UNx: ^NewProperty;
               OGx: ^ObjectGenerator; 
               OGsx: ^OGSequence
            do (* OG.primNo = value_prim for handling _v: var Value 
                * in integer, char and boolean *)
               (if (OG.isBasicValue or OG.isValueObj) 
                   or (OG.primNo = value_prim) then
                   (if not A.isValue then
                       true ->  loadRec;
                       A.E[] -> E[]; A.originIsValue -> originIsValue;
                       0 -> Address -> A[]; 
                       E[] -> A.E[]; originIsValue -> A.originIsValue;
                       newOff -> A.off;
                       OG.isBasicValue 
                       or OG.isValueObj or (OG.primNo = value_prim)
                         -> A.isValue; 
                    else
                       (if nameListInDcl then
                           (* there emay be more than one name in names! *)
                           (if A.off > 0 then
                               (sig.names.firstDecl).newOff - 1 + A.off 
                                 -> A.off;
                            else
                               (sig.names.firstDecl).newOff -> A.off
                           if)
                        else
                           (if A.off > 0 then
                               newOff - 1 + A.off -> A.off;
                            else
                               newOff -> A.off
                       if)if);
                       OG.isBasicValue or OG.isValueObj 
                       or (OG.primNo = value_prim)
                         -> A.isValue;
                   if);
                   (if A.isValue then   
                       (OG.super.ATd.asDecl).OG.IS.newDescNo -> A.valDescNo 
                   if);
                   cd.com(#do 'DI:OG:'->TT; OG.dopt -> TT #);
                   (if (OG.super.ATd[] <> none)
                       and (OG.super.ATd.asDecl->ptn[]).OG.IS.isEmpty then
                       (* MUST be FIXED: introduce getNewBasicProp*)
                       (ptn.OG.super.ATd.asDecl).OG.IS.newBasicProp.UNIT[] 
                         -> UN[];
                    else
                       ptn.OG.IS.newBasicProp.UNIT[] -> UN[];
                   if);
                   cd.com(# UN: ^NewProperty; ptn: ^Pattern
                         do 'before:floatTest: ' -> TT;
                            dopt -> TQ;
                            OG.label -> TT;
                            (if ptn[] <> none then
                                ptn.sig.dopt -> TT; 
                                (if ptn.OG.IS.isEmpty then
                                    ' IS.empty:'->TT
                                 else
                                    ' NOT IS.empty:'->TT
                                if);
                                (if UN[] <> none then UN.dopt -> TT; if)
                         if)#);
                   cd.com(#do A.print->TT #);
                   UN[] <> none -> A.isUnitVal;
                   cd.com(#do 'After:U*U:'->TT; A.print->TT #);
                   (if (OG.primNo = float_prim) or OG.isFloat then
                       cd.com(#
                             do 'getAdr:isfloat:A: ' -> TT; dopt -> TT;
                                ' A.isValue:'->TT; A.isValue -> BB
                             #);
                       true -> A.isFloat
                   if);
                else                   
                   true -> loadRec;
                   0 -> Address -> A[];
                    (if nameListInDcl then
                        (* there may be more than one name in names! *)
                        (sig.names.firstDecl).newOff -> A.off
                     else
                        newOff -> A.off
               if)if)
            #);
          invoke::
            (* called when not receiver - i.e. value to be pushed *)
            (# gdb::(#do '>newOff:'-> TT; newOff -> II #);
               orgIsVal: @integer;
               org: ^Items;
               isResumeX: BooleanValue
                 (#
                 do (if E[] = none then 
                        (*'!!!! isResume: ' -> puttext; dopt -> putline;*)
                     else
                        L: E.args.scanArgs(#do true -> value; leave L #)
                    if)
                 #);
               vn,rn: @integer
            do (if isResume then
                   cd.com
                   (#do 'dataItem:invoke:hasArgs:DI: ' -> TT; dopt->TQ; nl;
                      ' rec: '->TT;
                      (if rec[] <> none then rec.dopt ->TQ;
                          ' arg: ' -> TT; rec.args.dopt -> TQ if);
                      ' E: ' -> TT; E.dopt -> TQ;
                      ' lab: ' -> TT; E.label -> TQ;
                   #);
                   OG.IS.scanItemArgs -> (vn,rn);
                   (* Part of the adr of this(DI) is on the rstack  - thisObj
                    * and possible arguments are alos on thje stack
                    * we need to get the partial adr of this(DI) on the top
                    * to be able to execute adr.loadAdr
                    *)
                   (if rn > 0 then rn -> cd.rswap; if);
                   adr.loadAdr;
                   ('ResumeDI','D') -> cd.call;
                   cd.rpop;
                   leave invoke
               if);
               (if OG.isBasicValue or OG.isValueObj then 
                   (if (E[] <> none) then
                       (if ((E.ATd.asDecl).primNo <> cmpAndSwap_prim) then
                           (* May happen for V := 117 where := is assignment
                            * - no offset shall be pushed for V 
                            * since V is assigned afterwards
                            * For R ++ 117 offset for R should be pushed 
                            * since it is origin
                            *) 
                           (if true
                            // OG.isBasicValue 
                            // OG.primNo = value_prim then 
                               (* OG.primNo = value_prim for handling 
                                * _v: var Value 
                                * in integer, char and boolean *)
                               (* problem here! *)
                               adr.load
                            // OG.isValueObj then 
                               cd.com(#do 'isValueObj:isAdr:' -> TT;
                                        adr.isAdr -> BB; 
                                        ' Size:'->TT; objSize -> II;
                                        ' rec'->TT; rec.dopt->TQ;',E:'->TT;
                                        E.dopt -> TQ; E.label -> TQ;
                                        'E.isCompositeValueObj:' -> TT; 
                                        E.isCompositeValueObj -> BB 
                                     #);
                               true -> adr.isAdr;
                               E.isCompositeValueObj -> adr.isCompositeValueObj;
                               cd.com(#do 'createValueProxy:'->TT; 
                                         OG.OGid->TQ; dopt -> TQ;
                                         'origin:'->TT; OG.origin.dopt->TQ
                                      #);
                               adr.load; 
                           if)
                        else
                           cd.com(#do 'cmpAndSwap:Off:'->TT; off->II; 
                                    adr.print -> TT #);
                           adr.loadAdr;
                       if)
                    else 
                       cd.com(#do '>:E=none' -> TT#);
                       (if adr[] <> none then 
                           adr.load
                        else
                           (if (OG.primNo = float_Prim) 
                               or OG.isUnitValueObj then
                               (if nameListInDcl then
                                   (sig.id[],(sig.names.firstDecl).newOff) 
                                     -> cd.fpushg
                                else
                                   (sig.id[],NewOff) -> cd.fpushg
                               if)
                            else
                               cd.com(#do 'push:A:' -> TT #);
                               origin[] -> org[];
                               788->cd.pushconst;                               
                               (org.encOG.OGidwDno,NewOff) -> cd.pushg
                   if)if)if)
                else
                   cd.com(#do '>Object:unique:'->TT; OG.IS.isUnique->BB#);
                   (if adr[] <> none then 
                       adr.load;
                       E.adjustEmbodied
                    else
                       cd.com(# do '>adr=none'->TT #);
                       (if true then
                           (if org[] = none then
                               (if nameListInDcl then
                                   ('orgIsNone',(sig.names.firstDecl).NewOff)
                                     -> cd.rpushg
                                else
                                   ('orgIsNone',NewOff) -> cd.rpushg
                               if)
                            else
                               (if nameListInDcl then
                                   (org.encOG.OGidWdNo
                                   ,(sig.names.firstDecl).NewOff) -> cd.rpushg
                                else
                                   (org.encOG.OGidWdNo,NewOff) -> cd.rpushg
                           if)if)
                        else
                           (sig.id[],NewOff) -> cd.rpushg
               if)if)if)
            #);
          store::
            (# gdb::(#do '>newOff:'->TT; newOff -> II;
                       ',isVirtualObject:' -> TT; isVirtualObject -> BB;
                       ' isValueObj:'->TT; OG.isValueObj -> BB
                    #);
               OGx: ^ObjectGenerator; 
            do (if true
                // OG.isBasicValue // OG.primNo = value_prim then 
                // OG.isValueObj then 
               if);
               (if true
                // OG.isBasicValue // OG.primNo = value_prim 
                   (*// OG.isUnitValueObj*) then 
                   (* OG.primNo = value_prim for handling _v: ?Value 
                    * in integer, char and boolean *)
                   cd.pushThis;
                   (if (OG.primno = float_prim) or OG.isUnitValueObj then
                       (if nameListInDcl then
                           (sig[],OG[]) -> storeRealDecls
                        else
                           (sig.id[],NewOff) -> cd.fstoreg
                       if)
                    else
                       (if true then
                           (if nameListInDcl then
                               (sig[],OG[]) -> storeDecls
                            else
                               (OG.OGidWdNo,NewOff) -> cd.storeg
                           if)
                        else
                           (sig.id[],NewOff) -> cd.storeg
                   if)if)
                // OG.isValueObj then
                   (* is the order of src and dest objs on the stack correct? *)
                   (# L1, L2: @labelHandler.label; out: ^text; 
                      E: ^Invocation; OGs: ^OGsequence;
                      qual: ^objectGenerator
                   do L1.new; L2. new;
                      (0,L1) -> cd.jmpFalse;
                      cd.pushThis;
                      (if nameListInDcl then
                          (sig.names.firstDecl).off -> cd.pushConst;
                       else
                          newOff -> cd.pushConst;
                      if);
                      (if false then
                          (* attemtp to handle Cvalue with 
                           * in V: var ThisValue
                           * but does not work, since we dont know the
                           * size of thisValue
                           *)
                          '**** bingo:'->puttext; og.objsize->putint; 
                          ' ' -> PUT; OG.dopt -> putheadN;
                          '**   DI:'->puttext; dopt ->putheadN;
                          (if OG.IS.isEmpty then
                              '**** OG.IS.isEmpty: ' -> puttext;
                              OG.super.dopt -> putline;
                          if);
                          '**   mainIS:'->puttext; mainIS.dopt -> putheadN;
                      if);
                      sig.dopt -> parseInv->(out[],E[]);
                      mainIS[] -> E.father[];
                      mainIS[] -> E.setUpOrigin;
                      (none,mainIS[],mainIs[],true) -> E.check;
                      (mainIS.encOG,true
                      ,(mainIS.encOG,false,none) -> OGsequence)
                        -> E.getVqual 
                        -> (OGs[],qual[]);
                      (OG.objSize,0) -> cd.vassign;
                      L2 -> cd.jmp;
                      L1 -> cd.defLab;   
                      (if true then
                          (if nameListInDcl then
                              (sig.id[],(OG.superPtn).new_DescNo,
                              (sig.names.firstDecl).newOff - 1)
                                -> cd.invokeVal;
                           else
                              (sig.id[],(OG.superPtn).new_DescNo,newOff - 1)
                                -> cd.invokeVal;
                          if)
                       else
                          (sig.id[],(OG.superPtn).OG.IS.newDescNo,newOff - 1)
                            -> cd.invokeVal;
                      if);
                      L2 -> cd.defLab
                   #)
                else
                   cd.pushThis;
                   (if not noSwap then cd.rswap if); 
                   (* Could be S: ?elm where elm:< Object *) 
                   (if nameListInDcl then
                       (sig[],OG[]) -> storeRefDecls
                    else
                       (sig.id[],NewOff) -> cd.rstoreg
               if)if)
            #);
          popReturn::
            (#
            do (if OG.isBasicValue then 
                   cd.vpop
                else
                   (* could be S: ref elm where elm:< object*)
                   cd.rpop
               if)
            #)          
       #);
     NameDecl::
       (# loadArgs::
            (#
            do '**** NameDecl:loadArgs:'->puttext; dopt -> putline;
               (E[],superAdj,staticOff) -> ATd.loadArgs -> isResume
            #);
          getAdr::
            (#
            do (*'**** NameDecl:getAdr:'->puttext; dopt -> putline;*)
               A[] -> ATd.getAdr -> (loadRec,A[]);
               (if A.off = 0 then off -> A.off if)
            #);
          invoke::
            (#
            do '**** NameDecl:invoke:'->puttext; dopt -> putline;
               (rec[],E[],useRtnVal,staticOff,adr[],isResume)
               -> ATd.invoke
            #)
       #);
     Signature:: 
       (# gen:: (##)
       #);
     Arguments:: (##);
     AssignmentStatement::
       (# gen::
            (# isArgOfAssignI2IwithUniValArg: BooleanValue
                 (* for the case: a3 := 3 * a2 where a3 and a2 are UnitValueObj
                  * and * is int2int, typeOf('* a2') is unit and not int;
                  * at this place: this(pattern) = AssignmentPattern;
                  * rec: 'a3', E: ':= 3 * a2', arg = '3 * a2';
                  * we check if arg has the form '3 * a2' and decode into
                  * recx = '3' and argx = '* a2'
                  *)
                 (# arg: ^ObjectGenerator; recx,argx: ^Exp;  i: @integer
                 enter arg[]
                 do (if arg.IS.isEmpty then
                        arg.super.scanSons
                        (# 
                        do i + 1 -> i;
                           (if i 
                            // 1 then 
                               current[] -> recx[]
                            // 2 then
                               current[] -> argx[]
                        if)#);
                        (if i = 2 then
                            (recx[],argx[]) -> checkInt2IntWithUnitArg -> value;
                    if)if)
                 #);
               rec,dstE: ^Exp; adr: ^Address;
               dstDI,srcDI: ^DataItem; ptn: ^Pattern
            do (if false then
                   'AssignmentStatement:gen: '->puttext; dopt ->putline
               if);
               cd.bcPos -> beginBCP;
               
               superAdj -> left.computeAdr -> (rec[],dstE[],adr[]);
               (true(*useRtnVal*),superAdj,staticOff) -> right.gen;

               (* checker/semchecker has ensure that dstE is a DataItem *)
               dstE.ATd[] -> dstDI[];
               
               cd.com
               (#do 'rec:'->TT; (if rec[] <> none then rec.dopt -> TQ if);
                  'dstE:'->TT; dstE.dopt->TQ;
                  'dstE.ATd:'->TT; dstE.ATd.dopt -> TQ;
                  'useRtn:'->TT; useRtnVal->BB;
                  adr.print->TT;                  
               #);
               cd.com
               (#
               do 'dstDI.isBasicVal:'->TT; dstDI.isBasicValue->BB;
                  'dstDI.isValObj:'->TT; dstDI.OG.isValueObj-> BB;
                  'dstDI.OG.isUnitValObj:'->TT; dstDI.OG.isUnitValueObj->BB; 
                  nl;
                  'right.super.isUnitValObj:'->TT; 
                  (right.super.ATd.asDecl).OG.isUnitValueObj-> BB;
                  'F:'->TT; (right.super.ATd.asDecl).isFloat ->BB;
                  'I:'->TT; (right.super.ATd.asDecl).isInteger->BB;
               #);
               (* see ageneratorBody::pattern:assign and handleNonVirtualArg *)
               (if dstDI.OG.primNo 
                   (* an indexed is a ref and else-part below is selected;
                    * so perhaps move to else-part ?
                    *)
                // indexed_prim then
                   (if right.bracketedListLength > 0 then
                       right.bracketedListLength -> cd.pushConst;
                       (dstDI.OG.super.ATd.asDecl).OG.IS.newDescNo 
                         -> cd.mkVindexed
                   if)
                // rindexed_prim then
                   (if right.bracketedListLength > 0 then
                       right.bracketedListLength -> cd.pushConst;
                       (dstDI.OG.super.ATd.asDecl).OG.IS.newDescNo 
                         -> cd.mkRindexed
               if)if);
               (if true
                // dstDI.isBasicValue 
                // (dstDI.OG.primNo = value_prim) 
                // dstDI.OG.isUnitValueObj
                   (* L1,L2: var Length.Meter; 
                    * L1 := L2; dstDI and right.super are UnitValueObj
                    * L1 := 3.1; dstDI isUnitValueObj; right is float
                    * L1 := F2M(12.0)
                    * dstDI isUniValueObj, but right.super is 
                    * neither uniValueObj, float or integer
                    *)
                   and 
                   ((right.super.ATd.asDecl).OG.isUnitValueObj 
                     or (right.super.ATd.asDecl).isFloat 
                     or (right.super.ATd.asDecl).isInteger)

                   then
                   true -> adr.isValue;
                   (if not (right[] -> isArgOfAssignI2IwithUniValArg) then
                       dstDI[] -> right.checkNumberConvert
                       (# I2F:: (#do cd.I2f #);
                          F2I:: (# do cd.F2I #);
                       #)
                   if);
                // dstDI.OG.isValueObj 
                   and not (dstDI.OG.primNo = String_prim) then 
                   true -> adr.isValue -> adr.destIsVal -> adr.isAdr;
                   dstDI.objSize -> adr.size;                            
                   (if true
                    // (right.super.ATd.asDecl).isPattern then 
                       cd.com(#do 'right:isPattern:'-> TT #);
                       (right.super.ATd.asDecl 
                         -> ptn[]).getReturnDecl 
                         -> srcDI[];
                       (if not ((srcDI[] <> none) and srcDI.OG.isValueObj) then
                           (if ptn.OG.primNo <> indexedGet_prim then 
                               cd.fcom(#do 'KUK:A:'->TT#);
                               ptn.OG.IS.newDescno -> adr.descNo;
                       if)if);
                       (if (srcDI[] <> none) and srcDI.OG.isNonBasicValueObj
                           then                       
                           cd.com(#do 'KUK:B:'->TT#);
                           (if stringAsVal and 
                               (srcDI.OG.primNo = string_prim) then
                               (srcDI.sig.dopt,srcDI.newOff)
                                 -> cd.rpushg
                            else
                               srcDI.objSize -> cd.pushValue
                           if)
                        else
                           cd.fcom(#do 'else:'->TT; dopt->TT #)
                       if)
                    // (right.super.ATd.asDecl).isDataItem then
                       cd.fcom(#do 'right:isDI:'-> TT #);
                       right.inValueObj -> adr.srcIsVal;
                       right.objSize-> cd.pushValue
                   if);
                else (* reference *)
                   true -> adr.isAdr;
               if);
               adr.store;
               cd.bcPos -> endBCP
            #)
       #);
     ObjectCall::
       (# classDef::
            (#
            do '**** ObjectCall:classDef: ' -> puttext; OGid-> puttext;
               ' ' -> put;
               IS.newDescno -> putint; newline;
            #);
          gen::
            (#
            do cd.com(#do dopt -> TQ; ' OC:isCompositeValueObj: ' -> TT;
                        isCompositeValueObj -> BB #);
               (if ((super.last).ATd[] <> none) 
                   and not ((super.last).ATd.asDecl).isPattern then
                   (* does no completely undersatand what goes on here
                    * For INV = L2, we have to assign 
                    * For inv := L1 * L2, we cannot!
                    *)
                   isCompositeValueObj -> (super.last).isCompositeValueObj;
               if);
               (useRtnVal,superAdj,staticOff) -> super.gen
            #);
       #);

     transInArgs:
       (# theOG: ^ObjectGenerator; staticOff: @integer; T: ^text
       enter(theOG[],staticOff)
       do theOG.OGidWdNo -> T[]; 
          theOG.IS.scanItemArgsReverse
          (# DI: ^DataItem
          do cd.lcom(#do 'store:arg: ' -> TT; currentarg.dopt -> TT #);
             (if (currentArg[]->DI[]).isBasicValue then
                 (T[],DI.newOff) -> cd.storeX
              else
                 (T[],DI.newOff,false) -> cd.rstoreX
          if)#);
       #);
     goOriginAdr:
       (# super: ^Invocation; ptn: ^Pattern; rec,E,pRec: ^Exp; 
          A,recA: ^Address;
          loadRec,orgIsVal: @Boolean; BE: ^ BracketedExp; 
       enter super[]
       do cd.lcom(#do 'goOriginAdr: ' -> TT; super.dopt -> TQ; #);
          (if super.isImplSuper then
              cd.lcom(#do 'goOriginAdr:isImplSuper:' -> TT #);
              (if super.isSingularImplSuper then
                  (* super = V:< A{...};skip - we have origin on the stack *)
               else
                  (* super = V:< A
                   * Binding has the form V::< { ... }
                   * Should be handled as if binding was: V::< A{ ... }
                   * as in the else-part below
                   *)
                  super.ATd.asDecl -> ptn[];
                  (* TODO *)
                  cd.lcom(#do '!!!TODO:goOriginAdr:super:not:implSingular:'->TT;
                            'super:' -> TT; super.dopt -> TQ; 
                            'super.father:' -> TT; super.father.dopt -> TQ; 
                            'ptn:' -> TT; ptn.dopt -> TQ; print  #);
              if)
           else
              cd.lcom(#do 'goOriginAdr:not:isImplSuper:' -> TT #);
              Address -> A[];
              super.scanSons
              (#
              do rec[] -> pRec[]; E[] -> rec[];
                 current[] -> E[];
                 (if isFirst then
                     cd.lcom(#do 'goOriginAdr:isFirst: '->TT; E.dopt -> TT #);
                     (if ('BracketedExp' -> (E.label).equalNCS) then
                         '\n!!! bracketedExp: ' -> puttext; 
                         E.dopt  -> putline;
                         (E[] -> BE[]).IV.scansons
                         (#
                         do current[]  ->  E[];
                            (if isFirst then
                                0 -> E.loadOrigin->(rec[],E[],orgIsval);
                                A[] -> E.getAdr -> (loadRec,A[]);
                             else
                                A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                                (if loadRec then
                                    cd.lcom(#do 'goOriginAdr:D:rec:' ->TT;
                                              rec.dopt -> TT #);
                                    (0,0) -> rec.loadArgs;
                                    (pRec[],E[],true,0,recA[],false)
                                      -> rec.invoke;
                         if)if)#)
                      else
                         cd.lcom(#do 'before:E.loadOrigin:'->TT; E.dopt->TQ#);
                         0 -> E.loadOrigin -> (rec[],E[],orgIsVal);
                         A[] -> E.getAdr -> (loadRec,A[]);
                     if);
                     (* shall we check for originIsValue? See computeAdr*)
                  else
                     cd.lcom(#do 'goOriginAdr:not:isFirst:'->TT; E.dopt->TT #);
                     A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                     (if loadRec then
                         cd.lcom(#do 'goOriginAdr:D:rec:' ->TT; rec.dopt->TT #);
                         (0,0) -> rec.loadArgs;
                         (pRec[],E[],true,0,recA[],false) -> rec.invoke;
                         cd.lcom(#do 'goOriginAdr:E: ' -> TT; #);
          if)if)#)if)   
       exit E[]
       #);
     storeOrigins:
       (* Store origins defined for the main OG and super patterns:
        * P1: {...}, P2: P1{...}, P3: P2{...}, OG = P3{...}
        * mainOG = OG = P3{...}
        * thisOG = one of P3, P2, P1
        * We may skip store of origin for OGs with same originOff
        *)
       (# mainOG,thisOG,OGx: ^ObjectGenerator; ISx: ^items; 
          rec,E: ^Exp; A: ^Address;
          trace: (# exit false #);
          fArgs: [10] ^DataItem; top: @integer; DI: ^DataItem;
          fromVDTalloc,orgIsVal: @boolean
       enter(mainOG[],thisOG[],fromVDTalloc)
       do (if thisOG.IS.newOriginOff > 0 then
              (if thisOG.super.ATd[] <> none then  -1 -> cd.rdouble if);
              (if fromVDTalloc and 
                  (thisOG.origin[] -> thisOG.IS.originisValue -> orgIsVal) then
                  cd.lcom(#do 'OBS! we need the correct off'-> TT;
                            'of value object in holder object'->TT; #);
                  4 -> cd.pushConst;
                  4 -> cd.pushConst;
              if);
              (* rstack = [..., obj,callee], store obj in callee.origin *)
              (* mainOG.OGidWdNO is the type callee
               * if vStub, then the type may be the vStub type 
               * We should check for this and bitcast
               *)
              (if emitLLVM then
                  mainOG.OGidWdNo -> cd.fixTypeOfBinding
              if);
              (mainOG.OGidWdNo,thisOG.IS.newOriginOff
              ,thisOG.origin[] -> thisOG.IS.originisValue
              ) -> cd.rstoreX;
              (* rstack = [..., callee]; ... *)
           else
              cd.lcom(#do 'no:origin:newOriginOff=0' -> TT #)
          if);
          (if thisOG.super.ATd[] <> none then
              thisOG.IS[] -> ISx[];
              cd.stack.put;
              cd.rswap;
              thisOG.super[] -> goOriginAdr -> E[];
              cd.stack.put;
              (if E[] <> none then 
                  (if cd.thisClassDescNo = thisOG.IS.newDescNo then
                      (thisOG.IS.newOriginOff,0) -> E.loadArgs;
                   else
                      (0,0) -> E.loadArgs;
                  if);
                  (if not fromVDTalloc 
                      and (E.args[] <> none) and (E.args.noOfSons > 0) then
                      (E.Atd.asDecl).OG.IS.scanNonBoundItemArgs
                      (#
                      do (if currentArg.isDataItem then
                             cd.lcom(#do currentArg.dopt -> TT #);
                             currentArg[] -> fArgs[top + 1 -> top][]
                         if)
                      #);
                      (for i: top repeat
                           fArgs[top - i + 1][] -> DI[];
                           cd.rswap;
                           cd.rdouble;
                           (if DI.isBasicValue then
                               (if nameListInDcl then
                                   (DI.sig[],mainOG[]) -> storeDecls
                                else
                                   (mainOG.OGidWdNo,DI.newOff) -> cd.storeg
                               if)
                            else
                               (mainOG.OGidWdNo,DI.newOff) -> cd.rstoreg
                           if);
                           cd.rswap
                  for)if)
               else
                 (* '**** E is none:main:\n' -> Puttext; 
                  main.dopt -> puthead;
                  ' this: ' -> puttext; thisOg.doPT -> putline*)
              if);(mainOG[],thisOG.super.ATd.OG[],fromVDTalloc) -> storeOrigins;
           else
              (if trace then newline if)
          if);
       #);
     storeArgs:
       (# T: ^text; theOG: ^ objectGenerator
       enter (T[],theOG[])
       do (if theOG.super.ATd[] <> none then
              (T[],(theOG.super.ATd.asDecl).OG[]) -> storeArgs
          if);
          theOG.IS.scanItemArgsReverse
          (# DI: ^DataItem
          do (if (currentArg[]->DI[]).isBasicValue then
                 (T[],DI.newOff) -> cd.storeX
              else
                 (T[],DI.newOff,false) -> cd.rstoreX
          if)#)              
       #);
     callInvoke:
       (# theOG: ^ObjectGenerator; staticOff: @integer; fromStub: @boolean;
          T: ^text
       enter(theOG[],staticOff,fromStub)
       do (theOG.OGid,theOG.IS.newDescNo,theOG.IS.objSize,staticOff,theOG.isObj)
            -> cd.invoke
          (# topSuperId::
               (# superDesc: ^Items
               do (theOG.IS.topSuper->superDesc[]).encOG.OGidWdNo -> superId[];
                  superDesc.newDescNo -> superDescNo
               #);
             fArgs: [10] ^DataItem;  top: @integer; DI: ^DataItem
          do (* vStack = [..., possible V-args
              * rStack = [..., possible origin, possible R-args, callee
              *)
             theOG.OGidWdNo -> T[]; 
             (*'$' -> T.put; IS.newDescNo -> T.putint;*)
             (if false then
                 (T[],theOG[]) -> storeArgs
              else
                 cd.lcom(#do 'store:args'->TT #);
                 theOG.IS.scanNonBoundItemArgs
                 (# 
                 do currentArg[] -> fArgs[top + 1 -> top][];
                    cd.lcom(#do 'arg:' -> TT; currentArg.dopt -> TT #)
                 #);
                 (for i:top repeat
                      fArgs[top - i + 1][] -> DI[];   
                      (if DI.isBasicValue then
                          (T[],DI.newOff) -> cd.storeX
                       else
                          (T[],DI.newOff,false) -> cd.rstoreX
             if)for)if);
             cd.lcom(#do 'after:store:args:top:'-> TT; top->II  #);
             (* vStack = [...]
              * rStack = [..., possible origin, callee]
              *)
             (if not newFeature then
                 (theOG[],theOG[],false) -> storeOrigins;
             if);
          #);
          (if not fromStub then (theOG[],T[]) -> pushOut if)
       #);
     ObjectGenerator::
       (# classDef::
            (# org:^Items; orgId: ^text; orgDescNo: @integer
            do (if marked then
                   (if (not IS.isEmpty or hasVirtualArgs)
                       and (IS.newDescNo > 0) then
                       (if (origin[] -> org[]) <> none then
                           org.encOG.OGid -> orgID[];
                           org.newDescNo -> orgDescNo;
                           (if IS.newOriginOff = 0 then
                               none -> orgID[];
                               0 -> orgDescNo
                           if)
                        else
                           'Object' -> orgId[];
                           objectDecl.OG.OGid ->orgId[];
                           objectDecl.OG.IS.newDescNo -> orgDescNo;
                       if);                           
                       (OGid,IS.newDescNo,isValueObj,orgID[],orgDescNo)
                         -> cd.classDef
                       (#
                       do mkLLVMstruc
                          (# addRX:: 
                               (#
                               do (if false then
                                      '**** addRX:addR:'->puttext; off->putint;
                                      ' ' -> put; OGid[] -> putline;
                                  if);
                                  (off,OGid[]) -> addR 
                               #);
                             addVX:: (#do off -> addV #);
                             addAX:: (#do off -> addA #);
               #)#)if)if)
            #);
          gen::
            (* gen is only called for singular Objects and pushed on stack
             * For patterns OG is pushed on stack and genClass called later
             *)
            (# gdb::
                 (#
                 do '>OGid:' -> TT; OGid -> TQ;
                    (if IS.isEmpty then 
                        ' IS.isempty!' -> TT 
                     else
                        ' singular!' -> TT
                    if);
                    ' staticOff='-> TT; staticOff -> II;
                    ' descNo=' -> TT; IS.newDescno->II;
                    ' superAdj=' -> TT; superAdj -> II
                 #);
               printQoff:
                 (#
                 do (if trace then
                        IS.scanSons
                        (# I: ^Item; D: ^Decl
                        do  current[] -> I[];
                           (if I.isDecl then 
                               I[] -> D[];
                               D.qoff[1] -> putint; ' ' -> put; 
                               D.doPT -> putline
                    if)#)if)
                 #);
               name: ^text; head: @boolean;
               on,pn: @integer;
               E: ^Exp; OI: ^ObjectInvocation;
               trace: (# exit false #);
            do (if not genIsDone or true then
                   true -> genIsDone;
                   super.last -> E[];   
                   (if ('???' -> (E.label).equal) and IS.isEmpty then
                       '!!!! OG:gen: is empty ' -> putline;
                       doPP -> putline;
                       leave gen
                   if);
                   (* we have non-singular: foo or singular: foo{...} *)
                   
                   cd.bcPos -> beginBCP;
                   (if IS.isEmpty 
                       and not super.hasVirtualArgs 
                       or (super.isPrimitive and IS.isEmpty) then
                       (* Implies that super.OG is pushed on objTmpStack *)
                       (if ((super.last).ATd[] <> none) 
                           and not ((super.last).ATd.asDecl).isPattern then
                           (* does not completely understand 
                            * what goes on here
                            * For INV = L2, we have to assign 
                            * For inv := L1 * L2, we cannot!
                            *)
                           isCompositeValueObj 
                             -> (super.last).isCompositeValueObj;
                       if);
                       (useRtnVal,superAdj,staticOff) -> super.gen
                    else
                       (* Perhaps move check for virtuals to here!? *)
                       (* Singular object like R.foo{ }
                        * includes pattern invocations with 
                        * virtual arguments like %if .. %then% ... %else ...
                        *)
                       (if not IS.globalRestrictionsInMain then
                           cd.pushThis; (* origin for a singular object *)
                           (* This is also the case for R.S.foo{ ... } *)
                       if);
                       (* Invoke the singular object *)
                       cd.com(#do 'before objTmpStack:add: '->TT;
                                IS.newDescNo -> II; ' ' -> TT; OGid ->TQ #);
                       (this(ObjectGenerator)[],staticOff,false) 
                         -> callInvoke;
                       L:
                         (if not useRtnVal then 
                             IS.scanAllItemDecls
                             (# DI: ^DataItem
                             do (if currentDcl.isOutArg then
                                    currentDcl[] -> DI[]; 
                                    DI.popReturn;
                                    leave L
                             if)#);
                             cd.rPop 
                   if)if);
                   cd.bcPos -> endBCP;     
               if)
            #);
          newStub::
            (# OGxx: ^ObjectGenerator; errs: ^Stream; dNo: @integer
            do '{}' -> parseObjectGeneratorText -> (errs[],OGxx[]);
               OGxx[] -> QnewDesc -> dNo -> OGxx.IS.QdescNo[1];
                           
               (*dNo -> stubDescNo;*)
            #);
          mkVirtualBinding::
            (* make this(OG) a binding of the virtual ptn in encIS
             * with offSet = off
             *)
            (# dNoZero:
                 (# P: ^Pattern; T: ^text; errs: ^Stream; OGs: ^ObjectGenerator;
                 do(* This is a hack - Qalloc is not always called
                    * Perhaps we need to call Qalloc on all 
                    * OGs being included!?
                    *)
                    '**** mkVirtualBinding:dNoZero: ' -> puttext; 
                    sig.dopt -> putline;
                    father.dopt -> putline; '---' ->putline;
                    father.father.dopt -> putline;
                    
                    '' -> T[];
                    sig.dopt -> T.append;
                    ': { %id stub }' 
                      -> T.append
                      -> parseDeclText -> (errs[],P[]);
                    P.OG[] -> OGs[]; 
                    P.setUpOrigin;
                    P.check;
                    OGs[] -> QnewDesc -> dNo -> OGs.IS.QdescNo[1];
                    (if vDescNo > 0 then
                        '!!!! OG.vDescNo > 0 :' -> puttext;
                        vDescNo -> putint; ' ' -> put;
                        dNo -> putint; newline
                     else
                        dNo  -> vDescNo;
                    if);
                    '$' -> OGs.sig.type.id.put;
                    dNo -> OGs.sig.type.id.putint;
                    (if false then
                        '**   dNo: ' -> puttext; dNo -> putint;
                        ' vDescNo: ' -> puttext; 
                        vDescNo -> putint;
                        newline;
                        P.doPt -> putline;
                    if)
                 #);
               dNo: @integer; 
               stubN,stubS: ^text; errs: ^Stream; OGxx: ^ObjectGenerator
               (*encIS: ^Items; off: @integer
            enter(false[],off)*)
            do (if false then
                   '**** mkVirtualBinding: "' -> puttext; OGID -> puttext;
                   '" off: ' -> puttext; off -> putint;
                   '  vDescNo:'->dumpT; vDescNo->dumpI;
                   label -> dumpT; father.label -> dumpT; 
                   father.father.label -> dumpT;
                   ' in: ' -> putline;
                   encIS.dopt -> putHead;
               if);
               (if virtualDone then
                   '**** mkVirtualBinding:virtualDone:' -> putline;
                   leave mkVirtualBinding
               if);
               true -> virtualDone;
               (if not hasItems then 
                   (* not hasItems ==> nonSingularBinding
                    * Like fool(#Ko), elm::< Record, etc. *) 
                   vDescNo -> dNo;
                   (if dNo = 0 then (* never happens? *) dNoZero if);
                   (sig[],this(ObjectGenerator)[]) 
                     -> mkStubName -> (stubN[],stubS[]);
                   (if false then
                       '**   vdt:addTo: ' -> puttext; 
                       cd.descs.current.descInx -> putint;
                       ' ' -> puttext; stubN[] -> puttext; ' '-> put;
                       dNo -> putint; newline;
                   if);
                   (off,dNo,false,stubS[]) -> cd.vdtTable;
                   (if false then
                       '**** Vstub:add: ' -> puttext; OGidWdNo -> puttext;
                       ' vDescNo: ' -> puttext; vDescNo -> putint;
                       ' dNo:' -> puttext; dNo -> putint;
                       ' orgOff:' ->  puttext; IS.newOriginOff ->putint; 
                       newline; father.doPT -> putline;
                   if);
                   (stubN[],dNo,this(ObjectGenerator)[],encIS[]) 
                     -> ObjStubStackX.add;
                else
                   (if false then
                       '**   hasItems:off: ' -> puttext; off -> putint; 
                       ' IS.newDescNo: ' -> puttext;
                       IS.newDescNo -> putint; newline;
                   if);
                   (off,IS.newDescNo,false,OGid(*sig.dopt*)) -> cd.vdtTable
               if);
            #);
          virtualDone: @Boolean;
          pushReturnValues:
            (# ptn: ^Pattern; DI: ^DataItem
            do (if ((father[]->ptn[]).getReturnDecl -> DI[]) <> none then
                   (if true then
                       '**** pushReturnValues:Off:' -> puttext;
                       DI.newOff -> putint;
                       ' '  -> put; DI.doPT -> putline;
                   if);
                   (if not isValueObj then
                       cd.setThisStack
                   if);                   
                   (if DI.OG.isValueObj 
                       and not (DI.OG.primNo = integer_prim) 
                       and not (DI.OG.primNo = boolean_prim) 
                       and not (DI.OG.primNo = char_prim) 
                       and not (DI.OG.primNo = float_prim) 
                      (* and not DI.OG.isUnitValueObj*)
                       then
                       cd.pushThis;
                       DI.newOff -> cd.pushConst;
                       DI.OG.IS.newDescNo -> cd.pushConst
                    else
                       cd.pushThis;
                       DI.invoke
                   if)
                else 
                   (if isValueObj then
                    else
                       cd.setThisStack;
                       cd.pushThis
               if)if)
            #);    
          pushRtnV:
            (# DI: ^DataItem
            enter DI[]
            do (if not isValueObj then
                   cd.setThisStack
               if);                   
               (if DI.OG.isValueObj 
                   and not (DI.OG.primNo = integer_prim) 
                   and not (DI.OG.primNo = boolean_prim) 
                   and not (DI.OG.primNo = char_prim) 
                   and not (DI.OG.primNo = float_prim) 
                   (* and not DI.OG.isUnitValueObj*)
                   then
                   cd.pushThis;
                   DI.newOff -> cd.pushConst;
                   DI.OG.IS.newDescNo -> cd.pushConst
                else
                   cd.pushThis;
                   DI.invoke
               if)
            #);          
          genClass::
            (#
            do (if hasVirtualObject then
                   (if traceGeneric3 then
                       '***** HasVirtualObject: ' -> putline; 
                       (if sig[] <> none then 
                           sig.doPT -> putline;
                        else
                           doPT -> putline;
                           display
               if)if)if);
               (* Move IS.genclass to here? *)
               (if false and (primNo > 0) then
                   '****genclass: isPrimitive: ' -> puttext;
                   OGid -> putline
               else
                   this(ObjectGenerator) -> IS.genClass
               if)
            #);
          
          mkLLVMstruc:
            (# emitLLVMdataItems:
                 (# OGx: ^ObjectGenerator; off: @integer
                 enter(OGx[],off)
                 do (if false then
                        '**** mkLLVMstruc:emitLLVMdataItems:' -> puttext;
                        OGx.OGid -> putline;
                    if);
                    (if (OGx.super.ATd[] <> none) then
                        (*'**   go:super:'->putline;*)
                        ((OGx.super.ATd.asDecl).OG[],off) -> emitLLVMdataItems;
                        (*'**   end:super:'->putline;*)
                    if);
                    OGx.IS.scanSons
                    (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
                    do (if current.isDataItem then
                           current[] -> DI[];
                           cd.com(#do DI.sig.dopt -> TT;
                                    ' Basic:' -> TT; DI.OG.isBasicValue->BB;
                                    ' val: ' -> TT; DI.isValue -> BB;
                                    ' valObj:' -> TT; DI.OG.isValueObj ->BB;
                                    ' Inx:' -> TT; DI.OG.IS.isIndexed -> BB;
                                 #);
                           (if false then
                               '**   :emb: ' -> puttext; DI.sig.dopt -> puttext;
                               ' ' -> put; DI.newoff -> putint;
                               ' ' -> put; off -> putint; newline;
                           if);
                           (if true
                            // DI.OG.IS.isIndexed then
                               DI.newOff + off -> addAX
                            // DI.OG.isBasicValue then 
                               DI.newOff + off-> addVX
                            // DI.isValue then
                               (DI.OG[],DI.newOff - 1) -> emitLLVMdataItems
                            else
                               (DI.newOff  + off,DI.OG.OGidWdNo) -> addRX
                           if)
                       if)
                    #);
                    (if false then
                        '**   mkLLVMstruc:emitLLVMdataItems:end:'->putline
                    if)
                 #);
               addRX:<
                 (# msg:
                      (#
                      do '**** addRXw: ' -> puttext; off -> putint;
                         ' ' -> put; OGid[] -> putline;
                      #);
                    off: @integer; OGid: ^text
                 enter(off,OGid[])
                 do (*msg;*)
                    (if (offTop < off) then 
                        inner;
                        off -> offTop;
                     else
                        (* This happen when origin has been added in a super *)
                        (if false then
                            msg;
                            '!!! offTop >= off ' -> puttext;
                            offTop -> putint; ' ' -> put; off -> putint;
                            newline;
                    if)if)
                 #);
               addVX:<
                 (# off: @integer
                 enter off
                 do (*'**** addVX: ' -> puttext; off -> putint; newline;*)
                    inner;
                    off -> offTop
                 #);
               addAX:<
                 (# off: @integer
                 enter off
                 do (*'**** addAX: ' -> puttext; off -> putint; newline;*)
                    inner;
                    off -> offTop
                 #);                 
               offTop: @integer; org: ^Items; 
               withDN:
                 (# T: ^text; dn: @integer
                 enter(T[],dn)
                 do '$' -> T.put; dn -> T.putint;
                 exit T[]
                 #);
               dn: @integer
            do (if false then
                   '**** mkLLVMstruc: ' -> puttext; dopt -> puthead;
                   cd.typeInfo.print;
               if);
               (* Clean-up needed here
                * Must be recursive in super as is emitLLVMdataItems
                * Must handle more than one origin
                * Must skip origin for value objects
                *)
               (if (IS.superDesc[] <> none) 
                   and (IS.superDesc[] <> objectDecl.desc) then
                   (if false then
                       '**   super: ' -> puttext; 
                       IS.superDesc.encOG.OGid -> puttext; ' ' -> put;
                       IS.superDesc.newOriginOff -> putint; ' ' -> put;
                       IS.superDesc.sig.dopt -> puthead;
                   if);
                   &IS.superDesc.encOG.mkLLVMstruc
                   (# addRX::
                        (#
                        do (off,OGid[]) -> this(mkLLVMstruc).addRX
                        #);
                      addVX::
                        (#
                        do off -> this(mkLLVMstruc).addVX
                        #);
                      addAX::
                        (#
                        do off -> this(mkLLVMstruc).addAX
                        #)
                   #);
               if);
               (if IS.newOriginOff <> 0 then 
                   (* some objects have no origin *)
                   origin[] -> org[];
                   (if org[] <> none then
                       (if false then
                           '**** origin: '->puttext;
                           org.encOG.OGidWdNo -> puttext; ' ' -> put;
                           IS.newOriginOff -> putint;
                           newline;
                       if);
                       (IS.newOriginOff,org.encOG.OGidWdNo) -> addRX;
                       (if (origin[] -> IS.originIsValue) then
                           IS.newOriginOff + 1 -> addVX;
                           IS.newOriginOff + 2 -> addVX;
                       if)
                    else
                       (IS.newOriginOff,objectDecl.OG.OGidWdNo) -> addRX;
               if)if);
               (if sig[] <> none then
                   sig.scanSons
                   (# DI: ^DataItem;
                   do (if current.isDataItem then
                          current[] -> DI[];
                          (if true
                           // DI.OG.isBasicValue (* isBasicPattern? *) then 
                              DI.newOff -> addVX
                           else
                              '**** signature:DI:not catched!' -> putline
                      if)if)
                   #);
               if);
               IS.scanSons
               (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem
               do (if current.isDataItem then
                      current[] -> DI[];
                      cd.com(#do DI.sig.dopt -> TT;
                               ' basic: ' -> TT; DI.OG.isBasicValue -> BB;
                               ' val: ' -> TT; DI.isValue -> BB;
                               ' valObj: ' -> TT; DI.OG.isValueObj -> BB;
                               ' Inx:' -> TT; DI.OG.IS.isIndexed -> BB; print
                            #);
                      (if true
                       // DI.OG.IS.isPureIndexed then
                          DI.newOff -> addAX
                       // DI.OG.isBasicValue (* isBasicPattern? *) then 
                          DI.newOff -> addVX
                       // DI.isValue then
                          (*'*** embed value:' -> puttext; 
                          DI.sig.dopt -> putline;*)
                          (DI.OG[],DI.newOff - 1) -> emitLLVMdataItems;
                       else
                          (if false then
                              '**** addRXq: ' -> puttext; DI.newOff -> putint;
                              ' ' -> put; DI.sig.dopt -> putline;
                          if);
                          (DI.newOff,DI.OG.OGidWdNo) -> addRX
                      if);
                   else 
                      (if current## 
                       // Module## then
                          current[] -> M[]; 
                          (if true then
                              'Module: '->puttext; moduleName -> puttext; 
                              ' ' -> put; M.newOff -> putint; newline;
                          if);
                          (M.newOff,M.OG.OGidWdNo(*moduleName*)) -> addRX
                       // ModuleItem## then
                          current[] -> MI[];
                          (if MI.MD.off > 0 then
                              (If false then
                                  'MI:'->puttext; 
                                  MI.MD. moduleName->puttext;
                                  ' ' -> put; 
                                  MI.MD.OG.OGidWdNo -> puttext;
                                  ' ' -> put;
                                  MI.MD.newOff -> putint;
                                  (*MI.MD.OG.IS.qDescNo[1] -> putint;*)
                                  newline;
                              if);
                              (MI.MD.newOff,MI.MD.OG.OGidWdNo(*moduleName*)) 
                                -> addRX
                  if)if)if)
               #);
               (if false then
                   cd.typeInfo.print;
                   '**** mkLLVMstruc:end: ' -> puttext; dopt -> puthead;
               if)
            #);
          computeGCinfo:
            (# 
            do (*'****compouteGCinfo: '->putline; dopt -> puthead;*)
               cd.addGCinfo
               (# rtnDI: ^DataItem
               do (if IS.newOriginOff <> 0 then (* some objects have no origin*)
                      IS.newOriginOff -> add;
                  if);
                  (* Code for checking refs in Signature has been removed *)
                  (if (IS.superDesc[] <> none) 
                      and (IS.superDesc[] <> objectDecl.desc) then
                      (*'\nsuper: ' ->puttext; IS.superDesc.sig.dopt->puthead;*)
                      (*(IS.superDesc.theObjectGenerator).computeGCinfo*)
                      IS.superDesc.encOG.computeGCinfo
                  if);
                  IS.scanSons
                  (# DI: ^DataItem; M: ^Module; MI: ^ModuleItem;
                     doAdd:
                       (# D: ^Decl
                       enter D[]
                       do (if nameListInDcL then
                              D.sig.names.scan
                              (#
                              do (if false then
                                     D.sig.dopt -> puttext; ':'->put;
                                     current.off->putint; newline;
                                     current.off -> add (* OBS! after if! *)
                                 if)
                              #)
                           else
                              D.newOff -> add
                          if)
                       #)
                  do (if current.isDataItem then
                         current[] -> DI[];
                         (if DI.OG.isBasicValue or DI.isValue then
                          else
                             (*DI.sig.dopt->puttext; ':'->put; 
                              * DI.newOff->putint;newline;*)
                             DI[] -> doAdd
                         if);
                      else 
                         (if current## 
                          // Module## then
                             current[] -> M[]; 
                             (*'Module: '->puttext; moduleName -> puttext;
                              * ' ' -> put; M.newOff -> putint; newline;*)
                             M[] -> doAdd
                          // ModuleItem## then
                             current[] -> MI[];
                             (if MI.MD.off > 0 then
                                 (*'MI:'->puttext; MI.MD. moduleName->puttext;
                                  * ' ' -> put; MI.MD.newOff->putint; newline;*)
                                 MI.MD[] -> doAdd
                     if)if)if)
                  #);
                  (*newline*)
               #);
            #);
          clear::< (# do false -> marked -> virtualDone; inner #);
       #);
     items::
       (# isIndexed: booleanValue
            (#                               
            do (if primNo // String_prim // indexed_prim // rIndexed_prim then
                   true -> value
                else
                   (if superDesc[] <> none then
                       superDesc.isIndexed -> value
               if)if)
            #); 
          isPureIndexed: booleanValue
            (#                               
            do (if primNo // indexed_prim // rIndexed_prim then
                   true -> value
                else
                   (if superDesc[] <> none then
                       superDesc.isPureIndexed -> value
               if)if)
            #);
          codeGenDone: @boolean;
          genClass:
            (# N: ^text; sig: ^Signature; descNo: @integer; 
               super: ^Invocation;
               T: @text; ptn: ^Pattern;
               vSuperDesc: ^Items;
               OG: ^ObjectGenerator;
               genSuperClass:
                 (#
                 do (if (superDesc[] <> none) then
                        superDesc.father.father -> ptn[]; 
                        encOG[] ->  superDesc.genClass;
                    if)
                 #);
               mkClassDef:
                 (# org: ^items; originDescNo: @integer; orgId: ^text
                 do (if (origin[] -> org[]) <> none then
                        org.encOG.OGid -> orgID[];
                        org.newDescNo -> originDescNo;
                     else
                        objectDecl.OG.OGid ->orgId[];
                        objectDecl.OG.IS.newDescNo -> originDescNo;
                    if);
                    (N[],newDescNo,false,(topSuper).newDescNo
                    ,newOriginOff,orgId[],originDescNo,encOG.isValueObj,false)
                      -> cd.class;
                    (* Copy vdt and literals; this must be done after
                     * cd.class is executed, sine eval of arguments in super
                     * may conatin strings being added to Literals
                     *)
                    (if this(Items)[] -> hasRealSuper then
                        superDesc.newDescNo -> cd.vdtTableCopy;
                        (if superDesc.innerInx > 0 then
                            (superDesc.innerInx,newDescno,true,'innerS') 
                              -> cd.vdtTable
                    if)if)
                 #);
               handleArgumentsAndOrigin:
                 (* mainIS was introduced in order to handle virtual
                  * valueObjs as in eq (=) for Cvalue, but does not work;
                  * we dont know the size of in V: var thisValue
                  *)
                 (# mainIS,theIS: ^Items; vArgsInSuper: @integer
                 enter(mainIS[],theIS[])
                 do (mainIS[],theIS[]) -> storeArguments -> vArgsInSuper;
                    (mainIS[],theIS[]) -> StoreOrigin;
                    (theIS[],vArgsInSuper) -> AllocateSuper;
                    (if theIS[] -> hasRealSuper then
                        cd.com(#do 'hArgOrg:super:' -> TT; 
                                 theIS.superDesc.encOG.OGid -> TT
                              #);
                        (mainIS[],theIS.superDesc[]) -> handleArgumentsAndOrigin
                    if)
                 #);               
               StoreArguments:
                 (# mainIS,theIS: ^Items; N: @integer; org: ^Items;
                    emit:
                      (#
                      do '**** StoreArguments:origin:isValueObj:'->puttext;
                         theIS.encOg.dopt -> putheadn;
                      #);
                    isVeq: @boolean
                 enter(mainIS[],theIS[])
                 do (if not emitLLVM then
                        cd.com(#do 'Store itemArgs:' -> TT; dopt->TT #);
                        (* Should this be scanNonBoundItemArgs?
                         ' No! Only onbound args in theIS, since we 
                         * visit IS of all superpatterns
                         *)
                        (if primNo
                         // vEq_prim // vLE_prim then true -> isVeq		
                            (*'**** vEq: '->puttext; theIS.dopt -> putheadN;*)
                        if);
                        (*'**** theIS:'->puttext; theIS.dopt->putheadn;
                         * '**   args:'->putline;
                         *)
                        theIS.scanItemArgsReverse
                        (# qual: ^ObjectGenerator; OGSx: ^OGsequence;
                           isString: @boolean
                        do cd.com(#do currentArg.dopt -> TT;
                                     stringAsVal -> BB;
                                     currentArg.OG.primNo -> II
                                  #);
                           false -> isString;
                           (if stringAsVal and
                               ((currentArg.OG.primNo = this_prim) or
                               (currentArg.OG.primNo = string_prim))
                               then
                               (mainIS.encOG[],false
                               ,(mainIS.encOG[],false,none)->OGsequence)
                                 -> currentArg. getVqual
                                 -> (OGSx[],qual[]);
                               qual.primNo = String_prim -> isString
                           if);
                           (if false and isVeq then 
                               currentArg.dopt->putline; 
                               cd.com(#do 'vEq:store:'->TT; 
                                        currentArg.dopt -> TQ #)
                           if);
                           (if isString then
                               (* we may have a ref arg on the stack
                                * - so use shiftUp
                                *)
                               (*cd.rswap;*)
                               cd.pushThis; (* we store this 
                                             * should be ref on stack
                                             *)
                               (currentArg.sig.dopt,currentArg.newOff)
                               -> cd.rstoreg
                            else
                               (true,mainIS[]) -> currentArg.store
                           if)
                        #);
                        (if (theIS.origin[]<>none)
                            and (theIS.origin->org[]).encOG.isValueObj then
                            true -> theIS.scanNonBoundItemArgs
                            (# DI: ^DataItem
                            do (if false and currentArg.isDataItem then
                                   (if false and (N = 0) then emit if);
                                   currentArg[]  -> DI[];
                                   (if true 
                                    // DI.OG.isBasicValue then
                                       N + 1 -> N;
                                    // DI.OG.isValueObj then
                                       N +  DI.OG.objSize + 1 -> N
                                    else
                                       '???' ->putline
                                   if);
                                   (if false then
                                       '**   objSize: ' -> puttext;
                                       DI.OG.objSize -> putint;
                                       ' basicValue: ' -> puttext;
                                       DI.OG.isBasicValue -> putboolean;
                                       ' valueObj: '-> puttext;
                                       DI.OG.isValueObj -> putboolean;
                                       ' ' -> put;
                                       currentArg.dopt -> putline;
                                   if);
                                   (# out: ^text; E: ^Invocation;
                                      OGs: ^OGsequence; qual: ^ObjectGenerator
                                   do DI.sig.dopt -> parseInv->(out[],E[]);
                                      theIS[] -> E.father[];
                                      theIS[] -> E.setUpOrigin;
                                      (none,theIS[],theIs[],true) -> E.check;
                                      (theIS.encOG,true
                                      ,(theIS.encOG,false,none) ->OGsequence)
                                        -> E.getVqual
                                        -> (OGs[],qual[]);
                                      (if false then
                                          E.dopt->putline;
                                          qual.doPT -> puthead;
                                          qual.objSize -> putint; 
                                          ' valueObj: ' -> puttext;
                                          qual.isValueObj -> putboolean;
                                          newline;
                                      if);
                                      qual.objSize -> N;
                                      (if qual.isValueObj then N + 1 -> N  if)
                                   #);
                               if)
                            #);
                            (if N > 0 then
                                (*N -> putint; newline; *)
                                N + 1 -> cd.vShiftUp;
                                N + 1 -> cd.vShiftUp;
                    if)if)if)
                 exit N
                 #);
               StoreOrigin:
                 (# mainIS,theIS: ^Items; org: ^Items
                 enter(mainIS[],theIS[])
                 do (if theIS.globalRestrictionsInMain then
                        (if traceNoGlobals then
                            cd.com(#do 'NoNlobals,noOrigin'->TT;theIS.dopt->TT#)
                        if)
                     else
                        cd.com(#do 'Store:Origin:'->TT;
                                 (if (mainIS.origin[]->org[]) <> none then
                                 org.primNo->II if)#);
                        (if ((theIS.noOfRefArgsInSuper -> rArgsInSuper) > 0)
                            (*or 
                            ((mainIS.origin[]->org[]) <> none)
                            and (org.primNo = String_prim)*)
                            then
                            (* if super has ref args, 
                             * then these are on the stack above origin
                             * Here S = origin and x,y,z are 3 ref args
                             * rShift moves S to top of rStack
                             * ------------      ------------
                             * |...|S|x|y|z  ==> |...|x|y|z|S
                             * ------------      ------------
                             *)                           
                            rArgsInSuper -> cd.rShiftUp
                        if);
                        cd.tstOriginIsNone;
                        ('origin',theIS.newOriginOff) -> cd.rstore;
                        (if false and (theIS.newDescNo = 78) then
                            '**** StoreOrigin:before:originISValue:'->putline;
                            dopt -> puthead
                        if);
                        (if (theIS.origin[] -> originIsValue)
                            and (mainIS.origin[] -> originIsvalue) then
                            ('origin.valueOff',theIS.NewOriginOff + 2) 
                              -> cd.store;
                            ('origin.valueOff',theIS.NewOriginOff + 1) 
                              -> cd.store;
                   if)if)
                 #);
               prepareSuper:
                 (*************** only for main.super: factor out *)
                 (#
                 do (ptn.sig.id[],superDesc.newDescNo) -> cd.super;
                 #);
               addOG:
                 (# OGx: ^ObjectSpecification; off: @integer
                 do (if OG.isArgofE[] <> none then
                        cd.com(#do 'addOG:'->TT #);
                        (if traceArgOG then
                            '**** OG inArgument: ' -> putline;
                            OG.dopt -> puthead;
                            '**   OG.isArgOfE:\n' -> puttext;
                            OG.isArgOfE.dopt -> putline;
                        if);
                        (if OG.isArgOfE.father.father##
                            = BracketedExp## then
                            OG.isArgOfE.father.father.father[]
                              -> OGx[];
                         else
                            OG.isArgOfE.father.father[] -> OGx[];
                        if);
                        OGx.IS.newOriginOff -> off;
                        (* We do get ObjectCall and off = 0 below!
                         * OG.isArgOfE.enclosingObjectGenerator and 
                         * OG.isArgOfE.origin.father[] do not work, 
                         * since they return the OG enclosing OGx.
                         * Must be understood!?
                         *)
                        (if (OGx## = ObjectCall##)
                            or (off = 0)  then
                            '**** OG in:argument: ' -> puttext;
                            OGx.label -> puttext; ' ' -> put;
                            off -> putint; newline;
                            OGx.dopt -> putheadN
                        if);
                        (if traceArgOG then
                            OGx.dopt -> puthead;
                            '**   originOff:'->puttext; 
                            off->putint; newline;
                        if);
                        (if (off > 0) then
                            (if nameListInDcl then
                                ('ArgOGs',(sig.names.firstDecl).off) 
                                  -> cd.rpushg;
                             else
                                ('ArgOGs',off) -> cd.rpushg;
                    if)if)if)
                 #);               
               AllocateSuper: 
                 (# pushAddress:
                      (* super is searched in the origin of 
                       * this(OG); we must then have an 
                       * additional goOrigin from this(OG);
                       * this is handled by passing newOriginOff
                       * as an argument of Address - superAdj;
                       * adjustOrigin will generate this goOrigin
                       * if superAdj > 0
                       *)
                      (# super: ^Invocation; E,rec: ^Exp; A: ^Address;
                      enter super[]
                      do (if globalRestrictionsInSuper then
                             super.last -> E[]
                          else
                             theIS.newOriginOff
                               -> super.computeAdr(#do addOG #)
                               -> (rec[],E[],A[]);
                             cd.com
                             (#do 'genClass:after:pushAddress:'-> TT; 
                                E.doPT -> TQ; A.print -> TT #);
                         if)
                      exit E[]
                      #);
                    handleSuperArgs:
                      (# theIS: ^Items; E: ^Exp
                      enter(theIS[],E[])
                      do cd.com(#do 'handleSuperArgs:E:'->TT; E.dopt->TQ;
                                  'theIS:'->TT; theIS.dopt->TQ #);
                         (* What does sig[] = none imply? *)
                         (if theIS.sig[] = none then
                             cd.com(#do'super.sig:none:superAdj:'-> TT;
                                      newOriginOff -> II #);
                             (theIS.newOriginOff,0) -> E.loadArgs; 
                          else
                             cd.com(#do'super.sig:not:none:superAdj:'->TT;
                                      - newOriginOff -> II #);
                             (* go ON-1, use newOriginOff first time *)
                             (- theIS.newOriginOff,0) -> E.loadArgs;
                         if);
                         (******* handle virtual args of super ***)
                         E.handleVargs;
                      #);
                    theIS: ^Items; E: ^Exp; vArgsInSuper,off: @integer; 
                 enter(theIS[],vArgsInSuper)
                 do (if not theIS.encOG.isValueObj then 
                        (if not ((theIS.superDesc[] <> none) 
                            and not theIS.superDesc.isPrimitive) then
                            theIS.encOG.isObj -> cd.allocEventQ
                    if)if);
                    (if theIS[] -> hasRealSuper then
                        prepareSuper;
                        cd.com(#do 'push:super.origin:'->TT #);
                        (********* push super.origin *)
                        (if theIS.super.isImplSuper then
                            (if not theIS.globalRestrictionsInsuper then
                                (if theIS.super.isSingularImplSuper then
                                    cd.com(#do'isSingularImplSuper:'->TT#);
                                    cd.pushThis;
                                    ('iOrigin',theIS.newOriginOff) -> cd.rpushg;
                                    (if (theIS.origin[] -> originIsValue) then
                                        cd.pushThis;
                                        (T[],theIS.newOriginOff + 1) 
                                          -> cd.pushg;
                                        cd.pushThis;
                                        (T[],theIS.newOriginOff + 2)
                                          -> cd.pushg;
                                    if);
                                    (* For implicit super we may have
                                     * snorf::< {...}
                                     * we thus create an empty Exp
                                     *)
                                    Exp -> E[] 
                                 else
                                    cd.com(#do'isNonSingularImplSuper:'->TT#);
                                    theIS.super.ATd.asDecl -> ptn[]; 
                                    (* snorf:< foo    or
                                     * snorf:< koks.foo
                                     * ...
                                     * snorf ::
                                     *    ...
                                     * ptn = snorf:< foo or snorf:< koks.foo
                                     *)
                                    ptn.OG.super[] -> pushAddress -> E[];
                            if)if)
                         else
                            theIS.super[] -> pushAddress -> E[];
                        if);
                        (if vArgsInSuper > 0 then
                            vArgsInSuper + 1 -> cd.vShiftDown;
                            vArgsInSuper + 1 -> cd.vShiftDown;
                        if);
                        (if E[] = none then
			     (*'!!!! E is none'->putline*)
                        else
                           (theIS[],E[]) -> handleSuperArgs;
                        if);		 
                        (if rArgsInSuper > 0 then 
                            (* Reverse of rShiftUp as described above
                             * See rShift in VM/objectImage
                             *)
                           rArgsInSuper -> cd.rShiftDown
                        if);
                     else
                        (if objectDecl.OG.IS[] <> theIS[] then
                            (1,theIS.newDescno,true,'innerM') -> cd.vdtTable;
                    if)if)
                 #);
               checkIfBetaWorldOrStringModule:
                 (#
                 do (if newDescNo = (markIncludes.topModule.desc).newDescno then
                        cd.pushThis;
                        cd.saveBETAworld
                    if);
                    (if isStringModule then cd.saveStringOrigin if);;
                 #);
               mvStack:
                 (#
                 do (if (superDesc[] <> none) and not superDesc.isPrimitive then
                     else 
                        (if not OG.isValueObj then 
                            cd.mvStack
                    if)if)
                 #);
               genAttributes:
                 (# theIS: ^Items
                 enter theIS[]
                 do (if (theIS[] -> hasRealSuper)
                        and (theIS.superDesc[] <> objectDecl.desc) then
                        theIS.superDesc[] -> genAttributes
                    if);
                    theIS.scanSons
                    (# I: ^Item; MP: ^Module
                    do current[] -> I[];
                       (if true
                        // I.isDecl and (I## <> LabelDecl##) then
                           (if not I.isPattern or I.isVirtual then
                               (false,0,0) -> current.gen -> MP[];
                               (if MP[] <> none then
                                   MP[] -> mainPathModule[];
                               if)
                            else
                               (if I[] = StringDecl[] then
                                   (false,0,0) -> current.gen if) 
                           if)
                        // I.isNewProp then
                           (false,0,0) -> current.gen -> MP[];
                           (if MP[] <> none then
                               MP[] -> mainPathModule[];
                           if)
                    if)#);
                    (if mainPathModule[] <> none then
                        (false,0,0) -> mainPathModule.gen;
                        none -> mainPathModule[]
                    if)
                 #);
               genActionPart:
                 (#
                 do (not OG.isValueObj and 
                    not ((superDesc[] <> none) and not superDesc.isPrimitive )
                    ) -> cd.actions;
                   (if not OG.isValueObj then cd.mvStack if);
                   restartLab -> cd.defLab;
                   scanSons
                   (# I: ^Item; superHasNewInner: @boolean
                   do current[] -> I[];
                      (if not I.isDecl or (I## = LabelDecl##) then 
                          cd.com(#do 'genclass:stmt:'->TT; current.doPT->TQ#);
                          (if isLast then
                              (if super.ATd[] <> none then
                                  (super.ATd.asDecl).OG.IS.newInner[] <> none
                                    -> superHasNewInner
                          if)if);
                          (superHasNewInner,0,0) -> current.gen 
                   if)#);
                   leaveLab -> cd.defLab;
                   (if (superDesc[] <> none) and not superDesc.isPrimitive then
                       'M' -> cd.rtnInner
                    else
                       cd.com(#do 'pushReturn: ' -> TT; 
                                (if sig[] <> none then sig.id[] -> TQ if)#);
                       (if encOG.isValueObj then
                           (if sig[] <> none then
                               encOG.pushReturnValues
                           if);
                           cd.rtnV
                        else
                           cd.setThisStack;
                           cd.pushThis
                       if);
                       'D' -> cd.rtn (* also for value object?  *)
                   if)
                 #);
               BindVirtuals:
                 (# E: ^Exp;
                    args: [6]^ObjectGenerator(*Specification*); top,i: @integer;
                 do (if (super.last -> E[]) = none then 
                        leave BindVirtuals
                    if);
                    (if (E.args[] <> none) and (E.args.noOfSons > 0)  then
                        cd.com(#do 'Handle VB:'->TT; dopt -> TQ;
                                 'E:' -> TT; E.doPT -> TQ #);
                        E.args.scanArgs
                        (#
                        do (if (top+1 -> top) > args.range then 
                               args.range -> args.extend 
                           if);
                           current[] -> args[top][];
                        #);
                        (if super.ATd[] <> none then
                            (* bind possible virtuals in arguments to super *)
                            (super.ATd.asDecl).OG.IS.scanAllDecls
                            (# i: @integer; P: ^Pattern; off: @integer
                            do (* Only some inargs may be virtual
                                * And not all virtuals are inargs
                                *)
                               (if currentDcl.isInarg then 
                                   i + 1 -> i;
                                   (if (currentDcl.isVirtual)  then
                                       currentDcl[] -> P[];
                                       (if false then
                                           P.dopt -> putline;
                                           '---'->putline;
                                           args[i].doPT -> putline;
                                           ' args[i].hasItems:' -> puttext;
                                           args[i].hasItems -> putboolean;
                                           ' args[i].vDescNo:' -> puttext;
                                           args[i].vDescNo -> putint;
                                           ' P.OG.vDescNo:' -> puttext;
                                           P.OG.vDescNo -> putint;
                                           ' P.off:' -> puttext;
                                           P.off -> putint;
                                           '\n==='->putline;
                                       if);
                                       (if nameListInDcl then
                                           (P.sig.names.firstDecl).off-> off;
                                           (this(Items)[],off) 
                                             -> args[i].mkVirtualbinding
                                        else
                                           (this(Items)[],P.off)
                                             -> args[i].mkVirtualbinding
                                       if)
                    if)if)#)if)if);
                    (* bind virtuals defined in Signature *)
                    (if sig[] <> none then
                        sig.scanSons
                        (# D: ^Decl; P: ^Pattern
                        do (if current.isDecl then
                               current[] -> D[];
                               (if D.isVirtual then
                                   D[] -> P[];
                                   (if nameListInDcl then
                                       (this(Items)[]
                                       ,(P.sig.names.firstDecl).off)
                                         -> P.OG.mkVirtualbinding
                                    else
                                       (this(Items)[],P.off) 
                                         -> P.OG.mkVirtualBinding
                    if)if)if)#)if);
                    (* Bind virtuals defined/bound in mainpart *)
                    scanSons
                    (# I: ^Item; P: ^Pattern
                    do current[] -> I[];
                       (if I.isVirtual then
                           I[]->P[];
                           (if nameListInDcl then
                               (this(Items)[]
                               ,(P.sig.names.firstDecl).off)
                                 -> P.OG.mkVirtualbinding
                            else
                               (this(Items)[],P.off) -> P.OG.mkVirtualBinding
                    if)if)#);
                    newDescNo -> cd.endNewVirtDefs;
                 #);  
               handleLLVMvirtuaDefs:
                 (#
                 do cd.mkLLVMvirtualDefs
                    (# handleOrigins::
                         (#
                         do cd.lcom(#do 'handleOrigins:NEW:'->TT; OG.OGid->TT#);
                            (if (OG.IS.newOriginOff > 0) then
                                (if OG.primNo 
                                 // object_prim then
                                 else
                                    (OG[],OG[],true) -> storeOrigins;
                                    cd.lcom(#do 'handleOrigins:END: ' -> TT #)
                         if)if)#);
                       vName::
                         (# OGx: ^ObjectGenerator; org: ^Items
                         do dn -> QnewDesc.getOD -> OGx[];
                            (if OGx.super[] = none then
                                (if false then
                                    'handleLLVMvirtualDefs:supIsNone:'->putline;
                                    dn -> putint; newline;
                                    OGx.dopp -> putline;
                                    OG.dopt -> puthead;
                                if);
                                'emptyOG'->vN[]
                             else
                                (if false then
                                    '**** vName:'->puttext; 
                                    OGx.OGidWdNo -> puttext;
                                    ' ' -> put; OG.vDescNo -> putint;
                                    ' ' -> put; OGx.vDescNo -> putint;
                                if);
                                OGx.OGidWdNo -> vN[];
                            if);
                            origin[] -> org[];
                            (if org[] <> none then 
                                org.encOG.OGidWdNo -> orgOfVN[];
                                (if false then
                                    '**   origin:'->puttext; 
                                    orgOfVN[] -> puttext; ' ' ->put;
                                    org.encOG.vDescNo -> putint;
                                    newline;
                                if)
                             else
                                'Object$0' -> orgOfVN[] (* to be fixed! *)
                    if)#)#)
                 #);
               mainPathModule: ^Module;     
               rArgsInSuper: @integer;
            enter OG[]
            do (* Is called with descNo = NewDescNo *)
               (* the following dataitems used to be arguments of genClass *)
               OG.OGid -> N[]; OG.sig[] -> sig[]; newDescNo -> descNo;
               OG.super[] -> super[];
               
               cd.com
               (#do 'Items:GenClass:'->TT; N[]->TT; 'descNo:'->TT; descNo->II#);
               
               2 -> labelhandLer.labCount;
               genSuperClass;
               
               (if (primNo = vEq_Prim) or (primNo = vLE_prim) then
                   (*'**** got:vEq: ' -> puttext; primNo -> putint; ',' -> put;
                   (if (super[] <> none) and (super.ATd[] <> none) then
                       (super.ATd.asDecl).primNo -> putint;
                   if);
                   newline;*)
                   5 -> qsize[1] (* do we nneed this?*)
               if);
                    
               (if (superDesc[] <> none) 
                   and (super[] <> none) 
                   and (super.ATd[] <> none)
		   and (((super.ATd.asDecl).primNo = vEq_prim)
                   or ((super.ATd.asDecl).primNo = vLE_prim)) then
                   cd.com(#do 'got:sub:vEq: ' ->TT; 
                             (if (super[] <> none) and (super.ATd[] <> none)
                                 then
                                 super.ATd.primNo -> II
                             if);
                             ' isValueObj: ' -> TT; encOG.isValueObj -> BB;
                             qsize[1] -> II
                          #);
                   qsize[1] + 5 -> qsize[1]; (* needed? *)
                   encOG.reAlloc;
               if);

               (if not codeGenDone then
                   true -> codeGenDone;
                   mkClassDef;
                   (* thisObj = the new instance of this class 
                    * thisStack = caller
                    * Possible arguments on callerStack = thisStack
                    *)
                   cd.bcPos -> beginBCP;
                   
                   (this(Items)[],this(Items)[]) ->handleArgumentsAndOrigin;
                   checkIfBetaWorldOrStringModule;
                   mvStack;
                   (if sig[] <> none then (*(false,0,0) -> sig.gen*) if);
                   (* genAttributes for possible super - recursively *)
                   cd.markEnterE; 
                   this(Items)[] -> genAttributes;
                   (* goSuper *)
                   (if (this(Items)[] -> hasRealSuper) then
                       (if superDesc.primNo // vEq_prim // vLE_prim then
 		        else
                           (* Value::Eq (=) has no code and possible *)
                           1 -> cd.rtnAlloc;
                           (realTopSuper).newDescNo -> cd.toSuper
                       if)
		      else
		       (if not this(Items).encOG.isValueObj then
                           1 -> cd.rtnAlloc
		   if)if);
                   genActionPart;
                   encOG.computeGCinfo;
                   (objSize,isIndexed,newBasicProp.OSDvisibility) 
                     -> cd.endClass;
                   cd.bcPos -> endBCP;
                   (if innerInx > 0 then
                       (innerInx,0,true,'innerX') -> cd.vdtTable; 
                   if);
                   BindVirtuals;
                   handleLLVMvirtuaDefs;                   
                   cd.lcom(#do 'ObjStubStackX:gen' -> TT #);
                   ObjStubStackX.gen;
               if);
            #);
          goOrigin:
            (# on: @integer; NA: ^Apl; org: ^Items; scp: ^Scope; T: ^text; 
               orgIsVal: @boolean; off: @integer
            enter(on,NA[])
            do (if on > 0 then
                   cd.com(#do 'items:goOrigin:'-> TT; on -> II #);
                   (if false and encOG.isValueObj then
                       '**** Items:goOrigin:isValueObj:'->dumpT;
                       encOG.OGid -> dumpTN; dopt->dumpTN;
                       cd.fcom(#do 'goOrigin:valueObj:'->TT; encOG.OGid->TQ #)
                   if);
                   NA[] -> checkGlobalsViolations;
                   (if encOG.IS.newOriginOff = 0 then 
                       '!!!! encOG.IS.newOriginOff = 0:'->dumpTN;
                   if);
                   (if true then
                       encOG.OGidWdNo -> T[];
                    else                   
                       ((NA.origin[]->scp[]).OGofScope).OGidWdNo -> T[];
                   if);
                   (if (origin[] -> originIsValue) and
                       not ((origin[]->org[]).encOG.primNo = string_prim) then
                       cd.fcom(#do 'origin.valueOff:load ' -> TT; 
                                newOriginOff + 1 -> II #);
                       cd.rdouble;
                       (T[],newOriginOff) -> cd.rpushg;
                       cd.rswap;
                       cd.rdouble;
                       (T[],newOriginOff + 1) -> cd.pushg;
                       (T[],newOriginOff + 2) -> cd.pushg;
                       true -> orgIsVal
                    else
                       (if newOriginOff = 0 then
                           cd.fcom(#do 'newOriginOff=0:'->TT; T[] -> TQ #);
                           (T[],(encOG.origin[]->org[]).newOriginOff) 
                             -> cd.rpushg;
                        else
                           (T[],newOriginOff) -> cd.rpushg;
                       if)
                   if);
                   (if (origin[] <> none) (*and (on > 1)*) then
                       (on - 1,NA[]) 
                         -> (origin[]->org[]).goOrigin
                         -> (org[],orgIsVal);
                   if);
                   (if (encOG.isArgofE[] <> none) then
                       encOG.IS.newOriginOff -> off;
                       (if false then
                           '**** GoOrigin:OG inArgument: ' -> putline;
                           encOG.dopt -> puthead;
                           '**   of:'->putline; 
                           encOG.isArgofE.dopt -> puthead;
                           '**   originOff:'->puttext; off->putint;newline;
                       if);
                       ('ArgOG',off) -> cd.rpushg;
                       cd.fcom(#do 'ArgOG:'->TT; off->II #)
                   if);
                else
                   this(Items)[] -> org[]
               if)
            exit(org[],orgIsVal)
            #); 
          findNextImp::
            (#
            do L:
                 scanSons
                 (#
                 do (if (bcp -> current.findNextImp -> impx[]) <> none then
                        leave L
                 if)#);
            #);
          clear::< (# do false -> done -> codeGenDone #)
       #);
     Pattern::
       (# GeneralPattern::
            (# invoke:: (# <<SLOT GeneralPattern_invoke:doPart>> #);
            #);
          AssignmentPattern::
            (# invoke:: (# <<SLOT AssignMentPattern_invoke:doPart>> #);
            #);
          BreakPattern::
            (# invoke:: (# << SLOT BreakPatternInvoke:doPart>> #)
            #);
          IndexedPattern::
            (# invoke:: (# <<SLOT IndexPattern_invoke:doPart>> #);
            #);
          OtherPrimPattern:: 
            (# invoke:: (# <<SLOT OtherPrim_invoke:doPart>> #); 
               org: ^Items; Tlab,exitLab: @labelHandler.label;
            #);
          virtualDone: @boolean;
          gen:: (##);
          pushThis::
            (# T: @text
            do (if OG.primNo
                // 0 
                // value_prim  (* OBS - needed for a ptn being sub of Value
                                * otherwise execution fails since origin 
                                * is not loaded
                                * An explicit sub of Object also fails
                                *)
                // this_prim 
                // indexedGet_prim (* not tested*)
                // indexedPut_prim (* ditto *)
                // stringGet_prim 
                // indexed_prim  
                // rIndexed_prim
                // immutable_prim then
                   cd.pushThis 
                else (* ugly *)
                   (if ptnKind // virtualPtn // furtherPtn // FinalPtn then
                       cd.pushThis 
                   if)
               if)
            #);
          loadArgs::
            (# gdb:: 
                 (# 
                 do '>E:' -> TT; E.doPT -> TQ;
                    ':descNo:' -> TT; OG.IS.newDescNo -> II;
                 #);
               handleNonVirtualArg:             
                 (# formalArg: ^DataItem; actualArg: ^ObjectSpecification;
                    superOG: ^ObjectGenerator;
                 enter(formalArg[],actualArg[])
                 do (* E is the exp with arguments actArgs 
                     * this(Pattern) = E.ATd
                     * formalArg is arg no. argInx of this(Pattern)
                     *)
                    cd.com(#do 'NonVirt:'->TT; E.doPT -> TQ; nl;
                             'ActArg: ' -> TT;actualArg.dopt->TQ;
                             'isValue: ' -> TT;  actualArg.isValueObj->BB;
                          #);
                    cd.com(#do
                             'formalArg.OG.isBasicValue:' -> TT;
                             formalArg.OG.isBasicValue -> BB;
                             ' formalArg.OG.isValueObj:' ->TT; 
                             formalArg.OG.isValueObj -> BB;nl;
                             ' formalArg.OG.isNonBasicValueObj:' -> TT;
                             formalArg.OG.isNonBasicValueObj -> BB
                          #);
                    (* The call of gen should perhaps have the receiver 
                     * as an argument!?
                     * Currenly we handle stuff af gen that depends on 
                     * the receiver
                     *)
                    0 -> staticOff;
                    (* we may mark actualArg as isUnitVal or float 
                     * depending on this ptn *)
                    (if primNo 
                     // 112 (* float-* *) then
                        cd.com
                        (#do 'loadArgs:isPrim:assign,fmult: '->TT; 
                           primNo->II;E.dopt->TQ #);
                     else 
                        (* Perhaps we dont need both booleans below!? *)
                        formalArg.OG.isNonBasicValueObj 
                          -> actualArg.isCompositeValueObj;
                         
                        (* actualArg is a composite valueObj,
                         * not a basic value
                         * and this(ptn) is not value assignment nor * !
                         * We do not know if it is a UnitValue
                         * ActualArg is a valueObj being an actual arg to 
                         * a ptn that is not assign, float-*, etc.
                         *)
                        cd.com(#do 'loadArgs:not:*: ' -> TT;
                                 'formalArgOf:' -> TT; E.doPT -> TQ;
                                 ' isCompositeValueObj:' -> TT;
                                 actualArg.isCompositeValueObj -> BB
                              #)
                    if);
                    cd.com(#do 'loadArgs:A:' -> TT; actualArg.doPT -> TQ #);
                    (true,superAdj,staticOff) -> actualArg.gen;
                    cd.com(#do 'loadArgs:after:gen:' -> TT; E.doPT->TQ #);

                    (if actualArg.isNonBasicValueObj 
                        and (actualArg.super.ATd.asDecl).isDataItem then
                        (* actualArg is a data-item being 
                         * a (nonBasic?) ValueObj *)
                        cd.com(#do 'before:pushSize: ' -> TT;
                                 'actualArg.super.ATd.OG.isUnitValueObj:'
                                   -> TT;
                                 actualArg.super.ATd.OG.isUnitValueObj 
                                   -> BB; nl;
                                 ':actualArg.isCompositeValueObj:'->TT;
                                 actualArg.isCompositeValueObj -> BB;
                              #);
                        (if not (actualArg.super.ATd.asDecl).OG.isUnitValueObj 
                            or actualArg.isCompositeValueObj
                            then
                            (* composite valueObj or not a unitValue *)
                            (*11 -> cd.pushConst;*)
                            actualArg.objSize -> cd.pushValue;
                            1 -> cd.pushConst
                         else
                            cd.com(#do 'actualArg:UnitOne?:'-> TT; 
                                     actualArg.dopt-> TT #)
                        if)
                     else (* not NonBasicValueobj or not data-item *)
                        (if true     
                         // (this(Pattern).primNo = vEq_prim)
			 // (this(Pattern).primNo = vLE_prim) then
                            cd.com(#do 'vEq:'->TT; #);
                         else (* this pattern is not assignment *)
                            cd.com(#do 'formalArg:isPtn:' -> TT; 
                                     formalArg.doPT->TQ; 
                                     ':isBasicVal:'->TT; 
                                     formalArg.isBasicValue -> BB;
                                     ':valueObj:' -> TT; 
                                     formalArg.OG.isValueObj -> BB; nl;
                                     ':actArg:' ->  TT; 
                                     actualArg.dopt -> TQ;
                                     ':isBasicVal:' -> TT; 
                                     actualArg.isBasicValue -> BB 
                                  #);
                            (if formalArg.OG.isNonBasicValueObj 
                                and actualArg.isBasicValue then
                                (* in formalArg: var aValueObj 
                                 * actualArg is float or int bar(15"m") 
                                 * formalArg is a unit 
                                 * - tested by semchecker
                                 *)
                                cd.com
                                (#
                                do 'case:A:'->TT; actualArg.dopt->Tq;
                                   'form:isNonBasicValueObj:'->TT;
                                   formalArg.OG.isNonBasicValueObj ->BB;
                                   'act:isBasicValue:'->TT;
                                   actualArg.isBasicValue ->BB;
                                #);
                                (if actualArg.isInteger then cd.I2F if);
                                1 -> cd.pushConst
                             else
                                cd.com(#do 'case:B:'->TT; actualArg.dopt->TT;
                                         actualArg.label -> TT;
                                         formalArg.OG.primNo -> II;
                                         actualArg.primno->II;
                                         (actualArg.desc).encOG.primNo -> II;
                                         formalArg.OG.isNonBasicValueObj ->BB;
                                         actualArg.isValueObj ->BB
                                      #);
                                (if not actualArg.int2floatDone then
                                    formalArg[] 
                                      -> actualArg.checkNumberConvert
                                    (# I2F:: (#do cd.I2f #);
                                       F2I:: (# do cd.F2I #);
                                #)if);
                                (if formalArg.OG.isNonBasicValueObj 
                                    and not actualArg.isValueObj 
                                    then
                                    (* actualArg must be a pattern 
                                     * returning a value *)
                                    (*44 -> cd.pushConst;*)
                                    (if stringAsVal
                                        and ((actualArg.desc).encOG.primNo
                                        = String_prim) then
                                        cd.com(#do 'string:'->TT; 
                                                  formalArg.dopt-> TT #);
                                     else
                                        formalArg.objSize -> cd.pushValue;
                                        1 -> cd.pushConst
                                    if)
                                 else
                                    (formalArg.OG.super.ATD.asDecl).OG[] 
                                      -> superOG[];
                                    (if superOG.primNo 
                                     // indexed_prim
                                     // rIndexed_prim then
                                        superOG[] -> objTmpStack.add;
                                        cd.com(#do 'formalArg is indexed:'->TT;
                                                 formalArg.dopt -> TT; ' ' ->TT;
                                                 superOG.IS.newDescNo ->II; nl;
                                                 actualArg.dopt -> TT; ' '->TT;
                                                 actualArg.label -> TT;
                                              #);
                                        cd.com(#
                                              do superOG.IS.newDescNo ->II;
                                                 formalArg.OG.super.ATd.dopt->TT
                                              #);
                                        (if actualArg.bracketedListLength > 0 
                                            then
                                            actualArg.bracketedListLength 
                                              -> cd.pushConst;
                                            (if superOG.IS.primNo
                                                =  rIndexed_prim then
                                                superOG.IS.newDescNo 
                                                  -> cd.mkRindexed
                                             else
                                                superOG.IS.newDescNo 
                                                  -> cd.mkVindexed
                    if)if)if)if)if)if)if);
                    cd.com(#do 'end:loadArgs:NonVirt:' -> TT; E.dopt -> TQ #);
                 #);
               actArgs: [6] ^ObjectSpecification; (* actual arguments *)
               top,argInx: @integer;
               enclosingOG: ^ObjectGenerator;
            do (* loadArgs is followed by invoke.
                * There are different invoke patterns for assignment,
                * general patterns, ...
                * Perhaps we should also have different loadArgs for 
                * assignment, general patterns, ...
               *)
               (if OG.primNo 
                   (* Some of these are handled in invoke below
                    * May be moved to here*)
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   (* skip *)
                else 
                   E.args.scanArgs
                   (#
                   do (if (top+1 -> top) > actArgs.range then 
                          actArgs.range -> actArgs.extend 
                      if);
                      current[] -> actArgs[top][];
                   #);
                   (if OG.primNo = resume_prim then
                       cd.com(#do 'resume: ' -> TT; E.dopt -> TT; ' '->TT;
                                E.father.dopt -> TT#);
                   if);
                   scanArgs
                   (#
                   do argInx + 1 -> argInx; 
                      (if argInx <= top then
                          (* can we do currentArg.LoadArg?
                           * And then perhaps special for virtual primitive
                           * and ptName? Virt is of course ptn *)
                          (if currentArg.isVirtual then
                              (* (currentArg[],actArgs[argInx][]) 
                               * -> handleVirtualArg
                               * See handleVargs instead
                               *)
                           else 
                              (currentArg[],actArgs[argInx][]) 
                                -> handleNonVirtualArg
                          if)
                          (*else: E is a super as foo in foo{...} *)
                   if)#);
                   handleSuperArgs:
                     (if (argInx < top) and (OG.primNo <> resume_prim) then
                         '\n!!!! pattern:loadArgs:argInx<top:'
                           -> putline;
                         dopt -> putline;
                         (* a hack - need to scan arguments of super *)
                         argInx + 1 -> argInx;
                         (true,superAdj,staticOff) -> actArgs[argInx].gen;
                         restart handleSuperargs
               if)if);
            #);
          load::
            (#
            do cd.com
               (#do 'Pattern:load:???'->TT;OG.primNo->II; ' '->TT; dopt->TT #)
            #);
          getAdr::
            (# B: @boolean
            do cd.com(#do A.print -> TT #);
               (if isPrimitive then
                   true -> loadRec;
                else
                   true -> loadRec;
                   true -> A.isAdr
               if);
            #);
          invoke:: 
            (# 
            do cd.com(#do 'ptn:invoke:' -> TT; sig.dopt -> TQ;
                        'E:'->TT; E.dopt -> TQ;
                        'useRtnV:' -> TT; useRtnVal -> BB#);
               (if false then
                   '**** ptn:invoke: ' -> puttext; PtnKind -> putint;
                   ' ' -> put;
                   dopt -> putheadN;
                   E.father.father.father.dopt -> putheadN;
               if);
               (rec[],E[],useRtnVal,staticOff,adr[]) 
                 -> currentPtnKind.invoke 
            #);
          popReturn:
            (* perhaps this should be the same virtual as in dataItem!?
             * And do consider signature:popReturn
             *)
            (# D: ^Decl
            do (if (getReturnDecl -> D[]) <> none then
                   D.popReturn
                else 
                   cd.rpop
               if)
            #);
          store::
            (#
            do 'Pattern:store: '->puttext; doPT -> putline;
            #);
          clear::< (# do false -> genIsDone; inner #);
          genIsDone: @boolean;
       #);
     Address: superAdr
       (* E = first exp in "R.S.Q", ie. E = "R" *)
       (# nameOfE_OG:
            (# D: ^Decl; org: ^Items
            do (if E[] <> none then
                   E.ATd.asDecl -> D[];
                   E.origin[]->org[]; 
                   (for i: E.on repeat org.origin[] -> org[] for);
                   org.encOG.OGidWdNo -> T[];
                else
                   'EisNone' -> T[]
               if)
            exit T[]
            #);
          done: @boolean; T: ^text;
          load:: (* actually push value *)
            (#
            do (if isAdr then
                   loadAdr
                else
                   (if off > 0 then
                       cd.com(#do 'load:'->TT; this(Address).print -> TT #);
                       (if isValue then
                           (if originIsValue then
                               (if isFloat then
                                   ('',off) -> cd.fovpushg
                                else
                                   ('',off) -> cd.ovpushg
                               if)
                            else
                               cd.com(#do 'isFloat:B: '->TT; isFloat->BB #);
                               (if isFloat then
                                   ('',off) -> cd.fpushg
                                else
                                   '' -> T[];
                                   (if rec[] <> none then 
                                       rec.dopt -> T.append if);
                                   '/'-> T.put;
                                   (if E[] <>none then E.dopt->T.append if);
                                   (* problem here!*)
                                   (nameOfE_OG,off) -> cd.pushg;
                                   cd.com(#do 'BOBS!'->TT #)
                               if)
                           if)
                        else
                           (if isUnique then
                               cd.com(#do 'address:load:isUnique' -> TT #);
                               cd.rdouble;
                               ('',off) -> cd.rpushg;
                               cd.rswap;
                               cd.pushNone;
                               cd.rswap;
                               ('kuk',off) -> cd.rstoreg
                            else
                               '' -> T[];
                               (if rec[] <> none then rec.dopt -> T.append if);
                               '/'-> T.put;
                               (if E[] <> none then E.dopt -> T.append if);
                               (nameOfE_OG,off) -> cd.rpushg
                           if)
                       if)
                    else
                       '**** Address:load:off = 0 ' -> puttext; 
                       (if E[] <> none then E.dopt -> putline else newline if);
               if)if)
            #);
          loadAdr::
            (#    
            do cd.com
               (#do 'Address:loadAdr:'->TT; this(Address).print->TT 
               #);
               (if off > 0 then
                   (if isValue then
                       (if isUnitVal and not isCompositeValueObj then
                           (* isUnitVal should be enough, but is not!? *)
                           ('',off) -> cd.fpushg
                        else
                           (if originIsValue then
                               cd.swap;
                               off - 1 -> cd.pushConst;
                               61 (*plus*) -> cd.op;
                               cd.swap
                            else
                               off -> cd.pushConst;
                               valDescNo -> cd.pushConst
                       if)if)
                    else
                       (nameOfE_OG,off) -> cd.rpushg
                   if)
                else
                   '**** Address:loadAdr:off = 0 ' -> puttext; 
                   (if E[] <> none then E.dopt -> putline else newline if);
               if)
            #);
          store::
            (# mode: @integer
            do (if not done then
                   true -> done;
                   cd.com(#do 'store:'->TT; this(address).print->TT #);
                   (if off > 0 then
                       cd.com
                       (#
                       do 'isValue:' -> TT; isValue -> BB; 
                          ' isAdr:' -> TT; isAdr -> BB;
                          ' descNo: ' -> TT; descNo -> II;
                       #);
                       (if isValue then
                           (if isAdr then
                               (if descNo > 0 then
                                   (if stringAsVal
                                       and ((E.Atd.asDecl).OG.primNo = String_prim)
                                       then
                                       cd.rswap;
                                       (nameOfE_OG,off) -> cd.rstoreg
                                    else
                                       cd.vpop;
                                       cd.saveAndSetThis;
                                       (*(failureTrace,'koks') -> stop;*)
                                       (* quite complex 1st arg, 
                                        * ex: E = P, where
                                        * P: var Point(0,0)
                                        * E.ATd.OG.super.last = Point(0,0) = X
                                        * X.ATd.OG = Point descriptor
                                        *)
                                       ((((E.ATd.asDecl).OG.super.last).ATd.asDecl).OG.OGid
                                       ,descNo,off - 1) 
                                         -> cd.invokeVal;
                                       cd.restoreThis
                                   if)
                                else
                                   (if stringAsVal
                                       and ((E.Atd.asDecl).OG.primNo = String_prim)
                                       then
                                       cd.rswap;
                                       (nameOfE_OG,off) -> cd.rstoreg
                                    else
                                       (* (if srcIsVal then 1 -> mode if);
                                        * (if destIsVal then mode + 2 -> mode if);*)
                                       (if originIsValue then 1 -> mode if);
                                       cd.com(#do 'Address:store::srcIsVal:'->TT; 
                                                srcIsVal -> BB;
                                                ' destIsVal:'->TT;originIsValue->BB;
                                                ' mode:' -> TT; mode -> II #);
                                       off -> cd.pushConst;
                                       (size,mode) -> cd.vassign
                                   if)
                               if)
                            else
                               (if originIsValue then
                                   cd.com(#do 'Address:store:originIsValue:'->TT #);
                                   (if isFloat then
                                       ('',off) -> cd.fovstoreg
                                    else
                                       ('',off) -> cd.ovstoreg
                                   if)
                                else
                                   cd.com(#do 'isFloat:D: '->TT; isFloat->BB #);
                                   (if isUnitVal or isFloat then
                                       ('address:storeg',off) -> cd.fstoreg
                                    else
                                       (nameOfE_OG,off) -> cd.storeg
                                   if);
                           if)if)
                        else
                           (*(if isAdr then loadAdr if);*)
                           cd.rswap;
                           (nameOfE_OG,off) -> cd.rstoreg
                       if)
                   if)
                else
                   '**** Address:store:off = 0 ' -> puttext; 
                   (if E[] <> none then E.dopt -> putline else newline if);    
               if)
            #);
          print::
            (# 
            do ':Adr:'-> T.append; 
               'off:'-> T.puttext; off -> T.putint;
               ' size:'-> T.puttext; size -> T.putint;
               ' isFloat:' -> T.puttext; 
               (if isFloat then 'T'->T.putText else 'F'->T.puttext if);
               ' isUnitVal:'->T.puttext; 
               (if isUnitVal then 'T'-> T.puttext else 'F'->T.puttext if);
               ' superAdj:'->T.puttext; superAdj->T.putint;
               ' isUnique:'->T.puttext; 
               (if isUnique then 'T'->T.putText else 'F'->T.puttext if);
               ' isValue:' -> T.puttext; 
               (if isValue then 'T'-> T.puttext else 'F'->T.puttext if);
               ' originIsValue:' -> T.puttext; 
               (if originIsValue then 'T'-> T.puttext
                else 'F'->T.puttext if);
               ':E:"'->T.puttext;
               (if E[] = none then 'none"'->T.puttext
                else
                   E.dopt -> T.puttext; '"' -> T.put
               if);
               ':rec:'->T.puttext;
               (if rec[] = none then '-'->T.put else rec.dopt->T.puttext if);
            #);
       enter superAdj
       exit this(Address)[]
       #);
     checkInt2IntWithUnitArg: booleanValue
       (# rec,E: ^Exp; OGx: ^ObjectGenerator
       enter(rec[],E[])
       do (if (rec[] <> none) and (E.args[] <> none)  then
              cd.com(#do 'checkInt2IntWithUnitArg'->TT #);
              E.args.scanArgs(#do current[]->OGx[] #);
              (if (OGx[] <> none) and OGx.IS.isEmpty then
                  (if true
                   // OGx.super.ATd[] = integerDecl then
                      cd.com(#do 'arg:integer'->TT #)
                   // OGx.super.ATd[] = floatDecl then
                      cd.com(#do 'arg:float'->TT #)
                   // OGx.super.ATd.OG.isUnitValueObj then
                      cd.com(#do 'arg:unit'-> TT #);
                      (if true
                       // rec.ATd[] = integerDecl then
                          cd.com(#do rec.dopt->TQ; E.dopt -> TQ #);
                          cd.com(#do 'rec:isInteger'->TT #);
                          true -> value
                       // rec.ATd[] = floatDecl then
                          cd.com(#do 'rec:isFloat'->TT #)
                      if)
                   else
                      cd.com(#do 'arg:other'-> TT #)
          if)if)if)
       #);
     Invocation::
       (* E1.E2.E3
        *    E1.pushThis
        *    E1.on -> gorigin
        *    E1.pushOff
        *    E2.pushOff
        *    E3.invoke
        * R.foo
        * R.foo{...}
        * X:= y + 12
        * R ++ E  -- problem E1 = R ++ E , i.e. first = true 
        * perhaps same problem for keyWord
        * We must reconsider parsing/AST and/or gen below
        *)
       (# checkOrigins:
            (* m1: var Length.Meter
             * m1.print
             * path(m1) o path(Length) o nest(Meter)
             * origins(print) = origins(Length) O nest(Meter)
             * print.origin = Meter, Meter.origin = Length
             * P: var R1.R2.R3.PPP
             * P.msg
             * P isA PPP
             * PPP.origin = R3.ATd, R3.origin = R2.origin, R2.origin = R1.ATd
             * X: var TTT
             * X.foo
             * X isA TTT
             * TTT.origin = encloser(TTT)
             *)
            (# emitCode,hasValueObj: @boolean; T: ^Text;
               getMax:
                 (# E: ^Exp; m: @integer; ISx: ^Items
                 enter E[]
                 do E.ATd.OG.IS.maxOn -> m;
                    E.ATd.OG.IS[] -> ISx[];
                    L:
                      (if ISx.superDesc[] <> none then
                          ISx.superDesc[] -> ISx[];
                          (if ISx.maxOn > m then ISx.maxOn -> m if);
                          restart L
                      if)
                 exit m
                 #)
            enter emitCode
            do 'Start: '->T[]; dopt->T.putline;
               scanSons
               (# E: ^Exp; org: ^Scope
               do current[] -> E[];
                  (if true
                   // isFirst then
                      'first: '->T.puttext; E.doPT -> T.putline;
                      (E[],emitCode) -> declOrigin -> (hasValueObj,T.puttext)
                   // isLast then
                      'last: "' -> T.puttext; E.dopt -> T.puttext;
                      (if E.ATd.isPattern  then
                          '" isPattern maxOn: '->T.puttext;
                          E[] -> getMax -> T.putint; T.newline;
                          E.ATd.dopt -> T.puttext
                      if);
                   else
                      'nest: ' -> T.puttext; E.dopt -> T.putline;
                      (if emitCode then
                          cd.com(#do 'pushOff'->TT; E.ATd.newOff -> II #)
                      if)
                  if)
               #)
            exit(hasValueObj,T[])
            #);
          declOrigin:
            (* m1: var Length.Meter
             * m2: obj T{ ... }
             *)
            (# E: ^Exp; emitCode: @ Boolean;
               OG: ^ObjectGenerator; hasValueObj: @boolean; T: @Text;
            enter(E[],emitCode)
            do 'declOrigin: ' -> T.puttext;
               E.ATd.OG[] -> OG[]; OG.OGid->T.putline;
               (if emitCode then
                   cd.fcom(#do 'pushThis'->TT #);
                   cd.fcom(#do 'goOrigin'->TT; E.on -> II #);
                   cd.fcom(#do 'pushOff'->TT; E.ATd.newOff -> II #);
               if);
               (if OG.IS.isEmpty then
                   OG.super.scanSons
                   (# E: ^Exp
                   do current[] -> E[];
                      (if isFirst then
                          'origin:first: "'->T.puttext; E.dopt->T.puttext;
                          (if emitCode then
                              cd.fcom(#do 'goOrigin'->TT; E.on -> II;  #);
                              cd.rdouble;
                              0->E.loadOrigin;
                              cd.fcom(#do 'pushOff'->TT; E.ATd.newOff -> II #);
                              (E.dopt,E.ATd.newOff) -> cd.rpushg
                          if)
                       else
                          'origin:next: "'->T.puttext; E.dopt->T.puttext;
                          (if not isLast and emitCode then
                              cd.fcom(#do 'pushOff'->TT; E.ATd.newOff -> II #);
                      if)if);
                      (if E.ATd.OG.isValueObj and not E.ATd.OG.isBasicValue then
                          '" isValueObj:true ' -> T.putline;
                          true -> hasValueObj
                       else
                          '" isValueObj:false ' -> T.putline
                   if)#)
                else
                   'singular: ' -> T.putline; 
               if)
            exit(hasValueObj,T[])
            #);
          findOrigins:
            (# hasValueObj: @boolean; T,S: ^Text; org: ^Scope; orgx: ^Items;
               E: ^Exp
            enter E[]
            do '**   FO: ' -> T[]; E.dopt->T.putline;         
               (if '???'->(E.label).equal then
                   leave findOrigins 
               if);
               (if E.ATd.OG.isValueObj then
                   ' this:true'->T.putline
                else
                   ' this:false'->T.putline
               if);
               (if E.on > 0 then
                   '**** findOrigins: '->T.puttext; E.dopt -> T.puttext;
                   ' on: '->T.puttext; on -> T.putint; 
                   T.newline;
                   E.origin[] -> org[];
                   (if org[] <> none then
                   L:
                     (for i: E.on + 1 repeat
                          org.encOG.OGid -> T.puttext; 
                          (if org.encOG.isValueObj then 
                              ' True '-> T.puttext; 
                              true -> hasValueObj
                           else
                              ' False '->T.puttext
                          if);
                          (if org.isItems then
                              (org[]->orgx[]).newOriginOff->T.putint; T.newline;
                          if);
                          (if (org.origin[] -> org[]) = none then
                              leave L
                          if)
                   for)if);
                else
                   '**** local: '->T.puttext; E.dopt->T.putline;
                   (if E.ATd.OG.super[] <> none then
                       E.Atd.OG.super.checkOrigins -> (hasValueObj,S[]);
                       S[] -> T.append;
                    else
                       'none'->T.putline
                   if)
               if);
            exit(hasValueObj,T[])
            #);
          checkOriginsII:
            (# T: @Text
            do (* M1.print(17) *)
               scanSons
               (# E: ^Exp
               do current[] -> E[];
                  (if not isLast then
                      E.doPT -> T.append; 
                      ':'->T.put; 
                      E[] -> getOrigin -> T.append
                   else
                      'last:' -> T.append; E.dopt -> T.append
                  if);
               #) 
            exit T[]
            #);
          getOrigin:
            (* M: var Length.Meter
             * M.print(17)
             *)
            (# E: ^Exp; OGx: ^ObjectGenerator; T: @Text
            enter E[]
            do (* E = M1 *)
               E.ATd.OG[] -> OGx[]; (* OGx = Length.Meter *)
               
               (if OGx.IS.isEmpty then                   
                   OGx.super.scanSons
                   (#
                   do current[] -> E[];
                      ';'->T.put; 
                      (if not isLast then
                          E.dopt -> T.append;
                       else
                          'last;' -> T.append; E.dopt -> T.append 
                      if);
                      (if E.ATd.OG.isValueObj and not E.ATd.OG.isBasicValue then
                          ';isValueObj ' -> T.putline;
                          (* no proxy here
                           * cd.fcom
                           * (#do 'CreateProxyQ:'->TT; E.ATd.sig.dopt->TQ#);
                           *)
                      if)
                   #)
                else
                   ';singular;'->T.append; 
                   OGx.OGid -> T.append
               if);
            exit T[]
            #);
          gen:: 
            (# gdb:: 
                 (# 
                 do '>useRtnV:'->TT; useRtnVal -> BB;
                    scanSons
                    (# ptn: ^Pattern; OI: ^ObjectInvocation
                    do (if (current## = ObjectInvocation##)
                           and 
                           ((current[] -> OI[]).ATD## = pattern##) then
                           OI.ATd[] -> ptn[];
                           ' descNo: ' -> TT; ptn.OG.IS.newDescNo -> II;
                    if)#)                                         
                 #);
               rec,E: ^Exp; T: ^Text;
               IVinx,IVlength: @integer; noOrigin: @boolean;
               needOrigin: 
                 (# IT: ^Items; Ex: ^Exp; value,originIsValueObj: @Boolean
                 do true -> value;
                    cd.com(#do 'needorigin:'-> TT; dopt -> TQ #);
                    scanSons
                    (#
                    do IVlength + 1 -> IVlength;
                       current[] -> E[]; 
                       (if (E.ATd.asDecl).isPattern and not E.isConstLiteral 
                           and (Ex[] = none) then 
                           E[] -> Ex[];
                           IVlength -> IVinx
                       if);
                       (* if-stmt below is superflouos?
                        * not clear why superflouos!? And what goes non here?
                        *)
                       (if not isLast then E[] -> rec[] 
                        else
                           (if isFirst then 
                               E[] -> rec[] -> Ex[];
                               IVlength -> IVinx
                    if)if)#);
                    cd.com(#do 'needOrigin:E:'->TT; E.dopt -> TQ;
                             ' E.ATd:'-> TT; E.ATd.dopt -> TQ #);

                    (if not (E.ATd.asDecl).isPattern then (* DataItem *)
                        cd.com(#do 'needOrigin:dataItem:leave'->TT #);
                        leave needOrigin
                    if);
                    (if Ex[] = none then
                        'needOrigin: Ex is none: ' -> puttext; dopt -> putline;
                        leave needOrigin
                    if);
                    Ex[] -> E[];
                    Ex.ATd.desc -> IT[]; 
                    (if IT.globalRestrictionsInMain and not IT.inVirtualPtn then
                        (* Check if globalRestrictionsInMain cover only
                         *    %globals
                         * or also %globals P1,P2,P3
                         * If the latter is covered, this check is not correct
                         *)
                        cd.com(#do 'Ex:loadOrign:no:loadOrigin: ' -> TT;
                                 IT.encOG.doPT -> TQ #);
                        (if value and false then
                            '!!! needOrigin:conflict:A: ' -> puttext; 
                            dopt -> puttext;
                            ' E: ' -> puttext; E.dopt -> puttext;
                            ' Ex: ' -> puttext; Ex.dopt -> putline
                        if);
                        false -> value;
                     else
                        (if not value then
                            '!!! needOrigin:conflict:B: ' -> puttext; 
                            dopt -> puttext;
                            ' E: ' -> puttext; E.dopt -> puttext;
                            ' Ex: ' -> puttext; Ex.dopt -> putline
                        if); 
                        cd.fcom(#do 'doNeedOrigin:Ex:'->TT; Ex.dopt -> TQ #);
                        (# org: ^Items
                        do (if (IT.origin[]->org[]).encOG.isValueObj
                               and not org.isPrimitive
                               -> originIsValueObj then
                               cd.fcom(#do 'origin:isValueObj:'->TT;
                                         (IT.origin[]->org[]).encOG.OGid -> TQ 
                                      #)
                        if)#)
                    if);
                    not value -> noOrigin
                 exit(value,originIsValueObj)
                 #);
               handleBracketedExp:
                 (# done: @boolean
                 do scanSons
                    (# BE: ^BracketedExp
                    do (if 'BracketedExp' -> (current.label).equalNCS then
                           current[] -> BE[];
                           (if BE.noOfSons > 1 then
                               cd.com(#do 'bracketedExp:' -> TT; dopt -> TQ;
                                        'noOfSons:'->TT; BE.noOfSons -> II;
                                        'useRTNV:' -> TT; useRtnVal -> BB;
                                     #);
                               (useRtnVal,superAdj,staticOff) -> BE.gen;
                               true -> done;
                    if)if)#)
                 exit done
                 #);
               done,hasValueObj: @boolean; T1: ^Text
            do (* for P1.X := P2.Y,
                * we need no origin for P1 (and X!?)
                * we need adress of P1 to be added address of X to get embedded
                * adr of X
                * In R.foo, if foo has globalRestrictions we shall not 
                * load adr of R
                * How about: R.S.T.Q ? Q globalRestrictions, or globals?
                *)
               cd.bcPos -> beginBCP;
               cd.com(#do 'Invocation:gen:superAdj: '->TT; superAdj->II #);
               (* We should rewrite computeAdr to include handling
                * of constants, patterns with no origin and bracketedExp
                *)
               (if false then
                   'Head:'->T[]; dopt->T.putline;
                   false -> checkOrigins -> (hasValueObj,T.puttext);
                   (if hasValueObj then
                       (*'---'->putline; T[] -> putline;;*)
                       '=====' -> putline;
                       checkOriginsII -> T1[] -> putline;
               if)if);
               handleBracketedExp -> done;
               (if not done then isConstant -> done if);
               (if not done then
                   (# A: ^Address; off,argNo: @integer; 
                      doNeedOrigin,originIsValueObj: @boolean
               do needOrigin -> (doNeedOrigin,originIsValueObj);
                  (if doNeedOrigin then
                      superAdj -> computeAdr -> (rec[],E[],A[]);
                  if);
                      (if withValueProxy and originIsValueObj (*hasValueObj*) 
                          and (E.ATd.asDecl).isPattern then
                      (* shall only happen if E is a pattern *)
                      (* cd.fcom(#do 'hasValueObj:'->TT;  T[]->TL #);*)
                      (* true -> checkOrigins;*)
                      (* cd.fcom(#do 'COII:'->TT; T1[]->TL #);*)
                      (* Actually only generate proxy if E.origin isValueObj
                       * Perhaps needOrigin should return 
                       * 1. Standard origin is needed
                       * 2. No origin is needed
                       * 3. Origin isValueObj
                       * Create a proxy object for valueObj
                       * with ref to embedded obj - on stack
                       * wih origin as origin of valueObj
                       * must be computed
                       *)
                      (# org: ^Items; Ex: ^Exp; loadRec: @Boolean; A: ^Address
                      do cd.fcom(#do 'CreateProxyW:'->TT; 
                                   (E.ATd.origin[]->org[]).encOG.OGid -> TQ;
                                   (org.origin[] -> org[]).encOG.OGid -> TQ;
                                   dopt -> TQ
                                #);
                         cd.rdouble;
                         scansons(# 
                                 do (if not isLast then current[]->Ex[] if) #);
                         (if Ex[] <> none then
                             cd.fcom(#do Ex.dopt -> TQ;
                                       Ex.ATd.OG.super.doPT -> TQ
                                    #);
                             Ex.ATd.OG.super.scanSons
                             (# Ey: ^Exp
                             do current[] -> Ey[];
                                (if isFirst then
                                    cd.fcom(#do 'first:'->TT; Ey.dopt -> TQ #);
                                    Ey.loadOrigin;
                                    &Address[] -> Ey.getAdr -> (loadRec,A[]);
                                    A.loadAdr;
                                    (85,3) -> cd.mkValueProxy
                                 else
                                    cd.fcom(#do 'next:'->TT; Ey.dopt -> TQ #)
                                if);
                                cd.fcom(#do 'createValueProxy:'->TT #);
                             #)
                         if)
                  #)if);
                  cd.com(#do 'IV:after:computeAdr:superAdj:'->TT; superAdj->II;
                           (if A[] <>  none then A.print->TT if); nl;
                           'rec: '->TT; rec.dopt->TQ; 'E: '->TT; E.dopt->TQ;
                        #);
                  (* case bar(L1) where L1 is a unit
                   * we should not push L2.magnitude
                   * but push L1 as a valueObj
                   * For E = bar(L1), the load of L1 happens in E.loadArgs 
                   * For X := exp and foo(exp), E.loadArgs load exp
                   * E.invoke generates assigment for := and invocation for foo
                   *)
                  cd.com(#do 'INV:gen:E.loadArgs'->TT; E.dopt->TQ #);
                  (superAdj,off) -> E.loadArgs; (* only if E is pattern *)
                  (if noOrigin and (IVinx < IVlength) then
                      (* we come here if E does not need an origin
                       * For IV = I1.I2.,,,.In, E  = Ej, j = IVinx, n = IVlength
                       * IVinx and IVlength set by needOrigin
                       *)
                      (* We do come here! *)
                      (rec[],E[],true,staticOff,A[],false) -> E.invoke;
                      (* The code below is only relevant 
                       * if E does not need an origin.
                       * We then have to call invoke for Ej+1,...,En
                       * But what if som Ek, j+1 <= k has no origin?
                       *)
                      scanSons
                      (# found: @boolean; Ey: ^Exp;
                      do (if found then
                             cd.com(#do 'IV:gen:checkTail:'->TT; dopt -> TQ;
                                      'E:'->TT; E.doPT -> TQ;
                                      'tail:' -> TT; current.dopt -> TQ;
                                       ' not isLast:' -> TT; not isLast -> BB;
                                    #);
                             (superAdj,off) -> (current[]->Ey[]).loadArgs;
                             (* In a previous version, 'not isLast' was used
                              * as the value of the useRtnVal parameter,
                              * but this did not work for expressions like
                              * (":" + I2S(N) + "\n").print
                              * However, there may have been a reason for using
                              * 'not isLast'!?
                              *)
                             (E[],current[],useRtnVal,staticOff,A[],false)
                               -> Ey.invoke;
                         if);
                         (if current[] = E[] then true -> found if);
                      #);
                   else
                      cd.com(#do 'IV:E.invoke:useRtnVal:' -> TT; 
                               useRtnVal -> BB; 'E:' -> TT; E.dopt -> TQ;
                            #);
                      (rec[],E[],useRtnVal,staticOff,A[],false) -> E.invoke;
               if)#)if);
               cd.bcPos -> endBCP
            #);
          isConstant: BooleanValue
            (* Not good enough for 
             * V: obj 12; W: obj 87; X: obj V + W;
             * we dont push 12 for V, but 87 for W
             *)
            (# T: @text
            do cd.com(#do 'isConstant:'->TT; label->TQ; dopt->TQ #);
               L:
                 scanSons
                 (# E: ^Exp; DI: ^SuperDataItem
                 do current[] -> E[];
                    (if (E.ATd.asDecl).isDataItem (*or E.ATd.isModuleItem*) then
                        E.ATd.asDecl -> DI[];
                        (if DI.isConst then
                            (if isLast then
                                (if DI.OG.isBasicValue then
                                    (if (DI.OG.super.last->E[]).isConstLiteral then
                                        DI.OG.super.dopt -> T.puttext;
                                        cd.com
                                        (#
                                        do 'const literal: ' -> TT;
                                           T[] -> TT;
                                           ' ' -> TT;
                                           (DI.OG.super.last).label -> TT
                                        #);
                                        T.setPos; 
                                        T.getInt -> cd.pushConst;
                                        true -> value
                                    if)
                                 else
                                    leave L
                            if)if)
                         else
                            cd.com(#do 'notConst:'->TT;E.dopt->TT;DI.dopt->TT#);
                            leave L
                        if)
                     else
                        leave L
                 if)#)
            #);
          computeAdr:
            (* R.S.foo(exp).Q
             * X := Y + (Z +117)
             * aLine.aPoint.X
             * (4) @if ascii.isLetter(ch1) || ascii.isDigit(ch2) :then ...
             *)
            (# A,recA: ^Address; E,rec,pRec: ^Exp; j: @integer; 
               loadRec,orgIsVal: @boolean; ptn: ^Pattern;
               superAdj: @integer;
            enter superAdj
            do cd.com(#do 'computeAdr:superAdj:'->TT; superAdj->II; dopt->TQ #);
               superAdj -> Address -> A[];
               (* for (4) above, A.superAdj may be non-zero when computing 
                * address of ascii.isLetter(ch1) || ascii.isDigit(ch2)
                * We must thus save A.superAdj to be used when calling 
                * rec.loadArgs below to load ch1.
                * If || ascii.isDigit(ch2) is not present, loadArgs is not 
                * called here but in IV:gen
                *)
               scanSons
               (# org: ^Items
               do rec[] -> pRec[]; E[] -> rec[]; current[] -> E[];
                  cd.com
                  (#do 'computeAdr:'->TT; j+1->j->II; ':rec:'->TT; 
                     (if rec[]<> none then rec.dopt->TQ else 'none'->TQ if);
                     ' E:'->TT; E.dopt -> TQ;  
                     (if A.E[] <> none then ' A.E:' -> TT; A.E.dopt->TQ if);
                     nl; A.print -> TT;
                  #);
                  (if isFirst then
                      E[] -> rec[];
                      E.pushThis; (* why E? we should pushThis for thisObj!
                                   * So just cd.pushThis? TST fails if 
                                   * cd.pushThis
                                   *)
                      (if (E.ATd.asDecl).isPattern 
                          and (origin->org[]).encOG.isValueObj then  
                          (* origin is a value object;
                           * E is a pattern invoked in the mainpart
                           * of the value object;
                           * we thus must push an extended origin for E
                           * with holder ref, offset to value obj and
                           * descNo of the actual value pattern.
                           * The offset must be 1 (one) since the bytecodes
                           * pushg, etc adds the offset stored in 
                           * thisObj = holder
                           * We do not know the descNo of the value pattern
                           * here, since the actual value pattern may
                           * be a subpatttern of the one we are generating
                           * code for here.
                           * The actual descNo is saved by a subsequent 
                           * invokeVal and pushed by a possible invoke
                           * or sendv
                           *)
                          cd.com
                          (#do 'computeAdr:orgIsValue:'->TT; E.dopt->TQ; 
                             E.label->TQ; E.ATd.primNo->II#);
                          (if (E.ATd.asDecl).primNo
                           // string_prim // inner_prim then
                           else
                              (* Perhaps virtual E.pushValId is better? *)
                              cd.pushValId;
                              (* push const 1 & thisValObjDescInx *)
                      if)if);
                      A.superAdj -> E.loadOrigin -> (rec[],E[],orgIsVal);
                      (* we should ignore rec and E - defined above 
                       * And A.superAdj should be eliminated *)
                      inner computeAdr;
                      (* start of problem *)
                      A[] -> E.getAdr -> (loadRec,A[]);
                      (* really getOffSet of E.ATd *)
                      cd.com(#do 'E.on:' -> TT; E.on -> II #);
                      (if (E.on > 0) or (A.superadj > 0) then
                          cd.com(#do 'beforeIsValueObj:E:'->TT; E.dopt->TQ;
                                   ' ATd:'->TT; E.ATd.dopt -> TQ;
                                #);
                          ((E.ATd.asDecl).enclosingObjectGenerator).isValueObj 
                            -> A.originIsValue
                          (* should probably be for each receiver in
                           * R.S.foo(exp).Q, i.e. R, S and foo
                           *)
                      if);
                      cd.com(#do 'computeAdr:isFirst:' -> TT; A.print->TT #)
                   else
                      (* mutex.cmpAndSwap 
                       * rec = mutex, cmpAndSwap = E
                       *)
                      A[] -> recA[] -> E.getAdr -> (loadRec,A[]);
                      (* really getOffSet of E.ATd *)
                      (if (E.ATd.asDecl).isPattern then
                          E.ATd.asDecl -> ptn[];
                          cd.com(#do 'ptn.isUnitValueObj:'->TT; 
                                   ptn.OG.isUnitValueObj -> BB;
                                   ' isFloat:E:' -> TT; 
                                   ptn.OG.isFloat -> BB #);
                          (if ptn.OG.isUnitValueObj 
                              or ptn.OG.isFloat then
                              (# UN: ^NewProperty
                              do ptn.OG.getUnitProp -> UN[];
                                 (if (UN[] <> none) 
                                     and 
                                     ('%unit "U*U"' -> (UN.doPT).equal)
                                     then
                                     cd.com
                                     (#
                                     do 'Generic:unit:' -> TT;
                                        UN.dopt -> TT; nl;
                                        'ptn: ' -> TT; ptn.dopt -> TQ; 
                                     #);
                                     false -> A.isUnitVal    
                              if)#)
                           else
                              false -> A.isUnitVal 
                      if)if);
                      (if loadRec then
                          (* In R.foo, rec = R, E = foo
                           *    P.print, rec = P, E = print
                           *    R.S,      rec = R, E = S
                           * E is a pattern or dataItem 
                           * For ascii.isLetter(ch1) 
                           * || ascii.isDigit(ch2)
                           * see comment at the beginning of computeAdr
                           *)
                          (superAdj,0) -> rec.loadArgs;
                          (* Perhaps a combined invoke & getAdr *)
                          (* A is the address of E - not of rec!!!!!! *)
                          (pRec[],E[],true,0,recA[],false) -> rec.invoke;
                          (if (pRec[],E[]) -> checkInt2IntWithUnitArg then
                              cd.I2F
                  if)if)if);
                  (if isLast then
                      cd.com(#do 'computeAdr:isLast:E: '->TT; E.dopt->TQ #)
               if)#);
            exit(rec[],E[],A[])
            #);          
          loadOrigin:
            (# useRtnVal: @boolean;
               staticOff,superAdj: @integer;
               rec,E,nE: ^Exp;
            enter(useRtnVal,staticOff,superAdj)
            do cd.com(#do 'Invocation:loadOrigin:'-> TT; doPT->TT #);
               (* could rec be thisObject for first E1 in E1.E2.E3 ?*)
               (* Perhaps the other way around
                * e1 -> rec
                * rec -> e2.invoke
                * e2 -> rec
                * rec -> e3.invoke
                *)
               '**** DO we come here? INV:loadOrigin:'->dumpT; dopt -> dumpTN;
               scanSons
               (# gdb: debug
                    (#
                    do 'Invocation:loadOrigin:scan: ' -> TT;
                       current.doPT -> TQ;
                    #);
                  T: ^ Text; orgIsVal: @boolean
               do current[] -> E[]; 
                  gdb;
                  (if isFirst then 
                      E.pushThis;
                      (superAdj) -> E.loadOrigin -> (rec[],E[],orgIsVal)
                  if); 
                  (* For X: = { R:  = { ... q: ...} ... R.X }
                   * stack[top] = origin = X 
                   * add offset to R or push(ref(R))
                   *)
                  cd.com(#do 'loadOrigin:afterIsFirst:'->TT;current.doPT->TQ #);
                  (if not isLast then
                      E[] -> rec[];
                          cd.com(#do'loadOrigin:loadArgs:superAdj:E:'->TT;
                                         superAdj -> II #);
                          (superAdj,staticOff) -> E.loadArgs;
                          (rec[],nE[],true,staticOff,none,false) ->E.invoke
                   else
                      cd.com(#do 'loadOrigin:last:' -> TT; current.doPt ->TQ;
                               'rec:'->TT; rec.doPT -> TT; 
                               ':E:'->TT; E.doPT -> TT #);
                      (if not isFirst then
                          (rec[],rec[],true,staticOff,none,false)
                            -> rec.invoke
               if)if)#);
               (* S.simple_bar.c1 := 'x'
                *     rec = c1, E = ':='
                *     No pushOff for c1 = rec, since E = ':='
                *     no loadAsReceiver for c1 = rec
                * S.simple_bar.c1 + 1
                *     rec = c1, E = ':='
                *     pushOff for c1 = rec, but empty action
                *     loadAssReceiver for c1, since simple
                * S.simple_bar.simple_fisk;
                *     rec = simple_bar, E = simple_fisk
                *     pushOff for simple_bar = rec
                *     loadAsReceiver for simple_bar, but empty action
                *)
            exit(rec[],E[])
            #);
          goInclude:<
            (*    %include Q.R
             *    ...
             *    %include S.T
             *    ...
             *    U
             * means: Q.R,S.T.U
             *)
            (# org: ^Items; onx: @integer; orgIsVal: @boolean;
               MI: ^ModuleItem; OI: ^ObjectInvocation; ATdx: ^Decl
            enter(org[],onx)                       
            do cd.com(#do 'IV:viaIncl:on:' -> TT; on -> II; dopt -> TQ;
                        ' org:'->TT; org.dopt -> TQ; 
                     #);
               scanSons
               (#
               do current[] -> OI[];
                  cd.com(#do 'viaIncl:son:isFirst:'->TT; isFirst->BB;
                           'viaIncl<>none:'->TT; OI.ptnId.viaIncl[] <> none->BB;
                           current.dopt -> TQ;
                        #);
                  (if isFirst then
                      (if OI.ptnId.viaIncl[] <> none then
                          (org[],on + 1) 
                            -> OI.ptnId.viaIncl.goInclude 
                            -> (org[],orgIsVal)
                       else
                          (onx + OI.on + 1,OI[]) 
                            -> org.goOrigin  -> (org[],orgIsVal);
                  if)if);
                  OI.ATd.asDecl -> ATdx[];
                  (if nameListInDcl then
                      (ATdx.sig.id[],
                      ((ATdx[]->MI[]).MD.sig.names.firstDecl).newOff) 
                        -> cd.rpushg
                   else
                      (ATdx.sig.id[],(ATdx[]->MI[]).MD.newOff) -> cd.rpushg
                  if)
               #)
            exit(org[],orgIsVal)
            #);
       #);
     adjustOrigin:
       (# originOff: @integer; OGid: ^text
       enter(originOff,OGid[])
       do (if (originOff > 0) then
              cd.com(#do 'AdjustOrigin:originOff:'  -> TT; originOff -> II #);
              (OGid[],originOff) -> cd.rpushg
          if)
       #);
     ObjectInvocation::
       (* May be 
        *  A simple variable X declared as X:@integer; 
        *  An object R declared as R: @Foo
        *  A pattern Foo declared as Foo: Bar{ ... }
        *  ATd = operator.Decl
        *)
       (# pushThis:: (# do (ATd.asDecl).pushThis #);
          getAdr::
            (# gdb:: 
                 (# DI: ^DataItem
                 do '>ATd.off:'->TT;
                    (if ATd.isDataitem then
                        (ATd[]->DI[]).newOff -> II
                     else
                        '0 (isPtn)'->TT
                    if);
                    ':on:'->TT; on->II;
                    ':superAdj:'->TT; adr.superAdj->II;
                    ATd.dopt -> TQ; adr.print->TT 
                 #);
               isVeqDI: BooleanValue
                 (# org: ^Items; eOG: ^ObjectGenerator
                 enter org[]
                 do (if org.superDesc[] <> none then
                        (*'**** isVeq:'->puttext; 
                         * org.superDesc.primNo -> putint; newline;*)
                        ((org.superDesc.primNo = vEq_prim) 
                          or (org.superDesc.primNo = vLE_prim))
                         and (ATd.asDecl).isDataitem
                          -> value
                    if)
                 #);
               getOIqual:
                 (* IV = this(OI).father = R1.R2...Rn
		  * this(OI)= Ri for some i
                  * Compute R1.R2...Ri
		  * It might be more efficient if qual and OGSx are
		  * parameters/returns of getAdr
                  *)
                 (# IV: ^Invocation; org: ^Items; qual: ^ObjectGenerator;
                    OGsx: ^OGsequence; 
                 do father[] -> IV[];
                    (if traceGetVqual then
                        '**** OI:getOIqual: "'->puttext; dopt -> puttext;
                        '" IV:"' -> puttext; IV.dopt -> puttext;
                        '"\n**   origin.encOG: '->puttext;
                        (origin[]->org[]).encOG.dopt -> putheadN;
                    if);
                    ((origin[]->org[]).encOG -> qual[],false,none)
                      -> OGsequence -> OGSx[];
                    L:
         	       IV.scanSons
                       (#
                       do (qual[],not isFirst,OGSx[])
		             -> current.getVqual -> (OGSx[],qual[]);
			  (if current[] = this(ObjectInvocation)[] then
			      leave L
                        if)#);
                 exit qual[]
                 #);                  
               Ax: ^Address; OG: ^ObjectGenerator; org: ^Items; DI: ^DataItem;
               qual: ^ObjectGenerator; T: ^Text
            do (*superAdj -> A.superAdj;*)
               (if stringAsVal then
                   getOIqual -> qual[];
               if);
               (if stringAsVal
                   and origin.isItems
                   and ((origin.origin[]->org[]).encOG.primNo = String_prim)
                   or stringAsVal and ((qual.primNo = String_prim))
		   (* can we elim the first or-clause? *)
                   then
                   cd.com(#do 'PING:String'->TT;
                            (origin[]->org[]).encOG.primNo -> II;
                            org.encOG.dopt ->TT #);
                   L:
                     (if (origin[]->isVeqDI) or (qual.primNo = String_prim) then
                       cd.com(#do'BOBS:ATd:'->TT; ATd.dopt->TQ; #);
                       (if (ATd.asDecl).isDataItem 
                           and ((ATd.asDecl->DI[]).newOff = 2) then
                           DI.dopt -> T[];
                           (if not ('in Veq: var this(Value)' ->T.equalNCS) then
                               cd.com(#do 'Is not: in Veq: var this(Value)'
                                          ->TT #);
                               leave L
                           if);
		          (* newOff = 2 is a dirty hack
			   * we should test if DI = in Veq: var this(Value);
                           * we do that now, but still a hack
			   *)
                           cd.com(#do 'String:vEq: '->TT; dopt -> TQ;
                                    'off: ' -> TT; (ATd[]->DI[]).newOff -> II;
                                    'ATd:'->TT; ATd.dopt -> TQ;
                                 #);
                           DI.newOff ->  adr.off;
                           false -> adr.isValue;
                           true -> adr.isAdr;
                           leave getAdr
               if)if)if);
               adr[] -> Ax[];
               (if (on > 0) or (Ax.E[] = none) then
                   this(ObjectInvocation)[] -> Ax.E[];
                   (* tricky - in R.S.Q, R.on may be > 0, but S.on = Q.on = 0
                    * and the latter must not override on from R and E = R!
                    *)
               if);
               (* here we should check if we can elim asDecl in the call
                * of this OI:getAdr!
                *)
               (if nameListInDcl 
                   and (Atd.sig[] <> none) 
                   and (ATd.sig.names[] <> none) 
                   and (ATd.sig.names.firstDecl <> none) then
                   Ax[] -> (ATd.sig.names.firstDecl).getAdr -> (loadRec,adr[]);
                else
                   Ax[] -> ATd.getAdr -> (loadRec,adr[]);
               if);
            #);
          loadOrigin::
            (# gdb::
                 (#
                 do '>on:'->TT; on -> II; ' superAdj:'->TT; superAdj->II;
                    ' isValueObj:'->TT; ATd.OG.isValueObj->BB
                 #);
               org: ^Items; T: @text; MI: ^ModuleItem;  orig: ^Scope
            do (if (ATD.asDecl).primNo
                // 0 
                // indexed_prim 
                // rIndexed_prim
                // string_prim
                // stringGet_prim // indexedGet_prim
                // immutable_prim then
                   ATd.origin[] -> orig[];
                   (if orig.isItems then orig[] -> org[] if);
                   (# hasValueObj: @boolean; T: ^Text
                   do (if on > 0 then
                          (if false then
                              '**** loadOrigin: '->T[]; dopt -> T.puttext;
                              ' on: '->T.puttext; on -> T.putint; 
                              T.newline;
                              origin[] -> org[];
                              (for i: on + 1 repeat
                                   org.encOG.OGid -> T.puttext; 
                                   (if org.encOG.isValueObj then 
                                       ' True '-> T.puttext; 
                                       true -> hasValueObj
                                    else
                                       ' False '->T.puttext
                                   if);
                                   org.newOriginOff -> T.putint; T.newline;
                                   org.origin[] -> org[]
                              for);
                              (if hasValueObj then
                                  T[] -> putline
                   if)if)if)#);     
                   (if superAdj < 0 then 
                       (if on >= 0 then (* OBS! Used to be on > 0, but if on=0,
                                         * we still need to adjust origin! *)
                           (if (on = 0) and
                               ((ATd.asDecl).origin[] ->orig[]).isSignature then
                            else
                               (-superAdj,'origin-x') -> AdjustOrigin;
                           if);
                           (on - 1,this(ObjectInvocation)[]) 
                             -> (origin[]->org[]).goOrigin
                             -> (org[],orgIsVal)
                       if)
                    else
                       (superAdj,(origin[]->org[]).encOG.OGidWdNo)
                         -> AdjustOrigin;
                       (on,this(ObjectInvocation)[]) 
                         -> (origin[]->org[]).goOrigin
                         -> (org[],orgIsVal)
                   if);
                   (if ptnId.viaIncl[] <> none then
                      (org[],0) -> ptnId.viaIncl.goInclude
                   if)
                // this_prim then
                   (* Must check that argument is the name of an enclosing 
                    * object or the name of the superpattern of an
                    * enclosing object.
                    * For %this foo, ON = %this.origin, A.super.ON = foo.origin
                    *)
                   (superAdj,'origin-z') -> AdjustOrigin;
                   args.scanArgs(* only one argument in %this foo *)
                   (# A: ^ObjectSpecification
                   do current[] -> A[];
                      cd.com
                      (#do 'this_prim:'->TT; A.dopt -> TT;
                         ':super.on:'-> TT; A.super.ON -> II #);
                      (A.super.on - 1,this(ObjectInvocation)[])
                        -> (origin[]->org[]).goOrigin
                        -> (org[],orgIsVal)
                   #)
                // thisCore_prim then 
                   (* perhaps not in loadOrigin, but in execute/ATd.invoke *)
                   ('thisCore',thisCore_prim) -> cd.callPrim
                // thisCoreId_prim then
                   ('thisCoreId',thisCoreId_prim) -> cd.callPrim
               if);
               (* Actually rec = origin*n, E = this(OG) *)
               this(ObjectInvocation)[] -> E[] -> rec[]
            #);
          load::
            (#
            do cd.com
               (#do 'OI:load:'->TT; dopt->TT; ':unit: '->TT; unit.T[]->TT#);
               (rec[],A[]) -> (ATd.asDecl).load
            #);
          handleVargs::
            (# actArgs: [6] ^ObjectSpecification; (* actual arguments *)
               top: @integer; ptn: ^pattern; 
               enclosingOG: ^ObjectGenerator; OGx: ^ObjectSpecification;
               formalArg: ^Pattern; actualArg: ^ObjectSpecification; 
               descNo: @integer; 
               mkCom:
                 (# msg: ^text
                 enter msg[]
                 do cd.com
                    (#do msg[]->TT;  dopt -> TQ; nl;
                       'formalArg: '-> TT; formalArg.dopt -> TQ; nl;
                       'actualArg: '-> TT; actualArg.dopt -> TQ; nl;
                       formalArg.off -> II;
                       ' (actualArg.desc).newDescno: '->TT; descno ->II;
                       ' (OGx.desc).newDescNo: '->TT; (OGx.desc).newDescNo->II;
                    #);
                 #);
            do (if ((ATd.asDecl)->ptn[]).OG.primNo
                // inner_prim // this_prim // ifThen_prim
                // restart_prim // leave_prim then
                   leave handleVargs
               if);
               args.scanArgs
               (#
               do (if (top+1 -> top) > actArgs.range then 
                      actArgs.range -> actArgs.extend 
                  if);
                  current[] -> actArgs[top][];
               #);
               ptn.scanArgs
               (# argInx,dNo: @integer; stubN,stubS,OGidx: ^text; zero: @boolean
               do argInx + 1 -> argInx; 
                  (if (argInx <= top) and currentArg.isVirtual then
                      currentArg[] -> formalArg[];
                      actArgs[argInx][] -> actualArg[]; 
                      cd.com(#do 'args: ' -> TT; currentArg.dopt->TQ;  
                               actualArg.dopt->TQ ; ptnid.dopt -> TT; #);
                      (* can we do currentArg.LoadArg?
                       * And then perhaps special for virtual primitive
                       * and ptName? Virt is of course ptn *)
                      L:
                      (if currentArg.isVirtual then
                          currentArg[] -> formalArg[];
                          actArgs[argInx][] -> actualArg[];
                          father.father[] -> OGx[];
                          (if false then
                              '**** encOGx: ' -> puttext; 
                              OGx.dopt -> putline;
                          if);
                          (if false and ((desc).primNo = indexed_prim) then
                              leave  L
                          if);
                          (if actualArg.IS.isEmpty then
                              actualArg.vDescNo -> dNo;
                              (none,actualArg[]) 
                                -> mkStubName -> (stubN[],stubS[]);
                              (if false then
                                  '**   bind: ' -> puttext; 
                                  StubN[] -> puttext;
                                  ' dNo: ' -> puttext; dNo -> putint; 
                                  ' off: '-> puttext;
                                  formalArg.off -> putint; 
                                  ' newDescNo: ' -> puttext;
                                  (OGx.desc).newDescNo -> putint; newline;
                              if);
                              (formalArg.off,dNo,(OGx.desc).newDescNo,'xx')
                                -> CD.vdtTableAt;
                              (stubN[],dNo,actualArg[],OGx.IS[]) 
                                -> objStubStackX.add
                           else
                              (actualArg.desc).newDescno -> descNo;
                              (if false then
                                  cd.com(#do 'arg:hasItems: ' -> TT #);
                                  '**   descNo: ' -> puttext; 
                                  descNo -> putint;
                                  ' (OGx.desc).newDescNo:' -> puttext;
                                  (OGx.desc).newDescNo -> putint; 
                                  ' OGx.IS.newDescNo: ' -> puttext;
                                  OGx.IS.newDescNo -> putint;
                                  ' ' -> put;
                                  (OGx.super.last).ATd.OG.IS.newDescNo 
                                    -> putint;
                                  newline;
                                  '**   ATd: '->putline;
                                  (OGx.super.last).ATd.dopt -> putline;
                                  '**   OGx: ' -> putline;
                                  OGx.dopt -> putline; '---' -> putline;
                                  (OGx.desc).encOG.dopt -> putline;
                                  true -> zero
                              if);
                              L:
                                OGX.super.scanSons
                                (# OI: ^ObjectInvocation
                                do (if zero then current.dopt ->putline if);
                                   current[] -> OI[];
                                   (if zero then OI.args.dopt ->putline if);
                                   (if args[] = OI.args[] then
                                       (if zero then true -> putboolean;
                                           ' ' -> puttext
                                       if);
                                       (OI.ATd.asDecl).OG.IS.newDescNo -> dNo;
                                       (OI.ATd.asDecl).OG.OGid -> OGidx[];
                                       (if zero then 
                                           dNo -> putint;
                                           newline;
                                           OI.ATd.dopt -> putline
                                       if);
                                       leave L
                                   if)
                                #);
                              (if stubDescNo > 0 then
                                  (formalArg.off,descno,stubDescNo,'yy')
                                    -> cd.vdtTableAt;
                               else
                                  (formalArg.off,descno
                                  ,(OGx.desc).newDescNo
                                  ,(actualArg.desc).encOG.OGid)
                                    -> cd.vdtTableAt;
                              if)
               if)if)if)#)
            #);
          invoke::
            (# gdb::
                 (#do '>rec:'->TT; 
                    (if rec[] = none then 'none'->TQ else rec.dopt -> TQ if);
                    ' ATd:'->TT; (ATd.asDecl).label -> TQ;
                    (if ATd.OG.isValueObj then ' isValueObj'->TT if);
                    ' E:'->TT; E.dopt -> TQ;
                    ' E.ATd:' -> TT; E.ATd.sig.doPT -> TQ;
                    ' unique:' -> TT; E.ATd.OG.IS.isUnique -> BB;
                 #);
               orig: ^Scope; org: ^Items; stubDescNo: @integer; ATdx: ^Decl
            do (* rec is a dataItem *)               
               ATd.origin[] -> orig[];
               (if orig.isItems then
                   (if ((orig[]->org[]) <> none) and org.encOG.isValueObj then 
                       cd.com(#do 'origin:isValueObj'->TT; org.sig.dopt->TQ #)
               if)if);
               (if (adr[] <> none) and (E.ATd[] <> none)  then
                   (if (E.ATd.asDecl).OG[] <> none then
                       (E.ATd.asDecl).OG.IS.isUnique -> adr.isUnique;          
                    else
                       (* Probably E.ATd is a ModuleItem, 
                        * then OG is not defined *)
                       (if not (E.ATd## = ModuleItem##) then
                           E[] -> warning
                           (# do 'E.ATd.OG is none: "' -> msg; 
                              E.dopt -> msg; 
                              '" E.ATd: "' -> msg; E.ATd.doPT -> msg; 
                              '"' -> msg #)
                   if)if);
                   cd.com(#do (if adr[] <> none then adr.print->TT if)#);
                   E[] -> adr.E[]
               if);
               ATd.asDecl -> ATdx[];
               (if hasVirtualArgs then
                   (* we must use newVirtH here *)
                   (if false then
                       '**** OI:genStubv:'->putline; dopt -> puthead;
                       ' ' -> put; useRtnVal -> putBoolean; newline
                   if);
                   (ATd.asDecl,'',QnewDesc->stubDescNo
                   ,(ATd.asDecl).OG.IS.newDescNo,0,0)
                     -> ObjStubStack.add;
                   stubDescNo -> ATdx.OG.vDescNo;
                   (* the code here does not seem to handle more than one arg *)
                   (if (ATd.asDecl).isPattern then stubDescNo ->handleVargs if);
                   ('stub',stubDescNo,4,0,false) ->  cd.invoke;
                   (if useRtnVal then
                       (ATdx.OG[],'stub') -> pushOut
                   if);
                else 
                   cd.com
                   (#do 'OI:invoke:B:'->TT; doPT -> TQ; 
                      'E:' -> TT; E.dopt -> TQ;
                      ' rec:' -> TT; (if rec[] <> none then rec.dopt -> TQ if);
                      ' useRtnV:' -> TT; useRtnVal -> BB; ATd.dopt -> TQ
                   #);
                   cd.com(#do (if adr[] = none then
                            'adr:none' -> TT else adr.print -> TT if)#);
                   (rec[],E[],useRtnVal,staticOff,adr[],false) -> ATdx.invoke;
               if);
               cd.com
               (#do 'OI:invoke:C:'->TT; dopt->TT; ':unit: '->TT; unit.T[]->TT;
                  ' convFactor: ' -> TT; convFactor -> FF #);
               (if convFactor <> 0 then
                   convFactor -> cd.pushFloatConst;
                   112 -> cd.op
               if)
            #);
          loadArgs:: 
            (# gdb:: 
                 (#
                 do '>staticOff:' -> TT; staticOff -> II; ' '->TT;
                    ATd.dopt -> TQ; ' superAdj:'->TT; superAdj -> II;
                    args.scanArgs(#do 'arg:'->TT; current.dopt -> TQ #)
                 #)
            do (this(Exp)[],superAdj,staticOff) 
                 -> (ATd.asDecl).loadArgs -> isResume
            #);
          adjustEmbodied::
            (* if this OI is accesed throuh an embodied object, then push
             * the address of the embodied object to get its address
             *)
            (# OI: ^ObjectInvocation
            do (if isEmbodied then
                   cd.com(#do 'OI:adjustEmbodied:'->TT; isEmbodied -> BB; 
                             theEmbodied.dopt->TQ; theEmbodied.newOff -> II #);
                   ('embody',theEmbodied.newOff) -> cd.rpushg
               if)
            #);
          bracketedListLength:: 
            (# 
            do (if (ATd.asDecl).OG.primNo 
                // indexed_prim // rIndexed_prim // dumpObj_prim then
                else
                   cd.com(#do 'OI:bracketedListLength: ' -> TT;
                            dopt -> TQ; ' ATd.OG.primNo: '-> TT;
                            ATd.OG.primNo -> II #);
                   1 -> value 
               if)
            #);
       #);    
     LabelDecl::
       (# gen::
            (#
            do cd.bcPos -> beginBCP;
               (false,0,0) -> OG.gen;
               cd.bcPos -> endBCP;               
            #)
       #);
     IfThen::
       (# gen::
            (# Tlab, Flab, exitLab: @ LabelHandler.label
            do (if false then
                   '**** IfThenElse:gen ' -> puttext; dopt -> putline;
               if);
               (*118 -> cd.pushConst; cd.vPop;*)
               Tlab.new;
               Flab.new;
               exitLab.new;
               (true,0,staticOff) -> cond.gen;
               (Tlab,Flab) -> cd.jmpFalse;
               Tlab -> cd.defLab;
               (false,0,staticOff) -> thenPart.gen;
               Flab -> cd.defLab;
            #);
          invoke:: 
            (# 
            do (if false then
                   '**** IfThenElse:Invoke: ' -> putline;
               if);
               gen
            #)
       #);
     IfThenElse::
       (#gen::
            (# Tlab, Flab, exitLab: @ LabelHandler.label
            do (if false then
                   '**** IfThenElse:gen ' -> puttext; dopt -> putline;
               if);
               117 -> cd.pushConst;
               cd.vPop;
               Tlab.new;
               Flab.new;
               exitLab.new;
               (true,0,staticOff) -> cond.gen;
               (Tlab,Flab) -> cd.jmpFalse;
               Tlab -> cd.defLab;
               (false,0,staticOff) -> thenPart.gen;
               exitLab -> cd.jmp;
               Flab -> cd.defLab;
               (false,0,staticOff) -> elsePart.gen;  
               exitLab -> cd.defLab
            #);
          invoke:: 
            (# 
            do (if false then
                   '**** IfThenElse:Invoke: ' -> putline;
               if);
               gen
            #)
       #);
     BracketedExp::
       (* a := b + (c * d)
        *     execute c * d
        * (foo).x
        *    loadOrigin foo
        * (foo(e1,e2)).x
        *    execute foo(e1,e29?
        * (%this P).suspend
        *     loadOrigin?
        * (E1)
        *    (E1).pushThis
        *    (E1).loadOrigin
        *    (E1).invoke
        *    rec -> E.invoke
        * (E1).E2
        *    
        * (R.S).foo
        * (R.bar(e1,e2,)).foo  
        * (ch = 'i') && (S <> none)
        * Do we always execute exp in (exp) and (exp).foo?
        * We should thus not just call load origin!?
        * What about (exp), (R.foo)
        * Look at gen: for (exp) we call loadOrigin and then execute
        *   for (exp).foo we call loadOrigin(exp) and then exe on foo
        *   but exe(exp) is not called
        *   How do we in loadOrigin ensure that exe(exp) is called when needed?
        * 
        * E1.(E2)
        * E1.(E2).E3
        *)
       (# gen:: 
            (# 
            do (* we dont come here 
                * but we do for indexed literal like (e1,e2,e3) *)
               (if false then
                   '**** BracketedExp:gen:'->puttext; dopt -> putline;
               if);
               (if noOfSons = 1 then
                   (useRtnVal,superAdj,staticOff) -> IV.gen ;
                else
                   scanSons
                   (#do (useRtnVal,superAdj,staticOff) -> current.gen #)
               if)
            #);
          getAdr::
            (# rec,E: ^Exp
            do cd.com(#do 'BracketedExp:getAdr:'->TT;adr.print -> TT #);
               (*adr[] -> IV.computeAdr -> (rec[],E[],adr[]);*)
               '\n!!!! Koks!Bexp:getAdr'->dumpT; dopt -> dumpTN;
               (adr.superAdj,0) -> E.loadArgs; 
               (* do we need staticOff here? *)
               (* (rec[],E[],true,0,0,none,adr[],false) -> E.invoke;*)
            #);
          pushThis:: 
            (* Skip, since loadOrigin below includes pushThis *)  
            (# #);
          loadOrigin:: 
            (# off: @integer; A: ^Address
            do (* OBS! useRtnVal, staticOff must be handled! *)
               superAdj -> IV.computeAdr -> (rec[],E[],A[]);
               cd.com(#do 'BE:loadOrigin:E:'->TT; E.doPT->TT #);
            #);
          loadArgs:: 
            (* Skip, since loadOrigin includes loadArgs *)              
            (# 
            do cd.com(#do 'BracketedExp:loadArgs: ' -> TT; dopt -> TT #);
            #);
          invoke::
            (# 
            do cd.com(#do 'Bracketed invoke: ' -> TT; dopt->TT #);
              (if noOfSons = 1 then
                   (useRtnVal,0,staticOff) -> IV.gen ;
               else
                  doPP -> putline;
                  scanSons(#do (useRtnVal,0,staticOff) -> current.gen #)
               if)
            #)
       #);
     Const::
       (# gen:: (# do invoke #);
          getAdr::
            (# 
            do this(Const)[] -> adr.E[]
            #);
          invoke:: 
            (# V: @integer; F: @Real
            do T.setpos; T.getInt -> V;
               (if convFactor = 0 then
                   V -> cd.pushConst;
                else
                   V * convFactor -> cd.pushFloatConst;
                   (* Note that the type is now Float ! *)
               if)
            #);
          load:: (# do T.setpos; T.getReal -> cd.pushConst #);
          bracketedListLength:: (# do 1 -> value #);
       #);
     FloatConst::
       (# gen:: (# do invoke #);
          getAdr::
            (# 
            do this(FloatConst)[] -> adr.E[];(* 2 -> adr.size???*)
            #);
          invoke:: 
            (# 
            do (if false then               
                   '****invoke ' -> puttext; dopt -> putline;
                   ' unit: ' -> puttext; unit.T[] -> putline;
               if);
               T.setpos; T.getReal-> cd.pushFloatConst; 
               (if convFactor <> 0 then
                   convFactor -> cd.pushFloatConst;
                   112 -> cd.op
               if)
            #);
          load:: (#do invoke #);
          bracketedListLength:: 
            (# 
            do 1 -> value;
               '!!!! Float:bracketedListLength may not work! ' -> puttext;
               dopt -> putline
            #);
       #);
     CharObj::
       (# gen:: (* Never called? *) (# do invoke #);
          pushThis:: (##);
          getAdr:: (#do this(CharObj)[] -> adr.E[] #);
          invoke:: 
            (# ch: @char
            do (if T.length = 1 then
                   1 -> T.inxget -> cd.pushConst 
                else
                   (if 2 -> T.inxget -> ch
                    // 'n' then 10 -> cd.pushConst
                    // 't' then 9 -> cd.pushConst
                    // '\\' then '\\' -> cd.pushConst
                    // '\'' then '\'' -> cd.pushConst
                    else
                       'CharObj:Special symbol: ' -> puttext; ch -> putint;
                       ':' -> put; '"' -> put; ch -> put; '"' -> put;
                       newline;
                       ch -> cd.pushConst
               if)if)
            #);
          bracketedListLength:: (# do 1 -> value #);
       #);
     getStringPlus:
       (# D: ^Decl
       do L:
            stringDecl.OG.IS.scanSons
            (# 
            do (if current.isDecl then
                   current[] -> D[];
                   (if ('+' -> D.sig.id.equal) then
                       D.markForCodeGen;
                       leave L
            if)if)#)
       exit D[]
       #);
     StringObj::
       (# gen:: 
            (* Never called ? *)
            (# do 'StringObj:gen:' ->puttext; doPT -> putline; invoke #);
          loadOrigin::
            (* In "hello".foo, "hello" plays the same role as R in R.foo,
             * i.e. we must generate a pushText "hello"
             * For an exp "Hello", 
             * loadOrigin then also generates a pushText "hello"
             * Invoke is called only for the last exp in R1.R2.exp 
             * and 'just store the string!
             *)
            (# 
            do cd.com(#do 'StringObj:loadOrigin:' -> TT; dopt->TT; #);
               this(StringObj)[] -> E[] -> rec[]
            #);
          getAdr:: (#do this(StringObj)[] -> adr.E[]; (*T[]->cd.pushText*)#);
          invoke:: 
            (# stringDescNo,n: @integer; (* no of embedded invocations in T*)
               start,end: [4] @integer; 
               prev: @integer;
               doAdd: @boolean;
               plusDecl: ^Pattern;
               getPlusRes:
                 (#
                 do L:
                      plusDecl.OG.IS.scanAllItemDecls
                      (# DI: ^DataItem
                      do (if currentDcl.isOutArg then
                             currentDcl[] -> DI[];
                             (if true
                              // DI.OG.isBasicValue then
                                 (if nameListInDcl then
                                     (T[],(DI.sig.names.firstDecl).newOff) 
                                       -> cd.pushg;
                                  else
                                     (T[],DI.newOff) -> cd.pushg;
                                 if)
                              // DI.OG.isValueObj then
                                 '**** out arg: ' -> puttext; DI.dopt ->putline;
                                 DI.newOff -> cd.pushConst
                              else
                                 (if nameListInDcl then
                                     (T[],(DI.sig.names.firstDecl).newOff) 
                                       -> cd.rPushg;
                                  else
                                     (T[],DI.newOff) -> cd.rPushg;
                                 if)
                             if);
                           leave L
                 if)#)#)
            do
               getStringPlus -> plusDecl[];
               (stringDecl.desc).newDescNo -> stringDescNo;
               T[] -> scanForBrace
               (# pos: @integer
               do (*'*** gen got brace: ' -> puttext; inn[] -> putline;*)
                  n + 1 -> n;
                  first -> start[n];
                  last -> end[n];
                  (*first -> putint; ' ' -> put; last -> putint; newline;
                  (1,first - 1) -> T.sub -> puttext; '#' -> put;
                  (first,last) -> T.sub -> putline;*)
               #);
               scanSons
               (# S: ^Text; n: @integer; 
               do n + 1 -> n;
                  (prev + 1,start[n] - 1) -> T.sub -> S[];
                  (*cd.com(# do 'pushText: ' -> TT; S[] -> TQ #);*)

                  (S[],stringDescNo) -> cd.pushText;
                  (if doAdd then
                      (plusDecl.sig.id[],plusDecl.OG.getDescNo,
                      plusDecl.OG.IS.objSize,0,true) 
                        -> cd.invoke;
                      getPlusRes;
                  if);
                  (*cd.com(#do 'execute' -> TT;
                           (start[n],end[n]) -> T.sub -> TT
                           current.dopt  -> TT #); *)
                          (true,0,0) -> current.gen;
                  (plusDecl.sig.id[],plusDecl.OG.getDescNo
                  ,plusDecl.OG.IS.objSize,0,true)
                    -> cd.invoke;
                  getPlusRes;
                  end[n] -> prev;
                  true  -> doAdd
               #);
               (*cd.com
               (#do 'pushText: ' -> TT; (prev + 1,T.length) -> T.sub -> TQ #);*)
               ((prev + 1,T.length) -> T.sub,stringDescNo)  -> cd.pushText;
               (if doAdd then                    
                   (plusDecl.sig.id[],plusDecl.OG.getDescNo
                   ,plusDecl.OG.IS.objSize,0,true) 
                     -> cd.invoke;
                   getPlusRes;
               if);
               (if not useRtnVal then cd.com(#do 'Kuk'-> TT #); cd.rPop if)
            #);
       #);
     pushOut:
       (# OGx: ^ObjectGenerator; id: ^text;
          pushReturn:
            (# DI: ^DataItem
            enter DI[]
            do cd.com(#do 'pushReturn'->TT; DI.sig.dopt->TT  #);
               (if true
                // DI.OG.isBasicValue then
                   (if DI.OG.isFloat then
                       (if nameListInDcl then
                           (id[],(DI.sig.names.firstDecl).newOff) 
                             -> cd.fpushg
                        else
                           (id[],DI.newOff) -> cd.fpushg;
                       if)
                    else
                       (if nameListInDcl then
                           (* Assuming only one var in an out DI *)
                           (id[],(DI.sig.names.firstDecl).newOff) 
                             -> cd.pushg;
                        else (if (DI.OG.super <> none) and
                               ((DI.OG.super.last).ATd.OG.primNo = string_prim)
                               then
                               (id[],3) -> cd.pushg;
                            else
                               (id[],DI.newOff) -> cd.pushg;
                           if)
                   if)if)
                // DI.OG.isValueObj then
                   (if nameListInDcl then
                       (DI.sig.names.firstDecl).newOff -> cd.pushConst;
                    else
                       DI.newOff -> cd.pushConst;
                   if);
                   DI.OG.IS.newDescNo -> cd.pushConst
                else
                   (if nameListInDcl then
                       (id[],(DI.sig.names.firstDecl).newOff)
                         -> cd.rPushg;
                    else
                       (id[],DI.newOff) -> cd.rPushg;
            if)if)#);
          DI: ^Decl
       enter(OGx[],id[])
       do (if OGx.isValueObj then
              '!!!! pushOut:OG.isValueObj:NOT handled! ' -> puttext; 
              OGx.dopt -> putline;
           else
              (if (OGx.getReturnDecl -> DI[]) <> none then 
                  DI[] -> pushReturn;
                  (*Apparenly pushOut is called even if no returnDecl*)
          if)if)
       #);
     genVstub:
       (# stubN,stubT: ^text; dNo: @integer; OG: ^ObjectSpecification;
          ptn: ^Pattern; encIS: ^Items;
          restartLab,leaveLab: @LabelHandler.label;
       enter(stubN[],dNo,OG[],encIS[])
       do (if false then
              '*** genVstub: ' -> puttext; stubN[] -> puttext; 
              ' dNo: ' -> puttext; dNo -> putint; 
              ' originOff: ' ->  puttext; encIS.newOriginOff->putint; newline;
              OG.dopt -> puthead; '----' -> putline;
              encIS.dopt -> puthead
          if);
          (if false and OG.isValueObj then
              '!!!! genVstub:valueObj: '->puttext;
              OG.dopt -> putheadn
          if);
          (stubN[],dNo,false,'Object',0) -> cd.classDef
          (#
          do (1,encIS.encOG.OGidWdNo) -> addR; (* origin for vStub *)
             (2,OG.OGidWdNo) -> addR(* to store ref to obj generated by stub *)
          #);
          
          objectDecl[] -> ptn[];
          
          (OG.OGidWdNo,OG.getDescNo,false,'Object',0) -> cd.classDef;
          
          (stubN[],dNo,false,ptn.OG.IS.newDescNo
          ,encIS.newOriginOff ,encIS.encOG.OGidWdNo,encIS.newDescNo,false,true)
            -> cd.class;
          
          (* last arg is isValueObj, to be fixed!*)
          cd.com(#do 'Load origin:OG.isVirtualArg:'->TT; 
                   OG.isVirtualArg->BB #);
          
          (stubN[],dNo,encIS.encOG.OGid,encIS.newDescNo,OG.OGidWdNo) 
            -> cd.prepareStub -> stubT[];
          (if not OG.isValueObj then          
              (if OG.isVirtualArg then
                  (OG.super.on + 1,OG.super[]) -> encIS.goOrigin;
               else
                  (if OG.super.ATd.asDecl <> objectDecl[] then
                      (OG.super.on,OG.super[]) -> encIS.goOrigin;
          if)if)if);
          cd.com
          (#do 'OG.super.on/descNo:' -> TT; 
             OG.super.on->II; OG.getDescNo->II; #);
          (if true then
              (* arg 2 = staticOff,do we need it?*)
              (if not emitLLVM then
                  (if OG.IS.isEmpty and not OG.super.hasVirtualArgs then
                      ((OG.super.ATd.asDecl).OG[],0,true) -> callInvoke
                   else (* never happens! *)
                      (OG[],0,true) -> callInvoke
              if)if)
           else
              (encIS.sig.id[],OG.getDescNo,OG.IS.objSize,0,true)
                -> cd.invoke
          if);
          
          (* move refTo thisObj to caller stack
           * This rstoreg seems odd/wrong? WHy?
           * we seem to store  ref to thisObj in vStub
           * and the push it on the caller stack!?
           *)
          cd.pushThis;
          (stubT[],2) -> cd.rstoreg;
          cd.setThisStack;
          cd.pushThis;
          (stubT[],2) -> cd.rpushg;
          
          'D' -> cd.rtn;
          (3(*objSize*),false,encIS.newBasicProp.OSDvisibility) 
            -> cd.endClass;
          (* mkLLVMvirtualDefs for thisClass!
           * But a vStub has no virtuals, so superflous? NO! mkVdtAlloc *)
          cd.mkLLVMvirtualDefs
          (# vName:: (#do '*** vStub: vName no binding' -> putline #);
             handleOrigins::
               (# E: ^Exp;
               do (if false then
                      '**** Vstub handleOrigins: ' -> puttext; stubN[]->puttext;
                      ' ' -> put; OG.OGidWdNo -> puttext;
                      ' ' -> put; OG.super.dopt -> puttext; newline;
                  if);
                  cd.lcom(#do 'Vstub:handleOrigins:NEW:' -> TT; stubN[] -> TT; 
                            OG.super.ATd.OG.doPT-> TT #);
                  cd.stack.put;
                  cd.rswap;
                  cd.stack.put;
                  OG.super[] -> goOriginAdr -> E[];
                  (* store possible argumenst of E *)
                  cd.rswap;
                  (OG[],(OG.super.ATd.asDecl).OG[],true) -> storeOrigins;
                  cd.lcom(#do 'Vstub:handleOrigins:END: ' -> TT #)
               #)
          #);
          cd.com(#do 'vdt:a:dNo:'->TT; dNo -> II; 
                   ' newDescNo: '->TT; encIS.newDescNo->II
                #);
       #);
     genStub:
       (* do we need to generate and store an origin here as for genVstub? *)
       (# atD: ^Pattern; N: ^Text; 
          descNo,stubDescNo,superDescNo,originOff,originDescNo: @integer
       enter(atD[],N[],descNo,superDescNo,originOff,originDescNo)
       do ('Stub',descNo,false,ATd.OG.IS.newDescNo,1,'Object',originDescNo
          ,false,false) 
            -> cd.class;
          cd.com(#do Atd.dopt -> TQ #);
          ATd.OG.iS.newDescNo -> cd.vdtTableCopy;
          cd.tstOriginIsNone;
          ('sorigin',1) -> cd.rstore;
          (* OBS! we assume that originOff = 1 for super!
           * This needs to be validated!
           *)
          superDescNo -> cd.toSuper;
          'S' -> cd.rtnInner;
          (16,false,0) -> cd.endClass
       exit stubDescNo
       #);     
     mkStubName:
       (# sig: ^signature; OGx: ^ObjectSpecification; T,S: ^text
       enter(sig[],OGx[])
       do '' -> T[];
          (if sig[] <> none then
              sig.id.copy -> S[]
           else
              'S' -> S[]
          if);
          '#' -> S.put;    
          OGx.vDescNo -> S.putint;
          S[] -> T.append;
          (if false then
              '**** mkStubName:B: ' -> puttext; T[] -> puttext;
              ' ' -> put; S[] -> putline
          if)
       exit(T[],S[])
       #);
     ObjStubStackX: @
       (# add:
            (# gen:
                 (#
                 do (stubN[],dNo,OG[],encIS[]) -> genVstub;
                 #);
               stubN: ^text; dNo: @integer; OG: ^ObjectSpecification;
               encIS: ^Items;
            enter(stubN[],dNo,OG[],encIS[])
            do (if (top + 1 -> top) > OIS.range then
                   OIS.range -> OIS.extend
               if);
               this(add)[] -> OIS[top][];
            #);
          gen:
            (#
            do (for  i: top repeat
                    OIS[i].gen
               for);
               0 -> top
            #);
          OIS: [12] ^add; top: @integer
       #);
     ObjStubStack: @
       (# add:
            (# gen:
                 (#
                 do (atD[],N[],stubDescNo,superDescNo,originOff,originDescNo)
                    -> genStub
                 #);
               atD: ^Pattern; N: ^Text; 
               stubDescNo,superDescNo,originOff,originDescNo: @integer
            enter(atD[],N[],stubDescNo,superDescNo,originOff,originDescNo)
            do (if (top + 1 -> top) > OIS.range then
                   OIS.range -> OIS.extend
               if);
               this(add)[] -> OIS[top][];
            exit stubDescNo
            #);
          gen:
            (#
            do (for  i: top repeat
                    OIS[i].gen
               for)
            #);
          OIS: [12] ^add; top: @integer
       #);
     
     ObjTmpStackClass::
       (# item: 
            (# OG: ^ObjectGenerator;
            enter OG[]
            exit this(item)[]
            #);
          add::
            (# 
            do (if (top+1-> top) > OTL.range then 
                   OTL.range -> OTL.extend;
                   done.range -> done.extend
               if);
               (if false then
                   'ObjTmpStack:add: ' -> puttext; OG.ogID -> puttext;
                   ' ' -> put; OG.IS.newDescno ->putint; newline;
               if);
               (if OG[] = StringDecl.OG[] then
                   cd.lcom(#do ' String: ' -> TT; OG.IS.newDescNo -> II#);
               if);
               cd.com(# do 'ObjTmpStack:add:'->TT; 
                        (if OG.sig[] <> none then
                            OG.sig.doPT -> TQ; ':' -> TT;
                        if);
                        OG.doPT -> TQ;
                     #);
               OG[] -> item -> OTL[top][];
               (* Does IS.newDescNo correspond to var? Probably no!?*)
            #);                   
          next:
            (# inx: @integer; B: @boolean
            do 0 -> inx; false -> B;
               Loop:
                 (#
                 do inx + 1 -> inx;
                    (if inx <= top then
                        cd.com(# do 'objTmpStack:next: ' -> TT;
                                 ' : done:'->TT; done[inx] -> BB;
                              #);
                        (if not OTL[inx].OG.IS.codeGenDone then
                            cd.com(# do 'objTmpStack:next:genClass:' -> TT;
                                     OTL[inx].OG.IS.newdescno -> II; 
                                  #);
                            OTL[inx].OG.genClass;
                        if);
                        restart Loop
                    if);
                 #)
            exit B
            #); 
          OTL: [10] ^Item; top: @integer;
          done: [10] @boolean
       #);       

     markIncludes,EPpath: @ ModulePath;
     
     ModulePath:
       (* mark all modules used by main module,and
        * find origin offsets for the nested modules enclosing main
        * We dont seem to use the origin offsets for QBETA 
        * -- needed for BETA, but for QBETA Alloc executes the object,
        * -- i.e. allocation of Main in BETAworld executes Main
        * -- with correct origin
        *)
       (# find:
            (# md: ^module;
               MI: ^ModuleItem;
               org: ^TopNode;
               D: ^Items;
               trace: (#exit false #);
            enter md[]
            do (if md[] <> none then
                   (if trace then
                       '\nModule: ' -> puttext; md.sig.doPT -> puttext;
                       ' descNo: ' -> puttext; (md.desc).newDescNo -> putint; 
                       ' imports: ' -> putline;
                   if);
                   true -> md.markModule;
                   (if md.origin[] <> none then
                       md.NewOff -> addOff;
                       (* else top module BETAworld *)
                   if);    
                   md.origin[] -> org[];
                   FindModule: (* same as encModule?*)
                     (if org[] <> none then 
                         (if org## <> Module## then 
                             org.father[] -> org[]; restart FindModule 
                         if);
                         org[] -> find 
                      else 
                         md[] -> topModule[] 
                     if)
               if)
            #);
          
          topModule: ^module; (* BETAworld *)
          orgOff: [6] @integer; top: @integer;
          addOff: (* not needed, see above *)
            (# off: @integer
            enter off
            do (if (top+1 -> top) > orgOff.range then 
                   orgOff.range -> orgOff.extend 
               if);
               off -> orgOff[top];
               (*' addOff: ' -> puttext; off -> putint; ' ' ->put*)
            #);
          main: ^Module
       enter main[]
       do 0 -> top;
          main[] -> find;
       #);
     genStubs:
       (# genValueProxy:
            (# dN: @integer;
            do (Invocation,Items) -> ObjectGenerator -> QnewDesc -> dN;
               ('valProx',dN,false, 1,1,'Object',0,false,false) -> cd.class;
               dN -> valueProxyDescNo;
               (4,false,0) -> cd.endClass
            #);
          genMain:
            (# restartLab,leaveLab: @LabelHandler.label;  
            do (Invocation,Items) -> ObjectGenerator -> QnewDesc -> mDescNo;
               ('main',mDescNo,false,1,0,'Object',0,false,false) -> cd.class;
               labelHandler.init; 
               restartLab.new;
               leaveLab.new;

               restartLab -> cd.defLab;
               cd.pushThis;
               (if false then
                   'TopModule: ' -> puttext;
                   markIncludes.topModule.sig.doPT -> putLine;
                   'Main: ' -> puttext; main.doPt -> putline
               if);
               ('BETAworld',(markIncludes.topModule.desc).newDescno
               ,(markIncludes.topModule.desc).objSize,0,true) 
                 -> cd.invoke
               (# topSuperId::
                    (#
                    do (markIncludes.topModule.desc).encOg.OGidWdNo 
                         -> superId[]
                    #)
               #);
               cd.stop; (* We should generate stop here and not in betaVM *)
               (* The objSize of main is set to 2 but perhaps not needed?
                * Was needed by qenv before an empty ObjectGenerator was 
                * generated for main *)
               leaveLab -> cd.defLab;
               'D' -> cd.rtn;
               (2,false,0) -> CD.endClass;
               
               (if markIncludes.main## <> Module## then
                   '\n\n***** Only Modules can be executed *****\n\n'
                     -> putline
               if)
            #);
          genThreadStub:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('ThreadStub',descNo,false,descNo,0,'Object',0,false,false) 
                 -> cd.class;
               false -> cd.actions;
               ('ThreadStub','D') -> cd.call;
               cd.stop;
               (1,false,0) -> CD.endClass;               
            #);
          genEventProcessor:
            (# descNo: @integer;
            do ObjectGenerator -> QnewDesc -> descNo;
               ('EventProcessor',descNo,false,1,0,'Object',0,false,false) 
                 -> cd.class;
               cd.stop; (* we should generate stop here and not in betaVM *)
               (1,false,0) -> CD.endClass;               
            #);
       do genValueProxy;
          (* OBS! genMain; genEventProcessor; genThreadStub
           * MUST come in this order, since interpreter_c assumes
           * that threadStubDescNo = mainDescNo + 2;
           * it calls  mainDescNo = getMainDescInx();  
           * mainDescNo is packed in the image; 
           * threadStubNo SHOULD also be packed in the image
           *)
          genMain;          
          (if not emitLLVM then 
              genEventProcessor;     
              genThreadStub;
          if);
       #);
     valueProxyDescNo,
     mDescNo: @integer;
     mainDescNo:: 
       (# 
       do mDescNo -> value (* ad hoc *);
       #);
     (* cd: @ObjectCode; moved to abstractSyntaxTree for debugging purposes *)
     runTimeDescs:: (# do descs[] -> rtDescs[] #);
     descs: ^RunTimeDescriptors;
     BC,BCllvm: @File;
     emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs: @boolean; ch: @integer;
     ind: @integer;
     emitBC:
     (# N: ^TopNode;
        indent:
	(#
	do (for i: ind repeat ' ' -> put for);
	#)
     enter N[]
     do indent;
        '['->put; N.beginBCP -> putint; ','->put; N.endBCP -> putint; ']'->put;
        newline;
        N.scanSons
	(#
	do indent;
	   current.dopt -> putline;
	   ind +  3 -> ind;
	   current[] -> emitBC;
	   ind - 3 -> ind
        #)
     #);
  do (if verbose then '**** GENERATOR ****' -> putline if);
     (if emitLLVM then
         newFeature -> cd.newFeature;     
         (FN[],'.ll') -> mkAuxName -> BC.name;
         ('tmp.xbeta','.ll') -> mkAuxName -> BCllvm.name;
         BCllvm.openWrite;
         (BCllvm[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs) -> cd.init;
      else
         (FN[],'..s') -> mkAuxName -> BC.name;
         (BC[],emitLLVM,emitCom,traceLLVMcalls,dumpLLVMobjs) -> cd.init;
     if);
     BC.openWrite;
     cd.com(#do'QBETA'-> TT #);
     
     labelHandler.init;
     0-> ObjTmpStack.top;
     main[] -> markIncludes;     

     (* Module::gen puts OG on ObjTmpStack *)
     (* rootModule = BETAworld must have descNo = 1 
      * - no longer the case *)
     (# ptn: ^Pattern; OGx: ^ObjectGenerator
     do (*'**** rootModule.markForCodeGen'->putline;*)
        rootModule.markForCodeGen;	
        objectDecl.markForCodeGen;
        (* Pattern Object is special and not reached during a by-need scan
         * but must be allocated
         *)
        (*true -> (ptn.OG[]->OGx[]).marked *)
     #);
     getStringPlus;
     rootModule.classDef;
     L:
       (# B: @ boolean
       do false -> B;
          ObjTmpStack.next or B -> B;
          (* Eliminate boolean and fix test for objTmpStack.isEmpty *)
          (if B then
              restart L 
          if)
       #);
     objStubStack.gen;
     genStubs;
     (if verbose then '**** REQUIRES ****' -> putline if);
     rootModule.importRequires;
     (if not locateWorld.aMiniBetaModule then
         rootModule.checkRequires;
     if);
     
     (if stringDecl[] <> none then
         (if (stringDecl.desc).newDescNo = 0 then
             rootModule[] 
               -> SemanticError(#do 'StringDecl.newDescNo = 0!' -> msg #)
          else
             (stringDecl.desc).newDescNo -> CD.descs.textDescNo
         if)
      else
         rootModule[] -> SemanticError(#do 'StringDecl not found!' 
                                           -> msg #)
     if);
     (*  (if StructureRefDesc[] <> none then
      *          StructureRefDesc.newDescNo -> CD.descs.structureRefDescNo
      *       else
      *          rootModule[] 
      *            -> SemanticError(#do 'StructureRefDesc not found!' 
      * -> msg #)
      *    if);
      *)
     
     cd.descs[] -> descs[]; (* descs is transferred to betaVM ?*)
     true -> descs.newAlloc;
     cd.close;
     (if false and mainPT then
         '**** main: ' -> putline; main.doPT -> putline
     if);
     (if emitLLVM then
         (*(0,fromBeginning) -> BCllvm.setpos;*)
         ';;; Start of LLVM\n' -> BC.puttext;
         BCllvm.close;
         BCllvm.openRead;
         (*CD.LLVMstructs[] -> BC.puttext;*)
         'target triple = "i686-pc-windows-cygnus"\n' -> BC.puttext;
         cd.typeInfo.printStructs;
         CD.LLVMstructs[] -> BC.puttext;
         'declare noalias i8* @malloc(i64)\n' -> BC.puttext;
         'declare noalias i32* @allocIndexed(i32,i32)\n' -> BC.puttext;
         'declare noalias i32 @arrayLength(i32*)\n' -> BC.puttext;
         'declare noalias i32* @allocString(i8*, i32)\n' -> BC.puttext;
         'declare i32 @puts(i8* nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @putCh(i32 nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @putHex(i32 nocapture) nounwind\n' -> BC.puttext;
         'declare i32 @dumpHex(i32 nocapture, i32 nocapture) nounwind\n' 
         'declare void @notImpl(i32 nocapture) nounwind\n' 
           -> BC.puttext;
         
         copy:
           (if not BCllvm.eos then
               BCllvm.get -> ch;
               (if ch <> ascii.cr then ch -> BC.put; if);
               restart copy
           if);
         BCllvm.close
     if);
     (*true -> PTwithBCP;
     main.dopt -> putline;*)
     BC.close
  #)

