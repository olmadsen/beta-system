ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaAST';
INCLUDE 'qStdBetaLexer';
INCLUDE '~beta/sysutils/envstring';
INCLUDE '~beta/dependency/dependency';
INCLUDE '~beta/grammars/beta/betacfl';
INCLUDE '~beta/newmps/grammarinit';
--Lib:attributes--
doTrace: (# exit false #);
doTraceParser: (#exit false #);
parseStdBetaModule: StdBetaAst
  (# 
      mkFN:
       (# stripLast:
            (# pth: ^text; lastDirPos: @integer
            enter pth[]
            do (*''**** strip:' -> dumpT; pth[] -> dumpTN;*)
               pth.scanAll
               (# i: @integer 
               do i + 1 -> i;
                  (if (ch = '/') and (i < pth.length) then
                      i -> lastDirPos 
               if)#);
               (1,lastDirPos) -> pth.sub -> pth[];
               (*'**   got:'->dumpT; pth[] -> dumpTN*)
            exit pth[]
            #);               
          
          FN,currentDir,fullFN,BetaLib: ^text;
       enter(FN[],currentDir[])
       do (if false then
              '**** mkFN:'->dumpTN; FN[] -> dumpTN; currentDir[] -> dumpTN;
          if);
          (if (1 -> FN.inxGet) = '\'' then
              (2,FN.length) -> FN.sub -> FN[]
          if);
          (if (FN.length -> FN.inxGet) = '\'' then
              (1,FN.length - 1) -> FN.sub -> FN[]
          if);
          
          L:
          (if true
           // '../' -> ((1,3) -> FN.sub).equal then
              (4,FN.length) -> FN.sub -> FN[];
              currentDir[] -> stripLast -> currentDir[];
              restart L
           // '~beta/' ->((1,6) -> FN.sub).equal then
               '$(BETALIB)' -> expandEnvVar -> BetaLib[] ;
              (if betaLib[] = none then 
                  '!!!! Did not find BETALIB!'->putline 
               else
                  (if false then
                      '**   BetaLib:'->dumpT; BetaLib[] -> dumpTN;
              if)if);          
              '/' -> BetaLib.append -> betaLib[];
              (7,FN.length) -> FN.sub -> BetaLib.append -> fullFN[];
           else
              FN[] -> (currentDir.copy).append -> fullFN[];
          if);
          (if not 
              ('.bet' -> ((fullFN.length - 3,fullFN.length)->fullFN.sub).equal)
              then 
              '.bet' -> fullFN.append
          if);
          (if false then
              '**   fullFN:'->dumpT; fullFN[] -> dumpTN
          if)
       exit fullFN[]
       #);
     mkCurrentDir:
       (# fullPath, currentDir: ^text; lastSlash: @integer
       enter fullPath[]
       do fullPath.scanAll
          (# i: @integer
          do i + 1 -> i; 
             (if ch = '/' then
                 i -> lastSlash
          if)#);
          (1,lastSlash) -> fullPath.sub -> currentDir[];
          (if false then
              '**** mkCurrentDir:' -> dumpTN; fullPath[]->dumpTN;
              currentDir[] -> dumpTN;
          if)
       exit currentDir[]
       #);    
     superParser: 
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
       enter fileName[]
       do (path.append).copy -> pathToFN[];
          &StdBetaLexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          lex;
          INNER;
          inFile.close;
       #); 

     slotCollector: @
       (# theSlots: [10] ^SlotList; top: @integer;
          push:
            (#
            do (if (top +1 -> top) > theSlots.range then 
                   theSlots.range -> theSlots.extend
               if);
               &SlotList[] -> theSlots[top][]
            #);
          pop:
            (# slots: ^SlotList;
            do theSlots[top][] -> slots[];
               top - 1 -> top;
            exit slots[]
            #);
          add:
            (# slt: ^Slot
            enter slt[]
            do slt[] -> theSlots[top].append
            #);
       #);
     moduleCollector: @
       (#
          theModules: [10] ^StdBetaModule; top: @integer;
          add:
            (# M: ^StdBetaModule
            enter M[]
            do (if (top + 1 -> top) > theModules.range then 
                   theModules.range -> theModules.extend
               if);
               M[] -> theModules[top][]
            #);
          has: 
            (# fragPath: ^text; M: ^StdBetaModule
            enter fragPath[]
            do L:
                 scan
                 (#
                 do scan
                    (#
                    do (if fragPath[] -> current.fragPath.equal then
                           (*'**   Alreay parsed:'->dumpT; fragPath[]->dumpTN;*)
                           current[] -> M[];
                           leave L
                 if)#)#)
            exit M[]
            #);
          scan:
            (# current: ^StdBetaModule
            do (for i: top repeat
                    theModules[i][] -> current[];
                    inner scan
            for)#);
          bindSlots:
            (#
            do scan
               (# slt: ^Slot; moduleOrigin: ^StdBetaModule
               do (if (current.moduleOrigin[]->moduleOrigin[]) <> none then
                      (if false then
                          '**** Bind fragments in: ' -> dumpT;
                          current.moduleName.doPT -> dumpTN;
                          '**   in slots in:' -> dumpT; 
                          moduleOrigin.moduleName.dopt->dumpTN;
                      if);
                      current.frags.scanSons
                      (# frag: ^BetaFragment
                      do ((current[]->frag[]).theName.N.T[],frag.cat.dopt)
                           -> moduleOrigin.findSlot
                           -> slt[]
                           -> frag.matchingSlot[];
                         (if slt[] <> none then
                             (if false then
                                 '**   slt:'->dumpT; slt.dopt->dumpTN;
                                 '**   frag:'->dumpT; frag.dopt->dumpTN;
                             if);
                             frag[] -> slt.addBinding
                          else
                             '\n**** did not find a binding of: '->puttext;
                             current.dopt->putline;
       if)#)if)#)#)#);
     openBetaModule:
       (# moduleName,currentDir,fragPath: ^text;
          NM: ^Name;
          BPS: ^BetaProperties; frags: ^BetaFragments;
          slots: ^SlotList;
          SBM,moduleOrigin: ^StdBetaModule;
       enter(moduleName[],currentDir[])
       do (moduleName[],currentDir[]) -> mkFN -> fragPath[];
          (if (fragPath[] -> moduleCollector.has -> SBM[]) = none then
              (if true or doTrace then
                  '**** openBetaModule:'->dumpT; moduleName[] -> dumpTN
              if);
              slotCollector.push;
              fragPath[] -> mkCurrentDir -> currentDir[];
              fragPath[] -> doParse -> (BPS[],frags[]); 
              (moduleName.copy,BPS[],frags[]) 
                -> StdBetaModule -> SBM[] -> moduleCollector.add;
              fragPath.copy -> SBM.fragPath[];
              slotCollector.pop -> SBM.slots[];
              
              (if false and doTrace then SBM.doPT -> dumpTN if);
              
              (SBM[],currentDir[]) -> handleProperties -> SBM.moduleOrigin[];
              (if SBM.moduleOrigin[] = none then 
                  SBM[] -> topModule[] 
          if)if);
       exit SBM[]
       #);
     handleProperties:
       (# SBM,propModule,moduleOrigin: ^StdBetaModule; BPS: ^BetaProperties; 
          frags: ^BetaFragments; currentDir: ^text;
       enter(SBM[],currentDir[])
       do (if doTrace then
              '**** handle Beta properties'->dumpTN;
          if);
          SBM.frags[] -> frags[];
          SBM.BPS.scanSons
          (# 
          do (*'**** SBM.BPS:'->dumpT; current.dopt -> dumpTN;*)
             current.scanSons
             (# n: @integer; propN,propArg: ^text; 
                isOrigin,isInclude,isMdbody,gotQbetaSelector: @boolean
             do n + 1 -> n;
                (if n = 1 then
                    current.doPT -> propN[];
                    (if true
                     // 'ORIGIN' -> propN.equalNCS then
                        true -> isOrigin
                     // 'BODY' -> propN.equalNCS
                     // 'INCLUDE' -> propN.equalNCS then
                        true -> isInclude
                     // 'MDBODY' -> propN.equalNCS then
                        true -> isMdbody
                    if);
                 else
                    current.dopt -> propArg[];
                    (if doTrace then
                        (if true 
                         // isOrigin then
                            '**** handle origin:'->dumpTN
                         // isInclude then
                            '**** handle include:'->dumpTN
                         // isMdbody then
                            '**** handle mdbody:'->dumpTN
                    if)if);
                    (if true
                     // isOrigin or isInclude then
                        (if isMdBody then
                            '**** mdbody:'->dumpt;
                            proparg[] -> dumpt;
                            currentdir[] -> dumptn
                         else
                            (propArg[],currentDir[])
                              -> OpenBetaModule
                              -> propModule[];   
                        if);
                        (if propModule[] <> none then
                            (if doTrace then
                                (if true 
                                 // isOrigin then
                                    '**** open:origin:'->dumpT;
                                 // isInclude then
                                    '**** open:include:'->dumpT
                                 // isMdbody then
                                    '**** open:mdbody:'->dumpT
                                if);
                                current.dopt -> dumpTN;
                                propModule.doPT -> putHeadN
                            if);
                            (if isOrigin then 
                                propModule[] -> moduleOrigin[]
                        if)if);
                        false -> isOrigin -> isInclude;
                     // isMdBody then                        
                        (*'**** mdbody:'->dumpt; n -> putint; ' ' -> put;
                        proparg[] -> dumpTN;*)
                        (if (n mod 2) = 0 then
                            (if true
                             // 'qbeta'->propArg.equalNCS 
                             // 'default'->propArg.equalNCS then
                                true -> gotQbetaSelector
                            if)
                         else
                            (if gotQbetaSelector then
                                (propArg[],currentDir[])
                                  -> OpenBetaModule
                                  -> propModule[];
                                false -> gotQbetaSelector
                        if)if)
          if)if)#)#)
       exit moduleOrigin[]
       #);
     doParse: superParser
        (# BPS: ^BetaProperties;  frags: ^BetaFragments
        do (if doTrace then
               '**** doParse:' -> dumpT; fileName[] -> dumpTN;
           if);
           pProperties -> BPS[];
           pFragments -> frags[]; 
        exit(BPS[],frags[])
        #);
     pProperties:
       (# BPS:  ^BetaProperties; prop: ^BetaProperty; symb: ^Text;  
          gotOne: @boolean
       do 'pProperties'->trace;
          BetaProperties -> BPS[];
          L:
            (if lex.symb
             // lex.symbols.idf  then
                lex.sym[] -> symb[];
                lex;
                symb[] -> pProperty -> prop[] -> BPS.append;
                (if lex.symb = lex.symbols.semicolon then 
                    true -> gotOne;
                    lex; 
                    'pProperties:repeat'->trace; 
                    restart L
                if)
             // lex.symbols.frag then (* no properties *)
             // lex.symbols.eos then (* empty file *)
             else
                (if not gotOne then SyntaxError if)
            if)
       exit BPS[]
       #);
     
     pProperty:
       (# symb: ^Text;  prop: ^BetaProperty;
       enter symb[]
       do 'pProperty'->trace;
          BetaProperty -> prop[]; symb.copy -> Name -> NameApl -> prop.append;
          L:
            (if lex.symb
             // lex.symbols.textSy then
                lex.sym[] -> BetaString -> prop.append;
                lex;
                restart L
             // lex.symbols.charSy then
                lex.sym.copy -> BetaString -> prop.append;
                lex;
                restart L
             // lex.symbols.idf then
                'pProperty:idf:'->trace;
                lex.sym.copy -> Name -> NameApl -> prop.append;
                lex;
                restart L
             // lex.symbols.const then
                'pProperty:const:'->trace;
                lex.sym.copy -> ConstExp -> prop.append;
                lex;
                restart L
            if);
          'pProperty:end'->trace;
       exit prop[]
       #);

     pFragments: 
       (# frags: ^BetaFragments; frag: ^BetaFragment
       do 'pFragments'->trace;
          BetaFragments -> frags[];
          Loop:
            (if lex.symb = lex.symbols.frag then 
                lex;
                pFragment -> frag[] -> frags.append;
                'pFragments:after:pFragment'->trace;
                (if lex.symb = lex.symbols.frag then 
                    restart Loop
            if)if);
          'pFragments:end'->trace
       exit frags[]
       #);
     pFragment:
       (# frag: ^BetaFragment; theName,cat,language: ^Name;
       do 'pFragment'->trace; 
          loop:
            (if lex.symb = lex.symbols.idf then
                lex.sym.copy -> Name -> theName[];
                lex; 
                'pFragment:idf'->trace; 
                (if lex.symb = lex.symbols.colon then
                    lex;
                    'pFragment:colon'->trace; 
                    (if lex.symb = lex.symbols.idf then
                        'pFragment:idf:colon:idf'->trace; 
                        lex.sym.copy -> Name -> cat[];
                        lex;
                        (if lex.symb = lex.symbols.colon then
                            'pFragment:idf:colon:idf:colon'->trace; 
                            lex;
                            (if lex.symb = lex.symbols.idf then 
                                (* --- x:objectDesc:beta --- *)
                                lex.sym.copy -> Name -> language[];
                                lex;                          
                             else
                                SyntaxError
                            if)
                         else
                            'pFragment:idf:colon:BETA'->trace; 
                            'BETA'-> Name -> language[];
                        if);
                        (if lex.symb = lex.symbols.frag then
                            'pFragment:frag:last'->trace; 
                            lex;
                            (if true 
                             // 'descriptor' -> cat.T.equalNCS 
                             // 'descriptorForm' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> pObjDescFrag -> frag[]
                             // 'attributes' -> cat.T.equalNCS 
                             // 'attribute' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> pAttFrag
                                  -> frag[]
                             // 'doPart' -> cat.T.equalNCS then 
                                (theName[],cat[],language[]) 
                                  -> pDoPartFrag -> frag[]
                             // 'mainPart' -> cat.T.equalNCS then
                                '\n!!!! MainPart category is not implemented' 
                                  -> putline
                             else
                                'Unknown category: ' -> puttext; 
                                cat.T[] -> putline
                            if);
                            (if frag[] <> none then frag.markNamesAsSlot if);
                            (if lex.symb = lex.symbols.frag then 
                                (*lex;
                                restart loop*)
                            if);
                         else
                            SyntaxError
                        if)
                     else
                        SyntaxError
                    if)
                 else
                    SyntaxError
                if)
             else
                SyntaxError
            if)
       exit frag[]
       #);
     pObjDescFrag:
       (# theName,cat,language: ^Name; ODF: ^ObjDescFrag;
       enter(theName[],cat[],language[])
       do 'pObjDescFrag'->trace;
          (theName[],cat[],language[]) -> ObjDescFrag -> ODF[];
          '' -> Name ->  NameApl -> PatternDen -> pObjectDesc -> ODF.OD[] -> ODF.append
       exit ODF[]
       #);
     pDoPartFrag:
       (# theName,cat,language: ^Name; DPF: ^DoPartFrag;
       enter(theName[],cat[],language[])
       do 'pDoPartFrag'->trace;
          lex;
          (theName[],cat[],language[]) -> DoPartFrag -> DPF[];
          pImperatives -> DoPart -> DPF.DP[] -> DPF.append
       exit DPF[]
       #);
     pAttFrag:
       (# theName,cat,language: ^Name; frag: ^AttFrag; 
       enter(theName[],cat[],language[])
       do 'pAttFrag'->trace;
          (theName[],cat[],language[]) -> AttFrag -> frag[];
          (*Attributes -> frag.att[];*)
          pAttributes -> frag.att[] -> frag.append
       exit frag[]
       #);
     pAttributes:
       (# gotDoPartSlot:<
            (# slt: ^Slot;
            enter slt[]
            do inner
            #);
          theName,cat,language: ^Name; att: ^Attributes; slt: ^Slot;
       enter(theName[],cat[],language[])
       do 'pAttributes'->trace;
          Attributes -> att[];
          Loop:
            (#
            do
               (if lex.symb 
                // lex.symbols.semicolon then
                   lex;
                   restart Loop
                // lex.symbols.nonTbegin then
                   (*lex.markPos;*)
                   lex;
                   pSlot -> slt[]; 
                   (*'pAttributes:got:SLOT:'->dumpT;
                   slt.doPT -> dumpT;*)
                   (if slt.isDopart then 
                       (*'isDoPart' ->dumpTN;*)
                       slt[] -> gotDoPartSlot
                    else
                       slt[] -> att.append;  
                       restart Loop
                   if);
                // lex.symbols.doSy
                // lex.symbols.end
                // lex.symbols.enterSy
                // lex.symbols.exitSy 
                // lex.symbols.frag
                // lex.symbols.eos (* obs ok if attributes slot not in objDesc *) then 
                   leave Loop 
                else
                   pBetaDecl -> att.append;
                   restart Loop
               if)               
            #)
       exit att[]
       #);
     pActionPart:
       (# doPartSlot: ^Slot; acp: ^ActionPart; 
          enterP: ^EnterPart; exitP: ^ExitPart; imps: ^Imperatives; slt: ^Slot;
       enter doPartSlot[]
       do 'pActionPart'->trace;
          pEnterPart -> enterP[];
          Imperatives -> imps[];
          (if doPartSlot[] <> none then
              (*'pActionPart:withDoPartSlot'->dumpTN;;*)
              doPartSlot[] -> imps.append
           else
              (if lex.symb 
               // lex.symbols.doSy then
                  lex;
                  pImperatives -> imps[]
               // lex.symbols.nonTbegin then
                  lex;
                  'pActionPart:slot'->trace;
                  pSlot -> slt[] -> imps.append;
                  (*'**** Slot:'->dumpT; slt.doPT->dumpTN;*)
          if)if);
          pExitPart -> exitP[];
          (enterP[],imps[],exitP[]) -> ActionPart -> acp[];
          'pActionPart:end'->trace;
       exit acp[]
       #);
     pEnterPart:
       (# enterP: ^EnterPart; eval: ^Evaluation; 
       do 'pEnterPart'->trace;
          (if lex.symb = lex.symbols.enterSy then
              lex; 
              pEvaluation -> eval[];
              'pEnterPart:after:pEval'->trace;              
           else
              Evaluation -> eval[]
          if);
          eval[] -> EnterPart -> enterP[]
       exit enterP[]
       #);
     pImperatives:
       (# imps: ^Imperatives; slt: ^StdBetaNode;
       do 'pImperatives'->trace;
          Imperatives -> imps[];
          Loop:
            (#
            do (if lex.symb 
                // lex.symbols.semiColon then (* empty imp *) lex; restart Loop 
                // lex.symbols.nonTbegin then
                   lex;
                   pSlot -> slt[];
                   (*'pImperatives:got:slot:'->dumpT; slt.dopt->dumpTN;*)
                // lex.symbols.end 
                // lex.symbols.ifSy
                // lex.symbols.alternative
                // lex.symbols.elseSy
                // lex.symbols.forSy 
                // lex.symbols.exitSy 
                // lex.symbols.eos 
                // lex.symbols.frag then leave Loop 
                   (* perhaps we need to test positive for symbols that may
                    * begin en imperative
                    *)
                else
                   pImperative -> imps.Append
               if);
               restart Loop
            #)
       exit imps[]
       #);
     pImperative:
       (# imp: ^StdBetaNode
       do 'pImperative'->trace;
          (if lex.symb
           // lex.symbols.leftBrack then
              (if lex.nextIsForOrIf then
                  lex;
                  (if lex.symb
                   // lex.symbols.forSy then
                      lex;
                      pForImp -> imp[]
                   // lex.symbols.ifSy then
                      lex;
                      pIfImp -> imp[]
                  if)
               else
                  pEvaluation -> imp[];
              if)
           // lex.symbols.leaveSy then
              lex; 
              pLeaveImp -> imp[]
           // lex.symbols.restartSy then
              lex; 
              pRestartImp -> imp[]
              (* LabelledImp?
               * L: 3 -> a;
               * A -> B;
               *)
           // lex.symbols.innerSy then
              lex;
              pInnerImp -> imp[]
           // lex.symbols.idf then
              'pImperative:idf'->trace;
              (if lex.peek = ':' then
                  pLabelledImp -> imp[];
               else
                  pEvaluation -> imp[];
              if)
           else 
              pEvaluation -> imp[];
          if); 
          'pImperative:end'->trace;
       exit imp[]
       #);
     pExitPart:
       (# exitP: ^ExitPart; eval: ^Evaluation; 
       do 'pExitPart'->trace; 
          (if lex.symb = lex.symbols.exitSy then
              lex; 
              pEvaluation -> eval[]
           else
              Evaluation -> eval[]
          if);
          eval[] -> ExitPart -> exitP[]
       exit exitP[]
       #);
     pSlot:
       (# slt: ^StdBetaNode (*Slot*); name,cat: ^Text;
       do 'pSlot'->trace;
          (if lex.symb = lex.symbols.idf then
              (* must be SLOT *)
              lex;
              'pSlot:A'->trace;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> name[];
                  lex;
                  'pSlot:B'->trace;
                  (if lex.symb = lex.symbols.colon then
                      lex;
                      (if lex.symb = lex.symbols.idf then
                          (* descriptor, attributes, dopart, etc *)
                          lex.sym[] -> cat[];
                          lex;
                          (if true
                           // 'attributes'->cat.equalNCS then
                              (name[],cat[]) 
                              (*-> Slot*)
                                -> AttSlot
                                -> slt[]
                           // 'descriptor'->cat.equalNCS
                           // 'objectDescriptor'->cat.equalNCS then 
                              (name[],cat[]) -> ObjDescSlot -> slt[]
                           // 'doPart'->cat.equalNCS then
                              (name[],cat[]) -> DoPartSlot -> slt[]
                           else
                              '!!! unknown slot category:'->dumpT;
                              cat[] -> dumptn;
                              (name[],cat[]) -> Slot -> slt[]
                          if);
                          (if lex.symb = lex.symbols.nontEnd then
                              lex
                           else
                              syntaxError
                          if)
                       else
                          syntaxerror
                      if)
                   else
                      syntaxError
                  if)
               else
                  syntaxError
              if)
           else
              syntaxError
          if);
          slt[] -> slotCollector.add
       exit slt[]
       #);
     pForImp:
       (# fImp: ^ForImp; inx: ^BetaNameDecl;
          NS:  ^NameDecls; ND: ^BetaNameDecl;
          inxItem: ^ForImpItem; rangee: ^Evaluation; imps: ^Imperatives;
          D: ^BetaDecl;
       do 'pForImp'->trace;
          (if lex.nextISColon then
              pNameDecl -> ND[]; true -> ND.isForInx;
              (if lex.symb = lex.symbols.colon then
                  lex
              if)
           else
              (# 
              do 
                 '-' -> Name -> BetaNameDecl -> ND[];
                 true -> ND.isForInx;
              #);
          if);
          ND[] -> inx[];
          pevaluation -> rangee[];
          pForImpItem -> InxItem[];
          ND[] -> (NameDecls -> NS[]).append;
          (NS[],InxItem[]) -> BetaDecl -> D[];
          
          (if lex.symb = lex.symbols.repeatSy then
              lex; 
              'pForImp:repeat'->trace;
              pImperatives -> imps[];
              'pForImp:after:pImperatives'->trace;
              (if lex.symb = lex.symbols.forSy then
                  lex;
                  (if lex.symb = lex.symbols.rightBrack then
                      lex;
                   else
                      441 -> SyntaxError
                  if)
               else
                  442 -> SyntaxError
              if)
           else
              443 -> SyntaxError
          if);
          (D[],rangee[],imps[]) -> ForImp -> fImp[];
       exit fImp[]
       #);
     mkForImpDecl:
       (# 
       #);
     pForImpItem:
       (# fi: ^ForImpItem
       do ForImpItem -> fi[]
       exit fi[]
       #);
     pIfImp:
       (# iImp: ^IfImp; Eval: ^Evaluation;
          thenPart,elsePart: ^Imperatives; alt: ^Alternatives
       do 'pIfImp' -> trace;
          pEvaluation -> eval[];
          (if lex.symb 
           // lex.symbols.thenSy then
              lex;
              pImperatives -> thenPart[];
              Alternatives -> alt[]
           // lex.symbols.alternative then
              lex;
              pAlternatives -> alt[];
              Imperatives -> thenPart[]
           else (* // ... then ... *)
              501 -> SyntaxError
          if);
          (if lex.symb = lex.symbols.elseSy then
              lex;
              pImperatives -> elsePart[] 
           else
              Imperatives -> elsePart[]
          if);
          (if lex.symb = lex.symbols.ifSy then
              lex; 
              (if lex.symb = lex.symbols.rightBrack then
                  lex; 
               else
                  502 -> syntaxerror
              if)
           else
              503 -> syntaxerror
          if);
          (eval[],thenPart[],elsePart[],alt[]) -> IfImp -> iImp[];
       exit iImp[]
       #);
     pAlternatives:
       (# alt: ^Alternatives
       do 'pAlternatives'->trace;
          Alternatives -> alt[];
          L: (# 
             do pAlternative -> alt.append; 
                (if lex.symb = lex.symbols.alternative then 
                    lex;
                    restart L 
                if)
             #)
       exit alt[]
       #);
     pAlternative:
       (# alt: ^Alternative; sel: ^Selections; imps: ^Imperatives
       do 'pAlternative'->trace;
          pSelections -> sel[];
          (if lex.symb = lex.symbols.thenSy then
              lex;
              pImperatives -> imps[];
          if);
          (sel[],imps[]) -> Alternative -> alt[]          
       exit alt[]
       #);
     pSelections:
       (# sel: ^Selections;
       do'pSelections'->trace;
          Selections -> sel[];
          L: (#
             do pSelection -> sel.append;
                (if lex.symb = lex.symbols.alternative then
                    lex;
                    restart L
                if)
             #)
       exit sel[]
       #); 
     pSelection:
       (# sel: ^Selection
       do 'pSelection'->trace;
          pEvaluation -> Selection -> sel[]
       exit sel[]
       #);
     pLabelledImp:
       (# lImp: ^LabelledImp; lab: ^BetaNameDecl; imp: ^Imperative
       do 'pLabelledImp'->trace;
          pNameDecl -> lab[];
          (if lex.symb = lex.symbols.colon then
              lex
           else
              511  -> SyntaxError
          if);
          pImperative -> imp[];
          (lab[],imp[]) -> LabelledImp -> lImp[];
       exit lImp[]
       #);
     pBreak:
       (# bImp: ^Break; symb: ^NameApl
       do 'pBreak' -> trace;
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> Name -> NameApl -> symb[];
              lex;
              inner;
           else
              700 -> syntaxError
          if)
       exit bImp[]
       #);
     pLeaveImp: pBreak
       (#
       do 'pLeaveImp'->trace;
          symb[] -> LeaveImp -> bImp[];
       #);
     pRestartImp: pBreak
       (#
       do 'pRestartImp'->trace;
          symb[] -> RestartImp -> bImp[];
       #); 
     pInnerImp:
       (# inImp: ^InnerImp;
       do 'pInner'->trace;
          (if lex.symb = lex.symbols.idf then 
              lex.sym[] -> Name -> NameApl -> InnerImp -> inImp[];
              lex
           else
              '' -> Name -> NameApl -> innerImp -> inImp[]
          if)
       exit inImp[]
       #);
     pEvaluation:
       (# eval: ^Evaluation;
       do '*** Evaluation:'->trace;
          Evaluation -> eval[];
          pExp -> eval.append;
          L:
            (if lex.symb = lex.symbols.assign then
                lex;
                'pEvaluation:repeat'->trace;
                pTransaction -> eval.append;
                restart L
            if);
          'pEvaluation:end'->trace;
       exit eval[]
       #);
        
     ExpParser: 
       (# lE,rE: ^Exp; op: @integer;
       do inner 
       exit lE[] 
       #);
     pExp: ExpParser
       (# 
       do 'pExp'->trace;
          pSimpleExp -> lE[];
          (if lex.isRelOp then
              lex.symb -> op;
              lex; 
              pSimpleExp -> rE[];
              (lE[],op,rE[]) -> BetaBinaryExp -> lE[];
          if);
       #);
     pSimpleExp: ExpParser
       (#  
       do 'pSimpleExp'->trace;
          (if lex.isAddOrSub (*or (lex.symb = lex.symbols.adr (* @@X *)
              then 
              lex.Symb -> op;
              lex;
              pTerm -> lE[];
              (op,lE[]) -> BetaUnaryExp -> lE[];
           else
              pTerm -> lE[];
          if);
          Loop:
            (if lex.isAddOp then 
                lex.symb -> op;
                lex; 
                pTerm -> rE[];
                (lE[],op,rE[]) -> BetaBinaryExp -> lE[]; 
                restart Loop
            if);
       #);
     pTerm: ExpParser
       (#
       do 'pTerm'->trace;
          pFactor -> lE[];
          Loop:
            (if lex.isMultOp or (lex.symb = lex.symbols.prim) then
                (if lex.symb = lex.symbols.prim then
                    (* we should mark the operator as primitive for PT *)
                    lex;
                    (if lex.symb <> lex.symbols.idf then
                        SyntaxError
                if)if);
                lex.symb -> op;
                lex; 
                pFactor -> rE[];
                (lE[],op,rE[]) -> BetaBinaryExp -> lE[];
                restart Loop
            if)
       #);
     pFactor: ExpParser
       (* textConst, IntegerConst, NoneExp, 
        *          * not EXP, RepetitionSlice,
        *          * Transaction, UnaryPrimitiveExp
        *          * Are they alle sub of exp/term?
        *          *)
       (#
       do 'pFactor'->trace;
          (if lex.symb
           // lex.symbols.textSy then
              lex.sym[] -> TextExp -> lE[];
              lex;
           // lex.symbols.const then
              'pFactor:const'->trace;
              lex.sym[] -> ConstExp -> lE[];
              lex;
           // lex.symbols.charSy then
              lex.sym[] -> CharExp -> lE[];
              lex;
           // lex.symbols.nott then 
              'pFactor:not'->trace; 
              lex.symb -> op;
              lex;
              pFactor -> lE[];
              (op,lE[]) -> BetaUnaryExp -> lE[]
           // lex.symbols.noneSy then
              noneValue -> lE[];
              lex
           else (* missing repetitionSlice R[e1:e2] *)
              pTransaction -> BetaTerm -> lE[];
          if);
          'pFactor:end'->trace;
       #);     

     pTransaction:
       (* T:: ObjectEvaluation 
        *   | ComputedEval     - R.S!
        *   | ObjRef           - R.S[]
        *   | EvalList         - (E1, E2,E3)
        *   | StrucRef         - R.S##
        *   | Primitive        - tos foo
        *   | Address          - @@ X
        * ObjectEvaluation :: InsItem   - R.P(# ... #) 
        *          |           - (# ... #) 
        *          | Reference 
        * Reference:: ObjDen    - R.PA
        *           | DynObjGen - R.P&
        * ObjDen:: AttributeDenonation       - R.P
        *)
       (# tra: ^Transaction; evl: ^EvaluationList; EV: ^ObjectEvaluation;
          op: @integer; lE: ^Exp
       do 'pTransaction'->trace;
          (if lex.symb 
           // lex.symbols.idf // lex.symbols.begin // lex.symbols.thisObj 
              then
              pObjectEvaluation -> tra[];
              'pTransaction:A'->trace;
              (if lex.symb 
               // lex.symbols.objRef then
                  tra[] -> pObjectReference -> tra[];
                  lex
               // lex.symbols.strucVar then
                  tra[] -> pStructureRef -> tra[];
                  lex
              if);
           // lex.symbols.leftBrack then
              lex; 
              pEvaluationList -> EVL[] -> tra[];
              (if lex.symb = lex.symbols.dot then 
                  (* We come here in sitations like (if (e).f ... *)
                  lex;
                  EVL[] -> pComputedRemote -> tra[];
                  (if lex.symb 
                   // lex.symbols.begin then
                      (* '\n!!!!! In module "' -> puttext;           
                       thisModuleName[] -> puttext;
                       '", ComputedRemote as super may not work!\n' 
                       * -> puttext;
                       3 -> lex.printlines;
                       newline;
                       *)
                      (*tra.markAsSuper;*)
                      (# PD: ^PatternDen; AD: ^NameApl; OE: ^ObjectEvaluation
                      do &PatternDen[] -> PD[];
                         ''-> Name -> NameApl -> AD[];
                         &ObjectEvaluation[] -> OE[];
                         tra[] 
                           -> pComputedRemoteAsDenotation
                           (*-> AD.NA[]
                           -> AD.append;*);
                         AD[] -> PD.AD[] -> PD.append;
                         PD[] -> pObjectDesc -> ObjectEvaluation -> OE[];
                         OE[] -> tra[]
                      #)
                   // lex.symbols.leftSquare then
                      '\npTransaction:Got Indexed "[exp]" after:' -> puttext;
                      tra.dopt -> putline;
                      lex;
                      (if true then 'Bingo'->putline;
                          evaluation;
                          'banko' -> putline;
                          (if lex.symb = lex.symbols.rightSquare then
                              lex
                           else
                              201 -> SyntaxError
                          if)
                       else
                          tra[] -> pComputedRemoteAsDenotation
                           (* -> Indexed*)
              if)if)if)
           // lex.symbols.new then
              lex;
              pDynamicObjectGeneration -> tra[]
           // lex.symbols.prim then 
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex;
                  pFactor -> tra[]
              if)
           // lex.symbols.adr then
              lex;
              pFactor -> tra[]
           else 
              200->syntaxError;
              &Transaction[] -> tra[]
          if);
          'pTransaction:end'->trace; 
       exit tra[]
       #);
     pObjectEvaluation:
       (# objEV: ^ObjectEvaluation; OS: ^BetaObjectSpecification; 
          PD: ^PatternDen;
       do 'pObjectEvaluation'->trace;
          pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
          OS[] -> ObjectEvaluation -> objEV[];
          'pObjectEvaluation:end'->trace;
       exit objEv[]
       #);
     pThisObj:
       (# thisObj: ^ThisObject; tra: ^Transaction; 
          AD: ^AttributeDenotation; EV: ^ObjectEvaluation;
       do 'pThisObj'->trace; 
          (*lex;*)
          (if lex.symb = lex.symbols.leftBrack then
              lex;
              'pThisObj:X'->trace; 
              pNameApl -> AD[]; 
              'pThisObj:Y'->trace; 
              (if lex.symb = lex.symbols.rightBrack then
                  lex;
                  'pThisObj:Z'->trace; 
               else
                  123 -> syntaxError
              if)
           else
              802 -> syntaxError;
              '' -> Name -> NameApl -> AD[]
          if);
          AD[] -> ThisObject -> thisObj[];
          (*
           'pTransaction:thisObj'->trace; 
              (if lex.symb 
               // lex.symbols.objRef then
                  thisObj[] -> pObjectReference -> tra[];
                  lex
               // lex.symbols.strucVar then
                  thisObj[] -> pStructureRef -> tra[];
                  lex
               else
                  thisObj[] -> tra[]
           if)*);
          'pThisObj:end'->trace; 
       exit thisObj[]
       #);
     pObjectReference:
       (# OV: ^StdBetaNode (*AttributeDenotation*); ref: ^ObjectReference
       enter OV[]
       do 'pObjectReference'->trace;
          OV[] -> ObjectReference -> ref[]
       exit ref[]
       #);
     pStructureRef:
       (# OV: ^StdBetaNode (*AttributeDenotation*); ref: ^StructureRef
       enter OV[]
       do 'pStructureRef'->trace;
          OV[] -> StructureRef -> ref[]
       exit ref[]
       #);
     pEvaluationList:
       (# evl: ^EvaluationList
       do 'pEvaluationList'->trace; 
          EvaluationList -> evl[];
          Loop:
            (# 
            do
               pEvaluation -> evl.append;
               (if lex.symb = lex.symbols.comma then
                   lex;
                   restart Loop
            if)#);
          (if lex.symb = lex.symbols.rightBrack then 
              lex
           else 
              601 -> syntaxError 
          if)
       exit evl[]
       #);
     pDynamicObjectGeneration:
       (# OS: ^BetaObjectSpecification; DOG: ^DynamicObjectGeneration; 
          EV: ^Evaluation
       do 'pDynamicObjectGeneration'->trace; 
          (if lex.symb = lex.symbols.component then
              lex; (* should mark as Module *)
          if);
          (# PD: ^PatternDen
          do pPatternDen -> PD[];
             (if lex.symb = lex.symbols.begin then
                 PD.markAsSuper;
                 PD[] -> pObjectDesc -> OS[]
              else
                 PD[] -> OS[] 
             if);
             (if lex.symb = lex.symbols.leftBrack then
                 (if true then
                     pEvaluation -> EV[]
                  else
                     lex;
                     pEvaluation -> EV[];
                     (if lex.symb = lex.symbols.rightBrack then
                         lex
                      else                     
                         222 -> syntaxerror
                 if)if)
              else
                 Evaluation -> EV[]
             if);
             (OS[],EV[]) -> DynamicObjectGeneration -> DOG[];
             (if lex.symb = lex.symbols.objRef then (* Note: Only &P[], not &P
                                                     * We allow &P to be able
                                                     * to parse StdBETA
                                                     *)
                 lex;
                 true -> DOG.isRef
                 (* else
                  (16,(0),(0)) -> SyntaxError*)
             if)
          #)
       exit DOG[]          
       #);
     pComputedRemote:
       (# EVL: ^EvaluationList; NA: ^NameApl; CR: ^ComputedRemote
       enter EVL[]
       do 'pComputedRemove'->trace;
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> Name -> NameApl -> NA[];
              lex
           else
              777 -> syntaxError;
              '' -> Name -> NameApl -> Na[]
          if);
          (EVL[],NA[]) -> ComputedRemote -> CR[]
       exit CR[]          
       #);
     pComputedRemoteAsDenotation:
       (# tra: ^EvaluationList; CRD: ^ComputedRemoteAsDenotation
       enter tra[]
       do
       exit CRD[]          
       #);
     pBetaDecl:
       (# dcl: ^BetaDecl; symb: ^Text; NS: ^NameDecls; IT: ^StdBetaNode
       do 'pBetaDecl' -> trace;
          pNameDecls -> NS[]; 
          (if lex.symb = lex.symbols.colon then
              lex;
              'pBetaDecl:colon'->trace;
              (if lex.symb
               // lex.symbols.object then
                  lex;
                  pStaticItem -> IT[];
                  (NS[],IT[]) -> BetaDecl -> dcl[]
               // lex.symbols.ref then                  
                  lex;
                  pDynamicItem -> IT[];
                  (NS[],IT[]) -> BetaDecl -> dcl[]
               // lex.symbols.lt then
                  lex;
                  NS[] -> pVirtualPattern -> dcl[]
               // lex.symbols.colon then (* X:: *)
                  lex; 
                  (if lex.symb = lex.symbols.lt then  (* X::< *)
                      lex;
                      NS[] -> pFurtherBinding -> dcl[]
                   else (* X :: *)
                      NS[] -> pFinalBinding -> dcl[] 
                      (* potential syntax problem here 
                       *   V: # (# #)
                       * does not give a syntax error
                       * but should not be caught here
                       *)
                  if)
               // lex.symbols.leftSquare then
                  lex;
                  pRepetition -> IT[];
                  (* OBS!!! Perhaps not ok . not tested ! *)
                  (NS[],IT[]) -> BetaDecl -> dcl[]
               // lex.symbols.strucVar then
                  lex;
                  pvarPtn -> IT[];
                  (NS[],IT[]) -> BetaDecl -> dcl[]
               else
                  'pAttribute:idf:colon:PTN'->trace;
                  NS[] -> pPattern -> dcl[];
              if)
           else
              111 -> SyntaxError
          if)
       exit dcl[]
       #);
     pNameDecls:
       (# NS:  ^NameDecls
       do 'pNameDecls'->trace;
          NameDecls -> NS[];
          L:
            (#
            do pNameDecl -> NS.append;
               (if Lex.Symb = Lex.Symbols.Comma Then 
                   Lex;
                   restart L
            if)#)
       exit NS[]
       #);
     pNameDecl:
       (# N: ^BetaNameDecl
       do 'pNameDecl'->trace;
          (if Lex.Symb = Lex.Symbols.Idf Then
              'pNameDecl:idf'->trace;
              Lex.sym[] -> Name -> BetaNameDecl -> N[];
              Lex;
           else
              199 -> SyntaxError
          if)
       exit N[]
       #);
     pStaticItem:
      (# IT: ^StaticItem; 
         PD: ^PatternDen;  OS: ^BetaObjectSpecification; isComponent: @Boolean
      do 'pStaticItem'->trace;
         (if lex.symb = lex.symbols.component then
             lex; 
             true -> isComponent
         if);
         pPatternDen -> PD[];
         (if lex.symb 
          // lex.symbols.begin // lex.symbols.nonTbegin then
             PD[] -> pObjectDesc -> OS[]
          else
             PD[] -> OS[]
         if);
         (OS[],isComponent) -> StaticItem -> IT[]
      exit IT[]
      #);     
     pDynamicItem:
       (# IT: ^DynamicItem; isComponent: @Boolean
       do 'pDynamicItem' -> trace;
          (if lex.symb = lex.symbols.component then
              lex; 
              true -> isComponent
          if);
          (pPatternDen,isComponent) -> DynamicItem -> IT[]
       exit IT[]
       #);
     pRepetition:
       (# inx: ^Index;
          IT: ^StdBetaNode
       do pIndex -> inx[];
          (if lex.symb 
           // lex.symbols.object then
              lex;
              pStaticItem -> IT[] 
           // lex.symbols.ref then
              lex;
              pDynamicItem -> IT[]
           // lex.symbols.strucVar then
              lex;
              pvarPtn -> IT[]
           else
              333 ->  SyntaxError;
              StaticItem -> IT[]
          if);
          (inx[],IT[]) -> Repetition -> IT[]
       exit IT[]
       #);
     pIndex:
       (#  INX: ^Index
       do pEvaluation -> Index -> INX[];
          (if lex.symb = lex.symbols.rightSquare then
              lex
           else
              334 ->  SyntaxError
          if)
       exit INX[]
       #);
     pVarPtn:
       (# VP: ^VarPtn; 
       do 'pVarPtn' -> trace;
          pAttributeDenotation -> VarPtn -> VP[]
       exit VP[]
       #);
     pPattern:
       (# NS: ^NameDecls; OD: ^ObjectDesc; dcl: ^BetaDecl;
       enter NS[]
       do 'pPattern'->trace;
          pPatternDen -> pObjectDesc -> OD[];
          (NS[],OD[]-> BetaPattern) -> BetaDecl -> dcl[];
       exit dcl[]
       #);
     pVirtualSpec:
       (# PD: ^PatternDen; OS: ^BetaObjectSpecification;
       do pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
       exit OS[]
       #);
     pVirtualPattern:
       (# NS: ^NameDecls; PD: ^PatternDen; dcl: ^BetaDecl; 
          OS: ^BetaObjectSpecification;
       enter NS[]          
       do 'pVirtualPattern'->trace;
          pVirtualSpec -> OS[];
          (NS[],OS[]->BetaVirtualPattern) -> BetaDecl -> dcl[];
       exit dcl[]
       #);
     pFurtherBinding:
       (# NS: ^NameDecls; dcl: ^BetaDecl; OS: ^BetaObjectSpecification;
       enter NS[]
       do 'pFurtherBinding'->trace;
          pVirtualSpec -> OS[];
          (NS[],(NS[],OS[])->FurtherBinding) -> BetaDecl -> dcl[];
       exit dcl[]
       #);
     pFinalBinding:
       (# NS: ^NameDecls; dcl: ^BetaDecl; OS: ^BetaObjectSpecification;
       enter NS[]
       do 'pFinalBinding'->trace;
          pVirtualSpec -> OS[];
          (NS[],(NS[],OS[])->FinalBinding) -> BetaDecl -> dcl[];
       exit dcl[]
       #);
     pObjectDesc:
       (# sup: ^PatternDen; symb: ^Text; OD: ^ObjectDesc; 
          doPartSlot,slt: ^Slot;
          att: ^Attributes; acp: ^ActionPart;
       enter sup[]
       do 'pObjectDesc'->trace;
          (if lex.symb 
           // lex.symbols.begin then
              lex;
              'pObjectDesc:begin'->trace;
              pAttributes
              (# gotDoPartSlot::
                   (#
                   do (*'pObjectDesc:pAttributes:gotDoPartsDesc:'->dumpT;
                      slt.doPT -> dumpTN;*)
                      slt[] -> doPartSlot[];
                   #);
              #) -> att[];
              doPartSlot[] -> pActionPart -> acp[];
              'pObjectDesc:after:pActionPart'->trace;
              (sup[],att[],acp[]) -> ObjectDesc -> OD[];
              'pObjectDesc:after:ObjectDesc'->trace;
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  113 -> syntaxError
              if)
           // lex.symbols.nonTbegin then
              lex;
              pSlot -> slt[];
              (*'pObjdesc:got:SLOT:'->dumpT; slt.doPT->dumpTN;*)
              (sup[],Attributes,ActionPart) -> ObjectDesc -> OD[];
              slt[] -> OD.slt[]
          if);
          'pObjectDesc:end'->trace;
       exit OD[]
       #);
     pPatternDen:
       (# ptnDen: ^PatternDen; 
       do 'pPatternDen'->trace;
          true -> pAttributeDenotation -> PatternDen->ptnDen[];
       exit ptnDen[]
       #);
     pAttributeDenotation:
       (# B: @Boolean; NA: ^AttributeDenotation; AD: ^NameApl; 
       enter B
       do 'pAttributeDenotation'->trace;
          (if lex.symb 
           // lex.symbols.idf then
              lex.sym.copy -> Name -> NameApl -> NA[];
              lex;  
           // lex.symbols.thisObj then
              lex;
              pThisObj -> NA[]
           else
              '' -> Name -> NameApl -> NA[]
          if);
          Loop: 
            (#
            do 
               (if lex.symb = lex.symbols.leftSquare then
                   lex;
                   NA[] -> pIndexed -> NA[];
               if);
               (if lex.symb = lex.symbols.dot then
                   lex;
                   NA[] -> pRemote -> NA[];
            if)#);
          'pAttributeDenotation:end'->trace;
       exit NA[]
       #);
     pNameApl:
       (# NA: ^NameApl; 
       do (if lex.symb = lex.symbols.idf then
              lex.sym[] -> Name -> NameApl -> NA[];
              lex
           else
              771 -> syntaxError
          if);
       exit NA[]
       #);
     pIndexed:
       (# NA: ^AttributeDenotation; inx: ^Indexed; EV,uE: ^Evaluation
       enter NA[]
       do 'pIndexed'->trace;
          pEvaluation -> EV[];
          (if lex.symb = lex.symbols.colon then
              (* R[low:high] *)
              lex;
               pEvaluation -> uE[]
            else
               Evaluation -> uE[]
          if);
          (if lex.symb = lex.symbols.rightSquare then
              lex
           else
              202 -> SyntaxError
          if);
          (NA[],EV[],uE[]) -> Indexed -> inx[];
       exit inx[]
       #);
     pRemote:
       (# den: ^AttributeDenotation; rm: ^Remote; sy: ^Text
       enter den[]
       do 'pRemote'->trace;
          Remote -> rm[];
          (#
          do den[] -> rm.append;
             L:
               (if lex.symb 
                // lex.symbols.idf then
                   pAttributeDenotation -> den[] -> rm.append;
                   (if lex.symb = lex.symbols.dot then
                       lex;
                       restart L
                   if)
                // lex.symbols.prim then
                   lex;
                   'pRemote:prim'->trace;
                   (if lex.symb = lex.symbols.idf then
                       lex.sym[] -> sy[];
                       lex;
                       sy[] -> Primitive -> rm.append
                    else
                       syntaxerror
                   if)
          if)#)
       exit rm[]
       #);
     trace:
       (# S: ^Text
       enter S[]
       do (if doTraceParser then
              S[] -> puttext; ':'->put; '\t'->put;
              lex.symb -> putint; ' ' -> put;
              lex.symb -> lex.symbols.asText -> puttext;
              ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
              inner trace
          if)
       #);

     openFragmentFile: (* not used *)
       (# S: ^BetaString; StdPath,fragPath: ^text;
          FD: ^FragmentDir;
          NM: ^Name;
          betaLib: ^StdBetaNode;
       enter S[]
       do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
          (if stdpath[] = none then '!!!! Did not find BETALIB!'->putline if);
          '**** BETALIB: ' -> puttext; StdPath[] -> putline;
          'A fragment' -> Name -> NM[];
          '/' -> (StdPath.copy).append -> fragPath[];
          S.T[] -> fragPath.append -> fragPath[];
          (NM[],fragPath[],'',true) -> FragmentDir -> FD[];
          (NM[],FD[]) -> FragmentModule -> betaLib[];
          '\n**   FD.dopt:'->dumpTN;
          FD.doPT -> putline;
          '\n**   betaLIB:'->dumpTN;
          betaLib.doPT->dumpT;
       #);
     checkFrag:
       (# AST: @AstInterface(# defaultGrammarFinder:: findgrammar #);
          beta: ^AST.beta; FN,currentDir,name,fragPath: ^Text;
          dg: @AST.DependencyGraph;
       enter(FN[],currentDir[])
       do (* init astlevel *)
          AST.astLevelInit;
          &AST.beta[] -> beta[];
          '~beta/grammars/beta/beta' -> name[];
          (name[],'beta',screen[]) -> beta.betagrammarInit; 
          dg.init;
          (if false then
              'nti'->dg.TargetMachine;      
              'nti_ns'->dg.TargetDirectory;
           else
              'qbeta'->dg.TargetMachine;      
              'qbs'->dg.TargetDirectory;

          if);
          (FN[],currentDir[]) -> mkFN -> fragPath[];
          (if doTrace then
              '**** Extent:'->dumpTN;
              fragPath[] -> dumpTN;
              
              fragPath[] -> dg.scanExtent
              (# 
              do current.name -> dumpTN
              #);
              '**** Domain: ' -> dumpTN;
              fragPath[] -> dg.scanDomain
              (# 
              do current.name -> dumpTN
          #)if);
       #);
     mainModule,topModule: ^StdBetaModule;
     currentDir:  ^Text; (* FN is in the folder currentDir *)
  enter currentDir[]
  do (if FN[] = none then 'FN is none'->putline if);
     (FN[],currentDir[]) -> openBetaModule -> mainModule[];
     (*(FN[],currentDir[]) -> checkFrag;*)
     moduleCollector.bindSlots;
     moduleCollector.scan
     (#
     do '**** bindings:XXX:'->dumpT; current.doPT->putheadN;
        current.slots.scan
        (#
        do '**  SLOT:'->dumpT; current.dopt->dumpTN;
           current.scanBindings(#do '**   binding:'->dumpT; 
                                  current.dopt-> putheadN #);
        #);
        newline
     #);
     inner;
     mainModule.dopt -> putline
  exit(mainModule[],topModule[])
  #);
