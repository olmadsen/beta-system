ORIGIN 'qbeta'
---dumpObj:doPart---
do (# trace: (#exit false #);
      length: IntegerValue
        (# lengthOfDcl: integerValue
             (# D: ^compile.DataItem; 
             enter D[]
             do value 
                + D.sig.id.length + 1 (* sig.id + zero *)
                + 4 (* off, kind, size, descNo *)
                  -> value;
                (if D.OG.isValueObj then
                    (if D.OG.IS.isEmpty then
                        (if D.OG.primNo 
                         // integer_prim
                         // char_prim
                         // boolean_prim 
                         // value_prim then
                            value + 1 -> value
                         else
                            ((D.OG.superPtn).OG.IS[] -> length) + value 
                              -> value
                        if)
                     else
                        (D.OG.IS[] -> length) + value -> value
                    if)
                 else
                    value + 1 -> value
                if);
                (*'lengthOf: ' -> puttext; D.doPT -> puttext; ' ' -> put;
                 value -> putint; newline*)
             #);
           
           IS: ^compile.Items; ptn: ^compile.Pattern
        enter IS[]
        do (* get possible declarations in signature
            * (if (IS.sig[] <> none) and (IS.sig. a_rgs[] <> none) then
            IS.sig. a_rgs. scanSons
            (#
            do (current[] -> lengthOfDcl) + value -> value; '!'->put
            #);
            if);*)
           (if false and IS.encOG.isSubOfBasicValue then
               (* add $1 length = 2 + 1 + 4 + 1 = *)
               8 -> value;
           if);
           (if IS.super.ATd[] <> none then
               (if true
                // IS.super.ATD.isPattern then
                   IS.super.ATd[] -> ptn[];
                   (ptn.OG.IS[] -> length) + value -> value
           if)if);
           IS.scanSons
           (# D: ^compile.DataItem; size: @integer
           do (if current.isDataItem then
                  (current[] -> lengthOfDcl) + value -> value
           if)#);
           (if trace then 'length: ' -> puttext; value -> putint; newline if)
        #);
      add:
        (# V: @integer
        enter V
        do v -> items[top + 1 -> top];
        #);
      
      top: @integer;
      
      decode:
        (# decodeDcl:
             (# D: ^compile.DataItem; size,kind: @integer
             enter D[]
             do (if false then 
                    D.newOff -> putint; ':' -> put;
                    D.objSize -> size;
                    (if size = 0 then 1 -> size if);
                    size -> putint; ' ' -> put;
                    D.sig.id[] -> puttext; 
                    (if D.isConst then ' const' -> puttext
                     else ' var' -> puttext
                    if);
                    (if true
                     // D.OG.isPrimitive then ' primitive' -> puttext
                     // D.OG.isValueObj then ' value' -> puttext;
                     else ' ref' -> puttext;
                    if);
                    ' descNo:' -> puttext;
                    D.OG.IS.newDescNo -> putint;
                    newline;
                if);
                (for i: D.sig.id.length repeat 
                     i -> D.sig.id.inxGet -> add
                for);
                0 -> add;
                D.newOff -> add;
                D.objSize -> size;
                (if (size = 0) then 1 -> size if);
                size -> add;
                (if true
                 // D.OG.isPrimitive and (D.primNo <> indexed_prim) then 
                    (if D.isConst then 
                        0 -> kind -> add
                     else 
                        1 -> kind -> add;
                    if);
                 // D.OG.isValueObj then
                    (if D.isConst then 
                        2 -> kind -> add
                     else 
                        3 -> kind -> add;
                    if)
                 else
                    (if D.isConst then 
                        4 -> kind -> add
                     else 
                        5 -> kind -> add;
                    if);
                if);
                D.OG.IS.newDescNo -> add; (* May not be ok, 
                                           * since we changed
                                           * from calling descNo in 
                                           * qvariants
                                           *)
                (if kind // 2 // 3 then
                    (if D.OG.IS.isEmpty then
                        (D.OG.superPtn).OG.IS[] -> decode
                     else
                        D.OG.IS[] -> decode; 
                    if)
                 else
                    0 -> add
                if);
             #);
           IS: ^compile.Items; ptn: ^compile.pattern
        enter IS[]
        do (* get possible declarations in signature *)
           (* Old signature code:
            * (if (IS.sig[] <> none) and (IS.sig._a_rgs[] <> none) then
            *      IS.sig._a_rgs.scanSons(#do current[] -> decodeDcl #);
            * if);
            *)
           (if false and IS.encOG.isSubOfBasicValue then 
               (* add $1 *)
               '$' -> add; '1' -> add; 0 -> add;
               1 -> add; 1 -> add; 1 -> add; 0 -> add;
               0 -> add;
           if);
           (if IS.super.ATd[] <> none then
               (if true
                // IS.super.ATD.isPattern then
                   IS.super.ATd[] -> ptn[];
                   ptn.OG.IS[] -> decode
           if)if);
           IS.scanSons
           (# 
           do (if current.isDataItem then
                  current[] -> decodeDcl;         
              if)
           #);
        #);
      IS: ^compile.Items; 
   do (if trace then '\ndumpObjEvent:'->putline; if);
      (obj.myObjDesc).descInx -> compile.getObjectDesc -> IS[];
      (*IS.doPT -> putline; '---' -> putline;*)
      IS[] -> length -> items.new;
      IS[] -> decode
   #)
   
