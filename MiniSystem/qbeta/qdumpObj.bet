ORIGIN 'qcontrol'
---dumpObj:doPart---
do (# trace: (#exit false #);
      length: IntegerValue
        (# lengthOfDcl:integerValue
             (# lengthOfDcl_single: integerValue
                  (# D: ^compile.DataItem; 
                  enter D[]
                  do value 
                     + D.sig.id.length + 1 (* sig.id + zero *)
                     + 4 (* off, size, kind, descNo *)
                       -> value;
                     (if D.OG.isValueObj then
                         (if D.OG.IS.isEmpty then
                             (if D.OG.primNo 
                              // integer_prim
                              // char_prim
                              // boolean_prim 
                              // value_prim then 
                                 value + 1 -> value
                              // float_prim then
                                 value + 2 -> value
                              else
                                 ((D.OG.superPtn).OG.IS[] -> length) + value 
                                   -> value
                             if)
                          else
                             (D.OG.IS[] -> length) + value -> value
                         if)
                      else
                         value + 1 -> value
                     if);
                     (if trace then
                         'lengthOf: ' -> puttext; D.doPT -> puttext; ' ' -> put;
                         value -> putint; newline
                     if)
                  #);
                lengthOfDcl_nameList: integerValue
                  (# D: ^compile.DataItem; 
                  enter D[]
                  do D.sig.names.scan
                     (#
                     do value 
                        + current.T.length + 1 (* sig.id + zero *)
                        + 4 (* off, kind, size, descNo *)
                          -> value;
                        (if D.OG.isValueObj then
                            (if D.OG.IS.isEmpty then
                                (if D.OG.primNo 
                                 // integer_prim
                                 // char_prim
                                 // boolean_prim 
                                 // value_prim then
                                    value + 1 -> value
                                 // float_prim then
                                    value + 2 -> value (* 1 or 2 - see above*)
                                 else
                                    ((D.OG.superPtn).OG.IS[] -> length) + value 
                                      -> value
                                if)
                             else
                                (D.OG.IS[] -> length) + value -> value
                            if)
                         else
                            value + 1 -> value
                        if);
                        (if trace then
                            'lengthOf: ' -> puttext; current.doPT ->puttext;
                            ' '->put; value -> putint; newline
                        if)
                  #)#); 
                D: ^compile.DataItem; 
             enter D[]
             do (if nameListInDcl then
                    D[] -> lengthOfDcl_nameList -> value
                 else
                    D[] -> lengthOfDcl_single -> value
                if);
                (*value + 1 -> value*)
             #);    
             lengthOfArray: IntegerValue
                (#
                do  '****: '->puttext; 2 -> obj.get -> putint; ' ' -> put; 3 -> obj.get -> putint; newline;
                    arrayStrucSize + (2 -> obj.get) -> value;
                #);
           IS: ^compile.Items; ptn: ^compile.Pattern; ATdx: ^compile.Decl
        enter IS[]
        do (if false and IS.encOG.isSubOfBasicValue then
               (* add $1 length = 2 + 1 + 4 + 1 = *)
               8 -> value;
           if);
           (if IS.encOG.primNo 
           // indexed_prim // rIndexed_prim then
              lengthOfArray -> value
           else
           IS.super.ATd[] -> ATdx[];
           (if ATdx[] <> none then
               (if true
                // ATdx.isPattern then
                   ATdx[] -> ptn[];
                   (ptn.OG.IS[] -> length) + value -> value
           if)if);
           (* get possible declarations in signature*)
           (if (IS.sig[] <> none) then
               IS.sig.scanSons
               (#
               do (if current.isDecl then
                      (current[] -> lengthOfDcl) + value -> value; '!'->put
                  if)
               #)
           if);
           IS.scanSons
           (# D: ^compile.DataItem; size: @integer
           do (if current.isDataItem then
                  (current[] -> lengthOfDcl) + value -> value
           if)#)if);
           (if trace then 'length: ' -> puttext; value -> putint; newline if)
        #);
      add:
        (# V: @integer
        enter V
        do (if (top + 1 -> top) > items.range then
               items.range -> items.extend
           if);
           (if trace then
               'add:'->puttext; top -> putint; '='->put; V -> putint; newline;
           if);
           v -> items[top];
        #);
      
      top: @integer;
      
      decode:
        (# decodeDcl:
             (# D: ^compile.DataItem; size,kind: @integer
             enter D[]
             do (if trace then 
                    '**** decodeDcl:'->dumpT;
                    D.newOff -> putint; ':' -> put;
                    D.objSize -> size;
                    (if size = 0 then 1 -> size if);
                    size -> putint; ' ' -> put;
                    D.sig.id[] -> puttext; 
                    (if D.isConst then ' const' -> puttext
                     else ' var' -> puttext
                    if);
                    (if true
                     // D.OG.isPrimitive then ' primitive' -> puttext
                     // D.OG.isValueObj then ' value' -> puttext;
                     else ' ref' -> puttext;
                    if);
                    ' descNo:' -> puttext; (* need to go super is IS.isEmpty*)
                    D.OG.IS.newDescNo -> putint; (* see below *)
                    newline;
                if);
                (if nameListInDcl then
                    D.sig.names.scan
                    (#
                    do (for i: current.T.length repeat 
                            i -> current.T.inxGet -> add
                       for);
                       0 -> add;
                       current.newOff -> add;
                       D.objSize -> size;
                       (if (size = 0) then 1 -> size if);
                       size -> add;
                       (if true
                        // D.OG.isPrimitive and (D.primNo <> indexed_prim) then 
                           (if D.isConst then 
                               0 -> kind -> add
                            else 
                               1 -> kind -> add;
                           if);
                        // D.OG.isValueObj then
                           (if D.isConst then 
                               2 -> kind -> add
                            else 
                               3 -> kind -> add;
                           if)
                        else
                           (if D.isConst then 
                               4 -> kind -> add
                            else 
                               5 -> kind -> add;
                           if);
                       if);
                       (* the code below is a quick fix: there should be a virtual
                        * getNewDescNo or similar, that handles this:
                        *)
                       (# Dx: ^Compile.Decl
                       do D[] -> Dx[];
                          L:
                            (if Dx.OG.IS.isEmpty then
                                Dx.OG.super.ATd.asDecl -> Dx[];
                                restart L
                             else
                                Dx.OG.IS.newDescNo -> add; 
                                (* May not be ok, 
                                 * since we changed
                                 * from calling descNo 
                                 * in qvariants
                                 *)
                       if)#);
                       (if kind // 2 // 3 then
                           (if D.OG.IS.isEmpty then
                               (D.OG.superPtn).OG.IS[] -> decode;
                            else
                               D.OG.IS[] -> decode;
                           if)
                        else
                           0 -> add;
                           (if (kind <= 1) and (size = 2) then
                               (* float *)
                               (if trace then
                                   '**** float:add 0'->putline;
                               if);
                               0 -> add
                           if)
                       if);
                    #)
                 else
                    (for i: D.sig.id.length repeat 
                         i -> D.sig.id.inxGet -> add;
                    for);
                    0 -> add;
                    D.newOff -> add; 
                    D.objSize -> size;
                    (if (size = 0) then 1 -> size if);
                    size -> add;
                    (if true
                     // D.OG.isPrimitive and (D.primNo <> indexed_prim) then 
                        (if D.isConst then 
                            0 -> kind -> add
                         else 
                            1 -> kind -> add;
                        if);
                     // D.OG.isValueObj then
                        (if D.isConst then 
                            2 -> kind -> add
                         else 
                            3 -> kind -> add;
                        if)
                     else
                        (if D.isConst then 
                            4 -> kind -> add
                         else 
                            5 -> kind -> add;
                        if);
                    if);
                    (* the code below is a quick fix: there should be a virtual
                     * getNewDescNo or similar, that handles this:
                     *)
                    (# Dx: ^Compile.Decl
                    do D[] -> Dx[];
                       L:
                         (if Dx.OG.IS.isEmpty then
                             Dx.OG.super.ATd[] -> Dx[];
                             restart L
                          else
                             Dx.OG.IS.newDescNo -> add; (* May not be ok, 
                                                         * since we changed
                                                         * from calling descNo 
                                                         * in qvariants
                                                         *)
                    if)#);
                    (if kind // 2 // 3 then
                        (if D.OG.IS.isEmpty then
                            (D.OG.superPtn).OG.IS[] -> decode;
                         else
                            D.OG.IS[] -> decode;
                        if)
                     else
                        0 -> add;
                        (if (kind <= 1) and (size = 2) then
                            (* float *)
                            (if trace then
                                '**** float:add 0'->putline;
                            if);
                            0 -> add
                        if)
                    if);                    
                if);
             #);
           IS: ^compile.Items; ptn: ^compile.pattern
        enter IS[]
        do (if trace then 
               '**** decode:' -> putline
           if);
           (if IS.super.ATd[] <> none then
               (if true
                // (IS.super.ATd.asDecl).isPattern then
                   IS.super.ATd.asDecl -> ptn[];
                   ptn.OG.IS[] -> decode;
           if)if);
           (* get possible declarations in signature *)
           (if (IS.sig[] <> none) then
               IS.sig.scanSons
               (#
               do (if current.isDecl then
                      current[] -> decodeDcl;
           if)#)if);
           (if false and IS.encOG.isSubOfBasicValue then 
               (* add $1 *)
               '$' -> add; '1' -> add; 0 -> add;
               1 -> add; 1 -> add; 1 -> add; 0 -> add;
               0 -> add;
           if);
           IS.scanSons
           (# 
           do (if current.isDataItem then 
                  current[] -> decodeDcl;         
              if)
           #);
        #);
      plainObjSnap: (# exit 0 #);
      valueArraySnap: (# exit 1 #);
      refArraySnap: (# exit 2 #);
      IS: ^compile.Items; lg:@integer
   do (if trace then '\ndumpObjEvent:'->putline; if);
      (obj.myObjDesc).descInx -> compile.getObjectDesc -> IS[];
      (if trace then
          IS.doPT -> putHeadN; '---' -> putline;
          IS.encOG.primNo -> putint; newline
      if);
      (if IS.encOG.primNo // indexed_prim // rIndexed_prim then
               (IS[] -> length) + 1  -> items.new;
               '**** after length -> items.new:'->puttext; items.range -> putint; newline;
               (if IS.encOG.primNo = indexed_prim then 
                   valueArraySnap -> objKind 
               else 
                   refArraySnap -> objKind 
               if);
               objKind -> items[1]; 1 -> top;
       else
         (IS[] -> length) + 1 -> lg -> items.new; 
         plainObjSnap -> objKind -> items[1]; 1 -> top;
         IS[] -> decode; 
      if);
   #)
   
