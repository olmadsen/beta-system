ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qabstractSyntaxTree';
---lib:attributes---

readNumber:
  (# T: ^text; N:@integer
  enter T[]
  do T.setPos; T.getInt -> N
  exit N
  #);
UnitTree:
  (# token: @integer; op: ^text;
     left,right: ^UnitTree;
     replaceUnitVar:
       (# unitVal: ^text; UTv: ^UnitTree;
       enter unitVal[]
       do (if false then
              '**** replaceUnitVal: ' -> puttext; unitVal[] -> putline;
          if);
          unitVal[] -> parseUnit -> UTv[] -> replace;
          (if false then
              '** replaceUnitVar:done: ' -> puttext; 
              true -> print -> putline
          if)
       #);
     replace:
       (# UTv: ^UnitTree
       enter UTv[]
       do (if false then
              '**    replace: ' -> puttext; UTv.print -> puttext; 
              ' in: ' -> puttext; print -> putline;
          if);
          (if (left[] <> none) then
              (if (left.token = var) then
                  UTv[] -> left[]
               else
                  UTv[] -> left.replace
          if)if);
          (if (right[] <> none) then
              (if (right.token = var) then
                  UTv[] -> right[]
               else
                  UTv[] -> right.replace
          if)if)
       #);
     print:
       (# withB: @boolean; T: @text
       enter withB
       do (if left[] <> none then 
              (if withB then '(' -> T.put if);
              withB -> left.print -> T.append
          if);
          op[] -> T.puttext;
          (if right[] <> none then 
              withB -> right.print -> T.append;
              (if withB then ')' -> T.put if);
          if);
       exit T[]
       #)
  enter(token,op[],left[],right[])
  exit this(UnitTree)[]
  #);

eos: (# exit 0 #);
idf: (#exit 1 #);
mult: (#exit 2 #);
divv: (#exit 3 #);
expT: (#exit 4 #);
plus: (# exit 5 #);
minus: (# exit 6 #);
number: (# exit 7 #);
leftBracket: (# exit 8 #);
rightBracket: (# exit 9 #);
var: (# exit 10 #);

parseUnit:
  (# lex: 
       (# nextCh:
            (#
            do (if U.eos then
                   255 -> ch
                else
                   U.get -> ch
               if);
               pos + 1 -> pos
            #);
          readName:
            (#
            do (if (ch -> ascii.isLetter) or (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readName
               if)
            #);
          readNumber:
            (#
            do (if (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readNumber
               if)
            #);          
         token: @integer; T: ^text
       do 
          L:
            (if ch <= ' ' then 
                nextCh;
                restart L
            if);
          &text[] -> T[];
          (if true 
           // (ch = '#') or (ch -> ascii.isLetter) then
              ch -> T.put;
              nextCh;
              readName;
              idf -> token
           // ch -> ascii.isDigit then
              ch -> T.put;
              nextCh;
              readNumber;
              number -> token
           // ch = '$' then
              ch -> T.put;
              nextCh;
              var -> token
           else
              (if ch = 255 then
                  eos -> token;
               else
                  ch -> T.put;
                  (if ch
                   // '*' then mult -> token
                   // '/' then divv -> token
                   // '^' then expT -> token
                   // '+' then plus -> token
                   // '-' then minus -> token
                   // '(' then leftBracket -> token
                   // ')' then rightBracket -> token
                   else
                      eos -> token
                  if);
                  nextCh
          if)if);
       exit(token,T[])
       #);

     expression:
       (# left,right: ^UnitTree; Tx: ^Text; TK: @integer
       do term -> left[];
          L: 
            (if token // plus // minus then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                term -> right[]; 
                (* call expression instead as left associative, see term *)
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];                
                restart L
             else
                (if false and (token <> eos) then
                    '**** Syntax error: Eos expected pos: ' -> puttext;
                    pos -> putint; ' length: ' -> puttext; U.length -> putint;
                    ' ' -> put; U[] -> putline; T[] -> putline
                if);
            if);
       exit left[]
       #);
     term:
       (# left,right: ^UnitTree; Tx: ^text; TK: @integer
       do factor -> left[];
          L: 
            (if token // mult // divv then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                term -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
             else 
                (if false and (token <> eos) then
                    '**** syntax error: Eos expected pos: ' -> puttext;
                    pos -> putint; ' length: ' -> puttext; U.length -> putint;
                    ' ' -> put; U[] -> putline; T[] -> putline
            if)if)
       exit left[]
       #);
     factor:
       (# left,right: ^UnitTree; TK: @integer
       do expo -> left[];
          L: 
            (if token // expT then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]); 
                (if false then
                    '**** expT: ' -> puttext; token -> putint; 
                    ' ' -> put; T[] -> putline;
                if);
                expo -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
            if);
       exit left[]
       #);
     expo:
       (# left,right: ^UnitTree
       do (if token
           // idf // number // var then
              (token,T[],none,none) -> UnitTree -> left[];
              lex -> (token,T[]);
           // minus then
              lex -> (token,T[]);
              (if token = number then
                  '-' -> T.prepend;
                  (token,T[],none,none) -> UnitTree -> left[];
                  lex -> (token,T[]);                  
               else
                  'number expected' -> reportSyntaxError
              if)
           // leftBracket then
              lex -> (token,T[]);
              expression -> left[];
              (if false then
                  '**** expo: ' -> puttext; token -> putint; 
                  ' ' -> put; T[] -> putline;
              if);
              (if token = rightBracket then
                  lex -> (token,T[]);
               else
                  'right bracket expected' -> reportSyntaxError
              if)
           else
              'No legal token found' -> reportSyntaxError
          if)
       exit left[]
       #);
     reportSyntaxError:
       (# msg: ^text
            enter msg[]
       do '**** Syntax error:' -> puttext;  
          msg[] -> puttext;
          ' pos: ' -> puttext;
          pos -> putint; ' length: ' -> puttext; U.length -> putint;
          ' ' -> put; U[] -> putline; T[] -> putline
       #);
     ch: @char;
     token,opT: @integer;
     opr,Tx,T: ^text;
     Lft,right,node: ^UnitTree;
     U: ^text; pos: @integer
  enter U[]
  do (if false then
         'A / B + C/D/E' -> U[];
         (* 'a + b^2^3  + x * c^2 * y * (K +J)' -> U[]; *)
     if);
     (*'**** parse: ' -> puttext; U[] -> putline;*)
     U.setPos;
     lex -> (token,T[]);
     expression -> node[];
     (if token <> eos then
         'Eos expected pos: ' -> reportSyntaxError
     if)
  exit node[]
  #)

