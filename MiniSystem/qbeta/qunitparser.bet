ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qabstractSyntaxTree';
---lib:attributes---

readNumber:
  (# T: ^text; N:@integer
  enter T[]
  do T.setPos; T.getInt -> N
  exit N
  #);
UnitTree:
  (# token: @integer; op: ^text;
     left,right: ^UnitTree;
     replaceUnitVar:
       (# unitVal: ^text; UTv: ^UnitTree;
       enter unitVal[]
       do (if false then
              '**** replaceUnitVal: ' -> puttext; unitVal[] -> putline;
          if);
          unitVal[] -> parseUnit -> UTv[] -> replace;
          (if false then
              '** replaceUnitVar:done: ' -> puttext; 
              true -> print -> putline
          if)
       #);
     replace:
       (# UTv: ^UnitTree
       enter UTv[]
       do (if false then
              '**    replace: ' -> puttext; UTv.print -> puttext; 
              ' in: ' -> puttext; print -> putline;
          if);
          (if (left[] <> none) then
              (if (left.token = var) then
                  UTv[] -> left[]
               else
                  UTv[] -> left.replace
          if)if);
          (if (right[] <> none) then
              (if (right.token = var) then
                  UTv[] -> right[]
               else
                  UTv[] -> right.replace
          if)if)
       #);
     elimDiv:
       (# R: ^UnitTree
       do (if token = divv then
              (*  / (A,B) -> * (A, ^(B,-1) *)
              (number,'-1',none,none) -> UnitTree -> R[];
              (expT,'^', right[],R[]) -> UnitTree -> right[];
              mult -> token; '*' -> op[]
          if);
          (if left[] <> none then left.elimDiv if);
          (if right[] <> none then right.elimDiv if);
       #);
     reduceExp:
       (#
          R: ^UnitTree; newLeft: ^UnitTree; N1,N2: @integer
       do
          (if token = mult then
              (if (right.token = expT) and (right.left.token = idf) then
                  right.right.op[] -> readNumber -> N1;
                  (if traceUE then
                      '**   tryElim: ' -> puttext; right.left.op[] -> puttext;
                      ' ' -> put; N1 -> putint; newline;
                  if);
                  right.left.op[] -> left.elimExp -> (newLeft[],N2);
                  (if newLeft[] <> none then
                      (if traceUE then
                          '**   new expT: ' -> puttext; N1 + N2 -> putint; newline;
                      if);
                      &text[] -> right.right.op[];
                      N1 + N2 ->  right.right.op.putint;
                      newLeft[] -> left[]
                  if)
               else
                  left.reduceExp
              if)
          if)
       #);                  
     elimExp:
       (# id: ^text; newLeft,nx: ^UnitTree; N1,N2: @integer
       enter id[]
       do (if token = mult then
              (if (right.token = expT) and (right.left.token = idf) then
                  (if id[] -> right.left.op.equalNCS then
                      right.right.op[] -> readNumber -> N1;
                      (if traceUE then
                           '**   match: ' -> puttext;
                          N1 -> putint; newline;
                       if);
                      '0' -> right.right.op[];
                      left[] -> newLeft[]
                  if);
                  id[] -> left.elimExp -> (nx[],N2); (**** <<<<<< *)
                  N1 + N2 -> N1
          if)if)
       exit(newLeft[],N1)
       #);                  
     print:
       (# withB: @boolean; T: @text
       enter withB
       do (if left[] <> none then 
              (if withB then '(' -> T.put if);
              withB -> left.print -> T.append
          if);
          op[] -> T.puttext;
          (if right[] <> none then 
              withB -> right.print -> T.append;
              (if withB then ')' -> T.put if);
          if);
       exit T[]
       #)
  enter(token,op[],left[],right[])
  exit this(UnitTree)[]
  #);

canonicalize:
  (* no loner used *)
  (# U: ^text; top: ^UnitTree
  enter U[]
  do (if (U[] <> none) and (U.length > 0) then
         (if traceUE then
             '\n**** canonicalize: ' -> puttext; U[] -> puttext; newline
         if);
         U[] -> parseUnit -> top[];
         (if traceUE then
             '**   print: ' -> puttext;
             top.print -> putline;
             '**   after elimDiv:' ->  puttext;
         if);
         top.elimDiv;
         (if traceUE then true -> top.print -> putline; if);
         top.reduceExp;
         top.print -> U[];
         (if true
          // 'UU' -> U.equal then 'U' -> U[] 
          // 'mU' -> U.equal then 'm' -> U[]; '!!!! Got "mU"' -> putline;
          // 'm*m' -> U.equal then 'm2' -> U[] 
         if);
         (if traceUE then
             ' --> ' -> puttext;
             U[] -> putline;
         if)
     if)
  exit U[]
  #);
eos: (# exit 0 #);
idf: (#exit 1 #);
mult: (#exit 2 #);
divv: (#exit 3 #);
expT: (#exit 4 #);
plus: (# exit 5 #);
minus: (# exit 6 #);
number: (# exit 7 #);
leftBracket: (# exit 8 #);
rightBracket: (# exit 9 #);
var: (# exit 10 #);

parseUnit:
  (# lex: 
       (# nextCh:
            (#
            do (if U.eos then
                   255 -> ch
                else
                   U.get -> ch
               if);
               pos + 1 -> pos
            #);
          readName:
            (#
            do (if (ch -> ascii.isLetter) or (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readName
               if)
            #);
          readNumber:
            (#
            do (if (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readNumber
               if)
            #);          
         token: @integer; T: ^text
       do 
          L:
            (if ch <= ' ' then 
                nextCh;
                restart L
            if);
          &text[] -> T[];
          (if true 
           // (ch = '#') or (ch -> ascii.isLetter) then
              ch -> T.put;
              nextCh;
              readName;
              idf -> token
           // ch -> ascii.isDigit then
              ch -> T.put;
              nextCh;
              readNumber;
              number -> token
           // ch = '$' then
              ch -> T.put;
              nextCh;
              var -> token
           else
              (if ch = 255 then
                  eos -> token;
               else
                  ch -> T.put;
                  (if ch
                   // '*' then mult -> token
                   // '/' then divv -> token
                   // '^' then expT -> token
                   // '+' then plus -> token
                   // '-' then minus -> token
                   // '(' then leftBracket -> token
                   // ')' then rightBracket -> token
                   else
                      eos -> token
                  if);
                  nextCh
          if)if);
       exit(token,T[])
       #);

     expression:
       (# left,right: ^UnitTree; Tx: ^Text; TK: @integer
       do term -> left[];
          L: 
            (if token // plus // minus then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                term -> right[]; 
                (* call expression instead as left associative, see term *)
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];                
                restart L
             else
                (if false and (token <> eos) then
                    '**** Syntax error: Eos expected pos: ' -> puttext;
                    pos -> putint; ' length: ' -> puttext; U.length -> putint;
                    ' ' -> put; U[] -> putline; T[] -> putline
                if);
            if);
       exit left[]
       #);
     term:
       (# left,right: ^UnitTree; Tx: ^text; TK: @integer
       do factor -> left[];
          L: 
            (if token // mult // divv then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                term -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
             else 
                (if false and (token <> eos) then
                    '**** syntax error: Eos expected pos: ' -> puttext;
                    pos -> putint; ' length: ' -> puttext; U.length -> putint;
                    ' ' -> put; U[] -> putline; T[] -> putline
            if)if)
       exit left[]
       #);
     factor:
       (# left,right: ^UnitTree; TK: @integer
       do expo -> left[];
          L: 
            (if token // expT then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]); 
                (if false then
                    '**** expT: ' -> puttext; token -> putint; 
                    ' ' -> put; T[] -> putline;
                if);
                expo -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
            if);
       exit left[]
       #);
     expo:
       (# left,right: ^UnitTree
       do (if token
           // idf // number // var then
              (token,T[],none,none) -> UnitTree -> left[];
              lex -> (token,T[]);
           // minus then
              lex -> (token,T[]);
              (if token = number then
                  '-' -> T.prepend;
                  (token,T[],none,none) -> UnitTree -> left[];
                  lex -> (token,T[]);                  
               else
                  'number expected' -> reportSyntaxError
              if)
           // leftBracket then
              lex -> (token,T[]);
              expression -> left[];
              (if false then
                  '**** expo: ' -> puttext; token -> putint; 
                  ' ' -> put; T[] -> putline;
              if);
              (if token = rightBracket then
                  lex -> (token,T[]);
               else
                  'right bracket expected' -> reportSyntaxError
              if)
           else
              'No legal token found' -> reportSyntaxError
          if)
       exit left[]
       #);
     reportSyntaxError:
       (# msg: ^text
            enter msg[]
       do '**** Syntax error:' -> puttext;  
          msg[] -> puttext;
          ' pos: ' -> puttext;
          pos -> putint; ' length: ' -> puttext; U.length -> putint;
          ' ' -> put; U[] -> putline; T[] -> putline
       #);
     ch: @char;
     token,opT: @integer;
     opr,Tx,T: ^text;
     Lft,right,node: ^UnitTree;
     U: ^text; pos: @integer
  enter U[]
  do (if false then
         'A / B + C/D/E' -> U[];
         (* 'a + b^2^3  + x * c^2 * y * (K +J)' -> U[]; *)
     if);
     (*'**** parse: ' -> puttext; U[] -> putline;*)
     U.setPos;
     lex -> (token,T[]);
     expression -> node[];
     (if token <> eos then
         'Eos expected pos: ' -> reportSyntaxError
     if)
  exit node[]
  #)

