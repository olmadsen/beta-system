ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'
---lib:attributes---
traceUE: (# exit false #);
getNumber:
  (# T: ^text; N:@integer
  enter T[]
  do T.setPos; T.getInt -> N
  exit N
  #);
UnitTree:
  (# token: @integer;op: ^text;
     left,right: ^UnitTree;
     elimDiv:
       (# R: ^UnitTree
       do (if token = divv then
              (*  / (A,B) -> * (A, ^(B,-1) *)
              (number,'-1',none,none) -> UnitTree -> R[];
              (exp,'^', right[],R[]) -> UnitTree -> right[];
              mult -> token; '*' -> op[]
          if);
          (if left[] <> none then left.elimDiv if);
          (if right[] <> none then right.elimDiv if);
       #);
     reduceExp:
       (#
          R: ^UnitTree; newLeft: ^UnitTree; N1,N2: @integer
       do
          (if token = mult then
              (if (right.token = exp) and (right.left.token = idf) then
                  right.right.op[] -> getNumber -> N1;
                  (if traceUE then
                      '**   tryElim: ' -> puttext; right.left.op[] -> puttext;
                      ' ' -> put; N1 -> putint; newline;
                  if);
                  right.left.op[] -> left.elimExp -> (newLeft[],N2);
                  (if newLeft[] <> none then
                      (if traceUE then
                          '**   new exp: ' -> puttext; N1 + N2 -> putint; newline;
                      if);
                      &text[] -> right.right.op[];
                      N1 + N2 ->  right.right.op.putint;
                      newLeft[] -> left[]
                  if)
               else
                  left.reduceExp
              if)
          if)
       #);                  
     elimExp:
       (# id: ^text; newLeft,nx: ^UnitTree; N1,N2: @integer
       enter id[]
       do (if token = mult then
              (if (right.token = exp) and (right.left.token = idf) then
                  (if id[] -> right.left.op.equalNCS then
                      right.right.op[] -> getNumber -> N1;
                      (if traceUE then
                           '**   match: ' -> puttext;
                          N1 -> putint; newline;
                       if);
                      '0' -> right.right.op[];
                      left[] -> newLeft[]
                  if);
                  id[] -> left.elimExp -> (nx[],N2); (**** <<<<<< *)
                  N1 + N2 -> N1
          if)if)
       exit(newLeft[],N1)
       #);                  
     print:
       (# withB: @boolean; T: @text
       enter withB
       do (if left[] <> none then 
              (if withB then '(' -> T.put if);
              withB -> left.print -> T.append
          if);
          op[] -> T.puttext;
          (if right[] <> none then 
              withB -> right.print -> T.append;
              (if withB then ')' -> T.put if);
          if);
       exit T[]
       #)
  enter(token,op[],left[],right[])
  exit this(UnitTree)[]
  #);
canonicalize:
  (# U: ^text; top: ^UnitTree
  enter U[]
  do (if (U[] <> none) and (U.length > 0) then
         (if traceUE then
             '\n**** canonicalize: ' -> puttext; U[] -> puttext; 
         if);
         U[] -> parseUnit -> top[];
         (if traceUE then
             '**   print: ' -> puttext;
             top.print -> putline;
             '**   after elimDiv:' ->  puttext;
         if);
         top.elimDiv;
         (if traceUE then true -> top.print -> putline; if);
         top.reduceExp;
         top.print -> U[];
         (if traceUE then
             ' --> ' -> puttext;
             U[] -> putline;
         if)
     if)
  exit U[]
  #);
eos: (# exit 0 #);
idf: (#exit 1 #);
mult: (#exit 2 #);
divv: (#exit 3 #);
exp: (#exit 4 #);
plus: (# exit 5 #);
minus: (# exit 6 #);
number: (# exit 7 #);
leftBracket: (# exit 8 #);
rightBracket: (# exit 9 #);

parseUnit:
  (# lex: 
       (# nextCh:
            (#
            do (if U.eos then
                   255 -> ch
                else
                   U.get -> ch
               if);
            #);
          readName:
            (#
            do (if (ch -> ascii.isLetter) or (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readName
               if)
            #);
          readNumber:
            (#
            do (if (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readNumber
               if)
            #);          
         token: @integer; T: ^text
       do 
          L:
            (if ch <= ' ' then 
                nextCh;
                restart L
            if);
          &text[] -> T[];
          (if true 
           // (ch = '#') or (ch -> ascii.isLetter) then
              ch -> T.put;
              nextCh;
              readName;
              idf -> token
           // ch -> ascii.isDigit then
              ch -> T.put;
              nextCh;
              readNumber;
              number -> token
           else
              (if ch = 255 then
                  eos -> token;
               else
                  ch -> T.put;
                  (if ch
                   // '*' then mult -> token
                   // '/' then divv -> token
                   // '^' then exp -> token
                   // '+' then plus -> token
                   // '-' then minus -> token
                   // '(' then leftBracket -> token
                   // ')' then rightBracket -> token
                   else
                      eos -> token
                  if);
                  nextCh
          if)if)
       exit(token,T[])
       #);

     expression:
       (# left,right: ^UnitTree; Tx: ^Text; TK: @integer
       do term -> left[];
          L: 
            (if token // plus // minus then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                term -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];                
                restart L
            if);
       exit left[]
       #);
     term:
       (# left,right: ^UnitTree; Tx: ^text; TK: @integer
       do factor -> left[];
          L: 
            (if token // mult // divv then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                factor -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
             else 
                (if token <> eos then
                    '**** syntax error: Eos expected' -> putline
            if)if)
       exit left[]
       #);
     factor:
       (# left,right: ^UnitTree; TK: @integer
       do expo -> left[];
          L: 
            (if token // exp then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                factor -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
            if);
       exit left[]
       #);
     expo:
       (# left,right: ^UnitTree
       do (if token
           // idf // number then
              (token,T[],none,none) -> UnitTree -> left[];
              lex -> (token,T[]);
           // minus then
              lex -> (token,T[]);
              (if token = number then
                  '-' -> T.prepend;
                  (token,T[],none,none) -> UnitTree -> left[];
                  lex -> (token,T[]);                  
               else
                  '*** syntax error: number expected' -> putline
              if)
           // leftBracket then
              lex -> (token,T[]);
              expression -> left[];
              (if token = rightBracket then
                  lex -> (token,T[]);
               else
                  '**** syntax error: right bracket expected' -> putline
              if)
           else
              '**** syntax error' -> putline;
          if)
       exit left[]
       #);
     ch: @char;
     token,opT: @integer;
     opr,Tx,T: ^text;
     Lft,right,node: ^UnitTree;
     U: ^text;
  enter U[]
  do (if false then
         'A / B + C/D/E' -> U[];
         (*
          'a + b^2^3  + x * c^2 * y * (K +J)' -> U[];
          *)
     if);
     U.setPos;
     lex -> (token,T[]);
     expression -> node[];
  exit node[]
  #)

