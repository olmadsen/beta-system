ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'
---lib:attributes---
UnitTree:
  (# token: @integer;op: ^text;
     left,right: ^UnitTree;
     elimDiv:
       (# R: ^UnitTree
       do (if token = divv then
              (*  / (A,B) -> * (A, ^(B,-1) *)
              (number,'-1',none,none) -> UnitTree -> R[];
              (exp,'^', right[],R[]) -> UnitTree -> right[];
              mult -> token; '*' -> op[]
          if);
          (if left[] <> none then left.elimDiv if);
          (if right[] <> none then right.elimDiv if);
       #);
     print:
       (#
       do (if left[] <> none then 
               '(' -> put;
              left.print 
          if);
          op[] -> puttext;
          (if right[] <> none then 
              right.print;
              ')' -> put;
          if);
       #)
  enter(token,op[],left[],right[])
  exit this(UnitTree)[]
  #);
canonicalize:
  (# U: ^text; top: ^UnitTree
  enter U[]
  do (if false and (U[] <> none) and (U.length > 0) then
         '\n**** canonicalize: ' -> puttext; U[] -> putline;
         U[] -> parseUnit -> top[];
         '**   print: ' -> puttext;
         top.print;
         newline;
         '**   after elimDiv:' ->  puttext;
         top.elimDiv;
         top.print;
         newline
     if)
  #);
eos: (# exit 0 #);
idf: (#exit 1 #);
mult: (#exit 2 #);
divv: (#exit 3 #);
exp: (#exit 4 #);
plus: (# exit 5 #);
minus: (# exit 6 #);
number: (# exit 7 #);
leftBracket: (# exit 8 #);
rightBracket: (# exit 9 #);

parseUnit:
  (# lex: 
       (# nextCh:
            (#
            do (if U.eos then
                   255 -> ch
                else
                   U.get -> ch
               if);
            #);
          readName:
            (#
            do (if (ch -> ascii.isLetter) or (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readName
               if)
            #);
          readNumber:
            (#
            do (if (ch -> ascii.isdigit) then
                   ch -> T.put;
                   nextCh;                        
                   restart readNumber
               if)
            #);          
         token: @integer; T: ^text
       do 
          L:
            (if ch <= ' ' then 
                nextCh;
                restart L
            if);
          &text[] -> T[];
          (if true 
           // (ch = '#') or (ch -> ascii.isLetter) then
              ch -> T.put;
              nextCh;
              readName;
              idf -> token
           // ch -> ascii.isDigit then
              ch -> T.put;
              nextCh;
              readNumber;
              number -> token
           else
              (if ch = 255 then
                  eos -> token;
               else
                  ch -> T.put;
                  (if ch
                   // '*' then mult -> token
                   // '/' then divv -> token
                   // '^' then exp -> token
                   // '+' then plus -> token
                   // '-' then minus -> token
                   // '(' then leftBracket -> token
                   // ')' then rightBracket -> token
                   else
                      eos -> token
                  if);
                  nextCh
          if)if)
       exit(token,T[])
       #);

     expression:
       (# left,right: ^UnitTree; Tx: ^Text; TK: @integer
       do term -> left[];
          L: 
            (if token // plus // minus then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                term -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];                
                restart L
            if);
       exit left[]
       #);
     term:
       (# left,right: ^UnitTree; Tx: ^text; TK: @integer
       do factor -> left[];
          L: 
            (if token // mult // divv then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                factor -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
             else 
                (if token <> eos then
                    '**** syntax error' -> putline
            if)if)
       exit left[]
       #);
     factor:
       (# left,right: ^UnitTree; TK: @integer
       do expo -> left[];
          L: 
            (if token // exp then
                T[] -> Tx[];
                token -> TK;
                lex -> (token,T[]);
                factor -> right[];
                (TK,Tx[],left[],right[]) -> UnitTree -> left[];
                restart L
            if);
       exit left[]
       #);
     expo:
       (# left,right: ^UnitTree
       do (if token
           // idf // number then
              (token,T[],none,none) -> UnitTree -> left[];
              lex -> (token,T[]);
           // leftBracket then
              lex -> (token,T[]);
              expression -> left[];
              (if token = rightBracket then
                  lex -> (token,T[]);
               else
                  '**** syntax error' -> putline
              if)
           else
              '**** syntax error' -> putline;
          if)
       exit left[]
       #);
     ch: @char;
     token,opT: @integer;
     opr,Tx,T: ^text;
     Lft,right,node: ^UnitTree;
     U: ^text;
  enter U[]
  do '**   parse: ' -> puttext;
     (if false then
         'A / B + C/D/E' -> U[];
         (*
          'a + b^2^3  + x * c^2 * y * (K +J)' -> U[];
          *)
     if);
     U.setPos;
     lex -> (token,T[]);
     expression -> node[];
     newline;


  exit node[]
  #)

