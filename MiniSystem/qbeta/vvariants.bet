ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qrestrictions';
---lib:attributes---
variants: restrictions
  (#
     Module::<
       (# Qalloc:: (#do (varNo,IT[]) -> DI.Qalloc #);
       #);
     ModuleItem::<
       (# Qalloc:: 
            (# 
            do (if isChecked then (varNo,IT[]) -> MD.Qalloc if)
            #);          
       #);
     Value::< 
       (# Qalloc:: (# do scanSons(#do (varNo,IT[]) -> current.Qalloc #)#)#);
     DataItem::<
       (# Qalloc:: 
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   IT.qsize[varNo] + 1 -> IT.qsize[varNo] -> qoff[varNo];
               if);
               (varNo,IT[]) -> sig.Qalloc;
               (varNo,IT[]) -> OG.Qalloc
            #);
          NewOff:
            (# V: @integer
            do (if newAlloc then
                   qoff[1] -> V
                else
                   off -> V
               if)
            exit V
            #);
       #);
     Signature::<
       (# Qalloc:: 
            (# 
            do (if type[] <> none then
                   (varNo,IT[]) -> type.Qalloc
               if);
               (if args[] <> none then
                   (varNo,IT[]) -> args.Qalloc
               if);
               (if val[] <> none then
                   (varNo,IT[]) -> val.Qalloc;
               if)
            #);
       #);
     Arguments::<
       (# Qalloc:: (# do  scanSons(#do (varNo,IT[]) -> current.Qalloc #)#);
       #);
     ObjectGenerator::<
       (# Qvariants: @
            (# var: [1] ^Variant; top: @integer; 
               new:
                 (# V: ^Variant
                 do (if (top + 1 -> top) > var.range then
                        var.range -> var.extend
                    if);
                    Variant -> var[top][] -> V[];
                    top -> V.varNo
                 exit V[]
                 #);
               add:
                 (# VD,BD: ^Pattern
                 enter(VD[],BD[])
                 do (*(if (top + 1 -> top) > var.range then
                        var.range -> var.extend
                    if);
                    Variant -> var[top][];*)
                    (VD[],BD[]) -> var[top].add
                 #);
               topVarExists: booleanValue
                 (* Check if var[top] is in var[1], ..., var[top - 1 *)
                 (#
                 do (*(if top > 0 then '\n*** topVarExists:' -> putline if);*)
                    (for i : top - 1 repeat
                         (if (var[i][] -> var[top].equal -> value) then
                             (*'var alreday exists'->putline;*)
                             top - 1 -> top;
                             leave topVarExists
                    if)for);
                    (*' new var'->putline;*)
                 #);
               propagateToSuper:
                 (# ptn: ^Pattern; superOG: ^ObjectGenerator; 
                    superVar: ^Variant
                 do (if super[] <> none then
                        (if super.ATd[] = none then
                            (*'ptn is none:'->putline;
                             dopt -> putline*)
                         else
                            (if super.ATd## 
                             // DataItem## then 
                                (* understand this!? apparently in
                                 * X := V
                                 * 'Dataitem:'->putline; dopt -> putline;
                                 * '------------' ->putline;
                                 * father.father.dopt -> putline;
                                 *)
                             // Pattern## then
                                '\n** propagateToSuper: ' -> putline;
                                super.ATd[] -> ptn[];
                                ptn.doPT -> printhead;
                                ptn.OG[] -> superOG[];
                                superOG.Qvariants.new -> superVar[];
                                (for i: var[top].top repeat
                                     (var[top].vDcl[i][],var[top].binding[i][]) 
                                       -> superVar.add
                                for);
                                (*superOG.Qvariants.topVarExists;*)
                                superOG.Qvariants.checkIfTopIsNew
                    if)if)if)
                 #);
               checkIfTopIsNew:
                 (#
                 do (if not topVarExists then
                        'Added new variant' -> putline;
                        (* We should add this variant to the ObjTmpStack 
                         * But declared in vgenerator
                         * And we should do it for each superclass
                         *)
                        propagateToSuper
                     else
                        'Variant already exists' -> putline
                    if)
                 #);
               print:
                 (#
                 do (if (top > 0) and (var[1].top > 0) then 
                        'NoOf variants:'-> puttext; top -> putint; newline;
                        (for i: top repeat
                             var[i].print
                    for)if)
                 #)     
            #);
          Qalloc::
            (# E:^Exp
            do (varNo,IT[]) -> super.Qalloc;
               (* some addBinding in checker:OG:alloc *)
               super.scanSons(# do current[] -> E[] #);
               (if (E[] <> none) and (E.ATd[] <> none) then 
                   E[] -> E.ATd.handleArgs  (* !!!*)
               if);
               (if isObjectDesc then
                   this(ObjectGenerator)[] -> QnewDesc -> IS.QdescNo[varNo];
                   (varNo,IT[]) -> IS.Qalloc 
               if);               
            #);
       #);
     items::<
       (# newDescNo:
            (# dNo: @integer
            do (if false and newAlloc then
                   QdescNo[1] -> dNo
                else
                   descNo -> dNo
               if)
            exit dNo 
            #);          
          Qalloc:: 
            (#
            do (if varNo > noOfVar then
                   1 -> qsize.extend;
                   noOfVar + 1 -> noOfVar
               if);
               
               (* 'Items:Qalloc: varNo: ' -> puttext; varNo -> putint;*)
               (if super.ATd[] <> none then
                   (if superDesc[] = none then
                       'Items:alloc: ' -> puttext; dopt ->putline
                   if);
                   (*superDesc.vsize -> vsize;*)
                   superDesc.qsize[varNo] -> qsize[varNo];
                   (*superDesc.dsize -> dsize; *)
                   (if super.isThisBlockLevel and 
                       (not super.isImplSuper) and (not super.isSingularImplSuper)
                       then
                       superDesc.qOriginOff[varNo] -> qOriginOff[varNo] 
                    else
                       qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo] 
                   if)
                else
                   qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo] 
               if);
               (*' originOff: ' -> puttext; newOriginOff -> putint; newline;*)
               (if sig[] <> none then
                   (varNo,this(items)[]) -> sig.Qalloc
               if);
               scanSons(# do (varNo,this(items)[]) -> current.Qalloc #)
            #);
          newOriginOff: 
            (# orgOff: @integer
            do (if newAlloc then
                   qOriginOff[1] -> orgOff
                else
                   originOff -> orgOff
               if)
            exit orgOff
            #);
          qsize: [1] @integer; 
          qOriginOff: [1] @integer;
          noOfVar: @integer;
       #);
     Pattern::<
       (# Qalloc:: (# do (varNo,IT[]) -> OG.Qalloc (* more stuff in checker:ptn:alloc *) #);
       #);
     Invocation::<
       (# Qalloc:: (# do scanSons(# do (varNo,IT[]) -> current.Qalloc #) #);
       #);
     ObjectInvocation::<
       (# Qalloc:: (# do scanSons(#do (varNo,IT[]) -> current.Qalloc #) #);
       #);
     BracketedExp::<
       (# Qalloc:: (# do (varNo,IT[]) -> IV.Qalloc #);
       #);
     Const::<
       (# #);
     CharObj::< (# #);
     StringObj::< (# #);
     Variant:
       (# varNo: @integer;
          vDcl: [1]  ^Pattern; top: @integer;
          type: [1] @ integer;
          size: [1] @ integer;
          binding: [1] ^Pattern;
          add:
            (# VD,BD: ^Pattern
            enter(VD[],BD[])
            do L:
                 (if true then
                     (for i: top repeat
                          (if VD[] = vDcl[i][]  then
                              (* already a binding of VD *)
                              (if BD[] <> binding[i][] then
                                  '\n*** inconsitent virtual binding' 
                                    -> putline
                          if)if);
                          leave L
                     for);
                     (if (top + 1 -> top) > vDcl.range then
                         vDcl.range -> vDcl.extend;
                         type.range -> type.extend;
                         size.range -> size.extend;
                         binding.range -> binding.extend; 
                     if);
                     VD[] -> vDcl[top][];
                     -1 -> type[top];
                     -1 -> size[top];
                     BD[] -> binding[top][]
                 if)
            #); 
          noMatch: booleanValue
            (# B1,B2: ^Pattern
            enter(B1[],B2[])
            do (* instead of integer_prim we must check if value-type *)
               (if B1.OG.primNo = integer_prim then
                   B2.OG.primNo <>  integer_prim -> value
                else
                   B2.OG.primNo = integer_prim -> value
               if)
            #);
          equal: booleanValue
            (# V: ^Variant
            enter V[]
            do (if top > 0 then
                   '\nVariant: equal: ' -> putline;
                   print;
                   '-----' -> putline;
                   V.print;
                   '====='->putline;
               if);
               (for i: top repeat
                    (for j: V.top repeat
                         (if vDcl[i][] = V.vDcl[j][] then
                             '>>>' -> puttext; 
                             binding[i].dopt -> puttext; ' == ' -> puttext;
                             V.binding[i].dopt -> putline;
                             (if ((binding[i][],V.binding[j][])) -> noMatch 
                                 then
                                 (*' noMatch: ' ->putline;*)
                                 false -> value;
                                 leave equal
                              else
                                 (*' match'->putline*)
               if)if)for)for);
               true -> value
            #);
          print:
            (#
            do 'Variant: ' -> putline;
               (for i: top repeat
                    vDcl[i].doPT -> puttext; ' :: ' -> puttext;
                    binding[i].doPT -> putline
               for)
            #);
       exit this(Variant)[]
       #);
     QnewDesc: @
       (# getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectGenerator
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
          OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;          
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
  do 

     inner
  #)
