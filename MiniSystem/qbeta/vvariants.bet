ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qrestrictions';
---lib:attributes---
variants: restrictions
  (#
     Module::<
       (# Qalloc:: (#do (varNo,IT[]) -> DI.Qalloc #);
       #);
     ModuleItem::<
       (# Qalloc:: 
            (# 
            do (* '\n***ModuleItem:Qalloc: ' -> putline;
               doPT -> printHead;*)
               (if isChecked then (varNo,IT[]) -> MD.Qalloc if)
            #);          
       #);
     Value::< 
       (# Qalloc:: (# do scanSons(#do (varNo,IT[]) -> current.Qalloc #)#)#);
     DataItem::<
       (# Qalloc:: 
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   (if varNo < IT.qsize.range then
                       1 -> IT.qsize.extend;
                       1 -> qoff.extend
                   if);
                   IT.qsize[varNo] + 1 -> IT.qsize[varNo] -> qoff[varNo];
               if);
               (varNo,IT[]) -> sig.Qalloc;
               (*(if not dynAlloc then
                   (varNo,IT[]) -> OG.Qalloc
               if)*)
            #);
          NewOff:
            (# V: @integer
            do (if newAlloc then
                   qoff[1] -> V
                else
                   off -> V
               if)
            exit V
            #);
       #);
     Signature::<
       (# Qalloc:: 
            (# 
            do (if type[] <> none then
                   (varNo,IT[]) -> type.Qalloc
               if);
               (if args[] <> none then
                   (varNo,IT[]) -> args.Qalloc
               if);
               (if val[] <> none then
                   (varNo,IT[]) -> val.Qalloc;
               if)
            #);
       #);
     Arguments::<
       (# Qalloc:: (# do  scanSons(#do (varNo,IT[]) -> current.Qalloc #)#);
       #);
     ObjectGenerator::<
       (# Qalloc::
            (* Should be called when genClass for this OG is called *)
            (# E:^Exp; ptn: ^Pattern
            do (* '\n***OG:Qalloc:'->putline; label -> putline;
                doPT -> printHead;
                *)
               (if newAlloc then(*
                   (if Qvariants.var[varNo].allocDone then
                       '***** OG:QallocDone: ' -> puttext;
                       dopt -> printHead;
                       true -> Qvariants.var[varNo].allocDone
                   if);*)
                   (if (IS.superDesc[] <> none) and (IS.superDesc.newDescNo = 0) then
                       (* superDesc is always a pattern *)
                       IS.superDesc.father.father[] -> ptn[];

                       (if ptn[] <> objectDecl[] then
                           (1,none) -> ptn.OG.Qalloc;
                   if)if)
                else '#'->put;
                   (varNo,IT[]) -> super.Qalloc;
               if);
               (* some addBinding in checker:OG:alloc *)
               super.scanSons(# do current[] -> E[] #);
               (if (E[] <> none) and (E.ATd[] <> none) then 
                  (* (if E.on > 0 then
                       'E:on: ' -> puttext; 
                       E.on -> putint; ' ' -> put;
                       E.dopt -> puttext;
                       newline;
                   if);*)
                   E[] -> E.ATd.handleArgs  (* !!!*)
               if);
               (if isObjectDesc then 
                   (*'\n*** OG:Qalloc:QnewDesc:varNo: ' -> puttext;
                   varNo -> putint;*)
                   (if varNo > IS.qDescNo.range then
                      (* ' extend-range: '->puttext;*)
                       (* should be done in items:Qalloc*)
                       1 -> IS.QDescNo.extend
                   if);
                 (*  ' range:' -> puttext;
                  IS.QdescNo.range -> putint; *)
                   
                   this(ObjectGenerator)[] -> QnewDesc -> IS.QdescNo[varNo];
                   
                   (*' descNo:'->puttext;
                   IS.QdescNo[varNo]->putint; newline;*)
                   (varNo,IT[]) -> IS.Qalloc 
               if);               
            #);   
          hasVariants: BooleanValue(# do not Qvariants.isEmpty -> value #);
          Qvariants: @
            (# var: [1] ^Variant; top: @integer; 
               new:
                 (# V: ^Variant
                 do (* '\n***** ObjectGenerator: Qgen:Computing variants:' 
                     * -> putline; doPT -> printhead ; *)
                    (if (top + 1 -> top) > var.range then
                        var.range -> var.extend;
                    if);
                    Variant -> var[top][] -> V[];
                    top -> V.thisVarNo;
                 exit V[]
                 #);
               
               scanObjectRefs:
                 (# trace: (# exit true #);
                    head: @boolean;         
                    ATd: ^Decl; on,pn: @integer; Px: ^OGpath;
                    callingOG: ^ObjectGenerator; V: ^Variant
                 enter(callingOG[],V[])
                 do addBinding.scanObjectRefs
                    (# DI: ^DataItem; OGx,qual: ^ObjectGenerator; org: ^Items
                    do (if trace and not head then                          
                           '\n**** ObjectGenerator:Qgen:scanObjectRefs:'->putline; 
                           dopt -> printhead;
                           '\>>> callingOG:'->putline;
                           callingOG.dopt -> printhead;
                           true -> head
                       if);
                       (if trace then
                          '>>>> DataItem:with:ObjectQ:\n    ' -> puttext;
                          current.doPT -> putline;
                       if);
                       current[] -> DI[];
                       (* DI = R: ? elm where elm :< Object 
                        * Find actual binding of elm in the context of this OG
                        * Execute getV_qual(Invocation(R)) in this(OG)
                        *)
                       (if trace then
                           '>>>> theOG: ' -> putline;
                           this(ObjectGenerator).doPT -> putline;
                       if);
                       (* DI.sig.id = R *)
                       (*(DI.sig.id[],true) -> IS.search -> (ATd[],on,pn);*)
                       (* (on,pn) = path from IS to R: ? elm where on = 0 
                        * But why do we need this path?
                        * It seems that if on=0, we dont need it
                        * But do we have a case where on > 0? Probably yes:
                        *    List:
                        *       elm:< Object
                        *       item:
                        *          E: ? elm   
                        *          next: ? item
                        * Looks like the case with R:= V in insert
                        * Must have a closer look here!?
                        *)
                       (if trace then
                           'Search: ' -> puttext; DI.sig.id[] -> puttext;
                           ' '-> put; on -> putint; 
                           ' ' -> put; pn -> putint; newline;
                       if);
                       (* the code below is the same as in
                        * Invocation:getV_qual
                        * Should be unified
                        *)
                       (this(ObjectGenerator)[],0,pn,none) 
                         -> OGpath
                         -> DI.OG.super.ATd.pathToDcl 
                         -> px[];
                       px.qual[] -> qual[];
                       (DI.OG.super.ATd[],qual.father[]) -> V.add;
                       (if trace then
                           '>>>> Qual:'->puttext; qual.doPT -> putline; newline;
                       if)
                    #);
                    V[] -> scanObjectInvs
                 #);
               encOG:
                 (# OG: ^ObjectGenerator; N: ^Node
                 enter OG[]
                 do OG.father[] -> N[];
                    L:
                      (if N## = ObjectGenerator## then
                          N[] -> OG[]
                       else
                          N.father[] -> N[];
                          (if N[] = none then
                              '\n\nOBS! encOG:no enclosing OG: ' -> puttext; 
                           else
                              restart L
                          if);
                      if)
                 exit OG[]
                 #);
               addPair:
                 (# V: ^Variant; OI: ^OBjectInvocation;
                    
                    DI: ^DataItem; ptn: ^Pattern; ITx: ^Items;
                    OGx,qual: ^ObjectGenerator;
                    ATd: ^Decl; on,pn: @integer; Px: ^OGpath;
                 enter(V[],OI[])
                 do '\n\n****Addpair: '->puttext;  OI.doPT -> puttext;
                    (' on: ',OI.on) -> putTI;
                    (' pn: ',OI.pn) -> putTI;
                    '\n---In items: ' -> putline;
                    IS.dopt -> putline;
                    (if OI.ATD.isPattern then
                        '\n**OI.ATd is pattern:\n'->puttext;
                        OI.ATd.doPT -> printhead;
                        OI.ATd[] -> ptn[];
                        (ptn.sig.id[],true) -> IS.search -> (ATd[],on,pn);
                     else
                        '\n**OI.ATd is dataitem:\n'->puttext;
                        OI.ATd.doPT -> printhead;
                        OI.ATD[] -> DI[];
                        (DI.sig.id[],true) -> IS.search -> (ATd[],on,pn);
                    if);
                    (if atd[] = none then 'atd is none' ->putline 
                     else
                        '**ATd:'->putline;
                        atd.dopt -> putline;
                        (' on: ',OI.on) -> putTI;
                        (' pn: ',OI.pn) -> putTI;
                        (* the code below is the same as in
                         * Invocation:getV_qual
                         * Should be unified
                         *)
                    if);
                    (if OI.ATD.isPattern then
                     else
                        this(OBjectGenerator)[] -> OGx[];
                        (for i: on repeat
                             OGx[] -> encOG -> OGx[]
                         for);
                        '\nOG^on:\n' -> puttext;
                        OGx.dopt -> printHead;
                        (OGx[],on,pn,none) 
                          -> OGpath
                          -> DI.OG.super.ATd.pathToDcl 
                          -> px[];
                        px.qual[] -> qual[];
                        (DI.OG.super.ATd[],qual.father[]) -> V.add;
                        (if true then
                            '\n>>>> Qual:'->puttext; qual.doPT -> putline; newline;
                        if)                    
                    if)
                 #);
               scanObjectInvs:
                 (* addPair is not sufficient as it is for dataIem
                  * Consider
                  * List:
                  *    elm:?Object
                  *    R: ?elm
                  *    insert(V: ?elm):
                  *       R:= V  
                  * When in OG for insert, we are not in the right context
                  * Should probably be
                  *    Lrecord.insert(..)
                  *       ...
                  *       R:= V -- consider this OG as singular
                  *       -- when finding qualification of R and V
                  *)
                 (#
                    V: ^Variant
                 enter V[]
                 do addBinding.scanObjectInvs
                    (#
                    do (* current is an OI as in S := R 
                        * Find S : ^V where V:< Object
                        * Them find binding of V
                        *)
                       (* '\nscanObjectInvs: '-> puttext; 
                        current.father.dopt->putline;*)
                       (* ATd may be a dataItem as in : 'R := V'
                        * or a pattern as in: 'body' *)
                       (V[],current[]) -> addPair

                    #)
                 #);
               findSuperVar:
                 (# V,sV: ^Variant
                 enter V[]
                 do L:
                      (for i: top repeat
                           (if V[] -> var[i].equal then
                               (*'\n*** match:'->putline; print;*)
                               var[i][] -> sV[];
                               leave L
                      if)for);                             
                 exit SV[]
                 #);
               topVarExists: booleanValue
                 (* Check if var[top] is in var[1], ..., var[top - 1 *)
                 (#
                 do (*(if top > 0 then '\n*** topVarExists:' -> putline if);*)
                    (for i : top - 1 repeat
                         (if (var[i][] -> var[top].equal -> value) then
                             (*'var alreday exists'->putline;*)
                             top - 1 -> top;
                             leave topVarExists
                    if)for);
                    (*' new var'->putline;*)
                 #);
               propagateToSuper:
                 (# ptn: ^Pattern; superOG: ^ObjectGenerator; 
                    superVar: ^Variant
                 do (* we should only prtopagateToSuer if super has
                     * virtual Objects as in the variant
                     *)
                    (if super[] <> none then
                        (if super.ATd[] = none then
                            (*'ptn is none:'->putline;
                             dopt -> putline*)
                         else
                            (if super.ATd## 
                             // DataItem## then 
                                (* understand this!? apparently in
                                 * X := V
                                 * 'Dataitem:'->putline; dopt -> putline;
                                 * '------------' ->putline;
                                 * father.father.dopt -> putline;
                                 *)
                             // Pattern## then
                                (*'\n** propagateToSuper: ' -> putline;*)
                                super.ATd[] -> ptn[];
                                (if ptn[] = objectDecl[] then
                                    (* do not propagate to Object *)
                                    '\n***OBS! No propagation to Object'->putline;
                                    leave propagateToSuper
                                if);
                                (*ptn.doPT -> printhead;*)
                                ptn.OG[] -> superOG[];
                                superOG.Qvariants.new -> superVar[];
                                (for i: var[top].top repeat
                                     (var[top].vDcl[i][],var[top].binding[i][]) 
                                       -> superVar.add
                                for);
                                (*superOG.Qvariants.topVarExists;*)
                                superOG.Qvariants.checkIfTopIsNew
                    if)if)if)
                 #);
               checkIfTopIsNew:
                 (#
                 do (if not topVarExists and not isEmpty then
                        (* 'Added new variant' -> putline;*)
                        (* We should add this variant to the ObjTmpStack 
                         * But declared in vgenerator
                         * And we should do it for each superclass
                         *)
                        (if top > IS.QdescNo.range then
                            1 -> IS.QDescNo.extend;
                        if);
                        propagateToSuper
                    (* else
                        'Variant already exists' -> putline*)
                    if)
                 exit var[top][]
                 #);
               isEmpty: booleanValue
                 (#
                 do (*not ((top > 0) and (var[1].top > 0)) -> value;*)
                    true -> value;
                    (for i: top repeat 
                         (if var[i].top > 0 then
                             false -> value;
                             leave isEmpty
                    if)for)
                 #);
               print:
                 (#
                 do (if (top > 0) and (var[1].top > 0) then 
                        '\n*** OG: ' -> puttext; OGid -> puttext;
                        ' NoOf variants:'-> puttext; top -> putint; newline;
                        (for i: top repeat
                             var[i].print
                    for)if)
                 #) ;
                printAll:
                 (#
                 do 
                        'NoOf variants:'-> puttext; top -> putint; newline;
                        (for i: top repeat
                             var[i].print
                        for)
                 #) ;
            #);
       #);
     items::<
       (# thisVar: ^Variant;
          newDescNo:
            (# dNo: @integer
            do (if newAlloc then
                   (if thisVar[] <> none then
                       QdescNo[thisVar.thisVarNo] -> dNo
                    else
                       QdescNo[1] -> dNo
                   if)
                else
                   descNo -> dNo
               if)
            exit dNo 
            #);          
          Qalloc:: 
            (#
            do (if varNo > noOfVar then
                   1 -> qsize.extend;
                   1 -> qOriginOff.extend;
                   noOfVar + 1 -> noOfVar
               if);
               
               (* 'Items:Qalloc: varNo: ' -> puttext; varNo -> putint;*)
               (if super.ATd[] <> none then
                  (* '\n*** HasSuper:\n'->puttext; dopt -> printhead;*)
                   (if superDesc[] = none then
                       'Items:alloc: ' -> puttext; dopt ->putline
                   if);
                   (*superDesc.vsize -> vsize;*)
                   superDesc.qsize[varNo] -> qsize[varNo];
                   (*superDesc.dsize -> dsize; *)
                   (if super.isThisBlockLevel and 
                       (not super.isImplSuper) and (not super.isSingularImplSuper)
                       then
                       superDesc.qOriginOff[varNo] -> qOriginOff[varNo] 
                    else
                       qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo] 
                   if);
                   (*'***originOff:'->puttext; qOriginOff[varNo] -> putint; ; newline*)
                else
                   qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo] 
               if);
               (*' originOff: ' -> puttext; newOriginOff -> putint; newline;*)
               (if sig[] <> none then
                   (varNo,this(items)[]) -> sig.Qalloc
               if);
               scanSons(# do (varNo,this(items)[]) -> current.Qalloc #)
            #);
          newOriginOff: 
            (# orgOff: @integer
            do (if newAlloc then
                   qOriginOff[1] -> orgOff
                else
                   originOff -> orgOff
               if)
            exit orgOff
            #);
          qsize: [1] @integer; 
          qOriginOff: [1] @integer;
          noOfVar: @integer;
       #);
     Pattern::<
       (# Qalloc:: 
            (# 
            do (if newAlloc then
                   (if isBasic then
                       (*'\n*** pattern:qalloc: ' -> putline;
                       doPT -> printHead;*)
                       (if OG.IS.newDescNo = 0 then
                           (varNo,IT[]) -> OG.Qalloc; 
                           (* more stuff in checker:ptn:alloc *)
                       if);
                       (*
                       (if IT[] <> none then
                           'descNo: ' -> puttext; IT.newDescNo -> putint; newline
                       if)*)
                    else
                       (if ptnKind
                        // plainPtn then                 
                        // virtualPtn then
                           (* Is theere a more genral way to handle this *)
                           (if not OG.hasItems  then
                               (if (OG.super.desc).newDescNo = 0 then
                                   '(OG.super.desc).newDescN0 = 0' -> cd.comment;
                                   (# ptn: ^Pattern
                                   do OG.super.ATd[] -> ptn[];
                                      (1,none) -> ptn.OG.Qalloc;
                                      cd.com(#
                                            do (OG.super.desc).newDescNo -> I
                                            #);
                                   #);
                           if)if)
                        // furtherPtn // finalPtn then                           
                       if)
                   if)
                else
                   (varNo,IT[]) -> OG.Qalloc (* more stuff in checker:ptn:alloc *) 
               if)
            #);
       #);
     Invocation::<
       (# Qalloc:: 
            (# 
            do '\n*** Invocation:Qalloc:' -> puttext; dopt -> putline;
               scanSons(# do (varNo,IT[]) -> current.Qalloc #) #);
       #);
     ObjectInvocation::<
       (# Qalloc:: 
            (# 
            do '\n*** ObjectInvocation:Qalloc:' -> puttext; dopt -> putline;
               scanSons(#do (varNo,IT[]) -> current.Qalloc #) #);
       #);
     BracketedExp::<
       (# Qalloc:: (# do (varNo,IT[]) -> IV.Qalloc #);
       #);
     Const::<
       (# #);
     CharObj::< (# #);
     StringObj::< (# #);
     Variant:
       (# thisVarNo: @integer;
          vDcl: [1]  ^Pattern; top: @integer;
          type: [1] @ integer;
          size: [1] @ integer;
          binding: [1] ^Pattern;
          PN: @integer; (* path to super with vDcl *)
          allocDone,genDone: @boolean;
          add:
            (# VD,BD: ^Pattern
            enter(VD[],BD[])
            do L:
                 (if true then
                     (for i: top repeat
                          (if VD[] = vDcl[i][]  then
                              (* already a binding of VD *)
                              (if BD[] <> binding[i][] then
                                  '\n*** inconsitent virtual binding' 
                                    -> putline
                          if)if);
                          leave L
                     for);
                     (if (top + 1 -> top) > vDcl.range then
                         vDcl.range -> vDcl.extend;
                         type.range -> type.extend;
                         size.range -> size.extend;
                         binding.range -> binding.extend; 
                     if);
                     VD[] -> vDcl[top][];
                     -1 -> type[top];
                     -1 -> size[top];
                     BD[] -> binding[top][]
                 if)
            #); 
          noMatch: booleanValue
            (# B1,B2: ^Pattern
            enter(B1[],B2[])
            do (* instead of integer_prim we must check if value-type *)
               (if B1.OG.primNo = integer_prim then
                   B2.OG.primNo <>  integer_prim -> value
                else
                   B2.OG.primNo = integer_prim -> value
               if)
            #);
          equal: booleanValue
            (# V: ^Variant
            enter V[]
            do (if top > 0 then
                  (* '\nVariant: equal: ' -> putline;
                   print;
                   '-----' -> putline;
                   V.print;
                   '====='->putline;*)
               if);
               (for i: top repeat
                    (for j: V.top repeat
                         (if vDcl[i][] = V.vDcl[j][] then
                            (* '>>>' -> puttext; 
                             binding[i].dopt -> puttext; ' == ' -> puttext;
                             V.binding[i].dopt -> putline;*)
                             (if ((binding[i][],V.binding[j][])) -> noMatch 
                                 then
                                 (*' noMatch: ' ->putline;*)
                                 false -> value;
                                 leave equal
                              else
                                 (*' match'->putline*)
               if)if)for)for);
               true -> value
            #);
          print:
            (#
            do 'Variant: ' -> putline;
               (for i: top repeat
                    vDcl[i].doPT -> puttext; ' :: ' -> puttext;
                    binding[i].doPT -> putline
               for)
            #);
       exit this(Variant)[]
       #);
     QnewDesc: @
       (# getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectGenerator
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
          OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;          
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
  do 

     inner
  #)
