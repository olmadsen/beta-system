ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qrestrictions';
---lib:attributes---
variants: restrictions
  (#
     Module::<
       (# Qalloc:: (#do (varNo,IT[]) -> DI.Qalloc #);
       #);
     ModuleItem::<
       (# Qalloc:: 
            (# 
            do (if isChecked then (varNo,IT[]) -> MD.Qalloc if)
            #);          
       #);
     Value::< 
       (# Qalloc:: (# do scanSons(#do (varNo,IT[]) -> current.Qalloc #)#)#);
     DataItem::<
       (# Qalloc:: 
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   IT.qsize[varNo] + 1 -> IT.qsize[varNo] -> qoff[varNo];
               if);
               (varNo,IT[]) -> sig.Qalloc;
               (varNo,IT[]) -> OG.Qalloc
            #);
          NewOff:
            (# V: @integer
            do (if newAlloc then
                   qoff[1] -> V
                else
                   off -> V
               if)
            exit V
            #);
       #);
     Signature::<
       (# Qalloc:: 
            (# 
            do (if type[] <> none then
                   (varNo,IT[]) -> type.Qalloc
               if);
               (if args[] <> none then
                   (varNo,IT[]) -> args.Qalloc
               if);
               (if val[] <> none then
                   (varNo,IT[]) -> val.Qalloc;
               if)
            #);
       #);
     Arguments::<
       (# Qalloc:: (# do  scanSons(#do (varNo,IT[]) -> current.Qalloc #)#);
       #);
     ObjectGenerator::<
       (# Qvariants: @
            (# Var: [1] ^Variant; top: @integer; 
              
             (*  varExists: booleanValue
                 (# VD,BD: ^Pattern
                 enter(VD[],BD[])
                 do L:
                      (for i: top repeat
                           (if VD[] = Var[i].vDcl[] then
                               ( * already a binding of VD * )
                               (if BD[] <> var[i].binding[] then
                                   '\n*** inconsitent virtual binding' 
                                     -> putline
                           if)if);
                           leave L
                                 
              #);*)
               new:
                 (# V: ^Variant
                 do (if (top + 1 -> top) > var.range then
                        var.range -> var.extend
                    if);
                    Variant -> var[top][] -> V[];
                 exit V[]
                 #);
               Add:
                 (# VD,BD: ^Pattern
                 enter(VD[],BD[])
                 do (if (top + 1 -> top) > var.range then
                        var.range -> var.extend
                    if);
                    Variant -> var[top][];
                    (VD[],BD[]) -> var[top].add
                 #);
               print:
                 (#
                 do (if (top > 0) and (var[1].top > 0) then 
                        'NoOf variants:'-> puttext; top -> putint; newline;
                        (for i: top repeat
                             var[i].print
                    for)if)
                 #)     
            #);
          Qalloc::
            (# E:^Exp
            do (varNo,IT[]) -> super.Qalloc;
               (* some addBinding in checker:OG:alloc *)
               super.scanSons(# do current[] -> E[] #);
               (if (E[] <> none) and (E.ATd[] <> none) then 
                   E[] -> E.ATd.handleArgs  (* !!!*)
               if);
               (if isObjectDesc then
                   (varNo,IT[]) -> IS.Qalloc 
               if);               
            #);
       #);
     items::<
       (# Qalloc:: 
            (#
            do (if varNo > noOfVar then
                   1 -> qsize.extend;
                   noOfVar + 1 -> noOfVar
               if);
               
               (* 'Items:Qalloc: varNo: ' -> puttext; varNo -> putint;*)
               (if super.ATd[] <> none then
                   (if superDesc[] = none then
                       'Items:alloc: ' -> puttext; dopt ->putline
                   if);
                   (*superDesc.vsize -> vsize;*)
                   superDesc.qsize[varNo] -> qsize[varNo];
                   (*superDesc.dsize -> dsize; *)
                   (if super.isThisBlockLevel and 
                       (not super.isImplSuper) and (not super.isSingularImplSuper)
                       then
                       superDesc.qOriginOff[varNo] -> qOriginOff[varNo] 
                    else
                       qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo] 
                   if)
                else
                   qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo] 
               if);
               (*' originOff: ' -> puttext; newOriginOff -> putint; newline;*)
               (if sig[] <> none then
                   (varNo,this(items)[]) -> sig.Qalloc
               if);
               scanSons(# do (varNo,this(items)[]) -> current.Qalloc #)
            #);
          newOriginOff: 
            (# orgOff: @integer
            do (if newAlloc then
                   qOriginOff[1] -> orgOff
                else
                   originOff -> orgOff
               if)
            exit orgOff
            #);
          qsize: [1] @integer; 
          qOriginOff: [1] @integer;
          noOfVar: @integer;
       #);
     Pattern::<
       (# Qalloc:: (# do (varNo,IT[]) -> OG.Qalloc (* more stuff in checker:ptn:alloc *) #);
       #);
     Invocation::<
       (# Qalloc:: (# do scanSons(# do (varNo,IT[]) -> current.Qalloc #) #);
       #);
     ObjectInvocation::<
       (# Qalloc:: (# do scanSons(#do (varNo,IT[]) -> current.Qalloc #) #);
       #);
     BracketedExp::<
       (# Qalloc:: (# do (varNo,IT[]) -> IV.Qalloc #);
       #);
     Const::<
       (# #);
     CharObj::< (# #);
     StringObj::< (# #);
     Variant:
       (# vDcl: [1]  ^Pattern; top: @integer;
          type: [1] @ integer;
          size: [1] @ integer;
          binding: [1] ^Pattern;
          add:
            (# VD,BD: ^Pattern
            enter(VD[],BD[])
            do L:
                 (if true then
                     (for i: top repeat
                          (if VD[] = vDcl[i][]  then
                              (* already a binding of VD *)
                              (if BD[] <> binding[i][] then
                                  '\n*** inconsitent virtual binding' 
                                    -> putline
                          if)if);
                          leave L
                     for);
                     (if (top + 1 -> top) > vDcl.range then
                         vDcl.range -> vDcl.extend;
                         type.range -> type.extend;
                         size.range -> size.extend;
                         binding.range -> binding.extend; 
                     if);
                     VD[] -> vDcl[top][];
                     -1 -> type[top];
                     -1 -> size[top];
                     BD[] -> binding[top][]
                 if)
            #); 
          print:
            (#
            do 'Variant: ' -> putline;
               (for i: top repeat
                    vDcl[i].doPT -> puttext; ' :: ' -> puttext;
                    binding[i].doPT -> putline
               for)
            #);
       exit this(Variant)[]
       #);
  do 

     inner
  #)
