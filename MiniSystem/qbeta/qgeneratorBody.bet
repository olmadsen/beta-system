ORIGIN 'qgenerator'
---doMarkPrim:doPart---
do L:
     (if primNo
      // put_prim 
      // rAssign_prim 
      // vAssign_prim 
      // ifThen_prim then
         true -> value
      // restart_prim
      // leave_prim 
      // inner_prim 
      // none_prim
      // suspend_prim 
      // resume_prim
      // disable_prim 
      // enable_prim 
      // attach_prim
      // cmpAndSwap_prim
      // fork_prim
      // sleep_prim
      // indexedPut_prim 
      // indexedGet_prim
      // stringGet_prim
      // indexed_prim
      // asString_prim 
      // thisCore_prim 
      // file_open_prim 
      // file_get_prim 
      // file_eof_prim 
      // file_close_prim          
         then
      else
         (if (sig[] <> none) then
             (if (sig.type ## = Sig.Binary##) and (primNo > 0) 
                 or 
                 (sig.type ## = Sig.Unary##) and (primNo = 65) then
                 leave L
             if);
         if);
         (if IS.isExternal > 0 then
          else
             true -> value       
         if)
     if);
   (if value = false then
       (*'doMarkPrim: '->puttext; primNo -> putint; newline*)
   if)
   
---doPrimElse:doPart---
do 
   (if (sig.type ## = Sig.Binary##) and (OG.primNo > 0) 
       or 
       (sig.type ## = Sig.Unary##) and (OG.primNo = 65) then
       'bodyC:'->cd.comment;
       OG.primNo -> cd.op
    else
       (if (OG.IS.isExternal -> exNo) > 0 then
           (* Origin is on rStack here, but is not used
            * is popped by interpreter_c.c - not good,
            * should avoid generating code for loadOrigin *)
           (sig.id[],exNo) -> cd.invokeExternal
        else
           true -> value       
   if)if)
---GeneralPattern_invoke:doPart---
do (#  N:^ Node; di: ^DataItem; var: ^Variant; isVal: @boolean
   do (*(if not OG.IS.isEmpty then
       (OG.OGid,OG.sig[],OG[],OG.super[],CC[],none) -> ObjTmpStack.add;
       if);*)
      (if doPrimElse then
          (* Cases: E is an invocation of a pattern as in E, rec.E, R.rec.E, .
           * (a)The receiver, rec, may be a constant or variable dataItem
           * (For a variable DI, we forbid assigment etc if virtual Object)
           * We have rec.E, like Lrecord.insert(...)
           * rec may have virtual bindings that qualify data-items in E
           * E is an invocation of this(Pattern)
           * Find out if a new variant of this(Pattern) is needed
           * In List example insert is local to List
           * (b)The receiver may be a pattern as in Foo(...).bar(...)
           * (a) We may mark OG as having virtual Object: 
           * OG (insert) has probably no variants since local to List
           * We have to create a new variant based on the bindings 
           * in rec (Lrecord)
           * For each virtual Object ref, or DI there is a variant
           * with the corresponding bindings in the reciver
           * Note we may need to consider the whole invocation list
           * R.S.foo(...) R and S may have bindings
           *)
          cd.com(#do'Pattern:invoke:descNo:'->TT; OG.is.newDescNo -> II;
                   ' top:' -> TT; OG.Qvariants.top -> II;
                   ' rec:' -> TT; 
                   (if rec[] <> none then rec.dopt -> TQ else 'none'->TQ if)
                #);
          (* We must understand the differences between
           * computeVariant and computeVariantX and the different 
           * situations below where computeVarints(X) is called
           *)
          (if rec[] = E[] then
           else                
              (if rec.ATd## = dataItem## then 
                  (* if receiver is constant, then only one variant *)
                  rec.ATd[] -> OG.Qvariants.computeVariantX
                  (# H:: (# do head #);
                     head: @
                       (# done: @boolean
                       do (if not done then
                              true -> done;
                              ('\n***pattern:invoke:rec: '
                              ,rec.dopt,' . ',E.dopt,'\n'
                              ,OG.dopt,'\n')
                                -> putTextL;
                          if);
                       #);
                  #) -> var[];
                  (if var[] <> none then
                      (* var.print;  
                       OG.Qvariants.print*)
                  if)
               else 
                  (* Receiver and rec.ATd is module 
                   * or pattern (as in foo(e).bar) 
                   * but receiver is actually the return 
                   * value of foo *)
                  OG.Qvariants.computeVariantX -> var[];
                  cd.com(#do 'Rec:module or pattern:'-> TT; sig.id[] -> TQ;
                           ' descNo: ' -> TT; OG.IS.newDescNo -> II;
                           ' top: ' -> TT; OG.Qvariants.top -> II; OG.dopt->TQ
                        #);
          if)if);
          (if ptnKind // virtualPtn // furtherPtn // finalPtn then
              (# DI: ^DataItem; isStatic: @boolean
              do (if rec.ATd## = DataItem## then
                     rec.ATd[] -> DI[];
                     (if true
                      // DI.OG.isValueObj then
                         true -> isStatic;
                         (* '\nRec is value:call: '-> puttext; 
                          * OG.IS.newDescNo -> putint;
                          * ' ' -> put; DI.dopt -> putline;
                          * dopt -> putline;
                          *)
                      // DI.isConst then
                         true -> isStatic;
                         (* '\nRec is const: '-> puttext; 
                          * OG.IS.newDescNo -> putint;
                          * ' ' -> put;DI.dopt -> putline;;
                          * dopt -> putline;
                          *)
                 if)if);
                 (if isStatic then
                     (sig.id[],OG.IS.newDescno,staticOff,not OG.IS.doHasCode) 
                       -> cd.invoke
                  else
                     (sig.id[],off) -> cd.sendVirtual
                 if)                          
              #)
           else 
              (if not isBasicPtn then 
                  (if var[] <> none then 
                      cd.com(#do 'invoke:var not none'->TT; OG.IS.newDescno -> II #);
                      (if OG.isValueObj then
                          (if staticOff = 0 then
                              cd.com(#do 'invokeVal:X:staticOff=0:'->TT;
                                       sig.id[] -> TQ#);
                              0 -> cd.pushConst
                           else
                              (sig.id[],OG.IS.newDescno,staticOff - 1) -> cd.invokeVal;
                          if);
                          true -> isVal
                       else
                          (sig.id[],OG.IS.newDescno,staticOff,not OG.IS.doHasCode) 
                            -> cd.invoke
                      if)                               
                   else 
                      (if OG.isValueObj then
                            (if staticOff = 0 then
                                cd.com(#do 'invokeVal:Y:staticOff=0:'->TT;
                                         sig.id[]->TQ #);
                                0 -> cd.pushConst
                             else
                                (sig.id[],OG.IS.newDescno,staticOff - 1) -> cd.invokeVal;
                            if);
                          true -> isVal
                       else
                          (sig.id[],OG.IS.newDescno,staticOff,not OG.IS.doHasCode) 
                            -> cd.invoke
                      if)
              if)if)
          if);
          (if not useReturnValue and not isVal then popReturn if);
      if)
   #);   
---AssignmentPattern_invoke:doPart--
do (# D: ^DataItem; destIsVal,srcIsVal: @boolean
   do rec.ATd[] -> D[];
      (if true
       // D.OG.isSimpleValue then 
          cd.com(#do'#Store simple value: ' -> TT; rec.dopt -> TQ #)  
       // D.OG.isValueObj then 
          cd.com(#do '>Assign:StoreValue:rec:' -> TT; rec.dopt -> TQ; 
                   ',size:'->TT; D.objSize -> II #);
          true -> adr.destIsVal -> adr.isAdr;
          D.objSize -> adr.size;
          E.args.scanArgs
          (# OGa: ^ObjectGenerator; ptn: ^Pattern; descNo: @integer; org: ^Items
          do current[] -> OGa[];
             (if (OGa.super[]<> none) 
                 and (OGa.super.ATd[] <> none) then                 
                 (if OGa.super.ATd.isPattern then 
                     OGa.super.ATd[] -> ptn[];
                     ptn.OG.IS.newDescno -> descNo;
                     'pattern:arg:'->puttext;
                     descNo -> putint; ' ' -> put;
                     current.dopt -> putline; 
                     descNo -> adr.descNo;
                  else
                     (if OGa.super.ATd.isDataItem then
                         'pattern:arg:isDataItem: '->puttext; OGa.super.ATd.dopt -> puttext; 
                         (*newline;
                         OGa.super.ATd.origin.dopt -> putline;*)
                         (if ((OGa.super.ATd.origin[] -> org[])-> Org.originIsValue) then
                             ' -- origin is value'->putline;
                             true -> adr.srcIsVal
                          else
                             newline
                         if)
          if)if)if)#)
       else
          cd.com(#do 'Store reference: ' -> TT; rec.dopt -> TT#);
      if);
      
      (if isValueAssign then
          cd.com(#do 'vAssign:invoke:rec:' -> TT; rec.dopt -> TQ; ' E:' -> TT; E.dopt -> TQ #);
          cd.com(#do adr.print -> TT #);
          adr.store;
      else
          cd.com(#do 'rAssign:invoke:'-> TT; dopt -> TT; adr.print -> TT#);
          adr.store;
      if)
   #)
   
--BreakPatternInvoke:doPart---
do
   (# doBreak:
        (# IS: ^Items; Ex : ^ObjectGenerator; 
           primNo,ON: @integer
        enter primNo
        do E.args.scanArgs(# do current[] -> Ex[]#);
           Ex.super.on -> ON;
           (* We assume ON > 0 as in
            *    L: = { ... }
            * but perhaps not the case in
            *    cycle{ ... }
            *)
           ON - 1 -> (E.origin[] -> IS[]).toOrigin -> IS[];
           (if primNo
            // restart_prim then 
               (if ON = 1 then
                   IS.restartLab -> cd.jmp
                else
                   (ON - 1, IS.restartLab,IS.newDescNo) -> cd.break 
               if)
            // leave_prim then 
               (if ON = 1 then
                   IS.leaveLab -> cd.jmp
                else
                   (ON - 1, IS.leaveLab,IS.newDescNo) -> cd.break
               if)
           if)
        #);  
   do (if OG.primNo
       // restart_Prim then 
          restart_Prim -> doBreak
       // leave_Prim then 
          leave_Prim -> doBreak   
      if)
   #)
---IndexPattern_invoke:doPart---
do (#
   do (if OG.primNo 
       // indexedPut_prim then 
          (* Can indexedPut and other primtives
           * just be opcodes? May simplify things*)
          (# D: ^DataItem; isRef: @boolean
          do rec.ATd[] -> D[];
             D.OG.scanActualArgs
             (# i: @integer
             do (if (i + 1 -> i) = 2 then
                    current.dopt -> cd.comment;
                    (if current.isBasic then
                        'basic' -> cd.comment;
                     else 
                        'ref' -> cd.comment;
                        true -> isRef;
                if)if);
             #);
             (if isRef then
                 cd.rswap;
                 ('inx',1) -> cd.xrstoreg
              else
                 ('inx',1) -> cd.xstoreg  
             if)
          #)       
       // indexedGet_prim then
          (* check if rec is value or ref indexed *)
          (# D: ^DataItem; isRef: @boolean
          do (if rec.ATd.primNo = indexedGet_prim then
                 (* The case for indexed::length *)
                 ('inx',1) -> cd.xpushg
              else
                 rec.ATd[] -> D[];
                 D.OG.scanActualArgs
                 (# i: @integer
                 do (if (i + 1 -> i) = 2 then
                        current.dopt -> cd.comment;
                        (if current.isBasic then 
                            'value' -> cd.comment;
                         else 
                            'ref' -> cd.comment;
                            true -> isRef
                    if)if)
                 #);
                 (if isRef then
                     ('inx',1) -> cd.xrpushg
                  else
                     ('inx',1) -> cd.xpushg
                 if);
             if)
          #)
       // stringGet_prim then
          ('inx',1) -> cd.xpushg  
       // indexed_prim then
          (if elimOrigin then
              cd.pushThis (* not used by allocIndexed - just popped *)
          if);
          E.args.scanArgs
          (# OG: ^ObjectGenerator; i: @integer
          do (*current.dopt -> puttext; ' ' -> put;*)
             i + 1 -> i;
             (if i = 2 then
                 current[] -> OG[];
                 (if Og.primNo = integer_prim then
                     (*'Got value' -> puttext;*)
                     0 -> cd.pushConst;   (* not isRindexed *)
                  else
                     (*'Got ref' -> puttext;*)
                     1 -> cd.pushConst;   (* isRindexed *)
          if)if)#); 
          (sig.id[],sig[],OG[],OG.super[],CC[],OG.computeVariant) 
            -> objTmpStack.add;           
          (if elimOrigin then
              1 -> cd.pushConst; (* dinx *)
           else
              (* rsize may be from the first Beta compiler
               * where there may be non-indexed data-items
               * and indexed was the last declaration!?
               * With qbeta no other data-items than indexed
               *)
              OG.IS.rsize -> cd.pushConst; (* dinx *)
          if);
          ('StaticRep',OG.IS.newDescNo,false (*not used*),true) 
            -> cd.allocIndexed;
          (if staticOff > 0 then
              cd.pushThis;
              ('indexed',staticOff) -> cd.rstoreg
          if)
       // asString_prim then
          ('asString',primNo) -> cd.callPrim
      if)
   #)   
---OtherPrim_invoke:doPart---
do (if OG.primNo    
    // ifthen_prim then
       exitLab.new;                   
       E.args.scanSons
       (# N: @integer
       do N + 1 -> N;
          (if N
           // 1 // 3 then
           // 2 then 
              (true,0,staticOff) -> current.Qgen;
              exitlab -> cd.jmpFalse;
           // 4 then
              (false,0,staticOff) -> current.Qgen;
              exitLab -> cd.defLab;
           else
              'invoke:%if%then: too many arguments' -> putline;
              E.doPt -> putline
          if)
       #)                
    // inner_prim then
       (if E.args.length > 0 then
           E.args.scanArgs
           (# A: ^ObjectGenerator; org: ^Items; orgIsVal: @boolean
           do current[] -> A[]; 
              cd.pushThis;
              (A.super.on - 1,A.super[]) -> (E.origin[]->org[]).goOrigin -> (org[],orgIsVal); 
              (if org.basicNo = ifthen_prim then
                  (* we need to clean-up goOrigin *)
                  org.origin[] -> org[]
              if);
              org.innerInx -> cd.innerP; 
              cd.rpopThisObj
           #)
        else
           E.origin[] -> org[];
           org.innerInx -> cd.innerx; 
       if)
    // none_prim then 
       cd.pushNone
    // suspend_prim then
       cd.suspendd
    // resume_prim then
       ('Resume','D') -> cd.call;
       cd.rpop
    // disable_prim then
       ('disable',disable_prim) -> cd.callPrim
    // enable_prim then  
       ('enable',enable_prim) -> cd.callPrim   
    // put_prim then 
       ('put',OG.primNo) -> cd.Callprim
    // attach_prim then
       ('attach',OG.primNo) -> cd.callPrim;
       cd.rPop;
    // cmpAndSwap_prim then
       (# I: ^Invocation
       do E.father -> I[];
          L:
            I.scanSons
            (# R: ^Exp
            do current[] -> R[];
               cd.swap;
               ('cmpAndSwap',OG.primNo ) -> cd.callPrim;
               leave L
            #)
       #)
    // fork_prim then
       ('fork',OG.primNo ) -> cd.callPrim
    // sleep_prim then
       ('sleep',OG.primNo ) -> cd.callPrim;
    // thisCore_prim then
       (*OG.markForCodeGen*)
    // file_open_prim then
       ('file_open',primNo) -> cd.callPrim
    // file_get_prim then
       ('File_get',primNo) -> cd.callPrim
    // file_eof_prim then
       ('File_eof',primNo) -> cd.callPrim
    // file_close_prim then
       ('File_close',primNo) -> cd.callprim       
    else
   if)
