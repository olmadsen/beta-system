ORIGIN 'qgenerator'
---doMarkPrim:doPart---
do L:
     (if primNo
      // put_prim 
      // get_prim
      // rAssign_prim 
      // vAssign_prim 
      // indexed_prim
      // ifThen_prim then
         true -> value
      // restart_prim
      // leave_prim 
      // inner_prim 
      // none_prim
      // suspend_prim 
      // resume_prim
      // disable_prim 
      // enable_prim 
      // attach_prim
      // cmpAndSwap_prim
      // fork_prim
      // sleep_prim
      // indexedPut_prim 
      // indexedGet_prim
      // stringGet_prim

      // asString_prim 
      // thisCore_prim 
      // file_open_prim 
      // file_get_prim 
      // file_eof_prim 
      // file_close_prim
      // dumpObj_prim 
      // log_prim 
         then
      else
         (if (sig[] <> none) then
             (if (sig.type ## = Sig.Binary##) and (primNo > 0) 
                 or 
                 (sig.type ## = Sig.Unary##) and (primNo = 65 (* not *)) then
                 leave L
             if);
         if);
         (if (IS[] <> none) and (IS.isExternal > 0) then
          else
             true -> value       
         if)
     if);
   (if value = false then
       (*'doMarkPrim: '->puttext; primNo -> putint; newline*)
   if)
---GeneralPattern_invoke:doPart---
do (# doPrimElse: BooleanValue
        (# exNo: @integer
        do (if (sig.type ## = Sig.Binary##) and (OG.primNo > 0) 
               or 
               (sig.type ## = Sig.Unary##) and (OG.primNo = 65) then
               'bodyC:'->cd.comment;
               OG.primNo -> cd.op
            else
               (if (OG.IS.isExternal -> exNo) > 0 then
                   (* Origin is on rStack here, but is not used
                    * is popped by interpreter_c.c - not good,
                    * should avoid generating code for loadOrigin *)
                   (sig.id[],exNo) -> cd.invokeExternal
                else
                   true -> value       
        if)if)#);
      boxedInvokeVal:
        (# id: ^text; dNo: @integer; useReturnValue: @boolean;
           DI: ^DataItem
        enter(id[],dNo,useReturnValue)
        do (id[],dNo,OG.objSize) -> cd.boxedInvokeVal;
           (* the return from BoxedInvodeVal is quite tricky 
            * Saved return in boxedInvokeVal is set to after cd.rtn 
            * since the invokeValue in boxedInvokeValue
            * will return to cd.mvStack and we must avoid executing
            * the code below twice - see also betaVM::boxedInvokeVal
            *)
           cd.mvStack;
           cd.rtn;
        #);
      N:^ Node; di: ^DataItem; var: ^Variant; isVal,isObj: @boolean
   do (if doPrimElse then
          (* Cases: E is an invocation of a pattern as in E, rec.E, R.rec.E, .
           * (a)The receiver, rec, may be a constant or variable dataItem
           * (For a variable DI, we forbid assigment etc if virtual Object)
           * We have rec.E, like Lrecord.insert(...)
           * rec may have virtual bindings that qualify data-items in E
           * E is an invocation of this(Pattern)
           * Find out if a new variant of this(Pattern) is needed
           * In List example insert is local to List
           * (b)The receiver may be a pattern as in Foo(...).bar(...)
           * (a) We may mark OG as having virtual Object: 
           * OG (insert) has probably no variants since local to List
           * We have to create a new variant based on the bindings 
           * in rec (Lrecord)
           * For each virtual Object ref, or DI there is a variant
           * with the corresponding bindings in the reciver
           * Note we may need to consider the whole invocation list
           * R.S.foo(...) R and S may have bindings
           *)
          cd.com(#do'Pattern:invoke:useRTNv:'->TT; useReturnValue -> BB;
                   'descNo:'->TT; OG.is.newDescNo -> II;
                   ' top:' -> TT; OG.Qvariants.top -> II;
                   ' rec:' -> TT; 
                   (if rec[] <> none then rec.dopt -> TQ else 'none'->TQ if)
                #);
          (* We must understand the differences between
           * computeVariant and computeVariantX and the different 
           * situations below where computeVarints(X) is called
           *)
          (if rec[] = E[] then
           else                
              (if rec.ATd## = dataItem## then 
                  (* if receiver is constant, then only one variant *)
                  rec.ATd[] -> OG.Qvariants.computeVariantX -> var[];
               else 
                  (* receiver and rec.atd is module or pattern 
                   * (as in foo(e).bar) 
                   * but receiver is actually the return value of foo *)
                  og.qvariants.computeVariantX -> var[];
                  cd.com(#do 'rec:module or pattern:'-> tt; sig.id[] -> tq;
                           ' descno: ' -> tt; og.is.newdescno -> ii;
                           ' top: ' -> tt; og.qvariants.top -> ii; 
                           og.dopt->tq
                        #);
          if)if);
          
          (# DI: ^dataItem; ptn: ^Pattern; 
             isValue,isStatic,returnsValueObj,recIsValObj:  @boolean; 
             org: ^Items;
             noOfRefArgs: @integer;            
             vObjId: ^text
          do (if ptnkind // virtualptn // furtherptn // finalptn then
                 (if true
                  // 'var' -> (rec.father.father.father.label).equal
                  // 'val' -> (rec.father.father.father.label).equal then
                     (* This is really a hack!!! *)
                     true -> isStatic -> isValue;
                     rec.father.father.father[] -> DI[];
                     (if false then
                         '***** DataItem:alloc: V: var TTT:off:'->puttext;
                         DI.newOff -> putint; newline;
                         DI.doPT -> putline;
                     if);
                     DI.newOff -> staticOff; 
                  // rec.ATd.isDataItem then 
                     rec.ATd[] -> DI[];
                     DI.OG.isValueObj or DI.isConst -> isStatic;
                  // rec.ATd.isPattern then
                     (if rec[] <> e[] then (* we should eliminate rec=e *)
                         rec.ATd[] -> ptn[]; 
                         (ptn.getReturnOG).isValueObj 
                         or
                         (ptn.og.primno = indexedget_prim) -> isstatic
                 if)if);
                 (if isStatic then
                     (if isValue then
                         (sig.id[],new_descNo,staticOff - 1) 
                           -> cd.invokeval;
                         true -> isVal
                      else
                         cd.com(#do 'before:invoke:A:' -> TT#);
                         (if true then
                             (OG[],staticOff,false) -> callInvoke
                          else
                             (sig.id[],OG.is.newdescno,OG.IS.objSize
                             ,staticoff,true) 
                               -> cd.invoke
                     if)if)
                  else
                     (* OG may have ref-args that will be above the
                      * obj-ref to be dispatched.
                      * S is the obj-ref and x, y and z are obj-args
                      * The noOfRefArgs is passed to invokeV
                      * ------------      ------------
                      * |...|S|x|y|z  ==> |...|x|y|z|S
                      * ------------      ------------
                      *)
                     OG.IS.noOfObjArgs -> noOfRefArgs;
                     (if true then
                         (if OG.IS.theDescNo = 0 then
                             'thexDescNo=0 ' -> puttext; 
                             OG.IS.theDescNo ->  putint; ' '-> put;
                             sig.dopt -> putline;
                             OG.dopp -> putline
                         if);
                         (if rec[] = E[] then
                             E.origin[] -> org[];
                             (for i: E.on repeat
                                  org.father.origin[] -> org[];
                             for);
                             (if org.encOG.isValueObj -> recIsValObj then
                                 (if false then
                                     '** Virtual invocation: ' 
                                       -> puttext; E.dopt -> puttext;
                                     ' on: ' -> puttext; E.on -> putint;
                                     '\n** receiver is value object: '
                                       -> puttext;
                                     org.encOG.OGid -> putline;
                                 if);
                                 (*org.dopt ->  putline;*)
                             if);
                         if);
                         cd.lcom(#do 'invokev:' -> TT; OG.OGid -> TT #);
                         (if OG.vDescNo > 0 then
                             cd.lcom(#do 'Using Vstub in vDescNo: ' -> TT;
                                    OG.vDescNo -> II; OG.sig.dopt ->TT; #);
                             (if true then 
                                 '' -> vObjId[];
                              else 
                                  'Vstub$' -> vObjId[];
                             if);
                             OG.sig.dopt -> vObjId.append;
                             '$' -> vObjId.put;
                             OG.vDescNo -> vObjId.putint;
                             '$' -> vObjId.put;
                             OG.vDescNo -> vObjId.putint;
                          else
                             cd.lcom(#do 'Using OG.OGidWdNo: ' -> TT; 
                                       OG.OGidWdNo-> TT#);
                             (if false then
                                 '**** Using OG.OGidWdNo: ' -> puttext;
                                 OG.OGidWdNo-> putline;
                             if);
                             OG.OGidWdNo->vObjId[];
                         if);
                         cd.lcom(#do 'invokeV:before:'->TT;vObjId[]->TT #);
                         (vObjId[],off,noOfRefArgs,recIsValObj)
                           -> cd.invokeV
                         (# originOff::
                              (# ISx: ^Items
                              do OG.IS.isEmpty -> usestub;
                                 (if false then
                                     '**** originOff:of: ' -> puttext;
                                     vObjId[] -> puttext;
                                     ' top: ' -> puttext; 
                                     (OG.IS.topSuper).encOG.OGidWdNo 
                                       -> putline;
                                 if);
                                 (OG.IS.topSuper).encOG.OGidWdNo 
                                   -> topSuperId[];

                                 (OG.origin[]->ISx[]).encOG.OGidWdNo 
                                   -> type[];
                                 (if false then
                                     type[] -> puttext; 
                                     ' useStub: ' -> puttext;
                                     useStub -> putboolean; newline;
                                 if);
                                 OG.IS.newOriginOff -> off;
                                 (if OG.IS.isEmpty then
                                     OG.super.ATd.OG.IS.newOriginOff -> off
                                 if)
                              #)                       
                         #);
                         (* Push return value;
                          * should we check useReturnValue ? *)
                         (OG[],vObjId[]) -> pushOut
                         (* callee is on rtop of rStack *)
                      else
                         (sig.id[],off,noOfRefArgs,false) -> cd.invokeV
                     if);
                 if)
              else 
                 (if not isPrimitivePtn then 
                     (if (getReturnDecl -> DI[]) <> none then
                         DI.isValue -> returnsValueObj
                     if);
                     cd.com(#
                           do 'ptn:invoke:' -> TT;
                              'useRtnV:'->TT; useReturnValue -> BB;
                              'isValObj:' -> TT; OG.isValueObj -> BB;
                              ':rtnValObj:' -> TT; returnsValueObj -> BB;
                              ':' -> TT; doPT -> TQ; nl;
                              'rec=E:'->TT; rec[] = E[] -> BB;
                              ':rec:'->TT; rec.dopt -> TQ
                           #);
                     (*OG.IS[] -> noOfObjArgs -> C;
                     (if c > 0 then 
                         '!!!! invoke:noOfObjArgs > 0: ' -> puttext;
                         c -> putint; ' ' -> put;
                         sig.doPT -> puthead
                     if);*)
                     (if OG.isValueObj then
                         (if staticOff = 0 then
                             (if (DI[] <> none) and DI.OG.isValueObj then
                                 (sig.id[],OG.is.newdescno,useReturnValue) 
                                   -> BoxedInvokeVal
                              else
                                 cd.com(#do 'ptn:invoke:valuObj:asArg:'->TT;
                                          sig.id[] -> TQ #);
                                 0 -> cd.pushConst
                             if)
                          else
                             (sig.id[],OG.is.newdescno,staticoff - 1) 
                               -> cd.invokeVal
                             (# T: ^text
                             do cd.thisClassId[] -> T[]; 
                                OG.IS.scanItemArgsReverse
                                (# DI: ^DataItem
                                do cd.lcom(#do 'store arg: ' -> TT;
                                             currentarg.dopt -> TT #);
                                   cd.pushThis;
                                   (if (currentArg[]->DI[]).isBasicValue 
                                       then
                                       (T[],DI.newOff + staticOff)
                                         -> cd.storeX
                                    else
                                       (T[],DI.newOff + staticOff,false)
                                         -> cd.rstoreX
                                   if)
                                #);
                             #)
                         if);
                         true -> isval
                      else
                         (if rec[] = E[] then
                             (* check if E is a const ref that must be marked
                              * as an object.
                              * A clean-up is needed - also for virtuals above *)
                             (if (rec.ATd.father.father.father[] 
                                   -> N[]).isDataItem then
                                 rec.ATd.father.father.father[] -> DI[];
                                 DI.isConst -> isObj;
                                 cd.com(#do 'bingo:DI:'->TT; DI.dopt->TQ #)
                         if)if);
                         isObj or OG.returnsThis and useReturnValue -> isObj;
                         cd.com(#do 'before:invoke:useReturnValue: ' -> TT; 
                                  useReturnValue->BB#);
                         (if true then
                             (*(# org: ^Items
                             do '**** invoke: ' -> puttext;
                                (OG.origin[]->org[]).newDescNo -> putint; 
                                newline;
                                OG.dopt->putline
                             #);*)
                             (OG[],staticOff,false) -> callInvoke
                          else
                             (sig.id[],OG.IS.newDescno,OG.IS.objSize
                             ,staticOff,isObj)
                               -> cd.invoke;
                         if)
                     if)
                  else
                     cd.com(#do 'ptn:invoke:primitive:'->TT; sig.dopt->TT#);
                     (if primno 
                      // this_prim // string_prim then
                      // integer_prim then
                         0 -> cd.pushConst
                      // log_prim then
                         ('log_prim',primNo) -> cd.callprim  
                      // printf_prim then
                         ('printf_prim',primNo) -> cd.callprim
                      // sqrt_prim then
                         ('sqrt_prim',primNo) -> cd.callprim  
                      // cbrt_prim then
                         ('cbrt_prim',primNo) -> cd.callprim    
                      else
                         E[] -> warning
                         (#
                         do 'The use of the basic pattern "' -> msg; sig.dopt -> msg;
                            '" here may give an error' -> msg;
             #)if)if)if);
             cd.com
             (#
             do 'useRtnVal:' -> TT; useReturnValue -> BB;
                ':isVal:'-> TT; isVal -> BB;
                ':rtnValObj:' -> TT; returnsValueObj -> BB;
                ':rec=E:'->TT; rec[] = E[] -> BB;
                rec.doPT -> TQ
             #);
             (if not useReturnValue and not isVal then popReturn if);
          #)
      if)
   #);   
---AssignmentPattern_invoke:doPart--
do (# dstDI,srcDI: ^DataItem; arg: ^ObjectSpecification;  ptn: ^Pattern; UT: ^text;
      asgKind: @integer; (* basic: 1
                          * value: 2 but not basic
                          * ref  : 3
                          *)
   do cd.com(#do 'AssignPtn:invoke:rec: '-> TT; rec.doPt -> TQ; 
               'from: '->TT; E.doPT->TQ #);
      (if rec.ATd.isPattern then 
          cd.com(#do 'Assign to pattern - %this ' -> TT; print #)
       else
          E.args.scanArgs(#do current[] -> arg[] #); 
          (* Only one argument since assign *)
          rec.ATd[] -> dstDI[]; 
          cd.com(#do 'assign:dstDI :' -> TT; dstDI.doPT -> TQ; 
                   'isUnitValueObj: ' -> TT; dstDI.OG.isUnitValueObj -> BB #);
          cd.com(#do 'assign:arg: '->TT; arg.doPT->TQ; 
                   'lab:' ->TT;arg.label->TQ;
                   'UnitValObj :' -> TT; arg.isUnitValueObj -> BB;
                   ' ptn: ' -> TT; arg.isPattern -> BB; nl;
                   ' float: '-> TT; arg.isFloat -> BB;
                   ' DataItem:'-> TT; arg.isDataItem -> BB;
                   ' arg.super:'->TT; arg.super.dopt -> TT; nl;
                   (* arg = foo, arg.super.ATd = foo.ATd
                    * arg = R.foo, arg.super.ATd = foo.ATd
                    * arg = L1 * L2, arg.super.ATd = *.ATD
                    *)
                   ' arg.super.ATd:'->TT; arg.super.label->TQ;
                   arg.super.ATd.dopt -> TQ; nl;
                   ' arg.super.ATd.isDataItem:'->TT; 
                   arg.super.ATd.isDataItem->BB;
                   ' arg.super.ATd.isFloat:'->TT; 
                   arg.super.ATd.isFloat->BB; nl;
                   ' arg.super.ATd.label: ' -> TT; arg.super.ATd.label->TQ
                #);
          (if dstDI.OG.primNo = indexed_prim then
              (if false then
                  '**** assign to indexed: ' -> puttext; 
                  dstDI.dopt -> putline;
                  '**   src: ' -> puttext; arg.dopt -> putline;
              if);
              cd.com(#do 'mkIndexed: ' -> TT; arg.bracketedListLength->II;
                       ' ' -> TT; arg.DoPT -> TT #);
              (if arg.bracketedListLength > 0 then
                  arg.bracketedListLength -> cd.pushConst;
                  dstDI.OG.super.ATd.OG.IS.newDescNo -> cd.mkVindexed
              if)
          if);
          (if true
           // dstDI.OG.isBasicValue // dstDI.OG.primNo = value_prim 
           // dstDI.OG.isUnitValueObj and 
              (arg.super.ATd.OG.isUnitValueObj or arg.super.ATd.isFloat 
              or arg.super.ATd.isInteger) then
              (* arg.super.ATd.isPattern and arg.isFloat then *)
              (* dstDI.OG.primNo = value_prim for handling _v: var Value 
               * in integer, char and boolean *)
              (* 1: X := Y - ok if X, Y are basic values
               * 2: X := Y - ok, if X, Y are UnitValueObjs
               * 3: X := Y * Z, OK, if X, Y both are basic values
               * 4: X := Y * Z, OK, if X, Y both UnitValueObjs
               * 5: X := foo(exp), OK, if X is basic value 
               * and foo retunrs basic value
               * 6: X := foo(exp), not OK, if X is UbitValueObj 
               * and foo returns UnitValueObj
               * 1,3,4: handled by dstDI.isBasicValue
               * 2: dstDI.OG.isUnitValueObj and arg.isUnitValueObj 
               * (this test dont work)
               *                    arg.isDataItem => unitValueObj
               * 5: dstDI.og.IsUnitValueObj and not arg.isPattern 
               * and not basicPattern
               * 
               *)
              (* for X := Y and X := Foo, we come here 
               * - should not come here for Foo
               * for X := Y * Z, we do not come here 
               * since Y * Z is not UnitValueObj
               * perhaps test for basic pattern?
               * The above comments are not up-to-date
               *)
              cd.com(#do'assign:simple value: ' -> TT #);
              dstDI[] -> arg.checkNumberConvert
              (# I2F:: (#do cd.I2f #);
                 F2I:: (# do cd.F2I #);
              #);
              1 -> asgKind
           // dstDI.OG.isValueObj then 
              (* X: = Y where Y is a ValueObj that is not a unit 
               * - but yet not tested above!
               * X := foo where foo  is a pattern
               *)
              cd.com(#do 'assign:ValueObj:isPtn: ' -> TT;  
                       arg.super.ATd.isPattern -> BB;
                       ' size:' -> TT; dstDI.objSize -> II; #);
              true -> adr.destIsVal -> adr.isAdr;
              dstDI.objSize -> adr.size;
              (* Clean-up needed. Currenlty we assume that we have an assigment
               * dst := src, where dst is a dimension.unit being a sub of Value
               * and src is a float or an integer.
               * getUnit should always return UT[] <> none, 
               * but this is not the case!
               *)           
              (if true
               // arg.super.ATd.isPattern then 
                  (arg.super.ATd[] -> ptn[]).getReturnDecl -> srcDI[];
                  (if not ((srcDI[] <> none) and srcDI.OG.isValueObj) then
                      (if ptn.OG.primNo <> indexedGet_prim then 
                          ptn.OG.IS.newDescno -> adr.descNo;
                  if)if)
               // arg.super.ATd.isDataItem then
                  arg.inValueObj -> adr.srcIsVal
              if);
              2 -> asgKind
           else
              cd.com(#do 'assign:reference: ' -> TT; rec.dopt -> TQ #);
              3 -> asgKind
      if)if);

      (if arg.IS.isUnique then 
          (* only relevant for references! Should also be checked *)
          cd.com(#do 'assign:isUnique: ' -> TT #);
          (if not dstDI.OG.IS.isUnique then
              E[] -> SemanticError
              (#
              do 'In the assignment of "' -> msg; E.dopt -> msg; 
                 '" to "' -> msg; dstDI.doPT -> msg; 
                 '",\n     the source is unique, but the the destination is not!' 
                   -> msg
              #)
          if);
      if);
      (if useReturnValue then
          (* assignment is last statement in main part
           * where super has redefined inner to return a value
           *)
          (if false then '**** useReturnValue: ' -> puttext; 
              dopt -> putline if);
          (if asgKind
           // 1 (* basic value *) then cd.double
           // 2 (* compound value obj *) then
              '\n!!!! OBS! Mainpart returning compound value is not implemented!'
              -> putline;
           // 3 (* reference *) then
              cd.rdouble;
              '\n!!!! OBS! Mainpart returning a refence may not work!'
                -> putline;
           else
              '\n!!!! OBS! Mainpart returning unknown value!*' 
                -> putline;
          if)
      if);
      cd.com(# Ax: ^Address
            do 'assign:before:adr.store:E: ' -> TT; 
               (if E[] <> none then E.dopt -> TQ; if);
               ' rec: ' -> TT; (If rec[] <> none then rec.dopt -> TQ if);
               (adr[]->Ax[]).nameOfE_OG -> TQ; nl;
               adr.print -> TT #);
      rec[] -> adr.E[]; (* perhaps a hack for lLVM ?? *)
      adr.store; (* generate the assigment code *)
   #)
   
--BreakPatternInvoke:doPart---
do
   (# doBreak:
        (# trace:
             (# T: ^text
             enter T[]
             do (if false then
                    '**** Break: "' -> puttext; E.dopt -> puttext; 
                    '" arg: "' -> puttext; Ex.dopt -> puttext;
                    '" lab: "' -> puttext; Ex.label -> puttext;
                    '"' -> put;
                    '\n**   ON: ' -> puttext; on -> putint; 
                    ' descNo: ' -> puttext; IS.newDescNo -> putint;
                    ' noOfSuper: ' -> puttext; noOfSuper -> putint;
                    newline;
                    (if ONs > 0 then
                        '**   BreakToSuper: ONs:' -> puttext; 
                        ONs -> putint; newline;
                    if);
                    (IS.theObjectGenerator).father.doPT -> putline;
                    '**   dcl:'->putline;
                    dcl.dopt -> putline
                if)
             #);
           labInSuper:
             (# ISx: ^Items; 
             do (if ON > 1 then
                    E.origin[] -> ISx[];
                    (for i: ON -1 repeat
                         (if ISx.super[] <> none then
                             (if ISx.super.ATd[] = dcl[] then
                                (* '\n**** Break to super pattern: on: ' 
                                   -> puttext; i -> putint;
                                 newline;*)
                                 i -> ONs;
                                 ISx.super.ATd.OG.IS.newDescNo -> descNoS;
                                 ISx[] -> IS[];
                                 leave labInSuper;
                              else
                                 ISx.origin[] -> ISx[]
                             if)
                if)for)if)
             #);
           countSuper:
             (# ISx: ^Items
             do IS[] -> ISx[];
                L:
                  (if ISx.super.ATd[] <> none then
                      noOfSuper + 1 -> noOfSuper;
                      (if ISx.super.ATd[] = Dcl[] then
                          (if false then
                              '*** found super in break: ' -> puttext;
                              noOfSuper -> putint; newline;
                              dcl.dopt -> putline
                          if)
                      else 
                          ISx.super.ATd.OG.IS[] -> ISx[];
                          restart L
                      if)
                  if)
             exit ISx[]
             #);
           topSuper:
             (# ISx: ^Items; pn,dns: @integer
             do IS[] -> ISx[]; dn -> dns;
                L:
                  (if ISx.super.ATd[] <> none then
                      pn + 1 -> pn;
                      ISx.super.ATd.OG.IS[] -> ISx[];
                      ISx.newDescNo -> dns;
                      restart L
                  if)
             exit(pn,ISx[],dns)
             #);
           IS,superIS: ^Items; Ex : ^ObjectSpecification; dcl: ^Decl;
           primNo,ON,ONs,descNoS,dn,noOfSuper: @integer; 
           org: ^Items; OI: ^ObjectInvocation
        enter primNo
        do (if true then
               E.args.scanArgs(# do current[] -> Ex[]#);  
               Ex.super.on -> ON;
               Ex.origin[] -> IS[]; 
               (if false then
                   '**** ON: ' -> puttext; ON -> putint; 
                   ' ptnId.on: ' -> puttext; 
                   (Ex.super.last->OI[]).ptnId.on -> ON -> putint;
                   newline;
                   IS.doPT -> puthead; '--'->putline;
               if);
               ON - 1 -> (Ex.origin[] -> IS[]).toOrigin -> IS[];
               IS.newDescNo -> dn;
               topSuper -> (noOfSuper,superIS[],dn);
               (if false then
                   '**** break:to:descNo: ' -> puttext; dn -> putint; 
                   ' ON: ' -> puttext; ON -> putint; newline;
                   IS.doPT -> puthead;
               if);
               (if noOfSuper > 0 then
                   (if false then 
                       '**   super: ' -> puttext; 
                       noOfSuper -> putint; newline;
                       superIS.doPT -> putline;
                   if);
                   superIS[] -> IS[]
               if);
               (if primNo
                // restart_prim then 
                   (if (ON = 1) and (noOfSuper = 0) then
                       IS.restartLab -> cd.jmp
                    else
                       (ON - 1, IS.restartLab,dn,noOfSuper) -> cd.break
                   if)
                // leave_prim then
                   (if (ON = 1) and (noOfSuper = 0) then
                       IS.leaveLab -> cd.jmp
                    else
                       (ON - 1, IS.leaveLab,dn,noOfSuper) -> cd.break
               if)if)
            else
               '**** break:OLD:'->puttext; e.dopt -> puttext; 
               ' Ex: ' -> puttext;
               E.args.scanArgs(# do current[] -> Ex[]#);
               Ex.dopt -> puttext; ' on: ' -> puttext;
               Ex.super.on -> ON; on -> putint; 
               ' ptnId.on: ' -> puttext; 
               (Ex.super.last->OI[]).ptnId.on -> ON -> putint;
               
               newline;
               Ex.super.ATd[] -> dcl[]; (* is dcl for the case where we leave a
                                         * super as in L: P{ ...; leave P}
                                     * It seems that this might be a doubtfull
                                     * case that we should not support!
                                     *)
               (* We assume ON > 0 as in
                *    L: = { ... }
                * but perhaps not the case in
                *    cycle{ ... }
                *)
               ON - 1 -> (E.origin[] -> IS[]).toOrigin -> IS[];
               IS.newDescNo -> dn;
                                 labInSuper;(*(#do ONs -> ON; dns -> dn #); *)
               (if true or (ON > 1) then countSuper -> superIS[] if);
               (* pn should be the path to super where break shall continue
                * IS thus also relevant for ON = 1
                * We then dont have to search via super in doBreak
                *)
               trace;
               (if (ONs > 0) and (ONs < ON) then ONs -> ON; descNoS -> dn if);
               (if true then
                   '**** break:to:descNo: ' -> puttext; dn -> putint; 
                   ' ON: ' -> puttext; ON -> putint; newline;
                   IS.doPT -> puthead;
                   (if noOfSuper > 0 then
                       '**   super: ' -> puttext; noOfSuper -> putint; newline;
                       (*superIS.doPT -> putline;
                       superIS[] -> IS[]*)
                   if);
                   '**** E:' -> puttext;  E.dopt->  putline;
               if);
               (if primNo
                // restart_prim then 
                   (if ON = 1 then
                       (if noOfSuper > 0 then
                           '**** restart: PN > 0: ' -> puttext;
                           E.dopt -> putline;
                           superIS.dopt -> putline
                       if);
                       IS.restartLab -> cd.jmp
                    else
                       (if emitLLVM then
                           cd.pushThis;
                           (ON - 1, E[]) -> (E.origin[]->org[]).goorigin;
                       if);
                       (ON - 1, IS.restartLab,dn,noOfSuper) -> cd.break 
                   if)
                // leave_prim then 
                   (if ON = 1 then
                       (if noOfSuper > 0 then
                           '**** leave: PN > 0: ' -> puttext;
                           E.dopt -> putline;
                           superIS.dopt -> putline
                       if);                   
                       IS.leaveLab -> cd.jmp
                    else
                       (if emitLLVM then
                           cd.pushThis;
                           (ON - 1, E[]) -> (E.origin[]->org[]).goorigin;
                       if);
                       (ON - 1, IS.leaveLab,dn,noOfSuper) -> cd.break
                   if)
               if)
           if)
        #);  
   do (if OG.primNo
       // restart_Prim then 
          restart_Prim -> doBreak
       // leave_Prim then 
          leave_Prim -> doBreak   
      if)
   #)
---IndexPattern_invoke:doPart---
do (# getIndexedArgs:
        (# D: ^DataItem; isRef: @boolean; isValueObj,size: @integer
        do rec.ATd[] -> D[];           
           1 -> size; (* Apparently scan below does not work for
                       * %put V: ?^ elm %at% inx: ?^ integer:
                       * implies size = 0
                       *)
           (*'**** getIndexedArgs: ' -> puttext; D.dopt -> putline;*)
           D.OG.scanActualArgs
           (# i: @integer; OG: ^ObjectSpecification
           do (if (i + 1 -> i) = 2 then
                  cd.com(#do current.dopt -> TT #);
                  current[] -> OG[];
                  (if true
                   // current.isBasicValue then
                      cd.com(#do 'primitive: ' -> TT; OG.primNo -> II #);
                      (if OG.primNo = float_prim then
                          (* we apparently compute inx * size
                           * this can be done in betaVM!?
                           *)
                          2 -> size  -> cd.pushConst;
                          66 (* mult *) -> cd.op
                       else
                          1 -> size
                      if);
                   // current.isValueObj then
                      cd.com(#do 'IndexPut:ValueObj:size: ' -> TT; 
                               current.ObjSize -> II; ' ' -> TT#);
                      1 -> isValueObj;
                      current.ObjSize -> size;
                      current.objSize -> cd.pushConst;
                      66 (* mult *) -> cd.op
                   else 
                      'ref' -> cd.comment;
                      true -> isRef;
                      1 -> size
           if)if)#)
        exit(isRef,isValueObj,size)
        #);
      org: ^Items
   do (if OG.primNo 
       // indexedPut_prim then 
          cd.com(#do 'invoke:indexedPut: ' -> TT; dopt -> TT #);
          (* Can indexedPut and other primtives
           * just be opcodes? May simplify things*)
          (# isRef: @boolean; isValueObj,size: @integer
          do getIndexedArgs -> (isRef,isValueObj,size);
             (if size = 0 then
                 'size = 0'->putline;
                 dopt->putline
             if);
             (if isRef then
                 cd.rswap;
                 ('inx',1) -> cd.xrstoreg
              else                 
                 (if false and (rec[] <> none) then 
                     (rec.ATd.OG.super.last).args.scanArgs
                     (# i: @ integer; OG: ^ObjectSpecification
                     do (if (i + 1 -> i) = 2 then
                            current[] -> OG[];
                            (if OG.primNo = float_Prim then
                                '**   got indexed float: ' -> puttext;
                                OG.dopt -> putline
                        if)if)
                     #);
                 if);
                 ('inx',1,isValueObj,size) -> cd.xstoreg  
          if)#)       
       // indexedGet_prim then
          (* check if rec is value or ref indexed *)
          (# isRef: @boolean; isValueObj,size: @integer
          do (if rec.ATd.primNo = indexedGet_prim then
                 (* The case for indexed::length *) 
                 ('inx',1,0,1) -> cd.xpushg
              else
                 getIndexedArgs -> (isRef,isValueObj,size);
                 (if isRef then
                     ('inx',1) -> cd.xrpushg
                  else
                     ('inx',1,isValueObj,size) -> cd.xpushg
          if)if)#)
       // stringGet_prim then
          ('inx',1,0,1) -> cd.xpushg  
       // indexed_prim then
          (# size,isRefIndexed: @integer; D: ^DataItem
          do (if elimOrigin then
                 cd.pushThis (* not used by allocIndexed - just popped *)
             if);
             E.args.scanArgs
             (# OG: ^ObjectSpecification; i: @integer
             do (if (i + 1 -> i) = 2 then
                    current[] -> OG[];
                    (if true 
                     // OG.primNo = integer_prim then
                        1 -> size;
                        0 -> isRefIndexed;
                     // OG.primNo = float_prim then
                        2 -> size;
                        0 -> isRefIndexed;
                        E[] -> Warning
                        (#
                        do 'Indexed Floats are not implemented' -> msg
                        #);
                     // OG.isValueObj then 
                        OG.objSize -> size; 
                        0 -> isRefIndexed;                     
                     else
                        1 -> size;
                        1 -> isRefIndexed;
             if)if)#); 
             (OG[],CC[],OG.computeVariant) -> objTmpStack.add;           
             (if elimOrigin then
                 1 -> cd.pushConst; (* dinx *)
              else
                 (* rsize may be from the first Beta compiler
                  * where there may be non-indexed data-items
                  * and indexed was the last declaration!?
                  * With qbeta no other data-items than indexed
                  *)
                 OG.IS.rsize -> cd.pushConst; (* dinx *)
             if);
             (if true then
                 cd.lcom(# di: ^dataItem
                        do E.dopt -> TT; ' ' -> TT; sig.dopt -> TT; 
                           ' ' -> TT;
                           E.father.father.father.dopt -> TT; ' ' -> TT;
                           E.father.father.father.label -> TT; ' ' -> TT;
                           (* may give a qual error:
                            E.father.father.father[] -> DI[];
                            DI.sig.dopt -> TT
                            *)
                        #);
                 (*(E.origin[]->org[]).encOG.OGidWdNo -> putline;*)
                 (*rec.ATd[] -> D[]; *)
                 (*D.off -> putint;
                  ' ' -> put; D.dopt -> putline;*)
                 
                 ((E.origin[]->org[]).encOG.OGidWdNo
                 ,OG.IS.newDescNo,size,isRefIndexed,staticOff) 
                   -> cd.allocIndexed;
              else
                 ('StaticRep',OG.IS.newDescNo,size,isRefIndexed,staticOff) 
                   -> cd.allocIndexed;
             if);
             (if staticOff > 0 then
                 cd.pushThis;
                 (if true then
                     (org.encOG.OGidWdNo,staticOff) -> cd.rstoreg
                  else
                     ('indexed',staticOff) -> cd.rstoreg
                 if)
             if)
          #)
       // asString_prim then
          ('asString',primNo) -> cd.callPrim
      if)
   #)   
---OtherPrim_invoke:doPart---
do (if OG.primNo    
    // ifthen_prim then
       '\n!!!! ifthen_prim: should not come here! ' -> putline;
         
       Tlab.new;
       exitLab.new;                   
       E.args.scanSons
       (# N: @integer
       do N + 1 -> N;
          (if N
           // 1 // 3 then
           // 2 then 
              (true,0,staticOff) -> current.Qgen;
              (Tlab,exitlab) -> cd.jmpFalse;
              Tlab -> cd.defLab
           // 4 then
              (false,0,staticOff) -> current.Qgen;
              exitLab -> cd.defLab;
           else
              'invoke:%if%then: too many arguments' -> putline;
              E.doPt -> putline
          if)
       #)                
    // inner_prim then
       (*'****  inner:gen: ' -> puttext; E.dopt -> puttext; ' ' -> put;
        * sig.dopt -> putline; dopt -> putline;
        * *)
       (if E.args.length > 0 then
           cd.com(#do 'inner:hasArgs:' -> TT; E.dopt -> TT; nl;
                 adr.print -> TT #);
           E.args.scanArgs
           (# A: ^ObjectSpecification; org: ^Items; orgIsVal: @boolean
           do current[] -> A[]; 
              cd.pushThis;
              (A.super.on - 1,A.super[]) 
                -> (E.origin[]->org[]).goOrigin -> (org[],orgIsVal); 
              (if org.basicNo = ifthen_prim then
                  (* we need to clean-up goOrigin *)
                  org.origin[] -> org[]
              if);
              org.innerInx -> cd.innerP; 
              cd.rpopThisObj
           #)
        else
           (if true 
            // '@inner' -> (E.doPT).equal 
            // 'inner' -> (E.doPT).equal then
               E.origin[] -> org[];
               org.innerInx -> cd.innerx; 
            else
               cd.com(#do 'inner:noArgs:' -> TT; E.dopt -> TT #);
               (#  orgIsVal: @boolean
               do (if false then
                      'Bingo: ' -> puttext; E.on -> putint; 
                      '\nE.origin:'->putline; E.origin.doPT -> putline;
                  if);
                  cd.pushThis;
                  (adr.superAdj,'origin-q') -> adjustOrigin;
                  (E.on ,none)
                    -> (E.origin[]->org[]).goOrigin -> (org[],orgIsVal); 
                  (if org.basicNo = ifthen_prim then
                      (* we need to clean-up goOrigin *)
                      org.origin[] -> org[]
                  if);
                  org.innerInx -> cd.innerP; 
                  cd.rpopThisObj
       #) if)if)
    // none_prim then 
       cd.pushNone
    // suspend_prim then
       cd.suspendd;
       (if coArg then
       (# vn,rn: @integer
       do (if rec.ATd.OG.primNo = this_prim then
              (*'**** suspend:this: ' -> puttext; rec.dopt -> putline*)
              (* we should get the argument of @this foo
               * and scan the formal parameters of foo
               *)
           else
              (* pushThis below is wrong
               * possible argumenst msut be stored in the object being resumed
               * This is the address on the rstack before suspend
               * Perhaps we can just do an rdouble before suspend!?
               * In any case we need to know if the objects is resumed by
               * a call of an attach.
               * A zero (0) or 1 on the vstack may be used for this
               * Not so easy! For attach we do not necessarily resumer after a
               * suspend. An object must thus keep ttack wheter it has 
               * suspended itself or is premmptively suspended
               * When resumed, the doCall bytecode msut then pop the vstack
               * if preepmtively suspended, but leave if itself has supended!
               * At one point we tried using scanNonBoundItemArgs below
               * but this is wrong
               *)
              rec.ATD.OG.IS.scanItemArgs
              (# DI: ^DataItem; 
              do (if currentArg## = DataItem## then
                     currentArg[] -> DI[];
                     cd.com(#do 'arg: ' -> TT; currentArg.dopt -> TQ #);
                     (if DI.isValue then 
                         (*'basic'->putline; *)
                         vn + 1 -> vn;
                         cd.com(#do 'rdouble' -> TT #);
                         cd.com(#do 'storeg ' -> TT; Di.newOff ->  II #);
                         cd.pushThis;
                         ('arg',DI.newOff) -> cd.storeg 
                      else
                         cd.com(#do 'rdouble' -> TT #);
                         cd.com(#do 'rstoreg ' -> TT; Di.newOff ->  II #);
                         cd.pushThis;
                         ('arg',DI.newOff) -> cd.rstoreg;
                         (* 'ref'->putline; *)
                         rn + 1 -> rn;
          if)if)#)if);
          cd.mvStack;
       #)if)
    // resume_prim then
       (if false then
           '**** call:'->putline; dopt ->putline;
           rec.dopt -> putline;
           rec.ATd.dopt -> putline;
       if);
       (# vn,rn: @integer
       do rec.ATD.OG.IS.scanItemArgs
       (# DI: ^DataItem; 
       do (* currentArg.dopt -> putline ;*)
          (if currentArg## = DataItem## then
              currentArg[] -> DI[];               
              (if DI.isValue then 
                  (*'basic'->putline; *)
                  vn + 1 -> vn;
                  cd.com(#do 'rdouble' -> TT #);
                  cd.com(#do 'storeg ' -> TT; Di.newOff ->  II #);
                  (*cd.rdouble; ('arg',DI.newOff) -> cd.storeg *)
               else
                  cd.com(#do 'rdouble' -> TT #);
                  cd.com(#do 'rstoreg ' -> TT; Di.newOff ->  II #);
                  (*cd.rdouble; ('arg',DI.newOff) -> cd.rstoreg;*)
                  (*ref'->putline; *)
                  rn + 1 -> rn;
       if)if)#);
       cd.com(#do 'noOfRefArg: ' -> TT; rn -> II; 
                'noOfVarg: ' -> TT; vn -> II #);
       #);
       ('Resume','D') -> cd.call;
       cd.rpop
    // disable_prim then
       ('disable',disable_prim) -> cd.callPrim
    // enable_prim then  
       ('enable',enable_prim) -> cd.callPrim   
    // put_prim then 
       ('put',OG.primNo) -> cd.Callprim
    // get_prim then
       ('get',OG.primNo) -> cd.callPrim
    // attach_prim then
       ('attach',OG.primNo) -> cd.callPrim;
       cd.rPop;
    // cmpAndSwap_prim then
       (# I: ^Invocation
       do E.father -> I[];
          L:
            I.scanSons
            (# R: ^Exp
            do current[] -> R[];
               cd.swap;
               cd.vpop;
               cd.swap;
               ('cmpAndSwap',OG.primNo ) -> cd.callPrim;
               leave L
            #)
       #)
    // fork_prim then
       ('fork',OG.primNo ) -> cd.callPrim
    // sleep_prim then
       ('sleep',OG.primNo ) -> cd.callPrim;
    // thisCore_prim then
       (*OG.markForCodeGen*)
    // file_open_prim then
       ('file_open',primNo) -> cd.callPrim
    // file_get_prim then
       ('File_get',primNo) -> cd.callPrim
    // file_eof_prim then
       ('File_eof',primNo) -> cd.callPrim
    // file_close_prim then
       ('File_close',primNo) -> cd.callprim     
    // dumpObj_prim then
       ('dumpObj_prim',primNo) -> cd.callprim  
    // log_prim then
       ('log_prim',primNo) -> cd.callprim  
    // printf_prim then
       ('printf_prim',primNo) -> cd.callprim            
    else
   if)
