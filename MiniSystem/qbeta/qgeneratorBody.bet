ORIGIN 'qgenerator'
---doMarkPrim:doPart---
do L:
     (if primNo
      // put_prim 
      // rAssign_prim 
      // vAssign_prim 
      // ifThen_prim then
         true -> value
      // restart_prim
      // leave_prim 
      // inner_prim 
      // none_prim
      // suspend_prim 
      // resume_prim
      // disable_prim 
      // enable_prim 
      // attach_prim
      // cmpAndSwap_prim
      // fork_prim
      // sleep_prim
      // indexedPut_prim 
      // indexedGet_prim
      // stringGet_prim
      // indexed_prim
      // asString_prim 
      // thisCore_prim 
      // file_open_prim 
      // file_get_prim 
      // file_eof_prim 
      // file_close_prim
      // dumpObj_prim 
         then
      else
         (if (sig[] <> none) then
             (if (sig.type ## = Sig.Binary##) and (primNo > 0) 
                 or 
                 (sig.type ## = Sig.Unary##) and (primNo = 65) then
                 leave L
             if);
         if);
         (if IS.isExternal > 0 then
          else
             true -> value       
         if)
     if);
   (if value = false then
       (*'doMarkPrim: '->puttext; primNo -> putint; newline*)
   if)
---GeneralPattern_invoke:doPart---
do (# doPrimElse: BooleanValue
        (# exNo: @integer
        do (if (sig.type ## = Sig.Binary##) and (OG.primNo > 0) 
               or 
               (sig.type ## = Sig.Unary##) and (OG.primNo = 65) then
               'bodyC:'->cd.comment;
               OG.primNo -> cd.op
            else
               (if (OG.IS.isExternal -> exNo) > 0 then
                   (* Origin is on rStack here, but is not used
                    * is popped by interpreter_c.c - not good,
                    * should avoid generating code for loadOrigin *)
                   (sig.id[],exNo) -> cd.invokeExternal
                else
                   true -> value       
        if)if)#);
      N:^ Node; di: ^DataItem; var: ^Variant; isVal,isObj: @boolean
   do (*(if not OG.IS.isEmpty then
       (OG.OGid,OG.sig[],OG[],OG.super[],CC[],none) -> ObjTmpStack.add;
       if);*)
      (if doPrimElse then
          (* Cases: E is an invocation of a pattern as in E, rec.E, R.rec.E, .
           * (a)The receiver, rec, may be a constant or variable dataItem
           * (For a variable DI, we forbid assigment etc if virtual Object)
           * We have rec.E, like Lrecord.insert(...)
           * rec may have virtual bindings that qualify data-items in E
           * E is an invocation of this(Pattern)
           * Find out if a new variant of this(Pattern) is needed
           * In List example insert is local to List
           * (b)The receiver may be a pattern as in Foo(...).bar(...)
           * (a) We may mark OG as having virtual Object: 
           * OG (insert) has probably no variants since local to List
           * We have to create a new variant based on the bindings 
           * in rec (Lrecord)
           * For each virtual Object ref, or DI there is a variant
           * with the corresponding bindings in the reciver
           * Note we may need to consider the whole invocation list
           * R.S.foo(...) R and S may have bindings
           *)
          cd.com(#do'Pattern:invoke:descNo:'->TT; OG.is.newDescNo -> II;
                   ' top:' -> TT; OG.Qvariants.top -> II;
                   ' rec:' -> TT; 
                   (if rec[] <> none then rec.dopt -> TQ else 'none'->TQ if)
                #);
          (* We must understand the differences between
           * computeVariant and computeVariantX and the different 
           * situations below where computeVarints(X) is called
           *)
          (if rec[] = E[] then
           else                
              (if rec.ATd## = dataItem## then 
                  (* if receiver is constant, then only one variant *)
                  rec.ATd[] -> OG.Qvariants.computeVariantX
                  (# H:: (# do head #);
                     head: @
                       (# done: @boolean
                       do (if not done then
                              true -> done;
                              ('\n***pattern:invoke:rec: '
                              ,rec.dopt,' . ',E.dopt,'\n'
                              ,OG.dopt,'\n')
                                -> putTextL;
                          if);
                       #);
                  #) -> var[];
                  (if var[] <> none then
                      (* var.print;  
                       og.qvariants.print*)
                  if)
               else 
                  (* receiver and rec.atd is module 
                   * or pattern (as in foo(e).bar) 
                   * but receiver is actually the return 
                   * value of foo *)
                  og.qvariants.computevariantx -> var[];
                  cd.com(#do 'rec:module or pattern:'-> tt; sig.id[] -> tq;
                           ' descno: ' -> tt; og.is.newdescno -> ii;
                           ' top: ' -> tt; og.qvariants.top -> ii; og.dopt->tq
                        #);
          if)if);
          
          (# di: ^dataItem; ptn: ^Pattern; isStatic: @boolean; N: ^Node
          do (if ptnkind // virtualptn // furtherptn // finalptn then
                 (if true
                  // rec.atd.isdataitem then
                     rec.atd[] -> di[];
                     di.og.isvalueobj or di.isconst -> isstatic
                  // rec.atd.ispattern then
                     (if rec[] <> e[] then (* we should eliminate rec=e *)
                         (* 'rec: ispattern:'->puttext; rec.dopt -> putline;*)
                         rec.atd[] -> ptn[]; 
                         (*ptn.sig.dopt -> putline; e.dopt -> putline;*)
                         
                         (ptn.getreturnog).isvalueobj 
                         or
                         (ptn.og.primno = indexedget_prim)
                           -> isstatic
                 if)if);
                 (if isstatic then
                     (sig.id[],og.is.newdescno,staticoff,true) 
                       -> cd.invoke
                  else
                     (sig.id[],off) -> cd.sendvirtual
                 if)
              else 
                 (if not isbasicptn then 
                     cd.com(#do 'invoke:var:'->tt; var[]=none -> bb; 
                              og.is.newdescno -> ii #);
                     (if og.isvalueobj then
                         (if staticoff = 0 then
                             cd.com(#do 'invokeval:x:staticoff=0:'->tt;
                                      sig.id[] -> tq#);
                             0 -> cd.pushconst
                          else
                             (sig.id[],og.is.newdescno,staticoff - 1) -> cd.invokeval;
                         if);
                         true -> isval
                      else
                         cd.com(#do 'kuk:' -> TT; 
                                  rec.ATD.father.father.father.label -> TT;
                                  ' rec:'->TT;
                                  rec.ATd.dopt -> TT;
                               #);
                         (if rec[] = E[] then
                             (* check if E is a const ref that must be marked
                              * as an object.
                              * A clean-up is needed - also for virtuals above *)
                             (if (rec.ATd.father.father.father[] -> N[]).isDataItem then
                                 rec.ATd.father.father.father[] -> DI[];
                                 DI.isConst -> isObj;
                                 cd.com(#do 'bingo:DI'->TT; DI.dopt -> TT #)
                         if)if);
                         isObj or
                         OG.returnsThis and useReturnValue -> isObj;
                         (sig.id[],OG.IS.newDescno,staticOff,isObj) -> cd.invoke
             if)if)if);
             (if not useReturnValue and not isVal then popReturn if);
          #)
      if)
   #);   
---AssignmentPattern_invoke:doPart--
do (# D: ^DataItem; recP: ^Pattern; destIsVal,srcIsVal: @boolean
   do cd.com(#do 'AssignmentPattern:invoke:rec:'-> TT; rec.doPt -> TT; 
               ':rec.ATd:' -> TT; rec.ATD.doPT -> TT; 
            #);
      
      (if rec.ATd.isPattern then 
          rec.ATd[] -> recP[];
          cd.com(#do '***** Assign to pattern - %this ' ->  putline #)
       else
          rec.ATd[] -> D[];
      (if true
       // D.OG.isSimpleValue then 
          cd.com(#do'#Store simple value: ' -> TT; rec.dopt -> TQ #)  
       // D.OG.isValueObj then 
          cd.com(#do '>Assign:StoreValue:rec:' -> TT; rec.dopt -> TQ; 
                   ',size:'->TT; D.objSize -> II #);
          true -> adr.destIsVal -> adr.isAdr;
          D.objSize -> adr.size;
          E.args.scanArgs
          (# OGa: ^ObjectGenerator; ptn: ^Pattern; DI: ^DataItem;
             descNo: @integer; org: ^Items
          do current[] -> OGa[];
            (* (if true or (OGa.super[]<> none) 
                 and (OGa.super.ATd[] <> none) then       *)          
                 (if OGa.super.ATd.isPattern then 
                     OGa.super.ATd[] -> ptn[];
                     ptn.sig.getReturn -> DI[];
                     (if (DI[] <> none) and DI.OG.isValueObj  then
                         (*'\n***assign:return:value: '->puttext; 
                          * DI.doPt -> putline; *)
                         DI.objSize -> cd.pushValue
                      else
                         (if ptn.OG.primNo 
                          // indexedGet_prim then 
                             (* '\n*** primno in assign:' -> puttext;
                              * ptn.dopt -> putline;
                              * D.dopt -> putline *)
                             D.OG.objSize -> cd.pushValue
                         else
                             ptn.OG.IS.newDescno -> descNo;
                             (* 'pattern:arg:'->puttext;
                              * descNo -> putint; ' ' -> put;
                              * current.dopt -> putline; 
                              *)
                             descNo -> adr.descNo;
                         if)
                     if)
                  else
                     (if OGa.super.ATd.isDataItem then
                         (* 'pattern:arg:isDataItem: '->puttext; 
                          * OGa.super.ATd.dopt -> puttext; 
                          *)
                         (if OGa.inValueObj then
                             true -> adr.srcIsVal
                         if);
                         (*newline*)
          if)if)(*if)*)#)
       else
          cd.com(#do 'Store reference: ' -> TT; rec.dopt -> TT#);
      if)if);
      
      (if isValueAssign then
          cd.com(#do 'vAssign:invoke:rec:' -> TT; rec.dopt -> TQ; ' E:' -> TT; E.dopt -> TQ #);
          cd.com(#do adr.print -> TT #);
          adr.store;
      else
          cd.com(#do 'rAssign:invoke:'-> TT; dopt -> TT; adr.print -> TT#);
          adr.store;
      if)
   #)
   
--BreakPatternInvoke:doPart---
do
   (# doBreak:
        (# IS: ^Items; Ex : ^ObjectGenerator; 
           primNo,ON: @integer
        enter primNo
        do E.args.scanArgs(# do current[] -> Ex[]#);
           Ex.super.on -> ON;
           (* We assume ON > 0 as in
            *    L: = { ... }
            * but perhaps not the case in
            *    cycle{ ... }
            *)
           ON - 1 -> (E.origin[] -> IS[]).toOrigin -> IS[];
           (if primNo
            // restart_prim then 
               (if ON = 1 then
                   IS.restartLab -> cd.jmp
                else
                   (ON - 1, IS.restartLab,IS.newDescNo) -> cd.break 
               if)
            // leave_prim then 
               (if ON = 1 then
                   IS.leaveLab -> cd.jmp
                else
                   (ON - 1, IS.leaveLab,IS.newDescNo) -> cd.break
               if)
           if)
        #);  
   do (if OG.primNo
       // restart_Prim then 
          restart_Prim -> doBreak
       // leave_Prim then 
          leave_Prim -> doBreak   
      if)
   #)
---IndexPattern_invoke:doPart---
do (# getIndexedArgs:
        (# D: ^DataItem; isRef: @boolean; isValueObj,size: @integer
        do rec.ATd[] -> D[];           
           1 -> size; (* Apparently scan below does not work for
                       * %put V: ?^ elm %at% inx: ?^ integer:
                       * implies size = 0
                       *)
           D.OG.scanActualArgs
           (# i: @integer
           do (if (i + 1 -> i) = 2 then
                  current.dopt -> cd.comment;
                  (if true
                   // current.isBasic then
                      'basic' -> cd.comment;
                      1 -> size
                   // current.isValueObj then
                      (* 'IndexPut:ValueObj:size: ' -> puttext; 
                       *  current.ObjSize -> putint;
                       * ' ' -> put; current.dopt -> putline; *)
                      1 -> isValueObj;
                      current.ObjSize -> size;
                      current.objSize -> cd.pushConst;
                      66 (* mult *) -> cd.op
                   else 
                      'ref' -> cd.comment;
                      true -> isRef;
                      1 -> size
           if)if)#)
        exit(isRef,isValueObj,size)
        #)
   do (if OG.primNo 
       // indexedPut_prim then 
          (* Can indexedPut and other primtives
           * just be opcodes? May simplify things*)
          (# isRef: @boolean; isValueObj,size: @integer
          do getIndexedArgs -> (isRef,isValueObj,size);
             (if size = 0 then
                 'size = 0'->putline;
                 dopt->putline
             if);
             (if isRef then
                 cd.rswap;
                 ('inx',1) -> cd.xrstoreg
              else
                 ('inx',1,isValueObj,size) -> cd.xstoreg  
          if)#)       
       // indexedGet_prim then
          (* check if rec is value or ref indexed *)
          (# isRef: @boolean; isValueObj,size: @integer
          do (if rec.ATd.primNo = indexedGet_prim then
                 (* The case for indexed::length *) 
                 ('inx',1,0,1) -> cd.xpushg
              else
                 getIndexedArgs -> (isRef,isValueObj,size);
                 (if isRef then
                     ('inx',1) -> cd.xrpushg
                  else
                     ('inx',1,isValueObj,size) -> cd.xpushg
          if)if)#)
       // stringGet_prim then
          ('inx',1,0,1) -> cd.xpushg  
       // indexed_prim then
          (# size,isRefIndexed: @integer
          do (if elimOrigin then
                 cd.pushThis (* not used by allocIndexed - just popped *)
             if);
             E.args.scanArgs
             (# OG: ^ObjectGenerator; i: @integer
             do (*current.dopt -> puttext; ' ' -> put;*)
                i + 1 -> i;
                (if i = 2 then
                    current[] -> OG[];
                    (if true 
                     // OG.primNo = integer_prim then
                        (*0 -> cd.pushConst; *)
                        0 -> isRefIndexed;
                        1 -> size
                     // OG.isValueObj then 
                        (*  '\n***Got value array: '->puttext; 
                         * E.dopt -> puttext; 
                         * ' ' -> put; OG.dopt -> puttext; *)
                        OG.objSize -> size; 
                        (*0 -> cd.pushConst;*)
                        0 -> isRefIndexed;                     
                        (*' size: ' -> puttext; size -> putint; newline;*)
                     else
                        (*'Got ref' -> puttext;*)
                        1 -> size;
                        (*1 -> cd.pushConst; *)
                        1 -> isRefIndexed;
             if)if)#); 
             (sig.id[],sig[],OG[],OG.super[],CC[],OG.computeVariant) 
               -> objTmpStack.add;           
             (if elimOrigin then
                 1 -> cd.pushConst; (* dinx *)
              else
                 (* rsize may be from the first Beta compiler
                  * where there may be non-indexed data-items
                  * and indexed was the last declaration!?
                  * With qbeta no other data-items than indexed
                  *)
                 OG.IS.rsize -> cd.pushConst; (* dinx *)
             if);
             (* ('StaticRep',OG.IS.newDescNo,false (*not used* ),true) 
                                                    -> cd.allocIndexed;*)
             ('StaticRep',OG.IS.newDescNo,size,isRefIndexed) -> cd.allocIndexed;
             (if staticOff > 0 then
                 cd.pushThis;
                 ('indexed',staticOff) -> cd.rstoreg
             if)
          #)
       // asString_prim then
          ('asString',primNo) -> cd.callPrim
      if)
   #)   
---OtherPrim_invoke:doPart---
do (if OG.primNo    
    // ifthen_prim then
       exitLab.new;                   
       E.args.scanSons
       (# N: @integer
       do N + 1 -> N;
          (if N
           // 1 // 3 then
           // 2 then 
              (true,0,staticOff) -> current.Qgen;
              exitlab -> cd.jmpFalse;
           // 4 then
              (false,0,staticOff) -> current.Qgen;
              exitLab -> cd.defLab;
           else
              'invoke:%if%then: too many arguments' -> putline;
              E.doPt -> putline
          if)
       #)                
    // inner_prim then
       (if E.args.length > 0 then
           E.args.scanArgs
           (# A: ^ObjectGenerator; org: ^Items; orgIsVal: @boolean
           do current[] -> A[]; 
              cd.pushThis;
              (A.super.on - 1,A.super[]) -> (E.origin[]->org[]).goOrigin -> (org[],orgIsVal); 
              (if org.basicNo = ifthen_prim then
                  (* we need to clean-up goOrigin *)
                  org.origin[] -> org[]
              if);
              org.innerInx -> cd.innerP; 
              cd.rpopThisObj
           #)
        else
           E.origin[] -> org[];
           org.innerInx -> cd.innerx; 
       if)
    // none_prim then 
       cd.pushNone
    // suspend_prim then
       cd.suspendd
    // resume_prim then
       ('Resume','D') -> cd.call;
       cd.rpop
    // disable_prim then
       ('disable',disable_prim) -> cd.callPrim
    // enable_prim then  
       ('enable',enable_prim) -> cd.callPrim   
    // put_prim then 
       ('put',OG.primNo) -> cd.Callprim
    // attach_prim then
       ('attach',OG.primNo) -> cd.callPrim;
       cd.rPop;
    // cmpAndSwap_prim then
       (# I: ^Invocation
       do E.father -> I[];
          L:
            I.scanSons
            (# R: ^Exp
            do current[] -> R[];
               cd.swap;
               ('cmpAndSwap',OG.primNo ) -> cd.callPrim;
               leave L
            #)
       #)
    // fork_prim then
       ('fork',OG.primNo ) -> cd.callPrim
    // sleep_prim then
       ('sleep',OG.primNo ) -> cd.callPrim;
    // thisCore_prim then
       (*OG.markForCodeGen*)
    // file_open_prim then
       ('file_open',primNo) -> cd.callPrim
    // file_get_prim then
       ('File_get',primNo) -> cd.callPrim
    // file_eof_prim then
       ('File_eof',primNo) -> cd.callPrim
    // file_close_prim then
       ('File_close',primNo) -> cd.callprim     
    // dumpObj_prim then
       ('dumpObj_prim',primNo) -> cd.callprim     
    else
   if)
