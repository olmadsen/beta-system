ORIGIN 'qgenerator'
---doMarkPrim:doPart---
do L:
     (if primNo
      // put_prim 
      // assign_prim 
      // ifThen_prim then
         true -> value
      // restart_prim
      // leave_prim 
      // inner_prim 
      // none_prim
      // suspend_prim 
      // resume_prim
      // disable_prim 
      // enable_prim 

      // attach_prim
      // cmpAndSwap_prim
      // fork_prim
      // sleep_prim
      // indexedPut_prim 
      // indexedGet_prim
      // stringGet_prim
      // indexed_prim
      // asString_prim 
      // thisCore_prim 
      // file_open_prim 
      // file_get_prim 
      // file_eof_prim 
      // file_close_prim          
         then
      else
         (if (sig[] <> none) then
             (if (sig.type ## = Sig.Binary##) and (primNo > 0) 
                 or 
                 (sig.type ## = Sig.Unary##) and (primNo = 65) then
                 leave L
             if);
         if);
         (if IS.isExternal > 0 then
          else
             true -> value       
         if)
     if);
   (if value = false then
       (*'doMarkPrim: '->puttext; primNo -> putint; newline*)
   if)
   
---doPrimElse:doPart---
do (if OG.primNo    
    // ifthen_prim then
       exitLab.new;                   
       E.args.scanSons
       (# N: @integer
       do N + 1 -> N;
          (if N
           // 1 // 3 then
           // 2 then 
              (true,0,staticOff) -> current.Qgen;
              exitlab -> cd.jmpFalse;
           // 4 then
              (false,0,staticOff) -> current.Qgen;
              exitLab -> cd.defLab;
           else
              'invoke:%if%then: too many arguments' -> putline;
              E.doPt -> putline
          if)
       #); 
                
    // inner_prim then
       (if E.args.length > 0 then
           E.args.scanArgs
           (# A: ^ObjectGenerator; org: ^Items
           do current[] -> A[]; 
              cd.pushThis;
              (A.super.on - 1,A.super[]) -> (E.origin[]->org[]).goOrigin -> org[]; 
              (if org.basicNo = ifthen_prim then
                  (* we need to clean-up goOrigin *)
                  org.origin[] -> org[]
              if);
              org.innerInx -> cd.innerP; 
              cd.rpopThisObj
           #)
        else
           E.origin[] -> org[];
           org.innerInx -> cd.innerx; 
       if)
    // none_prim then 
       cd.pushNone
    // suspend_prim then
       cd.suspendd
    // resume_prim then
       ('Resume','D') -> cd.call;
       cd.rpop
    // disable_prim then
       ('disable',disable_prim) -> cd.callPrim
    // enable_prim then  
       ('enable',enable_prim) -> cd.callPrim   
    // put_prim then 
       ('put',OG.primNo) -> cd.Callprim
    // attach_prim then
       ('attach',OG.primNo) -> cd.callPrim;
       cd.rPop;
    // cmpAndSwap_prim then
       (# I: ^Invocation
       do E.father -> I[];
          L:
            I.scanSons
            (# R: ^Exp
            do current[] -> R[];
               cd.swap;
               ('cmpAndSwap',OG.primNo ) -> cd.callPrim;
               leave L
            #)
       #)
    // fork_prim then
       ('fork',OG.primNo ) -> cd.callPrim
    // sleep_prim then
       ('sleep',OG.primNo ) -> cd.callPrim;
    // thisCore_prim then
       (*OG.markForCodeGen*)
    // file_open_prim then
       ('file_open',primNo) -> cd.callPrim
    // file_get_prim then
       ('File_get',primNo) -> cd.callPrim
    // file_eof_prim then
       ('File_eof',primNo) -> cd.callPrim
    // file_close_prim then
       ('File_close',primNo) -> cd.callprim       
    else
       (if (sig.type ## = Sig.Binary##) and (OG.primNo > 0) 
           or 
           (sig.type ## = Sig.Unary##) and (OG.primNo = 65) then
           'bodyC:'->cd.comment;
           OG.primNo -> cd.op
        else
           (if (OG.IS.isExternal -> exNo) > 0 then
               (* Origin is on rStack here, but is not used
                * is popped by interpreter_c.c - not good,
                * should avoid generating code for loadOrigin *)
               (sig.id[],exNo) -> cd.invokeExternal
            else
               true -> value       
   if)if)if)
