ORIGIN 'qgenerator'
---doMarkPrim:doPart---
do L:
     (if primNo
      // put_prim 
      // assign_prim 
      // ifThen_prim then
         true -> value
      // restart_prim
      // leave_prim 
      // inner_prim 
      // none_prim
      // suspend_prim 
      // resume_prim
      // disable_prim 
      // enable_prim 

      // attach_prim
      // cmpAndSwap_prim
      // fork_prim
      // sleep_prim
      // indexedPut_prim 
      // indexedGet_prim
      // stringGet_prim
      // indexed_prim
      // asString_prim 
      // thisCore_prim 
      // file_open_prim 
      // file_get_prim 
      // file_eof_prim 
      // file_close_prim          
         then
      else
         (if (sig[] <> none) then
             (if (sig.type ## = Sig.Binary##) and (primNo > 0) 
                 or 
                 (sig.type ## = Sig.Unary##) and (primNo = 65) then
                 leave L
             if);
         if);
         (if IS.isExternal > 0 then
          else
             true -> value       
         if)
     if);
   (if value = false then
       (*'doMarkPrim: '->puttext; primNo -> putint; newline*)
   if)
   
---doPrimElse:doPart---
do (if OG.primNo
    // assign_prim then
       (if newAlloc and ((rec.ATd.desc).newDescNo = 0) then
           'descNo = 0'-> cd.comment;
           rec.ATD.dopt -> cd.comment
       if);
       cd.com(#do 'doPrimElse:assign:'-> T; dopt -> T#);
       (if valueImpl and (adr[] <> none) then
           cd.com(#do 'doPrimElse:adr:'-> T; adr.print -> T #);
           adr.store;
        else
           (false,hOff)-> rec.ATd.store;                   
       if)
    // ifthen_prim then
       exitLab.new;                   
       E.args.scanSons
       (# N: @integer
       do N + 1 -> N;
          (if N
           // 1 // 3 then
           // 2 then 
              (true,0,staticOff) -> current.Qgen;
              exitlab -> cd.jmpFalse;
           // 4 then
              (false,0,staticOff) -> current.Qgen;
              exitLab -> cd.defLab;
           else
              'invoke:%if%then: too many arguments' -> putline;
              E.doPt -> putline
          if)
       #); 
    // restart_Prim then 
       restart_Prim -> doBreak
    // leave_Prim then 
       leave_Prim -> doBreak                   
    // inner_prim then
       (if E.args.length > 0 then
           E.args.scanArgs
           (# A: ^ObjectGenerator; org: ^Items
           do current[] -> A[]; 
              cd.pushThis;
              (A.super.on - 1,A.super[]) -> (E.origin[]->org[]).goOrigin -> org[]; 
              (if org.basicNo = ifthen_prim then
                  (* we need to clean-up goOrigin *)
                  org.origin[] -> org[]
              if);
              org.innerInx -> cd.innerP; 
              cd.rpopThisObj
           #)
        else
           E.origin[] -> org[];
           org.innerInx -> cd.innerx; 
       if)

    // none_prim then 
       cd.pushNone
    // suspend_prim then
       cd.suspendd
    // resume_prim then
       ('Resume','D') -> cd.call;
       cd.rpop
    // disable_prim then
       ('disable',disable_prim) -> cd.callPrim
    // enable_prim then  
       ('enable',enable_prim) -> cd.callPrim   
    // put_prim then 
       ('put',OG.primNo) -> cd.Callprim
    // attach_prim then
       ('attach',OG.primNo) -> cd.callPrim;
       cd.rPop;
    // cmpAndSwap_prim then
       (# I: ^Invocation
       do E.father -> I[];
          L:
            I.scanSons
            (# R: ^Exp
            do current[] -> R[];
               cd.swap;
               ('cmpAndSwap',OG.primNo ) -> cd.callPrim;
               leave L
            #)
       #)
    // fork_prim then
       ('fork',OG.primNo ) -> cd.callPrim
    // sleep_prim then
       ('sleep',OG.primNo ) -> cd.callPrim;
    // indexedPut_prim then (* Can indexedPut and other primtives
                             * just be opcodes? May simplify things*)
       (# D: ^DataItem; isRef: @boolean
       do rec.ATd[] -> D[];
          D.OG.scanActualArgs
          (# i: @integer
          do (if (i + 1 -> i) = 2 then
                 current.dopt -> cd.comment;
                 (if current.isBasic then
                     'basic' -> cd.comment;
                  else 
                     'ref' -> cd.comment;
                     true -> isRef;
             if)if);
          #);
          (if isRef then
              cd.rswap;
              ('inx',1) -> cd.xrstoreg
           else
              ('inx',1) -> cd.xstoreg  
          if)
       #)
       
    // indexedGet_prim then
       (if false then
           (if (OG.primNo =  indexedGet_prim) then
               'indexedGet_prim: \n'->puttext; dopt -> putline;;
               E.dopt -> putline;
               'rec: ' -> puttext; rec.doPT -> putline;
               'indexedGet_prim:' -> cd.comment;
               (E.father.dopt,rec.doPT) -> cd.com2;
               rec.ATd.dopt -> cd.comment;
               (# T: @text
               do rec.ATd.primNo -> T.putint; T[] -> cd.comment;
               #);
       if)if);
       (* check if rec is value or ref indexed *)
       (# D: ^DataItem; isRef: @boolean
       do (if rec.ATd.primNo = indexedGet_prim then
              (* The case for indexed::length *)
              ('inx',1) -> cd.xpushg
           else
              rec.ATd[] -> D[];
              D.OG.scanActualArgs
              (# i: @integer
              do (if (i + 1 -> i) = 2 then
                     current.dopt -> cd.comment;
                     (if current.isBasic then 
                         'value' -> cd.comment;
                      else 
                         'ref' -> cd.comment;
                         true -> isRef
                 if)if)
              #);
              (if isRef then
                  ('inx',1) -> cd.xrpushg
               else
                  ('inx',1) -> cd.xpushg
              if);
          if)
       #)
    // stringGet_prim then
       ('inx',1) -> cd.xpushg  
    // indexed_prim then
       (*'\ninvoke:Indexed: ' -> putline;
        dopt-> putline;
        E.dopt -> putline;*)
       (if elimOrigin then
           cd.pushThis (* not used by allocIndexed - just popped *)
       if);
       E.args.scanArgs
       (# OG: ^ObjectGenerator; i: @integer
       do (*current.dopt -> puttext; ' ' -> put;*)
          i + 1 -> i;
          (if i = 2 then
              current[] -> OG[];
              (if Og.primNo = integer_prim then
                  (*'Got value' -> puttext;*)
                  0 -> cd.pushConst;   (* not isRindexed *)
               else
                  (*'Got ref' -> puttext;*)
                  1 -> cd.pushConst;   (* isRindexed *)
          if)if)
       #); 
       (*newline;*)
       (sig.id[],sig[],OG[],OG.super[],CC[],OG.computeVariant) 
         -> objTmpStack.add;           
       (if elimOrigin then
           1 -> cd.pushConst; (* dinx *)
        else
           (* rsize may be from the first Beta compiler
            * where there may be non-indexed data-items
            * and indexed was the last declaration!?
            * With qbeta no other data-items than indexed
            *)
           OG.IS.rsize -> cd.pushConst; (* dinx *)
       if);
       ('StaticRep',OG.IS.newDescNo,false (*not used*),true) 
         -> cd.allocIndexed;
       (if staticOff > 0 then
           cd.pushThis;
           ('indexed',staticOff) -> cd.rstoreg
       if)
    // asString_prim then
       ('asString',primNo) -> cd.callPrim
    // thisCore_prim then
       (*OG.markForCodeGen*)
    // file_open_prim then
       ('file_open',primNo) -> cd.callPrim
    // file_get_prim then
       ('File_get',primNo) -> cd.callPrim
    // file_eof_prim then
       ('File_eof',primNo) -> cd.callPrim
    // file_close_prim then
       ('File_close',primNo) -> cd.callprim       
    else
       'bodyA:'->cd.comment;
       (if adr[] <> none then
           adr.load
       if);
       'bodyB:'->cd.comment;
       (if (sig.type ## = Sig.Binary##) and (OG.primNo > 0) 
           or 
           (sig.type ## = Sig.Unary##) and (OG.primNo = 65) then
           'bodyC:'->cd.comment;
           OG.primNo -> cd.op
        else
           (if (OG.IS.isExternal -> exNo) > 0 then
               (* Origin is on rStack here, but is not used
                * is popped by interpreter_c.c - not good,
                * should avoid generating code for loadOrigin *)
               (sig.id[],exNo) -> cd.invokeExternal
            else
               true -> value       
   if)if)if)
