ORIGIN 'qgenerator'
---GeneralPattern_invoke:doPart---
do (# doPrimElse: BooleanValue
        (# exNo: @integer;
           selectPrimitiveOrCompoundEQ:
             (# OGx: ^ObjectGenerator; DI: ^DataItem
             do (rec.ATd.asDecl).OG[] -> OGx[];
                cd.fcom(#do 'rec:'->TT; rec.dopt -> TQ; rec.label ->TQ;
                          'OGx.label:'->TT; OGx.label -> TQ;
                          'OGx:'->TT; OGx.dopt->TT #);
                cd.fcom(#do 'rec.ATd:'->TT; rec.ATd.dopt -> TQ #);
                (if (OGx.getReturnDecl -> DI[]) <> none then
                    DI.OG[] -> OGx[]
                if);
                
                cd.fcom
                (#do 'bobs:'->TT; OGx.primNo->II; 'OGx:'->TT; OGx.dopt->TT;#);
                (if DI[] <> none then
                    cd.fcom(#do 'DI.OG:' -> TT; DI.OG.dopt -> TT#);
                if);
                (if OGx.primNo = 0 then
                    (rec.ATd.asDecl).OG.objSize -> cd.vEq
                 else
                    (* we assume a primitive value *)
                    OG.primNo -> cd.op
                if)
             #);
        do (if (sig.isBinary) and (OG.primNo > 0) or (OG.primNo =65(*not*)) then
               (if true // OG.primNo = veq_prim //  OG.primNo = vLE_prim  then
                   selectPrimitiveOrCompoundEQ
                else
                   (if (rec[],E[]) -> checkInt2IntWithUnitArg then
                       (if E.ATd.OG.primNo
                        // 61 (* + *) then
                           109 -> cd.op
                        // 66 (* * *) then
                           112 -> cd.op
                       if)
                    else
                       OG.primNo -> cd.op
               if)if)
            else
               (if (OG.IS.isExternal -> exNo) > 0 then
                   (* Origin is on rStack here, but is not used
                    * is popped by interpreter_c.c - not good,
                    * should avoid generating code for loadOrigin *)
                   (sig.id[],exNo) -> cd.invokeExternal
                else
                   true -> value       
           if)if)
        #);
      mkObjId:
        (# OGx: ^ObjectGenerator; vObjId: ^text
        enter OGx[]
        do (if OGx.vDescNo > 0 then
               OGx.sig.dopt -> vObjId[];
               '$' -> vObjId.put;
               OGx.vDescNo -> vObjId.putint;
               '$' -> vObjId.put;
               OGx.vDescNo -> vObjId.putint; 
            else
               OGx.OGidWdNo -> vObjId[];
           if) 
        exit vObjId[]
        #);
      boxedInvokeVal:
        (# id: ^text; dNo: @integer; useRtnVal: @boolean; DI: ^DataItem
        enter(id[],dNo,useRtnVal)
        do (id[],dNo,OG.objSize) -> cd.boxedInvokeVal;
           (* the return from BoxedInvodeVal is quite tricky 
            * Saved return in boxedInvokeVal is set to after cd.rtn 
            * since the invokeValue in boxedInvokeValue
            * will return to cd.mvStack and we must avoid executing
            * the code below twice - see also betaVM::boxedInvokeVal
            *)
           cd.mvStack;
           cd.rtn;
        #);
      checkIsUnitArg2N: BooleanValue
        (# n: @integer; Ux: ^Text; OI: ^ObjectInvocation;
        do E.args.scanArgs
           (#
           do current.getExpUnit -> Ux[];
              n + 1 -> n;
           #);
           (if (n = 1) and (Ux[] <> none) then
               (if true
                // '#I' -> Ux.equal // '#F' -> Ux.equal then
                else
                   Ux[] -> (E[]->OI[]).isUnitArg2N
                   (# isInt:: (#do cd.F2I; true -> value #);
                      isFloat::(##)
                   #) -> Ux[]
           if)if)
        #);
      N:^ Node; di: ^DataItem; isVal,isObj: @boolean;
      ATdx: ^Decl; mkI2F: @boolean
   do (if doPrimElse then
          (* Cases: E is an invocation of a pattern as in E, rec.E, R.rec.E, .
           * (a)The receiver, rec, may be a constant or variable dataItem
           * (For a variable DI, we forbid assigment etc if virtual Object)
           * We have rec.E, like Lrecord.insert(...)
           * rec may have virtual bindings that qualify data-items in E
           * E is an invocation of this(Pattern)
           * In List example insert is local to List
           * (b)The receiver may be a pattern as in Foo(...).bar(...)
           *)
          (# DI: ^dataItem; ptn: ^Pattern; 
             isValue,isStatic,returnsValueObj,recIsValObj:  @boolean; 
             org: ^Items; noOfRefArgs: @integer; vObjId: ^text
          do cd.com(#do 'GPTN:invoke:'->TT; ptnKind -> II #);
             (if ptnkind // virtualptn // furtherptn // finalptn then
                 (if true
                  // 'var' -> (rec.father.father.father.label).equal
                  // 'val' -> (rec.father.father.father.label).equal then
                     (* This is really a hack!!! *)
                     true -> isStatic -> isValue;
                     rec.father.father.father[] -> DI[];
                     DI.newOff -> staticOff; 
                  // (rec.ATd.asDecl).isDataItem then 
                     cd.com(#do 'isDI'-> TT#);
                     rec.ATd.asDecl -> DI[];
                     DI.OG.isValueObj or DI.isConst -> isStatic;
                  // (rec.ATd.asDecl).isPattern then
                     cd.com(#do 'isPtn'-> TT#);
                     (if rec[] <> e[] then (* we should eliminate rec=e *)
                         rec.ATd.asDecl -> ptn[]; 
                         (ptn.getReturnOG).isValueObj 
                         or
                         (ptn.og.primno = indexedget_prim) -> isstatic
                 if)if);
                 cd.com(#do 'isStatic:'->TT; isStatic->BB; 
                          'rec:'->TT; rec.dopt->TQ #);
                 (if isStatic then
                     (if isValue then
                         (sig.id[],new_descNo,staticOff - 1,inValueObj)
                           -> cd.invokeval;
                         true -> isVal
                      else
                         (OG[],staticOff,false) -> callInvoke
                     if)
                  else
                     (* OG may have ref-args that will be above the
                      * obj-ref to be dispatched.
                      * S is the obj-ref and x, y and z are obj-args
                      * The noOfRefArgs is passed to invokeV
                      * ------------      ------------
                      * |...|S|x|y|z  ==> |...|x|y|z|S
                      * ------------      ------------
                      *)
                     OG.IS.noOfObjArgs -> noOfRefArgs;
                     (if rec[] = E[] then
                         E.origin[] -> org[];
                         (for i: E.on repeat
                              org.father.origin[] -> org[];
                         for);
                         org.encOG.isValueObj -> recIsValObj 
                     if);
                     OG[] -> mkObjId -> vObjId[];                         
                     (vObjId[],off,noOfRefArgs,recIsValObj)-> cd.invokeV
                     (# originOff::
                          (# ISx: ^Scope
                          do OG.IS.isEmpty -> usestub;
                             (OG.IS.topSuper).encOG.OGidWdNo ->topSuperId[];
                             (OG.origin[]->ISx[]).encOG.OGidWdNo -> type[];
                             OG.IS.newOriginOff -> off;
                             (if OG.IS.isEmpty then
                                 (OG.super.ATd.asDecl).OG.IS.newOriginOff 
                                   -> off
                     if)#)#);
                     (* Push return value; should we check useRtnVal ? *)
                     (OG[],vObjId[]) -> pushOut
                     (* callee is on rtop of rStack *)
                 if)
              else 
                 (if not isPrimitivePtn then
                     (if (getReturnDecl -> DI[]) <> none then
                         DI.isValue -> returnsValueObj
                     if);
                     (if OG.isValueObj then
                         (if staticOff = 0 then
                             (if (DI[] <> none) and DI.OG.isValueObj then
                                 'A'->cd.nop;
                                 '**** BoxedInvokeVal:'->dumpT;
                                 sig.id[] -> dumpTN;
                                 (sig.id[],OG.is.newdescno,useRtnVal) 
                                   -> BoxedInvokeVal
                              else
                                 0 -> cd.pushConst
                             if)
                          else
                             (sig.id[],OG.is.newdescno,staticoff - 1,inValueObj)
                               -> cd.invokeVal
                             (# T: ^text
                             do cd.thisClassId[] -> T[]; 
                                OG.IS.scanItemArgsReverse
                                (# DI: ^DataItem
                                do cd.pushThis;
                                   (if (currentArg[]->DI[]).isBasicValue 
                                       then
                                       (T[],DI.newOff + staticOff)
                                         -> cd.storeX
                                    else
                                       (T[],DI.newOff + staticOff,false)
                                         -> cd.rstoreX
                         if)#)#)if);
                         true -> isval
                      else 
                         (if rec[] = E[] then
                             (* check if E is a const ref that must be marked
                              * as an object.
                              * A clean-up is needed -also for virtuals above *)
                             (if ((rec.ATd.asDecl).father.father.father[] 
                                   -> N[]).isDataItem then
                                 (rec.ATd.asDecl).father.father.father[]-> DI[];
                                 DI.isConst -> isObj;
                         if)if);
                         isObj or OG.returnsThis and useRtnVal -> isObj;
                         checkIsUnitArg2N -> mkI2F;
                         (if true then
                             (*(# org: ^Items
                             do '**** invoke: ' -> puttext;
                                (OG.origin[]->org[]).newDescNo -> putint; 
                                newline;
                                OG.dopt->putline
                              #);*)
                             (* we dont use isObj here,
                              * callInvoke uses OG.isObj
                              *)
                             (OG[],staticOff,false) -> callInvoke
                          else
                             (sig.id[],OG.IS.newDescno,OG.IS.objSize
                             ,staticOff,isObj)
                               -> cd.invoke;
                     if)if); 
                     (if mkI2F then cd.I2F if)
                  else
                     (if primno 
                      // this_prim then
                      // string_prim then
                         true -> useRtnVal
                      // integer_prim then
                         0 -> cd.pushConst
                      // log_prim then
                         ('log_prim',primNo) -> cd.callprim  
                      // printf_prim then
                         ('printf_prim',primNo) -> cd.callprim
                      // sqrt_prim then
                         ('sqrt_prim',primNo) -> cd.callprim  
                      // cbrt_prim then
                         ('cbrt_prim',primNo) -> cd.callprim  
                      // floatToString_prim then
                         ('floatToString_prim',primNo) -> cd.callPrim
                      else
                         E.dopt -> putline;
                         E.label -> putline; primNo -> putint; ' ' ->put;
                         isPrimitivePtn -> putBoolean; newline;
                         E[] -> warning
                         (#
                         do 'The use of the basic pattern "' -> msg; 
                            sig.dopt -> msg;
                            '" here may give an error' -> msg;
                         #);
             if)if)if);
             (if not useRtnVal and (not isVal or withValueProxy) then popReturn if)
      #)if)
   #);   
---AssignmentPattern_invoke:doPart--
do (# isArgOfAssignI2IwithUniValArg: BooleanValue
        (* for the case: a3 := 3 * a2 where a3 and a2 are UnitValueObj
         * and * is int2int, typeOf('* a2') is unit and not int;
         * at this place: this(pattern) = AssignmentPattern;
         * rec: 'a3', E: ':= 3 * a2', arg = '3 * a2';
         * we check if arg has the form '3 * a2' and decode into
         * recx = '3' and argx = '* a2'
         *)
        (# arg: ^ObjectGenerator; recx,argx: ^Exp;  i: @integer
        enter arg[]
        do (if arg.IS.isEmpty then
               arg.super.scanSons
               (# 
               do i + 1 -> i;
                  (if i 
                   // 1 then 
                      current[] -> recx[]
                   // 2 then
                      current[] -> argx[]
               if)#);
               (if i = 2 then
                   (recx[],argx[]) -> checkInt2IntWithUnitArg -> value;
           if)if)
        #);
      
      dstDI,srcDI: ^Decl(*DataItem*); arg: ^ObjectSpecification;  
      ptn: ^Pattern; UT: ^text;
      asgKind: @integer; (* basic: 1
                          * value: 2 but not basic
                          * ref  : 3
                          *)
   do (if (rec.ATd.asDecl).isPattern then 
          cd.com(#do 'Assign to pattern - %this ' -> TT; print #)
       else
          E.args.scanArgs(#do current[] -> arg[] #); 
          (* Only one argument since assign *)
          rec.ATd.asDecl -> dstDI[];
          (if dstDI.OG.primNo 
           // indexed_prim then
              (if arg.bracketedListElement > 0 then
                  arg.bracketedListElement -> cd.pushConst;
                  (dstDI.OG.super.ATd.asDecl).OG.IS.newDescNo -> cd.mkVindexed
              if)
           // rindexed_prim then
              (if arg.bracketedListElement > 0 then
                  arg.bracketedListElement -> cd.pushConst;
                  (dstDI.OG.super.ATd.asDecl).OG.IS.newDescNo -> cd.mkRindexed
              if)
          if);
          (if true
           // dstDI.OG.isBasicValue // dstDI.OG.primNo = value_prim 
           // dstDI.OG.isUnitValueObj and 
              ((arg.super.ATd.asDecl).OG.isUnitValueObj 
              or (arg.super.ATd.asDecl).isFloat 
              or (arg.super.ATd.asDecl).isInteger) then 
              
              (* 2024-04-15: we should make clear why we come here; the above
               * condition is very complicated; 
               *)
              
              (* dstDI.OG.primNo = value_prim for handling _v: var Value 
               * in integer, char and boolean *)
              (* 1: X := Y - ok if X, Y are basic values
               * 2: X := Y - ok, if X, Y are UnitValueObjs
               * 3: X := Y * Z, OK, if X, Y both are basic values
               * 4: X := Y * Z, OK, if X, Y both UnitValueObjs
               * 5: X := foo(exp), OK, if X is basic value 
               * and foo returns basic value
               * 6: X := foo(exp), not OK, if X is UbitValueObj 
               * and foo returns UnitValueObj
               * 1,3,4: handled by dstDI.isBasicValue
               * 2: dstDI.OG.isUnitValueObj and arg.isUnitValueObj 
               * (this test dont work)
               *                    arg.isDataItem => unitValueObj
               * 5: dstDI.og.IsUnitValueObj and not arg.isPattern 
               * and not basicPattern
               * 
               *)
              (* for X := Y and X := Foo, we come here 
               * - should not come here for Foo
               * for X := Y * Z, we do not come here 
               * since Y * Z is not UnitValueObj
               * perhaps test for basic pattern?
               * The above comments are not up-to-date
               *)
              (if not (arg[] -> isArgOfAssignI2IwithUniValArg) then
                  dstDI[] -> arg.checkNumberConvert
                  (# I2F:: (#do cd.I2f #);
                     F2I:: (# do cd.F2I #);
                  #)
              if);
              1 -> asgKind
           // dstDI.OG.isValueObj and not (dstDI.OG.primNo = String_prim) then 
              (* X: = Y where Y is a ValueObj that is not a unit 
               * - but yet not tested above!
               * X := foo where foo  is a pattern
               *)
              true -> adr.destIsVal -> adr.isAdr;
              dstDI.objSize -> adr.size;
              (* Clean-up needed. Currenlty we assume that we have an assigment
               * dst := src, where dst is a dimension.unit being a sub of Value
               * and src is a float or an integer.
               * getUnit should always return UT[] <> none, 
               * but this is not the case!
               *)           
              (if true
               // (arg.super.ATd.asDecl).isPattern then 
                  (arg.super.ATd.asDecl -> ptn[]).getReturnDecl -> srcDI[];
                  (if not ((srcDI[] <> none) and srcDI.OG.isValueObj) then
                      (if ptn.OG.primNo <> indexedGet_prim then 
                          ptn.OG.IS.newDescno -> adr.descNo;
                  if)if)
               // (arg.super.ATd.asDecl).isDataItem then
                  arg.inValueObj -> adr.srcIsVal
              if);
              2 -> asgKind
           else
              (if dstDI.OG.primNo = String_prim then
                  true -> adr.isAdr
              if);
              3 -> asgKind
      if)if);

      (if arg.IS.isUnique then 
          (* only relevant for references! Should also be checked *)
          (if not dstDI.OG.IS.isUnique then
              E[] -> SemanticError
              (#
              do 'In the assignment of "' -> msg; E.dopt -> msg; 
                 '" to "' -> msg; dstDI.doPT -> msg; 
                 '",\n     the source is unique, but the the destination is not!' 
                   -> msg
      #)if)if);
      (if useRtnVal then
          (* assignment is last statement in main part
           * where super has redefined inner to return a value
           *)
          (if asgKind
           // 1 (* basic value *) then cd.double
           // 2 (* compound value obj *) then
              '\n!!!!OBS! Mainpart returning compound value is not implemented!'
              -> putline;
           // 3 (* reference *) then
              cd.rdouble;
              '\n!!!! OBS! Mainpart returning a refence may not work!'
                -> putline;
           else
              '\n!!!! OBS! Mainpart returning unknown value!*' 
                -> putline;
      if)if);
      rec[] -> adr.E[]; (* perhaps a hack for lLVM ?? *)
      adr.store; (* generate the assigment code *)
   #)
   
--BreakPatternInvoke:doPart---
do
   (# doBreak:
        (# trace:
             (# T: ^text
             enter T[]
             do (if false then
                    '**** Break: "' -> puttext; E.dopt -> puttext; 
                    '" arg: "' -> puttext; Ex.dopt -> puttext;
                    '" lab: "' -> puttext; Ex.label -> puttext;
                    '"' -> put;
                    '\n**   ON: ' -> puttext; on -> putint; 
                    ' descNo: ' -> puttext; IS.newDescNo -> putint;
                    ' noOfSuper: ' -> puttext; noOfSuper -> putint;
                    newline;
                    (if ONs > 0 then
                        '**   BreakToSuper: ONs:' -> puttext; 
                        ONs -> putint; newline;
                    if);
                    (IS.theObjectGenerator).father.doPT -> putline;
                    '**   dcl:'->putline;
                    dcl.dopt -> putline
                if)
             #);
           labInSuper:
             (# ISx: ^Items; 
             do (if ON > 1 then
                    E.origin[] -> ISx[];
                    (for i: ON -1 repeat
                         (if ISx.super[] <> none then
                             (if ISx.super.ATd.asDecl = dcl[] then
                                (* '\n**** Break to super pattern: on: ' 
                                   -> puttext; i -> putint;
                                 newline;*)
                                 i -> ONs;
                                 (ISx.super.ATd.asDecl).OG.IS.newDescNo 
                                   -> descNoS;
                                 ISx[] -> IS[];
                                 leave labInSuper;
                              else
                                 ISx.origin[] -> ISx[]
                if)if)for)if)
             #);
           countSuper:
             (# ISx: ^Items
             do IS[] -> ISx[];
                L:
                  (if ISx.super.ATd[] <> none then
                      noOfSuper + 1 -> noOfSuper;
                      (if ISx.super.ATd.asDecl = Dcl[] then
                          (* found super *)
                      else 
                          (ISx.super.ATd.asDecl).OG.IS[] -> ISx[];
                          restart L
                  if)if)
             exit ISx[]
             #);
           topSuper:
             (# ISx: ^Items; pn,dns: @integer
             do IS[] -> ISx[]; dn -> dns;
                L:
                  (if ISx.super.ATd[] <> none then
                      pn + 1 -> pn;
                      (ISx.super.ATd.asDecl).OG.IS[] -> ISx[];
                      ISx.newDescNo -> dns;
                      restart L
                  if)
             exit(pn,ISx[],dns)
             #);
           IS,superIS: ^Items; Ex : ^ObjectSpecification; dcl: ^Decl;
           primNo,ON,ONs,descNoS,dn,noOfSuper: @integer; 
           org: ^Items; OI: ^ObjectInvocation
        enter primNo
        do (if true then
               E.args.scanArgs(# do current[] -> Ex[]#);  
               Ex.super.on -> ON;
               Ex.origin[] -> IS[]; 
               ON - 1 -> (Ex.origin[] -> IS[]).toOrigin -> IS[];
               IS.newDescNo -> dn;
               topSuper -> (noOfSuper,superIS[],dn);
               (if noOfSuper > 0 then
                   superIS[] -> IS[]
               if);
               (if primNo
                // restart_prim then 
                   (if (ON = 1) and (noOfSuper = 0) then
                       IS.restartLab -> cd.jmp
                    else
                       (ON - 1, IS.restartLab,dn,noOfSuper) -> cd.break
                   if)
                // leave_prim then
                   (if (ON = 1) and (noOfSuper = 0) then
                       IS.leaveLab -> cd.jmp
                    else
                       (ON - 1, IS.leaveLab,dn,noOfSuper) -> cd.break
               if)if)
            else
               '**** break:OLD:'->puttext; e.dopt -> puttext; 
               ' Ex: ' -> puttext;
               E.args.scanArgs(# do current[] -> Ex[]#);
               Ex.dopt -> puttext; ' on: ' -> puttext;
               Ex.super.on -> ON; on -> putint; 
               ' ptnId.on: ' -> puttext; 
               (Ex.super.last->OI[]).ptnId.on -> ON -> putint;
               
               newline;
               Ex.super.ATd.asDecl -> dcl[]; 
               (* is dcl for the case where we leave a
                * super as in L: P{ ...; leave P}
                * It seems that this might be a doubtfull
                * case that we should not support!
                *)
               (* We assume ON > 0 as in
                *    L: = { ... }
                * but perhaps not the case in
                *    cycle{ ... }
                *)
               ON - 1 -> (E.origin[] -> IS[]).toOrigin -> IS[];
               IS.newDescNo -> dn;
               labInSuper;
               (if true or (ON > 1) then countSuper -> superIS[] if);
               (* pn should be the path to super where break shall continue
                * IS thus also relevant for ON = 1
                * We then dont have to search via super in doBreak
                *)
               trace;
               (if (ONs > 0) and (ONs < ON) then ONs -> ON; descNoS -> dn if);
               (if true then
                   '**** break:to:descNo: ' -> puttext; dn -> putint; 
                   ' ON: ' -> puttext; ON -> putint; newline;
                   IS.doPT -> puthead;
                   (if noOfSuper > 0 then
                       '**   super: ' -> puttext; noOfSuper -> putint; newline;
                       (*superIS.doPT -> putline;
                       superIS[] -> IS[]*)
                   if);
                   '**** E:' -> puttext;  E.dopt->  putline;
               if);
               (if primNo
                // restart_prim then 
                   (if ON = 1 then
                       (if noOfSuper > 0 then
                           '**** restart: PN > 0: ' -> puttext;
                           E.dopt -> putline;
                           superIS.dopt -> putline
                       if);
                       IS.restartLab -> cd.jmp
                    else
                       (if emitLLVM then
                           cd.pushThis;
                           (ON - 1, E[]) -> (E.origin[]->org[]).goorigin;
                       if);
                       (ON - 1, IS.restartLab,dn,noOfSuper) -> cd.break 
                   if)
                // leave_prim then 
                   (if ON = 1 then
                       (if noOfSuper > 0 then
                           '**** leave: PN > 0: ' -> puttext;
                           E.dopt -> putline;
                           superIS.dopt -> putline
                       if);                   
                       IS.leaveLab -> cd.jmp
                    else
                       (if emitLLVM then
                           cd.pushThis;
                           (ON - 1, E[]) -> (E.origin[]->org[]).goorigin;
                       if);
                       (ON - 1, IS.leaveLab,dn,noOfSuper) -> cd.break
        if)if)if)#);  
   do (if OG.primNo
       // restart_Prim then 
          restart_Prim -> doBreak
       // leave_Prim then 
          leave_Prim -> doBreak   
      if)
   #)
---IndexPattern_invoke:doPart---
do (# getIndexedArgs:
        (# D: ^DataItem; isRef: @boolean; isValueObj,size: @integer
        do rec.ATd.asDecl -> D[];           
           1 -> size; (* Apparently scan below does not work for
                       * %put V: ?^ elm %at% inx: ?^ integer:
                       * implies size = 0
                       *)
           (*'**** getIndexedArgs: ' -> puttext; D.dopt -> putline;*)
           (* OBS! Does not work for 
            *    R: ref IndexedRef
            * due to no arguments to IndexRef
            * Must check primNo for IndexedRef
            * However we need to find size for valueObj
            *)
           D.OG.scanActualArgs
           (# i: @integer; OG: ^ObjectSpecification
           do (if (i + 1 -> i) = 2 then
                  current[] -> OG[];
                  (if true
                   // current.isBasicValue then
                      (if OG.primNo = float_prim then
                          (* we apparently compute inx * size
                           * this can be done in betaVM!?
                           *)
                          2 -> size  -> cd.pushConst;
                          66 (* mult *) -> cd.op
                       else
                          1 -> size
                      if);
                   // current.isValueObj then
                      1 -> isValueObj;
                      current.ObjSize -> size;
                      current.objSize -> cd.pushConst;
                      66 (* mult *) -> cd.op
                   else 
                      true -> isRef;
                      1 -> size
           if)if)#)
        exit(isRef,isValueObj,size)
        #);
      org: ^Items
   do (if OG.primNo 
       // indexedPut_prim then 
          (* Can indexedPut and other primtives
           * just be opcodes? May simplify things*)
          (# isRef: @boolean; isValueObj,size: @integer
          do getIndexedArgs -> (isRef,isValueObj,size);
             (if size = 0 then
                 '!!!! indexedPut:size = 0'->putline;
                 dopt->putline
             if);
             (if isRef then
                 cd.rswap;
                 ('inx',1) -> cd.xrstoreg
              else
                 ('inx',1,isValueObj,size) -> cd.xstoreg  
          if)#)       
       // indexedGet_prim then
          (* check if rec is value or ref indexed *)
          (# isRef: @boolean; isValueObj,size: @integer
          do (if (rec.ATd.asDecl).primNo = indexedGet_prim then
                 (* The case for indexed::length *) 
                 ('inx',1,0,1) -> cd.xpushg
              else
                 getIndexedArgs -> (isRef,isValueObj,size);
                 (if isRef then
                     ('inx',1) -> cd.xrpushg
                  else
                     ('inx',1,isValueObj,size) -> cd.xpushg
          if)if)#)
       // stringGet_prim then
          ('inx',1,0,1) -> cd.xpushg  
       // indexed_prim // rIndexed_prim then
          (# size,isRefIndexed: @integer; D: ^DataItem
          do cd.pushThis; (* not used by allocIndexed - just popped *)
             E.args.scanArgs
             (# OG: ^ObjectSpecification; i: @integer
             do (if (i + 1 -> i) = 2 then
                    current[] -> OG[];
                    (if true 
                     // OG.primNo = integer_prim then
                        1 -> size;
                        0 -> isRefIndexed;
                     // OG.primNo = float_prim then
                        2 -> size;
                        0 -> isRefIndexed;
                        E[] -> Warning
                        (#
                        do 'Indexed Floats are not implemented' -> msg
                        #);
                     // OG.isValueObj then 
                        OG.objSize -> size; 
                        0 -> isRefIndexed;                     
                     else
                        1 -> size;
                        1 -> isRefIndexed;
             if)if)#); 
             OG[] -> objTmpStack.add;           
             1 -> cd.pushConst; (* dinx *)
             (if true then
                 ((E.origin[]->org[]).encOG.OGidWdNo
                 ,OG.IS.newDescNo,size,isRefIndexed,staticOff) 
                   -> cd.allocIndexed;
              else
                 ('StaticRep',OG.IS.newDescNo,size,isRefIndexed,staticOff) 
                   -> cd.allocIndexed;
             if);
             (if staticOff > 0 then
                 cd.pushThis;
                 (if true then
                     (org.encOG.OGidWdNo,staticOff) -> cd.rstoreg
                  else
                     ('indexed',staticOff) -> cd.rstoreg
          if)if)#)
       // asString_prim then
          ('asString',primNo) -> cd.callPrim
      if)
   #)   
---OtherPrim_invoke:doPart---
do (if OG.primNo
    // inner_prim then
       (if E.args.length > 0 then
           E.args.scanArgs
           (# A: ^ObjectSpecification; org: ^Items; orgIsVal: @boolean
           do current[] -> A[]; 
              cd.pushThis;
              (A.super.on - 1,A.super[]) 
                -> (E.origin[]->org[]).goOrigin -> (org[],orgIsVal);
              org.innerInx -> cd.innerP;
              cd.rpopThisObj
           #)
        else
           (* May happen for: innerBool: { out B: var Boolean ...} *)
           (if 'inner' -> (E.doPT).equal then
               E.origin[] -> org[];
               org.innerInx -> cd.innerx; 
            else
               (# orgIsVal: @boolean
               do cd.pushThis;
                  (adr.superAdj,'origin-q') -> adjustOrigin;
                  (E.on ,none) (* OBS! NA is none! *)
                    -> (E.origin[]->org[]).goOrigin -> (org[],orgIsVal);
                  org.innerInx -> cd.innerP;
                  cd.rpopThisObj
       #)if)if)
   
    // none_prim then 
       cd.pushNone
    // suspend_prim then
       cd.suspendd;
       (if coArg then
           (# vn,rn: @integer
           do (if (rec.ATd.asDecl).OG.primNo = this_prim then
                  (*'**** suspend:this: ' -> puttext; rec.dopt -> putline*)
                  (* we should get the argument of @this foo
                   * and scan the formal parameters of foo
                   *)
               else
                  (* pushThis below is wrong
                   * possible args. must be stored in the object being resumed
                   * This is the address on the rstack before suspend
                   * Perhaps we can just do an rdouble before suspend!?
                   * In any case we need to know if the objects is resumed by
                   * a call of an attach.
                   * A zero (0) or 1 on the vstack may be used for this
                   * Not so easy! For attach we do not necessarily resumer 
                   * after a suspend. 
                   * An object must thus keep track wheter it has 
                   * suspended itself or is premmptively suspended
                   * When resumed, the doCall bytecode msut then pop the vstack
                   * if preepmtively suspended, but leave if itself has supended
                   * At one point we tried using scanNonBoundItemArgs below
                   * but this is wrong
                   *)
                  (rec.ATd.asDecl).OG.IS.scanItemArgs
                  (# DI: ^DataItem; 
                  do (if currentArg## = DataItem## then
                         currentArg[] -> DI[];
                         (if DI.isValue then 
                             vn + 1 -> vn;
                             cd.pushThis;
                             ('arg',DI.newOff) -> cd.storeg 
                          else
                             cd.pushThis;
                             ('arg',DI.newOff) -> cd.rstoreg;
                             rn + 1 -> rn;
              if)if)#)if);
              cd.mvStack;
       #)if)
    // resume_prim then
       (# vn,rn: @integer
       do (rec.ATD.asDecl).OG.IS.scanItemArgs
          (# DI: ^DataItem; 
          do (if currentArg## = DataItem## then
                 currentArg[] -> DI[];               
                 (if DI.isValue then 
                     vn + 1 -> vn;
                  else
                     rn + 1 -> rn;
          if)if)#);
          ('Resume','D') -> cd.call;
          cd.rpop
       #)
    // disable_prim then
       ('disable',disable_prim) -> cd.callPrim
    // enable_prim then  
       ('enable',enable_prim) -> cd.callPrim   
    // put_prim then 
       ('put',OG.primNo) -> cd.Callprim
    // get_prim then
       ('get',OG.primNo) -> cd.callPrim
    // attach_prim then
       ('attach',OG.primNo) -> cd.callPrim;
       cd.rPop;
    // cmpAndSwap_prim then
       (# I: ^Invocation
       do E.father -> I[];
          L:
            I.scanSons
            (# R: ^Exp
            do current[] -> R[];
               cd.swap;
               cd.vpop;
               cd.swap;
               ('cmpAndSwap',OG.primNo ) -> cd.callPrim;
               leave L
       #)#)
    // fork_prim then
       ('fork',OG.primNo ) -> cd.callPrim
    // sleep_prim then
       ('sleep',OG.primNo ) -> cd.callPrim;
    // thisCore_prim then
       (*OG.markForCodeGen*)
    // file_open_prim then
       ('file_open',primNo) -> cd.callPrim
    // file_get_prim then
       ('File_get',primNo) -> cd.callPrim
    // file_eof_prim then
       ('File_eof',primNo) -> cd.callPrim
    // file_close_prim then
       ('File_close',primNo) -> cd.callprim     
    // dumpObj_prim then
       ('dumpObj_prim',primNo) -> cd.callprim  
    // log_prim then
       ('log_prim',primNo) -> cd.callprim  
    // printf_prim then
       ('printf_prim',primNo) -> cd.callprim            
   if)
