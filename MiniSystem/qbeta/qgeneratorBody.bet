ORIGIN 'qgenerator'
---doMarkPrim:doPart---
do L:
     (if primNo
      // put_prim 
      // assign_prim 
      // ifThen_prim then
         true -> value
      // restart_prim
      // leave_prim 
      // inner_prim 
      // none_prim
      // suspend_prim 
      // resume_prim
      // disable_prim 
      // enable_prim 
      // attach_prim
      // cmpAndSwap_prim
      // fork_prim
      // sleep_prim
      // indexedPut_prim 
      // indexedGet_prim
      // stringGet_prim
      // indexed_prim
      // asString_prim 
      // thisCore_prim 
      // file_open_prim 
      // file_get_prim 
      // file_eof_prim 
      // file_close_prim          
         then
      else
         (if (sig[] <> none) then
             (if (sig.type ## = Sig.Binary##) and (primNo > 0) 
                 or 
                 (sig.type ## = Sig.Unary##) and (primNo = 65) then
                 leave L
             if);
         if);
         (if IS.isExternal > 0 then
          else
             true -> value       
         if)
     if);
   (if value = false then
       (*'doMarkPrim: '->puttext; primNo -> putint; newline*)
   if)
   
---doPrimElse:doPart---
do 
   (if (sig.type ## = Sig.Binary##) and (OG.primNo > 0) 
       or 
       (sig.type ## = Sig.Unary##) and (OG.primNo = 65) then
       'bodyC:'->cd.comment;
       OG.primNo -> cd.op
    else
       (if (OG.IS.isExternal -> exNo) > 0 then
           (* Origin is on rStack here, but is not used
            * is popped by interpreter_c.c - not good,
            * should avoid generating code for loadOrigin *)
           (sig.id[],exNo) -> cd.invokeExternal
        else
           true -> value       
   if)if)
---AssignMentPattern_invoke:doPart--
do (#
   do (if ((rec.ATd.desc).newDescNo = 0) then
          'descNo = 0'-> cd.comment;
          rec.ATD.dopt -> cd.comment
      if);
      cd.com(#do 'AssignmentPattern:invoke:'-> T; dopt -> T#);
      (if (adr[] <> none) then
          cd.com(#do 'doPrimElse:adr:'-> T; adr.print -> T #);
          adr.store;
      if)
   #)
   
--BreakPatternInvoke:doPart---
do
   (# doBreak:
        (# IS: ^Items; Ex : ^ObjectGenerator; 
           primNo,ON: @integer
        enter primNo
        do E.args.scanArgs(# do current[] -> Ex[]#);
           Ex.super.on -> ON;
           (* We assume ON > 0 as in
            *    L: = { ... }
            * but perhaps not the case in
            *    cycle{ ... }
            *)
           ON - 1 -> (E.origin[] -> IS[]).toOrigin -> IS[];
           (if primNo
            // restart_prim then 
               (if ON = 1 then
                   IS.restartLab -> cd.jmp
                else
                   (ON - 1, IS.restartLab,IS.newDescNo) -> cd.break 
               if)
            // leave_prim then 
               (if ON = 1 then
                   IS.leaveLab -> cd.jmp
                else
                   (ON - 1, IS.leaveLab,IS.newDescNo) -> cd.break
               if)
           if)
        #);  
   do (if OG.primNo
       // restart_Prim then 
          restart_Prim -> doBreak
       // leave_Prim then 
          leave_Prim -> doBreak   
      if)
   #)
---IndexPattern_invoke:doPart---
do (#
   do (if OG.primNo 
       // indexedPut_prim then 
          (* Can indexedPut and other primtives
           * just be opcodes? May simplify things*)
          (# D: ^DataItem; isRef: @boolean
          do rec.ATd[] -> D[];
             D.OG.scanActualArgs
             (# i: @integer
             do (if (i + 1 -> i) = 2 then
                    current.dopt -> cd.comment;
                    (if current.isBasic then
                        'basic' -> cd.comment;
                     else 
                        'ref' -> cd.comment;
                        true -> isRef;
                if)if);
             #);
             (if isRef then
                 cd.rswap;
                 ('inx',1) -> cd.xrstoreg
              else
                 ('inx',1) -> cd.xstoreg  
             if)
          #)       
       // indexedGet_prim then
          (* check if rec is value or ref indexed *)
          (# D: ^DataItem; isRef: @boolean
          do (if rec.ATd.primNo = indexedGet_prim then
                 (* The case for indexed::length *)
                 ('inx',1) -> cd.xpushg
              else
                 rec.ATd[] -> D[];
                 D.OG.scanActualArgs
                 (# i: @integer
                 do (if (i + 1 -> i) = 2 then
                        current.dopt -> cd.comment;
                        (if current.isBasic then 
                            'value' -> cd.comment;
                         else 
                            'ref' -> cd.comment;
                            true -> isRef
                    if)if)
                 #);
                 (if isRef then
                     ('inx',1) -> cd.xrpushg
                  else
                     ('inx',1) -> cd.xpushg
                 if);
             if)
          #)
       // stringGet_prim then
          ('inx',1) -> cd.xpushg  
       // indexed_prim then
          (if elimOrigin then
              cd.pushThis (* not used by allocIndexed - just popped *)
          if);
          E.args.scanArgs
          (# OG: ^ObjectGenerator; i: @integer
          do (*current.dopt -> puttext; ' ' -> put;*)
             i + 1 -> i;
             (if i = 2 then
                 current[] -> OG[];
                 (if Og.primNo = integer_prim then
                     (*'Got value' -> puttext;*)
                     0 -> cd.pushConst;   (* not isRindexed *)
                  else
                     (*'Got ref' -> puttext;*)
                     1 -> cd.pushConst;   (* isRindexed *)
          if)if)#); 
          (sig.id[],sig[],OG[],OG.super[],CC[],OG.computeVariant) 
            -> objTmpStack.add;           
          (if elimOrigin then
              1 -> cd.pushConst; (* dinx *)
           else
              (* rsize may be from the first Beta compiler
               * where there may be non-indexed data-items
               * and indexed was the last declaration!?
               * With qbeta no other data-items than indexed
               *)
              OG.IS.rsize -> cd.pushConst; (* dinx *)
          if);
          ('StaticRep',OG.IS.newDescNo,false (*not used*),true) 
            -> cd.allocIndexed;
          (if staticOff > 0 then
              cd.pushThis;
              ('indexed',staticOff) -> cd.rstoreg
          if)
       // asString_prim then
          ('asString',primNo) -> cd.callPrim
      if)
   #)   
---OtherPrim_invoke:doPart---
do (if OG.primNo    
    // ifthen_prim then
       exitLab.new;                   
       E.args.scanSons
       (# N: @integer
       do N + 1 -> N;
          (if N
           // 1 // 3 then
           // 2 then 
              (true,0,staticOff) -> current.Qgen;
              exitlab -> cd.jmpFalse;
           // 4 then
              (false,0,staticOff) -> current.Qgen;
              exitLab -> cd.defLab;
           else
              'invoke:%if%then: too many arguments' -> putline;
              E.doPt -> putline
          if)
       #)                
    // inner_prim then
       (if E.args.length > 0 then
           E.args.scanArgs
           (# A: ^ObjectGenerator; org: ^Items
           do current[] -> A[]; 
              cd.pushThis;
              (A.super.on - 1,A.super[]) -> (E.origin[]->org[]).goOrigin -> org[]; 
              (if org.basicNo = ifthen_prim then
                  (* we need to clean-up goOrigin *)
                  org.origin[] -> org[]
              if);
              org.innerInx -> cd.innerP; 
              cd.rpopThisObj
           #)
        else
           E.origin[] -> org[];
           org.innerInx -> cd.innerx; 
       if)
    // none_prim then 
       cd.pushNone
    // suspend_prim then
       cd.suspendd
    // resume_prim then
       ('Resume','D') -> cd.call;
       cd.rpop
    // disable_prim then
       ('disable',disable_prim) -> cd.callPrim
    // enable_prim then  
       ('enable',enable_prim) -> cd.callPrim   
    // put_prim then 
       ('put',OG.primNo) -> cd.Callprim
    // attach_prim then
       ('attach',OG.primNo) -> cd.callPrim;
       cd.rPop;
    // cmpAndSwap_prim then
       (# I: ^Invocation
       do E.father -> I[];
          L:
            I.scanSons
            (# R: ^Exp
            do current[] -> R[];
               cd.swap;
               ('cmpAndSwap',OG.primNo ) -> cd.callPrim;
               leave L
            #)
       #)
    // fork_prim then
       ('fork',OG.primNo ) -> cd.callPrim
    // sleep_prim then
       ('sleep',OG.primNo ) -> cd.callPrim;
    // thisCore_prim then
       (*OG.markForCodeGen*)
    // file_open_prim then
       ('file_open',primNo) -> cd.callPrim
    // file_get_prim then
       ('File_get',primNo) -> cd.callPrim
    // file_eof_prim then
       ('File_eof',primNo) -> cd.callPrim
    // file_close_prim then
       ('File_close',primNo) -> cd.callprim       
    else
   if)
