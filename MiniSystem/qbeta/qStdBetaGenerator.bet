ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaAllocator';
INCLUDE '../VM/objectcode'
---LIB:attributes---
qStdBetaGenerator: qStdBetaAllocator
  (# StdBetaModule::<
       (# gen:: 
            (# 
            do '**** StdBetaModule:gen:'-> dumpT; moduleName.doPT->dumpTN;
            #)
       #);   
     AttFrag::
       (# gen:: (# do 'A'->cd.nop; cd.fcom(#do thename.dopt->TT #) #)
       #);   
     ObjDescFrag::
       (# gen:: (# do 'B'->cd.nop; OD[] -> objTmpStack.add;  cd.fcom(#do thename.dopt->TT #); true -> done #)
       #);   
     DoPartFrag::
       (# gen:: (# do 'C'->cd.nop;  cd.fcom(#do thename.dopt->TT #) #)
       #);
     AttSlot::<
       (# gen::
            (#
            do scanBindings(#do current.gen #)
            #);
       #);
     ObjDescSlot::<
       (# gen::
            (#
            do  scanBindings
               (# ODF: ^ObjDescFrag
               do (current[] -> ODF[]).OD[] -> objTmpStack.add; 
                  true -> done
               #)
            #);
       #);
     ObjectDesc::
       (# gen:: (#do this(ObjectDesc)[] -> objTmpStack.add #);
          isExternal: BooleanValue
            (# primNo: @integer
            do (if sup.isExternal then
                   cd.com(#do 'External:'->TT; dopt -> TT; #);
                   L:
                     acp.imps.scanSons
                     (#
                     do cd.com(#do current.doPP -> TT#);
                        current.scanSons
                        (# i: @integer
                        do current.getPrimNo -> primNo;
                           cd.com(#do primNo -> II #);
                           true -> value;
                           leave L
                     #)#);
                   (if primNo 
                    // 2 then 
                       ('put',2) -> cd.callPrim
                    else
                   if)
               if)
            #);
          genClass:
            (# isExternal: 
                 (# primNo: @integer
                 do (if sup.isExternal then
                        '**** External:'->dumpT; dopt -> dumpTN;
                        acp.doPP->dumpTN;
                        L:
                          acp.imps.scanSons
                          (#
                          do current.doPP -> dumpTN ;
                             current.scanSons
                             (# i: @integer
                           do 
                                current.getPrimNo -> primNo -> putint; newline;
                                leave L
                          #)#);
                        (if primNo 
                         // 2 then 
                            ('put',2) -> cd.callPrim
                         else
                        if)
                    if)
                 #);
               T: ^Text
            do (if false then
                   'ObjectDesc:gen:'-> dumpT; 
               if);
               '_StdBeta_'-> T[];

               (if NS[] <> none then
                   NS.scanSons(#do current.dopt -> T.append #)
                else 
                   (if origin[] = none then
                       'betaenv'->T.append;
                    else
                       'singular'->T.append
               if)if);
               (if false then T[] -> dumptn; if);
               
               (T[],descNo,false,1,originOff,'bobs',1,false,false)
                 -> cd.class;
               'B' -> cd.nop;
               att.gen; (* patterns must go on a lsit to be handled after *)
               acp.gen;
               
               (objSize,false,0) -> cd.endclass;
               
       #)#);
     BetaNameDecl::
       (# store::
            (#
            do (N.T[],off) -> theDcl.IT.storeItem
            #)
       #);
     StaticItem::
       (# storeItem::
            (#
            do (id[],off) -> cd.storeg
            #);
          gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpStack.add if);
               true -> done
            #)
       #);
     BetaPattern::
       (# storeItem::
            (#
            do cd.fcom(#do 'invoke:'->TT; NS.dopt -> TQ #);
               (if OD.isExternal then
                else
                   (NS.doPT,OD.descNo,OD.objSize,0,false) -> cd.invoke
               if)
            #);
          gen:: (#do OD[] -> objTmpStack.add; true -> done #);
       #);
     BetaVirtualPattern:: 
       (# gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpSTack.add if); true -> done
            #)
       #);
     furtherBinding:: 
       (# gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpSTack.add if); true -> done
            #)
       #);
     FinalBinding:: 
       (# gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpSTack.add if); true -> done
            #)
       #);
          
     ActionPart::
       (# gen::
            (#
            do (*(if imps[] <> none then imps.gen if)*)
            #);
       #);
     imperatives::
       (# gen::
            (#
            do (* scanSons(#do current.gen #)*)
            #)
       #);
     Evaluation::
       (# gen::
            (#
            do (if false then
                   cd.fcom(#do 'Eval:gen:'->TT; dopt -> TQ #)
               if);
               scanSons
               (#
               do(if isFirst then
                      current.gen;
                   else
                      current.store
               if)#);
               true -> done
            #)
       #);
     PatternDen::
       (# gen:: (#do#);
       #);
     BetaBinaryExp::
       (# gen::
            (#
            do lE.gen; rE.gen; op -> cd.op; true -> done;
            #)
       #);
     NameApl::
       (# store::
            (#
            do (* goOrigin *)
               ATd.store;
               (*(N.T[],(*ATd.off* )7) -> cd.storeg (* if value * )*)
            #);
       #);     
     ConstExp::
       (# gen::
            (#
            do cst.T.setpos; cst.T.getInt  -> cd.pushConst;
               true -> done
            #)
       #);
     objTmpStack: @
       (# ODs: [30] ^ObjectDesc; next,top: @integer;
          add:
            (# OD: ^ObjectDesc;
            enter OD[]
            do (if (top + 1 -> top) > ODs.range then
                   ODs.range -> ODs.extend
               if);
               OD[] -> ODs[top][]
            #);
          gen:
            (#
            do (for i: top repeat
                    ODs[i].gen
            for)#);
          genNext: BooleanValue
            (#
            do (if (next + 1 -> next) <= top then
                   ODs[next].genClass;
                   true -> value
               if)
            #)
               
       #);
     genStdBeta:
       (#
       do '**** Generator: StdBeta:'->dumptn;
          topModule.alloc;
          topModule.gen;
          cd.fcom(#do 'objTmpStack.gen'->TT #);
          L:
            (if objTmpStack.genNext then
                restart L
            if)
       #);
     cd:  ^ObjectCode;
  enter cd[]
  #);

