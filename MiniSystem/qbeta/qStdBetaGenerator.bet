ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaAllocator';
INCLUDE '../VM/objectcode'
---LIB:attributes---
qStdBetaGenerator: qStdBetaAllocator
  (# StdBetaModule::<
       (# gen:: 
            (# 
            do '**** StdBetaModule:gen:'-> dumpT; moduleName.doPT->dumpTN;
               cd.fcom
               (#
               do 'StdBetaModule:gen:'->TT; moduleName.dopt->TQ; #);
               frags.gen
            #)
       #);   
     BetaFragments:: (# gen:: (#do scanSons(#do current.gen #); #)#);
     AttFrag::
       (# gen:: (# do cd.fcom(#do thename.dopt->TT #); att.gen #)
       #);   
     ObjDescFrag::
       (# gen:: 
            (# do OD[] -> objTmpStack.add;  cd.fcom(#do thename.dopt->TT #) #)
       #);   
     DoPartFrag::
       (# gen:: (# do cd.fcom(#do thename.dopt->TT #) #)
       #);
     AttSlot::<
       (# gen:: (#do scanBindings(#do current.gen #)#);
       #);
     ObjDescSlot::<
       (# gen::
            (#
            do scanBindings
               (# ODF: ^ObjDescFrag
               do (current[] -> ODF[]).OD[] -> objTmpStack.add;
               #)
            #);
       #);
     Attributes::
       (# gen:: (#do scanSons(#do current.gen #);#)
       #);
          
     ObjectDesc::
       (# gen:: (#do this(ObjectDesc)[] -> objTmpStack.add #);
          isExternal: BooleanValue
            (# primNo: @integer
            do (if sup.isExternal then
                   cd.com(#do 'External:'->TT; dopt -> TT; #);
                   L:
                     acp.imps.scanSons
                     (#
                     do cd.com(#do current.doPP -> TT#);
                        current.scanSons
                        (# i: @integer
                        do current.getPrimNo -> primNo;
                           cd.com(#do primNo -> II #);
                           true -> value;
                           leave L
                     #)#);
                   (if primNo 
                    // 2 then 
                       ('put',2) -> cd.callPrim
                    else
            if)if)#);
          genClass:
            (# isExternal: 
                 (# primNo: @integer
                 do (if sup.isExternal then
                        '**** External:'->dumpT; dopt -> dumpTN;
                        acp.doPP->dumpTN;
                        L:
                          acp.imps.scanSons
                          (#
                          do current.doPP -> dumpTN ;
                             current.scanSons
                             (# i: @integer
                           do 
                                current.getPrimNo -> primNo -> putint; newline;
                                leave L
                          #)#);
                        (if primNo 
                         // 2 then 
                            ('put',2) -> cd.callPrim
                         else
                        if)
                    if)
                 #);
               T: ^Text
            do cd.fcom(#do 'ObjectDesc:gen:'-> TT #);

               '_StdBeta_'-> T[];

               (if NS[] <> none then
                   NS.scanSons(#do current.dopt -> T.append #)
                else 
                   (if origin[] = none then
                       'betaenv'->T.append;
                    else
                       'singular'->T.append
               if)if);
               cd.fcom(#do 'ObjectDesc:gen:'-> TT; T[] -> TQ #);
               
               (T[],descNo,false,1,originOff,'bobs',1,false,false)
                 -> cd.class;
               'B' -> cd.nop;
               att.gen; (* patterns must go on a lsit to be handled after *)
               acp.gen;
               
               (objSize,false,0) -> cd.endclass;
            #);
          goOrigin::
            (#
            do (if on > 0 then
                   ('origin',originOff) -> cd.rpushg;
                   on - 1 -> origin.goOrigin
            if)#)
       #);
     BetaDecl::
       (# gen:: (# do NS.gen; IT.gen #)
       #);
     BetaNameDecl::
       (# load:: (# do (N.T[],off) -> theDcl.IT.loadItem #);
          store::
            (#
            do (N.T[],off) -> theDcl.IT.storeItem
            #);
       #);
     StaticItem::
       (# loadItem::
            (#
            do (id[],off) -> cd.rpushg
            #);
          storeItem::
            (#
            do (id[],off) -> cd.rstoreg
            #);
          gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpStack.add if);
            #)
       #);
     BetaPattern::
       (# storeItem::
            (#
            do cd.fcom(#do 'invoke:'->TT; NS.dopt -> TQ #);
               (if OD.isExternal then
                else
                   (NS.doPT,OD.descNo,OD.objSize,0,false) -> cd.invoke
               if)
            #);
          gen:: (#do OD[] -> objTmpStack.add; #);
       #);
     BetaVirtualPattern:: 
       (# gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpSTack.add if);
            #)
       #);
     furtherBinding:: 
       (# gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpSTack.add if);
            #)
       #);
     FinalBinding:: 
       (# gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpSTack.add if);
            #)
       #);
          
     ActionPart::
       (# gen::
            (#
            do cd.fcom(#do 'ActionPart:'->TT; #);
               (if imps[] <> none then imps.gen if)
            #);
       #);
     imperatives::
       (# gen::
            (#
            do cd.fcom(#do 'Imps:'->TT; #);
               scanSons(#do current.gen #)
            #)
       #);
     Evaluation::
       (# gen::
            (#
            do (if true then
                   cd.fcom(#do 'Eval:gen:'->TT; dopt -> TQ #)
               if);
               scanSons
               (#
               do (if isFirst then
                      current.load;
                   else
                      current.store
            if)#)#);
          load:: (#do gen #)
       #);
     PatternDen::
       (# load:: (#do AD.load #);
          store:: (#do AD.store #);
       #);
     ObjectEvaluation::
       (# load:: (# do OS.load #);
          store:: (# do OS.store #);
       #);
     BetaBinaryExp::
       (# gen::
            (#
            do cd.fcom(#do 'BinExp:gen:'->TT #);
               lE.load; rE.load; op -> cd.op; 
            #);
          load:: (#do cd.fcom(#do 'BinExp:load:'->TT #); gen #);
       #);
     BetaTerm::
       (# load:: 
            (# 
            do cd.fcom(#do 'Term:load'->TT; T.label-> TT; T.dopt -> TT #);
               T.load
            #); 
          store:: (# do T.store #); 
       #);
     EvaluationList::<
       (# load::
            (#
            do scanSons
               (#
               do cd.fcom
                  (#do 'EvalList:load:'-> TT; 
                     current.label->TT; current.dopt->TT#); 
                  current.load #)
            #);
          gen::(#do  #);
       #);
     NameApl::
       (# load::
            (#
            do cd.fcom(#do 'NameApl:load:'-> TT; dopt->TQ #);
               cd.pushThis;
               on -> origin.goOrigin;
               (if ATd[] <> none then
                   ATd.load
                else
                   cd.fcom(#do 'NameApl:gen:ATd=none:'-> TT; dopt->TQ #)
               if)
            #);
          store::
            (#
            do cd.pushThis;
               on -> origin.goOrigin;
               ATd.store;
            #);
       #);     
     ConstExp::
       (# gen::
            (#
            do cd.fcom(#do 'ConstExpr:gen:'->TT #);
               cst.T.setpos; cst.T.getInt  -> cd.pushConst;
            #);
          load:: (#do cd.fcom(#do 'ConstExpr:load:'->TT #); gen #);
       #);
     objTmpStack: @
       (# ODs: [30] ^ObjectDesc; next,top: @integer;
          add:
            (# OD: ^ObjectDesc;
            enter OD[]
            do (if (top + 1 -> top) > ODs.range then
                   ODs.range -> ODs.extend
               if);
               OD[] -> ODs[top][]
            #); 
          genNext: BooleanValue
            (#
            do (if (next + 1 -> next) <= top then
                   ODs[next].genClass;
                   true -> value
               if)
            #)
       #);
     genStdBeta:
       (#
       do '**** Generator: StdBeta:'->dumptn;
          topModule.alloc;
          topModule.gen;
          cd.fcom(#do 'objTmpStack.gen'->TT #);
          L:
            (if objTmpStack.genNext then
                restart L
            if)
       #);
     cd:  ^ObjectCode;
  enter cd[]
  #);

