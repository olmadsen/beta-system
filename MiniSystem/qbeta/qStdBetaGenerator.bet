ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaAllocator';
INCLUDE '../VM/objectcode'
---LIB:attributes---
qStdBetaGenerator: qStdBetaAllocator
  (# StdBetaModule::<
       (# gen:: 
            (# 
            do '**** StdBetaModule:gen:'-> dumpT; moduleName.doPT->dumpTN;
               cd.fcom
               (#
               do 'StdBetaModule:gen:'->TT; moduleName.dopt->TQ; #);
               frags.gen
            #)
       #);   
     BetaFragments:: (# gen:: (#do scanSons(#do current.gen #); #)#);
     AttFrag::
       (# gen:: (# do cd.fcom(#do thename.dopt->TT #); att.gen #)
       #);   
     ObjDescFrag::
       (# gen:: 
            (# do OD[] -> objTmpStack.add;  cd.fcom(#do thename.dopt->TT #) #)
       #);   
     DoPartFrag::
       (# gen:: (# do cd.fcom(#do thename.dopt->TT #) #)
       #);
     AttSlot::<
       (# gen:: (#do scanBindings(#do current.gen #)#);
       #);
     ObjDescSlot::<
       (# gen::
            (#
            do scanBindings
               (# ODF: ^ObjDescFrag
               do (current[] -> ODF[]).OD[] -> objTmpStack.add;
               #)
            #);
       #);
     Attributes::
       (# gen:: (#do scanSons(#do current.gen #);#)
       #);
          
     ObjectDesc::
       (# gen:: (#do this(ObjectDesc)[] -> objTmpStack.add #);
          isExternal: BooleanValue
            (# primNo: @integer
            do (if sup.isExternal then
                   cd.com(#do 'External:'->TT; dopt -> TT; #);
                   L:
                     acp.imps.scanSons
                     (#
                     do cd.com(#do current.doPP -> TT#);
                        current.scanSons
                        (# i: @integer
                        do current.getPrimNo -> primNo;
                           cd.com(#do primNo -> II #);
                           true -> value;
                           leave L
                     #)#);
                   (if primNo 
                    // 2 then 
                       ('put',2) -> cd.callPrim
                    else
            if)if)#);
          genClass:
            (# T,orgId,N: ^Text; orgDescNo: @integer
            do cd.fcom(#do 'ObjectDesc:gen:'-> TT #);

               '_StdBeta_'-> T[];

               (if NS[] <> none then
                   NS.scanSons(#do current.dopt -> T.append #)
                else 
                   (if origin[] = none then
                       'betaenv'->T.append;
                    else
                       'singular'->T.append
               if)if);
               cd.fcom(#do 'ObjectDesc:gen:'-> TT; T[] -> TQ #);
               
               (if (superDesc[] <> none) and not superDesc.done then
                   (* pretty ad hoc - since we copy the VDtable from super, 
                    * code must have been generated for super; 
                    * done is introduced to handle this. 
                    * But fix it
                    *)
                   (*sup.name -> *) superDesc.genClass;
                   superDesc.descNo -> orgDescNo;
                   'origin' -> orgId[];
                else
                   '' -> orgId[]
               if);
               (if not done then
                   true -> done;
                   (T[],descNo,false,1,originOff,orgId[],orgDescNo,false,false)
                     -> cd.class;
                   cd.bcPos -> beginBCP;
                   (* gen super, save origin, vdtTableCopy, etc  *)
                   (if superDesc[] <> none then
                       (if not sup.isThisBlockLevel then
                           ('origin',originOff) -> cd.rstore; (* save origin *)
                           (*sup.loadOrigin -> N[]; *)
                           cd.pushThis; (* ??? *)
                           'super' -> N[] (* fix *)
                       if);
                       (N[],superDesc.descNo) -> cd.exeAlloc;
                       cd.rpop;
                       (N[],superDesc.descNo)  -> cd.super; 
                       (if false then
                           '**** vdtTableCopy:'->dumpt; 
                           descNo -> putint; ' ' -> put;
                           superDesc.descNo -> putint; ' ' -> put;
                           dopt -> putHeadN;
                           '**    super:'->dumpTN;
                           superDesc.dopt -> putheadN;
                       if);
                       superDesc.descNo  -> cd.vdtTableCopy;
                       (* innerInx - fic *)
                    else
                       ('origin',originOff) -> cd.rstore; (* save origin *)
                   if);
                   (if false then ('super',501) -> cd.exeAlloc; if);
                   (if slt[] = none then
                       att.gen;
                       cd.markEnterE;
                       (* enter.gen *)
                       
                       (false (*(superDesc[] <> none)*)) -> cd.actions;
                       acp.gen;
                       'D' -> cd.rtn;
                   if);
                   (objSize,false,0) -> cd.endclass;
               if)
            #);   
          doCall:
             (# N: ^text; LMR: @char; TP: ^type; xType: @integer
             enter(N[],LMR)
             do cd.fcom(#do 'ObjDesc:doCall'->TT #);
                (if (exitType->TP[]) <> none then
                    (if TP.isRef then
                        2 -> xType
                     else
                        1 -> xType
                if)if);
                (if false then
                    doPt->putline;
                    'exitType: ' -> puttext; xType -> putint; newline;
                if);
                (if LMR
                 // 'S' then 
                    (if hasDoPart then (N[],'D') -> cd.call if);
                    cd.rtnEvent;                        
                 // 'L' then
                    (if hasDoPart then (N[],'D') -> cd.call if);
                    (N[],'X') -> cd.call;
                    xType -> cd.rtnEvent
                 // 'M' then
                    (N[],'N') -> cd.call;
                    (if hasDoPart then (N[],'D') -> cd.call if);
                    (N[],'X') -> cd.call;
                    xType -> cd.rtnEvent
                 // 'R' then
                    (N[],'N') -> cd.call;
                    (if hasDoPart then (N[],'D') -> cd.call if);
                    cd.rtnEvent;                     
                if);
             #);
          goOrigin::
            (#
            do (if on > 0 then
                   ('origin',originOff) -> cd.rpushg;
                   on - 1 -> origin.goOrigin
            if)#);
          done: @boolean
       #);
     BetaDecl::
       (# gen:: (# do NS.gen; IT.gen #);
          load::
            (#
            do cd.fcom
               (#do 'BetaDecl:load:'->TT; NS.label->TT; NS.doPT->TQ; #);
            #);
          doAlloc::
            (#
            do cd.fcom
               (#do 'BetaDecl:doAlloc:'->TT; NS.doPT->TQ; IT.label->TT #);
               IT.doAlloc
            #);
          
       #);
     BetaNameDecl::
       (# gen::
            (#
            do cd.fcom(#do 'NameDecl:'->TT; N.T[]->TQ #);
               theDcl.IT.gen
            #);
          load:: 
            (# 
            do cd.fcom
               (#do 'NameDecl:load:'->TT; N.T[]->TQ; theDcl.label->TT #);
               (N.T[],off) -> theDcl.IT.loadItem 
            #);
          store::
            (#
            do (N.T[],off) -> theDcl.IT.storeItem
            #);
          doAlloc::
            (#
            do cd.fcom
               (#do 'NameDecl:doAlloc:'->TT; N.T[]->TQ; theDcl.label->TT #);
               theDcl.doAlloc
            #);
       #);
     StaticItem::
       (# loadItem::
            (#
            do cd.fcom
               (#
               do 'StaticItem:loadItem:'->TT; id[]->TQ; 
                  (if NS.theDesc <> none then
                      (NS.theDesc).doPT -> TT;
                      (NS.theDesc).isPrimitive->BB;
                  if); 
               #);
               (if (NS.theDesc <> none) and (NS.theDesc).isPrimitive then
                   (id[],off) -> cd.pushg
                else
                   (id[],off) -> cd.rpushg
               if)
            #);
          storeItem::
            (#
            do (id[],off) -> cd.rstoreg
            #);
          gen::
            (#
            do (if OS.isSingular then OS[] -> objTmpStack.add if);
            #)
       #);
     DynamicItem::
       (# loadItem::
            (#
            do (id[],off) -> cd.rpushg
            #);
          storeItem::
            (#
            do (id[],off) -> cd.rstoreg
            #);
       #);
     BetaPattern::
       (# loadItem::
            (#
            do cd.fcom(#do 'PTN:loadItem:'->TT; NS.dopt -> TQ #);
               (NS.doPT,OD.descNo,false) -> cd.alloc;
               (NS.dopt,'S') -> OD.doCall
            #);
          storeItem::
            (#
            do cd.fcom(#do 'PTN:storeItem:'->TT; NS.dopt -> TQ #);
               (if OD.isExternal then
                else
                   (NS.doPT,OD.descNo,OD.objSize,0,false) -> cd.invoke
               if)
            #);
          gen:: (#do OD[] -> objTmpStack.add; #);
          doAlloc::
            (#
            do cd.fcom(#do 'PTN:doAlloc:'->TT; NS.dopt -> TQ #);
               (NS.doPT,OD.descNo,false) -> cd.alloc
            #);
       #);
     BetaVirtualPattern:: 
       (# gen::
            (#
            do cd.fcom(#do 'VirtualPtn:doAlloc:'->TT; NS.dopt -> TQ; #);
               (if OS.isSingular then OS[] -> objTmpSTack.add if);
               NS.scanSons
               (# ND: ^BetaNameDecl
               do ((current[]->ND[]).off,OS.getDescNo,false,'LLVMsig') 
                    -> cd.vdtTable;
               #)
            #);
          doAlloc::
            (# 
            do cd.fcom(#do 'VirtualPtn:doAlloc:'->TT; NS.dopt -> TQ;
                         'dispatch needed'->TQ #);
               (if true then
                   NS.scanSons
                   (# ND: ^BetaNameDecl
                   do current[]->ND[];
                      (ND.doPT,ND.off,0,false) -> cd.invokeV;
                      (* 0 is noOfRefArgs - must be defined *)
                   #)
                else
                   (NS.doPT,OS.getDescNo,false) -> cd.alloc
               if)
            #);
       #);
     furtherBinding:: 
       (# gen::
            (#
            do cd.fcom(#do 'FurtherPtn:doAlloc:'->TT; NS.dopt -> TQ; #);
               (if OS.isSingular then OS[] -> objTmpSTack.add if);
               NS.scanSons
               (# ND: ^BetaNameDecl
               do ((current[]->ND[]).off,OS.getDescNo,false,'LLVMsig') 
                    -> cd.vdtTable;
               #)
            #);
          doAlloc::
            (#
            do cd.fcom(#do 'FurtherPtn:doAlloc:'->TT; NS.dopt -> TQ;
                      'dispatch needed'->TQ #);
               (NS.doPT,OS.getDescNo,false) -> cd.alloc
            #);
       #);
     FinalBinding:: 
       (# gen::
            (#
            do cd.fcom(#do 'FinalPtn:doAlloc:'->TT; NS.dopt -> TQ; #);
               (if OS.isSingular then OS[] -> objTmpSTack.add if);
               NS.scanSons
               (# ND: ^BetaNameDecl
               do ((current[]->ND[]).off,OS.getDescNo,false,'LLVMsig') 
                    -> cd.vdtTable;
               #)
            #);
          doAlloc::
            (#
            do cd.fcom(#do 'FinalPTN:doAlloc:'->TT; NS.dopt -> TQ #);
               (NS.doPT,OS.getDescNo,false) -> cd.alloc
            #);
       #);
          
     ActionPart::
       (# gen::
            (#
            do cd.bcPos -> beginBCP;
               (*enterP.gen;*)
               (if imps[] <> none then imps.gen if);
               (*exitP.gen;*)
               cd.bcPos -> endBCP
            #);
       #);
     EnterPart::
       (# gen::
            (# 
            do cd.bcPos -> beginBCP;
               (if eval[] <> none then
                   cd.enterP; (* generate no code *)
                   (*'R' -> *) eval.gen;
                   (* cd.rtn *)
               if);
               cd.bcPos -> endBCP;
            #)
       #);
     Imperatives::
       (# gen::
            (#
            do scanSons(#do current.gen #)
            #)
       #);
     ExitPart::
       (# gen::
            (#
            do cd.bcPos -> beginBCP;
               cd.markExitE;
               (* do gen exit-part *)
               cd.bcPos -> endBCP;
            #)
       #);

     IfImp::
       (# gen::
            (# elseLab, Xlab,exitLab: @labelHandler.label
            do cd.fcom(#do 'IfImp:gen:'->TT; dopt -> TT #);
               cd.bcPos -> beginBCP;
               exitlab.new;
               (if not elsePart.isNull then
                   elseLab.new; 
                   elseLab -> Xlab
                else
                   exitLab -> xLab
               if);               
               cd.fcom(#do 'IfImp:eval:'->TT; eval.label->TT #);
               (*'L' -> *) Eval.gen;
                              
               (if not thenPart.isNull then
                   (* simpleif: (if e then I1 else I2 if *)
                   (Xlab,Xlab) -> cd.jmpFalse; (* cd expects a Tlab and an Flab
                                                * due to LLVM - must check *)
                   thenPart.gen
                else
                   (Xlab[],exitLab[]) -> alt.select
               if);
               
               (if not elsePart.isNull then
                   (* Sometimes extra jmp here perhaps if thenPart.isNull *)
                   exitLab -> cd.jmp;
                   elseLab -> cd.defLab;                   
                   elsePart.gen
               if);
               exitLab -> cd.defLab;
               cd.bcPos -> endBCP               
       #)#);
     Alternatives::
       (# select:
            (# xLab,exitLAb: ^LabelHandler.label; 
               A: ^Alternative;
               nLab: @LabelHandler.label
            enter(xLab[],exitLab[])
            do cd.bcPos -> beginBCP;
               scansons
               (#
               do current[] -> A[]; 
                  (if isLast then
                      (false,xLab[],exitLab[]) -> A.select
                   else
                      nLab.new;
                      (true,nLab[],exitLab[]) -> A.select;
                      nLab -> cd.defLab
                  if)
               #);
               cd.bcPos -> endBCP;
       #)#);
     Alternative::
       (# select:
            (# double: @Boolean; xLab,elseLAb: ^LabelHandler.label;
               tLab: @LabelHandler.label
            enter(double,xLab[],elseLab[])
            do cd.fcom(#do 'Alternative:'->TT; dopt -> TT #);
               cd.bcPos -> beginBCP;
               tLab.new;
               (double,tLab[],xLab[]) -> sel.select;
               tLab -> cd.defLab;
               imps.gen;
               elseLab -> cd.jmp;
               cd.bcPos -> endBCP;
       #)#);
     Selections::
       (# select:
            (# double: @Boolean; tLab,xLab: ^LabelHandler.label;
            enter(double,tLab[],xLab[])
            do cd.bcPos -> beginBCP;
               scansons
               (# S: ^Selection
               do current[] -> S[];
                  (if isLast then
                      (double,true,xLab[]) -> S.select 
                   else
                      (true,false,tLab[]) -> S.select
                  if)
               #);
               cd.bcPos -> endBCP;
       #)#);
     Selection::
       (# select:
            (# double,isLast: @boolean; lab: ^LabelHandler.Label
            enter(double,isLast,lab[])
            do (if double then cd.double if);
               (*'L' -> *) EV.gen;
               lex.symbols.eq -> cd.op;
               (if isLast then
                   (lab,lab) -> cd.jmpFalse; (* check objectcode *)
                   (if double then cd.vpop if);
                else
                   lab -> cd.jmpTrue
            if)#);
       #);
     Evaluation::
       (# gen::
            (#
            do cd.fcom(#do 'Eval:gen:'->TT; dopt -> TQ #);
               scanSons
               (#
               do (if isFirst then
                      current.load
                   else
                      current.store
            if)#)#);
          load:: (#do gen #)
       #);
     PatternDen::
       (# gen::
            (#
            do cd.fcom(#do 'PatternDen:gen:'->TT; AD.dopt->TQ #);
               AD.gen
            #);
          load:: 
            (#
            do cd.fcom(#do 'PatternDen:load:'-> TT; AD.label->TQ #);
               AD.load 
            #);
          store:: (#do AD.store #);
          doAlloc::
            (#
            do cd.fcom(#do 'PatternDen:doAlloc:'->TT; AD.label->TT; dopt->TT #);
               AD.doAlloc
            #);
       #);
     ObjectEvaluation::
       (# load:: (# do OS.load #);
          store:: (# do OS.store #);
       #);
     BetaBinaryExp::
       (# gen::
            (#
            do cd.fcom(#do 'BinExp:gen:'->TT #);
               lE.load; rE.load; 
               (if op
                // lex.symbols.eq then
                   (if true
                    // (lE.exitType).isRef then
                       cd.req
                    // (lE.exitType).isStrucRef then
                       cd.seq
                    else
                       op ->  cd.op;
                   if)
                // lex.symbols.ne then
                   (if true 
                    // (lE.exitType).isRef  then
                       cd.rne                       
                    // (lE.exitType).isStrucRef then
                       cd.sne
                    else
                       op -> cd.op;
                   if)                   
                else
                   op -> (*lex.symbols.asText ->*) cd.op;
               if);
            #);
          load:: (#do cd.fcom(#do 'BinExp:load:'->TT #); gen #);
       #);
     BetaTerm::
       (# load:: 
            (# 
            do cd.fcom(#do 'Term:load'->TT; T.label-> TT; T.dopt -> TT #);
               T.load
            #); 
          store:: (# do T.store #); 
       #);
     ObjectReference::
       (# load::
            (#
            do OV.load
            #)
       #);
     DynamicObjectGeneration::
       (# load::
            (#
            do cd.fcom
               (#do 'DynamicObjectGeneration:gen:'->TT; OS.doPT->TT;
                  (if isRef then '[]' -> TT if);
                  OS.label -> TQ
               #);
               OS.doAlloc; (* is this load or an alloc method? *)
               (* generator:
                * OS.loadOrigin
                * OS.doAlloc
                * perhaps LMR since perhaps enter or exit must be executed
                *)
            #);
       #);
     ThisObject::<
       (# load::
            (#
            do cd.fcom(#do 'ThisObject:load:'->TT; AD.doPT->TT #);
               (* probably not AD.load
                * push adr of enclosing AD
                *)
            #);
       #);
     EvaluationList::<
       (# load::
            (#
            do scanSons
               (#
               do cd.fcom
                  (#
                  do 'EvalList:load:'->TT; current.label->TT;current.dopt->TT#);
                  current.load #)
            #);
          gen::(#do  #);
       #);
     NoneValue::
       (# load:: (#do cd.pushNone #)
       #);
     NameApl::
       (# gen::
            (#
            do (if false then
                   cd.fcom(#do 'nameApl:gen:'->TT; N.dopt-> TQ #);
                   ATd.gen
               if)
            #);
          load::
            (#
            do cd.fcom(#do 'NameApl:load:'-> TT; ATd.label->TT; dopt->TQ #);
               cd.pushThis;
               on -> origin.goOrigin;
               (if ATd[] <> none then
                   ATd.load
                else
                   cd.fcom(#do 'NameApl:gen:ATd=none:'-> TT; dopt->TQ #)
            if)#);
          store::
            (#
            do cd.fcom(#do 'NameApl:store:'-> TT; dopt->TQ #);
               cd.pushThis;
               on -> origin.goOrigin;
               ATd.store;
            #);
          doAlloc::
            (#
            do cd.fcom(#do 'NameApl:doAlloc:' -> TT; ATd.label -> TT  #);
               ATd.doAlloc
            #);
       #);   
     Remote::
       (# doAlloc::
            (#
            do cd.fcom(#do 'Remote:doAlloc:'->TT; dopt -> TT #);
               scanSons
               (#
               do (if not isLast then
                      current.load
                   else
                      current.doAlloc
               if)#)
            #)
       #);
          
     ConstExp::
       (# load:: (# do cst.T.setpos; cst.T.getInt  -> cd.pushConst #);
          gen:: (#do load #);
       #);
     objTmpStack: @
       (# ODs: [30] ^ObjectDesc; next,top: @integer;
          add:
            (# OD: ^ObjectDesc;
            enter OD[]
            do (if (top + 1 -> top) > ODs.range then
                   ODs.range -> ODs.extend
               if);
               OD[] -> ODs[top][]
            #); 
          genNext: BooleanValue
            (#
            do (if (next + 1 -> next) <= top then
                   ODs[next].genClass;
                   true -> value
            if)#)
       #);   
     labelHandler: @
       (# labCount: @integer;
          label:
            (# labNo: @integer;
               new: (# do  labCount + 1 -> labCount -> labNo #);
            enter labNo
            exit labNo
            #);
          init: (# do 0 -> labCount #);
       #);
     genStdBeta:
       (#
       do '**** Generator: StdBeta:'->dumptn;
          topModule.alloc;
          topModule.gen;
          cd.fcom(#do 'objTmpStack.gen'->TT #);
          L:
            (if objTmpStack.genNext then
                restart L
            if)
       #);
     cd:  ^ObjectCode;
  enter cd[]
  #);

