ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
INCLUDE 'qprimitives';
---lib:attributes---
checker: Parser
  (# traceSearch: @ boolean;
     
     Module::<
       (# setUpOrigin:: (# do origin[] -> SO.setUpOrigin #);
          check::
            (#
            do (*'**** Module: ' -> puttext; SO.sig.doPT -> putline;*)
               (basicScope[],basicScope[],true) -> SO.check;
            #);
          alloc:: (# do IT[] -> SO.alloc #);
          desc:: (#do SO.desc -> D[] #);
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do(* 'Check ModuleItem: ' -> puttext; sig.doPT -> putline;*)
               (basicScope[],basicScope[],true) -> MD.check 
            #);
          alloc:: (# do IT[] -> MD.alloc #);
          desc:: (# do MD.desc -> D[] #)
       #);
     Items::<
       (# PT::
            (#
            do (if false then
                   '(' -> lx.put;
                   originOff -> lx.putint; ',' -> lx.put;
                   vsize -> lx.putint; ',' -> lx.put;
                   rsize -> lx.putint; ',' -> lx.put;
                   dsize -> lx.putint; ',' -> lx.put;
                   noOfInner -> lx.putint; ',' -> lx.put;
                   innerInx -> lx.putint;
                   ')' -> lx.put;
                   (pos,break) -> mkbreak
               if);
            #);
          setUpOrigin::
            (# 
            do false -> isChecked (*-> beingChecked -> isVinxd -> isRinxd*) -> done ;
               0 -> descNo -> vsize -> rsize -> originOff -> noOfInner -> dsize -> innerInx;
               scanSons(# do this(Items)[] -> current.setupOrigin #);
               (if props[] <> none then
                   this(Items)[] -> props.setUpOrigin
               if);
            #);
          checkItems:
            (# basicScope: ^Items; hasVirtualArgs: @boolean
            enter(basicScope[],superApl[],hasVirtualArgs)
            do (if not isEmpty or hasVirtualArgs then 
                   (basicScope[],basicScope[],true) -> check 
               if)
            #);
          check::
            (# checkDoubleDecls:
                 (#
                 do (*'\ncheckDoubleDecls: ' -> puttext;*)
                    scanDecls
                    (# thisDcl: ^Decl
                    do currentDcl[] -> thisDcl[]; 
                       (* thisDcl.sig.id[] -> puttext; '>' -> put;*)
                       L:
                         scanAllDecls
                         (#
                         do (*currentDcl.sig.id[] -> puttext; ' ' -> put;*)
                            (if currentDcl[] = thisDcl[] then leave L if);
                            (if currentDcl.sig.id[] -> thisDcl.sig.id.equalNCS then
                                (* We must check that currentDcl is actually 
                                 * a binding of thisDcl; perhpas 
                                 * currentDcl.off = thisDcl.off is ok?
                                 *)
                                (if not (thisDcl.isVirtual and currentDcl.isVirtual) then
                                    thisDcl[] -> SemanticError
                                    (#
                                    do 'Double declaration of: "' -> msg;
                                       thisDcl.sig.id[] -> msg; '"' -> msg
                            #)if)if);
                         #);
                       (*newline;*)
                    #)
                 #);
            do (*'CheckItems: ' -> puttext; doP->putline;*)
               this(items)[] -> basicScope[];

               (if superApl.ATd[] <> none then 
                   (* Has super <
                    * We must ensure that Super has been checked
                    * or is being checked!
                    *)
                   (*'Items:check:hasSuper:on:' -> puttext;
                    superApl.on -> putint; ' sig: ' -> puttext;
                    superApl.ATd.sig.doPT -> putline;*)
                   (* (superApl.ATd.desc).doPT -> putline*)
                   (* (if (superApl.ATd.desc).isEmpty then
                       'Super:empty: ' -> puttext;
                       superApl.ATd.dopt -> putline
                   if);*)
                   superApl.ATd.desc -> superDesc[];
                   (*(if superDesc[] = none then 'superDesc_none'->putline
                    else
                       superApl.dop->putline
                   if)*)
                else (*':no super'->putline;*)
                   objectDecl.desc -> superDesc[];
                   (if superDesc[] = this(items)[] then
                       none -> superDesc[]
                   if)
               if);
               true -> isChecked;               
               scanSons
               (# I: ^Item;
               do (basicScope[],basicScope[],true) -> current.check;
                  current[] -> I[];
                  (if I.hasCode then true -> doHasCode if)
               #);
               checkDoubleDecls;
            #);
          alloc::
            (#
            do (if superApl.ATd[] <> none then
                   superDesc.vsize -> vsize;
                   superDesc.rsize -> rsize;
                   superDesc.dsize -> dsize;
                   (if superApl.isThisBlockLevel and 
                       (not superApl.isImplSuper) and (not superApl.isSingularImplSuper)
                       then
                       superDesc.originOff -> originOff
                    else
                       rsize + 1 -> rsize -> originOff
                   if)
                else
                   rsize + 1 -> rsize -> originOff
               if);
               (if sig[] <> none then
                   this(items)[] -> sig.alloc
               if);
               scanSons(# do this(items)[] -> current.alloc #)
            #);
          topSuper:
            (# topDesc: ^Items
            do (if superDesc[] <> none then
                   superDesc.topSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          localSearch::
            (#
            do (if traceSearch then
                   '>>>Items:localSearch: ' -> puttext; CS[] -> putline;
                   'in:' -> putline; doP -> putline
               if);
               search:
                 (#
                 do scanSons
                    (# I: ^Item; AT: ^Decl; MI: ^ModuleItem
                    do (*'LocalSearch: ' -> puttext;  CS[] -> putline;*)
                       current[] -> I[]; 
                       (if I.isDecl then
                           I[] -> AT[]; 
                           (*'Try: ' -> puttext; AT.sig.id[] -> putline;*)
                           (if (CS[] -> AT.sig.id.equalNCS) then
                               (* 'Found in: ' -> puttext; doPT -> putline;*)
                               AT[] -> ATd[];
                               (if ATd## = ModuleItem## then
                                   (* A hack 
                                    * And worse: this does not work as long as
                                    * we check all modules. An non included
                                    * module may use another non included module,
                                    * which implies that this modules will be
                                    * marked as used!
                                    *)
                                   (*'!!!! Found ModuleItem (hack): ' -> puttext;
                                   ATd.sig.doPT -> putline;*)
                                   ATd[] -> MI[];
                                   true -> MI.MD.isAdded -> MI.MD.isIncluded
                               if);
                               Leave search
                    if)if)#);
                    (if trySig and (sig[] <> none) then
                        (CS[],false) -> sig.localSearch -> (ATd[],pn); (* pn = 0 *)
                        (* (if ATd[] <> none then                            
                         * 'Found in signature: ' -> puttext; CS[] -> puttext;
                         * ' decl: ' -> puttext; ATd.doPT -> putline*)
                    if);
                    (if (ATd[] = none) and (superDesc[] <> none) then
                        (CS[],true) -> superDesc.localSearch -> (ATd[],pn);
                        pn + 1 -> pn
                    if)
                 #)
            #); 
          
          search::
            (# org: ^Items
            do (if traceSearch then
                   '>>>Items:Search:'->puttext; CS[] -> putline;
                   'in: ' -> putline; doP -> putline
               if);
               (CS[],true) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (if incl[] = none then 
                       (*'!!!!!Items:search:incl=none-search for: '->puttext;
                       CS[] -> putline*)
                    else
                       CS[] -> incl.searchInclude -> ATd[];
                   if);
                   (if (ATd[] = none) and isFirst then
                       (if (origin[] -> org[]) <> none then
                           (CS[],isFirst) -> org.search -> (ATd[],on,pn);
                           (if org.isChecked then
                               (*'Origin is checked'->putline*)
                            else
                               'Origin is not checked:search: '->puttext;
                               CS[] -> putline;
                               org.doP -> putline;
                               org.father.doP -> putline
                           if);
                           (if basicNo = ifthen_prim then
                               (* '!!! Origin:search:%if%then: Adjust ON: ' 
                                * -> puttext; 
                                * doP -> putline *)
                            else
                               on + 1 -> on ;
                               (if traceSearch then
                                   '>>> on + 1 = ' -> puttext; on -> putint;
                                   (if ATd[] <> none then 
                                       ' found!' -> putline
                                    else
                                       ' not found' -> putline
                                   if);
                                   doP -> putline
                               if)
                           if)
               if)if)if)
            #);
          basicNo: integerValue
            (* should be used in isPrim *)
            (#
            do (*'Props: ' -> puttext; father.doP -> putline;*)
               (if (props[] <> none) and 
                   (props.basicProp[] <> none) then
                   (if (props.basicProp.primNo -> value) = 0 then
                       (if superDesc[] <> none then
                           superDesc.basicNo -> value;
                            (*value -> putint; newline*)
                        (*else 'no super'->putline*)
                       if)
                    (*else         
                       value -> putint; newline*)
                   if)
                else (*'none: '->puttext;*)
                   (if superDesc[] <> none then
                       superDesc.basicNo -> value;
                       (*value -> putint; newline
                    else 'no super'->putline*)
                   if)
               if)
            #); 
          toOrigin:
             (# on: @integer; org: ^Items
            enter on
            do (if on > 0 then
                   (if basicNo = ifthen_prim then
                       on  -> (origin[]->org[]).toOrigin -> org[]
                    else
                       on - 1 -> (origin[]->org[]).toOrigin -> org[]
                   if)
                else
                   this(Items)[] -> org[]
               if)
            exit org[]
             #); 
          getNameForOff::
            (#
            do '???' -> NM[];
               (*'\ngetNameForOff: ' -> puttext; attOff -> putInt; ' ' -> put;*)
               (if attOff = originOff then
                   'origin' -> NM[];
                   leave getNameForOff
               if);
               L:
                 scanSons
                 (# I: ^Item; D: ^Decl
                 do current[] -> I[];
                    (if I.isDecl then
                        I[] -> D[];
                        I[] -> D[];
                        (if D.off = attOff then
                            D.sig.id[] -> NM[];
                            leave L
                        if)
                    if)
                 #)
            #);          
          getDescNo:: (# do descNo -> dNo #);
          objDescEq:: (# do  DN = descNo -> value #);
          superApl: ^Apl;
          (*superDesc: ^Items; in AbstactSyntaxTree *)
          vsize,rsize,dsize,originOff,noOfInner,innerInx: @integer;
          done: @boolean (* codegen done*)
       #);
     Properties::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check:: (# #);
       #);
     Property::<
       (# setupOrigin::
            (# 
            do origin[] -> P.setupOrigin;
               (if arg[] <> none then origin[] -> arg.setupOrigin if)
            #);
       #);
     Include::
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (*'Check include:' -> puttext; doPT -> putline;*)
               (* basicScope.doPT -> putline;*)
               basicScope.origin[] -> basicScope[];
               scanSons(# do (basicScope[],basicScope[],true) -> current.check #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
          searchInclude:
            (# CS: ^Text; ATd: ^Decl
            enter CS[]
            do search:
                 scanSons
                 (# IV: ^Invocation; MI: ^ModuleItem; pn: @integer
                 do (if traceSearch then
                        '***** Include:search: ' -> puttext; 
                        current.doPT -> putline;
                    if);
                    current[] -> IV[];
                    (if IV.ATd[] = none then 'IV.ATd=none'->putline if);
                    (if IV.ATd.desc = none then 'IV.ATd.desc=none'->putline if);
                    (CS[],false) -> (IV.ATd.desc).localSearch -> (ATd[],pn);
                    (if ATd[] <> none then
                        (*'Found: ' -> puttext; CS[] -> puttext;
                         ' in %include: ' -> puttext; IV.doPT -> putline;*)
                        IV.ATd[] -> MI[]; 
                        (if not MI.MD.isAdded then
                            MI[] -> (encModule).MD.imports.add;
                            true -> MI.MD.isAdded
                        if);
                        leave search
                    if)
                 #)
            exit ATd[]
            #)
       #);
     Signature::<
       (# setUpOrigin::
            (#
            do scanSons(#do origin[] -> current.setupOrigin #);
               (if args[] <> none then
                   args.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (# 
            do scanSons(#do (basicScope[],basicScope[],true) -> current.check#)
            #); 
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
          search::
            (# org: ^Scope
            do (if traceSearch then
                   '>>>Signature:search: ' -> puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               (CS[],false) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (CS[],isFirst) -> (origin[]->org[]).search -> (ATd[],on,pn);
                   on + 1 -> on; (* check this *)
                else
                   (if traceSearch then '*** Found in signature' -> putline if)
               if)
            #);
          LocalSearch::
            (# 
            do (if traceSearch then
                   '>>>Signature:LocalSearch: '->puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               Loop:
                 (if args[] <> none then 
                     args.scanArgs
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if);
               Loop:
                 (if val[] <> none then
                     (*'Val: ' -> putline;
                     val.doPP -> putline;*)
                     val.scanSons
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if)
            #); 
       #);
     Arguments::<
       (# setUpOrigin:: 
            (# 
            do scanSons
               (# OG: ^ObjectGenerator
               do (if current## = ObjectGenerator## then
                      current[] -> OG[];
                      (if not OG.IS.isEmpty then 
                          (*'>>>Arg: virtual:'->putline; OG.doP -> putline;*)
                          (*OG.father.father.father.father.doPP -> putline;*)
                          OG.father.father.father.father -> OG[];
                          (*'Origin:' -> putline; OG.doP->putline;*)
                          (if false (*OG.IS.basicNo = ifthen_prim is NOT defined
                                     * since we are in setUpOrigin *) then
                              origin[] -> current.setUpOrigin
                           else
                              OG.IS[] -> current.setUpOrigin
                          if)
                       else
                          origin[] -> current.setUpOrigin
                      if)
                   else
                      origin[] -> current.setUpOrigin 
                  if)
               #)
            #);
          check:: 
            (# 
            do scanSons(#do (basicScope[],basicScope[],true) -> current.check #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);
     Value::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (#
            do scanSons(#do (basicScope[],basicScope[],true) -> current.check #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);          
     StaticObject::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# elm::Items
            do (basicScope[],argScope[],true) -> sig.check;
               (basicScope[],argScope[],true) -> OG.check; 
            #);
          alloc::
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   (if OG.isBasic then
                       IT.vsize + 1 -> IT.vsize -> off
                    else
                       IT.rsize + 1 -> IT.rsize -> off
               if)if);
               IT[] -> sig.alloc;
               IT[] -> OG.alloc
            #);          
          desc::
            (# elm:: scope
            do (*'StaticObject:desc:'->puttext; doPT -> putline;*)
               (if OG.IS.isEmpty then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
          hasCode:: 
            (* perhaps not suffcient!
             *   S: @T -- hasCode if T hasCode
             *   S: @T{ ... } -- hasCode if T hasCode or main.hasCode
             *   I: @integer --- no code
             *)
            (# 
            do (*OG.hasCode -> value *)
            #);
       #);
     DynamicObject::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> PI.setUpOrigin
            #);
          check::
            (# elm:: items
            do (* newline;
                doPT -> putline;
                basicScope.doPt -> putline;*)
               (basicScope[],basicScope[],true) -> PI.check;
            #);
          alloc::
            (#
            do IT.rsize + 1 -> IT.rsize -> off;
               IT[] -> sig.alloc;
               IT[] -> PI.alloc
            #);          
          desc::
            (# elm:: scope
            do (*'DO:desc:'->puttext; doPT -> putline;*)
               (if PI.ATd[] <> none then
                   PI.desc -> D[]
               if);
            #);
       #);
     (*Pattern: - see qAbstractSyntaxTree *)
     BasicUnaryPattern::<
       (# isPrim:: (#do OD.IS.props.basicProp.primNo -> value #);
          isInner::
            (* Perhaps ad hoc!? *)
            (# 
            do (if OD.IS.props.basicProp.primNo = inner_prim then
                   (*'Check:BasicUP:INNER: '->putline;*)
                   basicScope.noOfInner + 1 -> basicScope.noOfinner;
                   (if basicScope.noOfInner = 1 then 
                       basicScope.dsize + 1 
                         -> basicScope.dsize 
                         -> basicScope.innerInx 
                   if);
               if)
            #)
       #);
     BasicBinaryPattern::<
       (# isPrim:: (#do OD.IS.props.basicProp.primNo -> value #);
       #);     
     BasicFunctionalPattern::<
       (# isPrim:: (#do OD.IS.props.basicProp.primNo -> value #);
       #);
     BasicKeyWordPattern::<
       (# isPrim:: (#do OD.IS.props.basicProp.primNo -> value #);
          (* Use items::basicNo *)
          isInner::
            (#
            do (if OD.IS.props.basicProp.primNo = inner_prim then
                   args.scanArgs
                   (# A: ^ObjectGenerator; org: ^Items
                   do current[] -> A[]; 
                      A.super.on - 1 -> (args.origin[]->org[]).toOrigin -> org[]; 
                      org.noOfInner + 1 -> org.noOfinner;
                      (if org.noOfInner = 1 then 
                          org.dsize + 1 
                            -> org.dsize 
                            -> org.innerInx 
                      if);
                   #)                   
               if)
            #);
       #);
     VirtualPattern::<
       (# check::
            (# elm:: Items
            do (*'Check:virtualPtn: ' -> puttext; sig.dopt -> putline;*)
               (*basicScope.dsize + 1-> basicScope.dsize -> off*)
            #);
          alloc:: (# do IT.dsize + 1-> IT.dsize -> off #)
       #);
     FinalPattern::<
       (# Check::
            (# elm:: Items;
               setImplSuper::
                 (* Perhaps a misleading name
                  * We always search the vDcl/fDcl in super in order
                  * to get off for the virtual
                  * Then we test if super for this FinalPtn is implicit
                  *)
                 (# VP: ^VirtualPattern; (* not always the case *)
                    vDcl: ^Decl; 
                    pn: @integer
                 do (*'FinalPtn:check:setImplSuper:'->puttext;sig.doPT -> putline;*)
                    (sig.id[],false) -> basicScope.superDesc.localSearch -> (vDcl[],pn);
                    (if vDcl[] <> none then
                        (*'Found vDcl: ' -> puttext; vDcl.sig.dopt -> puttext;*)
                        (* OBS! in V:: A { } isImplSuper should not be true
                         * Only for  V:: { }
                         *)
                        vDcl[] -> VP[] -> OD.super.ATd[];
                        (* ' pn:' -> puttext; pn -> putint; 
                         ' off:' -> puttext; off -> putint; ' ' -> put; *)
                        (if OD.super.isEmpty then
                            pn + 1 -> OD.super.pn;
                            true -> OD.super.isImplSuper;
                            (* ' isImplSuper=T '-> puttext;*)
                        if);
                        (if not VP.OD.IS.isEmpty then
                            true -> OD.super.isSingularImplSuper;
                            (* ' isSingularImplSuper=T ' -> puttext; *)
                        if);
                        (*vDcl.sig.doPT -> putline*)
                     else
                        '\n!!! No virtual declaration in super for: ' -> puttext;
                        sig.doPT -> putline;
                    if);
                 #)
            #);
          alloc:: (# do OD.super.ATd.off -> off #);
       #);
     ObjectGenerator::<
       (# setUpOrigin::
            (#
            do origin[] -> super.setUpOrigin;
               origin[] -> IS.setUpOrigin;
               this(ObjectGenerator)[] -> IS.OT[];
               sig[] -> IS.sig[];
            #); 
          check::
            (#
            do (*'Check: ' -> puttext; doPT -> putline;*)

               (if super.ATd[] = none then (* else implict super that has been setUp*)
                   (if sig[] = none then 
                       (basicScope[],basicScope[],true) -> super.check;
                    else
                       (basicScope[],sig[],true) -> super.check;
                   if);                   
               if);               
               (if not IS.isEmpty or (super.hasVirtualArgs and not super.isBasic) then
                   this(ObjectGenerator)[] -> newDesc -> IS.descNo;
               if);
               (*'xCheck: ' -> puttext; doP -> puttext;
               (if super.hasVirtualArgs then
                   ':virtualArgs'->putline
                else
                   ':no vargs'->putline
               if);*)
               (origin[],super[],super.hasVirtualArgs) -> IS.checkItems
            #);
          alloc::
            (#
            do IT[] -> super.alloc;
               (if not IS.isEmpty or (super.hasVirtualArgs and not super.isBasic)
                   then 
                   IT[] -> IS.alloc 
               if)
            #);
          hasCode:: (# do true -> value #);
          getNameForOff::
            (#do (attOff,descNo,isRef,isIndexed) -> IS.getNameForOff -> NM[] #);
          getDescNo:: (# do IS.descNo -> dNo #);
          objDescEq:: (# do DN -> IS.objDescEq -> value #);
       #);
     PatternId::<
       (# setUpOrigin:: (# do origin[] -> IV.setUpOrigin #);
          check:: 
            (# elm:: scope
            do (* newline: IV.dopt->putline; *)
               (if IV.ATd[] <> none then 
                   'PatternId:ATv is defined: ' -> putline;
                   father.doP -> putline
                else
                   (basicScope[],basicScope[],true) -> IV.check -> basicScope[];
               if);
               (if ATd[] = none then
                   IV.ATd[] -> ATd[];
                   IV.on -> on;
                   IV.lgth -> lgth
                else
                   (* PatternId is an implicit super
                    * for a further or final binding, and
                    * ATd has been set by pattern:setImplictSuper
                    *)
                   on -> IV.on;
                   IV.lgth -> lgth
               if);               
            #);
          alloc:: (# do IT[] -> IV.alloc #)
       #);
     Invocation::<
       (# setupOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (*'Invocation:check: ' -> puttext; doP->putline;*)
               (* basicScope.doP -> putline;
               argscope.doP -> putline;*)
               scanSons
               (# E: ^Exp; i: @integer
               do i + 1 -> i;
                  (* 'IV: '->puttext; i -> putint; ' ' -> put; 
                   current.dopt -> putline;*)
                  (basicScope[],argScope[],isFirst) -> current.check -> basicScope[];
                  false -> isFirst;
                  (if isLast then
                      current[] -> E[];
                      E.ATd[] -> ATd[];
                      E.on -> on;
                      i -> lgth;
                  if)
               #)
            #);
          alloc:: (# do scanSons(# do IT[] -> current.alloc #)#)
       #);
     Unary::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> M.setUpOrigin; 
               origin[] -> args.setUpOrigin
            #);
          check::
            (# elm:: scope; org: ^Items
            do (*'Unary:check: ' -> puttext; M.T[] -> puttext;
                ' :scope: ' -> puttext; basicScope.doPP ->putline;*)
               (if basicScope[] <> none then (* ad hoc *)
                   (if traceSearch then
                       '>>>Unary:search: ' -> puttext;
                       M.T[] -> putline
                   if);
                   (M.T[],isFirst) -> basicScope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (M.T[],on,ATd[]) -> found;
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find var: '-> msg;
                          M.T[] -> msg;
                       #);
                       errorDecl[] -> ATd[]
                   if);
                   (if (ATd[] <> none) and (ATd.desc <> none) then 
                       (* ok if static/dynamicObject
                        * If pattern, scope is the desc of the return value
                        *)
                       (if ATd[] = thisCoreDecl[] then
                           coreDecl.desc -> basicScope[]
                        else
                           ATd.desc -> basicScope[]
                       if)
                   if)
                else
                   'Variable:check: scope is none: '->puttext; dopt -> putline
               if)
            #);
          alloc:: 
            (#
            do (IT[],none) -> ATd.isInner;
               scanSons(#do IT[] -> current.alloc #)
            #);
               (*desc:: (# do ATd.desc -> D[] #) To be fixed! *)
       #);
     Binary::<
       (# setUpOrigin::
            (# 
            do origin[] -> operator.setUpOrigin;
               origin[] -> args.setUpOrigin 
            #);
          check:: 
            (# elm:: scope
            do (*'Binary: '-> puttext; operator.T[] -> putline;*)
               (if basicScope[] <> none then (* ad hoc *)
                   (*basicScope[] -> rec.check -> basicScope[];*)
                   (operator.T[],isFirst) -> basicScope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (operator.T[],on,ATd[]) -> found
                    else
                       (if ':=' -> operator.T.equal then 
                           true -> isAssign;
                           (':= (assign)',0,none) -> found
                        else
                           this(TopNode)[] -> SemanticError
                           (#
                           do 'Did NOT find binary: '-> msg; 
                              operator.T[] -> msg;
                           #);
                           errorDecl[] -> ATd[]
                       if)
                   if)
                else                    
                   'binary:check:org none ' -> putline
               if);
               (argScope[],argScope[],true) -> args.check 
            #);
          alloc:: (#do scanSons(#do IT[] -> current.alloc #)#);
       #);
     Function::<
       (# setUpOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# elm:: scope
            do (if basicScope[] <> none then
                   (F.T[],isFirst) -> basicScope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (F.T[],on,ATd[]) -> found;
                       (if ATd.desc <> none 
                           (* why do we do that - see Unary? *) then
                           ATd.desc -> basicScope[];
                       if)
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find function: '-> msg; 
                          F.T[] -> msg;
                       #);
                       errorDecl[] -> ATd[]
                   if)
                else
                   'function:check:scope none ' -> putline    
               if);
               (argScope[],argScope[],true) -> args.check
            #);
          alloc:: (#do scanSons(#do IT[] -> current.alloc #)#);
       #);
     KeyWord::<
       (# setUpOrigin::
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# elm:: scope
            do (if basicScope[] <> none then
                   (id[],isFirst)-> basicScope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (id[],on,ATd[]) -> found
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find keyWord: '-> msg; 
                          id[] -> msg;
                       #);
                       errorDecl[] -> ATd[]
                   if)
                else
                   'KeyWord:check:scope none ' -> putline    
               if);               
               this(Exp)[] -> ATd.checkVirtualArgs;
               (if true then
                   (if ATd.isPrim = this_prim then
                       (* ad hoc - must be fixed *)
                       (if true then 
                           (# A: ^Item
                           do args.scanArgs(# do current[] -> A[] #);
                              (argScope[],argScope[],true) -> A.check;
                              A.desc -> basicScope[];
                       #)if)
                    else
                       (args[],argScope[]) -> argBuf.add
                   if)
                else
                   (argScope[],argScope[],true) -> args.check;
               if)
            #);
          alloc:: 
            (#
            do (IT[],args[]) -> ATd.isInner;
               scanSons(#do IT[] -> current.alloc #)
            #);          
       #);
     BracketedExp::<
       (# setUpOrigin:: (# do origin[] -> E.setUpOrigin #);
          check:: 
            (# 
            do (basicScope[],argScope[],isFirst) -> E.check -> basicScope[];
               E.ATd[] -> ATd[]
            #)
       #);
     const::<
       (# check:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     charObj::<
       (# check:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     found:
       (# id: ^text; on: @integer; ATd: ^Decl
       enter(id[],on,ATd[])
       do (if traceSearch then
              '***** Found: ' -> puttext; id[] -> puttext; 
              ' on: ' -> puttext; on -> putint;
              (if ATd[] <> none then
                  ' Decl: ' -> puttext; ATd.sig.doPT -> putline
               else 
                  newline
          if)if)
       #);
     argBuf:  @
       (# argElm:
            (# #);
          add:
            (# A: ^Arguments; S: ^Scope; next: ^add
            enter(A[],S[])
            do (if head[] = none then
                   this(add)[] -> head[] -> last[]
                else
                   this(add)[] -> last.next[] -> last[]
               if)
            #);
          head,last: ^add;
          check:
            (# H: ^Add;
            do head[] -> H[];
               none -> head[] -> last[];
               Loop: 
                 (if H[] <> none then
                     (H.S[],H.S[],true)  -> H.A.check;
                     H.next[] -> H[];
                     restart Loop
                 if);
               (if head[] <> none then restart check if)
            #)          
          
       #);
     
     getObjectDesc:: 
       (# OD: ^ObjectGenerator
       do descNo -> newDesc.getOD -> OD[];
          OD.IS[] -> D[] 
       #);
     
     newDesc: @
       (# OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;
          getOD: 
            (* only used from minienv *)
            (# descNo: @integer; anODx: ^ObjectGenerator
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     semanticError: 
       (#  msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          n: ^TopNode;
          thisModule: ^module;          
          printLines:
            (# first,last,p: @integer; ch: @char; Lines: ^Text;
            do true -> (n.theModule).doPT -> Lines[];
               n.beginPos -> p;
               L:
                 (if (first < 4) and (p > 1) then
                     p - 1 -> p;
                     (if  (p -> Lines.inxGet) = ascii.newline then first + 1 -> first if);
                     restart L
                 if);
               L:
                 (if (p <= n.endpos) or (ch <> ascii.newline) then 
                     Lines.T[p] -> ch -> put;
                     p + 1 -> p;
                     restart L
                 if);
               newline;
            #);               
       enter n[] 
       do (*n.theModule -> errorModule[];*)
          (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
          (if not withPos then 
              '\n**** Semantic error in module: "' -> puttext; 
              (if n.theModule <> none then                  
                  (n.theModule->thisModule[]).SO.sig.doPT -> puttext; 
                  '"' -> put; newline;
                  printLines;;
                  (*n.father.doPT -> putline*)
               else
                  'n.theModule = none"'->putline
              if);
              '**** ' -> puttext;
              &text[] -> lex.errorStream[]
          if);
          
          (if withPos then
              n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                -> lex.errorStream.putint; 
              ' ' -> lex.errorStream.put;
              n.endPos -> lex.errorStream.putint; 
              ' ' -> lex.errorStream.put;          
          if);
          INNER;
          lex.errorStream.newline;
          (if not withPos then
              lex.errorStream[] -> putline
          if);
          true -> semanticErrors
       #);
     semanticErrors: @boolean;
     
  do '**** CHECKER ****' -> putline;
     0 -> newDesc.noOfDescs; (* needed when exe from minienv
                              * we must find a way to compile changed modules
                              * currently we compile all modules
                              *)
     false -> semanticErrors;
     rootModule.setUpOrigin;
     rootModule.check;
     argBuf.check;
     rootModule.alloc;
     (*main.doPT -> putline;*)
     (*main.doPP -> putline;*)
     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline
      else
         inner
     if)
  #)
