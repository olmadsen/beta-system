ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
INCLUDE 'qprimitives';
---lib:attributes---
checker: Parser
  (# traceSearch: (# exit false #);
     
     Module::<
       (# setUpOrigin:: (# do origin[] -> SO.setUpOrigin #);
          check::
            (#
            do '**** Module: ' -> puttext; SO.sig.doPT -> putline;
               scope[] -> SO.check;
            #);
          desc:: (#do SO.desc -> D[] #);
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do(* 'Check ModuleItem: ' -> puttext; sig.doPT -> putline;*)
               scope[] -> MD.check 
            #);
          desc:: (# do MD.desc -> D[] #)
       #);
     Items::<
       (# PT::
            (#
            do (if false then
                   '(' -> lx.put;
                   originOff -> lx.putint; ',' -> lx.put;
                   vsize -> lx.putint; ',' -> lx.put;
                   rsize -> lx.putint; ',' -> lx.put;
                   dsize -> lx.putint; ',' -> lx.put;
                   noOfInner -> lx.putint; ',' -> lx.put;
                   innerInx -> lx.putint;
                   ')' -> lx.put;
                   (pos,break) -> mkbreak
               if);
            #);
          setUpOrigin::
            (# 
            do false (*-> isChecked -> beingChecked -> isVinxd -> isRinxd*) -> done ;
               0 -> vsize -> rsize -> originOff -> noOfInner -> dsize -> innerInx;
               scanSons(# do this(Items)[] -> current.setupOrigin #);
               (if props[] <> none then
                   this(Items)[] -> props.setUpOrigin
               if);
            #);
          checkItems:
            (# scope: ^Items; hasVirtualArgs: @boolean
            enter(scope[],superApl[],hasVirtualArgs)
            do (if not isEmpty or hasVirtualArgs then scope[] -> check if)
            #);
          check::
            (# 
            do this(items)[] -> scope[];
               (if superApl.ATd[] <> none then
                   (* Has super 
                    * We must ensure that Super has been checked
                    * or is being checked!
                    *)
                   (*'Items:check:hasSuper:on:' -> puttext;
                    superApl.on -> putint; ' sig: ' -> puttext;
                    superApl.ATd.sig.doPT -> putline;*)
                   (* (superApl.ATd.desc).doPT -> putline*)
                   (* (if (superApl.ATd.desc).isEmpty then
                       'Super:empty: ' -> puttext;
                       superApl.ATd.dopt -> putline
                   if);*)
                   superApl.ATd.desc -> superDesc[];
                   superDesc.vsize -> vsize;
                   superDesc.rsize -> rsize;
                   superDesc.dsize -> dsize;
                   (* We need to reallocate the variables in the signature!!!
                    * Currently an error in Recursive.xbeta
                    *)
                   (if superApl.isThisBlockLevel and 
                        not (superApl.isImplSuper and not superApl.isSingularImplSuper)
                       then
                       superDesc.originOff -> originOff 
                    else
                       rsize + 1 -> rsize -> originOff
                   if)
                else
                   rsize + 1 -> rsize -> originOff
               if);               
               scanSons(# do scope[] -> current.check #)
            #);
          topSuper:
            (# topDesc: ^Items
            do (if superDesc[] <> none then
                   superDesc.topSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          localSearch:
            (# CS: ^ Text; ATd: ^Decl; pn: @integer
            enter CS[]
            do search:
                 (#
                 do scanSons
                    (# I: ^Item; AT: ^Decl; MI: ^ModuleItem
                    do (*'LocalSearch: ' -> puttext;  CS[] -> putline;*)
                       current[] -> I[]; 
                       (if I.isDecl then
                           I[] -> AT[]; 
                           (*'Try: ' -> puttext; AT.sig.id[] -> putline;*)
                           (if (CS[] -> AT.sig.id.equalNCS) then
                               (* 'Found in: ' -> puttext; doPT -> putline;*)
                               AT[] -> ATd[];
                               (if ATd## = ModuleItem## then
                                   (* A hack 
                                    * And worse: this does not work as long as
                                    * we check all modules. An non included
                                    * module may use another non included module,
                                    * which implies that this modules will be
                                    * marked as used!
                                    *)
                                   (*'!!!! Found ModuleItem (hack): ' -> puttext;
                                   ATd.sig.doPT -> putline;*)
                                   ATd[] -> MI[];
                                   true -> MI.MD.isAdded -> MI.MD.isIncluded
                               if);
                               Leave search
                    if)if)#);
                    (*'Try signature'->putline;*)
                    (if sig[] <> none then
                        CS[] -> sig.searchSig -> ATd[];
                        (* (if ATd[] <> none then                            
                         * 'Found in signature: ' -> puttext; CS[] -> puttext;
                         * ' decl: ' -> puttext; ATd.doPT -> putline*)
                    if);
                    (if (ATd[] = none) and (superDesc[] <> none) then
                        CS[] -> superDesc.localSearch -> (ATd[],pn);
                        pn + 1 -> pn
                    if)
                 #)
            exit(ATd[],pn)
            #); 
          
          search:
            (# CS: ^ Text; org: ^Items; ATd: ^Decl; on,pn: @integer
            enter CS[]
            do (*'OT:Search:'->puttext; CS[] -> putline;*)
               CS[] -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (if ATd[] = none then
                       (if incl[] = none then 
                           '!!!!!Items:search:incl=none-search for: '->puttext;
                           CS[] -> putline
                        else
                           CS[] -> incl.searchInclude -> ATd[];
                       if);
                       (if ATd[] = none then
                           (if (origin[] -> org[]) <> none then
                               CS[] -> org.search -> (ATd[],on,pn);
                               (if basicNo =  ifthen_prim then
                                  (* '!!! Origin:search:%if%then: Adjust ON!!' -> puttext; 
                                   org.doP -> putline*)
                               if);
                               on + 1 -> on
               if)if)if)if)
            exit(ATd[],on,pn)
            #);
          basicNo: integerValue
            (* should be used in isPrim *)
            (#
            do (if props[] <> none then
                   (if (props.basicProp.primNo -> value) = 0 then
                       (if superDesc[] <> none then
                           superDesc.basicNo -> value
               if)if)if)
            #); 
          superApl: ^Apl;
          superDesc: ^Items;
          vsize,rsize,dsize,originOff,noOfInner,innerInx: @integer;
          done: @boolean (* codegen done*)
       #);
     Properties::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check:: (# #);
       #);
     Property::<
       (# setupOrigin::
            (# 
            do origin[] -> P.setupOrigin;
               (if arg[] <> none then origin[] -> arg.setupOrigin if)
            #);
       #);
     Include::
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (*'Check include:' -> puttext; doPT -> putline;*)
               (* scope.doPT -> putline;*)
               scope.origin[] -> scope[];
               scanSons(# do scope[] -> current.check #)#);
          searchInclude:
            (# CS: ^Text; ATd: ^Decl
            enter CS[]
            do scanSons
               (# IV: ^Invocation; MI: ^ModuleItem; pn: @integer
               do (if traceSearch then
                      '***** Include:search: ' -> puttext; 
                      current.doPT -> putline;
                  if);
                  current[] -> IV[];
                  (if IV.ATd[] = none then 'IV.ATd=none'->putline if);
                  (if IV.ATd.desc = none then 'IV.ATd.desc=none'->putline if);
                  CS[] -> (IV.ATd.desc).localSearch -> (ATd[],pn);
                  (if ATd[] <> none then
                      (*'Found: ' -> puttext; CS[] -> puttext;
                       ' in %include: ' -> puttext; IV.doPT -> putline;*)
                      IV.ATd[] -> MI[]; 
                      (if not MI.MD.isAdded then
                          MI[] -> (encModule).MD.imports.add;
                          true -> MI.MD.isAdded
                      if);
                  if)
               #)
            exit ATd[]
            #)
       #);
     Signature::<
       (# setUpOrigin::
            (#
            do scanSons(#do origin[] -> current.setupOrigin #);
               (if args[] <> none then
                   args.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (# 
            do scanSons(#do scope[] -> current.check#)
            #); 
          SearchSig:
            (# CS: ^text; ATd: ^Decl; isArg: @boolean
            enter CS[]
            do (*'\Signature:SearchSig: '->puttext; CS[] -> puttext;
                ':'->put; id[] -> putline;*)
               Loop:
                 (if args[] <> none then 
                     args.scanArgs
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if);
               Loop:
                 (if val[] <> none then
                     val.scanSons
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if)
            exit ATd[]
            #); 
       #);
     Arguments::<
       (# setUpOrigin:: 
            (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: (# do scanSons(# do scope[] -> current.check #) #);
       #);
     Value::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (#
            do scanSons(#do scope[] -> current.check #)
            #)
       #);          
     StaticObject::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# elm::Items
            do scope[] -> sig.check;
               scope[] -> OG.check; 
               (if scope[] <> none then
                   (* origin is none if StaticObject is a Module *)
                   (* origin is wrong here
                    * foo:
                    *    X: @integer -- in foo (origin)
                    *    max(a: @integer -- in max):
                    *       b: @integer -- in max
                    *)
                   (*origin[] -> scope[]; *)
                   (*'\n** ST:check: ' -> puttext; dopt -> putline;*)
                   (if OG.isBasic then
                       scope.vsize + 1 -> scope.vsize -> off
                    else
                       scope.rsize + 1 -> scope.rsize -> off
                   if)
               if);
            #);
          desc::
            (# elm:: Items
            do (*'StaticObject:desc:'->puttext; doPT -> putline;*)
               (if OG.IS.isEmpty then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
       #);
     DynamicObject::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> PI.setUpOrigin
            #);
          check::
            (# elm:: Items
            do (* newline;
                doPT -> putline;
                scope.doPt -> putline;*)
               scope[] -> PI.check;
               (if origin[] <> none then 
                   (*origin.doPT -> putline;*)
                   (* origin is none if StaticObject is a Module *)
                   (*origin[] -> scope[];*)
                   scope.rsize + 1 -> scope.rsize -> off;
                else
                   'Origin is none' -> putline
               if);
            #);
          desc::
            (# elm:: Items
            do (*'DO:desc:'->puttext; doPT -> putline;*)
               (if PI.ATd[] <> none then
                   PI.desc -> D[]
               if);
            #);
       #);
     (*Pattern: - see qAbstractSyntaxTree *)
     BasicUnaryPattern::<
       (# isInner::
            (* Perhaps ad hoc!? *)
            (#
            do (if OD.IS.props.basicProp.primNo
                // inner_prim then
                   (*'Check:BasicUP:INNER: '->putline;*)
                   scope.noOfInner + 1 -> scope.noOfinner;
                   (if scope.noOfInner = 1 then 
                       scope.dsize + 1 -> scope.dsize 
                         -> scope.innerInx 
                   if);
               if)
            #)
       #);
     BasicFunctionalPattern::<
       (# isPrim:: (#do OD.IS.props.basicProp.primNo -> value #);
       #);
     BasicKeyWordPattern::<
       (# isPrim:: (#do OD.IS.props.basicProp.primNo -> value #);
          (* Use items::basicNo *)
       #);
     VirtualPattern::<
       (# check::
            (# elm:: Items
            do (*'Check:virtualPtn: ' -> puttext; sig.dopt -> putline;*)
               scope.dsize + 1-> scope.dsize -> off
            #)
       #);
     FinalPattern::<
       (# Check::
            (# elm:: Items;
               setImplSuper::
                 (* Perhaps a misleading name
                  * We always search the vDcl/fDcl in super in order
                  * to get off for the virtual
                  * Then we test if super for this FinalPtn is implicit
                  *)
                 (# VP: ^VirtualPattern; (* not always the case *)
                    vDcl: ^Decl; 
                    pn: @integer
                 do (*'FinalPtn:check:setImplSuper:'->puttext;sig.doPT -> putline;*)
                    sig.id[] -> scope.superDesc.localSearch -> (vDcl[],pn);
                    (if vDcl[] <> none then
                        (*'Found vDcl: ' -> puttext; vDcl.sig.dopt -> puttext;*)
                        (* OBS! in V:: A { } isImplSuper should not be true
                         * Only for  V:: { }
                         *)
                        vDcl[] -> VP[] -> OD.super.ATd[];
                        vDcl.off -> off;
                        (* ' pn:' -> puttext; pn -> putint; 
                         ' off:' -> puttext; off -> putint; ' ' -> put; *)
                        (if OD.super.isEmpty then
                            pn + 1 -> OD.super.pn;
                            true -> OD.super.isImplSuper;
                            (* ' isImplSuper=T '-> puttext;*)
                        if);
                        (if not VP.OD.IS.isEmpty then
                            true -> OD.super.isSingularImplSuper;
                            (* ' isSingularImplSuper=T ' -> puttext; *)
                        if);
                        (*vDcl.sig.doPT -> putline*)
                     else
                        '\n!!! No virtual declaration in super for: ' -> puttext;
                        sig.doPT -> putline;
                    if);
                 #)
            #)
       #);
     ObjectGenerator::<
       (# setUpOrigin::
            (#
            do origin[] -> super.setUpOrigin;
               origin[] -> IS.setUpOrigin;
               this(ObjectGenerator)[] -> IS.OT[];
               sig[] -> IS.sig[];
            #); 
          check::
            (#
            do (*'Check: ' -> puttext; doPT -> putline;*)
               (if super.ATd[] <> none then
                   (* 'super:ATv is defined: ' -> putline;
                    father.doP -> putline*)
                else
                   scope[] -> super.check;
                   (*origin[] -> super.check;*) (* scope? And below?*)
               if);               
               (*(if super.hasVirtualArgs then
                'OG:super:hasVirtualArgs: ' -> puttext;
                super.doPT -> putline
                if);*)

               (if not IS.isEmpty or (super.hasVirtualArgs and not super.isBasic) then
                   this(ObjectGenerator)[] -> newDesc -> IS.descNo;
               if);

               (origin[],super[],super.hasVirtualArgs) -> IS.checkItems
            #);
       #);
     PatternId::<
       (# setUpOrigin:: (# do origin[] -> IV.setUpOrigin #);
          check:: 
            (# elm:: Items
            do (* newline: IV.dopt->putline; *)
               (if IV.ATd[] <> none then 
                   'PatternId:ATv is defined: ' -> putline;
                   father.doP -> putline
                else
                   scope[] -> IV.check -> scope[];
               if);
               (if ATd[] = none then
                   IV.ATd[] -> ATd[];
                   IV.on -> on;
                   IV.length -> length
                else
                   (* PatternId is an implicit super
                    * for a further or final binding, and
                    * ATd has been set by pattern:setImplictSuper
                    *)
                   on -> IV.on;
                   IV.length -> length
               if);               
            #)
       #);
     Invocation::<
       (# setupOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (*'Invocation:check: ' -> puttext; dopt->putline;*)
               scanSons
               (# E: ^Exp; i: @integer
               do i + 1 -> i;
                  (* 'IV: '->puttext; i -> putint; ' ' -> put; 
                   * current.dopt -> putline;*)
                  scope[] -> current.check -> scope[];
                  (if isLast then
                      current[] -> E[];
                      E.ATd[] -> ATd[];
                      E.on -> on;
                      i -> length;
                  if)
               #)
            #)
       #);
     Unary::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> M.setUpOrigin; 
               origin[] -> args.setUpOrigin
            #);
          check::
            (# elm:: items
            do (*'Search: ' -> puttext; M.T[] -> putline;
                ': Variable: ' -> puttext; scope.dopt ->putline;*)
               (if scope[] <> none then (* ad hoc *)
                   M.T[] -> scope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (M.T[],on,ATd[]) -> found;
                       scope[] -> ATd.isInner;
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find var: '-> msg;
                          M.T[] -> msg;
                       #);
                       Decl -> ATd[]
                   if);
                   (if (ATd[] <> none) and (ATd.desc <> none) then 
                       ATd.desc -> scope[]
                   if)
                else
                   'Variable:check: scope is none: '->puttext; dopt -> putline
               if)
            #);
               (*desc:: (# do ATd.desc -> D[] #) To be fixed! *)
       #);
     Binary::<
       (# setUpOrigin::
            (# 
            do origin[] -> operator.setUpOrigin;
               origin[] -> args.setUpOrigin 
            #);
          check:: 
            (# elm:: Items
            do (* 'Binary: '-> puttext; operator.T[] -> putline;*)
               (if scope[] <> none then (* ad hoc *)
                   (*scope[] -> rec.check -> scope[];*)
                   operator.T[] -> scope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (operator.T[],on,ATd[]) -> found
                    else
                       (if ':=' -> operator.T.equal then 
                           true -> isAssign;
                           (':= (assign)',0,none) -> found
                        else
                           this(TopNode)[] -> SemanticError
                           (#
                           do 'Did NOT find binary: '-> msg; 
                              operator.T[] -> msg;
                           #);
                           Decl -> ATd[]
                       if)
                   if)
                else                    
                   'binary:check:org none ' -> putline
               if);
               origin[] -> args.check 
            #)          
       #);
     Function::<
       (# setUpOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# elm:: Items
            do (if scope[] <> none then
                   F.T[]-> scope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (F.T[],on,ATd[]) -> found
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find function: '-> msg; 
                          F.T[] -> msg;
                       #);
                       Decl -> ATd[]
                   if)
                else
                   'function:check:scope none ' -> putline    
               if);
               scanSons(#do scope[] -> current.check #)
            #)
       #);
     KeyWord::<
       (# setUpOrigin::
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# elm:: Items
            do (if scope[] <> none then
                   id[]-> scope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       (id[],on,ATd[]) -> found
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find keyWord: '-> msg; 
                          id[] -> msg;
                       #);
                       Decl -> ATd[]
                   if)
                else
                   'KeyWord:check:scope none ' -> putline    
               if);
               
               this(Exp)[] -> ATd.checkVirtualArgs;
               
               scanSons(#do scope[] -> current.check #);               
            #) 
       #);
     found:
       (# id: ^text; on: @integer; ATd: ^Decl
       enter(id[],on,ATd[])
       do (if traceSearch then
              '***** Found: ' -> puttext; id[] -> puttext; 
              ' on: ' -> puttext; on -> putint;
              (if ATd[] <> none then
                  ' Decl: ' -> puttext; ATd.sig.doPT -> putline
               else 
                  newline
          if)if)
       #);
     newDesc: @
       (# OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;
          getOD: 
            (* only used from minienv *)
            (# descNo: @integer; anODx: ^ObjectGenerator
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     semanticError: 
       (#  msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          n: ^TopNode;
          thisModule: ^module;
       enter n[] 
       do (*n.theModule -> errorModule[];*)
          (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
          (if not withPos then 
              '\n**** Semantic error in module: "' -> puttext; 
              (if n.theModule <> none then
                  (n.theModule->thisModule[]).SO.sig.doPT -> puttext; 
                  '"' -> put; newline;
                  n.father.doPT -> putline
               else
                  'n.theModule = none"'->putline
              if);
              '**** ' -> puttext;
              &text[] -> lex.errorStream[]
          if);
          
          (if withPos then
              n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                -> lex.errorStream.putint; 
              ' ' -> lex.errorStream.put;
              n.endPos -> lex.errorStream.putint; 
              ' ' -> lex.errorStream.put;          
          if);
          INNER;
          lex.errorStream.newline;
          (if not withPos then
              lex.errorStream[] -> putline
          if);
          true -> semanticErrors
       #);
     semanticErrors: @boolean;
     
  do  (if doParse then
          '**** CHECKER ****' -> putline;
          rootModule.setUpOrigin;
          rootModule.check;
          main.doPT -> putline;
          (*main.doPP -> putline;*)
          (if semanticErrors then
              '\n***** Semantic errors: compilation stops' -> putline
           else
              inner
          if)
      if)
  #)
