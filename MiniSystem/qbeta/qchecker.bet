ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
INCLUDE 'qprimitives';
---lib:attributes---
(* origin is always in instance of Items or none - for the outermost Module 
 * basicScope = origin for Items
 * argScope = basicScope in most cases
 * except for a pattern: Signature: ObjectGenerator:super, where
 *  (none,basicScope[],sig[],true) -> super.check;
 * argScope is mainly passed as argument to check
 * but saved in argBuf.add and then used in argBuf.check
 * Checking is recursive whenever neeeded, see abstractsyntaxtree::check
 *)
traceGeneric: (# exit false #);
traceGeneric2: (# exit false #);
traceGeneric3: (# exit false #);
handleGeneric: (# exit true #);
checker: Parser
  (# traceCheck,traceSearch: @ boolean;
     Module::<
       (# setUpOrigin:: (# do origin[] -> DI.setUpOrigin #);
          check::
            (#
            do (if verbose then
                   '**** Module: ' -> puttext; DI.sig.doPT -> putline
               if);
               (none,basicScope[],basicScope[],true) -> DI.check;
               this(Module)[] -> imports.addM
            #);
          alloc:: 
            (# 
            do (*'Module:alloc: ' -> puttext; moduleName->putline; *)
               IT[] -> DI.alloc 
            #);
          desc:: (#do DI.desc -> D[] #);
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do(* 'Check ModuleItem: ' -> puttext; sig.doPT -> putline;*)
               (if false then
                   (none,basicScope[],basicScope[],true) -> MD.check
               if);
               false -> wasChecked
            #);
          alloc:: 
            (# 
            do 
               (if isChecked then 
                   (*'ModuleItem:alloc: ' -> puttext; MD.moduleName -> putline;*)
                   IT[] -> MD.alloc
               (* else
                'ModuleItem:alloc:NOT checked ' -> puttext; MD.moduleName -> putline*)
               if)
            #);
          desc:: (# do MD.desc -> D[] #)
       #);
     Items::<
       (# PT::
            (#
            do (if false then
                   '(' -> lx.put;
                   originOff -> lx.putint; ',' -> lx.put;
                   vsize -> lx.putint; ',' -> lx.put;
                   rsize -> lx.putint; ',' -> lx.put;
                   dsize -> lx.putint; ',' -> lx.put;
                   noOfInner -> lx.putint; ',' -> lx.put;
                   innerInx -> lx.putint;
                   ')' -> lx.put;
                   (pos,break) -> mkbreak
               if);
            #);
          setUpOrigin::
            (# 
            do false -> isChecked -> beingChecked (*-> isVinxd -> isRinxd*) -> done ;
               0 -> descNo -> vsize -> rsize -> originOff -> noOfInner -> dsize -> innerInx;
               scanSons(# do this(Items)[] -> current.setupOrigin #);
               (if props[] <> none then
                   this(Items)[] -> props.setUpOrigin
               if);
            #);
          checkItems:
            (# basicScope: ^Items; hasVirtualArgs: @boolean
            enter(basicScope[],superApl[],hasVirtualArgs)
            do (if not isEmpty or hasVirtualArgs then
                   (none,basicScope[],basicScope[],true) -> check 
               if)
            #);
          check::
            (# checkDoubleDecls:
                 (#
                 do (*'\ncheckDoubleDecls: ' -> puttext;*)
                    scanDecls
                    (# thisDcl: ^Decl
                    do currentDcl[] -> thisDcl[]; 
                       (* thisDcl.sig.id[] -> puttext; '>' -> put;*)
                       L:
                         scanAllDecls
                         (#
                         do (*currentDcl.sig.id[] -> puttext; ' ' -> put;*)
                            (if currentDcl[] = thisDcl[] then leave L if);
                            (if currentDcl.sig.id[] -> thisDcl.sig.id.equalNCS then
                                (* We must check that currentDcl is actually 
                                 * a binding of thisDcl; perhpas 
                                 * currentDcl.off = thisDcl.off is ok?
                                 *)
                                (if not (thisDcl.isVirtual and currentDcl.isVirtual) then
                                    thisDcl[] -> SemanticError
                                    (#
                                    do 'Double declaration of: "' -> msg;
                                       thisDcl.sig.id[] -> msg; '"' -> msg
                            #)if)if);
                         #);
                       (*newline;*)
                    #)
                 #);
            do (if traceCheck then '*** Check Items: \n' -> puttext; doPT->putline if);
               this(items)[] -> basicScope[];
               (if superApl.ATd[] <> none then
                   (* Has super <
                    * We must ensure that Super has been checked
                    * or is being checked!
                    *)
                   superApl.ATd.desc -> superDesc[];
                else
                   objectDecl.desc -> superDesc[];
                   (if superDesc[] = this(items)[] then
                       none -> superDesc[]
                   if)
               if);

               (if props[] <> none then 
                   (none,basicScope[],basicScope[],true) -> props.check 
               if);
               scanSons
               (# I: ^Item;
               do (none,basicScope[],basicScope[],true) -> current.check;
                  current[] -> I[];
                  (if I.hasCode then true -> doHasCode if)
               #);
               checkDoubleDecls;
            #);
          alloc::
            (#
            do (*'Items:alloc: ' -> puttext; *)
               (if superApl.ATd[] <> none then
                   superDesc.vsize -> vsize;
                   superDesc.rsize -> rsize;
                   superDesc.dsize -> dsize;
                   (if superApl.isThisBlockLevel and 
                       (not superApl.isImplSuper) and (not superApl.isSingularImplSuper)
                       then
                       superDesc.originOff -> originOff; 
                    else
                       rsize + 1 -> rsize -> originOff
                   if)
                else
                   rsize + 1 -> rsize -> originOff
               if);
               (if sig[] <> none then
                   this(items)[] -> sig.alloc
               if);
               scanSons(# do this(items)[] -> current.alloc #)
            #);
          topSuper:
            (# topDesc: ^Items
            do (if superDesc[] <> none then
                   superDesc.topSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          localSearch::
            (#
            do (if traceSearch then
                   '>>>Items:localSearch: ' -> puttext; CS[] -> putline;
                   'in:' -> putline; doP -> putline
               if);
               search:
                 (#
                 do scanSons
                    (# I: ^Item; AT: ^Decl; MI: ^ModuleItem; MD: ^Module
                    do (*'LocalSearch: ' -> puttext;  CS[] -> putline;*)
                       current[] -> I[]; 
                       (if I.isDecl then
                           I[] -> AT[]; 
                           (*'Try: ' -> puttext; AT.sig.id[] -> putline;*)
                           (if (CS[] -> AT.sig.id.equalNCS) then
                               (* 'Found in: ' -> puttext; doPT -> putline;*)
                               AT[] -> ATd[];
                               (if ATd## = ModuleItem## then
                                   (* A hack 
                                    * And worse: this does not work as long as
                                    * we check all modules. An non included
                                    * module may use another non included module,
                                    * which implies that this modules will be
                                    * marked as used!
                                    *)
                                   (*'!!!! Found ModuleItem (hack): ' -> puttext;
                                   ATd.sig.doPT -> putline;*)
                                   ATd[] -> MI[];
                                   (*true -> MI.MD.isAdded -> MI.MD.isIncluded*)
                                   MI[] -> (theModule->MD[]).imports.add
                               if);
                               Leave search
                    if)if)#);
                    (if trySig and (sig[] <> none) then
                        (CS[],false) -> sig.localSearch -> (ATd[],pn); (* pn = 0 *)
                        (* (if ATd[] <> none then                            
                         * 'Found in signature: ' -> puttext; CS[] -> puttext;
                         * ' decl: ' -> puttext; ATd.doPT -> putline*)
                    if);
                    (if (ATd[] = none) and (superDesc[] <> none) then
                        (CS[],true) -> superDesc.localSearch -> (ATd[],pn);
                        pn + 1 -> pn
                    if)
                 #)
            #); 
          
          search::
            (# org: ^Items; F: ^Node
            do (if traceSearch then
                   '>>>Items:Search:'->puttext; CS[] -> putline;
                   'in: ' -> putline; doP -> putline
               if);
               (CS[],true) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (if incl[] = none then 
                       (*'!!!!!Items:search:incl=none-search for: '->puttext;
                       CS[] -> putline*)
                    else
                       CS[] -> incl.searchInclude -> ATd[];
                   if);
                   (if (ATd[] = none) and isFirst then
                       (if (origin[] -> org[]) <> none then
                           (CS[],isFirst) -> org.search -> (ATd[],on,pn);
                           (if not org.isChecked then
                               (if traceCheck then
                                   '*** Origin not checked: ' -> puttext; doPT -> putline;
                                   '    Search: ' -> puttext; org.father.label -> putline;
                               if);
                               (none,org[],org[],true) -> (org.father[]->F[]).check
                           if);
                           (if basicNo = ifthen_prim then
                               (* '!!! Origin:search:%if%then: Adjust ON: ' 
                                * -> puttext; 
                                * doP -> putline *)
                            else
                               on + 1 -> on ;
                               (if traceSearch then
                                   '>>> on + 1 = ' -> puttext; on -> putint;
                                   (if ATd[] <> none then 
                                       ' found!' -> putline
                                    else
                                       ' not found' -> putline
                                   if);
                                   doP -> putline
                               if)
                           if)
               if)if)if)
            #);
          basicNo: integerValue
            (* should be used in primNo *)
            (#
            do (*'Props: ' -> puttext; father.doP -> putline;*)
               (if (props[] <> none) and 
                   (props.basicProp[] <> none) then
                   (if (props.basicProp.primNo -> value) = 0 then
                       (if superDesc[] <> none then
                           superDesc.basicNo -> value;
                            (*value -> putint; newline*)
                        (*else 'no super'->putline*)
                       if)
                    (*else         
                       value -> putint; newline*)
                   if)
                else (*'none: '->puttext;*)
                   (if superDesc[] <> none then
                       superDesc.basicNo -> value;
                       (*value -> putint; newline
                    else 'no super'->putline*)
                   if)
               if)
            #); 
          toOrigin:
             (# on: @integer; org: ^Items
             enter on
             do (if on > 0 then
                    (if basicNo = ifthen_prim then
                        on  -> (origin[]->org[]).toOrigin -> org[]
                     else
                        on - 1 -> (origin[]->org[]).toOrigin -> org[]
                    if)
                 else
                    this(Items)[] -> org[];
                if);
                (if org.basicNo = ifThen_prim then
                    org.origin[] -> org[]
                if)
             exit org[]
             #); 
          getNameForOff::
            (#
            do '???' -> NM[];
               (*'\ngetNameForOff: ' -> puttext; attOff -> putInt; ' ' -> put;*)
               (if attOff = originOff then
                   'origin' -> NM[];
                   leave getNameForOff
               if);
               L:
                 scanSons
                 (# I: ^Item; D: ^Decl
                 do current[] -> I[];
                    (if I.isDecl then
                        I[] -> D[];
                        I[] -> D[];
                        (if D.off = attOff then
                            D.sig.id[] -> NM[];
                            leave L
                        if)
                    if)
                 #)
            #);          
          getDescNo:: (# do descNo -> dNo #);
          objDescEq:: (# do  DN = descNo -> value #);
          superApl: ^Apl;
          vsize,rsize,dsize,originOff,noOfInner,innerInx: @integer;
          done: @boolean (* codegen done*)
       #);
     Properties::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check:: 
            (# 
            do scanSons
               (#do (none,basicScope[],basicScope[],true) -> current.check#)
            #)
       #);
     Property::<
       (# setupOrigin::
            (# 
            do (if P[] <> none then (* probably to be improved/generalized *)
                   origin[] -> P.setupOrigin;
               if);
               (if arg[] <> none then origin[] -> arg.setupOrigin if)
            #);
          check::
            (# elm:: scope;
            do (if P[] <> none then
                   (none,basicScope[],basicScope[],true) -> P.check;
                   (* only for globals, interface, etc
                    * Not for basic, const, etc
                    *)
                   (P.T[],true) -> basicScope.search -> (P.ATd[],P.on,P.pn);
                   (if false and (P.ATd[] = none) then
                       '\n*** Did not find a declartion of property: ' 
                         -> puttext;
                       P.T[] -> putline
               if)if);
               (if arg[] <> none then
                   (none,basicScope[],basicScope[],true) -> arg.check
               if)
            #)
       #);
     Include::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (if son[] <> none then
                   (if traceCheck then 
                       '*** Check include:' -> puttext; doPT -> putline if);
                   basicScope.origin[] -> basicScope[];
                   scanSons
                   (#do (none,basicScope[],basicScope[],true) -> current.check#);
                   (* Force check of included modules *)
                   scanSons
                   (# IV: ^Invocation; MI: ^ModuleItem
                   do current[] -> IV[];
                      (if IV.ATd[] <> none then
                          IV.ATd[] -> MI[];
                          (NONE,MI.MD.origin[],MI.MD.origin[],true) -> MI.MD.check;
                          true -> MI.isChecked;
                          (if not MI.MD.isAdded then
                              MI[] -> (encModule).MD.imports.add;
                              true -> MI.MD.isAdded
                        if);
                   if)#)
               if)
            #);
          alloc:: 
            (# 
            do 
               scanSons(#do IT[] -> current.alloc #)
            #);
          searchInclude:
            (# CS: ^Text; ATd: ^Decl
            enter CS[]
            do (none,origin[],origin,true) -> check;
               search:
                 scanSons
                 (# IV: ^Invocation; MI: ^ModuleItem; pn: @integer
                 do (if traceSearch then
                        '*** Include:search: ' -> puttext; 
                        current.doPT -> putline;
                    if);
                    current[] -> IV[];
                    (if IV.ATd[] = none then 'searchInclude:IV.ATd=none'->putline if);
                    (if IV.ATd.desc = none then 'IV.ATd.desc=none'->putline if);
                    (CS[],false) -> (IV.ATd.desc).localSearch -> (ATd[],pn);
                    (if ATd[] <> none then
                        (*'Found: ' -> puttext; CS[] -> puttext;
                         ' in %include: ' -> puttext; IV.doPT -> putline;*)
                        IV.ATd[] -> MI[]; 
                        (if not MI.MD.isAdded then
                            MI[] -> (encModule).MD.imports.add;
                            true -> MI.MD.isAdded
                        if);
                        leave search
                    if)
                 #)
            exit ATd[]
            #)
       #);
     Signature::<
       (# setUpOrigin::
            (#
            do scanSons(#do origin[] -> current.setupOrigin #);
               (if args[] <> none then
                   args.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (# 
            do (if traceCheck then
                   '*** Check signature: ' -> puttext; doPT -> putline
               if);
               (if true then 
                   (if type[] <> none then
                       (none,basicScope[],basicScope[],true) -> type.check;
                   if);
                   (if args[] <> none then
                       (none,basicScope[],basicScope[],true) -> args.check
                   if);
                   (if val[] <> none then
                       (none,basicScope[],basicScope[],true) -> val.check
                   if);
                else
                   scanSons
                   (#
                   do (none,basicScope[],basicScope[],true) -> current.check
                   #);
                   (if args[] <> none then
                       (none,basicScope[],basicScope[],true) -> args.check
                   if)
               if);
            #); 
          alloc:: 
            (# 
            do (if true then 
                   (if type[] <> none then
                       IT[] -> type.alloc;
                   if);
                   (if args[] <> none then
                       IT[] -> args.alloc
                   if);
                   (if val[] <> none then
                       IT[] -> val.alloc
                   if)
                else
                   scanSons(#do IT[] -> current.alloc #)
               if)
            #);
          search::
            (# org: ^Scope
            do (if traceSearch then
                   '>>>Signature:search: ' -> puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               (CS[],false) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (CS[],isFirst) -> (origin[]->org[]).search -> (ATd[],on,pn);
                   on + 1 -> on; (* check this *)
                else
                   (if traceSearch then '*** Found in signature' -> putline if)
               if)
            #);
          LocalSearch::
            (# 
            do (if traceSearch then
                   '>>>Signature:LocalSearch: '->puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               Loop:
                 (if args[] <> none then 
                     args.scanArgs
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if);
               Loop:
                 (if val[] <> none then
                     (*'Val: ' -> putline;
                     val.doPP -> putline;*)
                     val.scanSons
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if)
            #); 
       #);
    Arguments::<
       (# setUpOrigin:: 
            (# 
            do scanSons
               (# OG: ^ObjectGenerator
               do (if current## = ObjectGenerator## then
                      (* Foo: 
                       *    ...
                       *    %do body:< Object %with% CCC: ?char: -pattern
                       *        ...
                       *    ...
                       *    %do                 -- ObjectInvocation
                       *       S1
                       *       S2 
                       *    %with% exp
                       *       ... may be empty
                       *)
                      current[] -> OG[];
                      (* OG = Object{ S1; S2} *)
                      (if OG.isObjectDesc then
                          OG.father.father.father.father -> OG[];
                          OG.IS[] -> current.setUpOrigin
                       else (* exp above comes here *)
                          origin[] -> current.setUpOrigin
                      if)
                   else
                      origin[] -> current.setUpOrigin 
                  if)
               #)
            #);
          check:: 
            (# (* Why not argScope below? *)
            do scanArgs
               (# OG: ^ObjectGenerator
               do (*current.label -> putline;*)
                  (if current## = ObjectGenerator## then (* a virtual binding *)
                      current[] -> OG[];
                      (if OG.isObjectDesc then
                         (*'***** Virtual: ' -> putline;
                          current.doPT -> putline;
                          'Fathers: ' -> puttext;
                          current.father.label -> puttext; ' ' -> put;
                          current.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.father.label -> puttext; 
                          newline;
                          '*** Origin: ' -> putline;
                          (if current.origin[] <> none then
                              current.origin.doPT -> putline;
                              '*** origin.origin: ' -> putline;
                              current.origin.origin.doPT -> putline;
                              '*** origin: ' -> putline;
                              origin.doPt -> putline
                           else
                              ' none' -> putline
                          if)*)
                      if)
                   (* else a Decl? *)
                  if);
                  (none,basicScope[],basicScope[],true) -> current.check;
               #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);
     Value::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (#
            do scanSons(#do (none,basicScope[],basicScope[],true) -> current.check #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);          
     DataItem::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# elm::Items
            do (if traceCheck then '*** DataItem:check: ' -> puttext; doPT -> putline if);
               (none,basicScope[],argScope[],true) -> sig.check;
               (none,basicScope[],argScope[],true) -> OG.check; 
            #);
          markIfVirtualDataItem::
            (* Mark if this dataItem is qualified by a a virtual object - i.e. has the form:
             *    S: ? elm where elm:< Object
             * In this case elm may be bound to a simple value like Integer or
             * a pattern defining 'real' objects
             *)
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   (if (OG.super.ATd[] <> none) and (OG.super.ATd.isVirtualObject) then
                       true -> isVirtualObject -> value                       
               if)if)
            #);
          isVirtualObject: @ Boolean;
          alloc::
            (# fOG: ^ObjectGenerator
            do (if IT[] <> none then (* IT is none if top module *)
                   (if OG.isSimpleValue then
                       IT.vsize + 1 -> IT.vsize -> off
                    else
                       IT.rsize + 1 -> IT.rsize -> off
               if)if);
               IT[] -> sig.alloc;
               IT[] -> OG.alloc
            #);          
          desc::
            (# elm:: scope
            do (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
          isSimpleValue: booleanValue(# do OG.isSimpleValue -> value #);
          hasCode:: 
            (* perhaps not suffcient!
             *   S: @T -- hasCode if T hasCode
             *   S: @T{ ... } -- hasCode if T hasCode or main.hasCode
             *   I: @integer --- no code
             *)
            (# 
            do (*OG.hasCode -> value *)
            #);
       #);
     Pattern::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin;
               sig[] -> OD.sig[];
               origin[] -> OD.setupOrigin;
            #);
          isPatternDecl:: TrueValue;
          isVirtual:: (#do ptnKind <> PlainPtn -> value #);
          isVirtualObject::
            (#
            do (if isVirtual then
                   (if not OD.isObjectDesc then
                       OD.super.primNo = object_prim -> value
                   if)
               if)
            #);
          vDcl: ^Decl; 
          check::< 
            (# elm:: Items;
               setImplSuper:
                 (* Perhaps a misleading name:
                  * For any pattern: final or further, we search for a virtual
                  * declaration in super - and we need to get the off for this virtual
                  * Then we test if super for this FinalPtn is implicit
                  * In qAbstractSyntaxTree::decl:checkVirtualArgs,
                  * we do an almost identical check for virtual arguments
                  * We should unify ...
                  *)
                 (# VP: ^Pattern; (* not always the case ??*)
                    
                    pn: @integer
                 do (*'FinalPtn:check:setImplSuper:'->puttext; doPT -> putline;*)
                    (if ptnKind // FinalPtn // furtherPtn then
                        (sig.id[],false) -> basicScope.superDesc.localSearch -> (vDcl[],pn);
                        (if vDcl[] <> none then
                            (*'Found vDcl: ' -> puttext; vDcl.sig.dopt -> puttext;*)
                            (* OBS! in V:: A { } isImplSuper should not be true
                             * Only for  V:: { }
                             *)
                            vDcl[] -> VP[];(* -> OD.super.ATd[];*)
                            (* ' pn:' -> puttext; pn -> putint; 
                             ' off:' -> puttext; off -> putint; ' ' -> put; *)
                            (if OD.super.isEmpty then
                                VP[] -> OD.super.ATd[];
                                pn + 1 -> OD.super.pn;
                                true -> OD.super.isImplSuper;
                                (*' isImplSuper=T '-> puttext;*)
                            if);
                            (if VP.OD.hasItems (*not VP.OD.IS.isEmpty*) then
                                true -> OD.super.isSingularImplSuper;
                                (*' isSingularImplSuper=T ' -> puttext; *)
                             else
                                (*' isCategoryImplSuper: ' -> puttext*)
                            if);
                            (*vDcl.sig.doPT -> putline*)
                         else
                            '\n!!! No virtual declaration in super for: ' -> puttext;
                            sig.doPT -> putline;
                        if);
                        (if OD.IS.isEmpty then
                            newDesc -> OD.vDescNo;
                            (* '*** non-singular binding: ' -> puttext; 
                            OD.vDescNo -> putint; ' ' -> put;
                            doPT -> putline;*)
                        if);
                    (* else
                        'No virtual PnKind:' -> puttext;  ptnKind -> putint; newline*)
                    if)
                 #);

            do (if traceCheck then  
                   '*** Check ptn: ' -> puttext; sig.id[] -> putline if);
               setImplSuper;
               (* Must check sig before OD;
                * Items in OD may refer Decl's in sig
                * Allocation of storage for sig must be in OD.IS
                * Scope for Decl's in sig must be basicScope
                *)
               (none,OD.IS[],OD.IS[],true) -> sig.check; 
               (none,basicScope[],basicScope[],true) -> OD.check;
               (if traceGeneric then
                   OD.IS.scanAllDecls
                   (# D: ^Decl
                   do (if currentDcl.isVirtualObject then
                          'Virtual Object: ' -> puttext; 
                          currentDcl.doPt -> putline;                          
                      if)
               #)if);
               inner;
            #);
          isInner::
            (* Perhaps ad hoc!? -- from old code: inner
             * check BKWptn: %inner P
             *)
            (# A: ^ObjectGenerator; org: ^Items
            do (if OD.primNo = inner_prim then
                   basicScope[] -> org[];
                   args.scanArgs
                   (# A: ^ObjectGenerator
                   do current[] -> A[];
                      A.super.on - 1 
                        -> (args.origin[]->org[]).toOrigin -> org[]; 
                   #);
                   org.noOfInner + 1 -> org.noOfinner;
                   (if org.noOfInner = 1 then 
                       org.dsize + 1 
                         -> org.dsize 
                         -> org.innerInx 
                   if);
               if)
            #);     
          alloc::< 
            (# add:
                 (# enclosingOG: ^ObjectGenerator; ptn: ^pattern; F: ^Node
                 do father.father[] -> F[];
                    (if F##
                     // ObjectGenerator## then
                        (* 'ObjectGenerator: ' -> putline;
                         F.dopt->putline;*)
                        (this(Pattern)[], OD[]) -> (F[]-> enclosingOG[]).addBinding
                     // Signature## then
                        (*'Signature: ' -> putline; F.father.doPT -> putline;
                         F.father.label -> putline;*)
                        (this(Pattern)[], OD[]) -> (F.father[]-> ptn[]).OD.addBinding
                     else                           
                        'Koks'->putline;
                        father.father.label -> putline
                    if)
                 #);
            do (* '*** Ptn:alloc: ' -> puttext; sig.doPT -> putline;*)
               IT[] -> OD.alloc;
               (if ptnKind 
                // virtualPtn then 
                   (*'Virtual ptn: ' -> putline; sig.doPT -> putline;*)
                   IT.dsize + 1-> IT.dsize -> off;
                   add
                // furtherPtn // finalPtn then
                   (*'Virtual bind: ' -> putline; sig.doPT -> putline;*)
                   (*OD.super.ATd.off -> off;*)
                   vDcl.off -> off;
                   add
               if);
               inner 
            #);
          handleArgs::
            (# args: [6]^ObjectGenerator; top: @integer;
               enclosingOG: ^ObjectGenerator
            do (* 'HandleArgs: ' -> putline; dopt-> putline; 
                * E.doPT -> putline; '--' -> putline; 
                *)
               (if E.args[] = none then leave handleArgs if);
               E.args.scanArgs
               (#
               do (if (top+1 -> top) > args.range then 
                      args.range -> args.extend 
                  if);
                  current[] -> args[top][];
                  (*'ActualArg: ' -> puttext; current.dopt -> putline*)
               #);
               (if top = 0 then leave handleArgs if);
               
               (if sig[] = none then leave handleArgs if);
               sig.scanArgs
               (# D: ^Decl; i: @ integer; Ex: ^Exp; 
                  OI: ^ObjectInvocation; descNo: @integer
               do  i + 1 -> i;
                  (*'Arg: ' -> puttext; currentArg.doPT -> putline;*)
                  currentArg[] -> D[];
                  handleVirtArg:
                    (if D.isVirtual then
                        none -> Ex[];
                        L:
                          args[i].super.scanSons(# do current[] -> Ex[]; leave L #);
                        (if (Ex[] <> none) and (Ex## = ObjectInvocation##) then
                            (* 'Try: ' -> puttext; Ex.label -> putline; 
                            * Ex.doPP -> putline;  
                            * args[i].doPP -> putline;
                            *)
                            Ex[] -> OI[];
                            (if args[i].IS.isEmpty then
                                newDesc -> args[i].vDescNo;
                                true -> args[i].isVirtualArg;;
                               (* '*** non-singular argument binding: ' -> puttext; 
                                args[i].vDescNo -> putint; ' ' -> put;
                                args[i].doPT -> putline;*)
                            if);
                                
                            (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                (* 'Got ptn id: ' -> puttext; 
                                 * OI.ptnId.doPT -> puttext;
                                 *)
                                (args[i].desc).descNo -> descNo; 
                                (* ' descNo: ' -> puttext; 
                                 descNo -> putint; ' ' ->put;
                                 OI.ATd.primNo -> putint; newline;
                                 *)
                                (D[], args[i][])
                                  -> (E.father.father[]-> enclosingOG[])
                                .addBinding;
                                leave handleVirtArg
                            if);
                            (if (E.desc).primNo = indexed_prim then 
                                (* We ignore bindings of elm in Indexed *)
                                leave handleVirtArg
                             else
                                (if OI.ATd.(*args[i].*)primNo = integer_prim then
                                    '\n*** Virtual bound to integer in\n\n\t'->puttext;
                                    E.doPT -> putline;
                                    '\n    is ignored by the compiler\n' -> putline;
                                    leave handleVirtArg
                                if);
                            if);
                            (D[], args[i][]) 
                              -> (E.father.father[]-> enclosingOG[]).addBinding;
                         else
                            (* 'Not OG: ' -> putline; args[i].doPT -> putline*)
                            (D[], args[i][]) 
                              -> (E.father.father[]-> enclosingOG[]).addBinding;
                        if)
                    if)
               #)
            #);
          desc::<
            (# elm:: items
            do (*(if not isChecked and not beingChecked then 
                   '!!! ' -> puttext; sig.doPT -> putline;
                   '** Not checked: ' -> putline;
                   doPT -> putline;
                   (none,origin[],origin[],true) -> check;
               if);*)
               (if not OD.hasItems (*OD.IS.isEmpty*) then
                   (* V: < A, V::< B, or V:: C *)
                   OD.super.desc -> D[]
                else
                   OD.IS[] -> D[]
               if);
               inner;
            #);
          variants: ^Variant;
          isRecursive: @boolean;
          entity:: (#do OD.entity -> E[] #);
          skind:: (# do ': ' -> S[] #);
          getEntries:: (# do OD.getEntries -> (names[],entries[]) #);
          objDescEQ:: (# do DN -> OD.objDescEQ -> value #);
       #);
     
     ObjectGenerator::<
       (# setUpOrigin::
            (#
            do origin[] -> super.setUpOrigin;                    
               origin[] -> IS.setUpOrigin;
               this(ObjectGenerator)[] -> IS.OT[];
               sig[] -> IS.sig[];
            #); 
          check::
            (#
            do (if traceCheck then
                   '*** Check ObjectGenerator:' -> puttext; 
                   doPT -> putline if);
               (if super.ATd[] = none then 
                   (* else implict super that has been setUp*)
                   (if isSingular then
                       (* A singular statement:
                        *     bar(a,...) { ... }
                        * isObjectDesc: IS not empty or has virtual arguments
                        * else: just a pattern invocation
                        * Note! isObjectDesc is not defined before super.check 
                        *       has been executed
                        *)
                       (none,basicScope[],basicScope[],true) -> super.check;
                    else
                       (* A pattern:
                        *     foo(a: ?int, ...): bar(a, ...){ ... } 
                        * where
                        *     super = bar(a,...) 
                        *)
                       (none,basicScope[],sig[],true) -> super.check
                   if);                   
               if);      
               (if isObjectDesc then
                   this(ObjectGenerator)[] -> newDesc -> IS.descNo
               if);
               (origin[],super[],super.hasVirtualArgs) -> IS.checkItems;
            #);
          isSimpleValue: BooleanValue
            (* ObjectGeneration in (the rightside)
             * C: = integer(12)   -- refer to pattern integer
             * C: = 12
             * C: = a + b         -- pattern +
             * C: = foo(e1,e2,e3) -- pattern foo
             * C: = X             -- data-item X
             * V: ? a + b         -- and simialr for variable
             * V:= foo(e1,e2,e3)  -- and assignment
             * And they may be singular
             * 1:   OG - non-singular
             * 1.1  OG - integer, boolean, char ==> true
             * 1.2     - else get possible return value
             * 2:   {...} - singular, no super
             * 2.1        - primno = integer, char, boolean
             * 3:   OG{...} - singular with super
             * 3.1          -- return value of OG
             * 3.2          -- OG not simpleValue?
             *)
            (# q: ^ObjectGenerator; pNo: @integer
            do (* '*** isImpleValue: ' -> puttext; primNo -> putint; newline;
               doPT -> putline;
               '>>> super:qual:'->putline;
               (if (super.getQual -> q[]) = none then 'none' -> putline
                else
                   q.doPT -> putline;
                if);*)
               (if (super.getQual -> q[]) <> none then
                   q.primNo -> pNo
                else
                   primNo -> pNo
               if);
               (if pNo
                // integer_prim
                // char_prim
                // boolean_prim  then
                   true -> value
               if)
            #);
          isObjectDesc: booleanValue
            (* this can be a singular or pattern defined ObjectDesc:
             *    IS.hasItems
             * It can also be an ObjectInvocation with virtual arguments
             *     super.hasVirtualArguments
             * that has to treated as an ObjectDesc
             * And super is not a basic pattern
             *     not super.isBasic
             *)
            (#
            do hasItems or (super.hasVirtualArgs and not super.isBasic)
               -> value
            #);   
          isObject: booleanValue(# do primNo = object_prim -> value #);
          alloc::
            (# E:^Exp
            do IT[] -> super.alloc;
               addBinding.copySuper;
               super.scanSons(# do current[] -> E[] #);
               (if (E[] <> none) and (E.ATd[] <> none) then 
                   E[] -> E.ATd.handleArgs 
               if);
               (if isObjectDesc then
                   IT[] -> IS.alloc 
               if);
               (if traceGeneric2 then
                   addBinding.display
               if);
               addBinding.checkForVirtualObject;
               addBinding.checkSuperVariant
            #);
          hasCode:: (# do true -> value #);
          hasVirtualObject: @boolean;
          vDescNo: @integer;
          isVirtualArg: @boolean; (* as in foo(...,#bar,...) *)
          addBB::
            (# VD: ^Pattern; E: ^ObjectGenerator;
               vDecl: [2] ^Pattern;
               bindingType: [2] @integer; (* 0: inner; 1: ref; 2: value *)
               bindings: [2] ^ObjectGenerator;
               vTop: @integer;
               objectRefs: [2] ^Decl; rTop: @integer;
               scanBindings:
                 (# currentVdecl: ^Pattern; 
                    currentBindingType: @integer;
                    currentBinding: ^ObjectGenerator;
                    inx: @integer
                 do (for i: vTop repeat
                         i -> inx;
                         vDecl[i][] -> currentVdecl[];
                         bindingType[i] -> currentBindingType;
                         bindings[i][] -> currentBinding[];
                         inner
                    for)
                 #);
               scanObjectRefs:
                 (# current: ^Decl
                 do (for i: rTop repeat
                         objectRefs[i][] -> current[];
                         inner
                    for)
                 #);
               copySuper:
                 (# ptn: ^Pattern
                 do (if (super[] <> none) and (super.ATd[] <> none) then
                        (if super.ATd## <> pattern## then 
                            (* A unary exp like XXX where XXX is a data-item
                             * is syntactically an ObjectGenerator
                             * with XXX as super and empty main-part
                             *);
                            leave copySuper
                        if);
                        super.ATd[] -> ptn[];

                        (* 'copySuper:' ->putline; dopt->putline; 
                         *  ptn.OD.addBinding.display; *)
                        (for i: ptn.OD.addBinding.vTop repeat 
                             (*ptn.OD.addBinding.offSets[i] -> putint; ' '-> put;
                              ptn.OD.addBinding.bindingType[i] -> putint; 
                              * newline;
                             (if ptn.OD.addBinding.bindings[i][] <> none then
                                 ptn.OD.addBinding.bindings[i].dopt -> putline;
                              else
                                 'none' -> putline
                             if);*)
                             (if ptn.OD.addBinding.vDecl[i][] <> none then
                                 (ptn.OD.addBinding.vDecl[i][]
                                 ,ptn.OD.addBinding.bindings[i][]) 
                                   -> addBinding
                                 (*else = 0: inner *)
                             if)
                        for);
                        scanObjectRefs(# do current[] -> addObjRef #)
                    if)
                 #);
               addObjRef:
                 (# objRef: ^DataItem
                 enter objRef[]
                 do (if (rTop + 1 -> rTop) > objectRefs.range then
                        objectRefs.range -> objectRefs.extend 
                    if);
                    objRef[] -> objectRefs[rTop][];
                    true -> hasVirtualObject
                 #);
               checkSuperVariant:
                 (# ptn: ^Pattern
                 do (if (super[] <> none) and (super.ATd[] <> none) and (super.ATd## = pattern##) then 
                        super.ATd[] -> ptn[];
                        ptn.OD.addBinding.scanBindings
                        (# head: @boolean
                        do (if (currentBinding[] <> none) then
                               (if (currentBinding.isObject) then
                                   (if not head then
                                       (if traceGeneric2 then
                                           '*** Variant: ' -> putline;
                                           doPT -> putline;
                                       if);
                                       true -> head
                                   if);
                                   (if traceGeneric2 then
                                       currentBinding.doPT -> putline;
                                       bindings[inx].doPT -> putline;
                                       bindingType[inx] -> type;
                                       newline
                                   if)
                               if)                            
                            else
                               'currentBinding is none' -> putline;
                               dopt -> putline
                           if)
                        #);
                    if)
                 #);
               checkForVirtualObject:
                 (#
                 do L:
                      (for i: vTop repeat
                           (if bindings[i][] <> none then
                               (if bindings[i].primNo = object_prim then
                                   true -> hasVirtualObject;
                                   (if traceGeneric2 then
                                       '***** HasVirtualObject: ' -> putline; 
                                       (if sig[] <> none then 
                                           sig.doPT -> putline;
                                        else
                                           doPT -> putline;
                                           display
                                   if)if);
                                   leave L
                      if)if)for);
                    checkDataItemAsVirtualObject
                 #);
               checkDataItemAsVirtualObject:
                 (# isVirtualObject: 
                      (# D: ^Decl
                      enter D[]
                      do (if IS[] -> D.markIfVirtualDataItem then
                             (if traceGeneric2 then
                                 'Virtual DataItem: ' -> puttext; D.doPT -> putline;
                             if);
                             D[] -> addBinding.addObjRef
                         if)
                      #);
                 do (if sig[] <> none then
                        sig.scanArgs(# do currentArg[] -> isVirtualObject #)
                    if);
                    IS.scanSons
                    (# I: ^Item
                    do current[] -> I[];
                       (if I.isDecl then
                           I[] -> isVirtualObject 
                    if)#)
                 #);
               valueOrObject::
                 (#
                 do '***** ObjectGenerator:ValueOrObject:'->putline;
                    dopt -> putline;
                    display;
                    (for i: vTop repeat
                         (if vDecl[i][] = ptn[] then
                             'bound to: ' -> puttext;
                             bindingType[i] -> type; newline;
                             bindings[i].dopt -> putline;
                             bindingType[i] -> value
                         if)
                    for);
                    (for i: rTop repeat
                         'Decl: ' -> puttext;
                         objectRefs[i].dopt -> putline
                    for)
                 #);
               type:
                 (# T: @integer
                 enter T
                 do  (if T
                      // 0 then ' inner: ' -> puttext;
                      // 1 then ' ref: ' -> putline
                      // 2 then ' value: ' -> putline;
                      else 
                         '  ???' -> putline
                     if);
                 #);
               display:
                 (# T: ^Text
                 enter T[]
                 do (if vTop > 0 then
                        T[] -> puttext; 
                        '*** Bindings: descNo: ' -> puttext; 
                        IS.descNo -> putint; newline;
                        (for i: vTop repeat
                             i -> putint; ':' -> put;
                             vDecl[i].doPT -> putline;
                             vDecl[i].off -> putint; ':'->put;
                             bindingType[i] -> type;
                             (if bindings[i][] <> none then
                                 bindings[i].doPT -> putline
                              else 
                                 'none'->putline
                             if)
                    for)if)
                 #)      
            enter(VD[],E[])
            do (if handleGeneric then
                   (if VD.off > vTop then
                       VD.off - bindings.range + 2-> bindings.extend;
                       VD.off - bindingType.range + 2-> bindingType.extend;
                       VD.off - vDecl.range + 2 -> vDecl.extend;
                   if);
                   (if VD.off > vTop then VD.off -> vTop if);
                   VD[] -> vDecl[VD.off][];
                   (*'Add:' -> puttext; E.doPT -> puttext; 
                    ' ' -> put; off -> putint;
                    ' ' -> put; E.primNo -> putint; newline;
                    *)
                   (*(if false and (BindingType[off] > 0) then
                       '---addbinding:overwrite: ' -> puttext;
                       off -> putint; ' ' -> put; E.doPt -> putline;
                       '   was: ' -> puttext;
                       bindingType[off] -> putint; ' ' -> put;
                       bindings[off].dopt -> putline;
                       
                   if);*)
                   (if E.primNo // integer_prim then 
                       (* '--value--'->putline;*)
                       2 -> bindingType[VD.off]
                    else 
                       1 -> bindingType[VD.off]
                   if);
                   E[] -> bindings[VD.off][];
               if);
            #);
          getNameForOff::
            (#do (attOff,descNo,isRef,isIndexed) -> IS.getNameForOff -> NM[] #);
          getDescNo:: 
            (# ptn: ^Pattern
            do (if (IS.descNo -> dNo) = 0 then
                   (* Virtual bindings like DD in V ::< DD *)
                   (if (super[] <> none) and (super.ATd[] <> none) then
                       super.ATd[] -> ptn[];
                       ptn.OD.getDescNo -> dNo
               if)if)
            #);
          objDescEq:: (# do DN -> IS.objDescEq -> value #);
       #);
     Invocation::<
       (# setupOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (if traceCheck then
                   '*** Invocation:check: ' -> puttext; doPT -> putline 
               if);
               (* basicScope.doP -> putline;
               argscope.doP -> putline;*)
               scanSons
               (# E: ^Exp; i: @integer
               do i + 1 -> i;
                  (rec[],basicScope[],argScope[],isFirst) 
                    -> current.check -> basicScope[];
                  false -> isFirst;
                  current[] -> rec[];
                  (if isLast then
                      (* can be Exp with args or just a pattern name (#foo) *)
                      current[] -> E[]; (* use rec *)
                      E.ATd[] -> ATd[];
                      E.on -> on;
                      i -> lgth;
                   else
                      (* current must be Exp incl. possible argument *)
                  if)
               #)
            #);
          incrOn:
            (#
            do '***** incrOn: ' -> putline; doPT -> putline;
               scanSubTree
               (# doIt::
                    (# AP: ^Apl
                    do (if current## <= Apl## then
                           current.doPT -> putline;
                           current[] -> AP[];
                           AP.on + 1 -> AP.on;
                           AP.doPT -> putline;
                       if);
               #)#)
            #);
          alloc:: (# do scanSons(# do IT[] -> current.alloc #)#);
       #);
     ObjectInvocation::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> ptnId.setUpOrigin; 
               origin[] -> args.setUpOrigin
            #);
          check::
            (# elm:: scope; org: ^Items
            do (if traceCheck then
                   '*** ObjectInvocation:check: ' -> puttext; ptnId.T[] -> putline if);
               (* ' :scope: ' -> puttext; basicScope.doPT ->putline;*)
               (if basicScope[] <> none then (* ad hoc *)
                   (if traceSearch then
                       '>>>ObjectInvocation:search: ' -> puttext;
                       ptnId.T[] -> putline
                   if);
                   (if (1 -> ptnId.T.inxGet) = '#' then
                       ((2,ptnId.T.length) -> ptnId.T.sub,isFirst) 
                         -> basicScope.search -> (ATd[],on,pn);
                    else
                       (ptnId.T[],isFirst) 
                         -> basicScope.search -> (ATd[],on,pn);
                   if);
                   (if ATd[] <> none then 
                       on -> ptnId.on; (* just for debugging *)
                       (ptnId.T[],on,ATd[]) -> found;
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find a declaration of: "'-> msg;
                          ptnId.T[] -> msg;
                          '"' -> msg;
                       #);
                       errorDecl[] -> ATd[]
                   if);
                   
                   this(Exp)[] -> ATd.checkVirtualArgs;
                   
                   (if ATd.primNo 
                    // this_prim then
                       (* ad hoc - must be fixed *)
                       (# A: ^Item
                       do args.scanArgs(# do current[] -> A[] #);
                          (none,argScope[],argScope[],true) -> A.check;
                          A.desc -> basicScope[];
                       #);
                       leave check  
                   if);
                   (args[],argScope[]) -> argBuf.add;
                   
                   (* ok if static/dynamicObject - what does this mean?
                    * If pattern, scope is the desc of the return value
                    * ATd.desc <> none is before we used getQual - can be eliminated
                    *)
                   (if ATd[] = thisCoreDecl[] then (* perhaps move to getQual!?*)
                       coreDecl.desc -> basicScope[]
                    else
                       (if (ATd.getqual <> none) then
                           (ATd.getQual).IS -> basicScope[];
                        else
                           'getQual:none:' -> puttext; ATd.doPT -> putline
                       if)
                   if)
                else
                   'Variable:check: scope is none: '->puttext; dopt -> putline
               if)
            #);
          alloc:: 
            (#
            do (if ATd[] = none then 
                   'ATd is none: '->puttext; label -> puttext; ' ' -> put;
                   father.label -> puttext; ' ' -> put;
                   father.father.label -> puttext; ' ' -> put;
                   ' Father.father: ' -> putline;
                   father.father.doPT-> putline; 
               if);               
               (IT[],args[]) -> ATd.isInner ;
               scanSons(#do IT[] -> current.alloc #);
               (*'handleArgs'->puttext; dopt->putline;*)
               (* this(Exp)[] -> ATd.handleArgs *)
            #);
       #);
     BracketedExp::<
       (# setUpOrigin:: (# do origin[] -> IV.setUpOrigin #);
          check:: 
            (# 
            do (rec[],basicScope[],argScope[],isFirst) -> IV.check -> basicScope[];
               IV.ATd[] -> ATd[];
               IV.on -> on
            #);
          alloc:: (# do IT[] -> IV.alloc #)
       #);
     const::<
       (# check:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     charObj::<
       (# check:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     stringObj::<
       (# check:: (# do stringDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     Variant:
       (* An object representing different variants of a pattern with
        * virtual patterns qualified by Object as in
        *    foo(...,V:< Object, ...):
        *       W:< Object
        *       ...
        * V and W may be bound to simple values such as Integer 
        * or patterns as in 
        *    foo(...,#Record,...)
        *       W::< #Integer
        *       ...
        * In this case there may be 4 combinations of Value (V) or Reference (R)
        *    [R,R], [R,V], [V,R], [V,V]
        * Different code must be generated for Foo for each variant 
        *)
       (# vDecl: [2] ^Pattern; (* virtual decls of the form V:< Object *)
          type: [2] @ boolean; (* false: value, true: reference *)
          top: @integer;
          add:
            (# VD: ^Pattern;
               T: @integer
            enter(VD[],T)
            do
            #)
       #);
     found:
       (# id: ^text; on: @integer; ATd: ^Decl
       enter(id[],on,ATd[])
       do (if traceSearch then
              '***** Found: ' -> puttext; id[] -> puttext; 
              ' on: ' -> puttext; on -> putint;
              (if ATd[] <> none then
                  ' Decl: ' -> puttext; ATd.sig.doPT -> putline
               else 
                  newline
          if)if)
       #);
     argBuf:  @
       (# argElm:
            (# #);
          add:
            (# A: ^Arguments; S: ^Scope; next: ^add
            enter(A[],S[])
            do (if head[] = none then
                   this(add)[] -> head[] -> last[]
                else
                   this(add)[] -> last.next[] -> last[]
               if)
            #);
          head,last: ^add;
          check:
            (# H: ^Add;
            do head[] -> H[];
               none -> head[] -> last[];
               Loop: 
                 (if H[] <> none then
                     (none,H.S[],H.S[],true)  -> H.A.check;
                     H.next[] -> H[];
                     restart Loop
                 if);
               (if head[] <> none then restart check if)
            #)          
          
       #);
     
     getObjectDesc:: 
       (# OD: ^ObjectGenerator
       do descNo -> newDesc.getOD -> OD[];
          OD.IS[] -> D[] 
       #);
     
     newDesc: @
       (# OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;
          getOD: 
            (* only used from minienv *)
            (# descNo: @integer; anODx: ^ObjectGenerator
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     notification: 
       (#  msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          n: ^TopNode;
          thisModule: ^module;          
          printHeading:< (# do '\n' -> puttext;inner #);
          printLines:
            (# first,last,p: @integer; ch: @char; Lines: ^Text;
            do true -> (n.theModule).doPT -> Lines[];
               n.beginPos -> p;
               L:
                 (if (first < 4) and (p > 1) then
                     p - 1 -> p;
                     (if  (p -> Lines.inxGet) = ascii.newline then 
                         first + 1 -> first if);
                     restart L
                 if);
               L:
                 (if (0 < p) and ((p <= n.endpos) or (ch <> ascii.newline))
                     and (p <=Lines.length) then
                     Lines.T[p] -> ch -> put;
                     p + 1 -> p;
                     restart L
                 if);
               newline;
            #);         
          report:< BooleanValue(#do inner #);
       enter n[] 
       do (*n.theModule -> errorModule[];*)
          (if report then
              (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
              (if not withPos then 
                  printHeading;
                  ' in module: "' -> puttext; 
                  (if n.theModule <> none then                  
                      (n.theModule->thisModule[]).DI.sig.doPT -> puttext; 
                      '"' -> put; newline;
                      printLines;;
                      (*n.father.doPT -> putline*)
                   else
                      'n.theModule = none"'->putline
                  if);
                  '**** ' -> puttext;
                  &text[] -> lex.errorStream[]
              if);
          
              (if withPos then
                  n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                    -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;
                  n.endPos -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;          
              if);
              INNER;              
              lex.errorStream.newline;
              (if not withPos then
                  lex.errorStream[] -> putline
              if);
          if)
       #);
     SemanticError: Notification
       (# report:: (# do reportSemErr -> value #);
          printHeading::
            (#
            do 'Semantic error' -> puttext;
            #);
       do INNER;
          true -> semanticErrors
       #);
     QuaCheck: Notification
       (# report:: (# do reportQuaCheck -> value #);
          printHeading:: 
            (# 
            do 'Run-time check needed' -> puttext
            #)
       do (if reportQuaCheck then inner if)
       #);
     semanticErrors: @boolean;
  do '**** CHECKER ****' -> putline;
     0 -> newDesc.noOfDescs; (* needed when exe from minienv
                              * we must find a way to compile changed modules
                              * currently we compile all modules
                              *)
     false -> semanticErrors;
     (*true -> traceCheck;*)
     (*true -> traceSearch;*)
     
     rootModule.setUpOrigin;
     
     rootModule.check;
     (none,main.origin[],main.origin[],true) -> main.check;
     argBuf.check;
     (*main.doPP -> putline;*)
     '**** ALLOC     ****'->putline;
     rootModule.alloc;
     (*main.doPT -> putline;*)

     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline
      else
         inner
     if)
  #)
