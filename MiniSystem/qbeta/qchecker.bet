ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
(*INCLUDE 'Primitives';*)
---lib:attributes---
checker: Parser
  (# Module::<
       (# setUpOrigin:: (# do origin[] -> SO.setUpOrigin #);
          check::
            (#
            do scope[] -> SO.check;
            #);
          desc:: (#do SO.desc -> D[] #);
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do(* 'Check ModuleItem: ' -> puttext; sig.doPT -> putline;*)
               scope[] -> MD.check 
            #);
          desc:: (# do MD.desc -> D[] #)
       #);
     Items::<
       (# setUpOrigin::
            (# 
            do scanSons(# do this(Items)[] -> current.setupOrigin #);
               (if props[] <> none then
                   this(Items)[] -> props.setUpOrigin
               if);
            #);
          check::
            (# 
            do this(items)[] -> scope[];
               rsize + 1 -> rsize -> originOff; (* origin, but depends on super*)
               scanSons(# do scope[] -> current.check #)
            #); 
          vsize, rsize,originOff: @integer;
       #);
     Properties::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check:: (# #);
       #);
     Property::<
       (# setupOrigin::
            (# 
            do origin[] -> P.setupOrigin;
               (if arg[] <> none then origin[] -> arg.setupOrigin if)
            #);
       #);
     Include::
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (*'Check include:' -> puttext; doPT -> putline;*)
               (* scope.doPT -> putline;*)
               scope.origin[] -> scope[];
               scanSons(# do scope[] -> current.check #)#);
       #);
     Signature::<
       (# setUpOrigin::
            (#
            do scanSons(#do origin[] -> current.setupOrigin #);
               (if args[] <> none then
                   args.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (# 
            do scanSons(#do scope[] -> current.check#)
            #); 
       #);
     Arguments::<
       (# setUpOrigin:: 
            (# do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check:: (# do scanSons(# do scope[] -> current.check #) #);
       #);
     Value::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (#
            do scanSons(#do scope[] -> current.check #)
            #)
       #);          
     StaticObject::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# elm::Items
            do scope[] -> sig.check;
               scope[] -> OG.check; 
               (if scope[] <> none then
                   (* origin is none if StaticObject is a Module *)
                   (* origin is wrong here
                    * foo:
                    *    X: @integer -- in foo (origin)
                    *    max(a: @integer -- in max):
                    *       b: @integer -- in max
                    *)
                   (*origin[] -> scope[]; *)
                   (*'\n** ST:check: ' -> puttext; dopt -> putline;*)
                   (if OG.isBasic then
                       scope.vsize + 1 -> scope.vsize -> off
                    else
                       scope.rsize + 1 -> scope.rsize -> off
                   if)
               if);
            #);
          desc::
            (# elm:: Items
            do (*'StaticObject:desc:'->puttext; doPT -> putline;*)
               (if OG.IS.isEmpty then 
                   OG.IV.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
       #);
     DynamicObject::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> PI.setUpOrigin
            #);
          check::
            (# elm:: Items
            do (* newline;
               doPT -> putline;
               scope.doPt -> putline;*)
               scope[] -> PI.check;
               (if origin[] <> none then 
                   (*origin.doPT -> putline;*)
                   (* origin is none if StaticObject is a Module *)
                   (*origin[] -> scope[];*)
                   scope.rsize + 1 -> scope.rsize -> off;
                else
                   'Origin is none' -> putline
               if);
            #);
          desc::
            (# elm:: Items
            do (*'DO:desc:'->puttext; doPT -> putline;*)
               (if PI.ATd[] <> none then
                   PI.desc -> D[]
               if);
            #);
       #);
     (*Pattern - see yAbstractSyntaxTree *)
     ObjectGeneration::<
       (# setUpOrigin::
            (#
            do (if IS.isEmpty then
                   origin[] -> IV.setUpOrigin;
                   origin[] -> IS.setUpOrigin
                else     
                   (* '\nOG:SetUpOrigin:using: ' -> putline;
                    * this(objectTemplate).dopt ->putline;
                    * '---'->putline;
                    *)
                  (* this(ObjectTemplate)[] -> IV.setUpOrigin;
                   this(ObjectTemplate)[] -> IS.setUpOrigin;*)
                   origin[] -> IV.setUpOrigin;
                   origin[] -> IS.setUpOrigin;
               if);
               this(objectTemplate)[] -> IS.OT[];
            #); 
          check::
            (#
            do (if not IS.isEmpty then
                   this(ObjectTemplate)[] -> newDesc -> IS.descNo;
               if);
               origin[] -> IV.check; (* scope? And belwo?*)
               origin[] -> IS.check
            #);
       #);
     PatternId::<
       (# setUpOrigin:: (# do origin[] -> IV.setUpOrigin #);
          check:: 
            (# elm:: Items; on: @integer
            do (if true then
                   (* newline: IV.dopt->putline; *)
                   scope[] -> IV.check -> scope[];
                   IV.ATd[] -> ATd[];
                else
                   (if (id[] <> none) and (id.length > 0) then
                       scope[] -> IV.check -> scope[];
                       id[] -> scope.search -> (ATd[],on);
                       (if ATd[] <> none then
                           '*** Found patternId: ' -> puttext; id[] -> puttext;
                            ' on=' -> puttext; on -> putint; newline
                        else
                           '*** Did not find  patternId: ' -> puttext; id[] -> putline;
                           father.doPT -> putline;
                           Decl -> ATd[]
                   if)if)
               if)
            #)
       #);
     ObjectDesc::<
       (# setUpOrigin::
            (#
            do origin[] -> superPI.setUpOrigin;
              (* this(ObjectTemplate)[] -> IS.setUpOrigin*)
               origin[] -> IS.setUpOrigin;
               this(objectTemplate)[] -> IS.OT[];
            #);
          check:: 
            (# 
            do 
               this(ObjectTemplate)[] -> newDesc -> IS.descNo;
               (if superPI[] <> none then scope[] -> superPI.check if);
               origin[] -> IS.check
            #);
       #);
     Invocation::<
       (# setupOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (*'Invocation:check: ' -> puttext; *)
               scanSons
               (# E: ^Exp
               do (*'I: '->puttext; current.dopt -> putline;*)
                  scope[] -> current.check -> scope[];
                  (if isLast then
                      current[] -> E[];
                      E.ATd[] -> ATd[];
                  if)
               #)
            #)
       #);
     Unary::<
       (# setUpOrigin:: (# do origin[] -> M.setUpOrigin #);
          check::
            (# elm:: Items
            do (*'Search: ' -> puttext; M.T[] -> putline;
               ': Variable: ' -> puttext; scope.dopt ->putline;*)
               
               (if scope[] <> none then (* ad hoc *)
                   M.T[] -> scope.search -> (ATd[],on);
                   (if ATd[] <> none then
                       '*** Found var: '->puttext; M.T[] -> puttext;
                       ' on=' ->puttext; on -> putint; newline
                    else
                       '*** Did NOT find var: '->puttext; M.T[] -> putline;
                       Decl -> ATd[]
                   if);
                   (if (ATd[] <> none) and (ATd.desc <> none) then 
                       ATd.desc -> scope[]
                   if)
                else
                   'Variable:check: scope is none: '->puttext; dopt -> putline
               if)
            #);
          (*desc:: (# do ATd.desc -> D[] #) To be fixed! *)
       #);
     Binary::<
       (# setUpOrigin::
            (# 
            do origin[] -> operator.setUpOrigin;
               origin[] -> argument.setUpOrigin 
            #);
          check:: 
            (# elm:: Items
            do (* 'Binary: '-> puttext; operator.T[] -> putline;*)
               (if scope[] <> none then (* ad hoc *)
                   (*scope[] -> rec.check -> scope[];*)
                   operator.T[] -> scope.search -> (ATd[],on);
                   (if ATd[] <> none then
                       '*** Found binary: '->puttext; 
                       operator.T[] -> puttext; 
                       ' on=' -> puttext; on -> putint; newline
                    else
                       (if ':=' -> operator.T.equal then 
                           true -> isAssign;
                           '*** Found := (assign)' -> putline;
                        else
                           '*** Did NOT find binary: '->puttext; 
                           operator.T[] -> putline;
                           Decl -> ATd[]
                       if)
                   if)
                 else                    
                    'binary:check:org none ' -> putline
               if);
               origin[] -> argument.check 
            #)          
       #);
     Function::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# elm:: Items
            do (if scope[] <> none then
                   F.T[]-> scope.search -> (ATd[],on);
                   (if ATd[] <> none then
                       '*** Found function: '->puttext; 
                       F.T[] -> puttext; 
                       ' on='->puttext; on -> putint; newline
                    else
                       '*** Did NOT find function: '->puttext; 
                       F.T[] -> putline;
                       Decl -> ATd[]
                   if)
                else
                   'function:check:scope none ' -> putline    
               if);
               scanSons(#do scope[] -> current.check #)
            #)
       #);
     KeyWord::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# elm:: Items
            do (if scope[] <> none then
                   id[]-> scope.search -> (ATd[],on);
                   (if ATd[] <> none then
                       '*** Found keyWord: ' -> puttext; 
                       id[] -> puttext;
                       ' on= ' -> puttext; on -> putint; newline
                    else
                       '*** Did NOT find keyWord: '->puttext; 
                       id[] -> putline;
                       Decl -> ATd[]
                   if)
                else
                   'KeyWord:check:scope none ' -> putline    
               if);
              (* '\n***Checking actual parameters of Keyword:'->putline;
               dopt->putline;
               'Formals:'->putline;
               ATd.sig.scanParameters
               (#do currentArg.doPt -> putline #);
               'Actuals: ' -> putline;
               scanSons
               (# isArg: @boolean 
               do (if true or isArg then
                      current.doPT -> putline
                  if);
                  not isArg -> isArg
               #);
               *)
               scanSons(#do scope[] -> current.check #)
            #) 
       #);
     newDesc: @
       (# OD: [16] ^ObjectTemplate; 
          noOfDescs: @integer;
          anOD: ^ObjectTemplate;
          getOD: 
            (* only used from minienv *)
            (# descNo: @integer; anODx: ^ObjectTemplate
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
  do  (if doParse then
          '**** CHECKER ****' -> putline;
          rootModule.setUpOrigin;
          rootModule.check;
          (*main.doPT -> putline;*)
          (*main.doPP -> putline;*)
          inner
      if)
  #)
