ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
INCLUDE 'qprimitives';
INCLUDE 'qvirtual';
INCLUDE 'qunitparser'
---lib:attributes---
(* origin is always in instance of Items or none - for the outermost Module 
 * basicScope = origin for Items
 * argScope = basicScope in most cases
 * except for a pattern: Signature: ObjectGenerator:super, where
 *  (none,basicScope[],sig[],true) -> super.check;
 * argScope is mainly passed as argument to check
 * but saved in argBuf.add and then used in argBuf.check
 * Checking is recursive whenever neeeded, see abstractsyntaxtree::check
 *)
traceGeneric: (# exit false #);
traceGeneric2: (# exit false #);
traceGeneric3: (# exit false #);
handleGeneric: (# exit true #);
traceNoGlobals: (# exit false #);
checker: Parser
  (# traceSearch,traceAlloc: @ boolean;
     checkingModule: @boolean;
     Module::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
               sig[] -> OG.sig[];
               true -> OG.isObj
            #);
          check::
            (# org: ^Items; M: ^Module
            do (if traceCheck then
                   '**** Module:check: ' -> puttext; sig.doPT -> putline;
               if); 

               (* check enclosing module *)
               (if (origin[] <> none) 
                   and not (origin[]->org[]).isChecked then
                   (if traceCheck then
                       '\n**** check:Module:origin: ' -> puttext;
                       org.encOG.OGid -> putline;
                   if);
                   (none,org[],none,true) -> ((org.theModule)-> M[]).check;
               if);
               this(Module)[] -> requires.add;
               (none,basicScope[],none,true) -> sig.check;
               (none,basicScope[],none,true) -> OG.check; 
               markInModuleProp;
               this(Module)[] -> imports.addM;
            #);
          moduleAllocDone: @Boolean;
          alloc:: 
            (# 
            do (if false then
                   '**** Module:alloc: ' -> puttext; moduleName->putline; 
               if);
               (if moduleAllocDone then
                   (*'**** moduleAllocDone: ' -> puttext; moduleName->putline;*)
                   leave alloc
               if);
               true -> moduleAllocDone;
               (if enclIT[] <> none then (* IT is none if top module *)
                   (if OG.isBasicValue then
                       enclIT.vsize + 1 -> enclIT.vsize -> off
                    else
                       enclIT.rsize + 1 -> enclIT.rsize -> off
               if)if);
               (* For modules of the form
                *    AST: obj compiler_IF.Tree {...}
                * we must ensure that alloc has been called for 
                * compiler_IF and thus also Tree
                * For modules like
                *    SCPex: obj LIB.SimpleConcurrentProcesses.System
                * alloc must have been called for LIB and 
                *    SimpleConcurrentProcesses
                * We also need to ensure that alloc is called at most once
                * The boolean moduleAllocDone takes care of this
                *)
               OG.super.scanSons
               (# N: ^ objectInvocation; M: ^ModuleItem
               do (*current.dopt -> putline;*)
                  (if current## = ObjectInvocation## then
                      current[] -> N[];
                      (if N.ATd##
                       // Module## // ModuleItem## then 
                          N.Atd[] -> M[];
                          (if false then
                              ' isModule'->putline;
                              '** encModule: ' -> putline;
                              (encModule).OG.IS.dopt -> putline;
                          if);
                          (if not M.MD.moduleAllocDone then
                              (encModule).OG.IS[] -> N.ATd.alloc;
                              true -> M.MD.moduleAllocDone
                  if)if)if)
               #);
               enclIT[] -> sig.alloc;
               enclIT[] -> OG.alloc
            #);
          desc:: 
            (#
            do (*'**** Module:desc:OG: ' -> puttext;
               not OG.hasItems -> putboolean; newline;
               OG.dopt -> puthead;*)
               (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else  
                   OG.IS[] -> D[]
               if) 
            #);
          clear::<
            (#
            do (*'Clear: '->puttext; sig.doPT -> putline;*)
               false -> isAdded -> isIncluded -> inMainPath;
               inner
            #)
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do (if traceCheck or verbose then
                   '**** ModuleItem:check:NO:check: ' -> puttext;
                   sig.doPT->putline;
               if);
               (if false then
                   (none,basicScope[],none,true) -> MD.check
               if);
               false -> wasChecked
            #);
          checkRequires::
            (#
            do not MD.isIncluded -> done;
               (if traceCheck or false then
                   '**** MI:MD.isIncluded: ' -> puttext; sig.dopt->puttext;
                   ' ' -> put; done -> putboolean; newline
               if)
            #);
          importRequires::
            (#
            do (if MD.isIncluded then
                   (if false then
                       '**** import: ' -> puttext; MD.sig.dopt -> putline;
                   if);
                   MD.requires.import
               if)
            #);
          alloc:: 
            (# 
            do (if isChecked then enclIT[] -> MD.alloc if)
            #);
          setVirtualBindings::
            (#
            do not isChecked -> done;
            #);
       #);
     Items::<
       (# PT::
            (#
            do (if false then
                   '(' -> lx.put;
                   originOff -> lx.putint; ',' -> lx.put;
                   vsize -> lx.putint; ',' -> lx.put;
                   rsize -> lx.putint; ',' -> lx.put;
                   dsize -> lx.putint; ',' -> lx.put;
                   noOfInner -> lx.putint; ',' -> lx.put;
                   innerInx -> lx.putint;
                   ')' -> lx.put;
                   (pos,break) -> mkbreak
               if);
            #);
          setUpOrigin::
            (# 
            do false -> isChecked -> beingChecked 
               (*-> isVinxd -> isRinxd*) -> done ;
               0 -> descNo -> vsize -> rsize -> originOff -> noOfInner 
                 -> dsize -> innerInx;
               0 -> QDNtop;
               scanSons(# do this(Items)[] -> current.setupOrigin #);

               setAccessLevels
            #);
          setAccessLevels:
            (# acc_current: @integer; prop: ^NewProperty; dcl: ^Decl
            do scanSons
               (#
               do (if true
                   // current.isNewProp then
                      current[] -> prop[];
                      (if false then
                          '**** Got property: ' -> puttext; 
                          current.dopt -> putline;
                      if);
                      (if true 
                       // '%domain' -> prop.propId.T.equalNCS then
                          acc_domain -> acc_current;
                       // '%public' -> prop.propId.T.equalNCS then
                          acc_public -> acc_current;
                       // '%private' -> prop.propId.T.equalNCS then
                          acc_private -> acc_current;
                       // '%publicInSub' -> prop.propId.T.equalNCS then
                          acc_publicInSub -> acc_current;   
                       // '%domain_boundary' -> prop.propId.T.equalNCS then
                       // '%globals' -> prop.propId.T.equalNCS then
                          
                      if)
                   // current.isDecl then
                      current[] -> dcl[];
                      (if dcl## = ModuleItem## then
                          (* preliminary until we have fixed an explicit
                           * syntax for moduleItmes *)
                          acc_public -> dcl.accessLevel
                       else
                          acc_current -> dcl.accessLevel
                  if)if);
               #)
            #);
          checkGlobalAccess:
            (# globalRestrictionsInSuper,globalRestrictionsInMain,globalRestrictionsInSub: @boolean
            do (if superDesc[] <> none then
                   &superDesc.checkGlobalAccess -> 
                   (globalRestrictionsInSuper,globalRestrictionsInMain,globalRestrictionsInSub)
               if);
               (if true
                // (globalRestrictionsInMain = false) 
                   and (globalRestrictionsInSub = false) then
                   (* super may acces globals
	            * main may access globals unless globals-property
                    * so scan for globals below *)
                // (globalRestrictionsInMain = false) 
                   and (globalRestrictionsInSub = true) then
                   (* super may access globals
	            * main may not access globals, so leave *)
                   true -> globalRestrictionsInSuper -> globalRestrictionsInMain 
                     -> globalRestrictionsInSub;
                   leave checkGlobalAccess
                // (globalRestrictionsInMain = true) and (globalRestrictionsInSub = false) 
                   then  
                   (* super may not access globals
	            * main may access globals unless globals-prop
                    * scan for globals in main *)
                // (globalRestrictionsInMain = true) and (globalRestrictionsInSub = true) 
                   then  
                     (* super may not access globals
	              * main may not access globals - leave *)
                   true -> globalRestrictionsInSuper -> globalRestrictionsInMain
                     -> globalRestrictionsInSub;
                   leave checkGlobalAccess
               if);
               globalRestrictionsInMain -> globalRestrictionsInSuper;
               false -> globalRestrictionsInMain -> globalRestrictionsInSub;
               (if newBasicProp.globals[] <> none then
                   true -> globalRestrictionsInMain -> globalRestrictionsInSub;
                   L: newBasicProp.scanGlobals
                     (# INV: ^Invocation
                     do current.scanSons
                        (# OI: ^ObjectInvocation
                        do current[] -> OI[];
                           (if ('inSub' -> OI.ptnId.T.equalNCS) then
                               (*'***insub'-> putline; dopt -> putline;*)
                               (* OBS [globals[P1,P2,inSub,...]] *)
                               false -> globalRestrictionsInSub
                            else 
                               false -> globalRestrictionsInMAin -> globalRestrictionsInSub; 
                               leave L
                     if)#)#)
               if);
               (if traceNoGlobals and
                   (globalRestrictionsInSuper or globalRestrictionsInMain or globalRestrictionsInSub)
                   then
                   '****  CheckGlobalAccess:\n'->puttext;
                   encOg.dopt -> puthead;
                   (if globalRestrictionsInSuper then 
                       'globalRestrictionsInSuper:' -> puttext if);
                   (if globalRestrictionsInMain then 
                       'globalRestrictionsInMain:' -> puttext if);
                   (if globalRestrictionsInSub  then 'globalRestrictionsInSub:' ->puttext if);
                   newline;
               if);
            exit(globalRestrictionsInSuper,globalRestrictionsInMain,globalRestrictionsInSub)
            #);
          
          check::
            (# checkDoubleDecls:
                 (# 
                 do (*'\ncheckDoubleDecls: ' -> puttext;*)
                    scanDecls
                    (# illegalReDecl:
                         (# id: ^text; pNo: @integer
                         enter(id[],pNo)
                         do (if thisDcl.OG.primNo <> pNo then
                                currentDcl[] -> SemanticError
                                (#
                                do 'You cannot redeclare "' -> msg;
                                   id[] -> msg; '"' -> msg
                         #)if)#);                       
                       thisDcl: ^Decl
                    do currentDcl[] -> thisDcl[]; 
                       (if true
                        // 'object' -> currentDcl.sig.id.equalNCS then
                           ('object',object_prim) -> illegalReDecl
                        // 'value' -> currentDcl.sig.id.equalNCS then
                           ('value',value_prim) -> illegalReDecl
                       if);
                       (* thisDcl.sig.id[] -> puttext; '>' -> put;*)
                       (if currentDcl.OG.primNo
                        // fEq_prim // fLE_prim then
                        else
                           L:
                             scanAllDecls
                             (#
                             do (*currentDcl.sig.id[]->puttext; ' '->put;*)
                                (if currentDcl[] = thisDcl[] then leave L if);
                                isEq:
                                  (if currentDcl.sig.id[] 
                                        -> thisDcl.sig.id.equalNCS
                                      then
                                      (if 'Signature' 
                                            -> (thisDcl.origin.label).equalNCS then
                                          (if currentDcl.isInArg then
                                              (* thisDcl is a parameter of 
                                               * a pattern with fatComma 
                                               * syntax; and currentDcl 
                                               * must have been bound
                                               * by an argument in super 
                                               * of the pattern
                                               *)
                                              leave isEQ
                                      if)if);
                                      (* We must check that currentDcl is 
                                       * actually 
                                       * a binding of thisDcl; perhaps 
                                       * currentDcl.off=thisDcl.off is ok?
                                       *)
                                      (if not (thisDcl.isVirtual 
                                          and currentDcl.isVirtual) then
                                          thisDcl[] -> SemanticError
                                          (#
                                          do 'Double declaration of: "' 
                                               -> msg;
                                             thisDcl.sig.id[] -> msg; 
                                             '"' -> msg
                 #)if)if)#)if)#)#)               
            do (if traceCheck then 
                   '**** Items:check:\n' -> puttext; doPT->puthead;
                   ('basicScope',basicScope[]) -> putPT
               if);
               this(items)[] -> basicScope[];
               scanSons
               (# I: ^Item; 
               do (none,basicScope[],none,true) -> current.check;
                  current[] -> I[];
                  (if I.hasCode then true -> doHasCode if)
               #);
               checkDoubleDecls;

               checkGlobalAccess 
                 -> (globalRestrictionsInSuper,globalRestrictionsInMain,globalRestrictionsInSub);
            #);
          globalRestrictionsInSuper,         (* restrictions on globals in super *)
          globalRestrictionsInMain,          (* restrictions on globals in main *)
          globalRestrictionsInSub: @boolean; (* restrictions on globals  main.sub *)
          alloc::
            (# allocOrigin:
                 (# 
                 do (if globalRestrictionsInMain then
                     else
                        rsize + 1 -> rsize -> originOff
                    if)
                 #);
            do (if traceNoGlobals then
                   (if globalRestrictionsInMain then
                       '*** thisOG does not acces global attributes:\n '
                         -> puttext;
                       father.father.doPT -> puthead
               if)if);
               (if super.ATd[] <> none then
                   (if superDesc[] = none then
                       '**** Items:alloc: ' -> puttext; doPT -> putline;
                       '**   father: ' -> putline;
                       father.dopt -> putline;
                       '**   father.father: ' -> putline;
                       father.father.dopp -> putline;
                   if);
                   superDesc.vsize -> vsize;
                   superDesc.rsize -> rsize;
                   superDesc.dsize -> dsize;
                   (if super.isThisBlockLevel and (not super.isImplSuper) 
                       and (not super.isSingularImplSuper)
                       then
                       (if globalRestrictionsInSuper then
                           rsize + 1 -> rsize -> originOff
                        else
                           superDesc.originOff -> originOff
                       if)
                    else
                      allocOrigin 
                   if)
                else
                   allocOrigin;
                   (if objectDecl.OG.IS[] <> this(Items)[] then
                       1 -> dsize;
               if)if);
               (if sig[] <> none then
                   this(items)[] -> sig.alloc
               if);
               scanSons(# do this(items)[] -> current.alloc #);
            #);
          topSuper:
            (* This function also returns a primitive top pattern like value *) 
            (# topDesc: ^Items
            do (if (superDesc[] <> none) 
                   and (superDesc[] <> objectDecl.OG.IS[]) then
                   superDesc.topSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          hasRealSuper: BooleanValue
            (* used by generator:Items:genClass *)
            (# theIS: ^Items
            enter theIS[]
            do (theIS.superDesc[] <> none) 
               and 
               (not theIS.superDesc.isPrimitive
               or (theIS.superDesc.primNo = stringDecl.primNo)
               or (theIS.superDesc.primNo = immutable_prim)
               or (theIS.superDesc.primNo = vEq_prim)
               or (theIS.superDesc.primNo = vLE_prim)
               or (theIS.superDesc.primNo = ceq_prim)
               ) -> value
            #);
          realTopSuper:
            (* the top pattern being retrned must be a realSuper as specified
             * by hasRealSuper - used by generator:Items:genClass 
             *)
            (# topDesc: ^Items
            do (if this(Items)[] -> hasRealSuper then
                   superDesc.realTopSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          localSearch:            
            (# CS: ^ Text; ATd: ^Decl; pn: @integer
            enter CS[]
            do (if traceSearch then
                   '**** Items:localSearch: ' -> puttext; CS[] -> putline;
                   '**   in:' -> putline; doPT -> puthead; newline
               if);
               searchDcls:
                 (#
                 do (if false and (sig[] <> none) then
                        (if traceSearch then
                            '**** Items:localSearch:sig: ' -> puttext;
                            CS[] -> putline; sig.dopt -> putline
                        if);
                        sig.scanSons
                        (# D:^Decl
                        do (if current## <= Decl## then
                               current-> D[];
                               (if traceSearch then
                                   '**   sig:try:'->puttext; 
                                   D.dopt -> puthead
                               if);
                               (if (CS[] -> D.sig.id.equalNCS) then
                                   (if false then
                                       '**** found in sig:' -> puttext; 
                                       CS[] -> putline;
                                   if);
                                   D[] -> ATd[];
                                   leave searchDcls
                    if)if)#)if);
                    (if traceSearch then
                        '**   Items:localSearch:Decls: ' -> puttext;  
                        CS[] -> putline;
                    if);                      
                    scanSons
                    (# I: ^Item; AT: ^Decl; MI: ^ModuleItem; MD: ^Module;
                       OneArgFunc: BooleanValue
                         (#
                         do (if newFatComma then
                                ('()'-> (CS.copy).append 
                                  -> AT.sig.id.equalNCS) -> value
                            if)
                         #)
                    do current[] -> I[]; 
                       (if I.isDecl then
                           I[] -> AT[]; 
                           (if false and traceSearch then
                               'Try: ' -> puttext; AT.sig.id[] -> putline;
                           if);
                           (if (CS[] -> AT.sig.id.equalNCS) 
                               or OneArgFunc then
                               (* 'Found in: ' -> puttext; doPT->putline;*)
                               AT[] -> ATd[];
                               (if ATd## = ModuleItem## then
                                   (* A hack, and worse: this does 
                                    * not work as long as
                                    * we check all modules. An no included
                                    * module may use another non included 
                                    * module, which implies that this 
                                    * module will be marked as used!
                                    *)
                                   (*'!!!! Found ModuleItem (hack): ' 
                                    * -> puttext;
                                   ATd.sig.doPT -> putline;*)
                                   ATd[] -> MI[];
                                   (*true -> MI.MD.isAdded 
                                    * -> MI.MD.isIncluded*)
                                   MI[] -> (theModule->MD[]).imports.add
                               if);
                               leave searchDcls
                    if)if)#);
                    (if sig[] <> none then
                        CS[] -> sig.localSearch -> (ATd[],pn);(* pn = 0*)
                    if);
                    trySuper:
                      (if (ATd[] = none) and (superDesc[] <> none) then
                          (if traceSearch then
                              '**   Items:localSearch:trySuper:'->putline;
                              superDesc.dopt -> puthead; newline;
                          if);
                          CS[] -> superDesc.localSearch -> (ATd[],pn);
                          (if ATd[] <> none then pn + 1 -> pn if)
                       else
                          (if not super.isChecked then
                              (if traceCheck then
                                  '**   OG:check:super:isChecked:'->puttext;
                                  super.isChecked -> putboolean; newline;
                                  super.dopt -> puthead; '---'-> putline;
                                  dopt -> puthead; '==='->putline;
                              if);
                              (# SC: ^Scope
                              do (if sig[] <> NONE then
                                     sig[] -> SC[]
                                  else
                                     this(Items)[] -> SC[]
                                 if);
                                 (none,super.origin[] ,SC[],true) -> super.check
                                 (# beingCheckedX::
                                      (#
                                      do (if true then
                                             '\n!!!! Super is not checked: '
                                               -> puttext;
                                             super.dopt ->  putheadn;
                                             '!!   Super:beingChecked: true'
                                               -> putline;
                                             '**   OG:' -> puttext; 
                                             father.dopt -> puthead;
                              if)#)#)#);
                              (if super.ATd[] <> none then
                                  (if traceCheck then
                                      '**   check:super.ATd:'->putline;
                                     super.ATd.dopt -> puthead
                                  if);
                                  (none,super.ATd.origin[]
                                  ,super.ATd.origin[],true)
                                    -> super.ATd.check;
                                  restart trySuper
                      if)if)if)
                 #)
            exit(ATd[],pn)
            #); 
          searchIncludeProp:
            (# NA: ^Lexem; CS: ^Text; ATd: ^Decl; org: ^Items; F: ^node;
               trace: (# exit false #);
            enter(NA[])
            do (if traceSearch then
                   '**** Items:searchIncludeProp: ' -> puttext; 
                   NA.dopt -> puttext; ' in: ' -> putline;
                   dopt -> puthead;
                   '**   origin: ' -> putline; 
                   (if origin[] = none then
                       'none'->putline
                    else
                       origin.dopt -> puthead
               if)if);
               (if (1 -> NA.T.inxGet) = '#' then 
                   (2,NA.T.length) -> NA.T.sub -> CS[]
                else
                   NA.T[] -> CS[];
               if);
               (if (origin[] <> none) 
                   and not (origin[]->org[]).isChecked then
                   (if false and traceCheck then
                       '\n**** searchIncludeProp:Origin not checked:' 
                         -> puttext;
                       org.encOG.OGid -> putline;
                       (* '**   origin:beingChecked: ' -> puttext;
                       org.beingChecked -> putboolean; newline;
                       '**   to.search:in:origin: ' -> puttext;
                       org.label -> puttext; 
                       ' org.father.label: ' -> puttext;
                       org.father.label -> putline;
                       org.father.doPT -> puthead*)
                   if);
                   (none,org[],none,true) -> (org.father[]->F[]).check;
               if);
               scanSons
               (# I: ^Item; prop: ^NewProperty; 
               do current[] -> I[];
                  (if I.isNewProp then
                      I[] -> prop[];
                      (if true
                       // '%visible' -> prop.propID.T.equalNCS
                       // '%include' -> prop.propID.T.equalNCS then
                          (if traceSearch then
                              '**** searchIncludeProp: ' -> puttext; 
                              prop.dopt -> putline;
                          if);
                          (* We had origin[] instead of prop.origin[], 
                           * which did not work
                           * Dont understand the difference!? *)
                          (none,prop.origin[],none,true) -> prop.check;
                          searchProps:
                            prop.args.scanSons
                            (# IV: ^Invocation; pn: @integer; M: ^ModuleItem
                            do current[] -> IV[];
                               (if traceSearch then
                                   '**   search: ' -> puttext; 
                                   current.dopt -> puttext;
                                   ' IV.ATd.label: ' -> puttext;
                                   IV.ATd.label->putline;
                                   IV.ATd.doPT -> puthead;
                                   '**   desc: ' -> putline;
                                   (IV.ATd.desc).doPT -> puthead;
                                   '**   Items:'-> putline;
                                   IV.ATd.OG.IS.dopt -> puthead;
                                   '**    module:' -> putline;
                                   (IV.Atd[]->M[]).MD.dopt -> puthead;
                                   '**   M.desc: ' -> puthead;
                                   (M.desc).dopt -> puthead;
                                   '**   M.MD.desc: ' -> puthead;
                                   (M.MD.desc).dopt -> puthead;
                               if);
                               (if IV.Atd[] = none then
                                   'atv none' -> putline;
                                   prop.dopt -> putline;
                                   dopt -> putline;
                                   '---'->putline;
                                   origin.father.dopt -> putline;
                               if);
                               CS[] -> (IV.ATd.desc).localSearch -> (ATd[],pn);
                               (if ATd[] <> none then
                                   IV[] -> NA.viaIncl[];
                                   (* Perhaps mark module! *)
                                   leave searchProps
                               if)
                            #)
                  if)if);
               #)
            exit ATd[]
            #);
          doSearch::
            (#
            do (NA[],true) -> search -> (ATd[],on,pn)
            #);               
          search::
            (# org: ^Items; F: ^Node;
               CS: ^ Text;
               (* NA: ^Lexem; isFirst: @boolean; ATd: ^Decl; on,pn: @integer*)
            (*enter(NA[],isFirst)*)
            do 
               (if (1 -> NA.T.inxGet) = '#' then 
                   (2,NA.T.length) -> NA.T.sub -> CS[]
                else
                   NA.T[] -> CS[];
               if);
               (if traceSearch then
                   '**** Items:search: '->puttext; CS[] -> putline;
                   '**   in: ' -> putline; doPT -> puthead; newline
               if);
               (*'Vxx' -> CS.equal -> trx;*)
               CS[] -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   NA[] -> searchIncludeProp -> ATd[];                   
                   (if false and (ATd[] <> none) then
                       '**** Found: ' -> puttext; CS[] -> puttext;
                       ' in:' -> puttext;
                   if);

                   (if (ATd[] = none) and isFirst then
                       (if (origin[] -> org[]) <> none then
                           (NA[],isFirst) -> org.search -> (ATd[],on,pn);
                           (if not org.isChecked then
                               (if traceCheck then
                                   '\n**** Origin not checked:' -> puttext;
                                   ' org.beingChecked:'->puttext;
                                   org.beingChecked -> putboolean; newline;
                                   doPT -> puthead;
                                   (*'**   origin:beingChecked: ' -> puttext;
                                   '**   to.search:in:origin: ' -> puttext;
                                   org.label -> puttext; 
                                   ' org.father.label: ' -> puttext;
                                   org.father.label -> putline;
                                   org.father.doPT -> puthead*)
                               if);
                               (none,org[],none,true) 
                                 -> (org.father[]->F[]).check;
                           if);
                           (if basicNo = ifthen_prim then
                               (if false then
                                   '!!! Origin:search:%if%then: Adjust ON: ' 
                                     -> puttext; 
                                   doPT -> puthead
                               if)
                            else
                               on + 1 -> on ;
                               (if traceSearch then
                                   '>>> on + 1 = ' -> puttext; on -> putint;
                                   (if ATd[] <> none then 
                                       ' found!: "' -> puttext;
                                       NA.T[] -> puttext;
                                       '"! ATd.father:' -> putline;
                                       ATd.father.doPT -> puthead
                                    else
                                       ' not found' -> putline
                                   if);
                                   (*doP -> putline*)
                               if)
                           if)
               if)if)if);
               (if false and (ATd[] <> none) then 
                   '\n!!!!! found: ' -> puttext; CS[] -> puttext;
                   ' on:' -> puttext; on -> putint; 
                   ' pn:' -> puttext; pn -> putint; 
                   newline
               if)
            (*exit(ATd[],on,pn) *)
            #);
          basicNo: integerValue
            (* should be used in primNo *)
            (#
            do (*'Props: ' -> puttext; father.doP -> putline;*)
               (if (newBasicProp.primNo -> value) > 0 then
                else                  
                   (if superDesc[] <> none then
                       superDesc.basicNo -> value;
                       (*value -> putint; newline
                        else 'no super'->putline*)
                   if)
               if)
            #); 
          toOrigin:
             (# on: @integer; org: ^Items
             enter on
             do (if on > 0 then
                    (if basicNo = ifthen_prim then 
                        '\n!!! ifthen_prim:A:' -> putline;
                        dopt -> putline;
                        on  -> (origin[]->org[]).toOrigin -> org[]
                     else
                        on - 1 -> (origin[]->org[]).toOrigin -> org[]
                    if)
                 else
                    this(Items)[] -> org[];
                if);
                (if org.basicNo = ifThen_prim then
                    '\n!!! ifthen_prim:B:' -> putline;
                    org.origin[] -> org[]
                if)
             exit org[]
             #); 
          getNameForOff::
            (#
            do '???' -> NM[];
               (*'\ngetNameForOff: ' -> puttext; attOff -> putInt; ' ' -> put;*)
               (if attOff = originOff then
                   'origin' -> NM[];
                   leave getNameForOff
               if);
               L:
                 scanSons
                 (# I: ^Item; D: ^Decl
                 do current[] -> I[];
                    (if I.isDecl then
                        I[] -> D[];
                        (if D.off = attOff then
                            D.sig.id[] -> NM[];
                            leave L
                        if)
                    if)
                 #)
            #);          
          getDescNo:: (# do QdescNo[1] -> dNo #);
          objDescEq::< 
            (# 
            do (if trace then
                   'Items: '->puttext; getDescNo -> putint; 
                   inner;
                   ' QDNtop: ' -> puttext; QDNtop -> putint;
                   ' descNo: ' -> puttext; descNo -> putint;
                   newline;  
               if);
               DN = getDescNo -> value;
               (if trace then
                   ' items:' -> puttext; value -> putBoolean;
                   doPT -> putline
               if)
            #);
          clear::<
            (#
            do 0 -> vsize -> rsize -> dsize -> originOff
                 -> noOfInner -> innerInx;
               false -> done;
               inner
            #);
          newInner: ^Pattern;
          vsize,rsize,dsize,originOff,noOfInner,innerInx: @integer;
          isStringModule,
          done: @boolean (* codegen done*)
       #);
     NewProperty::<
       (# setUpOrigin::
            (#
            do (if false then
                   '**** NewProperty:setUpOrigin: ' -> puttext; dopt -> putline;
                   origin.dopt -> putline
               if);
               scanSons(# do origin[] -> current.setupOrigin #);
            #); 
         check::
            (# checkBasic:
                 (# NPA: ^NewPropertyArguments
                 do scanSons(#do (if isLast then current[] -> NPA[] if)#);
                    NPA.scanSons
                    (# INV: ^Invocation;
                    do current[] ->INV[];
                       INV.scanSons
                       (#
                       do (if not current.isConstLiteral then 
                              NPA[] -> SemanticError
                              (#
                              do 'Argument of %basic must be an '
                                 'integer constant: ' -> msg;
                                 current.doPT -> putline
                 #)if)#)#)#);
               
               checkInclude:
                 (# NPA: ^NewPropertyArguments
                 do (if false then
                        '**** checkInclude:' -> puttext; dopt -> puthead
                    if);
                    scanSons
                    (#
                    do (none,basicScope.origin[],none,true)->current.check
                    #);
                    scanSons(#do (if isLast then current[] -> NPA[] if)#);
                    NPA.scanSons
                    (# INV: ^Invocation; MI: ^ModuleItem
                    do current[] -> INV[];
                       (if INV.ATd.isModuleItem then 
                           (INV.ATd[]->MI[]).MD.markInModuleProp
                        else
                           NPA[] -> SemanticError
                           (#
                           do 'Argument of %include must be a Module: ' 
                                -> msg;
                              current.doPT -> msg
                           #)
                    if)#)
                 #);
               checkRequires:
                 (# NPA: ^NewPropertyArguments; org: ^Items
                 do (if false then
                        '**** checkRequiresProp: '->puttext; dopt->puttext;
                        ' in: ' -> puttext; 
                        (origin[]->org[]).encOG.OGid -> putline
                    if);                    
                    scanSons
                    (# 
                    do (if false then
                           '**   doCheck: ' -> puttext; 
                           current.label ->puttext;
                           ' ' ->put; current.dopt -> putline;
                       if);
                       true -> checkingModule;
                       (if not isFirst then
                           true -> (current[]->NPA[]).inModulePropX;
                       if);
                       (none,basicScope[],none,true)->current.check;
                    #);
                    false -> checkingModule;
                    scanSons
                    (#
                    do (*'** argX: ' -> puttext; current.dopt -> putline;*)
                       (if not isFirst then 
                           current[] -> NPA[];
                           NPA.scanSons
                           (# INV: ^Invocation; MI: ^ModuleItem
                           do current[] -> INV[];
                              (*'**   arg:' ->puttext; INV.doPT->putline;*)
                              (if INV.ATd.isModuleItem then 
                                  (*(if isFirst then
                                        '**** checkRequires:mark: ' 
                                        -> puttext;
                                   else ',' -> put if);
                                   INV.dopt -> puttext; *)
                                  
                                  (*(INV.ATd[]->MI[]).MD.markInModuleProp;*)
                                  (INV.ATd[]->MI[]).MD[]
                                    -> (theModule).requires.add;
                                  true -> (INV.ATd[]->MI[]).inModuleProp
                               else
                                  NPA[] -> SemanticError
                                  (#
                                  do 'Argument of %requires '
                                     'must be a Module: ' 
                                       -> msg;
                                     current.doPT -> msg
                                  #)
                    if)#)if)#); 
                    (*newline;*)
                    (if false then
                        '**** checkRequires:done: ' -> puttext;
                        dopt -> putline
                    if)
                 #);
            do (if traceCheck then
                   '**** NewProperty:Check: ' -> puttext; dopt -> putline;
                   (*''**   scope:A: ' -> putline; basicScope.dopt -> puthead*)
               if);
               L:
                 (#
                 do (if true 
                     // '%basic' -> propId.T.equalNCS then
                        checkBasic
                     // '%requires' -> propId.T.equalNCS 
                     // '%module' -> propId.T.equalNCS 
                     // '%modules' -> propId.T.equalNCS then 
                        (if not locateWorld.aMiniBetaModule then
                            checkRequires;
                        if);
                        leave L
                     // '%visible' -> propId.T.equalNCS
                     // '%include' -> propId.T.equalNCS then 
                        checkInclude;
                        checkRequires;
                        leave L
                        
                     // '%domain' -> propId.T.equalNCS then
                     // '%public' -> propId.T.equalNCS then
                     // '%publicInSub' -> propId.T.equalNCS then
                     // '%private' -> propId.T.equalNCS then
                     // '%domain_boundary' -> propId.T.equalNCS then
                     // '%unit' -> propId.T.equalNCS then
                        this(NewProperty)[] -> unitTable.add;
                     // '%association' -> propId.T.equalNCS then
                        
                     // '%globals' -> propId.T.equalNCS then
                     // '%locals' -> propId.T.equalNCS then
                     // '%interface' -> propId.T.equalNCS then
                     // '%arguments' -> propId.T.equalNCS then
                     // '%abstract' -> propId.T.equalNCS then
                     // '%kind' -> propId.T.equalNCS then
                     // '%immutable' -> propId.T.equalNCS then
                     // '%unique' -> propId.T.equalNCS then
                     // '%external' -> propId.T.equalNCS then
                     // '%core' -> propId.T.equalNCS then
                     // '%OSDvisibility' -> propId.T.equalNCS then
                     // '%ID' -> propId.T.equalNCS then
                        (*'**** %ID: ' -> puttext; dopt -> putline;*)
                        scanSons
                        (# T: ^Text
                        do (*current.dopt -> puttext; ' ' -> put;*)
                           (if not isFirst then
                               current.dopt -> T[];
                               (2,T.length) -> T.sub -> T[];
                               (*' notFirst: "' -> puttext;
                               T[] -> puttext; '"'->put;*)
                               (if 'object' -> T.equalncs then
                                   (*' **** check %ID: ' -> puttext;
                                   current.dopt -> putline;*)
                                else
                                   (*' *** dont check %ID: '  -> puttext;
                                   current.dopt -> putline;*)
                                   leave L
                           if)if)
                        #);
                        (*newline;*)
                     else
                        this(NewProperty)[] -> warning
                        (#
                        do 'Unknown property: ' -> msg;
                           propId.T[] -> msg
                        #)
                    if);
                    scanSons
                    (#do (none,basicScope[],none,true) -> current.check #)
                 #)
            #);
          checkRequires::
            (#
            do (if '%ID' -> propId.T.equalNCS then
                   true -> done
               if)
            #)
       #);
     NewPropertyArguments::<
       (# setUpOrigin:: 
            (#do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (# 
            do (if traceCheck then
                   '**** newPropArg:check: ' -> puttext; dopt -> putline
               if);
               scanSons
               (# INV: ^Invocation; MI: ^ModuleItem; ap: ^Apl
               do (if false then
                      '**   NPargs: ' -> puttext; current.dopt -> puttext;
                      ' ' -> put; inModulePropX -> putboolean; newline;
                      (*
                      (if basicScope[] = none then
                          ' basicScope is none' -> putline
                       else newline;
                          basicScope.dopt -> puthead;
                      if);*)
                  if);
                  inModulePropX -> (current[]->ap[]).inModulePropX;
                  (none,basicScope[],none,true) -> current.check;
                  current[] -> INV[];
               #)
            #)
       #);
     Signature::<
        (* Keyword = Signature(args)
         * else    = Signature(name(id),args?)
         * foo(D1)in(D2)with(D3): super+IS,  where IS ={...}
         * D1, D2 and D3 should be at the same block level as IS;
         * however, D1, D2 and D3 are not Items 
         * - but Items and Signature are sub of Scope
         * Can we have  Arguments = (Items (D1,D2,D3)) 
         * Are the fat commas also items 
         *)
       (# setUpOrigin::
            (#
            do (if true then
                   scanSons(#do this(Signature)[] -> current.setupOrigin #);
                else
                   scanSons(#do origin[] -> current.setupOrigin #);
               if)
            #);
          check::
            (# 
            do (if traceCheck then
                   '**** Signature:check: ' -> puttext; doPT -> putline
               if);
               (if type[] <> none then
                   (none,basicScope[],none,true) -> type.check;
               if);
               scanSons(#do (none,basicScope[],none,true) -> current.check #);
               
               (if false then
                   (if (args[] <> none) then
                       args.scanSons
                       (#do (none,basicScope[],none,true) -> current.check #)
               if)if)
            #);
          search::
            (# org: ^Items
            do NA.T[] -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (NA[],isFirst) -> (origin[]->org[]).search -> (ATd[],on,pn)
               if)
            #);
          localSearch:
            (# CS: ^Text; ATd,D: ^Decl; pn: @integer
            enter CS[]
            do (if traceSearch then
                   '**** Signature:localSearch: '->puttext; CS[] -> puttext;
                   ' in: ' -> puttext; dopt -> putline
               if);
               L:
               scanSons
               (# doTry: @Boolean; arg: ^Arguments
               do false -> doTry; none -> D[];
                  (* this a mess:
                   * For fatComma, the arguments are apparently in the signature
                   * For special/binary, the Signature has an Arguments son
                   * where we have to fecth the parameter.
                   * We should fix thia
                   *)
                  (if true
                   // current## <= Decl## then 
                      current[] -> D[]; true -> doTry
                   // current## <= Arguments## then
                      current[] -> arg[]; 
                      arg.scanSons
                      (# 
                      do (if current## <= Decl## then current[] -> D[] if)
                      #);
                      D[] <> none -> doTry
                  if);
                  (if false and doTry then
                      '**** try:CS: ' ->  puttext;
                      CS[] -> puttext; ' sig: ' -> puttext;
                      D.sig.id[] -> puttext; ' ' -> put;
                      D.dopt -> putline;
                  if);
                  (if doTry and (CS[] -> D.sig.id.equalNCS) then
                      (if false then
                          '**** signature:localSearch: found: ' -> puttext;
                          CS[] -> putline;
                      if);
                      D[] -> ATd[];
                      leave L
               if)#)
            exit(ATd[],pn)
            #);
          alloc:: 
            (# 
            do (if type[] <> none then
                   enclIT[] -> type.alloc
               if);
               scanSons
               (#do 
                  (if encOG[] <> none then
                      encOG.IS[] -> current.alloc
               if)#)
            #);
       #);
    Arguments::<
       (# setUpOrigin:: 
            (# 
            do (if false and (noOfSons > 0) then
                   '**** Arguments:setUpOrigin:' -> puttext; dopt -> puthead;
               if);
               scanSons
               (# OG: ^ObjectGenerator; OS: ^ObjectSpecification; 
                  N: ^node; BE: ^BracketedExp
               do (if current## = ObjectGenerator## then
                      (* Foo: 
                       *    ...
                       *    %do body:< Object %with% CCC: ?char: -pattern
                       *        ...
                       *    ...
                       *    %do                 -- ObjectInvocation
                       *       S1
                       *       S2 
                       *    %with% exp
                       *       ... may be empty
                       *)
                      (if trx then
                          '**** setUpOrigin:OG:'-> puttext; 
                          current.label -> putline;
                          current.dopt -> puthead;
                      if);
                      current[] -> OG[]; 
                      (* OG = Object{ S1; S2} *)
                      (if OG.isObjectDesc then
                          OG.father.father.father.father -> N[];
                          (if false then
                              '**** OG in:Arguments: ' -> putline;
                              OG.dopt ->  puthead;
                              '**** OG.father.father.father.father: ' -> puttext;
                              OG.father.father.father.father.label -> putline;
                              OG.father.father.father.father.dopt ->  puthead;
                              '**** OG.father.origin.father: ' ->  puttext; 
                              (If (OG.father.origin[] <> none) and (OG.father.origin.father[] <> none) then
                                  (*Koks: OG..origin is not setup here
                                   * we set it  up below;-)
                                   *)
                                  OG.father.origin.father.label -> putline;
                                  OG.father.origin.father.dopt -> putline 
                               else
                                  'none'->putline
                              if)
                          if);
                          (if N##
                           // objectCall## then
                              N[] -> OS[];
                              (if trx then
                                  '\n**** B:label: ' -> puttext; OS.label->putline;
                                  OS.dopt -> putline;
                                  '**   set:origin:'->putline;
                                  OS.origin.dopt -> puthead;
                              if);
                              (if false then
                                  '**   OC:origin:'->putline; OS.origin.dopt->puthead;
                                  if);
                              OS.origin[] -> current.setUpOrigin;
                           // ObjectGenerator## then
                              N[] -> OS[];
                              (if trx then
                                  '\n**** C:label: ' -> puttext; OS.label -> putline;
                                  OS.dopt -> putline;
                                   '**   set:origin:'->putline;
                                  OS.IS.dopt -> puthead;
                                  '**   OS:'->putline; OS.dopt -> puthead
                              if);
                              (if false then
                                  '**** arguments:setUpOrigin:' -> puttext; dopt -> putline;
                                  '**   OG:origin:'->putline;
                                  OS.IS.dopt->puthead;
                              if);
                              OS.IS[] -> current.setUpOrigin;
                           // BracketedExp## then
                              N[] -> BE[];
                              (if false then
                                  '**   BE:origin:'->putline; origin.dopt->puthead;
                              if);
                              N.origin[] -> current.setUpOrigin;
                           else
                              '!!!! no match:'->puttext; N.label->putline
                          if);
                       else (* exp above comes here *)
                          (if false then
                              'D:label: ' -> puttext;
                              OG.father.father.father.father.label -> putline;
                              OG.father.father.father.father.dopt -> puthead;
                          if);
                          (if trx then
                              '**   other:origin:'->puttext; 
                              current.label -> putline;
                              origin.dopt->puthead;
                          if);
                          origin[] -> current.setUpOrigin;
                      if)
                   else
                      (if false then
                          '**** setUpOrigin:E:'-> puttext; 
                          current.label -> putline;
                          current.dopt->puthead;
                           '**   set:origin:'->putline;
                          (if origin[] <> none then 
                              origin.dopt -> puthead;
                      if)if);
                      origin[] -> current.setUpOrigin 
                  if)
               #);
               (if trx and (noOfSons > 0) then
                   '**** Arguments:setUpOrigin:done:'->putline; dopt -> puthead
               if);

            #);
          check:: 
            (# (* Why not argScope below? *)
            do (if traceCheck then
                   '**** Arguments:check:' -> puttext; dopt -> putline
               if);
               scanArgs
               (# OG: ^ObjectGenerator
               do (*current.label -> putline;*)
                  (if false and (current## = ObjectGenerator##) then 
                      (* a virtual binding or a simgular computing a value*)
                      '**** arg: '->putline; current.dopt -> puthead;
                      current[] -> OG[];
                      (if OG.isObjectDesc then
                          '**  Fathers: ' -> puttext;
                          (*current.father.label -> puttext; ' ' -> put;
                          current.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.label -> puttext; ' ' -> put;*)
                          current.father.father.father.father.label -> puttext; 
                          newline;
                          current.father.father.father.father.dopt->puthead;
                          '*** current.origin: ' -> putline;
                          (if current.origin[] <> none then
                              current.origin.father.doPT -> puthead;
                              '*** origin.origin: ' -> putline;
                              current.origin.origin.father.doPT -> puthead;
                              '*** origin: ' -> putline;
                              origin.father.doPt -> puthead;
                              '*** basicScope: ' -> putline;
                              basicScope.father.doPt -> puthead; 
                              
                           else
                              ' none' -> putline
                          if)
                      if)
                   (* else a Decl? *)
                  if);
                  (none,basicScope[],none,true) -> current.check;
               #)
            #);
          alloc:: (# do scanSons(#do enclIT[] -> current.alloc #)#);
       #);
         
     DataItem::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
               sig[] -> OG.sig[];
               true -> OG.isObj
            #);
          check::
            (# elm::Items
            do (if traceCheck then
                   '**** DataItem:check: ' -> puttext; sig.id[] -> putline;
               if);
               (none,basicScope[],none,true) -> sig.check;
               (none,basicScope[],none,true) -> OG.check; 
               (If false then OG.super.clearQual; if);
               (if OG.IS.isEmpty and OG.super.hasVirtualArgs then
                   (* Qualifications: obj Set.Set(#Qualification)
                    *  must be converted, but
                    * QS: obj Qualifications
                    *  should not be converted
                    * Supplement of hastVirtualArgs, check if actual args
                    *)
                   (# E: ^Exp
                   do (if (OG## = ObjectCall##) and isConst then
                          OG.super.last -> E[];
                          (if (E.ATd.primNo <> indexed_prim) 
                              and (E.args[] <> none) 
                              and (E.args.noOfSons > 0) then
                              (if true then
                                  '**** DataItem:convertOC2OG: ' ->puttext;dopt -> puthead;
                                  '**   OG.label:' ->puttext;
                                  OG.label -> putline;
                                  '**   OG.super: ' -> puttext;
                                  OG.super.dopt -> puthead;
                              if);
                              (if true then
                                  OG[] -> convertObjectCallToGenerator -> OG[];
                                  OG.clear;
                                  false -> OG.IS.isEmpty;
                                  origin[] -> OG.setUpOrigin;
                                  (none,origin[],none(*origin[]*),true) -> OG.check;
                              if);
                              (if false then
                                  '**   to:'->putline; OG.dopt -> puthead;
                                  OG.label -> putline;
                                  doPT -> putline
                   if)if)if)#)
               if)
            #);
          checkVirtualArgs:: (* skip *)(##);
          markIfVirtualDataItem::
            (* Mark if this dataItem is qualified by a a virtual object 
             * - i.e. has the form:
             *    S: ? elm where elm:< Object
             * In this case elm may be bound to a simple value like Integer or
             * a pattern defining 'real' objects
             *)
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   (* IT is not referred so why an argument?*)
                   (if (OG.super.ATd[] <> none) 
                       and (OG.super.ATd.isVirtualObject) then
                       true -> isVirtualObject -> value                       
               if)if)
            #);
          isVirtualObject: @ Boolean;
          hasVirtualObjectQual::
            (#
            do (OG.super.ATd[] <> none) and (OG.super.ATd.isVirtualObject) 
                 -> value
            #);
          alloc::
            (# fOG: ^ObjectGenerator
            do (if OG.isBasicValue then
                   enclIT.vsize + 1 -> enclIT.vsize -> off
                else
                   enclIT.rsize + 1 -> enclIT.rsize -> off
               if);
               enclIT[] -> sig.alloc;
               enclIT[] -> OG.alloc
            #);          
          desc::
            (# elm:: scope
            do (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
          objDescEQ::<
            (#
            do (if trace then 'DataItem: ' -> puttext; newline if);
               DN -> OG.objDescEQ -> value;
               (if trace then 'DI:'->puttext; value -> putBoolean if)
            #);
          hasCode:: 
            (* perhaps not suffcient!
             *   S: @T -- hasCode if T hasCode
             *   S: @T{ ... } -- hasCode if T hasCode or main.hasCode
             *   I: @integer --- no code
             *)
            (# 
            do (*OG.hasCode -> value *)
            #);
          clear::< 
            (#do (*'DataItem:clear: ' -> puttext; sig.dopt -> putline; *)#);
       #);
     LabelDecL::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
               (*sig[] -> OG.sig[] - does not work: QUA-error - perhaps because
                * we assume that sig[] = none ==> OG is part of a patter!?
                *)
            #);
          check::
            (# elm::Items
            do (if traceCheck then
                   '**** LabelDecl:check: ' -> puttext; newline;
                   doPT -> putline
               if);
               (none,basicScope[],none,true) -> sig.check;
               (none,basicScope[],none,true) -> OG.check;                
            #);
          alloc::
            (#
            do (if false then
                   '**** LabelDecl:alloc: ' -> putline;
                   enclIT.dopt -> putline
               if);
               enclIT[] -> sig.alloc;
               enclIT[] -> OG.alloc
            #);
          desc::
            (# elm:: scope
            do (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
       #);
     Pattern::<
       (# setUpOrigin::
            (# org: ^Items;
            do origin[] -> sig.setUpOrigin;
               OG[] -> sig.encOG[];
               sig[] -> OG.sig[];
               origin[] -> OG.setupOrigin;
               (if OG.primNo = string_prim then
                   origin[] -> org[]; true -> org.isStringModule
               if)
            #);

          isVirtual:: (#do ptnKind <> PlainPtn -> value #);
          isVirtualObjectX::
            (#
            do (if isVirtual and OG.IS.isEmpty then
                   (*'kuk: ' -> puttext; dopt -> puthead; 
                   ' ' -> put; OG.super.primNo -> putint; newline;*)
                   OG.super.primNo = object_prim -> value
               if);
            #);
          isVirtualObject::
            (#
            do (if isVirtual then
                   (if not (*OG.isObjectDesc*) OG.isObjectGenerator then
                       OG.super.primNo = object_prim -> value
                   if)
               if)
            #);
          hasVirtualObjectQual::
            (#
            do isVirtualObject -> value
            #);
          goSuper: IntegerValue
            (# ptn: ^Pattern
            do (if OG.super.ATd[] = none then
                   (if primNo = inner_prim then 1 -> value if)
                else
                   (if OG.super.ATd## = Pattern## then
                       (if ((OG.super.ATd[]->ptn[]).goSuper 
                             -> value) > 0 then
                           value + 1 -> value;
                           (if false then
                               'BINGO: ' -> putline; dopt -> putline;
                           if);
                           inner_prim -> OG.IS.newBasicProp.primNo;
                           OtherPrimPattern -> currentPtnKind[]
                       if)
               if)if)
            #);
          checkIfInnerSub: 
            (# innerPtn: ^Pattern; org: ^Items
            do (if goSuper > 1 then
                   (if (origin[]->org[]).newInner[] = none then
                       this(Pattern)[] -> org.newInner[]
                    else
                       this(Pattern)[] -> warning
                       (#
                       do 'It is only possible to redefine inner once!'->msg;
                          '\n     Pattern "' -> msg;
                          org.newInner.sig.dopt -> msg;
                          '" also redefines inner'->msg
                       #)
                   if)
               if)
            #);
          theSig: ^MkSig;
          check::< 
            (# elm:: Items;
               checkInOut:
                 (# inOutError:
                      (#
                      do this(Pattern)[] -> SemanticError
                         (# 
                         do 'A ' -> msg;
                            (if pK
                             // PlainPtn then 'plain' -> msg
                             // VirtualPtn then 'virtual' -> msg
                             // FinalPtn then 'final' -> msg
                             // FurtherPtn then 'further' -> msg
                            if);
                            ' pattern "'->msg; sig.dopt -> msg; 
                            '" cannot be marked as an ' -> msg;
                            (if inOK then 'in' -> msg if);
                            (if outOK then 'out' -> msg if);
                            ' parameter' -> msg
                         #)
                      #);
                    pK: @integer; inOK,outOK: @boolean
                 enter(pK,inOK,outOK)
                 do (if isInArg and not inOK then
                         inOutError
                     if);
                    (if isOutArg and not outOK then
                         inOutError                         
                     if);
                 #);            
               handleVirtualBinding:
                  (* For any pattern: final or further, we search for a virtual
                   * declaration in super 
                   * - and we need to get the off for this virtual
                  * Then we test if super for this FinalPtn is implicit
                  * In qAbstractSyntaxTree::decl:checkVirtualArgs,
                  * we do an almost identical check for virtual arguments
                  * We should unify ...
                  *)
                 (# VP: ^Pattern; (* not always the case ??*)
                    pn: @integer
                 do (*'Ptn:check:handleVirtualBinding:'->puttext; 
                     * doPT -> putline;*)
                    (if ptnKind 
                     // VirtualPtn then
                        OG[] -> mkSig -> theSig[];
                        (if theSig.isSig and traceSingularFunc then
                            '**** is Signature ' -> putline; dopt -> putline
                        if);
                     // FinalPtn // FurtherPtn then
                        OG[] -> mkSig -> theSig[];
                        (ptnKind,false,false) -> checkInOut;
                        sig.id[] -> basicScope.superDesc.localSearch 
                          -> (vDcl[],pn);
                        (if vDcl[] <> none then
                            (if traceSingularFunc or vDcl.theSig.isSig then
                                '**** super is signature: ' -> putline; 
                                vDcl.doPT -> putline;
                                '**   binding: ' -> puttext; dopt -> putline
                            if);

                            (if false then
                                '**** Found vDcl: ' -> puttext; 
                                vDcl.dopt -> putline;
                                '**   Binding: ' -> puttext; dopt -> putline;
                            if);
                            (* OBS! in V:: A { } isImplSuper should not be true
                             * Only for  V:: { }
                             *)
                            vDcl[] -> VP[];(* -> OG.super.ATd[];*)
                            (* ' pn:' -> puttext; pn -> putint; 
                             ' off:' -> puttext; off -> putint; ' ' -> put; *)
                            (if OG.super.isEmpty then
                                VP[] -> OG.super.ATd[];
                                pn + 1 -> OG.super.pn;
                                true -> OG.super.isImplSuper;
                                (*' isImplSuper=T '-> puttext;*)
                            if);
                            (if VP.OG.hasItems (*not VP.OG.IS.isEmpty*) then
                                true -> OG.super.isSingularImplSuper;
                                (*' isSingularImplSuper=T ' -> puttext; *)
                             else
                                (*' isCategoryImplSuper: ' -> puttext*)
                            if);
                            (*vDcl.sig.doPT -> putline*)
                         else
                            this(Pattern)[] -> SemanticError
                            (#
                            do 'No virtual declaration in super for: "' -> msg;
                               sig.doPT -> msg; '"' -> msg
                            #)
                        if);
                     // plainPtn then
                        (ptnKind,false,false) -> checkInOut
                    if)
                 #);
            do (if traceCheck then  
                   '**** Pattern:check: ' -> puttext; sig.id[] -> putline if);
               handleVirtualBinding;
               (* Must check sig before OG;
                * Items in OG may refer Decl's in sig
                * Allocation of storage for sig must be in OG.IS
                * Scope for Decl's in sig must be basicScope
                * BUT! When checking sig, OG.super is not setup, 
                * which gives problems in
                * foo(x: ? bar):
                *    ...
                * bar: 
                *    S: ? foo
                *    S := foo(e) -- super for foo is not setup
                * Thus we check super before checking sig
                *)
               (* no circularity in super chain is deteched *)
               (none,OG.IS[],none,true) -> sig.check; 
               (none,basicScope[],none,true) -> OG.check;
               (if OG.circularityInSuper then
                   (* a litte bit clumsy *)
                   leave check
               if);
               checkIfInnerSub;
               (if traceGeneric then
                   OG.IS.scanAllDecls
                   (# D: ^Decl
                   do (if currentDcl.isVirtualObject then
                          (*'Virtual Object: ' -> puttext; 
                           currentDcl.doPt -> putline;*)
                      if)
               #)if);
               inner;
            #);
          isInner::<
            (* Perhaps ad hoc!? -- from old code: inner
             * check BKWptn: %inner P
             *)
            (# org: ^Items
            do (if (OG.primNo = inner_prim) -> value then
                   (if false then
                       '**** got inner:\n' -> puttext; dopt -> putline
                   if);
                   basicScope[] -> org[];
                   args.scanArgs
                   (# A: ^ObjectSpecification
                   do current[] -> A[];
                      A.super.on - 1 
                        -> (args.origin[]->org[]).toOrigin -> org[]; 
                   #);
                   org.noOfInner + 1 -> org.noOfinner;
                   (if false then
                       '**   org:'->putline; org.dopt -> puthead
                   if);
                   (if org.noOfInner = 1 then 
                       org.dsize + 1 
                         -> org.dsize 
                         -> org.innerInx 
                   if);
               if);
            #);     
          alloc::< 
            (# add:
                 (* We have a ptn: V:< OGv1, V::< OGv2
                  * OGv1 or OGv2 are bindings of V
                  * For OG2, we should perhaps have the initial V:< OG?
                  *)
                 (# enclosingOG: ^ObjectGenerator; ptn: ^pattern; F: ^Node
                 do father.father[] -> F[];
                    (if F##
                     // ObjectGenerator## then
                        (* 'ObjectGenerator: ' -> putline; F.dopt->putline;*)
                        (this(Pattern)[],OG[]) -> (F[]->enclosingOG[]).addBinding
                     else                           
                        'Koks'->putline;
                        father.father.label -> putline
                    if)
                 #);
            do (if false then
                   '*** Ptn:alloc: ' -> puttext; sig.doPT -> putline;
               if);
               enclIT[] -> OG.alloc;
               (if ptnKind 
                // virtualPtn then 
                   (if false then
                       '**** alloc:virtual ptn: ' -> puttext; 
                       enclIT.dsize -> putint; ' ' -> put;
                       sig.doPT -> putline;
                   if);
                   enclIT.dsize + 1 -> enclIT.dsize -> off;
                   (*add*)
                // furtherPtn // finalPtn then
                   (if false then
                       '**** alloc:Virtual bind: ' -> puttext; 
                       vDcl.off -> putint;
                       ' ' -> put;
                       sig.doPT -> puthead;                   
                   if);
                   (*OG.super.ATd.off -> off;*)
                   vDcl.off -> off;
                   (*add*)
               if);
               (*inner *)
            #);
          setVirtualBindings::
            (# add:
                 (* We have a ptn: V:< OGv1, V::< OGv2
                  * OGv1 or OGv2 are bindings of V
                  * For OG2, we should perhaps have the initial V:< OG?
                  *)
                 (# enclosingOG: ^ObjectGenerator; ptn: ^pattern; F: ^Node
                 do father.father[] -> F[];
                    (if F##
                     // ObjectGenerator## then
                        (if false then
                            '**** SVB:ObjectGenerator: ' -> putline; 
                            F.dopt->putline;
                        if);
                        (this(Pattern)[],OG[]) 
                          -> (F[]->enclosingOG[]).addBinding
                     else                           
                        'Koks'->putline;
                        father.father.label -> putline
                    if)
                 #);
            do  (if ptnKind 
                // virtualPtn then 
                   (*'**** Virtual ptn: ' -> putline; sig.doPT -> putline;*)
                   add
                // furtherPtn // finalPtn then
                    (*'**** Virtual bind: ' -> putline; sig.doPT -> putline;*)
                    OG.super.ATd.off -> off;
                    add;
               if);
            #);
          handleArgs::
            (# args: [6]^ObjectSpecification; top: @integer;
               enclosingOG: ^ObjectSpecification (*ObjectGenerator*)
            do (if false then
                   '**** HandleArgs: ' -> putline; dopt-> puthead;
                   '**   E: ' -> puttext; E.doPT -> puthead;
                   '**   E.father.father.father:'->putline;
                   E.father.father.father.dopt -> puthead;
               if);
               
               (if E.args[] = none then leave handleArgs if);
               E.args.scanArgs
               (#
               do (if (top+1 -> top) > args.range then 
                      args.range -> args.extend 
                  if);
                  current[] -> args[top][];
               #);
               (if top = 0 then leave handleArgs if);
               L:
               scanArgs
               (# i: @ integer; Ex: ^Exp; 
                  OI: ^ObjectInvocation; descNo: @integer
               do i + 1 -> i; 
                  (if i > top then
                      leave L; (* SemErr dont work for 
                                * Punky: Funky(200,300){...}
                                * Punky(100)
                                * TST/SuperArguments
                                *)
                      E[] -> SemanticError
                      (#
                      do 'Too few actual args: ' -> msg;  
                         E.dopt -> msg;
                      #);
                      leave L
                  if);
                  handleVirtArg:
                    (if currentArg.isVirtual then 
                        (if false then
                            '**   virtualArg: ' -> putline;
                            currentArg.dopt -> putline;
                            '**   args[i]: ' -> putline;
                            args[i].dopt -> putline
                        if);
                        args[i].super.last -> Ex[];
                        (if (Ex[] <> none) and (Ex.isObjectInvocation) then
                            (if false then
                                'Try: ' -> puttext; Ex.label -> putline; 
                                Ex.doPT -> putline;  
                                args[i].doPT -> putline;
                            if);
                            Ex[] -> OI[];
                            (if (args[i].IS[] = none) or args[i].IS.isEmpty then
                                (* We have a non-singular binding, 
                                 * see handleVirtualBinding *)
                                (* newDesc -> args[i].vDescNo;*)
                                true -> args[i].isVirtualArg;
                                (* '*** non-singular argument binding: ' -> puttext; 
                                args[i].vDescNo -> putint; ' ' -> put;
                                args[i].doPT -> putline;*)
                            if);
                            (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                (* 'Got ptn id: ' -> puttext; 
                                 * OI.ptnId.doPT -> puttext;
                                 *)
                                (args[i].desc).descNo -> descNo; (* dont use descNo!*)
                                (* args[i] is a binding of currentArg
                                 * Why dont we use the addBinding call below?
                                 *)
                                (currentArg[],args[i][])
                                  -> (E.father.father[]-> enclosingOG[]).addBinding;
                                leave handleVirtArg
                            if);
                            (if (E.desc).primNo = indexed_prim then 
                                (* We ignore bindings of elm in Indexed *)
                                leave handleVirtArg
                             else
                                (if OI.ATd.(*args[i].*)primNo = integer_prim then
                                    '\n*** Virtual bound to integer in\n\n\t'->puttext;
                                    E.doPT -> putline;
                                    '\n    is ignored by the compiler\n' -> putline;
                                    leave handleVirtArg
                                if);
                            if);
                            (* args[i] is a binding of currentArg *)
                            (currentArg[], args[i][]) 
                              -> (E.father.father[]-> enclosingOG[]).addBinding;
                         else
                            (* Not clear which situation we have here?
                             * Apparently a virtual with no super as in
                             *  map:
                             *    in F:<
                             *       in x: ...
                             *       ...
                             *)
                            (if false then
                                'Not OI: ' -> puttext; 
                                (if ex[]=none then 
                                    ' :ex=none: '->puttext;
                                    args[i].label -> puttext; 
                                 else
                                    Ex.label -> puttext; 
                                if);
                                newline;
                                args[i].dopt -> puttext;
                                '\n>>> ' ->puttext;
                                E.dopt -> puttext;
                                '\n>>> ' ->puttext;
                                currentArg.dopt -> putline;
                            if);
                            (* So what is the binding?*)
                            (currentArg[], args[i][]) 
                              -> (E.father.father[]-> enclosingOG[]).addBinding;
                        if)
                    if)
               #)
            #);
          desc::<
            (# elm:: items
            do (if false and traceCheck then
                   '**** Pattern:desc:'->putline;
                     dopt -> puthead
               if);
               (if not isChecked and not beingChecked then 
                   (*'!!! ' -> puttext; sig.doPT -> putline;
                   '** Not checked: ' -> putline;
                   doPT -> puthead;*)
                   (none,origin[],origin[],true) -> check;
               if);
               (if not OG.hasItems (*OD.IS.isEmpty*) then
                   (* V: < A, V::< B, or V:: C *)
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
               (*'**** pattern:desc:GOT:' -> putline;
               (if D[] <> none then
                   D.dopt -> puthead;
                else
                   'none' -> putline
               if);
               '**    OF:'->putline; dopt -> puthead;*)
               inner;
            #);

          isRecursive,isRec: @boolean;
          entity:: (#do OG.entity -> E[] #);
          skind:: (# do ': ' -> S[] #);
          getEntries:: (# do OG.getEntries -> (names[],entries[]) #);
          objDescEQ:: 
            (# 
            do (if trace then 'pattern: ' -> puttext; newline if);
               DN -> OG.objDescEQ -> value;
               (if trace then 
                   'pattern:'->putline; value -> putboolean;
                   dopt -> putline
               if)
            #);
       #);
     ObjectCall::<
       (# setUpOrigin::
            (#
            do (if false then
                   '**** ObjectCall:setUpOrigin:\n' -> puttext; dopP -> putline
               if);
               origin[] -> super.setUpOrigin;
               origin[] -> IS.setUpOrigin;
               (*this(ObjectGenerator)[] -> IS.encOG[];*)
               sig[] -> IS.sig[];
               super[] -> IS.super[]
            #); 
          check::
            (# OG: ^ObjectGenerator
            do (if traceCheck then
                   '**** ObjectCall:check: ' -> puttext; doPT -> putline;
               if);
               (none,basicScope[],none(*basicScope[]*),true) -> super.check;
               L:
                 (if (super.ATD[] <> none) and (super.ATd## <> ModuleItem##) then
                     super.ATd.desc -> IS.superDesc[];
                     L:
                       super.ATd.OG.IS.scanAllDecls
                       (#
                       do (if currentDcl.isVirtual then
                              (if false then
                                  '**** ObjectCall:after:convertOC:'->putline; 
                                  dopt -> puthead;
                                  '**   dcl:' -> putline;
                                  super.Atd.dopt -> puthead
                              if);
                              this(ObjectCall)[] 
                                -> convertObjectCallToGenerator
                                -> OG[];
                              OG.clear;
                              (if false then
                                  '**** OG:check:beforeOG.setUpOrigin:'->putline;
                                  origin.dopt -> puthead;
                                  '**   basicScope:' -> putline; 
                                  basicScope.dopt->puthead;
                              if);
                              origin[] -> OG.setUpOrigin;
                              (if false then
                                  ('**   argScope:',argScope[]) -> putPT;
                              if);
                              (none,basicScope[],none(*argScope[]*),isFirst) -> OG.check;
                              leave L
                 if)#)if)
            #);
          alloc::
            (# E: ^Exp
            do (if false then
                   '**** ObjectCall:alloc: ' -> puttext; dopt -> putline
               if);
               enclIT[] -> super.alloc;

               (if false then
                   (if ((super.last -> E[]) <> none) and (E.ATd[] <> none) then 
                       E[] -> E.ATd.handleArgs 
                   if);
                   (* do we need those below? *)
                   addBinding.checkForVirtualObject;
                   addBinding.checkSuperVariant
               if);
            #);
          setVirtualBindings::
            (# E: ^Exp
            do (if ((super.last -> E[]) <> none) and (E.ATd[] <> none) then 
                   E[] -> E.ATd.handleArgs 
               if);
               addBinding.checkForVirtualObject;
               addBinding.checkSuperVariant
            #);
          getDescNo:: (# do (super.last).ATd.OG.getDescNo -> dNo #)
       #);
     ObjectGenerator::<
       (# setUpOrigin::
            (#
            do origin[] -> super.setUpOrigin;  
               origin[] -> IS.setUpOrigin;
               this(ObjectGenerator)[] -> IS.encOG[];
               sig[] -> IS.sig[];
               super[] -> IS.super[]
            #); 
          checkSuper: booleanValue
            (# checkIfSuperIsCircular: BooleanValue
                 (# D: ^Decl; ptn: ^Pattern
                 enter D[]
                 do followSuper:
                      (if (D[] <> none) and D.isPatternDecl then
                          D[] -> ptn[];
                          (if (ptn.OG[] = this(ObjectGenerator)[]) then
                              true -> value -> circularityInSuper;
                              this(TopNode)[] -> SemanticError
                              (#
                              do 'There is circularity in the super pattern chain : "'
                                   -> msg;
                                 super.doPT -> msg;
                                 '"' -> msg;
                              #);
                           else
                              ptn.OG.super.ATd[] -> D[];
                              restart followSuper
                      if)if)
                 #);
               checkIfSuperIsPattern:
                 (* A unary exp like XXX where XXX is a data-item
                  * is syntactically an ObjectGenerator (Unary)
                  * with XXX as super and empty main-part:
                  * (ObjectGenerator
                  *    (Invocation
                  *       (Unary
                  *          (name:XXX)
                  *          (Arguments)))
                  *    (Items))
                  * We may consider a new syntactic category:
                  * (DataItemRef
                  *    (Invocation
                  *       (Unary
                  *          (name:XXX)
                  *)
                 (#
                 do (if (super.ATd[] <> none) and 
                        (not super.ATd.isPatternDecl and not IS.isEmpty) then
                        this(TopNode)[] -> SemanticError
                        (#
                        do 'Super is not a pattern: "' -> msg;
                           super.doPT -> msg;
                           '"' -> msg;
                        #)                       
                    if)
                 #);
               checkIfSuperIsVirtual:
                 (# ptn: ^Pattern
                 do (if (super.ATd[] <> none) and not IS.isEmpty and 
                        super.ATd.isPatternDecl then
                        super.ATd[] -> ptn[];
                        (if ptn.ptnKind
                         // virtualPtn // furtherPtn then
                            this(TopNode)[] -> SemanticError
                            (#
                            do 'Super cannot be a virtual pattern: "' -> msg;
                               super.doPT -> msg;
                               '"' -> msg;
                            #)                       
                    if)if)
                 #);
               setUpIS:
                 (* A preliminary attempt to setup IS.superDesc before 
                  * finishing checking of super. 
                  * We need to find out how to R.S.foo{...}!
                  * Can we handle R.S.foo? 
                  * R and S are objects - should be able to search for them.
                  * We must consider wheter or not this should be a seperate
                  * scan of the AST!
                  * But what else is check doing?
                  * Binding of virtuals is one issue and search may depend 
                  * of this!
                  * If IS.superDesc is setup here, we should not do it at 
                  * the end of checkSuper!
                  *)
                 (#
                 do (if not IS.isEmpty then
                        super.scanSons
                        (#  E: ^Exp; OI: ^ObjectInvocation; ATdx: ^Decl; 
                           onx,pnx,n: @integer
                        do current[] -> E[];
                           n + 1 -> n;
                           (if E.isObjectInvocation then
                               E[] -> OI[];
                               (OI.ptnId[],true) 
                                 -> basicScope.search -> (ATdx[],onx,pnx);
                               (if islast and (n = 1) and (ATdx[] <> none) then
                                   (*'**** Got:super:ATd:'->puttext; 
                                    ATdx.dopt->puthead;*)
                                   ATdx.oG.Is[] -> IS.superDesc[]
                                else
                                   (*'**** remote super: '->puttext; 
                                   current.dopt->putline;
                                   dopt -> puthead;*)
                               if)
                            else
                               (if E## = ifThen## then
                                   '**** setUpIS:ifThen:'->puttext;
                                   dopt -> puthead
                               if)
                    if)#)if)
                 #);
               basicScope: ^Scope
            enter basicScope[]
            do (if traceCheck then
                   '**** OG:check:super:' -> puttext; super.dopt -> putline
               if);
               (if super.ATd[] = none then 
                   (* else implict super that has been setUp
                    * Or has been called from Pattern:check
                    *)
                   (*setUpIS; -- ChemicalPlantSystem fails" *)
                   (if sig[] = none (*isSingular*) then
                       (* A singular statement:
                        *     bar(a,...) { ... }
                        * isObjectDesc: IS not empty or has virtual arguments
                        * else: just a pattern invocation
                        * Note! isObjectDesc is not defined before super.check 
                        *       has been executed
                        *)
                       (* checkOI fails in call of check if replacing
                        * 2nd basicScope by none
                        *)
                       (none,basicScope[],basicScope[],true) -> super.check
                    else
                       (* A pattern:
                        *     foo(a: ?int, ...): bar(a, ...){ ... } 
                        * where
                        *     super = bar(a,...) 
                        *)
                       (if false then
                           (* pNewFatCommaFile cannot be used to test if this is
                            * a .qbeta-module, since we parse all files
                            * before checking; a boolean is need for each module
                            *)
                           '**** checkSuper:sig<>none: "'->puttext; 
                           super.dopt -> puttext; '"\nsig: ' -> puttext;
                           sig.dopt -> putline
                       if);
                       (none,basicScope[],(*basicScope[]*)sig[],true) 
                         -> super.check
                   if); 
                   checkIfSuperIsPattern;
                   checkIfSuperIsVirtual;
                   (if (super.ATd[] -> checkIfSuperIsCircular) then
                       '!!!! Circulaity in super: ' -> puttext;
                       dopt  -> puthead;
                       true -> value;
                       leave checkSuper
                   if)
                else
                   (*'**   super.ATd<>none: ' -> puttext; 
                   (if sig[] <> none then sig.dopt -> putline if)*)
               if);
               (* we do this too often - perhaps a boolean: superIsChecked *)
               (if super.ATd[] <> none then
                   super.ATd.desc -> IS.superDesc[];
                else
                   objectDecl.desc -> IS.superDesc[];
                   (if IS.superDesc[] = IS[] then
                       none -> IS.superDesc[];
                   if)
               if);                
               (if traceCheck then
                   '**** super:check:end: ' -> puttext; dopt -> putheadn;
                   ('superDesc',IS.superDesc[]) -> putPT;
                   '**   OG:  ' -> puttext; doPT  -> putheadn;
               if);
            #);
          check::
            (# 
            do (if traceCheck then
                   '**** ObjectGenerator:check:\n' -> puttext; 
                   doPT -> putHeadn;
                   (*(' basicScope',basicScope[]) -> putPT;
                   ('origin',origin[]) -> putPT;
                   (if origin[] <> none then
                       ('origin.father',origin.father[]) -> putPT;
                   if)*)
               if);
               (*origin[] -> basicScope[];*)
               (* !!!!!! to fix @if S.exists{... } : then ...*)
               (if basicScope[] -> checkSuper then leave check if);
               (if hasItems or super.hasVirtualArgs then
                   (none,origin[],none(*origin[]*),true) -> IS.check 
               if);
            #);
         
          isObjectDescX: booleanValue
            (* this can be a singular or pattern defined ObjectDesc:
             *    IS.hasItems
             * It can also be an ObjectInvocation with virtual arguments
             *     super.hasVirtualArguments
             * that has to treated as an ObjectDesc
             * And super is not a basic pattern
             *     not super.isPrimitive
             * hasVirtuaArgsX returns false if the Exp in super with 
             * virtual args is primitive
             * See comment in qgenerator.bet::OG:markForCodegen
             *)
            (#
            do hasItems or super.hasVirtualArgsX -> value;
            #);  
          isObjectDesc::
            (* this can be a singular or pattern defined ObjectDesc:
             *    IS.hasItems
             * It can also be an ObjectInvocation with virtual arguments
             *     super.hasVirtualArguments
             * that has to treated as an ObjectDesc
             * And super is not a basic pattern
             *     not super.isPrimitive
             *)
            (#
            do hasItems or (super.hasVirtualArgs and not super.isPrimitive)
                 -> value;
            #);   
          
          
          alloc::
            (# E:^Exp
            do enclIT[] -> super.alloc;
               (if false then
                   addBinding.copySuper;
                   (if ((super.last -> E[]) <> none) and (E.ATd[] <> none) then 
                       E[] -> E.ATd.handleArgs 
                   if);
               if);             
               enclIT[] -> IS.alloc 
            #);
          setVirtualBindings::
            (# E: ^Exp
            do 
               addBinding.copySuper;
               (if ((super.last -> E[]) <> none) and (E.ATd[] <> none) then 
                   E[] -> E.ATd.handleArgs 
               if);
               (if traceGeneric2 then
                   addBinding.display
               if);
               addBinding.checkForVirtualObject;
               addBinding.checkSuperVariant
            #);         
          hasCode:: (# do true -> value #);
          hasVirtualObject: @boolean;

          Xvariants: @
            (# Var: [2] ^Variant; top: @integer; 
               Variant:
                 (* An object representing different variants of a pattern with
                  * virtual patterns qualified by Object as in
                  *    foo(...,V:< Object, ...):
                  *       W:< Object
                  *       ...
                  * V and W may be bound to simple values such as Integer 
                  * or patterns as in 
                  *    foo(...,#Record,...)
                  *       W::< #Integer
                  *       ...
                  * In this case there may be 4 combinations of Value (V) or Reference (R)
                  *    [R,R], [R,V], [V,R], [V,V]
                  * Different code must be generated for Foo for each variant 
                  *)
                 (# vDecl: [2] ^Pattern; (* virtual decls of the form V:< Object *)
                    type: [2] @ integer; 
                    top: @integer;
                    add:
                      (# VD: ^Pattern;
                         T: @integer
                      enter(VD[],T)
                      do (if (top + 1 -> top ) > vDecl.range then
                             vDecl.range -> vDecl.extend;
                             type.range -> type.extend
                         if);
                         VD[] -> vDecl[top][];
                         T -> type[top]
                      #);
                    print:
                      (#
                      do (for i: top repeat                               
                              (if type[i] 
                               // 1 then '   ref:  '->puttext
                               // 2 then '   value: ' -> puttext
                              if);
                              vDecl[i].dopt -> putline
                         for)
                      #)
                 #);
               new:
                 (#
                 do (if (top + 1 -> top) > var.range then
                        var.range -> var.extend
                    if);
                    &Variant[] -> var[top][];
                 exit var[top][]
                 #);
               checkDoublet:
                 (#
                 do (if top > 1 then
                        (for i: top - 1 repeat
                             L:
                               (if var[i].top = var[top].top then
                                   (for j: var[i].top repeat
                                        (if var[i].type[j] <> var[top].type[j] then
                                            leave L
                                   if)for);
                                   (* equal *)
                                   top - 1 -> top;
                                   leave checkDoublet
                               if)
                    for)if)
                 #);
               print:
                 (#
                 do (if (top > 1) then
                        '**** Has variants: ' -> putline;
                        (if sig[] <> none then
                            sig.dopt -> puttext; ':' -> put; newline
                        if);
                        dopt -> putline;
                        (for i: top repeat
                             '--Variant:' -> putline;
                             var[i].print
                        for)
                    if);
                    
                 #);
            #);
          addBB::
            (# bindingType: [2] @integer; (* 0: inner; 1: ref; 2: value *)

               objectInvs: [2] ^ObjectInvocation; oTop: @integer;
               scanBindings:
                 (# currentVdecl: ^Pattern; 
                    currentBindingType: @integer;
                    currentBinding: ^ObjectSpecification;
                    inx: @integer
                 do (for i: vTop repeat
                         i -> inx;
                         vDecl[i][] -> currentVdecl[];
                         bindingType[i] -> currentBindingType;
                         bindings[i][] -> currentBinding[];
                         inner
                    for)
                 #);
               scanObjectInvs:
                 (# current: ^ObjectInvocation
                 do (for i: oTop repeat
                         objectInvs[i][] -> current[];
                         inner
                    for)
                 #);
               copySuper:
                 (# ptn: ^Pattern
                 do (if (superPtn -> ptn[]) <> none then 
                        (* A unary exp like XXX where XXX is a data-item
                         * is syntactically an ObjectGenerator
                         * with XXX as super and empty main-part
                         *);
                        (* 'copySuper:' ->putline; dopt->putline; 
                         *  ptn.OG.addBinding.display; *)
                        (for i: ptn.OG.addBinding.vTop repeat 
                             (*ptn.OG.addBinding.offSets[i] -> putint; ' '-> put;
                              ptn.OG.addBinding.bindingType[i] -> putint; 
                              * newline;
                             (if ptn.OG.addBinding.bindings[i][] <> none then
                                 ptn.OG.addBinding.bindings[i].dopt -> putline;
                              else
                                 'none' -> putline
                             if);*)
                             (if ptn.OG.addBinding.vDecl[i][] <> none then
                                 (ptn.OG.addBinding.vDecl[i][]
                                 ,ptn.OG.addBinding.bindings[i][]) 
                                   -> addBinding
                                 (*else = 0: inner *)
                             if)
                        for);'KOKS'->putline;
                        ptn.OG.addBinding.scanObjectRefs(# do current[] -> addObjRef #)
                    if)
                 #);
               addObjRef: (* apparently called form the olad alloc and thus not
                           * used anymore!?
                           *)
                 (# objRef: ^DataItem
                 enter objRef[]
                 do (if (rTop + 1 -> rTop) > objectRefs.range then
                        objectRefs.range -> objectRefs.extend 
                    if); 'Ping'->putline;
                    objRef[] -> objectRefs[rTop][];
                    true -> hasVirtualObject
                 #);
               addObjectInvocation:
                 (# OI: ^ObjectInvocation
                 enter OI[]
                 do (if (oTop + 1 -> oTop) > objectInvs.range then
                        objectInvs.range -> objectInvs.extend 
                    if);
                    OI[] -> objectInvs[oTop][];
                    true -> hasVirtualObject
                 #);
               checkSuperVariant::
                 (# ptn: ^Pattern; OG: ^ObjectGenerator
                 do (if (superPtn -> ptn[]) <> none then
                        ptn.OG[] -> OG[];
                        (# V: ^ObjectGenerator.Xvariants.Variant
                        do OG.addBinding.scanBindings
                           (# head: @boolean; 
                           do (if (currentBinding[] <> none) then
                                  (if (currentBinding.isObject) then
                                      (if not head then
                                          OG.Xvariants.new -> V[];
                                          (if traceGeneric2 then
                                              '*** Variant: ' -> putline;
                                              doPT -> putline;
                                          if);
                                          true -> head
                                      if);
                                      (if traceGeneric2 then
                                          currentBinding.doPT -> putline;
                                          bindings[inx].doPT -> putline;
                                          bindingType[inx] -> type;
                                          newline
                                      if);
                                      (currentVdecl[],bindingType[inx]) -> V.add
                                  if)                            
                               else
                                  (*'currentBinding is none' -> putline;
                                   * dopt -> putline *)
                              if)
                           #);
                           (if V[] <> none then OG.Xvariants.checkDoublet if);
                        #)
                    if)
                 #);
               checkForVirtualObject::
                 (#
                 do L:
                      (for i: vTop repeat
                           (if bindings[i][] <> none then
                               (if bindings[i].primNo = object_prim then
                                   true -> hasVirtualObject;
                                   (if traceGeneric2 then
                                       '***** HasVirtualObject: ' -> putline; 
                                       (if sig[] <> none then 
                                           sig.doPT -> putline;
                                        else
                                           doPT -> putline;
                                           display
                                   if)if);
                                   leave L
                      if)if)for);
                    checkDataItemAsVirtualObject
                 #);
               checkDataItemAsVirtualObject:
                 (# isVirtualObject: 
                      (# D: ^Decl
                      enter D[]
                      do (if IS[] -> D.markIfVirtualDataItem then
                             (if traceGeneric2 then
                                 'Virtual DataItem: ' -> puttext; D.doPT -> putline;
                             if);
                             D[] -> addBinding.addObjRef
                         if)
                      #);

                    isVirtualObjectInvocation:
                      (* Identify statements where a virtualObject is referred
                       * Foo:
                       *    V:< Object
                       *    S1: ?V
                       *    Bar:
                       *      W:< Object
                       *      R1,R2: ?W
                       *      S2: ?V
                       *      S1 := S2  -- S1 nd S2 are virtual Object
                       *      R1 := R2  -- R1 and R2 ditto
                       *      R.Q       -- R cannot be Object, Q may be
                       *      R.fisk(S) -- R and fisk cannot be Object, S may
                       *      ...
                       *)
                      (# checkIfVirtualObject: 
                           (# OI: ^ObjectInvocation
                           enter OI[]
                           do (*'\n++++ Try: ' -> puttext; OI.dopt -> putline;
                               OI.atd.dopt -> putline;*)
                              (if OI.ATd.hasVirtualObjectQual then
                                  OI[] -> addBinding.addObjectInvocation;
                              if);
                              OI.args.scanArgs
                              (#
                              do current[] -> isVirtualObjectInvocation
                              #)
                           #);                         
                         OS: ^ObjectSpecification;
                         OG: ^ObjectGenerator; OI: ^Invocation
                      enter OS[]
                      do (if (OS## = ObjectGenerator##)then
                             OS[] -> OG[];
                             (if not OG.isObjectDesc then
                             (*(if (OG.super[] -> OI[]) <> none then*)
                                 (*'\n*** isVirtualObjectInvocation: ' 
                                  -> puttext;*)
                                 OG.super.scanSons (*OI.scanSons*)
                                 (# 
                                 do (if current.isObjectInvocation then 
                                        current[] -> checkIfVirtualObject
                                    if)
                                 #);
                                 (*newline*)
                             (*if);*)
                         if)if)
                      #);
                 do IS.scanSons
                    (# I: ^Item
                    do current[] -> I[]; 
                       (if true 
                        // I.isDecl then
                           I[] -> isVirtualObject 
                        // I.isObjectGenerator then
                           I[] -> isVirtualObjectInvocation
                    if)#);
                 #);
               valueOrObject::
                 (#
                 do '***** ObjectGenerator:ValueOrObject:'->putline;
                    dopt -> putline;
                    display;
                    (for i: vTop repeat
                         (if vDecl[i][] = ptn[] then
                             'bound to: ' -> puttext;
                             bindingType[i] -> type; newline;
                             bindings[i].dopt -> putline;
                             bindingType[i] -> value
                         if)
                    for);
                    (for i: rTop repeat
                         'Decl: ' -> puttext;
                         objectRefs[i].dopt -> putline
                    for)
                 #);
               type:
                 (# T: @integer
                 enter T
                 do  (if T
                      // 0 then ' inner: ' -> puttext;
                      // 1 then ' ref: ' -> putline
                      // 2 then ' value: ' -> putline;
                      else 
                         '  ???' -> putline
                     if);
                 #);
               display:
                 (# T: ^Text
                 enter T[]
                 do (if vTop > 0 then
                        T[] -> puttext; 
                        '*** Bindings: descNo: ' -> puttext; 
                        IS.descNo -> putint; newline; (* dont use descNo *)
                        (for i: vTop repeat
                             i -> putint; ':' -> put;
                             vDecl[i].doPT -> putline;
                             vDecl[i].off -> putint; ':'->put;
                             bindingType[i] -> type;
                             (if bindings[i][] <> none then
                                 bindings[i].doPT -> putline
                              else 
                                 'none'->putline
                             if)
                    for)if)
                 #)      

            do (if handleGeneric then
                   (if VD.off > vTop then
                       VD.off - bindings.range + 2-> bindings.extend;
                       VD.off - bindingType.range + 2-> bindingType.extend;
                       VD.off - vDecl.range + 2 -> vDecl.extend;
                   if);
                   (if false then
                       '**** AddBB: VD.off: ' -> puttext; VD.off -> putint;
                       ' vTop: ' -> puttext; vTop -> putint;
                       ' vDecl.range: ' -> puttext; vDecl.range -> putint; 
                       ' VD.isChecked: ' -> puttext; VD.isChecked -> putBoolean;
                       newline;
                       VD.doPt -> putline;
                   if);
                   (if VD.off = 0 then 
                       vd.dopt -> putline;
                       (dumpStack,'VD.off = 0') -> stop
                   if);
                   (if VD.off > vTop then VD.off -> vTop if);
                   VD[] -> vDecl[VD.off][];
                   (if false then
                       'Add:' -> puttext; E.doPT -> puttext; 
                       ' ' -> put; VD.off -> putint;
                       ' ' -> put; E.primNo -> putint; newline;
                    if);
                   (if  (BindingType[VD.off] > 0) then
                       (if false then
                           '---addbinding:overwrite: ' -> puttext;
                           VD.off -> putint; ' ' -> put; E.doPt -> putline;
                           '   was: ' -> puttext;
                           bindingType[VD.off] -> putint; ' ' -> put;
                           bindings[VD.off].dopt -> putline;
                       if)
                   if);
                   (if E.primNo // integer_prim then 
                       (*'--value--'->putline;*)
                       2 -> bindingType[VD.off]
                    else 
                       1 -> bindingType[VD.off]
                   if);
                   E[] -> bindings[VD.off][];
               if);
            #);
          getNameForOff::
            (#do (attOff,descNo,isRef,isIndexed) -> IS.getNameForOff -> NM[] #);
          getDescNo:: 
            (# ptn: ^Pattern
            do (if (IS.QdescNo[1] -> dNo) = 0 then
                    (* Virtual bindings like DD in V ::< DD *)
                    (if (superPtn -> ptn[]) <> none then
                        ptn.OG.getDescNo -> dNo
                    if)
               if)
            #);
          objDescEq:: 
            (# 
            do (if trace then 'OG: ' -> puttext; newline if);
               DN -> IS.objDescEq -> value;
               (if trace then
                   'OG:' -> puttext; value -> putBoolean;
                   doPT -> putline
               if)
            #);
          clear::<
            (#
            do 0 -> vDescNo -> xVariants.top;
               inner
            #)
       #);
     Invocation::<
       (* INV = R.Q.X, where R,Q,X: exp, R,Q may be data-item or patter*)
       (# setupOrigin:: 
            (#do scanSons(#do origin[] -> current.setUpOrigin #)#);
          check::
            (# E: ^Exp; OGS: ^OGsequence; lastMIa: ^ObjectInvocation;
               emitUnits:
                 (# i: @integer; U: ^text
                 enter(i,E[],U[])
                 do (if false and (U[] <> none) then
                        (if i = 1 then
                            '**** INV:units:OF:'->puttext; dopt -> putline;
                        if);
                        '**   INV::i='->puttext; i -> putint;
                        ' ' ->put; E.dopt -> puttext;
                        ' unit:'->puttext; U[] -> putline;
                 if)#)
            do (if (trx) or traceCheck then
                   '**** Invocation:check: ' -> puttext; doPT -> putheadn;
               if);
               scanSons
               (# i: @integer;
                  emit:
                    (# i: @integer
                    enter i 
                    do (if trx then
                           '**** INV:check:i=' -> puttext; i -> putint;
                           ' ' -> put; rec.dopt -> puttext;
                           ' label: ' -> puttext; current.label -> putline
                       if)
                    #);
                  ap: ^Apl; 
               do i + 1 -> i; i = 1 -> isFirst;
                  (if i > 1 then i - 1 -> emit if);
                  inModulePropX -> (current[] -> ap[]).inModulePropX;
                  (* Given: X: {...; R.foo(e1).bar(e2).x; ...}
                   * the scope for foo is R, but the scope for e1 is X
                   * the scope for bar is foo, but X for e2
                   *)
                  (rec[],basicScope[],argScope[],isFirst,OGS[]) 
                                     (**********)
                    -> current.checkOI
                    -> (basicScope[],OGS[]);
                  (if isLast and (basicScope[] <> none) then
                      (if true then
                          basicScope.OGofScope -> theQual[]
                       else
                          basicScope.father[] -> theQual[];
                      if);
                  if);
                  current[] -> rec[];
                  (if (rec.ATD[] <> none) and rec.ATd.isModuleItem then
                      rec[] -> lastMIa[]
                  if);
                  (if isLast then
                      (* can be Exp with args or a pattern name (#foo) *)
                      rec.ATd[] -> ATd[];
                      rec.on -> on;
                      (* we keep track of the last MI:
                       *    R.S.MI.foo
                       * If R, S and MI are moduleItems, 
                       * then MI must be %required.
                       * R and S do not have to be required.
                       *)
                      i -> lgth;
                      (if i > 1 then i -> emit if)
                  if);
               #);   
               (if lastMIa[] <> none then true -> lastMIa.isModuleItem if);
               scanSons
               (# i: @integer; E: ^Exp
               do i + 1 -> i;
                  (i,(current[]->E[]),E.expUnit[]) -> emitUnits
               #);
            #);
          alloc:: 
            (# 
            do scanSons(# do enclIT[] -> current.alloc #)
            #);
       #);

     ObjectInvocation::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> ptnId.setUpOrigin; 
               origin[] -> args.setUpOrigin
            #);
          checkOI::
            (# BS: ^Scope
            do (if (trx) or traceCheck or traceGetVqual then
                   '**** ObjectInvocation:checkOI: '->puttext;
                   dopt->puthead; ' ' -> put;
                   ' isFirst:'->puttext; isFirst -> putBoolean; newline
               if); 
               (rec[],basicScope[],none(*argScope[]*),isFirst) 
                 -> check 
                 -> basicScope[];
               (if ATd.primNo 
                // this_prim then
                   (* ad hoc - must be fixed *)
                   (# A: ^Item
                   do args.scanArgs(# do current[] -> A[] #);
                      (if true then
                          (none,basicScope[],none(*basicScope[]*),true) -> A.check;
                       else
                          (none,argScope[],argScope[],true) -> A.check;
                      if);
                      A.desc -> basicScope[];
                   #)
                // indexedGet_prim then
                   basicScope[] -> BS[];
                   father.scanSons
                   (# pred: ^node; OI: ^ObjectInvocation; DI: ^DataItem; 
                      E: ^Exp; OG: ^ObjectSpecification; ptn: ^Pattern; 
                      encOG,qual: ^ObjectGenerator;
                   do (if current[] = this(ObjectInvocation)[] then
                          (if pred[] <> none then
                              pred [] -> OI[];
                              OI.ATd[] -> DI[];
                              DI.OG.super.last -> E[];
                              (if E.args[] <> none then
                                  E.args.scanArgs(#do current[] -> OG[] #);
                                  (if OG[] <> none then
                                      OG.super.last-> OI[];
                                      (if not oi.isChecked then
                                          (none,basicScope[],argScope[],true)
                                            -> OI.check;
                                      if);
                                      (if OI.ATd[] = none then
                                          'OI.atd is none'->putline;
                                      if);
                                      (OI.ATd[]->ptn[]).OG.IS[] 
                                        -> basicScope[]
                      if)if)if)if);
                      (* here we must use argScope - else semantioc errors
                       * and BS does neither work
                       *)
                      (args[],argScope[]) -> argBuf.add;
                      current[] -> pred[];
                      (if isFirst then
                          origin.father[] -> encOG[]
                       else
                          BS.father[] -> encOG[]
                      if);
                      (encOG[],not isFirst,OGS[]) 
                        -> getVqual -> (OGS[],qual[]);
                   #)              
                else
                   (if false and 
                       (argScope[] <> basicScope[]) and (argScope[] <> none) then
                       '**** argScope differs:' -> putline;
                       (if argScope[] = none then 'none' -> putline
                        else
                           argScope.dopt->puthead;
                       if);
                       '**   basicScope:' -> putline; basicScope.dopt->puthead;
                   if);
                   (args[],argScope[]) -> argBuf.add;  
                   (* ok if static/dynamicObject - what does
                    * this mean?
                    * If pattern, scope is the desc of the return value
                    * ATd.desc <> none is before we used getQual 
                    * - can be eliminated
                    *)
                   (* Calling this(ObjectInvocation).getV_ qual *)
                   basicScope[] -> BS[];
                   (# encOG,qual: ^ObjectGenerator; org: ^Scope; 
                      ptn: ^Pattern; isArgToSuper: @Boolean
                   do (if false then
                          '**   checkOI:BS:' -> puttext; BS.label -> puttext;
                          ' origin: ' -> puttext; origin.label -> puttext;
                          ' origin.father: ' -> puttext; 
                          origin.father.label -> putline; 
                          '**   ATd: ' -> puttext; ATd.dopt -> putline;
                          '**   ATd.origin: ' -> puttext; 
                          ATd.origin.label -> putline;
                          ATD.origin.dopt -> putline;
                          ATD.origin.father.dopt -> putline;
                      if);
                      (if 'Signature' -> (ATd.origin.label).equalNCS then
                          (* Here we check for the situation where 
                           * thisOI = Xa in foo(Xa) and declared as Xd
                           *    bar(Xd: var Integer): foo(X){...}
                           * The condition is
                           *    Xd is a parameter of a pattern P
                           *       true if Xa.ATd.origin = Signature of P
                           *    Xa appears in super of P.OG
                           * In this case, encOG as passed of getVqual below
                           * is P.OG and not origin.encOG.
                           * We have not considered the case of not first below!
                           * This is a preliminary solution - we should 
                           * reconsider the notion of scope and origin.
                           *)
                          ATd.origin.father[] -> ptn[];
                          ptn.OG.super.scanSons
                          (# E: ^Exp;
                          do current[] -> E[];
                             (if E.args[] <> none then 
                                 E.args.scanArgs
                                 (#
                                 do (if current[] 
                                        = this(ObjectInvocation).father.father[]
                                        then
                                        (if false then
                                            '**   OI:checkOI:found:arg: ' 
                                              -> puttext; 
                                            current.dopt -> putline;
                                        if);
                                        true -> isArgToSuper;
                      if)#)if)#)if);                  
                      
                      (if isFirst then
                          (if true then
                              (if isArgToSuper then
                                  ptn.OG[] -> encOG[]
                               else
                                  (origin[]->org[]).encOG[] -> encOG[];
                              if);
                           else
                              origin.father[] -> encOG[]
                          if)
                       else
                          (if traceGetVqual then
                              '**** computing:encOG:BS.father=encOG:'
                                -> puttext; 
                              BS.father.dopt -> putheadN;
                          if);
                          (* BS = BasicScope
                           * For INV = R.X.Y, 
                           * R = BS for X, since  X is defined in R
                           *)
                          BS.father[] -> encOG[]
                      if);
                      (if traceGetVqual then
                          '**** encOG:' -> puttext; 
                          encOG.dopt -> putheadn;
                      if);
                      (encOG[],not isFirst,OGS[]) 
                        -> getVqual 
                        -> (OGS[],qual[]);
                      (if trx then
                          '**** checkOI:getVqual:GOT: ' ->puttext;
                          ptnID.dopt ->putline;
                          '**** qual:'->putline;
                          qual.dopt -> putheadN;
                          '**** OGS:'->putline;
                          OGS.print
                      if);
                      qual.IS[] -> basicScope[];
                      (if trx then
                          '**** checkOI:after:getVqual:OF: ' -> puttext;
                          ptnID.dopt -> puttext; ' qual:'->putline;
                          qual.dopt -> puthead;
                          '**** OGS:'->putline;
                          OGS.print;
               if)#)if);
               (if trx then 
                   '**** next:basicScope:from:' -> puttext;
                   ptnID.T[] -> putline; basicScope.dopt -> puthead;
               if)
            #);
          hasVirtualArgs: @boolean;
          check::
            (# elm:: Items;
               checkIfOneBasic:
                 (* not clear what happens here!?
                  * we check if scp has exactly one DataItem like
                  *    X: var float
                  * and the float is searched in scp
                  * Perhpas to ensure that Float in magnintude: var Float
                  * has and ATd in Dimension.Unit and supatterns of Unit!?
                  *)
                 (# scp: ^Items; n: @integer; DI: ^DataItem; dcl: ^Decl
                 enter scp[]
                 do (*'**** checkIfOneBasic: ' -> puttext; dopt->putline;*)
                    scp.scanAllDecls
                    (#
                    do (if currentDcl.isDataItem then
                           n + 1 -> n;
                           currentDcl[] -> DI[];
                       if);
                    #);
                    (if n = 1 then
                        (*'**** Got:DI: ' -> puttext; DI.dopt -> putline;*)
                        (if DI.OG.IS.isEmpty 
                            and 
                            (((DI.OG.super.last).ATd[]->dcl[]) <>none) then
                            (* dcl[] = none may happen in e.g.
                             *    ind : var intEEger
                             * where intEEger is not declared
                             *)
                            dcl.OG.IS[] -> scp[]; 
                            ptnId.T[] -> scp.localSearch -> (ATd[],pn);
                    if)if)
                 #);
               org: ^Scope; OGq: ^ObjectGenerator; done: @boolean;
               ptn: ^Pattern; MD: ^Module; MI: ^ModuleItem;
               OS: ^objectSpecification;
            do (if trx or traceCheck then
                   '**** ObjectInvocation:check: '->puttext; dopt->putline;
                   (* ptnID.T[] -> putline;*)
                   (*('scope',basicScope[]) -> putPT*)
               if);
               (if basicScope[] <> none then (* ad hoc *)
                   (*basicScope.dopt ->puthead;*)
                   (ptnId[],isFirst) -> basicScope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       on -> ptnId.on; (* just for debugging *)
                       (ptnId[],on,pn,ATd[]) -> found;
                       ATd[] -> ptnId.ATd[];
                       (none,ATd.origin[],ATd.origin[],true) -> ATd.check;
                    else
                       (if false then
                           '**** OI:check:notFound: ' -> puttext;
                           ptnId.dopt -> putline;
                           basicScope.doPt -> putline;
                       if);
                       (if basicScope## = Items## then
                           basicScope[] -> checkIfOneBasic;
                       if);
                       (if ATd[] <> none then
                          (* '**** found: ' -> putline;
                           ATd.doPT -> putline*)
                        else
                           this(TopNode)[] -> SemanticError
                           (#
                           do 'Did NOT find a declaration of: "'-> msg;
                              ptnId.T[] -> msg;
                              '"' -> msg;
                           #);
                           errorDecl[] -> ATd[]
                   if)if); 
                   this(Exp)[] -> ATd.checkVirtualArgs -> hasVirtualArgs;
                else
                   'ObjectInvocation:check: scope is none: '->puttext; 
                   dopt -> putline
               if);
            #);
          checkRequires::
            (# MI: ^ModuleItem
            do (if false then
                   '**** OI:checkRequires: ' -> puttext;
                   dopt -> puttext; ' ' -> put;
                   father.father.father.dopt -> putline;
               if);
               (if ATd[] = none then
                   '!!!! OI:checkRequires:ATd:NONE ' -> puthead;
                   true -> done;
                   leave checkRequires;
               if);
               (if isModuleItem then
                   ATd[] -> MI[];
                   (if false then
                       '**** Got:moduleItem: ' -> puttext;
                       ptnId.dopt -> puttext;
                       ' ' -> put;
                       inModulePropX -> putboolean;
                       newline;
                       father.father.father.dopt -> puthead;
                       (theModule).requires.print
                   if);
                   
                   (if not inModulePropX 
                       and not (MI.MD[]->(theModule).requires.has) then
                           this(objectInvocation)[] -> warning
                           (#
                           do 'The module "' -> msg;
                              ptnId.T[] -> msg;
                              '" cannot be accessed;\n     must be'
                              ' listed in a %requires property' -> msg
                           #)
               if)if);
               true -> done
            #);
          isModuleItem: @boolean;
          mustBeObject::
            (# error:
                 (#
                 do true -> value;
                    this(ObjectInvocation)[] -> Semanticerror
                    (#
                    do 'must be a data-item: ' -> msg;
                       dopt -> msg
                    #)
                 #);               
               ptn: ^Pattern; D: ^Decl
            do (*'**** mustBeObject: ' -> puttext; dopt -> putline;*)
               (if (ATd[] -> D[]) <> none then
                   L:
                     (if true 
                      // D.isDataItem // D.isModuleItem then
                         (* OK *)                       
                      // D.isPattern then
                         (*'**   mustBeObj:'->puttext; dopt -> putline;*)
                         (D[] -> ptn[]).getReturnDecl -> D[];
                         (if D[] = none then 
                             (if true then
                                 (* Problem here with e.g. 
                                  *  B := (@this String = S)
                                  * Seems to parse as (@this (String = S))
                                  *)
                                 error
                             if)
                         else 
                             restart L
                         if)
                      else
                         error
               if)if)
            #);
          alloc:: 
            (# org: ^Items
            do (if ATd[] = none then 
                   'ATd is none: '->puttext; label -> puttext; ' ' -> put;
                   father.label -> puttext; ' ' -> put;
                   father.father.label -> puttext; ' ' -> put;
                   ' Father.father: ' -> putline;
                   father.father.doPT-> putline; 
               if);
               (*'\nalloc:ATd.isinner: ' -> puttext; label -> putline;
               dopt -> putline;*)
               
               (if (enclIT[],args[]) -> ATd.isInner then
                   (if false then
                       '**   inner:'->puttext; on -> putint; ' ' -> put;
                       label -> puttext; ' ' -> put; dopt -> putline;
                       'father: ' -> puttext; father.label -> puttext; 
                       ' father.father: ' -> puttext;
                       father.father.label -> putline;
                       origin[] -> org[];
                       (for i: on repeat
                            org.origin[] -> org[];
                            '**   origin: ' ->putline;
                            org.doPT -> puthead;
                       for)
               if)if);
               (if (ATd[] <> none) and (ATd.isPattern) 
                   and (ATd.OG.primNo = inner_prim) then
                   (*'**** OI:alloc: ' -> puttext; dopt -> putline*)
                else                   
                   scanSons(#do enclIT[] -> current.alloc #);
               if);
               (*'handleArgs'->puttext; dopt->putline;*)
               (* this(Exp)[] -> ATd.handleArgs *)
            #);
          hasVirtualObjectQual: @boolean;
       #);
     IfThen::<
       (# setUpOrigin::
            (#
            do origin[] -> cond.setUpOrigin;
               origin[] -> thenPart.setUpOrigin;
            #);
          alloc:: (#do scanSons(#do enclIT[] -> current.alloc #)#);
          check::
            (#
            do (if traceCheck then
                   '**** IfThen: ' -> puttext; dopt -> putline
               if);
               (none,basicScope[],none(*argScope[]*),true) -> cond.check;
               (none,basicScope[],none(*argScope[]*),true) -> thenPart.check;
               ifThenDecl[] -> ATd[]
            #);
          checkOI::
            (#
            do (if false then
                   '*** checkOI: ' -> puttext; dopt -> putline;
               if);
               (rec[],basicScope[],argScope[],isFirst) 
                 -> check 
                 -> basicScope[];
            #)
       #);
     IfThenElse::<
       (# setUpOrigin::
            (#
            do origin[] -> cond.setUpOrigin;
               origin[] -> thenPart.setUpOrigin;
               origin[] -> elsePart.setUpOrigin;
            #);
          check::
            (#
            do (if traceCheck then
                   '**** IfThenElse:check:' -> putline; dopt -> puthead;
               if);
               (none,basicScope[],none(*argScope[]*),true) -> cond.check;
               (none,basicScope[],none(*argScope[]*),true) -> thenPart.check;
               (none,basicScope[],none(*argScope[]*),true) -> elsePart.check;
               ifThenDecl[] -> ATd[]
            #);
          checkOI::
            (#
            do (if false then
                   '*** checkOI: ' -> puttext; dopt -> putline;
               if);
               (rec[],basicScope[],argScope[],isFirst) 
                 -> check 
                 -> basicScope[];
            #);
          alloc:: (#do scanSons(#do enclIT[] -> current.alloc #)#);
       #);
     BracketedExp::<
       (# setUpOrigin:: 
            (# 
            do (if false then
                   '**** BracketedExP:setUpOrigin:noOfSons: ' -> puttext; 
                   noOfSons -> putint;  ' ' -> put;
                   doPT -> putline;
                   '**   origin: ' -> putline; origin.doPT -> putline
               if);
               (if noOfSons = 1 then
                   origin[] -> IV.setUpOrigin 
                else                   
                   scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          checkOI::
            (# 
            do (if traceCheck then
                   '**** BracketedExP:checkOI:noOfSons: ' -> puttext; 
                   noOfSons -> putint;  ' ' -> put;
                   doPT -> putline;
                   '**   basicScope: ' -> puttext; basicScope.dopt -> putline
               if);
               (if noOfSons = 1 then
                   (rec[],basicScope[],argScope[],isFirst) 
                     -> IV.check -> basicScope[];
                   (* Note: we do not assign basicScipe below! *)
                else
                   scanSons
                   (#
                   do (rec[],basicScope[],argScope[],isFirst) -> current.check 
               #)if);
               IV.ATd[] -> ATd[];
               IV.on -> on
            #); 
          check:: 
            (# 
            do (if traceCheck then
                   '**** BracketedExP:check: ' -> puttext; doPT -> putline;
                   '**   basicScope: ' -> puttext; basicScope.dopt -> putline
               if);
               (if noOfSons = 1 then
                   (rec[],basicScope[],argScope[],isFirst) 
                     -> IV.check -> basicScope[];
                else
                   scanSons
                   (#
                   do (rec[],basicScope[],argScope[],isFirst) -> current.check 
               #)if);                 
               IV.ATd[] -> ATd[];
               IV.on -> on
            #);
          alloc:: (# do enclIT[] -> IV.alloc #)
       #);
     const::<
       (# checkOI:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #);
          check:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     floatConst::<
       (# checkOI:: (# do floatDecl[] -> ATd[]; ATd.desc -> basicScope[] #);
          check:: (# do floatDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);          
     charObj::<
       (# checkOI:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #);
          check:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     stringObj::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          checkOI::
            (#
            do  scanSons
               (# B: ^Scope
               do 
                  (rec[],basicScope[],argScope[],true) 
                    -> current.check -> B[];
               #);
               stringDecl[] -> ATd[]; ATd.desc -> basicScope[];
            #);
          check:: 
            (# 
            do scanSons
               (# B: ^Scope
               do 
                  (rec[],basicScope[],argScope[],true) 
                    -> current.check -> B[];
               #);
               stringDecl[] -> ATd[]; ATd.desc -> basicScope[];
            #)
       #);
     mkSig:
       (# trace: (# exit false#);
          equal: BooleanValue
            (# subSig: ^mkSig
            enter subSig[]
            do (if trace then
                   '**** mkSig:equal:top:' -> puttext; 
                   subSig.top->putint; newline;
                   subSig.theOG.dopt -> putline;
                   '**   theOG:top:' -> puttext; top -> putint; newline;
                   theOG.dopt -> putline;
               if);
               L:
                 (if (top = subSig.top) and isSig then
                     true -> value;
                     (for i: top repeat
                          (if trace then
                              (subSig.inArgs[i].OG.getqual).dopt -> putline;
                              (inArgs[i].getQual).dopt -> putline;
                              '---'->putline;
                          if);
                          (if not (subSig.inArgs[i].OG.getqual
                              (*<> inArgs[i].getQual then*)
                                -> (inArgs[i].getQual).inSuper) then
                              false -> value;
                              leave L
                     if)for);
                     (if (subSig.outArg[] <> none) and (outArg[] = none) then
                         false -> value;
                         leave L
                     if);
                     (if (subSig.outArg[] = none) and (outArg[] <> none) then
                         false -> value;
                         leave L
                     if);
                     (if (subSig.outArg[] = none) and (outArg[] = none) then
                         leave L
                     if);
                     (if subSig.outArg.getQual <> outArg.getQual then
                         false -> value
                     if)
                 if)
            #);
          inArgs: [3] ^Decl; top: @integer; 
          outArg: ^Decl; isSig,hasOther: @boolean;
          theOG: ^ObjectGenerator
       enter theOG[]
       do theOG.IS.scanSons (* must also scan items of super - can be non-singular*)
          (# D: ^Decl
          do (if current.isDecl then
                 (if false then
                     '**   dcl:' -> puttext; current.dopt -> puttext;
                 if);
                 current[] -> D[];
                 (if true
                  // D.isInarg then
                     (if (top + 1 -> top) > inArgs.range then
                         inArgs.range -> inArgs.extend;
                     if);
                     D[] -> inArgs[top][]
                  // D.isOutArg then
                     D[] -> outArg[]
                  else
                     true -> hasOther
                 if)
              else
                 true -> hasOther
             if);
          #);
          not hasOther and ((top > 0) or (outArg[] <> none)) -> isSig;
          (if false then
              (if isSig then
                  '**   is signature' -> putline
               else
                  '**   is not signature' -> putline
          if)if)
       exit this(mkSig)[]
       #);
     found:
       (# inSame: booleanValue
            (# dclOrigin,aplOrigin: ^Items
            enter dclOrigin[]
            do ptnId.father.father.origin[] -> aplOrigin[];
               (if false then
                   '**** dclOrigin: ' -> putline; dclOrigin.dopt -> putline;
               if);
               Loop:
                 (#
                 do (if false then
                        '**** aplOrigin: ' -> putline; aplOrigin.dopt -> putline;
                    if);
                    inner inSame;
                    (if not value then
                        (if (aplOrigin.origin[] -> aplOrigin[]) <> none then
                            restart Loop
                 if)if)#)
            #);
          inSameOrigin: inSame
            (#
            do dclOrigin[] = aplOrigin[] -> value
            #);
          inSubOfSameOrigin: inSame
            (#
            do aplOrigin.enclosingObjectGenerator
                 -> (dclOrigin.enclosingObjectGenerator).inSuper 
                 -> value
            #);
          checkAccesability:
            (# 
            do (if ATd.accesslevel <> acc_public then
                   (if MDcall[] = MDdcl[] then (* in same domain *)
                       (if ATd.accesslevel = acc_private then
                           (if not (ATd.origin[] -> inSameOrigin) then
                               ptnId[] -> warning
                               (#
                               do 'Attribute is not accessible: ' -> msg;
                                  ptnID.dopt -> qmsg;
                                  '\n     Must be in same enclosing ' -> msg;
                                  'object descriptor as the declaration' -> msg
                               #)
                       if)if)
                    else (* in different domains *)
                       (if ATd.accesslevel 
                        // acc_private // acc_domain then
                           ptnId[] -> warning
                           (#
                           do 'Attribute is not accessible: ' -> msg;
                              ptnID.dopt -> qmsg;
                              '\n     CallerDomain: ' -> msg;
                              MDcall.sig.dopt -> qmsg;
                              ' DeclDomain: ' -> msg;
                              MDdcl.sig.dopt -> qmsg;
                           #);
                        // acc_publicInSub then
                           (if not (ATd.origin[] -> inSubOfSameOrigin) then
                               ptnId[] -> warning
                               (#
                               do 'Must be in subpattern of decl pattern: '
                                    -> puttext;
                                  ptnID.dopt -> putline     
                               #)
               if)if)if)if)
            #);
          ptnId: ^Name; on,pn: @integer; ATd: ^Decl; MDcall,MDdcl: ^Module;
          trx2: @boolean; T: ^text
       enter(ptnId[],on,pn,ATd[])
       do ptnId.enclosingDomain -> MDcall[];
          ATd.enclosingDomain -> MDdcl[];
          (if MDcall[] <> MDdcl[] then
              (if false then
                  '*** In different domains: ' -> puttext;
                  ptnId.T[] -> puttext; ' caller: ' -> puttext;
                  MDcall.sig.dopt -> puttext;
                  ' dcl: ' -> puttext; MDdcl.SIG.dopt -> putline
              if)
          if);

          (if trx or traceSearch then
              '**** Found: "' -> puttext; ptnId.T[] -> puttext; 
              '" on=' -> puttext; on -> putint;
              ' pn=' -> puttext; pn -> putint;
              ' Decl: "' -> puttext; ATd.sig.doPT -> puthead; 
              '" visibility: '->puttext;
              (if ATd[] <> none then                  
                  (if ATd.accessLevel
                   // acc_domain then '"domain"' -> puttext;          
                   // acc_public then '"public"' -> puttext;
                   // acc_publicInSub then '"publicInSub"' -> puttext;
                   // acc_private then '"private"' -> puttext;
                  if);
              if);
              '\n**   encModule: "'->puttext; MDcall.sig.dopt -> puttext;
              '" domainModule: "' -> puttext; MDdcl.sig.dopt->puttext; '"'->put;
              newline;
          if);
          (if trx2 then checkAccesability if);
       #);

     newDesc: @
       (# OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;
          getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectGenerator
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     BaseVector:
       (# theBase: [8] @integer;  (* [8] is Dimension, just technical*)
          convFactor: @Real;
          add:
            (# BV: ^BaseVector
            enter BV[]
            do (for i: 7 repeat 
                    theBase[i] + BV.theBase[i] -> theBase[i]
               for);
               BV.convFactor * convFactor -> convFactor
            #);
          minus:
            (# BV: ^BaseVector
            enter BV[]
            do (if false then
                   '**** BaseVector: left:' -> putline;
                   print;
                   '**   right: ' -> putline;
                   BV.print
               if);
               (for i: 7 repeat 
                    theBase[i] - BV.theBase[i] -> theBase[i]
               for)
            #);
          mult:
            (# C: @integer
            enter C
            do (for i: 7 repeat 
                    theBase[i] * C -> theBase[i]
               for)
            #);
          equal: BooleanValue
            (# BV: ^BaseVector;
               nonMatchingCV:< (# do inner #);
            enter BV[]
            do true -> value;
               (for i: 7 repeat 
                    (theBase[i] = BV.theBase[i]) and value -> value
               for);
               (if false and (BV.convFactor <> convFactor) then
                   '!!!! Conversion factors differ: ' -> putline;
                   'source: ' -> puttext; BV.print -> putline;
                   'destination: ' -> puttext; print -> putline;
                   nonMatchingCV
               if)
            #);
          rootN:
            (* In general we have a unit "u"^(left,right)
             * where left  = 1 and right is a positve integer
             * like "m*m"^(1/2), "m*m*m"^(1/3) or similar
             * 
             * all base units in the vector must be a multiply
             * of right or zero
             *)
            (# rootNerror:< 
                 (# M: ^text
                 enter M[]
                 do inner
                 #);
               numerator,denumerator: @integer
            enter(numerator,denumerator)
            do (if true then
                   '**** baseVector:rootN:'->puttext;
                   numerator -> putint; ' ' -> put; denumerator -> putint;
                   newline;
               if);
               (if numerator <> 1 then
                   'numerator is not 1 (one)' -> rootNerror
               if);
               (for i: 7 repeat
                    (if (theBase[i] mod denumerator) = 0 then
                        theBase[i] div denumerator -> theBase[i]
                     else
                        'value of a base unit is not a multiply of the denumerator'
                        -> rootNerror
               if)for);
               (*print*)
            #);
          print:
            (# T: @text
            do 'Cnv[' -> T.puttext; convFactor -> T.putReal; ']' -> T.put;
               (for i: 7 repeat
                    (if i 
                     // TimeInx then 'Time[' -> T.puttext
                     // LengthInx then 'Lgth[' -> T.puttext
                     // MassInx then 'Mass[' -> T.puttext
                     // ElectInx then 'Elec[' -> T.puttext
                     // TempInx then 'Temp[' -> T.puttext
                     // SubstanceInx then 'Subs[' -> T.puttext
                     // LuminousInx then 'Lumn[' -> T.puttext
                     else
                        'Inx = ' -> T.puttext;  i -> T.putint; ':' -> T.put
                    if);
                    theBase[i] -> T.putint; ']' -> T.put
               for);
               T.newline
            exit T[]
            #)
       #);     
     TimeInx: (# exit 1 #);
     LengthInx: (# exit 2 #);
     MassInx: (# exit 3 #);
     ElectInx: (#exit 4 #);
     TempInx: (#exit 5 #);
     SubstanceInx: (#exit 6 #);
     LuminousInx: (#exit 7 #);
     unitTable: @
       (# unitElm:
            (# dim: ^Decl; 
               isBaseDim: @boolean;
               unit: ^Pattern;
               isBaseUnit: @boolean;
               US: [5] ^Text; UStop: @integer;
               convFactor: @real;
               prop: ^NewProperty;
               baseInx: @integer; (* if base unit, index into baseVector *)
               decodeProp:
                 (# n: @integer; dimN: ^text; UT: ^UnitTree; BV: ^BaseVector
                 do prop.args.scanSons
                    (# INV: ^Invocation; 
                    do current[] -> INV[];
                       INV.scanSons
                       (# C: ^lexem
                       do (*current.dopt -> puttext; ',' -> put;*)
                          current[] -> C[];
                          (if true 
                           // current.isStringLiteral then
                              UStop + 1 -> UStop;;
                              C.T.copy -> US[UStop][];
                           // current.isConstLiteral then
                              n + 1 -> n;
                              C.T.setPos; C.T.getReal -> convFactor
                    if)#)#);
                    (if traceUE then
                        UStop -> putint; ' ' -> put; n -> putint;
                    if);
                    (* a base dimension has a form like
                     *    %unit "m", i.e only one unit
                     * a derived dimension has a form like
                     *    %unit "MpS", "m*s^-1", "m/s", 1
                     *        i.e. also a defintion in the form of other units 
                     *        and a conversitaion factor of 1 (one)
                     *)
                    UStop = 1 -> isBaseDim;
                    (if traceUE and isBaseDim then
                        ' base dimension '->puttext if);
                    (if isBaseDim then
                        (if convFactor = 0 then
                            true -> isBaseUnit;
                            1.0 -> convFactor
                         else
                            (* non base unit of base dim *)
                        if)
                     else 
                        (if convFactor = 1 then
                              (* for derived dimensions, we must set a 
                               * conversion factor of 1 (one) for the base unit
                               *)
                              true -> isBaseUnit
                         else
                            (* best to compute here, but some of the dimensions
                             * and units have not yet been added to the table; 
                             * a seperate scan is necessary
                             * Now we just compute it when needed below
                             '**** Derived dim: '
                             'compute conv factor of non base unit: ' 
                             -> puttext; US[2][] -> putline;
                             prop.dopt -> putline;
                             US[2][] -> parseUnit -> UT[]; UT.print->putline;
                             UT[] -> mkBaseVector -> BV[];
                             BV.print
                             *)
                    if)if);
                    dim.sig.dopt -> dimN[];
                    (if traceUE then 
                        ' baseDim:'->puttext; dimN[] -> putline if);
                    (if isBaseDim then
                        (if true 
                         // 'Dimension' -> dimN.equalNCS 
                         // 'Unit' -> dimN.equalNCS then
                            8 -> baseInx
                         // 'Time' -> dimN.equalNCS then
                            1 -> baseInx
                         // 'length' -> dimN.equalNCS then
                            2 -> baseInx
                         // 'Mass' -> dimN.equalNCS then
                            3 -> baseInx
                         // 'ElectricCurrent' -> dimN.equalNCS then
                            4 -> baseInx                         
                         // 'ThermodynamicTemperature' -> dimN.equalNCS then
                            5 -> baseInx                         
                         // 'AmountOfSubstance' -> dimN.equalNCS then
                            6 -> baseInx
                         // 'LuminousImtenmsity' -> dimN.equalNCS then
                            7 -> baseInx
                         else
                            '!!!! OBS! no matching base unit: ' -> puttext;
                            dimN[] -> puthead;
                            prop.dopt -> putline;
                    if)if)
                 #);

               print:
                 (#
                 do (if isBaseDim then
                        'Base Dimension: "' -> puttext
                     else
                        'Derived Dimension: "' -> puttext; 
                    if);
                    dim.sig.dopt -> puttext;
                    (if (convFactor = 1.0) 
                        or isBaseDim and (convFactor = 0.0) then
                        '" base unit: "' -> puttext;
                         unit.sig.dopt -> puttext;
                        '" ' -> puttext;
                     else
                        '" not base unit: ' -> puttext;
                    if);
                    (for i: UStop repeat 
                         '"'->put; US[i][] -> puttext; '"'-> put; ' ' -> put 
                    for);
                    (if convFactor <> 0 then 
                        'convFac: ' -> puttext;
                        convFactor -> putReal
                    if);
                    (if false then
                        ' ' -> put; prop.dopt -> putline
                    if);
                    newline;
                 #);
              
            enter(dim[],unit[],prop[])
            exit this(unitElm)[]
            #);
     
          add:
            (# prop: ^NewProperty; P: ^Pattern
            enter prop[]
            do (if traceUE then
                   '**** prop: ' -> puttext; prop.dopt -> puttext;
                   ' in:sig: ' -> puttext;
                   (prop.enclosingObjectGenerator).sig.dopt ->puttext;
                   ' arg1: ' -> puttext; 
                   prop.getSArg1 -> puttext;
                   newline;
               if);
               (if '$' -> (prop.getSarg1).equal then
                   leave add
               if);
               (prop.enclosingObjectGenerator).enclosingObjectGenerator 
                 -> N[];
               N.father[] -> DI[];   
               (if traceUE then 
                   DI.sig.dopt ->putline;
               if);
               (prop.enclosingObjectGenerator).father[] -> P[]; 
               (if (top + 1 -> top) > DU.range then DU.range -> DU.extend if);
               (DI[],P[],prop[]) -> unitElm -> DU[top][];
               DU[top].decodeProp
            #);
          find:
            (# u: ^text; current: ^unitElm
            enter U[]
            do L:
                 scan
                 (# 
                 do (if U[] -> current.US[1].equalNCS then
                        (if traceUE then
                            '**   found: "' -> puttext;
                            U[] -> puttext; '" -> ' -> puttext;
                            current.print;
                        if);
                        current[] -> this(find).current[];
                        inner find;
                        leave L
                    if)
                 #)
            #);
          findInAll:
            (# U: ^text; current: ^unitElm; U1: @text
            enter U[]
            do U.scanAll(#do (if ch // '(' // ')' then else ch -> U1.put if)#);
               U1[] -> U[];
               L:
                 scan
                 (# 
                 do (for i: current.UStop  repeat
                         (if U[] -> current.US[i].equalNCS then
                             (if traceUE then
                                 '**   findInAll:found: "' -> puttext;
                                 U[] -> puttext; '" -> ' -> puttext;
                                 current.print;
                             if);
                             current[] -> this(findInAll).current[];
                             inner findInAll;
                             leave L
                    if)for)
                 #)
            #);            
          findU: find
            (# isBase: @boolean; CF: @real
            do current.isBaseDim -> isBase;
               current.convFactor -> CF
            exit(isBase,CF)
            #);
          findAndCheck:
            (* Lookup lU and rU to check if they belong to the same
             * dimension. This could be meter and centimeter. 
             * If same dimension, true is returned together with the conversion
             * factors to the base unit.
             * For base unit, convFactor = 0; should probably be 1
             * Currently only the unit names of lU and rU are searched, thus 
             * "m2" and "m*m" will not be matched as in the same dimension,
             * even if they are the same unit. 
             * Perhaps this should be changed!?
             *)
            (# lU,rU: ^text; sameDim: @boolean;
               lDim,rDim: ^Decl;
               lCF,rCF: @real
            enter(lU[],rU[])
            do (if traceUE then
                   '**** unitTable.findandCheck:lU: "'->puttext; lU[]->puttext;
                   '" rU: "' -> puttext; rU[] -> puttext; '"' -> putline
               if);
               lU[] -> findInAll
               (#
               do current.dim[] -> lDim[];
                  current.convFactor -> lCF
               #);
               rU[] -> findInAll
               (#
               do current.dim[] -> rDim[];
                  current.convFactor -> rCF
               #);
               lDim[] = rDim[] -> sameDim;
               (if traceUE then
                   '**   sameDim: ' -> puttext; sameDim -> putBoolean;
                   newline
               if)
            exit(sameDim,lCF,rCF)
            #);
          checkIfSame:
            (# lU,rU: ^text; sameDim: @boolean;
               lDim,rDim: ^Decl;
               lCF,rCF: @real
            enter(lU[],rU[])
            do (if traceUE then
                   '**** unitTable:checkIfSame:lU: "' -> puttext; lU[]->puttext;
                   '" rU: "' -> puttext; rU[] -> puttext; '"' -> putline;
               if);
               lU[] -> FindInAll
               (#
               do current.dim[] -> lDim[]
               #);
               rU[] -> FindInAll
               (#
               do current.dim[] -> rDim[]
               #); 
               lDim[] = rDim[] -> sameDim;
               (if traceUE then
                   '**   checkIfSame:sameDim: ' -> puttext; sameDim -> putBoolean;
                   newline
               if)
            exit sameDim
            #);
          findUOG: find
            (# uOG: ^ObjectGenerator
            do current.unit.OG[] -> uOG[];
            exit uOG[]
            #);
           findUOGall: findInAll
            (# uOG: ^ObjectGenerator
            do current.unit.OG[] -> uOG[];
            exit uOG[]
            #);
          scan:
            (# current: ^unitElm
            do
               (for i: top repeat
                    DU[i][] -> current[];
                    inner
               for)
            #);
          print:
            (#
            do '**** UnitTable: ' -> putline;
               (for i: top repeat
                    DU[i].print;
               for)
            #);
          DU: [7] ^unitElm; top: @integer;
          N: ^ObjectGenerator; DI: ^Decl;
          L: ^unitElm
       #);
     mkBaseVector:
       (# getConstLiteral:
            (# op: ^text; V: @integer; isNeg: @boolean
            enter op[]
            do (if traceUE then 
                   '**** getConstLiteral: ' -> puttext; op[] ->puttext if);
               (if (1 -> op.inxGet) = '-' then
                   true -> isNeg; 
                   2 -> op.setpos;
               if);
               op[] -> readNumber -> V; (* readNumber makes op.setPos!
                                         * So setPos above, is superflous!
                                         **)
            exit V
            #);
          T: ^UnitTree; BVl,BVr: ^baseVector
       enter T[]
       do (if traceUE then 
              '**** mkBaseVector: ' -> puttext; true -> T.print -> putline;
          if);
          (if T.token
           // mult then
              T.left[] -> mkBaseVector -> BVl[];
              T.right[] -> mkBaseVector -> BVr[];
              BVr[] -> BVl.add
           // divv then
              T.left[] -> mkBaseVector -> BVl[];
              T.right[] -> mkBaseVector -> BVr[];
              BVr[] -> BVl.minus
           // expT then 
              T.left[] -> mkBaseVector -> BVl[];
              (if traceUE then
                  '**   mkBaseVector:expT: ' -> puttext; T.print ->putline;
                  BVl.print  -> puttext;
              if);
              (if true then
                  (if traceUE then
                      T.print -> putline;
                      T.right.print->putline;
                      T.right.op[]->putline;
                  if);
                  (if '/' -> T.right.op.equal then
                      (* we assume T.right = (1/2) but should be checked *)
                      (T.right.left.op[]->getConstLiteral
                      ,T.right.right.op[] -> getConstLiteral)
                        -> BVl.rootN
                      (# rootnError::
                           (#
                           do '\n\n!!! WARNING:'-> puttext;
                              M[] -> putline;
                              '    in: '  -> puttext;
                              T.print -> putline;
                              '\n! This message must be improved!'-> putline
                           #)#)
                   else
                      T.right.op[] -> getConstLiteral -> BVl.mult
                  if);
               else
                  T.right.op[] -> readNumber -> BVl.mult
              if)
           // idf then
              (if traceUE then
                  '**   MBK:idf: '->puttext; T.op[] -> putline; 
              if);
              T.op[] -> unitTable.find
              (# theDim: ^text; UT: ^UnitTree; BV: ^BaseVector
              do current.dim.sig.dopt -> theDim[];
                 (if traceUE then
                     '**   MBK:idf:thedim: ' -> puttext; theDim[] ->putline
                 if);
                 (if current.isBaseDim then
                     &BaseVector[] -> BVl[];
                     1 -> BVl.theBase[current.baseInx];
                     current.convFactor -> BVL.convFactor;
                     (if (current.convFactor = 0) 
                         and not current.isBaseUnit then
                         '**** convFactor is zero:'->putline;
                         current.print
                     if);
                  else (* Derived dimension *)
                     (if traceUE then
                         '**** Derived dimension: ' -> puttext; 
                         theDim[] -> puttext;
                         ' ' -> put; current.US[2][] -> putline;
                         (*current.print*)
                     if);
                     current.US[2][] 
                       -> parseUnit 
                       -> mkBaseVector -> BVl[];
                     (if current.isBaseUnit then
                         (if current.convFactor <> 1.0 then
                             '**** derived base unit wrong convFactor:'
                               ->puttext;
                             current.convFactor -> putreal; newline;
                             current.print
                         if);
                         current.convFactor -> BVL.convFactor;
                      else
                         current.US[2][] -> parseUnit -> UT[]; 
                         UT[] -> mkBaseVector -> BV[];
                         BV.convFactor -> BVl.convFactor;
                         (if false then
                             '**** compute convFactor from: ' -> puttext;
                             current.US[2][] -> putline;
                             current.print;
                             UT.print->putline;
                             BV.print -> putline;
                         if)
                     if);
                 if);
              #);
              (if BVl[] = none then 
                  '!!!! Unit not found: ' -> puttext; T.print-> putline;
                  &BaseVector[] -> BVl[];
              if);
              (if traceUE then 
                  'MBK:idf:final: ' -> putline; BVL.print -> puttext if)
           // number then
              'MBK:number: '->puttext;
              T.op[] -> putline;
              &BaseVector[] -> BVl[]
           // var then 
              &BaseVector[] -> BVl[]
           else
              '*** token not handled: '->puttext; T.token ->putint; newline
          if);
          (if traceUE then
              '**** mkBaseVector:res: ' -> putline; BVL.print -> puttext
          if)
       exit BVl[]
       #); 
     mkContextLines:
       (# N: ^Node; T,Lines: ^Text; ch: @char; 
          first,last,p,inx,lineNo: @integer
       enter N[]
       do true -> (N.theModule).doPT -> Lines[];
          N.beginPos -> p;
          (* find the position in N, 4 lines before N *)
          L:
            (if (first < 4) and (p > 1) then
                p - 1 -> p;
                (if (p -> Lines.inxGet) = ascii.newline then 
                    first + 1 -> first 
                if);
                restart L
            if);
          
          L: (if (inx + 1 -> inx) < p then
                 (if (inx ->Lines.inxGet) = ascii.newline then
                     lineNo + 1 -> lineNo
                 if);
                 restart L
             if);
            
          &text[] -> T[];
          lineNo + 1 -> lineNo -> T.putint; ':'  ->  T.put;
          (*  print fra pos p to N.endPos *)
          L:
            (if (0 < p) 
                and ((p <= N.endpos) or (ch <> ascii.newline))
                and (p <= Lines.length) then
                Lines.T[p] -> ch -> T.put;
                (if  ch = ascii.newline then
                    lineNo + 1 ->  lineNo -> T.putint; ':'  ->  T.put;
                if);
                p + 1 -> p;
                restart L
            if);

          (*T.newline;*)
       exit T[]
       #);
     notification: 
       (# msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          qmsg:
            (# T: ^text;
            enter T[]
            do '"' -> lex.errorStream.put; T[] -> msg; '"' -> lex.errorStream.put;
            #);
          n: ^TopNode;
          thisModule: ^module;          
          printHeading:< (# do '\n' -> puttext;inner #);
          printLines:
            (*  use getContextLines above! *)
            (# first,last,p: @integer; ch: @char; Lines: ^Text;
            do true -> (n.theModule).doPT -> Lines[];
               n.beginPos -> p;
               L:
                 (if (first < 4) and (p > 1) then
                     p - 1 -> p;
                     (if  (p -> Lines.inxGet) = ascii.newline then 
                         first + 1 -> first if);
                     restart L
                 if);
               L:
                 (if (0 < p) and ((p <= n.endpos) or (ch <> ascii.newline))
                     and (p <=Lines.length) then
                     Lines.T[p] -> ch -> put;
                     p + 1 -> p;
                     restart L
                 if);
               newline;
            #);         
          report:< BooleanValue(#do inner #);
       enter n[] 
       do (*n.theModule -> errorModule[];*)
          (if report then
              (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
              (if not withPos then 
                  printHeading;
                  ' in module: "' -> puttext; 
                  (if n.theModule <> none then                  
                      (n.theModule->thisModule[]).sig.doPT -> puttext; 
                      '"' -> put; newline;
                      printLines;;
                      (*n.father.doPT -> putline*)
                   else
                      'n.theModule = none"'->putline
                  if);
                  '**** ' -> puttext;
                  &text[] -> lex.errorStream[]
              if);
          
              (if withPos then
                  n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                    -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;
                  n.endPos -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;   
              if);
              INNER;              
              lex.errorStream.newline;
              (if not withPos then
                  lex.errorStream[] -> putline
              if);
          if)
       #);
     SemanticError: Notification
       (# report:: (# do reportSemErr -> value #);
          printHeading::
            (#
            do 'Semantic error' -> puttext;
            #);
       do INNER;
          true -> semanticErrors
       #);
     QuaCheck: Notification
       (# report:: (# do reportQuaCheck -> value #);
          printHeading:: 
            (# 
            do 'Run-time check needed' -> puttext
            #)
       do (if reportQuaCheck then inner if)
       #);
     Warning: Notification
       (# report:: (# do true -> value #);
          printHeading::(#do 'WARNING' -> puttext #);
       do inner
       #);
     semanticErrors: @boolean;
  do '**** CHECKER  ****' -> putline;
     0 -> newDesc.noOfDescs; (* needed when exe from minienv
                              * we must find a way to compile changed modules
                              * currently we compile all modules
                              *)
     false -> semanticErrors;
     none -> error_stream[];
     argBuf.init;
     (*true -> trx -> traceCheck;*)
     (*true -> traceSearch;*)
     (if rootModule.origin[] <> none then
         'B:rootModule.origin:not none ' -> putline;
         rootModule.doPT -> putline;
     if);
     rootModule.setUpOrigin;
     rootModule.check;
     (if main[] = none then          
         '\n\n!!!! main is none!'->putline; 
         '     This may be because of a case-inconsistency' -> putline;
         '     in the path name to the CWD like:'->putline;
         '        ".../BETAworld/LIB/.../foo"'->putline;
         '        ".../BETAworld/lib/.../foo"'->putline;
         '     May happen with Cugwin'->putline
     if);
     (none,main.origin[],none(*main.origin[]*),true) -> main.check;
     main.MarkInModuleProp;
     argBuf.check;
     
     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline;
         lex.errorStream[] -> error_stream[]
      else
         (*main.doPP -> putline;*)
         '**** ALLOC    ****'->putline;
         rootModule.alloc;
         '**** SET VIRTUAL BINDINGS ****' -> putline;
         rootModule.setVirtualBindings;
         (*main.doPP -> putline;*)
         (*unitTable.print;*)
         inner
     if);
  #)
