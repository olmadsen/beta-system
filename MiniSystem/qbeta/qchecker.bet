ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
INCLUDE 'qprimitives';
INCLUDE 'qvirtual';
INCLUDE 'qunitparser'
---lib:attributes---
(* origin is always in instance of Items or none - for the outermost Module 
 * basicScope = origin for Items
 * argScope = basicScope in most cases
 * except for a pattern: Signature: ObjectGenerator:super, where
 *  (none,basicScope[],sig[],true) -> super.check;
 * argScope is mainly passed as argument to check
 * but saved in argBuf.add and then used in argBuf.check
 * Checking is recursive whenever neeeded, see abstractsyntaxtree::check
 *)
traceGeneric: (# exit false #);
traceGeneric2: (# exit false #);
traceGeneric3: (# exit false #);
handleGeneric: (# exit true #);
traceNoGlobals: (# exit false #);
checker: Parser
  (# traceSearch,traceAlloc: @ boolean;
     checkingModule: @boolean;
     Module::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
               sig[] -> OG.sig[];
               true -> OG.isObj
            #);
          check::
            (# org: ^Items; M: ^Module
            do (if traceCheck then
                   '**** Module:check: ' -> puttext; sig.doPT -> putline;
               if); 

               (* check enclosing module *)
               (if (origin[] <> none) 
                   and not (origin[]->org[]).isChecked then
                   (if traceCheck then
                       '\n**** check:Module:origin: ' -> puttext;
                       org.encOG.OGid -> putline;
                   if);
                   (none,org[],none,true) -> ((org.theModule)-> M[]).check;
               if);
               this(Module)[] -> requires.add;
               (none,basicScope[],none,true) -> sig.check;
               (none,basicScope[],none,true) -> OG.check; 
               markInModuleProp;
               this(Module)[] -> imports.addM;
            #);
          moduleAllocDone: @Boolean;
          alloc:: 
            (# 
            do (if traceAllocC then
                   '**** Module:alloc: ' -> puttext; moduleName->putline; 
               if);
               (if moduleAllocDone then
                   (*'**** moduleAllocDone: ' -> puttext; moduleName->putline;*)
                   leave alloc
               if);
               true -> moduleAllocDone;
               (if enclIT[] <> none then (* IT is none if top module *)
                   (if OG.isBasicValue then
                       enclIT.vsize + 1 -> enclIT.vsize -> off
                    else
                       enclIT.rsize + 1 -> enclIT.rsize -> off
               if)if);
               (* For modules of the form
                *    AST: obj compiler_IF.Tree {...}
                * we must ensure that alloc has been called for 
                * compiler_IF and thus also Tree
                * For modules like
                *    SCPex: obj LIB.SimpleConcurrentProcesses.System
                * alloc must have been called for LIB and 
                *    SimpleConcurrentProcesses
                * We also need to ensure that alloc is called at most once
                * The boolean moduleAllocDone takes care of this
                *)
               OG.super.scanSons
               (# N: ^ objectInvocation; M: ^ModuleItem; ATdx: ^Decl
               do (*current.dopt -> putline;*)
                  (if current## = ObjectInvocation## then
                      current[] -> N[];
                      N.ATd.asDecl -> ATdx[];
                      (if ATdx##
                       // Module## // ModuleItem## then 
                          ATdx[] -> M[];
                          (if false then
                              ' isModule'->putline;
                              '** encModule: ' -> putline;
                              (encModule).OG.IS.dopt -> putline;
                          if);
                          (if not M.MD.moduleAllocDone then
                              (encModule).OG.IS[] -> (N.ATd.asDecl).alloc;
                              true -> M.MD.moduleAllocDone
                  if)if)if)
               #);
               enclIT[] -> sig.alloc;
               enclIT[] -> OG.alloc
            #);
          desc:: 
            (#
            do (if false then
                   '**** Module:desc:OG: ' -> puttext;
                   not OG.hasItems -> putboolean; newline;
                   OG.dopt -> putheadN;
               if);
               (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else  
                   OG.IS[] -> D[]
               if) 
            #);
          clear::<
            (#
            do (*'Clear: '->puttext; sig.doPT -> putline;*)
               false -> isAdded -> isIncluded -> inMainPath -> moduleAllocDone;
               inner
            #)
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do (if traceCheck then
                   '**** ModuleItem:check:NO:check: ' -> puttext;
                   sig.doPT->putline;
               if);
               (if false then
                   (none,basicScope[],none,true) -> MD.check
               if);
               false -> wasChecked
            #);
          checkRequires::
            (#
            do not MD.isIncluded -> done;
               (if traceCheck or false then
                   '**** MI:MD.isIncluded: ' -> puttext; sig.dopt->puttext;
                   ' ' -> put; done -> putboolean; newline
               if)
            #);
          importRequires::
            (#
            do (if MD.isIncluded then
                   (if false then
                       '**** import: ' -> puttext; MD.sig.dopt -> putline;
                   if);
                   MD.requires.import
               if)
            #);
          alloc:: 
            (# 
            do (if traceAllocC then
                   '**** Moduletem:alloc:' -> puttext; sig.dopt -> puthead;
                   ' ' -> put; isChecked -> putBoolean; newline
               if);
               (if isChecked then enclIT[] -> MD.alloc if)
            #);
          setVirtualBindings::
            (#
            do not isChecked -> done;
            #);
       #);
     Items::<
       (# PT::
            (#
            do (if false then
                   '(' -> lx.put;
                   originOff -> lx.putint; ',' -> lx.put;
                   vsize -> lx.putint; ',' -> lx.put;
                   rsize -> lx.putint; ',' -> lx.put;
                   dsize -> lx.putint; ',' -> lx.put;
                   noOfInner -> lx.putint; ',' -> lx.put;
                   innerInx -> lx.putint;
                   ')' -> lx.put;
                   (pos,break) -> mkbreak
               if);
            #);
          setUpOrigin::
            (# 
            do false -> isChecked -> beingChecked 
               (*-> isVinxd -> isRinxd*) -> done ;
               0 -> descNo -> vsize -> rsize -> originOff -> noOfInner 
                 -> dsize -> innerInx;
               0 -> QDNtop;
               scanSons(# do this(Items)[] -> current.setupOrigin #);
               setAccessLevels
            #);
          setAccessLevels:
            (# acc_current: @integer; prop: ^NewProperty; dcl: ^Decl
            do scanSons
               (#
               do (if true
                   // current.isNewProp then
                      current[] -> prop[];
                      (if false then
                          '**** Got property: ' -> puttext; 
                          current.dopt -> putline;
                      if);
                      (if true 
                       // '%domain' -> prop.propId.T.equalNCS then
                          acc_domain -> acc_current;
                       // '%public' -> prop.propId.T.equalNCS then
                          acc_public -> acc_current;
                       // '%private' -> prop.propId.T.equalNCS then
                          acc_private -> acc_current;
                       // '%publicInSub' -> prop.propId.T.equalNCS then
                          acc_publicInSub -> acc_current;   
                       // '%domain_boundary' -> prop.propId.T.equalNCS then
                       // '%globals' -> prop.propId.T.equalNCS then
                          
                      if)
                   // current.isDecl then
                      current[] -> dcl[];
                      (if dcl## = ModuleItem## then
                          (* preliminary until we have fixed an explicit
                           * syntax for moduleItmes *)
                          acc_public -> dcl.accessLevel
                       else
                          acc_current -> dcl.accessLevel
               if)if)#)
            #);
          checkGlobalAccess:
            (# globalRestrictionsInSuper,globalRestrictionsInMain,globalRestrictionsInSub: @boolean
            do (if superDesc[] <> none then
                   &superDesc.checkGlobalAccess -> 
                   (globalRestrictionsInSuper,globalRestrictionsInMain,globalRestrictionsInSub)
               if);
               (if true
                // (globalRestrictionsInMain = false) 
                   and (globalRestrictionsInSub = false) then
                   (* super may acces globals
	            * main may access globals unless globals-property
                    * so scan for globals below *)
                // (globalRestrictionsInMain = false) 
                   and (globalRestrictionsInSub = true) then
                   (* super may access globals
	            * main may not access globals, so leave *)
                   true -> globalRestrictionsInSuper 
                     -> globalRestrictionsInMain 
                     -> globalRestrictionsInSub;
                   leave checkGlobalAccess
                // (globalRestrictionsInMain = true) 
                   and (globalRestrictionsInSub = false) 
                   then  
                   (* super may not access globals
	            * main may access globals unless globals-prop
                    * scan for globals in main *)
                // (globalRestrictionsInMain = true) 
                   and (globalRestrictionsInSub = true) 
                   then  
                     (* super may not access globals
	              * main may not access globals - leave *)
                   true -> globalRestrictionsInSuper -> globalRestrictionsInMain
                     -> globalRestrictionsInSub;
                   leave checkGlobalAccess
               if);
               globalRestrictionsInMain -> globalRestrictionsInSuper;
               false -> globalRestrictionsInMain -> globalRestrictionsInSub;
               (if newBasicProp.globals[] <> none then
                   true -> globalRestrictionsInMain -> globalRestrictionsInSub;
                   L: newBasicProp.scanGlobals
                     (# INV: ^Invocation
                     do current.scanSons
                        (# OI: ^ObjectInvocation
                        do current[] -> OI[];
                           (if ('inSub' -> OI.ptnId.T.equalNCS) then
                               (*'***insub'-> putline; dopt -> putline;*)
                               (* OBS [globals[P1,P2,inSub,...]] *)
                               false -> globalRestrictionsInSub
                            else 
                               false -> globalRestrictionsInMAin 
                                 -> globalRestrictionsInSub; 
                               leave L
               if)#)#)if);
               (if traceNoGlobals and
                   (globalRestrictionsInSuper or globalRestrictionsInMain 
                   or globalRestrictionsInSub)
                   then
                   '****  CheckGlobalAccess:\n'->puttext;
                   encOg.dopt -> puthead;
                   (if globalRestrictionsInSuper then 
                       'globalRestrictionsInSuper:' -> puttext if);
                   (if globalRestrictionsInMain then 
                       'globalRestrictionsInMain:' -> puttext if);
                   (if globalRestrictionsInSub  then 'globalRestrictionsInSub:' ->puttext if);
                   newline;
               if);
            exit(globalRestrictionsInSuper,globalRestrictionsInMain,globalRestrictionsInSub)
            #);
          
          check::
            (# checkDoubleDecls:
                 (# 
                 do (*'\ncheckDoubleDecls: ' -> puttext;*)
                    scanDecls
                    (# illegalReDecl:
                         (# id: ^text; pNo: @integer
                         enter(id[],pNo)
                         do (if thisDcl.OG.primNo <> pNo then
                                currentDcl[] -> SemanticError
                                (#
                                do 'You cannot redeclare "' -> msg;
                                   id[] -> msg; '"' -> msg
                         #)if)#); 
                       checkReDecl:
                         (#
                         do (if nameListInDcl then
                                currentDcl.scanNames
                                (#
                                do (if true
                                    // 'object' -> current.T.equalNCS then
                                       ('object',object_prim) -> illegalReDecl
                                    // 'value' -> current.T.equalNCS then
                                       ('value',value_prim) -> illegalReDecl
                                   if)
                                #)
                             else
                                (if true
                                 // 'object' -> currentDcl.sig.id.equalNCS then
                                    ('object',object_prim) -> illegalReDecl
                                 // 'value' -> currentDcl.sig.id.equalNCS then
                                    ('value',value_prim) -> illegalReDecl
                            if)if)
                         #);
                       checkEqual: BooleanValue
                         (# aDecl: ^Decl
                         enter aDecl[]
                         do (if nameListInDcl then
                                L:
                                  thisDcl.scanNames
                                  (# cD: ^NameDecl
                                  do current[] -> cD[];
                                     (*'**** check: ' -> puttext;
                                     cD.T[] -> dumpT;
                                     cD.dopt -> putline;*)
                                     
                                     A: 
                                       aDecl.scanNames
                                       (#
                                       do (if cD[] = current[] then leave A if);
                                          (*'**   with: ' -> puttext;
                                          current.T[] -> dumpT;
                                          current.dopt -> putline;*)
                                          (if cD.T[] 
                                                -> current.T.equalNCS 
                                                -> value then
                                              leave L
                                  if)#)#)
                             else
                                aDecl.sig.id[] 
                                  -> thisDcl.sig.id.equalNCS
                                  -> value
                         if)#);
                       thisDcl: ^Decl
                    do currentDcl[] -> thisDcl[]; 
                       checkReDecl;
                       (if currentDcl.OG.primNo // fEq_prim // fLE_prim then
                        else
                           L:
                             scanAllDecls
                             (#
                             do (if currentDcl[] = thisDcl[] then leave L if);
                                isEq:
                                  (if currentDcl[] -> checkEqual
                                      then
                                      (if 'Signature' 
                                            -> (thisDcl.origin.label).equalNCS then
                                          (if currentDcl.isInArg then
                                              (* thisDcl is a parameter of 
                                               * a pattern with fatComma 
                                               * syntax; and currentDcl 
                                               * must have been bound
                                               * by an argument in super 
                                               * of the pattern
                                               *)
                                              leave isEQ
                                      if)if);
                                      (* We must check that currentDcl is 
                                       * actually a binding of thisDcl; perhaps 
                                       * currentDcl.off=thisDcl.off is ok?
                                       *)
                                      (if not (thisDcl.isVirtual 
                                          and currentDcl.isVirtual
                                          and dclInSuper) then
                                          thisDcl[] -> SemanticError
                                          (#
                                          do 'Double declaration of: "' 
                                               -> msg;
                                             thisDcl.sig.id[] -> msg; 
                                             '"' -> msg
                 #)if)if)#)if)#)#)               
            do (if traceCheck then 
                   '**** Items:check:\n' -> puttext; doPT->putheadN;
                   ('basicScope',basicScope[]) -> putPT
               if);
               this(items)[] -> basicScope[];
               scanSons
               (# I: ^Item; 
               do (none,basicScope[],none,true) -> current.check;
                  current[] -> I[];
                  (if I.hasCode then true -> doHasCode if)
               #);
               checkDoubleDecls;
               checkGlobalAccess 
                 -> (globalRestrictionsInSuper
                    ,globalRestrictionsInMain
                    ,globalRestrictionsInSub);
            #);
          globalRestrictionsInSuper,         (* restricts on globals in super *)
          globalRestrictionsInMain,          (* restricts on globals in main *)
          globalRestrictionsInSub: @boolean; (* restricts on globals main.sub *)
          alloc::
            (# allocOrigin:
                 (# 
                 do (if globalRestrictionsInMain then
                     else
                        rsize + 1 -> rsize -> originOff
                    if)
                 #);
            do (if traceAllocC then
                   '**** items:alloc:'->puttext; dopt -> putheadN
               if);
               (if traceNoGlobals then
                   (if globalRestrictionsInMain then
                       '*** thisOG does not acces global attributes:\n '
                         -> puttext;
                       father.father.doPT -> puthead
               if)if);
               (if super.ATd[] <> none then
                   (if superDesc[] = none then
                       '**** Items:alloc: ' -> puttext; doPT -> putline;
                       'This:'->puttext; label -> puttext; 
                       ' this.Super.label: ' -> puttext; super.label -> puttext;
                       ' father.label: ' -> puttext;
                       father.label -> putline;

                       doPP -> putline;
                       '**   father: ' -> putline;
                       father.doPP -> putline;
                       '**   father.father: ' -> putline;
                       father.father.dopp -> putline;
                   if);
                   superDesc.vsize -> vsize;
                   superDesc.rsize -> rsize;
                   superDesc.dsize -> dsize;
                   (if super.isThisBlockLevel and (not super.isImplSuper) 
                       and (not super.isSingularImplSuper)
                       then
                       (if globalRestrictionsInSuper then
                           rsize + 1 -> rsize -> originOff
                        else
                           superDesc.originOff -> originOff
                       if)
                    else
                      allocOrigin 
                   if)
                else
                   allocOrigin;
                   (if objectDecl.OG.IS[] <> this(Items)[] then
                       1 -> dsize;
               if)if);
               (if sig[] <> none then
                   this(items)[] -> sig.alloc
               if);
               scanSons(# do this(items)[] -> current.alloc #);
            #);
          topSuper:
            (* This function also returns a primitive top pattern like value *) 
            (# topDesc: ^Items
            do (if (superDesc[] <> none) 
                   and (superDesc[] <> objectDecl.OG.IS[]) then
                   superDesc.topSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          hasRealSuper: BooleanValue
            (* used by generator:Items:genClass *)
            (# theIS: ^Items
            enter theIS[]
            do (theIS.superDesc[] <> none) 
               and 
               (not theIS.superDesc.isPrimitive
               or (theIS.superDesc.primNo = stringDecl.primNo)
               or (theIS.superDesc.primNo = immutable_prim)
               or (theIS.superDesc.primNo = vEq_prim)
               or (theIS.superDesc.primNo = vLE_prim)
               or (theIS.superDesc.primNo = ceq_prim)
               ) -> value
            #);
          realTopSuper:
            (* the top pattern being retrned must be a realSuper as specified
             * by hasRealSuper - used by generator:Items:genClass 
             *)
            (# topDesc: ^Items
            do (if this(Items)[] -> hasRealSuper then
                   superDesc.realTopSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          searchEmbodied:
            (# NA: ^Lexem; CS: ^Text; ATd: ^Decl; pn: @integer; 
               OI: ^ObjectInvocation; found: @boolean 
            enter NA[]
            do (if not newBasicProp.checkingEmbodiedProp then
                   (if traceSearch then
                       '**** Items:searchEmbodied: '->puttext; 
                       NA.doPT -> putline; 
                   if);
                   NA.T[] -> CS[];
                   L:
                     newBasicProp.scanEmbodied
                     (# ATdx: ^Decl
                     do (*'prop:\n'->puttext; current.dopt -> putline;
                        current.label -> putline;*)
                        (if traceSearch then
                            'searchEmbodied:Search: ' -> puttext; 
                            CS[] -> puttext; ' in:'->dumpt;
                            current.dopt ->putline;
                        if);
                        CS[] -> current.OG.IS.localSearch -> (ATdx[],pn);
                        (if ATdx[] <> none then
                            (if not found then
                                ATdx[] -> ATd[];
                                (if traceSearch then
                                    'embodied:found: '->puttext;
                                    ATd.sig.dopt->putline; ATd.dopt -> putline;
                                if);
                                NA.father[] -> OI[];
                                true -> OI.isEmbodied;
                                current[] -> OI.theEmbodied[];
                                true -> found
                             else
                                '**** name clash for: '-> puttext;
                                NA.dopt -> putline;
                                '**   in: '-> putline; 
                                OI.theEmbodied.dopt -> putline;
                                '**   and:'->putline;
                                current.dopt -> putline;
                                '**   must be resolved'->putline
               if)if)#)if)
            exit ATd[]
            #);
          localSearch:            
            (# CS: ^ Text; ATd: ^Decl; pn: @integer
            enter CS[]
            do (if traceSearch then
                   '**** Items:localSearch: ' -> puttext; CS[] -> putline;
                   '**   in:' -> putline; doPT -> puthead; newline
               if);
               (if false and isEmpty and not super.hasVirtualArgs then
                   '**** localSearch:IS.isEmpty: ' -> puttext;
                   encOG.dopt -> putheadN
               if);
               searchDcls:
                 (#
                 do (if traceSearch then
                        '**   Items:localSearch:Decls: ' -> puttext;  
                        CS[] -> putline;
                    if);                      
                    scanSons
                    (# I: ^Item; AT: ^Decl; MI: ^ModuleItem; MD: ^Module;
                       OneArgFunc: BooleanValue
                         (#
                         do (if newFatComma then
                                ('()'-> (CS.copy).append 
                                  -> AT.sig.id.equalNCS) -> value
                            if)
                         #);
                       ATDx: ^Decl
                    do current[] -> I[]; 
                       (if I.isDecl then
                           I[] -> AT[]; 
                           (if traceSearch then
                               'Try: ' -> puttext; AT.sig.id[] -> putline;
                           if);
                           (if not nameListInDcl and (CS[] ->AT.sig.id.equalNCS)
                               or OneArgFunc then
                               (if false then
                                   'Found:A: ' -> puttext; CS[] -> puttext;
                                   ' in: ' -> puttext; doPT->putheadN;
                               if);
                               AT[] -> ATd[]; (* ATd is Decl *)
                           if);
                           (if nameListInDcl then
                               L: 
                                 AT.sig.names.scan
                                 (# ND: ^NameDecl
                                 do (*'try: '->puttext; current.dopt->putline;*)
                                    (if CS[] -> current.T.equalNCS then
                                        current[] -> ATd[]; (* is NameDecl *)
                                        (*'***found:'-> puttext; CS[] -> putline;*)
                                        leave L
                                     else
                                        (* special case if
                                         * CS        = @leave:
                                         * current.T = @leave
                                         * Must be fixed when newFatComma 
                                         * and nameListnDcl are done!
                                         *)
                                        (if (':' = (CS.length->CS.inxGet)) and
                                            (CS.length = (current.T.length + 1))
                                            then
                                            (*'Koks:'->dumpT; CS[] -> dumpTN;
                                             current.T[]->dumpT;*)
                                            (if (1,CS.length-1) 
                                                  -> CS.sub 
                                                  -> current.T.equalNCS then
                                                current[] -> Atd[];
                                                leave L
                           if)if)if)#)if);
                           (if (ATd[] <> none) then
                               ATd.asDecl -> ATdx[];
                               (if false then
                                   ATd.label -> puttext; newline;
                                   dopt -> putHeadN; 'father:'->puttext;
                                   Atd.father.father.dopt -> putline;
                                   ATDx[] = none -> putboolean;
                                   newline;
                                   ATDx.label->putline;
                               if);
                               (if (ATdx## = ModuleItem##) then
                                   (* A hack, and worse: this does 
                                    * not work as long as
                                    * we check all modules. An no included
                                    * module may use another non included 
                                    * module, which implies that this 
                                    * module will be marked as used!
                                    *)
                                   (*'!!!! Found ModuleItem (hack): ' -> uttext;
                                    ATdx.sig.doPT -> putheadN;*)
                                   ATdx[] -> MI[];
                                   (*true -> MI.MD.isAdded -> MI.MD.isIncluded*)
                                   MI[] -> (theModule->MD[]).imports.add;
                               if);
                               leave searchDcls
                    if)if)#);

                    (if sig[] <> none then 
                        CS[] -> sig.localSearch -> (ATd[],pn);(* pn = 0*)
                    if);
                    trySuper:
                      (if (ATd[] = none) and (superDesc[] <> none) then
                          (if traceSearch then
                              '**   Items:localSearch:trySuper:'->putline;
                              superDesc.dopt -> puthead; newline;
                          if);
                          CS[] -> superDesc.localSearch -> (ATd[],pn);
                          (if ATd[] <> none then pn + 1 -> pn if)
                       else
                          (if not super.isChecked then
                              (if traceCheck then
                                  '**   OG:check:super:isChecked:'->puttext;
                                  super.isChecked -> putboolean; newline;
                                  super.dopt -> puthead; '---'-> putline;
                                  dopt -> puthead; '==='->putline;
                              if);
                              (# SC: ^Scope
                              do (if sig[] <> NONE then
                                     sig[] -> SC[]
                                  else
                                     this(Items)[] -> SC[]
                                 if);
                                 (none,super.origin[] ,SC[],true) -> super.check
                                 (# beingCheckedX::
                                      (#
                                      do (if true then
                                             '\n!!!! Super is not checked: '
                                               -> puttext;
                                             super.dopt ->  putheadn;
                                             '!!   Super:beingChecked: true'
                                               -> putline;
                                             '**   OG:' -> puttext; 
                                             father.dopt -> puthead;
                              if)#)#)#);
                              (if super.ATd[] <> none then
                                  (if traceCheck then
                                      '**   check:super.ATd:'->putline;
                                     super.ATd.dopt -> puthead
                                  if);
                                  (none,super.ATd.origin[]
                                  ,super.ATd.origin[],true)
                                    -> super.ATd.check;
                                  restart trySuper
                      if)if)if)
                 #);
            exit(ATd[],pn)
            #); 
          searchIncludeProp:
            (# NA: ^Lexem; CS: ^Text; ATd: ^Decl; org: ^Items; F: ^node;
            enter(NA[])
            do (if traceSearch then
                   '**** Items:searchIncludeProp: ' -> puttext; 
                   NA.dopt -> puttext; ' in: ' -> putline;
                   dopt -> puthead;
                   '**   origin: ' -> putline; 
                   (if origin[] = none then
                       'none'->putline
                    else
                       origin.dopt -> puthead
               if)if);
               NA.rmHash -> CS[];
               (if (origin[] <> none) 
                   and not (origin[]->org[]).isChecked then
                   (if false and traceCheck then
                       '\n**** searchIncludeProp:Origin not checked:' 
                         -> puttext;
                       org.encOG.OGid -> putline;
                       (* '**   origin:beingChecked: ' -> puttext;
                       org.beingChecked -> putboolean; newline;
                       '**   to.search:in:origin: ' -> puttext;
                       org.label -> puttext; 
                       ' org.father.label: ' -> puttext;
                       org.father.label -> putline;
                       org.father.doPT -> puthead*)
                   if);
                   (none,org[],none,true) -> (org.father[]->F[]).check;
               if);
               scanSons
               (# I: ^Item; prop: ^NewProperty; 
               do current[] -> I[];
                  (if I.isNewProp then
                      I[] -> prop[];
                      (if true
                       // '%visible' -> prop.propID.T.equalNCS
                       // '%include' -> prop.propID.T.equalNCS then
                          (if traceSearch then
                              '**** searchIncludeProp: ' -> puttext; 
                              prop.dopt -> putline;
                          if);
                          (* We had origin[] instead of prop.origin[], 
                           * which did not work
                           * Dont understand the difference!? *)
                          (none,prop.origin[],none,true) -> prop.check;
                          searchProps:
                            prop.args.scanSons
                            (# IV: ^Invocation; pn: @integer; M: ^ModuleItem
                            do current[] -> IV[];
                               (if traceSearch then
                                   '**   search: ' -> puttext; 
                                   current.dopt -> puttext;
                                   ' IV.ATd.label: ' -> puttext;
                                   IV.ATd.label->putline;
                                   IV.ATd.doPT -> puthead;
                                   '**   desc: ' -> putline;
                                   (IV.ATd.desc).doPT -> puthead;
                                   '**   Items:'-> putline;
                                   IV.ATd.OG.IS.dopt -> puthead;
                                   '**    module:' -> putline;
                                   (IV.ATd.asDecl->M[]).MD.dopt 
                                     -> puthead;
                                   '**   M.desc: ' -> puthead;
                                   (M.desc).dopt -> puthead;
                                   '**   M.MD.desc: ' -> puthead;
                                   (M.MD.desc).dopt -> puthead;
                               if);
                               (if IV.Atd[] = none then
                                   'atv none' -> putline;
                                   prop.dopt -> putline;
                                   dopt -> putline;
                                   '---'->putline;
                                   origin.father.dopt -> putline;
                               if);
                               CS[] -> (IV.ATd.desc).localSearch -> (ATd[],pn);
                               (if ATd[] <> none then
                                   IV[] -> NA.viaIncl[];
                                   (* Perhaps mark module! *)
                                   leave searchProps
                  if)#)if)if)
               #)
            exit ATd[]
            #);
          doSearch::
            (#
            do (NA[],true) -> search -> (ATd[],on,pn)
            #);               
          search::
            (# org: ^Items; F: ^Node;
               CS: ^ Text;
               (* NA: ^Lexem; isFirst: @boolean; ATd: ^Decl; on,pn: @integer*)
            (*enter(NA[],isFirst)*)
            do NA.rmHash -> CS[];
               (if traceSearch then
                   '**** Items:search: '->puttext; CS[] -> putline;
                   '**   in: ' -> putline; doPT -> puthead; newline
               if);
               CS[] -> localSearch -> (ATd[],pn);
               (* we should probably split localSearch into searchMain 
                * and and searchSuper *)
               (if ATd[] = none then NA[] -> searchEmbodied -> ATd[] if);
               (if ATd[] = none then
                   NA[] -> searchIncludeProp -> ATd[];                   
                   (if false and (ATd[] <> none) then
                       '**** Found: ' -> puttext; CS[] -> puttext;
                       ' in:' -> puttext;
                   if);
                   (if (ATd[] = none) and isFirst then
                       (if (origin[] -> org[]) <> none then
                           (NA[],isFirst) -> org.search -> (ATd[],on,pn);
                           (if not org.encOG.isChecked then
                               (if traceCheck then
                                   '\n**** origin.encOG not checked:' ->puttext;
                                   'beingChecked:'->puttext;
                                   org.encOG.beingChecked -> putboolean; 
                                   org.encOG.doPT -> putheadN
                               if);
                               (none,org[],none,true) -> org.encOG.check;
                           if);
                           (if (basicNo = ifthen_prim) or
                               org.isEmpty and not org.super.hasVirtualArgs then
                               (if org.isEmpty 
                                   and not org.super.hasVirtualArgs then
                                   (*'!!!! Origin:search: IS.isEmpty'->puttext;
                                    org.encOG.dopt -> putheadN*)
                                   (* Skip this IS when counting on levels *)
                               if);
                               (if false then
                                   '!!! Origin:search:%if%then: Adjust ON: ' 
                                     -> puttext; 
                                   doPT -> puthead
                               if)
                            else
                               on + 1 -> on ;
                               (if traceSearch then
                                   '>>> on + 1 = ' -> puttext; on -> putint;
                                   (if ATd[] <> none then 
                                       ' found!: "' -> puttext;
                                       NA.T[] -> puttext;
                                       '"! ATd.father:' -> putline;
                                       ATd.father.doPT -> puthead
                                    else
                                       ' not found' -> putline
                                   if);
                                   (*doP -> putline*)
                               if)
                           if)
               if)if)if);
               (if false and (ATd[] <> none) then 
                   '\n!!!!! found: ' -> puttext; CS[] -> puttext;
                   ' on:' -> puttext; on -> putint; 
                   ' pn:' -> puttext; pn -> putint; 
                   newline
               if);
            (*exit(ATd[],on,pn) *)
            #);
          basicNo: integerValue
            (* should be used in primNo *)
            (#
            do (*'Props: ' -> puttext; father.doP -> putline;*)
               (if (newBasicProp.primNo -> value) > 0 then
                else                  
                   (if superDesc[] <> none then
                       superDesc.basicNo -> value;
                       (*value -> putint; newline
                        else 'no super'->putline*)
                   if)
               if)
            #); 
          toOrigin:
             (# on: @integer; org: ^Items
             enter on
             do (if on > 0 then
                    (if basicNo = ifthen_prim then 
                        '\n!!! ifthen_prim:A:' -> putline;
                        dopt -> putline;
                        on  -> (origin[]->org[]).toOrigin -> org[]
                     else
                        on - 1 -> (origin[]->org[]).toOrigin -> org[]
                    if)
                 else
                    this(Items)[] -> org[];
                if);
                (if org.basicNo = ifThen_prim then
                    '\n!!! ifthen_prim:B:' -> putline;
                    org.origin[] -> org[]
                if)
             exit org[]
             #); 
          getNameForOff::
            (# b1,b2,b3: @boolean
            do '???' -> NM[];
               (if false then
                   '\n**** getNameForOff:' ->puttext; attOff ->putInt; ' '->put;
                   (if encOG.isValueObj then
                       'isValue: '->puttext
                   if);
                   checkGlobalAccess -> (b1,b2,b3);
                   (if b1 or b2 or b3 then
                       'noGlobals: ' -> puttext
                   if);
                   dopt->putheadN;
               if);
               (if attOff = newOriginOff then
                   'origin' -> NM[];
                   (*'-> ' -> puttext; NM[] -> putline;*)
                   leave getNameForOff
               if);
               L: 
                 scanAllDecls
                 (#
                 do (if nameListInDcl then
                        currentDcl.scanNames
                        (#
                        do (if current.off = attOff then
                               current.T[] -> NM[];
                               leave L
                        if)#)
                     else
                        (if currentDcl.newOff = attOff then
                            currentDcl.sig.id[] -> NM[];
                            leave L
                 if)if)#)
               (*'-> ' -> puttext; NM[] -> putline*)
            #);          
          getDescNo:: (# do QdescNo[1] -> dNo #);
          objDescEq::< 
            (# 
            do (if trace then
                   'Items: '->puttext; getDescNo -> putint; 
                   inner;
                   ' QDNtop: ' -> puttext; QDNtop -> putint;
                   ' descNo: ' -> puttext; descNo -> putint;
                   newline;  
               if);
               DN = getDescNo -> value;
               (if trace then
                   ' items:' -> puttext; value -> putBoolean;
                   doPT -> putline
               if)
            #);
          clear::<
            (#
            do 0 -> vsize -> rsize -> dsize -> originOff
                 -> noOfInner -> innerInx;
               false -> done;
               inner
            #);
          newInnerX: ^Pattern;
          newOriginOff:< IntegerValue;
          vsize,rsize,dsize,originOff,noOfInner,innerInx: @integer;
          isStringModule,
          done: @boolean (* codegen done*)
       #);
     addToDimTable:<
       (# unitProp: ^NewProperty
       enter unitProp[]
       do inner
       #);     
     addToUnitTable:<
       (# unitProp: ^NewProperty
       enter unitProp[]
       do inner
       #);
     NewProperty::<
       (# setUpOrigin::
            (#
            do (if false then
                   '**** NewProperty:setUpOrigin: ' -> puttext; dopt -> putline;
                   origin.dopt -> putline
               if);
               scanSons(# do origin[] -> current.setupOrigin #);
            #); 
         check::
            (# checkBasic:
                 (# NPA: ^NewPropertyArguments
                 do scanSons(#do (if isLast then current[] -> NPA[] if)#);
                    NPA.scanSons
                    (# INV: ^Invocation;
                    do current[] ->INV[];
                       INV.scanSons
                       (#
                       do (if not current.isConstLiteral then 
                              NPA[] -> SemanticError
                              (#
                              do 'Argument of %basic must be an '
                                 'integer constant: ' -> msg;
                                 current.doPT -> putline
                 #)if)#)#)#);
               
               checkInclude:
                 (# NPA: ^NewPropertyArguments
                 do (if false then
                        '**** checkInclude:' -> puttext; dopt -> puthead
                    if);
                    scanSons
                    (#
                    do (none,basicScope.origin[],none,true)->current.check
                    #);
                    scanSons(#do (if isLast then current[] -> NPA[] if)#);
                    NPA.scanSons
                    (# INV: ^Invocation; MI: ^ModuleItem; 
                       ATdx: ^Decl; MD: ^Module
                    do current[] -> INV[];
                       INV.ATd.asDecl -> ATdx[];
                       (if true
                        // ATdx.isModuleItem then
                           (* Must clean -up ModuleIten and Module! *)
                           (ATdx[]->MI[]).MD.markInModuleProp
                        // ATdx.isModule then 
                           (ATdx[]->MD[]).markInModuleProp
                        else
                           father.label -> putline;
                           father.dopt -> putheadN;
                           NPA[] -> SemanticError
                           (#
                           do 'Argument of %include must be a Module: ' 
                                -> msg;
                              current.doPT -> msg
                           #)
                    if)#)
                 #);
               checkRequires:
                 (# NPA: ^NewPropertyArguments; org: ^Items
                 do (if false then
                        '**** checkRequiresProp: '->puttext; dopt->puttext;
                        ' in: ' -> puttext; 
                        (origin[]->org[]).encOG.OGid -> putline
                    if);                    
                    scanSons
                    (# 
                    do (if false then
                           '**   doCheck: ' -> puttext; 
                           current.label ->puttext;
                           ' ' ->put; current.dopt -> putline;
                       if);
                       true -> checkingModule;
                       (if not isFirst then
                           true -> (current[]->NPA[]).inModulePropX;
                       if);
                       (none,basicScope[],none,true)->current.check;
                    #);
                    false -> checkingModule;
                    scanSons
                    (#
                    do (*'** argX: ' -> puttext; current.dopt -> putline;*)
                       (if not isFirst then 
                           current[] -> NPA[];
                           NPA.scanSons
                           (# INV: ^Invocation; MI: ^ModuleItem; ATdx: ^Decl;
                              MD: ^ Module
                           do current[] -> INV[];
                              (*'**   arg:' ->puttext; INV.doPT->putline;*)
                              INV.ATd.asDecl -> ATdx[];
                              (if true
                               // ATdx.isModuleItem then 
                                  (ATdx[]->MI[]).MD[]
                                    -> (theModule).requires.add;
                                  true -> (ATdx[]->MI[]).inModuleProp
                               // ATdx.isModule then
                                  (ATdx[]->MD[])
                                    -> (theModule).requires.add;
                                  true -> MD.inModuleProp;
                               else
                                  NPA[] -> SemanticError
                                  (#
                                  do 'Argument of %requires '
                                     'must be a Module: ' 
                                       -> msg;
                                     current.doPT -> msg
                                  #)
                    if)#)if)#); 
                    (*newline;*)
                    (if false then
                        '**** checkRequires:done: ' -> puttext;
                        dopt -> putline
                    if)
                 #);
               checkEmbody:
                 (# org: ^Items; INV: ^Invocation
                 do (if not (origin[]->org[]).newBasicProp.checkingEmbodiedProp 
                        then
                        (if traceCheck then
                            '**** checkEmbody:'->puttext;
                        if);
                        true -> org.newBasicProp.checkingEmbodiedProp;
                        org.newBasicProp.embodiedProps.scan
                        (#
                        do (*'**   check:'->dumpT; current.dopt -> dumpTN;*)
                           current.scanSons
                           (# OI: ^ObjectInvocation; ok: @boolean; 
                              ATd: ^Decl; pn: @integer
                           do (if not isFirst then 
                                  current.scanSons
                                  (# n: @integer
                                  do current[] -> INV[];
                                     INV.scanSons
                                     (#
                                     do n + 1 -> n;
                                        (if current## = ObjectInvocation## then
                                            current[] -> OI[];
                                            true -> ok
                                     if)#);
                                     (if (n = 1) and ok then
                                         OI.ptnid.T[] 
                                           -> org.localSearch -> (ATd[],pn);
                                         (if ATd[] <> none then
                                             (if traceCheck then
                                                 '**** checkEmbody:found: ' 
                                                   -> puttext;
                                                 ATd.dopt ->putline;
                                             if);
                                             ATd[] -> OI.ATd[] -> INV.ATd[];
                                             true -> OI.isEmbodied
                                         if);
                                         (*'**   check:ATD:'->putline;*)
                                         (none,org[],none,true) -> ATd.check;
                                         0 -> n
                        if)#)if)#)#);
                        false -> org.newBasicProp.checkingEmbodiedProp;
                        (*'**   checkEmbody:end:'->putline*)
                    if)
                 #)
            do (if traceCheck then
                   '**** NewProperty:Check: ' -> puttext; dopt -> putline;
                   (*''**   scope:A: ' -> putline; basicScope.dopt -> puthead*)
               if);
               L:
                 (#
                 do (if true 
                     // '%basic' -> propId.T.equalNCS then
                        checkBasic
                     // '%requires' -> propId.T.equalNCS 
                     // '%module' -> propId.T.equalNCS 
                     // '%modules' -> propId.T.equalNCS then 
                        (if not locateWorld.aMiniBetaModule then
                            checkRequires;
                        if);
                        leave L
                     // '%visible' -> propId.T.equalNCS
                     // '%include' -> propId.T.equalNCS then 
                        checkInclude;
                        checkRequires;
                        leave L
                        
                     // '%domain' -> propId.T.equalNCS then
                     // '%public' -> propId.T.equalNCS then
                     // '%publicInSub' -> propId.T.equalNCS then
                     // '%private' -> propId.T.equalNCS then
                     // '%domain_boundary' -> propId.T.equalNCS then
                     // '%abstract' -> propId.T.equalNCS then
                     // '%embody' -> propId.T.equalNCS then
                        checkEmbody;
                     // '%unit' -> propId.T.equalNCS then
                        this(NewProperty)[] -> addToUnitTable
                     // '%dimension' -> propId.T.equalNCS then
                        this(NewProperty)[] -> addToDimTable
                     // '%association' -> propId.T.equalNCS then
                        
                     // '%globals' -> propId.T.equalNCS then
                     // '%locals' -> propId.T.equalNCS then
                     // '%interface' -> propId.T.equalNCS then
                     // '%arguments' -> propId.T.equalNCS then
                     // '%kind' -> propId.T.equalNCS then
                     // '%immutable' -> propId.T.equalNCS then
                     // '%unique' -> propId.T.equalNCS then
                     // '%external' -> propId.T.equalNCS then
                     // '%core' -> propId.T.equalNCS then
                     // '%OSDvisibility' -> propId.T.equalNCS then
                        scanSons
                        (#
                        do (*current.label->putline; current.dopp -> putline;*)
                           current.scanSons
                           (# i: @integer 
                           do (*current.label -> dumpT; current.dopt ->dumpTN;*)
                              (# INV: ^Invocation;
                                 org: ^Items; V: @integer; 
                                 OI: ^ObjectInvocation
                              do (current[]->INV[]).last -> OI[];
                                 (*OI.dopt -> putline;*)
                                 (if true 
                                  // 'disguised' -> OI.ptnId.T.equalNCS then
                                     2 -> V
                                  // 'SkipInternal' -> OI.ptnId.T.equalNCS then
                                     1 -> V
                                  // 'show' -> OI.ptnID.T.equalNCS then
                                     0 -> V
                                  else
                                     '!!!! %OSDvisibility: wrong argument: ' 
                                       -> putline;
                                     dopt -> putline
                                 if);
                                 (if false then
                                     '**** %OSDVisibility:'->puttext;V-> putint;
                                     newline;
                                 if);
                                 V 
                                   -> (origin[]->org[]).newBasicProp.OSDvisibility;
                                 (if false then org.sig.dopt -> putheadN if)
                              #)
                           #)
                        #)
                     // '%exclude' -> propId.T.equalNCS then
                     // '%ID' -> propId.T.equalNCS then
                        (*'**** %ID: ' -> puttext; dopt -> putline;*)
                        scanSons
                        (# T: ^Text
                        do (*current.dopt -> puttext; ' ' -> put;*)
                           (if not isFirst then
                               current.dopt -> T[];
                               (2,T.length) -> T.sub -> T[];
                               (*' notFirst: "' -> puttext;
                               T[] -> puttext; '"'->put;*)
                               (if 'object' -> T.equalncs then
                                   (*' **** check %ID: ' -> puttext;
                                   current.dopt -> putline;*)
                                else
                                   (*' *** dont check %ID: '  -> puttext;
                                   current.dopt -> putline;*)
                                   leave L
                           if)if)
                        #);
                        (*newline;*)
                     else
                        this(NewProperty)[] -> warning
                        (#
                        do 'Unknown property: ' -> msg;
                           propId.T[] -> msg
                        #)
                    if);
                    scanSons
                    (#do (none,basicScope[],none,true) -> current.check #)
                 #)
            #);
          checkRequires::
            (#
            do (if '%ID' -> propId.T.equalNCS then
                   true -> done
               if)
            #)
       #);
     NewPropertyArguments::<
       (# setUpOrigin:: 
            (#do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (# 
            do (if traceCheck then
                   '**** newPropArg:check: ' -> puttext; dopt -> putline
               if);
               scanSons
               (# INV: ^Invocation; MI: ^ModuleItem; ap: ^Apl
               do (if false then
                      '**   NPargs: ' -> puttext; current.dopt -> puttext;
                      ' ' -> put; inModulePropX -> putboolean; newline;
                      (*
                      (if basicScope[] = none then
                          ' basicScope is none' -> putline
                       else newline;
                          basicScope.dopt -> puthead;
                      if);*)
                  if);
                  inModulePropX -> (current[]->ap[]).inModulePropX;
                  (none,basicScope[],none,true) -> current.check;
                  current[] -> INV[];
               #)
            #)
       #);
     Signature::<
        (* Keyword = Signature(args)
         * else    = Signature(name(id),args?)
         * foo(D1)in(D2)with(D3): super+IS,  where IS ={...}
         * D1, D2 and D3 should be at the same block level as IS;
         * however, D1, D2 and D3 are not Items 
         * - but Items and Signature are sub of Scope
         * Can we have  Arguments = (Items (D1,D2,D3)) 
         * Are the fat commas also items 
         *)
       (# setUpOrigin::
            (#
            do (if false then
                   '**** Signature:setUpOrigin: ' -> puttext; dopt->putline;
               if);
               (if true then
                   scanSons(#do this(Signature)[] -> current.setupOrigin #);
                else
                   scanSons(#do origin[] -> current.setupOrigin #);
               if)
            #);
          check::
            (# 
            do (if traceCheck then
                   '**** Signature:check: ' -> puttext; doPT -> putline
               if);
               (if type[] <> none then
                   (none,basicScope[],none,true) -> type.check;
               if);
               scanSons(#do (none,basicScope[],none,true) -> current.check #);
               
               (if false then
                   (if (args[] <> none) then
                       args.scanSons
                       (#do (none,basicScope[],none,true) -> current.check #)
               if)if)
            #);
          search::
            (# org: ^Scope
            do
               NA.T[] -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (NA[],isFirst) -> (origin[]->org[]).search -> (ATd[],on,pn)
               if)
            #);
          localSearch:
            (# CS: ^Text; ATd,D: ^Decl; pn: @integer
            enter CS[]
            do (if traceSearch then
                   '**** Signature:localSearch: '->puttext; CS[] -> puttext;
                   ' in: ' -> puttext; dopt -> putline
               if);
               L:
               scanSons
               (# doTry: @Boolean; arg: ^Arguments
               do false -> doTry; none -> D[];
                  (* this a mess:
                   * For fatComma, the arguments are apparently in the signature
                   * For function/special/binary, 
                   * the Signature has an Arguments son
                   * where we have to fecth the parameter.
                   * We should fix this!
                   *)
                  (if true
                   // current## <= Decl## then 
                      current[] -> D[]; true -> doTry
                   // current## <= Arguments## then
                      current[] -> arg[]; 
                      arg.scanSons
                      (# 
                      do (if current## <= Decl## then current[] -> D[] if)
                      #);
                      D[] <> none -> doTry
                  if);
                  (if false and doTry then
                      '**** try:CS: ' ->  puttext;
                      CS[] -> puttext; ' sig: ' -> puttext;
                      D.sig.id[] -> puttext; ' ' -> put;
                      D.dopt -> putline;
                  if);
                  (if doTry and (CS[] -> D.sig.id.equalNCS) then
                      (if false then
                          '**** signature:localSearch: found: ' -> puttext;
                          CS[] -> putline;
                      if);
                      D[] -> ATd[];
                      leave L
               if)#)
            exit(ATd[],pn)
            #);
          alloc:: 
            (# 
            do (if type[] <> none then
                   enclIT[] -> type.alloc
               if);
               scanSons
               (#do 
                  (if encOG[] <> none then
                      encOG.IS[] -> current.alloc
               if)#)
            #);
       #);
    Arguments::<
       (# setUpOrigin:: 
            (# 
            do (if false and (noOfSons > 0) then
                   '**** Arguments:setUpOrigin:' -> puttext; dopt -> puthead;
               if);
               scanSons
               (# OG: ^ObjectGenerator; OS: ^ObjectSpecification; 
                  N: ^node; BE: ^BracketedExp
               do (if current## = ObjectGenerator## then
                      (* Foo: 
                       *    ...
                       *    %do body:< Object %with% CCC: ?char: -pattern
                       *        ...
                       *    ...
                       *    %do                 -- ObjectInvocation
                       *       S1
                       *       S2 
                       *    %with% exp
                       *       ... may be empty
                       *)
                      (if trx then
                          '**** setUpOrigin:OG:'-> puttext; 
                          current.label -> putline;
                          current.dopt -> puthead;
                      if);
                      current[] -> OG[]; 
                      (* OG = Object{ S1; S2} *)
                      (if OG.isObjectDesc then
                          OG.father.father.father.father -> N[];
                          (if false then
                              '**** OG in:Arguments: ' -> putline;
                              OG.dopt ->  puthead;
                              '**** OG.father.father.father.father: ' -> puttext;
                              OG.father.father.father.father.label -> putline;
                              OG.father.father.father.father.dopt ->  puthead;
                              '**** OG.father.origin.father: ' ->  puttext; 
                              (If (OG.father.origin[] <> none) and (OG.father.origin.father[] <> none) then
                                  (*Koks: OG..origin is not setup here
                                   * we set it  up below;-)
                                   *)
                                  OG.father.origin.father.label -> putline;
                                  OG.father.origin.father.dopt -> putline 
                               else
                                  'none'->putline
                              if)
                          if);
                          (if N##
                           // objectCall## then
                              N[] -> OS[];
                              (if trx then
                                  '\n**** B:label: ' -> puttext; OS.label->putline;
                                  OS.dopt -> putline;
                                  '**   set:origin:'->putline;
                                  OS.origin.dopt -> puthead;
                              if);
                              (if false then
                                  '**   OC:origin:'->putline; OS.origin.dopt->puthead;
                                  if);
                              OS.origin[] -> current.setUpOrigin;
                           // ObjectGenerator## then
                              N[] -> OS[];
                              (if trx then
                                  '\n**** C:label: ' -> puttext; OS.label -> putline;
                                  OS.dopt -> putline;
                                   '**   set:origin:'->putline;
                                  OS.IS.dopt -> puthead;
                                  '**   OS:'->putline; OS.dopt -> puthead
                              if);
                              (if false then
                                  '**** arguments:setUpOrigin:' -> puttext; dopt -> putline;
                                  '**   OG:origin:'->putline;
                                  OS.IS.dopt->puthead;
                              if);
                              OS.IS[] -> current.setUpOrigin;
                           // BracketedExp## then
                              N[] -> BE[];
                              (if false then
                                  '**   BE:origin:'->putline; origin.dopt->puthead;
                              if);
                              N.origin[] -> current.setUpOrigin;
                           else
                              '!!!! no match:'->puttext; N.label->putline
                          if);
                       else (* exp above comes here *)
                          (if false then
                              'D:label: ' -> puttext;
                              OG.father.father.father.father.label -> putline;
                              OG.father.father.father.father.dopt -> puthead;
                          if);
                          (if trx then
                              '**   other:origin:'->puttext; 
                              current.label -> putline;
                              origin.dopt->puthead;
                          if);
                          origin[] -> current.setUpOrigin;
                      if)
                   else
                      (if false then
                          '**** setUpOrigin:E:'-> puttext; 
                          current.label -> putline;
                          current.dopt->puthead;
                           '**   set:origin:'->putline;
                          (if origin[] <> none then 
                              origin.dopt -> puthead;
                      if)if);
                      origin[] -> current.setUpOrigin 
                  if)
               #);
               (if trx and (noOfSons > 0) then
                   '**** Arguments:setUpOrigin:done:'->putline; dopt -> puthead
               if);

            #);
          check:: 
            (# (* Why not argScope below? *)
            do (if traceCheck then
                   '**** Arguments:check:' -> puttext; dopt -> putline
               if);
               scanArgs
               (# OG: ^ObjectGenerator
               do (*current.label -> putline;*)
                  (if false and (current## = ObjectGenerator##) then 
                      (* a virtual binding or a simgular computing a value*)
                      '**** arg: '->putline; current.dopt -> puthead;
                      current[] -> OG[];
                      (if OG.isObjectDesc then
                          '**  Fathers: ' -> puttext;
                          (*current.father.label -> puttext; ' ' -> put;
                          current.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.label -> puttext; ' ' -> put;*)
                          current.father.father.father.father.label -> puttext; 
                          newline;
                          current.father.father.father.father.dopt->puthead;
                          '*** current.origin: ' -> putline;
                          (if current.origin[] <> none then
                              current.origin.father.doPT -> puthead;
                              '*** origin.origin: ' -> putline;
                              current.origin.origin.father.doPT -> puthead;
                              '*** origin: ' -> putline;
                              origin.father.doPt -> puthead;
                              '*** basicScope: ' -> putline;
                              basicScope.father.doPt -> puthead; 
                              
                           else
                              ' none' -> putline
                          if)
                      if)
                   (* else a Decl? *)
                  if);
                  (none,basicScope[],none,true) -> current.check;
               #)
            #);
          alloc:: (# do scanSons(#do enclIT[] -> current.alloc #)#);
       #);
     NameDecl::<
       (# setUpOrigin::
            (# D: ^Decl; I: ^Item
            do (if false then
                   '**** NameDecl:'->puttext; T[] -> puttext; 
               if);
               father.father.father[] -> ATd[]; 
               (if false then ' '->put; ATd.label -> puttext; if);
               (if (ATd.father[] <> none) then
                   (if true
                    // ATd.father## = Module## then
                       ATd.father[] -> Atd[];
                    // ATd.father## = ModuleItem## then
                       ATd.father[] -> ATd[];
                   if)
               if);
               (* (if ATD.father[] <> none then
                '**** ND:'->puttext; dopt -> putheadN;
                ATd.label -> putline;
                Atd.doPP -> putheadN;
                ATd.father.label -> putline;
                if);*)
                   
               ATd.OG[] -> OG[]
            #);
          check::
            (#
            do (if traceCheck then
                   '**** NameDecl:check:'->puttext; doPT -> putline;
               if);
               (rec[],basicScope[],argScope[],isFirst) 
                 -> ATd.check -> basicScope[]
            #);
          desc::
            (#
            do (*'**** NameDecl:desc:'->puttext; dopt -> putline;*)
               (*ATd.label -> putline;
               ATd.doPT -> putline;*)
               ATd.desc -> D[];
               (IF d[] = NONE THEN '!!!! D is none!'->putline if)
            #)
       #);
     NameList::<
       (# setUpOrigin::
            (#
            do scanSons(#do origin[] -> current.setUpOrigin #)
            #)
       #);
     DataItem::<
       (# setUpOrigin::
            (#
            do (if not isConst and not isValue then
                   true -> OG.super.isSuper
               if);
               origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
               sig[] -> OG.sig[];
               true -> OG.isObj; (* perhaps only for part-objects! *)
            #);
          check::
            (# elm::Items
            do (if traceCheck then
                   '**** DataItem:check: ' -> puttext; sig.id[] -> putline;
               if);
               (none,basicScope[],none,true) -> sig.check;
               (none,basicScope[],none,true) -> OG.check; 
               (If false then OG.super.clearQual; if);
               (if OG.IS.isEmpty and OG.super.hasVirtualArgs then
                   (* Qualifications: obj Set.Set(#Qualification)
                    *  must be converted, but
                    * QS: obj Qualifications
                    *  should not be converted
                    * Supplement of hastVirtualArgs, check if actual args
                    *)
                   (# E: ^Exp
                   do (if (OG## = ObjectCall##) and isConst then
                          OG.super.last -> E[];
                          (if ((E.ATd.asDecl).primNo <> indexed_prim) 
                              and (E.args[] <> none) 
                              and (E.args.noOfSons > 0) then
                              (if true then
                                  '**** DataItem:convertOC2OG: ' ->puttext;dopt -> puthead;
                                  '**   OG.label:' ->puttext;
                                  OG.label -> putline;
                                  '**   OG.super: ' -> puttext;
                                  OG.super.dopt -> puthead;
                              if);
                              (if true then
                                  OG[] -> convertObjectCallToGenerator -> OG[];
                                  OG.clear;
                                  false -> OG.IS.isEmpty;
                                  origin[] -> OG.setUpOrigin;
                                  (none,origin[],none(*origin[]*),true) -> OG.check;
                              if);
                              (if false then
                                  '**   to:'->putline; OG.dopt -> puthead;
                                  OG.label -> putline;
                                  doPT -> putline
                   if)if)if)#)
               if)
            #);
          checkVirtualArgs:: (* skip *)(##);
          markIfVirtualDataItem::
            (* Mark if this dataItem is qualified by a a virtual object 
             * - i.e. has the form:
             *    S: ? elm where elm:< Object
             * In this case elm may be bound to a simple value like Integer or
             * a pattern defining 'real' objects
             *)
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   (* IT is not referred so why an argument?*)
                   (if (OG.super.ATd[] <> none) 
                       and ((OG.super.ATd.asDecl).isVirtualObject) then
                       true -> isVirtualObject -> value                       
               if)if)
            #);
          isVirtualObject: @ Boolean;
          hasVirtualObjectQual::
            (#
            do (OG.super.ATd[] <> none) 
               and ((OG.super.ATd.asDecl).isVirtualObject) 
                 -> value
            #);
          alloc::
            (# fOG: ^ObjectGenerator
            do (if OG.isBasicValue then
                   enclIT.vsize + 1 -> enclIT.vsize -> off
                else
                   enclIT.rsize + 1 -> enclIT.rsize -> off
               if);
               enclIT[] -> sig.alloc;
               enclIT[] -> OG.alloc
            #);          
          desc::
            (# elm:: scope
            do (*'**** DataItem:desc:'->puttext; sig.dopt -> putline;*)
               (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
          objDescEQ::<
            (#
            do (if trace then 'DataItem: ' -> puttext; newline if);
               DN -> OG.objDescEQ -> value;
               (if trace then 'DI:'->puttext; value -> putBoolean if)
            #);
          hasCode:: 
            (* perhaps not suffcient!
             *   S: @T -- hasCode if T hasCode
             *   S: @T{ ... } -- hasCode if T hasCode or main.hasCode
             *   I: @integer --- no code
             *)
            (# 
            do (*OG.hasCode -> value *)
            #);
          clear::< 
            (#do (*'DataItem:clear: ' -> puttext; sig.dopt -> putline; *)#);
       #);
     LabelDecL::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
               sig[] -> OG.sig[];
               (*- does not work: QUA-error - perhaps because
                * we assume that sig[] = none ==> OG is part of a pattern!?
                *)
            #);
          check::
            (# elm::Items
            do (if traceCheck then
                   '**** LabelDecl:check: ' -> puttext; newline;
                   doPT -> putline
               if);
               (none,basicScope[],none,true) -> sig.check;
               (none,basicScope[],none,true) -> OG.check;                
            #);
          alloc::
            (#
            do (if traceAllocC then
                   '**** LabelDecl:alloc: ' -> putline;
                   enclIT.dopt -> putline
               if);
               enclIT[] -> sig.alloc;
               enclIT[] -> OG.alloc
            #);
          desc::
            (# elm:: scope
            do (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
       #);
     Pattern::<
       (# setUpOrigin::
            (# org: ^Items;
            do (if false then
                   'Pattern:setUpOrigin: ' -> puttext; sig.dopt -> putline;
               if);
               origin[] -> sig.setUpOrigin;
               OG[] -> sig.encOG[];
               sig[] -> OG.sig[];
               origin[] -> OG.setupOrigin;
               (if OG.primNo = string_prim then
                   origin[] -> org[]; true -> org.isStringModule
               if)
            #);

          isVirtual:: (#do ptnKind <> PlainPtn -> value #);
          isVirtualObjectX::
            (#
            do (if isVirtual and OG.IS.isEmpty then
                   (*'kuk: ' -> puttext; dopt -> puthead; 
                   ' ' -> put; OG.super.primNo -> putint; newline;*)
                   OG.super.primNo = object_prim -> value
               if);
            #);
          isVirtualObject::
            (#
            do (if isVirtual then
                   (if not (*OG.isObjectDesc*) OG.isObjectGenerator then
                       OG.super.primNo = object_prim -> value
                   if)
               if)
            #);
          hasVirtualObjectQual::
            (#
            do isVirtualObject -> value
            #);
          goSuper: IntegerValue
            (# ptn: ^Pattern; ATdx: ^Decl
            do (if OG.super.ATd[] = none then
                   (if primNo = inner_prim then 1 -> value if)
                else
                   OG.super.ATd.asDecl -> ATdx[];
                   (if ATdx## = Pattern## then
                       (if ((ATdx.asDecl->ptn[]).goSuper 
                             -> value) > 0 then
                           value + 1 -> value;
                           (if false then
                               'BINGO: ' -> putline; dopt -> putline;
                           if);
                           inner_prim -> OG.IS.newBasicProp.primNo;
                           OtherPrimPattern -> currentPtnKind[]
                       if)
               if)if)
            #);
          checkIfInnerSub: 
            (# innerPtn: ^Pattern; org: ^Scope
            do (if goSuper > 1 then
                   (if (origin[]->org[]).newInner[] = none then
                       this(Pattern)[] -> org.newInner[]
                    else
                       this(Pattern)[] -> warning
                       (#
                       do 'It is only possible to redefine inner once!'->msg;
                          '\n     Pattern "' -> msg;
                          org.newInner.sig.dopt -> msg;
                          '" also redefines inner'->msg
                       #)
                   if)
               if)
            #);
          theSig: ^MkSig;
          check::< 
            (# elm:: Items;
               checkInOut:
                 (# inOutError:
                      (#
                      do this(Pattern)[] -> SemanticError
                         (# 
                         do 'A ' -> msg;
                            (if pK
                             // PlainPtn then 'plain' -> msg
                             // VirtualPtn then 'virtual' -> msg
                             // FinalPtn then 'final' -> msg
                             // FurtherPtn then 'further' -> msg
                            if);
                            ' pattern "'->msg; sig.dopt -> msg; 
                            '" cannot be marked as an ' -> msg;
                            (if inOK then 'in' -> msg if);
                            (if outOK then 'out' -> msg if);
                            ' parameter' -> msg
                         #)
                      #);
                    pK: @integer; inOK,outOK: @boolean
                 enter(pK,inOK,outOK)
                 do (if isInArg and not inOK then
                         inOutError
                     if);
                    (if isOutArg and not outOK then
                         inOutError                         
                     if);
                 #);            
               handleVirtualBinding:
                  (* For any pattern: final or further, we search for a virtual
                   * declaration in super 
                   * - and we need to get the off for this virtual
                  * Then we test if super for this FinalPtn is implicit
                  * In qAbstractSyntaxTree::decl:checkVirtualArgs,
                  * we do an almost identical check for virtual arguments
                  * We should unify ...
                  *)
                 (# VP: ^Pattern; (* not always the case ??*)
                    pn: @integer; vDclx: ^NameDecl
                 do (*'Ptn:check:handleVirtualBinding:'->puttext; 
                     * doPT -> putline;*)
                    (if ptnKind 
                     // VirtualPtn then
                        OG[] -> mkSig -> theSig[];
                        (if theSig.isSig and traceSingularFunc then
                            '**** is Signature ' -> putline; dopt -> putline
                        if);
                     // FinalPtn // FurtherPtn then
                        OG[] -> mkSig -> theSig[];
                        (ptnKind,false,false) -> checkInOut;
                        (if nameListInDcl then
                            sig.id[] -> basicScope.superDesc.localSearch 
                              -> (vDclx[],pn);
                            vDclx.asDecl -> vDcl[]
                         else
                            sig.id[] 
                              -> basicScope.superDesc.localSearch 
                              -> (vDcl[],pn);
                        if);
                        (if vDcl[] <> none then
                            (if traceSingularFunc or vDcl.theSig.isSig then
                                '**** super is signature: ' -> putline; 
                                vDcl.doPT -> putline;
                                '**   binding: ' -> puttext; dopt -> putline
                            if);

                            (if false then
                                '**** Found vDcl: ' -> puttext; 
                                vDcl.dopt -> putline;
                                '**   Binding: ' -> puttext; dopt -> putline;
                            if);
                            (* OBS! in V:: A { } isImplSuper should not be true
                             * Only for  V:: { }
                             *)
                            vDcl[] -> VP[];(* -> OG.super.ATd[];*)
                            (* ' pn:' -> puttext; pn -> putint; 
                             ' off:' -> puttext; off -> putint; ' ' -> put; *)
                            (if OG.super.isEmpty then
                                VP[] -> OG.super.ATd[];
                                pn + 1 -> OG.super.pn;
                                true -> OG.super.isImplSuper;
                                (*' isImplSuper=T '-> puttext;*)
                            if);
                            (if VP.OG.hasItems (*not VP.OG.IS.isEmpty*) then
                                true -> OG.super.isSingularImplSuper;
                                (*' isSingularImplSuper=T ' -> puttext; *)
                             else
                                (*' isCategoryImplSuper: ' -> puttext*)
                            if);
                            (*vDcl.sig.doPT -> putline*)
                         else
                            this(Pattern)[] -> SemanticError
                            (#
                            do 'No virtual declaration in super for: "' -> msg;
                               sig.doPT -> msg; '"' -> msg
                            #)
                        if);
                     // plainPtn then
                        (ptnKind,false,false) -> checkInOut
                    if)
                 #);
            do (if traceCheck then  
                   '**** Pattern:check: ' -> puttext; sig.id[] -> putline if);
               handleVirtualBinding;
               (* Must check sig before OG;
                * Items in OG may refer Decl's in sig
                * Allocation of storage for sig must be in OG.IS
                * Scope for Decl's in sig must be basicScope
                * BUT! When checking sig, OG.super is not setup, 
                * which gives problems in
                * foo(x: ? bar):
                *    ...
                * bar: 
                *    S: ? foo
                *    S := foo(e) -- super for foo is not setup
                * Thus we check super before checking sig
                *)
               (* no circularity in super chain is deteched *)
               (none,OG.IS[],none,true) -> sig.check; 
               (none,basicScope[],none,true) -> OG.check;
               (if OG.circularityInSuper then
                   (* a litte bit clumsy *)
                   leave check
               if);
               checkIfInnerSub;
               (if traceGeneric then
                   OG.IS.scanAllDecls
                   (# D: ^Decl
                   do (if currentDcl.isVirtualObject then
                          (*'Virtual Object: ' -> puttext; 
                           currentDcl.doPt -> putline;*)
                      if)
               #)if);
               inner;
            #);
          isInner::<
            (* Perhaps ad hoc!? -- from old code: inner
             * check BKWptn: %inner P
             *)
            (# org: ^Items
            do (if (OG.primNo = inner_prim) -> value then
                   (if false then
                       '**** got inner:\n' -> puttext; dopt -> putline
                   if);
                   basicScope[] -> org[];
                   args.scanArgs
                   (# A: ^ObjectSpecification
                   do current[] -> A[];
                      A.super.on - 1 
                        -> (args.origin[]->org[]).toOrigin -> org[]; 
                   #);
                   org.noOfInner + 1 -> org.noOfinner;
                   (if false then
                       '**   org:'->putline; org.dopt -> puthead
                   if);
                   (if org.noOfInner = 1 then 
                       org.dsize + 1 
                         -> org.dsize 
                         -> org.innerInx 
                   if);
               if);
            #);     
          alloc::< 
            (# add:
                 (* We have a ptn: V:< OGv1, V::< OGv2
                  * OGv1 or OGv2 are bindings of V
                  * For OG2, we should perhaps have the initial V:< OG?
                  *)
                 (# enclosingOG: ^ObjectGenerator; F: ^Node
                 do father.father[] -> F[];
                    (if F##
                     // ObjectGenerator## then
                        (* 'ObjectGenerator: ' -> putline; F.dopt->putline;*)
                     else                           
                        '!!!! Koks:A:'->putline;
                        father.father.label -> putline
                    if)
                 #);
            do (if traceAllocC then
                   '**** Ptn:alloc: ' -> puttext; sig.doPT -> putline;
               if);
               enclIT[] -> OG.alloc;
               (if ptnKind 
                // virtualPtn then 
                   (if false then
                       '**** alloc:virtual ptn: ' -> puttext; 
                       enclIT.dsize -> putint; ' ' -> put;
                       sig.doPT -> putline;
                   if);
                   enclIT.dsize + 1 -> enclIT.dsize -> off;
                   (*add*)
                // furtherPtn // finalPtn then
                   (if false then
                       '**** alloc:Virtual bind: ' -> puttext; 
                       vDcl.off -> putint;
                       ' ' -> put;
                       sig.doPT -> puthead;                   
                   if);
                   (*OG.super.ATd.off -> off;*)
                   vDcl.off -> off;
                   (*add*)
               if);
               sig.names.scanSons
               (# i: @integer
               do (if (i + 1) > 0 then
                      (*'**** pattern:names > 1: ' ->puttext; sig.dopt->putline;
                      off -> current.off *)
                  if)
               #);
               (*inner *)
            #);
          setVirtualBindings::
            (# add:
                 (* We have a ptn: V:< OGv1, V::< OGv2
                  * OGv1 or OGv2 are bindings of V
                  * For OG2, we should perhaps have the initial V:< OG?
                  *)
                 (# enclosingOG: ^ObjectGenerator; F: ^Node
                 do father.father[] -> F[];
                    (if F##
                     // ObjectGenerator## then
                        (if false then
                            '**** SVB:ObjectGenerator: ' -> putline; 
                            F.dopt->putline;
                        if);
                     else                           
                        '!!!! Koks:B:'->putline;
                        father.father.label -> putline
                    if)
                 #);
            do  (if ptnKind 
                // virtualPtn then 
                   (*'**** Virtual ptn: ' -> putline; sig.doPT -> putline;*)
                   add
                // furtherPtn // finalPtn then
                    (*'**** Virtual bind: ' -> putline; sig.doPT -> putline;*)
                    OG.super.ATd.off -> off;
                    add;
               if);
            #);
          handleArgs::
            (# args: [6]^ObjectSpecification; top: @integer;
               enclosingOG: ^ObjectSpecification (*ObjectGenerator*)
            do (if false then
                   '**** HandleArgs: ' -> putline; dopt-> puthead;
                   '**   E: ' -> puttext; E.doPT -> puthead;
                   '**   E.father.father.father:'->putline;
                   E.father.father.father.dopt -> puthead;
               if);
               
               (if E.args[] = none then leave handleArgs if);
               E.args.scanArgs
               (#
               do (if (top+1 -> top) > args.range then 
                      args.range -> args.extend 
                  if);
                  current[] -> args[top][];
               #);
               (if top = 0 then leave handleArgs if);
               L:
               scanArgs
               (# i: @ integer; Ex: ^Exp; 
                  OI: ^ObjectInvocation; descNo: @integer
               do i + 1 -> i; 
                  (if i > top then
                      leave L; (* SemErr dont work for 
                                * Punky: Funky(200,300){...}
                                * Punky(100)
                                * TST/SuperArguments
                                *)
                      E[] -> SemanticError
                      (#
                      do 'Too few actual args: ' -> msg;  
                         E.dopt -> msg;
                      #);
                      leave L
                  if);
                  handleVirtArg:
                    (if currentArg.isVirtual then 
                        (if false then
                            '**   virtualArg: ' -> putline;
                            currentArg.dopt -> putline;
                            '**   args[i]: ' -> putline;
                            args[i].dopt -> putline
                        if);
                        args[i].super.last -> Ex[];
                        (if (Ex[] <> none) and (Ex.isObjectInvocation) then
                            (if false then
                                'Try: ' -> puttext; Ex.label -> putline; 
                                Ex.doPT -> putline;  
                                args[i].doPT -> putline;
                            if);
                            Ex[] -> OI[];
                            (if (args[i].IS[] = none) or args[i].IS.isEmpty then
                                (* We have a non-singular binding, 
                                 * see handleVirtualBinding *)
                                (* newDesc -> args[i].vDescNo;*)
                                true -> args[i].isVirtualArg;
                                (* '*** non-singular argument binding: ' -> puttext; 
                                args[i].vDescNo -> putint; ' ' -> put;
                                args[i].doPT -> putline;*)
                            if);
                            (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                (* 'Got ptn id: ' -> puttext; 
                                 * OI.ptnId.doPT -> puttext;
                                 *)
                                (args[i].desc).descNo -> descNo; (* dont use descNo!*)
                                (* args[i] is a binding of currentArg
                                 * Why dont we use the addBinding call below?
                                 *)

                                leave handleVirtArg
                            if);
                            (if (E.desc).primNo = indexed_prim then 
                                (* We ignore bindings of elm in Indexed *)
                                leave handleVirtArg
                             else
                                (if OI.ATd.(*args[i].*)primNo = integer_prim then
                                    '\n*** Virtual bound to integer in\n\n\t'->puttext;
                                    E.doPT -> putline;
                                    '\n    is ignored by the compiler\n' -> putline;
                                    leave handleVirtArg
                                if);
                            if);
                            (* args[i] is a binding of currentArg *)
                         else
                            (* Not clear which situation we have here?
                             * Apparently a virtual with no super as in
                             *  map:
                             *    in F:<
                             *       in x: ...
                             *       ...
                             *)
                            (if false then
                                'Not OI: ' -> puttext; 
                                (if ex[]=none then 
                                    ' :ex=none: '->puttext;
                                    args[i].label -> puttext; 
                                 else
                                    Ex.label -> puttext; 
                                if);
                                newline;
                                args[i].dopt -> puttext;
                                '\n>>> ' ->puttext;
                                E.dopt -> puttext;
                                '\n>>> ' ->puttext;
                                currentArg.dopt -> putline;
                            if);
                            (* So what is the binding?*)
                        if)
                    if)
               #)
            #);
          desc::<
            (# elm:: items
            do (if false and traceCheck then
                   '**** Pattern:desc:'->putline;
                     dopt -> puthead
               if);
               (if not isChecked and not beingChecked then 
                   (*'!!! ' -> puttext; sig.doPT -> putline;
                   '** Not checked: ' -> putline;
                   doPT -> puthead;*)
                   (none,origin[],origin[],true) -> check;
               if);
               (if not OG.hasItems (*OD.IS.isEmpty*) then
                   (* V: < A, V::< B, or V:: C *)
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
               (*'**** pattern:desc:GOT:' -> putline;
               (if D[] <> none then
                   D.dopt -> puthead;
                else
                   'none' -> putline
               if);
               '**    OF:'->putline; dopt -> puthead;*)
               inner;
            #);

          isRecursive,isRec: @boolean;
          entity:: (#do OG.entity -> E[] #);
          skind:: (# do ': ' -> S[] #);
          getEntries:: (# do OG.getEntries -> (names[],entries[]) #);
          objDescEQ:: 
            (# 
            do (if trace then 'pattern: ' -> puttext; newline if);
               DN -> OG.objDescEQ -> value;
               (if trace then 
                   'pattern:'->putline; value -> putboolean;
                   dopt -> putline
               if)
            #);
       #);
     AssignmentStatement::<
       (# setUpOrigin::
            (#
            do origin[] -> left.setUpOrigin;
               origin[] -> right.setUpOrigin
            #);
          check::
            (# dstE: ^exp
            do (if traceCheck then
                   '***** AssignmentStatement:check:'-> puttext; dopt->putline
               if);
               (none,basicScope[],argScope[],true) -> left.check;
               (none,basicScope[],argScope[],true) -> right.check;
               left.last -> dstE[];
               (* should this check be in semchecker *)
               (if not dstE.ATd.isDataItem then
                   this(AssignmentStatement)[] -> SemanticError
                   (#
                   do 'The left side of the above asignment must be a data-item'
                        -> msg;
                      '\n**   "'-> msg;
                      left.dopt -> msg; 
                      '" is not a data-item'-> msg
               #)if)
               (* perhaps assign as receiver?*)
            #);
       #);
     ObjectCall::<
       (# setUpOrigin::
            (#
            do (if false then
                   '**** ObjectCall:setUpOrigin:\n' -> puttext; dopP -> putline
               if);
               origin[] -> super.setUpOrigin;
               origin[] -> IS.setUpOrigin;
               (*this(ObjectGenerator)[] -> IS.encOG[];*)
               sig[] -> IS.sig[];
               super[] -> IS.super[]
            #); 
          check::
            (# OG: ^ObjectGenerator
            do (if traceCheck then
                   '**** ObjectCall:check: ' -> puttext; doPT -> putline;
               if);
               (none,basicScope[],none(*basicScope[]*),true) -> super.check;
               L:
                 (if (super.ATD[] <> none) and (super.ATd## <> ModuleItem##) then
                     super.ATd.desc -> IS.superDesc[];
                     L:
                       (super.ATd.asDecl).OG.IS.scanAllDecls
                       (#
                       do (if currentDcl.isVirtual then
                              (if false then
                                  '**** ObjectCall:after:convertOC:'->putline; 
                                  dopt -> puthead;
                                  '**   dcl:' -> putline;
                                  super.Atd.dopt -> puthead
                              if);
                              this(ObjectCall)[] 
                                -> convertObjectCallToGenerator
                                -> OG[];
                              OG.clear;
                              (if false then
                                  '**** OG:check:beforeOG.setUpOrigin:'->putline;
                                  origin.dopt -> puthead;
                                  '**   basicScope:' -> putline; 
                                  basicScope.dopt->puthead;
                              if);
                              origin[] -> OG.setUpOrigin;
                              (if false then
                                  ('**   argScope:',argScope[]) -> putPT;
                              if);
                              (none,basicScope[],none(*argScope[]*),isFirst) -> OG.check;
                              leave L
                 if)#)if)
            #);
          alloc::
            (# E: ^Exp
            do (if traceAllocC then
                   '**** ObjectCall:alloc: ' -> puttext; dopt -> putline
               if);
               enclIT[] -> super.alloc;
            #);
          setVirtualBindings::
            (# E: ^Exp
            do (if ((super.last -> E[]) <> none) and (E.ATd[] <> none) then 
                   E[] -> (E.ATd.asDecl).handleArgs 
               if);
            #);
          getDescNo:: (# do ((super.last).ATd.asDecl).OG.getDescNo -> dNo #)
       #);
     ObjectGenerator::<
       (# setUpOrigin::
            (#
            do (if not IS.isEmpty then true -> super.isSuper; if);
               origin[] -> super.setUpOrigin;  
               origin[] -> IS.setUpOrigin;
               this(ObjectGenerator)[] -> IS.encOG[];
               sig[] -> IS.sig[];
               super[] -> IS.super[];
            #); 
          checkSuper: booleanValue
            (# checkIfSuperIsCircular: BooleanValue
                 (# D: ^Decl; ptn: ^Pattern
                 enter D[]
                 do followSuper:
                      (if (D[] <> none) and (D.asDecl).isPatternDecl then
                          D.asDecl -> ptn[];
                          (if (ptn.OG[] = this(ObjectGenerator)[]) then
                              true -> value -> circularityInSuper;
                              this(TopNode)[] -> SemanticError
                              (#
                              do 'There is circularity in the super pattern chain : "'
                                   -> msg;
                                 super.doPT -> msg;
                                 '"' -> msg;
                              #);
                           else
                              ptn.OG.super.ATd[] -> D[];
                              restart followSuper
                      if)if)
                 #);
               checkIfSuperIsPattern:
                 (* A unary exp like XXX where XXX is a data-item
                  * is syntactically an ObjectGenerator (Unary)
                  * with XXX as super and empty main-part:
                  * (ObjectGenerator
                  *    (Invocation
                  *       (Unary
                  *          (name:XXX)
                  *          (Arguments)))
                  *    (Items))
                  * We may consider a new syntactic category:
                  * (DataItemRef
                  *    (Invocation
                  *       (Unary
                  *          (name:XXX)
                  *)
                 (# ND: ^NameDecl; ATdx: ^Decl
                 do super.ATd[] -> ND2D -> ATdx[];
                    (if (ATdx[] <> none) and 
                        (not ATdx.isPatternDecl and not IS.isEmpty) then
                        this(TopNode)[] -> SemanticError
                        (#
                        do 'Super is not a pattern: "' -> msg;
                           super.doPT -> msg;
                           '"' -> msg;
                        #)                       
                    if)
                 #);
               checkIfSuperIsVirtual:
                 (# ptn: ^Pattern; ATdx: ^Decl
                 do super.ATd[] -> ND2D -> ATdx[];
                    (if (ATdx[] <> none) and not IS.isEmpty and 
                        ATdx.isPatternDecl then
                        ATdx[] -> ptn[];
                        (if ptn.ptnKind
                         // virtualPtn // furtherPtn then
                            this(TopNode)[] -> SemanticError
                            (#
                            do 'Super cannot be a virtual pattern: "' -> msg;
                               super.doPT -> msg;
                               '"' -> msg;
                            #)                       
                    if)if)
                 #);
               setUpIS:
                 (* A preliminary attempt to setup IS.superDesc before 
                  * finishing checking of super. 
                  * We need to find out how to R.S.foo{...}!
                  * Can we handle R.S.foo? 
                  * R and S are objects - should be able to search for them.
                  * We must consider wheter or not this should be a seperate
                  * scan of the AST!
                  * But what else is check doing?
                  * Binding of virtuals is one issue and search may depend 
                  * of this!
                  * If IS.superDesc is setup here, we should not do it at 
                  * the end of checkSuper!
                  *)
                 (#
                 do (if not IS.isEmpty then
                        super.scanSons
                        (#  E: ^Exp; OI: ^ObjectInvocation; ATdx: ^Decl; 
                           onx,pnx,n: @integer
                        do current[] -> E[];
                           n + 1 -> n;
                           (if E.isObjectInvocation then
                               E[] -> OI[];
                               (OI.ptnId[],true) 
                                 -> basicScope.search -> (ATdx[],onx,pnx);
                               (if islast and (n = 1) and (ATdx[] <> none) then
                                   (*'**** Got:super:ATd:'->puttext; 
                                    ATdx.dopt->puthead;*)
                                   ATdx.oG.Is[] -> IS.superDesc[]
                                else
                                   (*'**** remote super: '->puttext; 
                                   current.dopt->putline;
                                   dopt -> puthead;*)
                               if)
                            else
                               (if E## = ifThen## then
                                   '**** setUpIS:ifThen:'->puttext;
                                   dopt -> puthead
                               if)
                    if)#)if)
                 #);
               basicScope: ^Scope
            enter basicScope[]
            do (if traceCheck then
                   '**** OG:check:super:' -> puttext; super.dopt -> putline
               if);
               (if super.ATd[] = none then 
                   (* else implict super that has been setUp
                    * Or has been called from Pattern:check
                    *)
                   (*setUpIS; -- ChemicalPlantSystem fails" *)
                   (if sig[] = none (*isSingular*) then
                       (* A singular statement:
                        *     bar(a,...) { ... }
                        * isObjectDesc: IS not empty or has virtual arguments
                        * else: just a pattern invocation
                        * Note! isObjectDesc is not defined before super.check 
                        *       has been executed
                        *)
                       (* checkOI fails in call of check if replacing
                        * 2nd basicScope by none
                        *)
                       (none,basicScope[],basicScope[],true) -> super.check
                    else
                       (* A pattern:
                        *     foo(a: ?int, ...): bar(a, ...){ ... } 
                        * where
                        *     super = bar(a,...) 
                        *)
                       (if false then
                           (* pNewFatCommaFile cannot be used to test if this is
                            * a .qbeta-module, since we parse all files
                            * before checking; a boolean is need for each module
                            *)
                           '**** checkSuper:sig<>none: "'->puttext; 
                           super.dopt -> puttext; '"\nsig: ' -> puttext;
                           sig.dopt -> putline
                       if);
                       (none,basicScope[],(*basicScope[]*)sig[],true) 
                         -> super.check
                   if); 
                   checkIfSuperIsPattern;
                   checkIfSuperIsVirtual;
                   (if (super.ATd[] -> checkIfSuperIsCircular) then
                       '!!!! Circulaity in super: ' -> puttext;
                       dopt  -> puthead;
                       true -> value;
                       leave checkSuper
                   if)
                else
                   (*'**   super.ATd<>none: ' -> puttext; 
                   (if sig[] <> none then sig.dopt -> putline if)*)
               if);
               (* we do this too often - perhaps a boolean: superIsChecked *)
               (if super.ATd[] <> none then
                   super.ATd.desc -> IS.superDesc[];
                else
                   objectDecl.desc -> IS.superDesc[];
                   (if IS.superDesc[] = IS[] then
                       none -> IS.superDesc[];
                   if)
               if);                
               (if traceCheck then
                   '**** check:super:end: ' -> puttext; dopt -> putheadn;
                   ('superDesc',IS.superDesc[]) -> putPT;
                   '**   OG:  ' -> puttext; doPT  -> putheadn;
               if);
            #);
          check::
            (# 
            do (if traceCheck then
                   '**** ObjectGenerator:check:' -> puttext; 
                   doPT -> putHeadn;
                   (*(' basicScope',basicScope[]) -> putPT;
                   ('origin',origin[]) -> putPT;
                   (if origin[] <> none then
                       ('origin.father',origin.father[]) -> putPT;
                   if)*)
               if);
               (*origin[] -> basicScope[];*)
               (* !!!!!! to fix @if S.exists{... } : then ...*)
               (if basicScope[] -> checkSuper then 'leave'->putline; leave check if);
               (if hasItems or super.hasVirtualArgs then
                   (none,origin[],none(*origin[]*),true) -> IS.check 
               if);
            #);
          isObjectDesc::
            (* this can be a singular or pattern defined ObjectDesc:
             *    IS.hasItems
             * It can also be an ObjectInvocation with virtual arguments
             *     super.hasVirtualArguments
             * that has to treated as an ObjectDesc
             * And super is not a basic pattern
             *     not super.isPrimitive
             *)
            (#
            do hasItems or (super.hasVirtualArgs and not super.isPrimitive)
                 -> value;
            #);
          alloc::
            (# E:^Exp
            do (if traceAllocC then
                   '**** OG:alloc:' -> puttext; dopt -> putHeadN
               if);
               enclIT[] -> super.alloc;
               enclIT[] -> IS.alloc 
            #);
          setVirtualBindings::
            (# E: ^Exp
            do 
               (if ((super.last -> E[]) <> none) and (E.ATd[] <> none) then 
                   E[] -> (E.ATd.asDecl).handleArgs 
               if);
               (if traceGeneric2 then

               if);
            #);         
          hasCode:: (# do true -> value #);
          hasVirtualObject: @boolean;


          getNameForOff::
            (#do (attOff,descNo,isRef,isIndexed) -> IS.getNameForOff -> NM[] #);
          getDescNo:: 
            (# ptn: ^Pattern
            do (if (IS.QdescNo[1] -> dNo) = 0 then
                    (* Virtual bindings like DD in V ::< DD *)
                    (if (superPtn -> ptn[]) <> none then
                        ptn.OG.getDescNo -> dNo
                    if)
               if)
            #);
          objDescEq:: 
            (# 
            do (if trace then 'OG: ' -> puttext; newline if);
               DN -> IS.objDescEq -> value;
               (if trace then
                   'OG:' -> puttext; value -> putBoolean;
                   doPT -> putline
               if)
            #);
          clear::<
            (#
            do 0 -> vDescNo;
               inner
            #)
       #);
     Invocation::<
       (* INV = R.Q.X, where R,Q,X: exp, R,Q may be data-item or patter*)
       (# setupOrigin:: 
            (#
            do scanSons
               (# E: ^Exp
               do isSuper -> (current[]->E[]).isSuper;
                  origin[] -> E.setUpOrigin; 
               #)
            #);
          check::
            (# E: ^Exp; OGS: ^OGsequence; lastMIa: ^ObjectInvocation;
               emitUnits:
                 (# i: @integer; U: ^text
                 enter(i,E[],U[])
                 do (if false and (U[] <> none) then
                        (if i = 1 then
                            '**** INV:units:OF:'->puttext; dopt -> putline;
                        if);
                        '**   INV::i='->puttext; i -> putint;
                        ' ' ->put; E.dopt -> puttext;
                        ' unit:'->puttext; U[] -> putline;
                 if)#)
            do (if (trx) or traceCheck then
                   '**** Invocation:check: ' -> puttext; doPT -> putheadn;
               if);
               scanSons
               (# i: @integer;
                  emit:
                    (# i: @integer
                    enter i 
                    do (if trx then
                           '**** INV:check:i=' -> puttext; i -> putint;
                           ' ' -> put; rec.dopt -> puttext;
                           ' label: ' -> puttext; current.label -> putline
                       if)
                    #);
                  ap: ^Apl; 
               do i + 1 -> i; i = 1 -> isFirst;
                  (if i > 1 then i - 1 -> emit if);
                  inModulePropX -> (current[] -> ap[]).inModulePropX;
                  (* Given: X: {...; R.foo(e1).bar(e2).x; ...}
                   * the scope for foo is R, but the scope for e1 is X
                   * the scope for bar is foo, but X for e2
                   *)
                  (rec[],basicScope[],argScope[],isFirst,OGS[]) 
                                     (**********)
                    -> current.checkOI
                    -> (basicScope[],OGS[]);
                  (if isLast and (basicScope[] <> none) then
                      basicScope.OGofScope -> theQual[]
                  if);
                  current[] -> rec[];
                  (if isLast then
                      (* can be Exp with args or a pattern name (#foo) *)
                      rec.ATd[] -> ATd[];
                      rec.on -> on;
                      (* we keep track of the last MI:
                       *    R.S.MI.foo
                       * If R, S and MI are moduleItems, 
                       * then MI must be %required.
                       * R and S do not have to be required.
                       *)
                      i -> lgth;
                      (if i > 1 then i -> emit if)
                  if);
               #);   
               scanSons
               (# i: @integer; E: ^Exp
               do i + 1 -> i;
                  (i,(current[]->E[]),E.expUnit[]) -> emitUnits
               #)
            #);
          alloc:: 
            (# 
            do (if traceAlloc then
                   '**** INV:alloc: ' -> puttext; doPT -> putline
               if);
               scanSons(# do enclIT[] -> current.alloc #);
            #);
       #);

     ObjectInvocation::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> ptnId.setUpOrigin; 
               origin[] -> args.setUpOrigin
            #);
          checkOI::
            (# BS: ^Scope
            do (if traceCheck or traceGetVqual then
                   '**** ObjectInvocation:checkOI: '->puttext;
                   dopt->puthead; ' ' -> put;
                   ' isFirst:'->puttext; isFirst -> putBoolean; newline
               if);
               (rec[],basicScope[],none(*argScope[]*),isFirst) 
                 -> check 
                 -> basicScope[];
               (if (ATd.asDecl).primNo 
                // this_prim then
                   (* ad hoc - must be fixed *)
                   (# A: ^Item
                   do args.scanArgs(# do current[] -> A[] #);
                      (if true then
                          (none,basicScope[],none(*basicScope[]*),true) -> A.check;
                       else
                          (none,argScope[],argScope[],true) -> A.check;
                      if);
                      A.desc -> basicScope[];
                   #)
                // indexedGet_prim then
                   (if false then
                       '**** IndexedGet_prim:'->dumpT; dopt -> dumpTN;
                       doPP->dumptN;
                       father.doPP ->dumpTN;
                   if);
                   basicScope[] -> BS[];
                   (*'**   scan:'->dumptN;*)
                   father.scanSons
                   (# pred: ^node; OI: ^ObjectInvocation; DI: ^DataItem; 
                      E: ^Exp; OG: ^ObjectSpecification; ptn: ^Pattern; 
                      encOG,qual: ^ObjectGenerator;
                   do (*'**   father:son'->dumpt; current.dopt -> dumptn; *)
                      (if current[] = this(ObjectInvocation)[] then
                          (*'**   current=this(OI):'->dumpT;*)
                          (if pred[] <> none then
                              pred [] -> OI[];
                              OI.ATd.asDecl -> DI[]; 
                              (*DI.dopt->dumpTN; DI.doPP -> dumpTN;*)
                              DI.OG.super.last -> E[];
                              (if E.args[] <> none then
                                  (*'**  E.args:'->dumpT; E.args.dopt->dumpTN;*)
                                  E.args.scanArgs(#do current[] -> OG[] #);
                                  (if OG[] <> none then
                                      OG.super.last-> OI[];
                                      (if not OI.isChecked then
                                          (none,basicScope[],argScope[],true)
                                            -> OI.check;
                                      if);
                                      (if OI.ATd[] = none then
                                          'OI.atd is none'->putline;
                                      if);
                                      (OI.ATd.asDecl->ptn[]).OG.IS[] 
                                        -> basicScope[]
                      if)if)if)if);
                      (* here we must use argScope - else semantioc errors
                       * and BS does neither work
                       *)
                      (args[],argScope[]) -> argBuf.add;
                      current[] -> pred[];
                      (if isFirst then
                          origin.father[] -> encOG[]
                       else
                          BS.father[] -> encOG[]
                      if);
                      (encOG[],not isFirst,OGS[]) 
                        -> getVqual -> (OGS[],qual[]);
                   #)              
                else
                   (if false and 
                       (argScope[] <> basicScope[]) and (argScope[] <> none) then
                       '**** argScope differs:' -> putline;
                       (if argScope[] = none then 'none' -> putline
                        else
                           argScope.dopt->puthead;
                       if);
                       '**   basicScope:' -> putline; basicScope.dopt->puthead;
                   if);
                   (args[],argScope[]) -> argBuf.add;  
                   (* ok if static/dynamicObject - what does
                    * this mean?
                    * If pattern, scope is the desc of the return value
                    * ATd.desc <> none is before we used get_Qual 
                    * - can be eliminated
                    *)
                   (* Calling this(ObjectInvocation).getV_ qual *)
                   basicScope[] -> BS[];
                   (# encOG,qual: ^ObjectGenerator; org: ^Scope; 
                      ptn: ^Decl; isArgToSuper: @Boolean
                   do (if false then
                          '**   checkOI:BS:' -> puttext; BS.label -> puttext;
                          ' origin: ' -> puttext; origin.label -> puttext;
                          ' origin.father: ' -> puttext; 
                          origin.father.label -> putline; 
                          '**   ATd: ' -> puttext; ATd.dopt -> putline;
                          '**   ATd.origin: ' -> puttext; 
                          ATd.origin.label -> putline;
                          ATD.origin.dopt -> putline;
                          ATD.origin.father.dopt -> putline;
                      if);
                      (if 'Signature' -> ((ATd.asDecl).origin.label).equalNCS
                          then
                          (* Here we check for the situation where 
                           * thisOI = Xa in foo(Xa) and declared as Xd
                           *    bar(Xd: var Integer): foo(X){...}
                           * The condition is
                           *    Xd is a parameter of a pattern P
                           *       true if Xa.ATd.origin = Signature of P
                           *    Xa appears in super of P.OG
                           * In this case, encOG as passed of getVqual below
                           * is P.OG and not origin.encOG.
                           * We have not considered the case of not first below!
                           * This is a preliminary solution - we should 
                           * reconsider the notion of scope and origin.
                           *)
                          (ATd.asDecl).origin.father[] -> ptn[];
                          ptn.OG.super.scanSons
                          (# E: ^Exp;
                          do current[] -> E[];
                             (if E.args[] <> none then 
                                 E.args.scanArgs
                                 (#
                                 do (if current[] 
                                        = this(ObjectInvocation).father.father[]
                                        then
                                        (if false then
                                            '**   OI:checkOI:found:arg: ' 
                                              -> puttext; 
                                            current.dopt -> putline;
                                        if);
                                        true -> isArgToSuper;
                      if)#)if)#)if);   
                      (if isFirst then
                          (if true then
                              (if isArgToSuper then
                                  ptn.OG[] -> encOG[]
                               else
                                  (origin[]->org[]).encOG[] -> encOG[];
                              if);
                           else
                              origin.father[] -> encOG[]
                          if)
                       else
                          (if traceGetVqual then
                              '**** computing:encOG:BS.father=encOG:'
                                -> puttext; 
                              BS.father.dopt -> putheadN;
                          if);
                          (* BS = BasicScope
                           * For INV = R.X.Y, 
                           * R = BS for X, since  X is defined in R
                           *)
                          BS.father[] -> encOG[]
                      if);
                      (if traceGetVqual then
                          '**** encOG:' -> puttext; 
                          encOG.dopt -> putheadn;
                      if);
                      (encOG[],not isFirst,OGS[]) 
                        -> getVqual 
                        -> (OGS[],qual[]);
                      (if trx then
                          '**** checkOI:getVqual:GOT: ' ->puttext;
                          ptnID.dopt ->putline;
                          '**** qual:'->putline;
                          qual.dopt -> putheadN;
                          '**** OGS:'->putline;
                          OGS.print
                      if);
                      qual.IS[] -> basicScope[];
                      (if trx then
                          '**** checkOI:after:getVqual:OF: ' -> puttext;
                          ptnID.dopt -> puttext; ' qual:'->putline;
                          qual.dopt -> puthead;
                          '**** OGS:'->putline;
                          OGS.print;
               if)#)if);
               (if trx then 
                   '**** next:basicScope:from:' -> puttext;
                   ptnID.T[] -> putline; basicScope.dopt -> puthead;
               if)
            #);
          hasVirtualArgs: @boolean;
          check::
            (# elm:: Items;
               checkIfOneBasicDecl:
                 (* we check if scp has exactly one DataItem like
                  *    magnitude: var float
                  * if this is the case, we search for ptnID in float;
                  * This is needed for Unit.
                  * We must ensure we are in a Unit-pattern with a %unit prop;
                  * this is  currently not done
                  *)
                 (# scp: ^Items; n: @integer; DI: ^DataItem; dcl: ^Decl
                 enter scp[]
                 do(* '**** checkIfOneBasicDecl: ' -> puttext; dopt->putline;*)
                    scp.scanAllDecls
                    (#
                    do (if currentDcl.isDataItem then
                           n + 1 -> n;
                           currentDcl[] -> DI[];
                    if)#);
                    (if n = 1 then
                        (*'**** Got:DI: ' -> puttext; DI.dopt -> putline;*)
                        (if DI.OG.IS.isEmpty 
                            and (((DI.OG.super.last).ATd[]->dcl[]) <> none)
                            and (dcl.OG.primNo = float_Prim)
                            then
                            (* dcl[] = none may happen in e.g.
                             *    ind : var intEEger
                             * where intEEger is not declared
                             *)
                            (dcl.asDecl).OG.IS[] -> scp[]; 
                            ptnId.T[] -> scp.localSearch -> (ATd[],pn);
                    if)if)
                 #);
               checkIfAbstract:
                 (* check if ATdx is a pattern having an %abstract property 
                  * which is illegal
                  *)
                 (# ATdx: ^Decl
                 enter ATdx[]
                 do (if ATdx.isPattern then
                        (if not isSuper 
                            and ATdx.OG.IS.newBasicProp.isAbstract then
                            this(ObjectInvocation)[] -> SemanticError
                            (#
                            do 'Pattern: "'-> msg; ptnId.dopt -> msg;
                               '" is abstract and cannot be instantiated'
                                 -> msg
                            #)
                        if)
                    if)
                 #);
               org: ^Scope; OGq: ^ObjectGenerator; done: @boolean;
               MD: ^Module; MI: ^ModuleItem; ATdx: ^Decl;
               OS: ^objectSpecification;
            do (if trx or traceCheck then
                   '**** ObjectInvocation:check: '->puttext; dopt->putline;
                   (* ptnID.T[] -> putline;*)
                   (*('scope',basicScope[]) -> putPT*)
               if);
               (if basicScope[] <> none then (* ad hoc *)
                   (ptnId[],isFirst) -> basicScope.search -> (ATd[],on,pn);
                   (if ATd[] <> none then
                       on -> ptnId.on; (* just for debugging *)
                       (if on > (origin[]->org[]).maxOn then
                           on -> org.maxOn;
                       if);
                       (if false then
                           '**** maxOn: ' -> dumpT; org.maxOn -> dumpI;
                           on -> dumpI; ptnId.T[] -> dumptN;
                       if);
                       (ptnId[],on,pn,ATd[]) -> found;
                       ATd.asDecl -> ATdx[] -> ptnId.ATd[];
                       (none,ATdx.origin[],ATdx.origin[],true) -> ATd.check;
                       ATdx[] -> checkifAbstract;                        
                    else
                       (if false then
                           '**** OI:check:notFound: ' -> puttext;
                           ptnId.dopt -> putline;
                           basicScope.doPt -> putline;
                       if);
                       (if basicScope## = Items## then
                           basicScope[] -> checkIfOneBasicDecl;
                       if);
                       (if ATd[] <> none then
                          (* '**** found: ' -> putline;
                           ATd.doPT -> putline*)
                        else
                           this(TopNode)[] -> SemanticError
                           (#
                           do 'Did NOT find a declaration of: "'-> msg;
                              ptnId.T[] -> msg;
                              '"' -> msg;
                           #);
                           errorDecl[] -> ATd[]
                   if)if); 
                   this(Exp)[] -> (ATd.asDecl).checkVirtualArgs 
                     -> hasVirtualArgs;
                else
                   'ObjectInvocation:check: scope is none: '->puttext; 
                   dopt -> putline
               if);
            #);
          checkRequires::
            (# MI: ^ModuleItem
            do (if false then
                   '**** OI:checkRequires: ' -> puttext;
                   dopt -> puttext; ' ' -> put;
                   father.father.father.dopt -> putline;
               if);
               (if ATd[] = none then
                   '!!!! OI:checkRequires:ATd:NONE ' -> puthead;
                   true -> done;
                   leave checkRequires;
               if);
               (if isModuleItem then
                   ATd.asDecl -> MI[];
                   (if false then
                       '**** Got:moduleItem: ' -> puttext;
                       ptnId.dopt -> puttext;
                       ' ' -> put;
                       inModulePropX -> putboolean;
                       newline;
                       father.father.father.dopt -> puthead;
                       (theModule).requires.print
                   if);
                   
                   (if not inModulePropX 
                       and not (MI.MD[]->(theModule).requires.has) then
                           this(objectInvocation)[] -> warning
                           (#
                           do 'The module "' -> msg;
                              ptnId.T[] -> msg;
                              '" cannot be accessed;\n     must be'
                              ' listed in a %requires property' -> msg
                           #)
               if)if);
               true -> done
            #);
          isModuleItem: @boolean;
          mustBeObject::
            (# error:
                 (#
                 do true -> value;
                    this(ObjectInvocation)[] -> Semanticerror
                    (#
                    do 'must be a data-item: ' -> msg;
                       dopt -> msg
                    #)
                 #);               
               ptn: ^Pattern; D: ^Decl
            do (*'**** mustBeObject: ' -> puttext; dopt -> putline;*)
               (if (ATd.asDecl -> D[]) <> none then
                   L:
                     (if true 
                      // D.isDataItem // D.isModuleItem then
                         (* OK *)                       
                      // D.isPattern then
                         (*'**   mustBeObj:'->puttext; dopt -> putline;*)
                         (D[] -> ptn[]).getReturnDecl -> D[];
                         (if D[] = none then 
                             (if true then
                                 (* Problem here with e.g. 
                                  *  B := (@this String = S)
                                  * Seems to parse as (@this (String = S))
                                  *)
                                 error
                             if)
                         else 
                             restart L
                         if)
                      else
                         error
               if)if)
            #);
          alloc:: 
            (# org: ^Items
            do (if ATd[] = none then 
                   'ATd is none: '->puttext; label -> puttext; ' ' -> put;
                   father.label -> puttext; ' ' -> put;
                   father.father.label -> puttext; ' ' -> put;
                   ' Father.father: ' -> putline;
                   father.father.doPT-> putline; 
               if);
               (*'\nalloc:ATd.isinner: ' -> puttext; label -> putline;
               dopt -> putline;*)
               
               (if (enclIT[],args[]) -> (ATd.asDecl).isInner then
                   (if false then
                       '**   inner:'->puttext; on -> putint; ' ' -> put;
                       label -> puttext; ' ' -> put; dopt -> putline;
                       'father: ' -> puttext; father.label -> puttext; 
                       ' father.father: ' -> puttext;
                       father.father.label -> putline;
                       origin[] -> org[];
                       (for i: on repeat
                            org.origin[] -> org[];
                            '**   origin: ' ->putline;
                            org.doPT -> puthead;
                       for)
               if)if);
               (if (ATd[] <> none) and ((ATd.asDecl).isPattern) 
                   and ((ATd.asDecl).OG.primNo = inner_prim) then
                   (*'**** OI:alloc: ' -> puttext; dopt -> putline*)
                else                   
                   scanSons(#do enclIT[] -> current.alloc #);
               if);
               (*'handleArgs'->puttext; dopt->putline;*)
               (* this(Exp)[] -> ATd.handleArgs *)
            #);
          hasVirtualObjectQual: @boolean;
       #);
     IfThen::<
       (# setUpOrigin::
            (#
            do origin[] -> cond.setUpOrigin;
               origin[] -> thenPart.setUpOrigin;
            #);
          alloc:: (#do scanSons(#do enclIT[] -> current.alloc #)#);
          check::
            (#
            do (if traceCheck then
                   '**** IfThen: ' -> puttext; dopt -> putline
               if);
               (none,basicScope[],none(*argScope[]*),true) -> cond.check;
               (none,basicScope[],none(*argScope[]*),true) -> thenPart.check;
               ifThenDecl[] -> ATd[]
            #);
          checkOI::
            (#
            do (if false then
                   '*** checkOI: ' -> puttext; dopt -> putline;
               if);
               (rec[],basicScope[],argScope[],isFirst) 
                 -> check 
                 -> basicScope[];
            #)
       #);
     IfThenElse::<
       (# setUpOrigin::
            (#
            do origin[] -> cond.setUpOrigin;
               origin[] -> thenPart.setUpOrigin;
               origin[] -> elsePart.setUpOrigin;
            #);
          check::
            (#
            do (if traceCheck then
                   '**** IfThenElse:check:' -> putline; dopt -> puthead;
               if);
               (none,basicScope[],none(*argScope[]*),true) -> cond.check;
               (none,basicScope[],none(*argScope[]*),true) -> thenPart.check;
               (none,basicScope[],none(*argScope[]*),true) -> elsePart.check;
               ifThenDecl[] -> ATd[]
            #);
          checkOI::
            (#
            do (if false then
                   '*** checkOI: ' -> puttext; dopt -> putline;
               if);
               (rec[],basicScope[],argScope[],isFirst) 
                 -> check 
                 -> basicScope[];
            #);
          alloc:: (#do scanSons(#do enclIT[] -> current.alloc #)#);
       #);
     BracketedExp::<
       (# setUpOrigin:: 
            (# 
            do (if false then
                   '**** BracketedExP:setUpOrigin:noOfSons: ' -> puttext; 
                   noOfSons -> putint;  ' ' -> put;
                   doPT -> putline;
                   '**   origin: ' -> putline; origin.doPT -> putline
               if);
               (if noOfSons = 1 then
                   origin[] -> IV.setUpOrigin 
                else                   
                   scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          checkOI::
            (# 
            do (if traceCheck then
                   '**** BracketedExP:checkOI:noOfSons: ' -> puttext; 
                   noOfSons -> putint;  ' ' -> put;
                   doPT -> putline;
                   '**   basicScope: ' -> puttext; basicScope.dopt -> putline
               if);
               (if noOfSons = 1 then
                   (rec[],basicScope[],argScope[],isFirst) 
                     -> IV.check -> basicScope[];
                   (* Note: we do not assign basicScipe below! *)
                else
                   scanSons
                   (#
                   do (rec[],basicScope[],argScope[],isFirst) -> current.check 
               #)if);
               IV.ATd[] -> ATd[];
               IV.on -> on
            #); 
          check:: 
            (# 
            do (if traceCheck then
                   '**** BracketedExP:check: ' -> puttext; doPT -> putline;
                   '**   basicScope: ' -> puttext; basicScope.dopt -> putline
               if);
               (if noOfSons = 1 then
                   (rec[],basicScope[],argScope[],isFirst) 
                     -> IV.check -> basicScope[];
                else
                   scanSons
                   (#
                   do (rec[],basicScope[],argScope[],isFirst) -> current.check 
               #)if);                 
               IV.ATd[] -> ATd[];
               IV.on -> on
            #);
          alloc:: (# do enclIT[] -> IV.alloc #)
       #);
     const::<
       (# checkOI:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #);
          check:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     floatConst::<
       (# checkOI:: (# do floatDecl[] -> ATd[]; ATd.desc -> basicScope[] #);
          check:: (# do floatDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);          
     charObj::<
       (# checkOI:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #);
          check:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     stringObj::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          checkOI::
            (#
            do scanSons
               (# B: ^Scope
               do (rec[],basicScope[],argScope[],true) 
                    -> current.check -> B[];
               #);
               stringDecl[] -> ATd[]; ATd.desc -> basicScope[];
            #);
          check:: 
            (# 
            do scanSons
               (# B: ^Scope
               do (rec[],basicScope[],argScope[],true) 
                    -> current.check -> B[];
               #);
               stringDecl[] -> ATd[]; ATd.desc -> basicScope[];
            #)
       #);
     mkSig:
       (# trace: (# exit false#);
          equal: BooleanValue
            (# subSig: ^mkSig
            enter subSig[]
            do (if trace then
                   '**** mkSig:equal:top:' -> puttext; 
                   subSig.top->putint; newline;
                   subSig.theOG.dopt -> putline;
                   '**   theOG:top:' -> puttext; top -> putint; newline;
                   theOG.dopt -> putline;
               if);
               L:
                 (if (top = subSig.top) and isSig then
                     true -> value;
                     (for i: top repeat
                          (if not (subSig.inArgs[i].OG.getqual
                                -> (inArgs[i].getQual).inSuper) then
                              false -> value;
                              leave L
                     if)for);
                     (if (subSig.outArg[] <> none) and (outArg[] = none) then
                         false -> value;
                         leave L
                     if);
                     (if (subSig.outArg[] = none) and (outArg[] <> none) then
                         false -> value;
                         leave L
                     if);
                     (if (subSig.outArg[] = none) and (outArg[] = none) then
                         leave L
                     if);
                     (if subSig.outArg.getQual <> outArg.getQual then
                         false -> value
                     if)
                 if)
            #);
          inArgs: [3] ^Decl; top: @integer; 
          outArg: ^Decl; isSig,hasOther: @boolean;
          theOG: ^ObjectGenerator
       enter theOG[]
       do theOG.IS.scanSons (* must also scan super items, can be non-singular*)
          (# D: ^Decl
          do (if current.isDecl then
                 (if false then
                     '**   dcl:' -> puttext; current.dopt -> puttext;
                 if);
                 current[] -> D[];
                 (if true
                  // D.isInarg then
                     (if (top + 1 -> top) > inArgs.range then
                         inArgs.range -> inArgs.extend;
                     if);
                     D[] -> inArgs[top][]
                  // D.isOutArg then
                     D[] -> outArg[]
                  else
                     true -> hasOther
                 if)
              else
                 true -> hasOther
             if);
          #);
          not hasOther and ((top > 0) or (outArg[] <> none)) -> isSig;
          (if false then
              (if isSig then
                  '**   is signature' -> putline
               else
                  '**   is not signature' -> putline
          if)if)
       exit this(mkSig)[]
       #);
     found:
       (# inSame: booleanValue
            (# dclOrigin,aplOrigin: ^Items
            enter dclOrigin[]
            do ptnId.father.father.origin[] -> aplOrigin[];
               (if false then
                   '**** dclOrigin: ' -> putline; dclOrigin.dopt -> putline;
               if);
               Loop:
                 (#
                 do (if false then
                        '**** aplOrigin: ' -> putline; aplOrigin.dopt ->putline;
                    if);
                    inner inSame;
                    (if not value then
                        (if (aplOrigin.origin[] -> aplOrigin[]) <> none then
                            restart Loop
                 if)if)#)
            #);
          inSameOrigin: inSame
            (#
            do dclOrigin[] = aplOrigin[] -> value
            #);
          inSubOfSameOrigin: inSame
            (#
            do aplOrigin.enclosingObjectGenerator
                 -> (dclOrigin.enclosingObjectGenerator).inSuper 
                 -> value
            #);
          checkAccesability:
            (# 
            do (if ATd.accesslevel <> acc_public then
                   (if MDcall[] = MDdcl[] then (* in same domain *)
                       (if ATd.accesslevel = acc_private then
                           (if not (ATd.origin[] -> inSameOrigin) then
                               ptnId[] -> warning
                               (#
                               do 'Attribute is not accessible: ' -> msg;
                                  ptnID.dopt -> qmsg;
                                  '\n     Must be in same enclosing ' -> msg;
                                  'object descriptor as the declaration' -> msg
                               #)
                       if)if)
                    else (* in different domains *)
                       (if ATd.accesslevel 
                        // acc_private // acc_domain then
                           ptnId[] -> warning
                           (#
                           do 'Attribute is not accessible: ' -> msg;
                              ptnID.dopt -> qmsg;
                              '\n     CallerDomain: ' -> msg;
                              MDcall.sig.dopt -> qmsg;
                              ' DeclDomain: ' -> msg;
                              MDdcl.sig.dopt -> qmsg;
                           #);
                        // acc_publicInSub then
                           (if not (ATd.origin[] -> inSubOfSameOrigin) then
                               ptnId[] -> warning
                               (#
                               do 'Must be in subpattern of decl pattern: '
                                    -> puttext;
                                  ptnID.dopt -> putline     
                               #)
               if)if)if)if)
            #);
          ptnId: ^Name; on,pn: @integer; ATd: ^Decl; MDcall,MDdcl: ^Module;
          trx2: @boolean; T: ^text
       enter(ptnId[],on,pn,ATd[])
       do ptnId.enclosingDomain -> MDcall[];
          ATd.enclosingDomain -> MDdcl[];
          (if MDcall[] <> MDdcl[] then
              (if false then
                  '*** In different domains: ' -> puttext;
                  ptnId.T[] -> puttext; ' caller: ' -> puttext;
                  MDcall.sig.dopt -> puttext;
                  ' dcl: ' -> puttext; MDdcl.SIG.dopt -> putline
              if)
          if);

          (if trx or traceSearch then
              '**** Found: "' -> puttext; ptnId.T[] -> puttext; 
              '" on=' -> puttext; on -> putint;
              ' pn=' -> puttext; pn -> putint;
              ' Decl: "' -> puttext; 
              (ATd[]->ND2D).sig.doPT -> puthead; 
              '" visibility: '->puttext;
              (if ATd[] <> none then                  
                  (if ATd.accessLevel
                   // acc_domain then '"domain"' -> puttext;          
                   // acc_public then '"public"' -> puttext;
                   // acc_publicInSub then '"publicInSub"' -> puttext;
                   // acc_private then '"private"' -> puttext;
                  if);
              if);
              '\n**   encModule: "'->puttext; MDcall.sig.dopt -> puttext;
              '" domainModule: "' -> puttext; MDdcl.sig.dopt->puttext; '"'->put;
              newline;
          if);
          (if trx2 then checkAccesability if);
       #);

     newDesc: @
       (# OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;
          getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectGenerator
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
 
     mkContextLines:
       (# N: ^Node; T,Lines: ^Text; ch: @char; 
          first,last,p,inx,lineNo: @integer
       enter N[]
       do true -> (N.theModule).doPT -> Lines[];
          N.beginPos -> p;
          (* find the position in N, 4 lines before N *)
          L:
            (if (first < 4) and (p > 1) then
                p - 1 -> p;
                (if (p -> Lines.inxGet) = ascii.newline then 
                    first + 1 -> first 
                if);
                restart L
            if);
          
          L: (if (inx + 1 -> inx) < p then
                 (if (inx ->Lines.inxGet) = ascii.newline then
                     lineNo + 1 -> lineNo
                 if);
                 restart L
             if);
            
          &text[] -> T[];
          lineNo + 1 -> lineNo -> T.putint; ':'  ->  T.put;
          (*  print fra pos p to N.endPos *)
          L:
            (if (0 < p) 
                and ((p <= N.endpos) or (ch <> ascii.newline))
                and (p <= Lines.length) then
                Lines.T[p] -> ch -> T.put;
                (if  ch = ascii.newline then
                    lineNo + 1 ->  lineNo -> T.putint; ':'  ->  T.put;
                if);
                p + 1 -> p;
                restart L
            if);

          (*T.newline;*)
       exit T[]
       #);
     notification: 
       (# msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          qmsg:
            (# T: ^text;
            enter T[]
            do '"' -> lex.errorStream.put; T[] -> msg; '"' -> lex.errorStream.put;
            #);
          n: ^TopNode;
          thisModule: ^module;          
          printHeading:< (# do '\n' -> puttext;inner #);
          printLines:
            (*  use getContextLines above! *)
            (# first,last,p: @integer; ch: @char; Lines: ^Text;
            do true -> (n.theModule).doPT -> Lines[];
               n.beginPos -> p;
               L:
                 (if (first < 4) and (p > 1) then
                     p - 1 -> p;
                     (if  (p -> Lines.inxGet) = ascii.newline then 
                         first + 1 -> first if);
                     restart L
                 if);
               L:
                 (if (0 < p) and ((p <= n.endpos) or (ch <> ascii.newline))
                     and (p <=Lines.length) then
                     Lines.T[p] -> ch -> put;
                     p + 1 -> p;
                     restart L
                 if);
               newline;
            #);         
          report:< BooleanValue(#do inner #);
       enter n[] 
       do (*n.theModule -> errorModule[];*)
          (if report then
              (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
              (if not withPos then 
                  printHeading;
                  ' in module: "' -> puttext; 
                  (if n.theModule <> none then                  
                      (n.theModule->thisModule[]).sig.doPT -> puttext; 
                      '"' -> put; newline;
                      printLines;;
                      (*n.father.doPT -> putline*)
                   else
                      'n.theModule = none"'->putline
                  if);
                  '**** ' -> puttext;
                  &text[] -> lex.errorStream[]
              if);
          
              (if withPos then
                  n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                    -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;
                  n.endPos -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;   
              if);
              INNER;              
              lex.errorStream.newline;
              (if not withPos then
                  lex.errorStream[] -> putline
              if);
          if)
       #);
     SemanticError: Notification
       (# report:: (# do reportSemErr -> value #);
          printHeading::
            (#
            do 'Semantic error' -> puttext;
            #);
       do INNER;
          true -> semanticErrors
       #);
     QuaCheck: Notification
       (# report:: (# do reportQuaCheck -> value #);
          printHeading:: 
            (# 
            do 'Run-time check needed' -> puttext
            #)
       do (if reportQuaCheck then inner if)
       #);
     Warning: Notification
       (# report:: (# do true -> value #);
          printHeading::(#do 'WARNING' -> puttext #);
       do inner
       #);
     semanticErrors: @boolean;
     emitCom_before: @Boolean
  do (if verbose then '**** CHECKER  ****' -> putline if);
     0 -> newDesc.noOfDescs; (* needed when exe from minienv
                              * we must find a way to compile changed modules
                              * currently we compile all modules
                              *)
     false -> semanticErrors;
     none -> error_stream[];
     argBuf.init;
     (if rootModule.origin[] <> none then
         'B:rootModule.origin:not none ' -> putline;
         rootModule.doPT -> putline;
     if);
     cd.emitCom -> emitCom_before;
     (if traceCheck then true -> cd.emitCom if);
     rootModule.setUpOrigin;
     rootModule.check;
     emitCom_before -> cd.emitCom;
     (if main[] = none then          
         '\n\n!!!! main is none!'->putline; 
         '     This may be because of a case-inconsistency' -> putline;
         '     in the path name to the CWD like:'->putline;
         '        ".../BETAworld/LIB/.../foo"'->putline;
         '        ".../BETAworld/lib/.../foo"'->putline;
         '     May happen with Cugwin'->putline
     if);
     (none,main.origin[],none(*main.origin[]*),true) -> main.check;
     main.MarkInModuleProp;
     argBuf.check;
     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline;
         lex.errorStream[] -> error_stream[]
      else
         (if verbose then '**** ALLOC    ****'->putline if);
         rootModule.alloc;
         (if verbose then '**** SET VIRTUAL BINDINGS ****' -> putline if);
         rootModule.setVirtualBindings;
         (*main.doPP -> putline;*)
         inner
     if);
  #)
