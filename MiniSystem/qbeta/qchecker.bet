ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
INCLUDE 'qprimitives';
INCLUDE 'qvirtual'
---lib:attributes---
(* origin is always in instance of Items or none - for the outermost Module 
 * basicScope = origin for Items
 * argScope = basicScope in most cases
 * except for a pattern: Signature: ObjectGenerator:super, where
 *  (none,basicScope[],sig[],true) -> super.check;
 * argScope is mainly passed as argument to check
 * but saved in argBuf.add and then used in argBuf.check
 * Checking is recursive whenever neeeded, see abstractsyntaxtree::check
 *)
elimOrigin: (# exit true #);
traceGeneric: (# exit false #);
traceGeneric2: (# exit false #);
traceGeneric3: (# exit false #);
handleGeneric: (# exit true #);
traceNoGlobals: (# exit false #);
checker: Parser
  (# traceCheck,traceSearch: @ boolean;
     Module::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> DI.setUpOrigin
            #);
          check::
            (#
            do (if verbose then
                   '**** Module: ' -> puttext; DI.sig.doPT -> putline
               if);
               (none,basicScope[],basicScope[],true) -> DI.check;
               this(Module)[] -> imports.addM
            #);
          alloc:: 
            (# 
            do (*'Module:alloc: ' -> puttext; moduleName->putline; *)
               IT[] -> DI.alloc 
            #);
          desc:: (#do DI.desc -> D[] #);
          clear::<
            (#
            do (*'Clear: '->puttext; DI.sig.doPT -> putline;*)
               false -> isAdded -> isIncluded -> inMainPath;
               inner
            #)
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do (if verbose then
                   'Check ModuleItem: ' -> puttext; sig.doPT -> putline;
               if);
               (if false then
                   (none,basicScope[],basicScope[],true) -> MD.check
               if);
               false -> wasChecked
            #);
          alloc:: 
            (# 
            do (if isChecked then IT[] -> MD.alloc if)
            #);
          desc:: (# do MD.desc -> D[] #)
       #);
     Items::<
       (# PT::
            (#
            do (if false then
                   '(' -> lx.put;
                   originOff -> lx.putint; ',' -> lx.put;
                   vsize -> lx.putint; ',' -> lx.put;
                   rsize -> lx.putint; ',' -> lx.put;
                   dsize -> lx.putint; ',' -> lx.put;
                   noOfInner -> lx.putint; ',' -> lx.put;
                   innerInx -> lx.putint;
                   ')' -> lx.put;
                   (pos,break) -> mkbreak
               if);
            #);
          setUpOrigin::
            (# 
            do false -> isChecked -> beingChecked (*-> isVinxd -> isRinxd*) -> done ;
               0 -> descNo -> vsize -> rsize -> originOff -> noOfInner -> dsize -> innerInx;
               0 -> QDNtop;
               scanSons(# do this(Items)[] -> current.setupOrigin #);
               (if props[] <> none then
                   this(Items)[] -> props.setUpOrigin
               if);
            #);
          checkGlobals:
            (# noGlobalsInSuper,noGlobals,noGlobalsInSub: @boolean
            do (if superDesc[] <> none then
                   &superDesc.checkGlobals -> 
                   (noGlobalsInSuper,noGlobals,noGlobalsInSub)
               if);
               (if true
                // (noGlobals = false) and (noGlobalsInSub = false) then
                   (* super may acces globals
	            * main may access globals unles globals-property
                    * so scan for globals below *)
                // (noGlobals = false) and (noGlobalsInSub = true) then
                   (* super may access globals
	            * main may not access globals, so leave *)
                   true -> noGlobalsInSuper -> noGlobals -> noGlobalsInSub;
                   leave checkGlobals
                // (noGlobals = true) and (noGlobalsInSub = false) then  
                   (* super may not access globals
	            * main may access globals unless globals-prop
                    * scan for globals in main *)
                // (noGlobals = true) and (noGlobalsInSub = true) then  
                     (* super may not access globals
	              * main may not access globals - leave *)
                   true -> noGlobalsInSuper -> noGlobals -> noGlobalsInSub;
                   leave checkGlobals
               if);
               noGlobals -> noGlobalsInSuper;
               false -> noGlobals -> noGlobalsInSub;
               (if props.globals[] <> none then 
                   (if traceNoGlobals then 
                       'Has globals prop: '->puttext; props.dopt -> putline
                   if);
                   true -> noGlobals -> noGlobalsInSub;
                   L: props.globals.scanSons
                     (# P: ^Property
                     do current[] -> P[]; 
                        (if ('inSub' -> P.P.T.equalNCS) then
                            (*'***insub'-> putline; dopt -> putline;*)
                            (* OBS [globals[P1,P2,inSub,...]] *)
                            false -> noGlobalsInSub
                         else 
                            false -> noGlobals -> noGlobalsInSub; 
                            leave L 
                     if)#); 
               if);
               (if traceNoGlobals then
                   '-----CheckGlobals:\n '->puttext;
                   father.dopt -> putline;
                   (if noGlobalsInSuper then 'noGlobalsInSuper:true, ' -> puttext if);
                   (if noGlobals then 'noGlobals:true, ' -> puttext if);
                   (if noGlobalsInSub  then 'noGlobalsInSub:true' -> puttext if);
                   newline;
               if);
            exit(noGlobalsInSuper,noGlobals,noGlobalsInSub)
            #);
          
          check::
            (# checkDoubleDecls:
                 (#
                 do (*'\ncheckDoubleDecls: ' -> puttext;*)
                    scanDecls
                    (# thisDcl: ^Decl
                    do currentDcl[] -> thisDcl[]; 
                       (* thisDcl.sig.id[] -> puttext; '>' -> put;*)
                       L:
                         scanAllDecls
                         (#
                         do (*currentDcl.sig.id[] -> puttext; ' ' -> put;*)
                            (if currentDcl[] = thisDcl[] then leave L if);
                            (if currentDcl.sig.id[] -> thisDcl.sig.id.equalNCS then
                                (* We must check that currentDcl is actually 
                                 * a binding of thisDcl; perhpas 
                                 * currentDcl.off = thisDcl.off is ok?
                                 *)
                                (if not (thisDcl.isVirtual and currentDcl.isVirtual) then
                                    thisDcl[] -> SemanticError
                                    (#
                                    do 'Double declaration of: "' -> msg;
                                       thisDcl.sig.id[] -> msg; '"' -> msg
                            #)if)if);
                         #);
                       (*newline;*)
                    #)
                 #);
 
            do (if traceCheck then '*** Check Items: \n' -> puttext; doPT->putline if);
               this(items)[] -> basicScope[];
               (if props[] <> none then 
                   (none,basicScope[],basicScope[],true) -> props.check 
               if);
               scanSons
               (# I: ^Item;
               do (none,basicScope[],basicScope[],true) -> current.check;
                  current[] -> I[];
                  (if I.hasCode then true -> doHasCode if)
               #);
               checkDoubleDecls;

               checkGlobals -> (noGlobalsInSuper,noGlobals,noGlobalsInSub);
               (*'***** checkglobals:'->putline;
                (theObjectGenerator).dopt -> putline;
                (if noGlobalsInSuper then ' -> noGlobalsInSuper'->puttext if);
                (if noGlobals then ' -> noGlobals' -> putline if);*)
               
               (if traceNoGlobals and  noGlobalsInSuper and not noGlobals then
                   '\n****noGloblasInSuper but globals in main: ' -> putline;
                   (theObjectGenerator).dopt -> putline
               if);
               (if traceNoGlobals then
                   (if noGlobals then
                       '*** no globals may be accessed: ' -> putline;
                    else
                       '*** globals may be accessed ' -> putline
               if)if);
            #);
          noGlobalsInSuper,         (* true: no global access in super *)
          noGlobals,                (* true: no global access in main *)
          noGlobalsInSub: @boolean; (* true: no global access in main.sub *)
          alloc::
            (# allocOrigin:
                 (# 
                 do (if elimOrigin and noGlobals then
                     else
                        rsize + 1 -> rsize -> originOff
                    if)
                 #);
            do (if traceNoGlobals then
                   (if noGlobals then
                       '*** thisOG does not acces global attributes:\n '
                         -> puttext;
                       father.father.dopt -> putline
               if)if);
               (if super.ATd[] <> none then
                   (if superDesc[] = none then
                       'Items:alloc: ' -> puttext; dopt -> putline;
                   if);
                   superDesc.vsize -> vsize;
                   superDesc.rsize -> rsize;
                   superDesc.dsize -> dsize;
                   (if super.isThisBlockLevel and 
                       (not super.isImplSuper) and (not super.isSingularImplSuper)
                       then
                       (if elimOrigin and noGlobalsInSuper then
                           rsize + 1 -> rsize -> originOff
                        else
                           superDesc.originOff -> originOff
                       if)
                    else
                      allocOrigin 
                   if)
                else
                   allocOrigin
               if);
               (if sig[] <> none then
                   this(items)[] -> sig.alloc
               if);
               scanSons(# do this(items)[] -> current.alloc #);
            #);
          topSuper:
            (# topDesc: ^Items
            do (if superDesc[] <> none then
                   superDesc.topSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          localSearch::
            (#
            do (if traceSearch then
                   '>>>Items:localSearch: ' -> puttext; CS[] -> putline;
                   'in:' -> putline; doP -> putline
               if);
               search:
                 (#
                 do scanSons
                    (# I: ^Item; AT: ^Decl; MI: ^ModuleItem; MD: ^Module
                    do (*'LocalSearch: ' -> puttext;  CS[] -> putline;*)
                       current[] -> I[]; 
                       (if I.isDecl then
                           I[] -> AT[]; 
                           (*'Try: ' -> puttext; AT.sig.id[] -> putline;*)
                           (if (CS[] -> AT.sig.id.equalNCS) then
                               (* 'Found in: ' -> puttext; doPT -> putline;*)
                               AT[] -> ATd[];
                               (if ATd## = ModuleItem## then
                                   (* A hack 
                                    * And worse: this does not work as long as
                                    * we check all modules. An non included
                                    * module may use another non included module,
                                    * which implies that this modules will be
                                    * marked as used!
                                    *)
                                   (*'!!!! Found ModuleItem (hack): ' -> puttext;
                                   ATd.sig.doPT -> putline;*)
                                   ATd[] -> MI[];
                                   (*true -> MI.MD.isAdded -> MI.MD.isIncluded*)
                                   MI[] -> (theModule->MD[]).imports.add
                               if);
                               Leave search
                    if)if)#);
                    (if trySig and (sig[] <> none) then
                        (CS[],false) -> sig.localSearch -> (ATd[],pn); (* pn = 0 *)
                        (* (if ATd[] <> none then                            
                         * 'Found in signature: ' -> puttext; CS[] -> puttext;
                         * ' decl: ' -> puttext; ATd.doPT -> putline*)
                    if);
                    (if (ATd[] = none) and (superDesc[] <> none) then
                        (CS[],true) -> superDesc.localSearch -> (ATd[],pn);
                        pn + 1 -> pn
                    if)
                 #)
            #); 
          
          search::
            (# org: ^Items; F: ^Node
            do (if traceSearch then
                   '>>>Items:Search:'->puttext; CS[] -> putline;
                   'in: ' -> putline; doP -> putline
               if);
               (CS[],true) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (if incl[] = none then 
                       (*'!!!!!Items:search:incl=none-search for: '->puttext;
                       CS[] -> putline*)
                    else
                       CS[] -> incl.searchInclude -> ATd[];
                   if);
                   (if (ATd[] = none) and isFirst then
                       (if (origin[] -> org[]) <> none then
                           (CS[],isFirst) -> org.search -> (ATd[],on,pn);
                           (if not org.isChecked then
                               (if traceCheck then
                                   '\n*** Origin not checked\n' -> puttext;
                                   doPT -> putline;
                                   '    Search: ' -> puttext; 
                                   org.father.label -> putline;
                                   org.father.doPT -> putline
                               if);
                               (none,org[],org[],true) -> (org.father[]->F[]).check
                           if);
                           (if basicNo = ifthen_prim then
                               (* '!!! Origin:search:%if%then: Adjust ON: ' 
                                * -> puttext; 
                                * doP -> putline *)
                            else
                               on + 1 -> on ;
                               (if traceSearch then
                                   '>>> on + 1 = ' -> puttext; on -> putint;
                                   (if ATd[] <> none then 
                                       ' found! ATd.father:' -> putline;
                                       ATd.father.doPT -> putline;
                                    else
                                       ' not found' -> putline
                                   if);
                                   (*doP -> putline*)
                               if)
                           if)
               if)if)if)
            #);
          basicNo: integerValue
            (* should be used in primNo *)
            (#
            do (*'Props: ' -> puttext; father.doP -> putline;*)
               (if (props[] <> none) and 
                   (props.basicProp[] <> none) then
                   (if (props.basicProp.primNo -> value) = 0 then
                       (if superDesc[] <> none then
                           superDesc.basicNo -> value;
                            (*value -> putint; newline*)
                        (*else 'no super'->putline*)
                       if)
                    (*else         
                       value -> putint; newline*)
                   if)
                else (*'none: '->puttext;*)
                   (if superDesc[] <> none then
                       superDesc.basicNo -> value;
                       (*value -> putint; newline
                    else 'no super'->putline*)
                   if)
               if)
            #); 
          toOrigin:
             (# on: @integer; org: ^Items
             enter on
             do (if on > 0 then
                    (if basicNo = ifthen_prim then
                        on  -> (origin[]->org[]).toOrigin -> org[]
                     else
                        on - 1 -> (origin[]->org[]).toOrigin -> org[]
                    if)
                 else
                    this(Items)[] -> org[];
                if);
                (if org.basicNo = ifThen_prim then
                    org.origin[] -> org[]
                if)
             exit org[]
             #); 
          getNameForOff::
            (#
            do '???' -> NM[];
               (*'\ngetNameForOff: ' -> puttext; attOff -> putInt; ' ' -> put;*)
               (if attOff = originOff then
                   'origin' -> NM[];
                   leave getNameForOff
               if);
               L:
                 scanSons
                 (# I: ^Item; D: ^Decl
                 do current[] -> I[];
                    (if I.isDecl then
                        I[] -> D[];
                        I[] -> D[];
                        (if D.off = attOff then
                            D.sig.id[] -> NM[];
                            leave L
                        if)
                    if)
                 #)
            #);          
          getDescNo:: (# do QdescNo[1] -> dNo #);
          objDescEq::< 
            (# 
            do (if trace then
                   'Items: '->puttext; getDescNo -> putint; 
                   inner;
                   ' QDNtop: ' -> puttext; QDNtop -> putint;
                   ' descNo: ' -> puttext; descNo -> putint;
                   newline;  
               if);
               DN = getDescNo -> value;
               (if trace then
                   ' items:' -> puttext; value -> putBoolean;
                   doPT -> putline
               if)
            #);
          super: ^Invocation (*Apl*);
          clear::<
            (#
            do 0 -> vsize -> rsize -> dsize -> originOff
                 -> noOfInner -> innerInx;
               false -> done;
               inner
            #);
          vsize,rsize,dsize,originOff,noOfInner,innerInx: @integer;
          isStringModule,
          done: @boolean (* codegen done*)
       #);
     Properties::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check:: 
            (# 
            do scanSons
               (#do (none,basicScope[],basicScope[],true) -> current.check#)
            #)
       #);
     Property::<
       (# setupOrigin::
            (# 
            do (if P[] <> none then (* probably to be improved/generalized *)
                   origin[] -> P.setupOrigin;
               if);
               (if arg[] <> none then origin[] -> arg.setupOrigin if)
            #);
          check::
            (# elm:: scope;
            do (if P[] <> none then
                   (none,basicScope[],basicScope[],true) -> P.check;
                   (* only for globals, interface, etc
                    * Not for basic, const, etc
                    *)
                   (P.T[],true) -> basicScope.search -> (P.ATd[],P.on,P.pn);
                   (if false and (P.ATd[] = none) then
                       '\n*** Did not find a declartion of property: ' 
                         -> puttext;
                       P.T[] -> putline
               if)if);
               (if arg[] <> none then
                   (none,basicScope[],basicScope[],true) -> arg.check
               if)
            #)
       #);
     Include::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (if son[] <> none then
                   (if verbose then 
                       '*** Check include:' -> puttext; doPT -> putline if);
                   basicScope.origin[] -> basicScope[];
                   scanSons
                   (#do (none,basicScope[],basicScope[],true) -> current.check#);
                   (* Force check of included modules *)
                   scanSons
                   (# IV: ^Invocation; MI: ^ModuleItem
                   do current[] -> IV[];
                      (if IV.ATd[] <> none then
                          IV.ATd[] -> MI[];
                          (NONE,MI.MD.origin[],MI.MD.origin[],true) -> MI.MD.check;
                          true -> MI.isChecked;
                          (if not MI.MD.isAdded then
                              MI[] -> (encModule).MD.imports.add;
                              true -> MI.MD.isAdded
                        if);
                   if)#)
               if)
            #);
          alloc:: 
            (# 
            do 
               scanSons(#do IT[] -> current.alloc #)
            #);
          searchInclude:
            (# CS: ^Text; ATd: ^Decl
            enter CS[]
            do (none,origin[],origin,true) -> check;
               search:
                 scanSons
                 (# IV: ^Invocation; MI: ^ModuleItem; pn: @integer
                 do (if traceSearch then
                        '*** Include:search: ' -> puttext; 
                        current.doPT -> putline;
                    if);
                    current[] -> IV[];
                    (if IV.ATd[] = none then 'searchInclude:IV.ATd=none'->putline if);
                    (if IV.ATd.desc = none then 'IV.ATd.desc=none'->putline if);
                    (CS[],false) -> (IV.ATd.desc).localSearch -> (ATd[],pn);
                    (if ATd[] <> none then
                        (*'Found: ' -> puttext; CS[] -> puttext;
                         ' in %include: ' -> puttext; IV.doPT -> putline;*)
                        IV.ATd[] -> MI[]; 
                        (if not MI.MD.isAdded then
                            MI[] -> (encModule).MD.imports.add;
                            true -> MI.MD.isAdded
                        if);
                        leave search
                    if)
                 #)
            exit ATd[]
            #)
       #);
     Signature::<
       (# setUpOrigin::
            (#
            do scanSons(#do origin[] -> current.setupOrigin #);
               (if args[] <> none then
                   args.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (# 
            do (if traceCheck then
                   '*** Check signature: ' -> puttext; doPT -> putline
               if);
               (if type[] <> none then
                   (none,basicScope[],basicScope[],true) -> type.check;
               if);
               (if args[] <> none then
                   (none,basicScope[],basicScope[],true) -> args.check
               if);
               (if val[] <> none then
                   (none,basicScope[],basicScope[],true) -> val.check
               if)
            #); 
          alloc:: 
            (# 
            do (if type[] <> none then
                   IT[] -> type.alloc
               if);
               (if args[] <> none then
                   IT[] -> args.alloc
               if);
               (if val[] <> none then
                   IT[] -> val.alloc
               if)
            #);
          search::
            (# org: ^Scope
            do (if traceSearch then
                   '>>>Signature:search: ' -> puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               (CS[],false) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (CS[],isFirst) -> (origin[]->org[]).search -> (ATd[],on,pn);
                   on + 1 -> on; (* check this *)
                else
                   (if traceSearch then '*** Found in signature' -> putline if)
               if)
            #);
          LocalSearch::
            (# 
            do (if traceSearch then
                   '>>>Signature:LocalSearch: '->puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               Loop:
                 (if args[] <> none then 
                     args.scanArgs
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if);
               Loop:
                 (if val[] <> none then
                     (*'Val: ' -> putline;
                     val.doPP -> putline;*)
                     val.scanSons
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if)
            #); 
       #);
    Arguments::<
       (# setUpOrigin:: 
            (# 
            do scanSons
               (# OG: ^ObjectGenerator
               do (if current## = ObjectGenerator## then
                      (* Foo: 
                       *    ...
                       *    %do body:< Object %with% CCC: ?char: -pattern
                       *        ...
                       *    ...
                       *    %do                 -- ObjectInvocation
                       *       S1
                       *       S2 
                       *    %with% exp
                       *       ... may be empty
                       *)
                      current[] -> OG[];
                      (* OG = Object{ S1; S2} *)
                      (if OG.isObjectDesc then
                          OG.father.father.father.father -> OG[];
                          OG.IS[] -> current.setUpOrigin
                       else (* exp above comes here *)
                          origin[] -> current.setUpOrigin
                      if)
                   else
                      origin[] -> current.setUpOrigin 
                  if)
               #)
            #);
          check:: 
            (# (* Why not argScope below? *)
            do scanArgs
               (# OG: ^ObjectGenerator
               do (*current.label -> putline;*)
                  (if current## = ObjectGenerator## then (* a virtual binding *)
                      current[] -> OG[];
                      (if OG.isObjectDesc then
                         (*'***** Virtual: ' -> putline;
                          current.doPT -> putline;
                          'Fathers: ' -> puttext;
                          current.father.label -> puttext; ' ' -> put;
                          current.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.father.label -> puttext; 
                          newline;
                          '*** Origin: ' -> putline;
                          (if current.origin[] <> none then
                              current.origin.doPT -> putline;
                              '*** origin.origin: ' -> putline;
                              current.origin.origin.doPT -> putline;
                              '*** origin: ' -> putline;
                              origin.doPt -> putline
                           else
                              ' none' -> putline
                          if)*)
                      if)
                   (* else a Decl? *)
                  if);
                  (none,basicScope[],basicScope[],true) -> current.check;
               #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);
     Value::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (#
            do scanSons
               (#do (none,basicScope[],basicScope[],true) -> current.check #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);          
     DataItem::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
               (*sig[] -> OG.sig[] - does not work: QUA-error - perhpas because
                * we assume that sig[] = none ==> OG is part of a patter!?
                *)
            #);
          check::
            (# elm::Items
            do (if traceCheck then 
                   '*** DataItem:check: ' -> puttext; sig.doPT -> putline if);
               (none,basicScope[],argScope[],true) -> sig.check;
               (none,basicScope[],argScope[],true) -> OG.check; 
            #);
          checkVirtualArgs:: (* skip *)(##);
          markIfVirtualDataItem::
            (* Mark if this dataItem is qualified by a a virtual object 
             * - i.e. has the form:
             *    S: ? elm where elm:< Object
             * In this case elm may be bound to a simple value like Integer or
             * a pattern defining 'real' objects
             *)
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   (* IT is not referred so why an argument?*)
                   (if (OG.super.ATd[] <> none) 
                       and (OG.super.ATd.isVirtualObject) then
                       true -> isVirtualObject -> value                       
               if)if)
            #);
          isVirtualObject: @ Boolean;
          hasVirtualObjectQual::
            (#
            do (OG.super.ATd[] <> none) and (OG.super.ATd.isVirtualObject) 
                 -> value
            #);
          alloc::
            (# fOG: ^ObjectGenerator
            do (if IT[] <> none then (* IT is none if top module *)
                   (if OG.isSimpleValue then
                       IT.vsize + 1 -> IT.vsize -> off
                    else
                       IT.rsize + 1 -> IT.rsize -> off
               if)if);
               IT[] -> sig.alloc;
               IT[] -> OG.alloc
            #);          
          desc::
            (# elm:: scope
            do (if not OG.hasItems then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
          isSimpleValue: booleanValue(# do OG.isSimpleValue -> value #);
          objDescEQ::<
            (#
            do (if trace then 'DataItem: ' -> puttext; newline if);
               DN -> OG.objDescEQ -> value;
               (if trace then 'DI:'->puttext; value -> putBoolean if)
            #);
          hasCode:: 
            (* perhaps not suffcient!
             *   S: @T -- hasCode if T hasCode
             *   S: @T{ ... } -- hasCode if T hasCode or main.hasCode
             *   I: @integer --- no code
             *)
            (# 
            do (*OG.hasCode -> value *)
            #);
          clear::< 
            (#do (*'DataItem:clear: ' -> puttext; sig.dopt -> putline; *)#);
       #);
     Pattern::<
       (# setUpOrigin::
            (# org: ^Items;
            do origin[] -> sig.setUpOrigin;
               sig[] -> OG.sig[];
               origin[] -> OG.setupOrigin;
               (if OG.primNo = string_prim then
                   origin[] -> org[]; true -> org.isStringModule
               if)
            #);
          isVirtual:: (#do ptnKind <> PlainPtn -> value #);
          isVirtualObject::
            (#
            do (if isVirtual then
                   (if not OG.isObjectDesc then
                       OG.super.primNo = object_prim -> value
                   if)
               if)
            #);
          hasVirtualObjectQual::
            (#
            do isVirtualObject -> value
            #);
          check::< 
            (# elm:: Items;
               handleVirtualBinding:
                  (* For any pattern: final or further, we search for a virtual
                   * declaration in super 
                   * - and we need to get the off for this virtual
                  * Then we test if super for this FinalPtn is implicit
                  * In qAbstractSyntaxTree::decl:checkVirtualArgs,
                  * we do an almost identical check for virtual arguments
                  * We should unify ...
                  *)
                 (# VP: ^Pattern; (* not always the case ??*)
                    pn: @integer
                 do (*'Ptn:check:handleVirtualBinding:'->puttext; 
                     * doPT -> putline;*)
                    (if ptnKind // FinalPtn // furtherPtn then
                        (sig.id[],false) 
                          -> basicScope.superDesc.localSearch -> (vDcl[],pn);
                        (if vDcl[] <> none then
                            (*'Found vDcl: ' -> puttext; 
                             * vDcl.sig.dopt -> puttext;*)
                            (* OBS! in V:: A { } isImplSuper should not be true
                             * Only for  V:: { }
                             *)
                            vDcl[] -> VP[];(* -> OG.super.ATd[];*)
                            (* ' pn:' -> puttext; pn -> putint; 
                             ' off:' -> puttext; off -> putint; ' ' -> put; *)
                            (if OG.super.isEmpty then
                                VP[] -> OG.super.ATd[];
                                pn + 1 -> OG.super.pn;
                                true -> OG.super.isImplSuper;
                                (*' isImplSuper=T '-> puttext;*)
                            if);
                            (if VP.OG.hasItems (*not VP.OG.IS.isEmpty*) then
                                true -> OG.super.isSingularImplSuper;
                                (*' isSingularImplSuper=T ' -> puttext; *)
                             else
                                (*' isCategoryImplSuper: ' -> puttext*)
                            if);
                            (*vDcl.sig.doPT -> putline*)
                         else
                            this(Pattern)[] -> SemanticError
                            (#
                            do 'No virtual declaration in super for: "' -> msg;
                               sig.doPT -> msg; '"' -> msg
                            #)
                        if);
                        (if OG.IS.isEmpty then
                            (* We have a non-singular binding, like
                             * fool(#ko), elm::< Person
                             * We allocate a descNo -> vDescNo for a vStub 
                             * that calls the actual pattern;
                             * See also handleVirtArg;
                             * Perhaps we may have a boolean: nonSingularBinding
                             * and then allocate the descNo in generator?
                             * Done: elim vDescNo is now possible
                             *)
                            newDesc -> OG.vDescNo;
                            true -> OG.nonVirtualBinding;
                            (* '*** non-singular binding: ' -> puttext; 
                             * OG.vDescNo -> putint; ' ' -> put; doPT -> putline;
                             *)
                        if);
                        (* else 'No virtual PtnKind:' -> puttext;  
                         * ptnKind -> putint; newline*)
                    if)
                 #);

            do (if traceCheck then  
                   '*** Check ptn: ' -> puttext; sig.id[] -> putline if);
               handleVirtualBinding;
               (* Must check sig before OG;
                * Items in OG may refer Decl's in sig
                * Allocation of storage for sig must be in OG.IS
                * Scope for Decl's in sig must be basicScope
                * BUT! When checking sig, OG.super is not setup, 
                * which gives problems in
                * foo(x: ? bar):
                *    ...
                * bar: 
                *    S: ? foo
                *    S := foo(e) -- super for foo is not setup
                * Thus we check super before checking sig
                *)
               (if not (basicScope[] -> OG.checkSuper) then
                   (* no circularity in super chain is deteched *)
                   (none,OG.IS[],OG.IS[],true) -> sig.check; 
                   (none,basicScope[],basicScope[],true) -> OG.check;
                   (if traceGeneric then
                       OG.IS.scanAllDecls
                       (# D: ^Decl
                       do (if currentDcl.isVirtualObject then
                              (*'Virtual Object: ' -> puttext; 
                               currentDcl.doPt -> putline;*)
                          if)
                   #)if);
                   inner;
               if)
            #);
          isInner::<
            (* Perhaps ad hoc!? -- from old code: inner
             * check BKWptn: %inner P
             *)
            (# A: ^ObjectGenerator; org: ^Items
            do (if OG.primNo = inner_prim then
                   basicScope[] -> org[];
                   args.scanArgs
                   (# A: ^ObjectGenerator
                   do current[] -> A[];
                      A.super.on - 1 
                        -> (args.origin[]->org[]).toOrigin -> org[]; 
                   #);
                   org.noOfInner + 1 -> org.noOfinner;
                   (if org.noOfInner = 1 then 
                       org.dsize + 1 
                         -> org.dsize 
                         -> org.innerInx 
                   if);
               if);
            #);     
          alloc::< 
            (# add:
                 (* We have a ptn: V:< OGv1, V::< OGv2
                  * OGv1 or OGv2 are bindings of V
                  * For OG2, we should perhaps have the initial V:< OG?
                  *)
                 (# enclosingOG: ^ObjectGenerator; ptn: ^pattern; F: ^Node
                 do father.father[] -> F[];
                    (if F##
                     // ObjectGenerator## then
                        (* 'ObjectGenerator: ' -> putline; F.dopt->putline;*)
                        (this(Pattern)[],OG[]) -> (F[]->enclosingOG[]).addBinding
                     // Signature## then
                        (*'Signature: ' -> putline; F.father.doPT -> putline;
                         F.father.label -> putline;*)
                        (this(Pattern)[],OG[]) -> (F.father[]->ptn[]).OG.addBinding
                     else                           
                        'Koks'->putline;
                        father.father.label -> putline
                    if)
                 #);
            do (* '*** Ptn:alloc: ' -> puttext; sig.doPT -> putline;*)
               IT[] -> OG.alloc;
               (if ptnKind 
                // virtualPtn then 
                   (*'Virtual ptn: ' -> putline; sig.doPT -> putline;*)
                   IT.dsize + 1-> IT.dsize -> off;
                   add
                // furtherPtn // finalPtn then
                   (*'Virtual bind: ' -> putline; sig.doPT -> putline;*)
                   (*OG.super.ATd.off -> off;*)
                   vDcl.off -> off;
                   add
               if);
               inner 
            #);
          handleArgs::
            (# args: [6]^ObjectGenerator; top: @integer;
               enclosingOG: ^ObjectGenerator
            do (* 'HandleArgs: ' -> putline; dopt-> putline; 
                * E.doPT -> putline; '--' -> putline; 
                *)
               (if E.args[] = none then leave handleArgs if);
               E.args.scanArgs
               (#
               do (if (top+1 -> top) > args.range then 
                      args.range -> args.extend 
                  if);
                  current[] -> args[top][];
                  (*'ActualArg: ' -> puttext; current.dopt -> putline*)
               #);
               (if top = 0 then leave handleArgs if);

               scanArgs
               (# i: @ integer; Ex: ^Exp; 
                  OI: ^ObjectInvocation; descNo: @integer
               do  i + 1 -> i;
                  handleVirtArg:
                    (if currentArg.isVirtual then
                        args[i].super.last -> Ex[];
                        (if (Ex[] <> none) and (Ex.isObjectInvocation) then
                            (* 'Try: ' -> puttext; Ex.label -> putline; 
                            * Ex.doPP -> putline;  
                            * args[i].doPP -> putline;
                            *)
                            Ex[] -> OI[];
                            (if args[i].IS.isEmpty then
                                (* We have a non-singular binding, 
                                 * see handleVirtualBinding *)
                                (if args[i].IS.descNo <> 0 then
                                    '\nhandleArgs: ' -> puttext; 
                                    args[i].IS.descNo -> putint; newline;
                                    args[i].doPT -> putline
                                if);
                                newDesc -> args[i].vDescNo;
                                true -> args[i].nonVirtualBinding;
                                true -> args[i].isVirtualArg;
                               (* '*** non-singular argument binding: ' -> puttext; 
                                args[i].vDescNo -> putint; ' ' -> put;
                                args[i].doPT -> putline;*)
                            if);
                                
                            (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                (* 'Got ptn id: ' -> puttext; 
                                 * OI.ptnId.doPT -> puttext;
                                 *)
                                (args[i].desc).descNo -> descNo; 
                                (* ' descNo: ' -> puttext; 
                                 descNo -> putint; ' ' ->put;
                                 OI.ATd.primNo -> putint; newline;
                                 *)
                                (* args[i] is a binding of currentArg
                                 * Why dont we use the addBinding call below?
                                 *)
                                (currentArg[],args[i][])
                                  -> (E.father.father[]-> enclosingOG[])
                                .addBinding;
                                leave handleVirtArg
                            if);
                            (if (E.desc).primNo = indexed_prim then 
                                (* We ignore bindings of elm in Indexed *)
                                leave handleVirtArg
                             else
                                (if OI.ATd.(*args[i].*)primNo = integer_prim then
                                    '\n*** Virtual bound to integer in\n\n\t'->puttext;
                                    E.doPT -> putline;
                                    '\n    is ignored by the compiler\n' -> putline;
                                    leave handleVirtArg
                                if);
                            if);
                            (* args[i] is a binding of currentArg *)
                            (currentArg[], args[i][]) 
                              -> (E.father.father[]-> enclosingOG[]).addBinding;
                         else
                            (* Not clear which situation we have here?
                             * 'Not OI: ' -> puttext; 
                            (if ex[]=none then ' :ex=none: '->puttext;
                                args[i].label -> puttext; 
                             else
                                Ex.label -> puttext; 
                            if);
                            newline;
                            args[i].dopt -> puttext;
                            '\n>>> ' ->puttext;
                            E.dopt -> puttext;
                            '\n>>> ' ->puttext;
                             currentArg.dopt -> putline;
                             *)
                            (* So what is the binding?*)
                            (currentArg[], args[i][]) 
                              -> (E.father.father[]-> enclosingOG[]).addBinding;
                        if)
                    if)
               #)
            #);
          desc::<
            (# elm:: items
            do (*(if not isChecked and not beingChecked then 
                   '!!! ' -> puttext; sig.doPT -> putline;
                   '** Not checked: ' -> putline;
                   doPT -> putline;
                   (none,origin[],origin[],true) -> check;
               if);*)
               (if not OG.hasItems (*OD.IS.isEmpty*) then
                   (* V: < A, V::< B, or V:: C *)
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
               inner;
            #);
         
          isRecursive,isRec: @boolean;
          entity:: (#do OG.entity -> E[] #);
          skind:: (# do ': ' -> S[] #);
          getEntries:: (# do OG.getEntries -> (names[],entries[]) #);
          objDescEQ:: 
            (# 
            do (if trace then 'pattern: ' -> puttext; newline if);
               DN -> OG.objDescEQ -> value;
               (if trace then 
                   'pattern:'->putline; value -> putboolean;
                   dopt -> putline
               if)
            #);
       #);
     
     ObjectGenerator::<
       (# setUpOrigin::
            (#
            do origin[] -> super.setUpOrigin;                    
               origin[] -> IS.setUpOrigin;
               this(ObjectGenerator)[] -> IS.OT[];
               sig[] -> IS.sig[];
               super[] -> IS.super[]
            #); 
          checkSuper: booleanValue
            (# checkIfSuperIsCircular: BooleanValue
                 (# D: ^Decl; ptn: ^Pattern
                 enter D[]
                 do followSuper:
                      (if (D[] <> none) and D.isPatternDecl then
                          D[] -> ptn[];
                          (if (ptn.OG[] = this(ObjectGenerator)[]) then
                              true -> value;
                              this(TopNode)[] -> SemanticError
                              (#
                              do 'There is circularity in the super pattern chain : "'
                                   -> msg;
                                 super.doPT -> msg;
                                 '"' -> msg;
                              #);
                           else
                              (if true or (ptn.OG.super[] <> none) then
                                  ptn.OG.super.ATd[] -> D[];
                                  restart followSuper
                      if)if)if)
                 #);
               checkIfSuperIsPattern:
                 (* A unary exp like XXX where XXX is a data-item
                  * is syntactically an ObjectGenerator (Unary)
                  * with XXX as super and empty main-part:
                  * (ObjectGenerator
                  *    (Invocation
                  *       (Unary
                  *          (name:XXX)
                  *          (Arguments)))
                  *    (Items))
                  * We may consider a new syntactic category:
                  * (DataItemRef
                  *    (Invocation
                  *       (Unary
                  *          (name:XXX)
                  *)
                 (#
                 do (if (super.ATd[] <> none) and 
                        (not super.ATd.isPatternDecl and not IS.isEmpty) then
                        this(TopNode)[] -> SemanticError
                        (#
                        do 'Super is not a pattern: "' -> msg;
                           super.doPT -> msg;
                           '"' -> msg;
                        #)                       
                    if)
                 #);
               basicScope: ^Scope
            enter basicScope[]
            do (if super.ATd[] = none then 
                   (* else implict super that has been setUp
                    * Or has been called from Pattern:check
                    *)
                   (if traceCheck then
                       '*** check super:' -> puttext; super.dopt -> putline
                   if);
                   (if sig[] = none (*isSingular*) then
                       (*(if not isSingularX then
                           '\n*** Inconsistency isSingular: ' -> putline;
                           (if IS.isEmpty then '-TT- '->puttext else '--FF-- ' -> puttext if);
                           (if hasVirtualArgs then '-TT- '->puttext else '--FF-- ' -> puttext if);
                           father.doPt -> putline; 
                           doPP -> putline
                       if);*)
                       (* A singular statement:
                        *     bar(a,...) { ... }
                        * isObjectDesc: IS not empty or has virtual arguments
                        * else: just a pattern invocation
                        * Note! isObjectDesc is not defined before super.check 
                        *       has been executed
                        *)
                       (none,basicScope[],basicScope[],true) -> super.check
                    else
                       (* A pattern:
                        *     foo(a: ?int, ...): bar(a, ...){ ... } 
                        * where
                        *     super = bar(a,...) 
                        *)
                       (none,basicScope[],sig[],true) -> super.check
                   if);   
 
                   (if traceCheck then
                       '*** end check super: ' -> putline; dopt -> putline;
                       '   superDesc[] '-> puttext; 
                       (if IS.superDesc[] <> none then
                           IS.superDesc.doPT -> putline;
                        else                           
                           'none' -> putline;
                       if)
                   if);
                   checkIfSuperIsPattern;
                   (if (super.ATd[] -> checkIfSuperIsCircular) then
                       true -> value;
                       leave checkSuper
                   if)
               if);
               (* we do this too often - perhaps a boolean: superIsChecked *)
               (if super.ATd[] <> none then
                   super.ATd.desc -> IS.superDesc[];
                else                           
                   objectDecl.desc -> IS.superDesc[];
                   (if IS.superDesc[] = IS[] then
                       none -> IS.superDesc[]
                   if)
               if);               
            #);                    
          check::
            (#                
            do (if traceCheck then
                   '*** Check ObjectGenerator:' -> puttext; 
                   doPT -> putline 
               if);
               (if basicScope[] -> checkSuper then leave check if);
               (if isObjectDesc then
                   (*this(ObjectGenerator)[] -> newDesc -> IS.descNo*)
               if);
               (* Note that 'isObjectDesc' is a stronger predicate than
                *  'hasItems or super.hasVirtualArgs '
                * and we must check IS if only the latter is true
                *)
               (if hasItems or super.hasVirtualArgs then
                   (none,origin[],origin[],true) -> IS.check 
               if);
            #);
          isSimpleValue: BooleanValue
            (* ObjectGeneration in (the rightside)
             * C: = integer(12)   -- refer to pattern integer
             * C: = 12
             * C: = a + b         -- pattern +
             * C: = foo(e1,e2,e3) -- pattern foo
             * C: = X             -- data-item X
             * V: ? a + b         -- and simialr for variable
             * V:= foo(e1,e2,e3)  -- and assignment
             * And they may be singular
             * 1:   OG - non-singular
             * 1.1  OG - integer, boolean, char ==> true
             * 1.2     - else get possible return value
             * 2:   {...} - singular, no super
             * 2.1        - primno = integer, char, boolean
             * 3:   OG{...} - singular with super
             * 3.1          -- return value of OG
             * 3.2          -- OG not simpleValue?
             *)
            (# q: ^ObjectGenerator; pNo: @integer
            do (* '*** isImpleValue: ' -> puttext; primNo -> putint; newline;
               doPT -> putline;
               '>>> super:qual:'->putline;
               (if (super.getQual -> q[]) = none then 'none' -> putline
                else
                   q.doPT -> putline;
                if);*)
               (if (super.getQual -> q[]) <> none then
                   q.primNo -> pNo
                else
                   primNo -> pNo
               if);
               (if pNo
                // integer_prim
                // char_prim
                // boolean_prim  then
                   true -> value
               if)
            #);
          isObjectDesc: booleanValue
            (* this can be a singular or pattern defined ObjectDesc:
             *    IS.hasItems
             * It can also be an ObjectInvocation with virtual arguments
             *     super.hasVirtualArguments
             * that has to treated as an ObjectDesc
             * And super is not a basic pattern
             *     not super.isBasic
             *)
            (#
            do hasItems or (super.hasVirtualArgs and not super.isBasic)
                 -> value;
            #);   
          isObject: booleanValue(# do primNo = object_prim -> value #);
          alloc::
            (# E:^Exp
            do IT[] -> super.alloc;
               addBinding.copySuper;
               (if ((super.last -> E[]) <> none) and (E.ATd[] <> none) then 
                   E[] -> E.ATd.handleArgs 
               if);
               (if isObjectDesc then
                   IT[] -> IS.alloc 
               if);
               (if traceGeneric2 then
                   addBinding.display
               if);
               addBinding.checkForVirtualObject;
               addBinding.checkSuperVariant
            #);
          hasCode:: (# do true -> value #);
          hasVirtualObject: @boolean;
          vDescNo: @integer;
          nonVirtualBinding,      (* Like fool(#Ko), elm::< Record, etc. *)
          isVirtualArg: @boolean; (* as in foo(...,#bar,...) *)
          Xvariants: @
            (# Var: [2] ^Variant; top: @integer; 
               Variant:
                 (* An object representing different variants of a pattern with
                  * virtual patterns qualified by Object as in
                  *    foo(...,V:< Object, ...):
                  *       W:< Object
                  *       ...
                  * V and W may be bound to simple values such as Integer 
                  * or patterns as in 
                  *    foo(...,#Record,...)
                  *       W::< #Integer
                  *       ...
                  * In this case there may be 4 combinations of Value (V) or Reference (R)
                  *    [R,R], [R,V], [V,R], [V,V]
                  * Different code must be generated for Foo for each variant 
                  *)
                 (# vDecl: [2] ^Pattern; (* virtual decls of the form V:< Object *)
                    type: [2] @ integer; 
                    top: @integer;
                    add:
                      (# VD: ^Pattern;
                         T: @integer
                      enter(VD[],T)
                      do (if (top + 1 -> top ) > vDecl.range then
                             vDecl.range -> vDecl.extend;
                             type.range -> type.extend
                         if);
                         VD[] -> vDecl[top][];
                         T -> type[top]
                      #);
                    print:
                      (#
                      do (for i: top repeat                               
                              (if type[i] 
                               // 1 then '   ref:  '->puttext
                               // 2 then '   value: ' -> puttext
                              if);
                              vDecl[i].dopt -> putline
                         for)
                      #)
                 #);
               new:
                 (#
                 do (if (top + 1 -> top) > var.range then
                        var.range -> var.extend
                    if);
                    &Variant[] -> var[top][];
                 exit var[top][]
                 #);
               checkDoublet:
                 (#
                 do (if top > 1 then
                        (for i: top - 1 repeat
                             L:
                               (if var[i].top = var[top].top then
                                   (for j: var[i].top repeat
                                        (if var[i].type[j] <> var[top].type[j] then
                                            leave L
                                   if)for);
                                   (* equal *)
                                   top - 1 -> top;
                                   leave checkDoublet
                               if)
                    for)if)
                 #);
               print:
                 (#
                 do (if (top > 1) then
                        '**** Has variants: ' -> putline;
                        (if sig[] <> none then
                            sig.dopt -> puttext; ':' -> put; newline
                        if);
                        dopt -> putline;
                        (for i: top repeat
                             '--Variant:' -> putline;
                             var[i].print
                        for)
                    if);
                    
                 #);
            #);
          addBB::
            (# VD: ^Pattern; E: ^ObjectGenerator;
               vDecl: [2] ^Pattern; (* not defined? *)
               bindingType: [2] @integer; (* 0: inner; 1: ref; 2: value *)
               bindings: [2] ^ObjectGenerator;
               vTop: @integer;
               objectRefs: [2] ^Decl; rTop: @integer;
               objectInvs: [2] ^ObjectInvocation; oTop: @integer;
               scanBindings:
                 (# currentVdecl: ^Pattern; 
                    currentBindingType: @integer;
                    currentBinding: ^ObjectGenerator;
                    inx: @integer
                 do (for i: vTop repeat
                         i -> inx;
                         vDecl[i][] -> currentVdecl[];
                         bindingType[i] -> currentBindingType;
                         bindings[i][] -> currentBinding[];
                         inner
                    for)
                 #);
               scanObjectRefs:
                 (# current: ^Decl; 
                 do (for i: rTop repeat
                         objectRefs[i][] -> current[];
                         inner
                    for)
                 #);
               scanObjectInvs:
                 (# current: ^ObjectInvocation
                 do (for i: oTop repeat
                         objectInvs[i][] -> current[];
                         inner
                    for)
                 #);
               copySuper:
                 (# ptn: ^Pattern
                 do (if (superPtn -> ptn[]) <> none then 
                        (* A unary exp like XXX where XXX is a data-item
                         * is syntactically an ObjectGenerator
                         * with XXX as super and empty main-part
                         *);
                        (* 'copySuper:' ->putline; dopt->putline; 
                         *  ptn.OG.addBinding.display; *)
                        (for i: ptn.OG.addBinding.vTop repeat 
                             (*ptn.OG.addBinding.offSets[i] -> putint; ' '-> put;
                              ptn.OG.addBinding.bindingType[i] -> putint; 
                              * newline;
                             (if ptn.OG.addBinding.bindings[i][] <> none then
                                 ptn.OG.addBinding.bindings[i].dopt -> putline;
                              else
                                 'none' -> putline
                             if);*)
                             (if ptn.OG.addBinding.vDecl[i][] <> none then
                                 (ptn.OG.addBinding.vDecl[i][]
                                 ,ptn.OG.addBinding.bindings[i][]) 
                                   -> addBinding
                                 (*else = 0: inner *)
                             if)
                        for);
                        ptn.OG.addBinding.scanObjectRefs(# do current[] -> addObjRef #)
                    if)
                 #);
               addObjRef:
                 (# objRef: ^DataItem
                 enter objRef[]
                 do (if (rTop + 1 -> rTop) > objectRefs.range then
                        objectRefs.range -> objectRefs.extend 
                    if);
                    (* 'AddBinding:addObjRef:in:' -> puttext; IS.descNo -> putint; newline;
                     * objRef.doPT -> putline;
                     *)
                    objRef[] -> objectRefs[rTop][];
                    true -> hasVirtualObject
                 #);
               addObjectInvocation:
                 (# OI: ^ObjectInvocation
                 enter OI[]
                 do (if (oTop + 1 -> oTop) > objectInvs.range then
                        objectInvs.range -> objectInvs.extend 
                    if);
                    (* 'AddBinding:addObjRef:in:' -> puttext; IS.descNo -> putint; newline;
                     * objRef.doPT -> putline;
                     *)
                    OI[] -> objectInvs[oTop][];
                    true -> hasVirtualObject
                 #);
               checkSuperVariant:
                 (# ptn: ^Pattern; OG: ^ObjectGenerator
                 do (if (superPtn -> ptn[]) <> none then
                        ptn.OG[] -> OG[];
                        (# V: ^OG.Xvariants.Variant
                        do OG.addBinding.scanBindings
                           (# head: @boolean; 
                           do (if (currentBinding[] <> none) then
                                  (if (currentBinding.isObject) then
                                      (if not head then
                                          OG.Xvariants.new -> V[];
                                          (if traceGeneric2 then
                                              '*** Variant: ' -> putline;
                                              doPT -> putline;
                                          if);
                                          true -> head
                                      if);
                                      (if traceGeneric2 then
                                          currentBinding.doPT -> putline;
                                          bindings[inx].doPT -> putline;
                                          bindingType[inx] -> type;
                                          newline
                                      if);
                                      (currentVdecl[],bindingType[inx]) -> V.add
                                  if)                            
                               else
                                  (*'currentBinding is none' -> putline;
                                   * dopt -> putline *)
                              if)
                           #);
                           (if V[] <> none then OG.Xvariants.checkDoublet if);
                        #)
                    if)
                 #);
               checkForVirtualObject:
                 (#
                 do L:
                      (for i: vTop repeat
                           (if bindings[i][] <> none then
                               (if bindings[i].primNo = object_prim then
                                   true -> hasVirtualObject;
                                   (if traceGeneric2 then
                                       '***** HasVirtualObject: ' -> putline; 
                                       (if sig[] <> none then 
                                           sig.doPT -> putline;
                                        else
                                           doPT -> putline;
                                           display
                                   if)if);
                                   leave L
                      if)if)for);
                    checkDataItemAsVirtualObject
                 #);
               checkDataItemAsVirtualObject:
                 (# isVirtualObject: 
                      (# D: ^Decl
                      enter D[]
                      do (if IS[] -> D.markIfVirtualDataItem then
                             (if traceGeneric2 then
                                 'Virtual DataItem: ' -> puttext; D.doPT -> putline;
                             if);
                             D[] -> addBinding.addObjRef
                         if)
                      #);

                    isVirtualObjectInvocation:
                      (* Identify statements where a virtualObject is referred
                       * Foo:
                       *    V:< Object
                       *    S1: ?V
                       *    Bar:
                       *      W:< Object
                       *      R1,R2: ?W
                       *      S2: ?V
                       *      S1 := S2  -- S1 nd S2 are virtual Object
                       *      R1 := R2  -- R1 and R2 ditto
                       *      R.Q       -- R cannot be Object, Q may be
                       *      R.fisk(S) -- R and fisk cannot be Object, S may
                       *      ...
                       *)
                      (# checkIfVirtualObject: 
                           (# OI: ^ObjectInvocation
                           enter OI[]
                           do (*'\n++++ Try: ' -> puttext; OI.dopt -> putline;
                               OI.atd.dopt -> putline;*)
                              (if OI.ATd.hasVirtualObjectQual then
                                  OI[] -> addBinding.addObjectInvocation;
                              if);
                              OI.args.scanArgs
                              (#
                              do current[] -> isVirtualObjectInvocation
                              #)
                           #);                         
                         OG: ^ObjectGenerator; OI: ^Invocation
                      enter OG[]
                      do (if not OG.isObjectDesc then
                             (*(if (OG.super[] -> OI[]) <> none then*)
                                 (*'\n*** isVirtualObjectInvocation: ' 
                                  -> puttext;*)
                                 OG.super.scanSons (*OI.scanSons*)
                                 (# 
                                 do (if current.isObjectInvocation then 
                                        current[] -> checkIfVirtualObject
                                    if)
                                 #);
                                 (*newline*)
                             (*if);*)
                         if);
                      #);
                 do (if sig[] <> none then
                        sig.scanArgs(# do currentArg[] -> isVirtualObject #)
                    if);
                    IS.scanSons
                    (# I: ^Item
                    do current[] -> I[];
                       (if true 
                        // I.isDecl then
                           I[] -> isVirtualObject 
                        // I.isObjectGenerator then
                           I[] -> isVirtualObjectInvocation
                    if)#)
                 #);
               valueOrObject::
                 (#
                 do '***** ObjectGenerator:ValueOrObject:'->putline;
                    dopt -> putline;
                    display;
                    (for i: vTop repeat
                         (if vDecl[i][] = ptn[] then
                             'bound to: ' -> puttext;
                             bindingType[i] -> type; newline;
                             bindings[i].dopt -> putline;
                             bindingType[i] -> value
                         if)
                    for);
                    (for i: rTop repeat
                         'Decl: ' -> puttext;
                         objectRefs[i].dopt -> putline
                    for)
                 #);
               type:
                 (# T: @integer
                 enter T
                 do  (if T
                      // 0 then ' inner: ' -> puttext;
                      // 1 then ' ref: ' -> putline
                      // 2 then ' value: ' -> putline;
                      else 
                         '  ???' -> putline
                     if);
                 #);
               display:
                 (# T: ^Text
                 enter T[]
                 do (if vTop > 0 then
                        T[] -> puttext; 
                        '*** Bindings: descNo: ' -> puttext; 
                        IS.descNo -> putint; newline;
                        (for i: vTop repeat
                             i -> putint; ':' -> put;
                             vDecl[i].doPT -> putline;
                             vDecl[i].off -> putint; ':'->put;
                             bindingType[i] -> type;
                             (if bindings[i][] <> none then
                                 bindings[i].doPT -> putline
                              else 
                                 'none'->putline
                             if)
                    for)if)
                 #)      
            enter(VD[],E[])
            do (if handleGeneric then
                   (if VD.off > vTop then
                       VD.off - bindings.range + 2-> bindings.extend;
                       VD.off - bindingType.range + 2-> bindingType.extend;
                       VD.off - vDecl.range + 2 -> vDecl.extend;
                   if);
                   (if VD.off > vTop then VD.off -> vTop if);
                   VD[] -> vDecl[VD.off][];
                   (*'Add:' -> puttext; E.doPT -> puttext; 
                    ' ' -> put; off -> putint;
                    ' ' -> put; E.primNo -> putint; newline;
                    *)
                   (*(if false and (BindingType[off] > 0) then
                       '---addbinding:overwrite: ' -> puttext;
                       off -> putint; ' ' -> put; E.doPt -> putline;
                       '   was: ' -> puttext;
                       bindingType[off] -> putint; ' ' -> put;
                       bindings[off].dopt -> putline;
                       
                   if);*)
                   (if E.primNo // integer_prim then 
                       (* '--value--'->putline;*)
                       2 -> bindingType[VD.off]
                    else 
                       1 -> bindingType[VD.off]
                   if);
                   E[] -> bindings[VD.off][];
               if);
            #);
          getNameForOff::
            (#do (attOff,descNo,isRef,isIndexed) -> IS.getNameForOff -> NM[] #);
          getDescNo:: 
            (# ptn: ^Pattern
            do  (if (IS.QdescNo[1] -> dNo) = 0 then
                    (* Virtual bindings like DD in V ::< DD *)
                    (if (superPtn -> ptn[]) <> none then
                        ptn.OG.getDescNo -> dNo
                if)if)
            #);
          objDescEq:: 
            (# 
            do (if trace then 'OG: ' -> puttext; newline if);
               DN -> IS.objDescEq -> value;
               (if trace then
                   'OG:' -> puttext; value -> putBoolean;
                   doPT -> putline
               if)
            #);
          clear::<
            (#
            do 0 -> vDescNo -> xVariants.top;
               inner
            #)
       #);
     Invocation::<
       (# setupOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (if traceCheck then
                   '*** Invocation:check: ' -> puttext; doPT -> putline 
               if);
              
               scanSons
               (# E: ^Exp; i: @integer
               do i + 1 -> i; 
                  (rec[],basicScope[],argScope[],isFirst) 
                    -> current.check -> basicScope[];
                  false -> isFirst;
                  current[] -> rec[];
                  (if isLast then
                      (* can be Exp with args or just a pattern name (#foo) *)
                      current[] -> E[]; (* use rec *)
                      E.ATd[] -> ATd[];
                      E.on -> on;
                      i -> lgth;
                   else
                      (* current must be Exp incl. possible argument *)
                      (* see comment on Remote Expressions on Confluence t*)
                  if)
               #)
            #);
          incrOn:
            (#
            do '***** incrOn: ' -> putline; doPT -> putline;
               scanSubTree
               (# doIt::
                    (# AP: ^Apl
                    do (if current## <= Apl## then
                           current.doPT -> putline;
                           current[] -> AP[];
                           AP.on + 1 -> AP.on;
                           AP.doPT -> putline;
                       if);
               #)#)
            #);
          alloc:: (# do scanSons(# do IT[] -> current.alloc #)#);
       #);
     ObjectInvocation::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> ptnId.setUpOrigin; 
               origin[] -> args.setUpOrigin
            #);
          check::
            (# elm:: scope; org: ^Items; OGq: ^ObjectGenerator; done: @boolean;
               ptn: ^Pattern
            do (if traceCheck then
                   '*** ObjectInvocation:check: ' -> puttext; ptnId.T[] -> puttext;
                   ' '-> put; dopt->puttext; ' ' -> put
               if);
               (* ' :scope: ' -> puttext; basicScope.doPT ->putline;*)
               (if basicScope[] <> none then (* ad hoc *)
                   (if (1 -> ptnId.T.inxGet) = '#' then
                       ((2,ptnId.T.length) -> ptnId.T.sub,isFirst) 
                         -> basicScope.search -> (ATd[],on,pn);
                    else
                       (ptnId.T[],isFirst) -> basicScope.search -> (ATd[],on,pn);
                   if);
                   (if ATd[] <> none then 
                       on -> ptnId.on; (* just for debugging *)
                       (ptnId.T[],on,ATd[]) -> found;
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find a declaration of: "'-> msg;
                          ptnId.T[] -> msg;
                          '"' -> msg;
                       #);
                       errorDecl[] -> ATd[]
                   if);
                   this(Exp)[] -> ATd.checkVirtualArgs;
                   
                   (if ATd.primNo 
                    // this_prim then
                       (* ad hoc - must be fixed *)
                       (# A: ^Item
                       do args.scanArgs(# do current[] -> A[] #);
                          (none,argScope[],argScope[],true) -> A.check;
                          A.desc -> basicScope[];
                       #);
                       leave check  
                    // indexedGet_prim then
                       father.scanSons
                       (# pred: ^node; OI: ^ObjectInvocation; DI: ^DataItem; E: ^Exp; 
                          OG: ^ObjectGenerator; ptn: ^Pattern; 
                       do (if current[] = this(ObjectInvocation)[] then
                              (if pred[] <> none then 
                                  (* 'Got indexGet:pred: ' -> puttext;
                                   pred.dopt -> puttext;
                                   ' this: ' -> puttext; dopt -> puttext; 
                                   *)
                                  pred[] -> OI[];
                                  (*' decl: ' -> puttext;*)
                                  OI.ATd[] -> DI[];
                                  DI.OG.super.last -> E[];
                                  (if E.args[] <> none then
                                      E.args.scanArgs(#do current[] -> OG[] #);
                                      (if OG[] <> none then 
                                          OG.super.last-> OI[];
                                          (* (OG.super.last-> OI[]).dopt -> putline; *)
                                          (OI.ATd[] -> ptn[]).OG.IS[] -> basicScope[];
                                          (*basicScope.dopt -> putline;*)
                                          true -> done
                              if)if)if)
                          if);
                          (args[],argScope[]) -> argBuf.add;
                          current[] -> pred[];
                       #);
                       (if done then leave check if)
                   if);
                   (args[],argScope[]) -> argBuf.add;
                   
                   (* ok if static/dynamicObject - what does this mean?
                    * If pattern, scope is the desc of the return value
                    * ATd.desc <> none is before we used getQual 
                    * - can be eliminated
                    *)
                   (if ATd[] = thisCoreDecl[] then 
                       (* perhaps move to getQual!?*)
                       coreDecl.desc -> basicScope[]
                    else
                       (if traceGetV_qual then
                           '*** ObjectInvocation:using getV_qual: '->puttext;
                           doPT -> putline;
                           'Father.father.father.father: ' -> puttext; 
                           father.father.father.father.dopt -> putline;
                       if);
                       (if false then
                           (if (basicScope.theObjectGenerator -> getV_qual)
                               = none then
                               ' (basicScope.father[] -> getV_qual is none' 
                                 -> putline;
                               dopt -> putline;
                               father.father.father.father.dopt -> putline
                       if)if);
                       (if traceGetV_qual then
                           '*** basicScope: ' -> putline;
                           basicScope.dopt -> putline;
                           '*** basicScope.theObjectGenerator: '
                             -> putline;
                           (basicScope.theObjectGenerator).dopt
                             -> putline
                       if);
                       (basicScope.theObjectGenerator -> getV_qual).IS[]
                         -> basicScope[]
                   if)
                else
                   'Variable:check: scope is none: '->puttext; dopt -> putline
               if)
            #);
          alloc:: 
            (#
            do (if ATd[] = none then 
                   'ATd is none: '->puttext; label -> puttext; ' ' -> put;
                   father.label -> puttext; ' ' -> put;
                   father.father.label -> puttext; ' ' -> put;
                   ' Father.father: ' -> putline;
                   father.father.doPT-> putline; 
               if);               
               (IT[],args[]) -> ATd.isInner ;
               scanSons(#do IT[] -> current.alloc #);
               (*'handleArgs'->puttext; dopt->putline;*)
               (* this(Exp)[] -> ATd.handleArgs *)
            #);
          hasVirtualObjectQual: @boolean;
       #);
     BracketedExp::<
       (# setUpOrigin:: (# do origin[] -> IV.setUpOrigin #);
          check:: 
            (# 
            do (rec[],basicScope[],argScope[],isFirst) -> IV.check -> basicScope[];
               IV.ATd[] -> ATd[];
               IV.on -> on
            #);
          alloc:: (# do IT[] -> IV.alloc #)
       #);
     const::<
       (# check:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     charObj::<
       (# check:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     stringObj::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check:: 
            (# 
            do 
               scanSons
               (# B: ^Scope
               do 
                  (rec[],basicScope[],argScope[],true) 
                    -> current.check -> B[];
               #);
               stringDecl[] -> ATd[]; ATd.desc -> basicScope[];
            #)
       #);
     found:
       (# id: ^text; on: @integer; ATd: ^Decl
       enter(id[],on,ATd[])
       do (if traceSearch then
              '***** Found: ' -> puttext; id[] -> puttext; 
              ' on: ' -> puttext; on -> putint;
              (if ATd[] <> none then
                  ' Decl: ' -> puttext; ATd.sig.doPT -> putline
               else 
                  newline
          if)if)
       #);
     argBuf:  @
       (# argElm:
            (# #);
          add:
            (# A: ^Arguments; S: ^Scope; next: ^add
            enter(A[],S[])
            do (if head[] = none then
                   this(add)[] -> head[] -> last[]
                else
                   this(add)[] -> last.next[] -> last[]
               if)
            #);
          head,last: ^add;
          check:
            (# H: ^Add;
            do head[] -> H[];
               none -> head[] -> last[];
               Loop: 
                 (if H[] <> none then
                     (none,H.S[],H.S[],true)  -> H.A.check;
                     H.next[] -> H[];
                     restart Loop
                 if);
               (if head[] <> none then restart check if)
            #)          
          
       #);
     

     
     newDesc: @
       (# OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;
          getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectGenerator
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     notification: 
       (#  msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          n: ^TopNode;
          thisModule: ^module;          
          printHeading:< (# do '\n' -> puttext;inner #);
          printLines:
            (# first,last,p: @integer; ch: @char; Lines: ^Text;
            do true -> (n.theModule).doPT -> Lines[];
               n.beginPos -> p;
               L:
                 (if (first < 4) and (p > 1) then
                     p - 1 -> p;
                     (if  (p -> Lines.inxGet) = ascii.newline then 
                         first + 1 -> first if);
                     restart L
                 if);
               L:
                 (if (0 < p) and ((p <= n.endpos) or (ch <> ascii.newline))
                     and (p <=Lines.length) then
                     Lines.T[p] -> ch -> put;
                     p + 1 -> p;
                     restart L
                 if);
               newline;
            #);         
          report:< BooleanValue(#do inner #);
       enter n[] 
       do (*n.theModule -> errorModule[];*)
          (if report then
              (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
              (if not withPos then 
                  printHeading;
                  ' in module: "' -> puttext; 
                  (if n.theModule <> none then                  
                      (n.theModule->thisModule[]).DI.sig.doPT -> puttext; 
                      '"' -> put; newline;
                      printLines;;
                      (*n.father.doPT -> putline*)
                   else
                      'n.theModule = none"'->putline
                  if);
                  '**** ' -> puttext;
                  &text[] -> lex.errorStream[]
              if);
          
              (if withPos then
                  n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                    -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;
                  n.endPos -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;   
              if);
              INNER;              
              lex.errorStream.newline;
              (if not withPos then
                  lex.errorStream[] -> putline
              if);
          if)
       #);
     SemanticError: Notification
       (# report:: (# do reportSemErr -> value #);
          printHeading::
            (#
            do 'Semantic error' -> puttext;
            #);
       do INNER;
          true -> semanticErrors
       #);
     QuaCheck: Notification
       (# report:: (# do reportQuaCheck -> value #);
          printHeading:: 
            (# 
            do 'Run-time check needed' -> puttext
            #)
       do (if reportQuaCheck then inner if)
       #);
     Warning: Notification
       (# report:: (# do true -> value #);
          printHeading::(#do 'WARNING' -> puttext #);
       do inner
       #);
     semanticErrors: @boolean;
  do '**** CHECKER ****' -> putline;
     0 -> newDesc.noOfDescs; (* needed when exe from minienv
                              * we must find a way to compile changed modules
                              * currently we compile all modules
                              *)
     false -> semanticErrors;
     none -> error_stream[];
     (*true -> traceCheck;*)
     (*true -> traceSearch;*)
     
     (if rootModule.origin[] <> none then
         'B:rootModule.origin:not none ' -> putline;
         rootModule.doPT -> putline;
     if);
     rootModule.setUpOrigin;
     
     rootModule.check;
     (none,main.origin[],main.origin[],true) -> main.check;
     argBuf.check;

     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline;
         lex.errorStream[] -> error_stream[]
      else
         (*main.doPP -> putline;*)
         '**** ALLOC     ****'->putline;
         rootModule.alloc;
         (*main.doPT -> putline;*)         
         inner
     if);
  #)
