ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qparser';
INCLUDE 'qprimitives';
---lib:attributes---
(* origin is always in instance of Items or none - for the outermost Module 
 * basicScope = origin for Items
 * argScope = basicScope in most cases
 * except for a pattern: Signature: ObjectGenerator:super, where
 *  (none,basicScope[],sig[],true) -> super.check;
 * argScope is mainly passed as argument to check
 * but saved in argBuf.add and then used in argBuf.check
 * Checking is recursive whenever neeeded, see abstractsyntaxtree::check
 *)
fixSuperOn: (# exit false #);
checker: Parser
  (# traceCheck,traceSearch: @ boolean;
     Module::<
       (# setUpOrigin:: (# do origin[] -> DI.setUpOrigin #);
          check::
            (#
            do (if verbose then
                   '**** Module: ' -> puttext; DI.sig.doPT -> putline
               if);
               (none,basicScope[],basicScope[],true) -> DI.check;
            #);
          alloc:: (# do IT[] -> DI.alloc #);
          desc:: (#do DI.desc -> D[] #);
       #);
     ModuleItem::<
       (# setUpOrigin:: (# do origin[] -> MD.setUpOrigin #);
          check:: 
            (# 
            do(* 'Check ModuleItem: ' -> puttext; sig.doPT -> putline;*)
               (none,basicScope[],basicScope[],true) -> MD.check 
            #);
          alloc:: (# do IT[] -> MD.alloc #);
          desc:: (# do MD.desc -> D[] #)
       #);
     Items::<
       (# PT::
            (#
            do (if false then
                   '(' -> lx.put;
                   originOff -> lx.putint; ',' -> lx.put;
                   vsize -> lx.putint; ',' -> lx.put;
                   rsize -> lx.putint; ',' -> lx.put;
                   dsize -> lx.putint; ',' -> lx.put;
                   noOfInner -> lx.putint; ',' -> lx.put;
                   innerInx -> lx.putint;
                   ')' -> lx.put;
                   (pos,break) -> mkbreak
               if);
            #);
          setUpOrigin::
            (# 
            do false -> isChecked -> beingChecked (*-> isVinxd -> isRinxd*) -> done ;
               0 -> descNo -> vsize -> rsize -> originOff -> noOfInner -> dsize -> innerInx;
               scanSons(# do this(Items)[] -> current.setupOrigin #);
               (if props[] <> none then
                   this(Items)[] -> props.setUpOrigin
               if);
            #);
          checkItems:
            (# basicScope: ^Items; hasVirtualArgs: @boolean
            enter(basicScope[],superApl[],hasVirtualArgs)
            do (if not isEmpty or hasVirtualArgs then
                   (none,basicScope[],basicScope[],true) -> check 
               if)
            #);
          check::
            (# checkDoubleDecls:
                 (#
                 do (*'\ncheckDoubleDecls: ' -> puttext;*)
                    scanDecls
                    (# thisDcl: ^Decl
                    do currentDcl[] -> thisDcl[]; 
                       (* thisDcl.sig.id[] -> puttext; '>' -> put;*)
                       L:
                         scanAllDecls
                         (#
                         do (*currentDcl.sig.id[] -> puttext; ' ' -> put;*)
                            (if currentDcl[] = thisDcl[] then leave L if);
                            (if currentDcl.sig.id[] -> thisDcl.sig.id.equalNCS then
                                (* We must check that currentDcl is actually 
                                 * a binding of thisDcl; perhpas 
                                 * currentDcl.off = thisDcl.off is ok?
                                 *)
                                (if not (thisDcl.isVirtual and currentDcl.isVirtual) then
                                    thisDcl[] -> SemanticError
                                    (#
                                    do 'Double declaration of: "' -> msg;
                                       thisDcl.sig.id[] -> msg; '"' -> msg
                            #)if)if);
                         #);
                       (*newline;*)
                    #)
                 #);
            do (if traceCheck then '*** Check Items: \n' -> puttext; doPT->putline if);;
               this(items)[] -> basicScope[];
               (if superApl[] = none then
                   'superApl is none' -> putline;
                   'CheckItems:\n' -> puttext; doPT->putline
               if);
               (if superApl.ATd[] <> none then
                   (* Has super <
                    * We must ensure that Super has been checked
                    * or is being checked!
                    *)
                   (*'Items:check:hasSuper:on:' -> puttext;
                    superApl.on -> putint; ' sig: ' -> puttext;
                    superApl.ATd.sig.doPT -> putline;*)
                   (* (superApl.ATd.desc).doPT -> putline*)
                   (* (if (superApl.ATd.desc).isEmpty then
                       'Super:empty: ' -> puttext;
                       superApl.ATd.dopt -> putline
                   if);*)
                   superApl.ATd.desc -> superDesc[];
                   (*(if superDesc[] = none then 'superDesc_none'->putline
                    else
                       superApl.dop->putline
                   if)*)
                else
                   objectDecl.desc -> superDesc[];
                   (if superDesc[] = this(items)[] then
                       none -> superDesc[]
                   if)
               if);
               scanSons
               (# I: ^Item;
               do (none,basicScope[],basicScope[],true) -> current.check;
                  current[] -> I[];
                  (if I.hasCode then true -> doHasCode if)
               #);
               checkDoubleDecls;
            #);
          alloc::
            (#
            do (if superApl.ATd[] <> none then
                   superDesc.vsize -> vsize;
                   superDesc.rsize -> rsize;
                   superDesc.dsize -> dsize;
                   (if superApl.isThisBlockLevel and 
                       (not superApl.isImplSuper) and (not superApl.isSingularImplSuper)
                       then
                       superDesc.originOff -> originOff
                    else
                       rsize + 1 -> rsize -> originOff
                   if)
                else
                   rsize + 1 -> rsize -> originOff
               if);
               (if sig[] <> none then
                   this(items)[] -> sig.alloc
               if);
               scanSons(# do this(items)[] -> current.alloc #)
            #);
          topSuper:
            (# topDesc: ^Items
            do (if superDesc[] <> none then
                   superDesc.topSuper -> topDesc[]
                else
                   this(Items)[] -> topDesc[]
               if)
            exit topDesc[]
            #);
          localSearch::
            (#
            do (if traceSearch then
                   '>>>Items:localSearch: ' -> puttext; CS[] -> putline;
                   'in:' -> putline; doP -> putline
               if);
               search:
                 (#
                 do scanSons
                    (# I: ^Item; AT: ^Decl; MI: ^ModuleItem
                    do (*'LocalSearch: ' -> puttext;  CS[] -> putline;*)
                       current[] -> I[]; 
                       (if I.isDecl then
                           I[] -> AT[]; 
                           (*'Try: ' -> puttext; AT.sig.id[] -> putline;*)
                           (if (CS[] -> AT.sig.id.equalNCS) then
                               (* 'Found in: ' -> puttext; doPT -> putline;*)
                               AT[] -> ATd[];
                               (if ATd## = ModuleItem## then
                                   (* A hack 
                                    * And worse: this does not work as long as
                                    * we check all modules. An non included
                                    * module may use another non included module,
                                    * which implies that this modules will be
                                    * marked as used!
                                    *)
                                   (*'!!!! Found ModuleItem (hack): ' -> puttext;
                                   ATd.sig.doPT -> putline;*)
                                   ATd[] -> MI[];
                                   true -> MI.MD.isAdded -> MI.MD.isIncluded
                               if);
                               Leave search
                    if)if)#);
                    (if trySig and (sig[] <> none) then
                        (CS[],false) -> sig.localSearch -> (ATd[],pn); (* pn = 0 *)
                        (* (if ATd[] <> none then                            
                         * 'Found in signature: ' -> puttext; CS[] -> puttext;
                         * ' decl: ' -> puttext; ATd.doPT -> putline*)
                    if);
                    (if (ATd[] = none) and (superDesc[] <> none) then
                        (CS[],true) -> superDesc.localSearch -> (ATd[],pn);
                        pn + 1 -> pn
                    if)
                 #)
            #); 
          
          search::
            (# org: ^Items; F: ^Node
            do (if traceSearch then
                   '>>>Items:Search:'->puttext; CS[] -> putline;
                   'in: ' -> putline; doP -> putline
               if);
               (CS[],true) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (if incl[] = none then 
                       (*'!!!!!Items:search:incl=none-search for: '->puttext;
                       CS[] -> putline*)
                    else
                       CS[] -> incl.searchInclude -> ATd[];
                   if);
                   (if (ATd[] = none) and isFirst then
                       (if (origin[] -> org[]) <> none then
                           (CS[],isFirst) -> org.search -> (ATd[],on,pn);
                           (if not org.isChecked then
                               (if traceCheck then
                                   '*** Origin not checked: ' -> puttext; doPT -> putline;
                                   '    Search: ' -> puttext; org.father.label -> putline;
                               if);
                               (none,org[],org[],true) -> (org.father[]->F[]).check
                           if);
                           (if basicNo = ifthen_prim then
                               (* '!!! Origin:search:%if%then: Adjust ON: ' 
                                * -> puttext; 
                                * doP -> putline *)
                            else
                               on + 1 -> on ;
                               (if traceSearch then
                                   '>>> on + 1 = ' -> puttext; on -> putint;
                                   (if ATd[] <> none then 
                                       ' found!' -> putline
                                    else
                                       ' not found' -> putline
                                   if);
                                   doP -> putline
                               if)
                           if)
               if)if)if)
            #);
          basicNo: integerValue
            (* should be used in primNo *)
            (#
            do (*'Props: ' -> puttext; father.doP -> putline;*)
               (if (props[] <> none) and 
                   (props.basicProp[] <> none) then
                   (if (props.basicProp.primNo -> value) = 0 then
                       (if superDesc[] <> none then
                           superDesc.basicNo -> value;
                            (*value -> putint; newline*)
                        (*else 'no super'->putline*)
                       if)
                    (*else         
                       value -> putint; newline*)
                   if)
                else (*'none: '->puttext;*)
                   (if superDesc[] <> none then
                       superDesc.basicNo -> value;
                       (*value -> putint; newline
                    else 'no super'->putline*)
                   if)
               if)
            #); 
          toOrigin:
             (# on: @integer; org: ^Items
             enter on
             do (if on > 0 then
                    (if basicNo = ifthen_prim then
                        on  -> (origin[]->org[]).toOrigin -> org[]
                     else
                        on - 1 -> (origin[]->org[]).toOrigin -> org[]
                    if)
                 else
                    this(Items)[] -> org[];
                if);
                (if org.basicNo = ifThen_prim then
                    org.origin[] -> org[]
                if)
             exit org[]
             #); 
          getNameForOff::
            (#
            do '???' -> NM[];
               (*'\ngetNameForOff: ' -> puttext; attOff -> putInt; ' ' -> put;*)
               (if attOff = originOff then
                   'origin' -> NM[];
                   leave getNameForOff
               if);
               L:
                 scanSons
                 (# I: ^Item; D: ^Decl
                 do current[] -> I[];
                    (if I.isDecl then
                        I[] -> D[];
                        I[] -> D[];
                        (if D.off = attOff then
                            D.sig.id[] -> NM[];
                            leave L
                        if)
                    if)
                 #)
            #);          
          getDescNo:: (# do descNo -> dNo #);
          objDescEq:: (# do  DN = descNo -> value #);
          superApl: ^Apl;
          (*superDesc: ^Items; in AbstactSyntaxTree *)
          vsize,rsize,dsize,originOff,noOfInner,innerInx: @integer;
          done: @boolean (* codegen done*)
       #);
     Properties::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check:: (# #);
       #);
     Property::<
       (# setupOrigin::
            (# 
            do origin[] -> P.setupOrigin;
               (if arg[] <> none then origin[] -> arg.setupOrigin if)
            #);
       #);
     Include::<
       (# setUpOrigin:: (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (if son[] <> none then
                   (if traceCheck then 
                       '*** Check include:' -> puttext; doPT -> putline if);
                   basicScope.origin[] -> basicScope[];
                   scanSons
                   (#do (none,basicScope[],basicScope[],true) -> current.check#);
                   (* Force check of included modules *)
                   scanSons
                   (# IV: ^Invocation; MI: ^ModuleItem
                   do current[] -> IV[];
                      (if IV.ATd[] <> none then
                          IV.ATd[] -> MI[];
                          MI.MD.check;
                   if)#)
               if)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
          searchInclude:
            (# CS: ^Text; ATd: ^Decl
            enter CS[]
            do (none,origin[],origin,true) -> check;
               search:
                 scanSons
                 (# IV: ^Invocation; MI: ^ModuleItem; pn: @integer
                 do (if traceSearch then
                        '*** Include:search: ' -> puttext; 
                        current.doPT -> putline;
                    if);
                    current[] -> IV[];
                    (if IV.ATd[] = none then 'searchInclude:IV.ATd=none'->putline if);
                    (if IV.ATd.desc = none then 'IV.ATd.desc=none'->putline if);
                    (CS[],false) -> (IV.ATd.desc).localSearch -> (ATd[],pn);
                    (if ATd[] <> none then
                        (*'Found: ' -> puttext; CS[] -> puttext;
                         ' in %include: ' -> puttext; IV.doPT -> putline;*)
                        IV.ATd[] -> MI[]; 
                        (if not MI.MD.isAdded then
                            MI[] -> (encModule).MD.imports.add;
                            true -> MI.MD.isAdded
                        if);
                        leave search
                    if)
                 #)
            exit ATd[]
            #)
       #);
     Signature::<
       (# setUpOrigin::
            (#
            do scanSons(#do origin[] -> current.setupOrigin #);
               (if args[] <> none then
                   args.scanSons(#do origin[] -> current.setUpOrigin #)
               if)
            #);
          check::
            (# 
            do (if traceCheck then
                   '*** Check signature: ' -> puttext; doPT -> putline
               if);
               (if true then 
                   (if type[] <> none then
                       (none,basicScope[],basicScope[],true) -> type.check;
                   if);
                   (if args[] <> none then
                       (none,basicScope[],basicScope[],true) -> args.check
                   if);
                   (if val[] <> none then
                       (none,basicScope[],basicScope[],true) -> val.check
                   if);
                else
                   scanSons
                   (#
                   do (none,basicScope[],basicScope[],true) -> current.check
                   #);
                   (if args[] <> none then
                       (none,basicScope[],basicScope[],true) -> args.check
                   if)
               if);
            #); 
          alloc:: 
            (# 
            do (if true then 
                   (if type[] <> none then
                       IT[] -> type.alloc;
                   if);
                   (if args[] <> none then
                       IT[] -> args.alloc
                   if);
                   (if val[] <> none then
                       IT[] -> val.alloc
                   if)
                else
                   scanSons(#do IT[] -> current.alloc #)
               if)
            #);
          search::
            (# org: ^Scope
            do (if traceSearch then
                   '>>>Signature:search: ' -> puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               (CS[],false) -> localSearch -> (ATd[],pn);
               (if ATd[] = none then
                   (CS[],isFirst) -> (origin[]->org[]).search -> (ATd[],on,pn);
                   on + 1 -> on; (* check this *)
                else
                   (if traceSearch then '*** Found in signature' -> putline if)
               if)
            #);
          LocalSearch::
            (# 
            do (if traceSearch then
                   '>>>Signature:LocalSearch: '->puttext; CS[] -> putline;
                   'in:'->putline; doP -> putline
               if);
               Loop:
                 (if args[] <> none then 
                     args.scanArgs
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if);
               Loop:
                 (if val[] <> none then
                     (*'Val: ' -> putline;
                     val.doPP -> putline;*)
                     val.scanSons
                     (# D: ^Decl
                     do current[] -> D[];
                        (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                     #)
                 if)
            #); 
       #);
    Arguments::<
       (# setUpOrigin:: 
            (# 
            do scanSons
               (# OG: ^ObjectGenerator
               do (if current## = ObjectGenerator## then
                      (* Foo: 
                       *    ...
                       *    %do body:< Object %with% CCC: ?char: -pattern
                       *        ...
                       *    ...
                       *    %do                 -- ObjectInvocation
                       *       S1
                       *       S2 
                       *    %with% exp
                       *       ... may be empty
                       *)
                      current[] -> OG[];
                      (* OG = Object{ S1; S2} *)
                      (if OG.isObjectDesc(*hasItems*) (*not OG.IS.isEmpty*) then 
                          (* probably OG.isObjectDesc *)
                          (*  '>>>Arg: virtual:'->putline; OG.doP -> putline;*)
                          
                          OG.father.father.father.father -> OG[];

                          (*origin[] -> current.setUpOrigin;*)
                          OG.IS[] -> current.setUpOrigin
                       else (* exp above comes here *)
                          origin[] -> current.setUpOrigin
                      if)
                   else
                      origin[] -> current.setUpOrigin 
                  if)
               #)
            #);
          check:: 
            (# (* Why not argScope below? *)
            do scanArgs
               (# OG: ^ObjectGenerator
               do (*current.label -> putline;*)
                  (if current## = ObjectGenerator## then (* a virtual binding *)
                      current[] -> OG[];
                      (if OG.isObjectDesc then
                         (* '***** Virtual: ' -> putline;
                          current.doPT -> putline;
                          'Fathers: ' -> puttext;
                          current.father.label -> puttext; ' ' -> put;
                          current.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.label -> puttext; ' ' -> put;
                          current.father.father.father.father.label -> puttext; 
                          newline;
                          '*** Origin: ' -> putline;
                          (if current.origin[] <> none then
                              current.origin.doPT -> putline;
                              '*** origin.origin: ' -> putline;
                              current.origin.origin.doPT -> putline;
                              '*** origin: ' -> putline;
                              origin.doPt -> putline
                           else
                              ' none' -> putline
                          if)*)
                      if)
                   (* else a Decl? *)
                  if);
                  (none,basicScope[],basicScope[],true) -> current.check;
               #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);
     Value::<
       (# setUpOrigin::(# do scanSons(# do origin[] -> current.setupOrigin #)#);
          check::
            (#
            do scanSons(#do (none,basicScope[],basicScope[],true) -> current.check #)
            #);
          alloc:: (# do scanSons(#do IT[] -> current.alloc #)#);
       #);          
     DataItem::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin; 
               origin[] -> OG.setUpOrigin; 
            #);
          check::
            (# elm::Items
            do (if traceCheck then '*** DataItem:check: ' -> puttext; doPT -> putline if);
               (none,basicScope[],argScope[],true) -> sig.check;
               (none,basicScope[],argScope[],true) -> OG.check; 
            #);
          alloc::
            (#
            do (if IT[] <> none then (* IT is none if top module *)
                   (if OG.isSimpleValue (*OG.isBasic*) then
                       IT.vsize + 1 -> IT.vsize -> off
                    else
                       IT.rsize + 1 -> IT.rsize -> off
               if)if);
               IT[] -> sig.alloc;
               IT[] -> OG.alloc
            #);          
          desc::
            (# elm:: scope
            do (if not OG.hasItems (*OG.IS.isEmpty*) then 
                   OG.super.desc -> D[]
                else
                   OG.IS[] -> D[]
               if);
            #);
          isSimpleValue: booleanValue(# do OG.isSimpleValue -> value #);
          hasCode:: 
            (* perhaps not suffcient!
             *   S: @T -- hasCode if T hasCode
             *   S: @T{ ... } -- hasCode if T hasCode or main.hasCode
             *   I: @integer --- no code
             *)
            (# 
            do (*OG.hasCode -> value *)
            #);
       #);
     Pattern::<
       (# setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin;
               sig[] -> OD.sig[];
               origin[] -> OD.setupOrigin;
            #);
          isPatternDecl:: TrueValue;
          isVirtual:: (#do ptnKind <> PlainPtn -> value #);
               
          check::< 
            (# elm:: Items;
               setImplSuper:
                 (* Perhaps a misleading name:
                  * For any pattern: final or further, we search for a virtual
                  * declaration in super - and we need to get the off for this virtual
                  * Then we test if super for this FinalPtn is implicit
                  * In qAbstractSyntaxTree::decl:checkVirtualArgs,
                  * we do an almost identical check for virtual arguments
                  * We should unify ...
                  *)
                 (# VP: ^Pattern; (* not always the case ??*)
                    vDcl: ^Decl; 
                    pn: @integer
                 do (*'FinalPtn:check:setImplSuper:'->puttext; doPT -> putline;*)
                    (if ptnKind // FinalPtn //furtherPtn then
                        (sig.id[],false) -> basicScope.superDesc.localSearch -> (vDcl[],pn);
                        (if vDcl[] <> none then
                            (*'Found vDcl: ' -> puttext; vDcl.sig.dopt -> puttext;*)
                            (* OBS! in V:: A { } isImplSuper should not be true
                             * Only for  V:: { }
                             *)
                            vDcl[] -> VP[] -> OD.super.ATd[];
                            (* ' pn:' -> puttext; pn -> putint; 
                             ' off:' -> puttext; off -> putint; ' ' -> put; *)
                            (if OD.super.isEmpty then
                                pn + 1 -> OD.super.pn;
                                true -> OD.super.isImplSuper;
                                (*' isImplSuper=T '-> puttext;*)
                            if);
                            (if VP.OD.hasItems (*not VP.OD.IS.isEmpty*) then
                                true -> OD.super.isSingularImplSuper;
                                (*' isSingularImplSuper=T ' -> puttext; *)
                             else
                                (*' isCategoryImplSuper: ' -> puttext*)
                            if);
                            (*vDcl.sig.doPT -> putline*)
                         else
                            '\n!!! No virtual declaration in super for: ' -> puttext;
                            sig.doPT -> putline;
                        if)
                    (* else
                        'No virtual PnKind:' -> puttext;  ptnKind -> putint; newline*)
                    if)
                 #);

            do (if traceCheck then  
                   '*** Check ptn: ' -> puttext; sig.id[] -> putline if);
               setImplSuper;
               (* Must check sig before OD;
                * Items in OD may refer Decl's in sig
                * Allocation of storage for sig must be in OD.IS
                * Scope for Decl's in sig must be basicScope
                *)
               (none,OD.IS[],OD.IS[],true) -> sig.check; 
               (none,basicScope[],basicScope[],true) -> OD.check;
               inner;
            #);
          isInner::
            (* Perhaps ad hoc!? -- from old code: inner
             * check BKWptn: %inner P
             *)
            (# A: ^ObjectGenerator; org: ^Items
            do (if OD.primNo = inner_prim then
                   basicScope[] -> org[];
                   args.scanArgs
                   (# A: ^ObjectGenerator
                   do current[] -> A[];
                      A.super.on - 1 
                        -> (args.origin[]->org[]).toOrigin -> org[]; 
                   #);
                   org.noOfInner + 1 -> org.noOfinner;
                   (if org.noOfInner = 1 then 
                       org.dsize + 1 
                         -> org.dsize 
                         -> org.innerInx 
                   if);
               if)
            #);     
          alloc::< 
            (# 
            do IT[] -> OD.alloc;
               (if ptnKind 
                // virtualPtn then
                   IT.dsize + 1-> IT.dsize -> off   
                // furtherPtn // finalPtn then
                   OD.super.ATd.off -> off
               if);
               inner 
            #);
          desc::<
            (# elm:: items
            do (*(if not isChecked and not beingChecked then 
                   '!!! ' -> puttext; sig.doPT -> putline;
                   '** Not checked: ' -> putline;
                   doPT -> putline;
                   (none,origin[],origin[],true) -> check;
               if);*)
               (if not OD.hasItems (*OD.IS.isEmpty*) then
                   (* V: < A, V::< B, or V:: C *)
                   OD.super.desc -> D[]
                else
                   OD.IS[] -> D[]
               if);
               inner;
            #);

          isRecursive: @boolean;
          entity:: (#do OD.entity -> E[] #);
          skind:: (# do ': ' -> S[] #);
          getEntries:: (# do OD.getEntries -> (names[],entries[]) #);
          objDescEQ:: (# do DN -> OD.objDescEQ -> value #);
       #);
     
     ObjectGenerator::<
       (# setUpOrigin::
            (#
            do (if fixSuperOn then
                   (if isObjectDesc then
                       IS[] -> super.setUpOrigin; 
                    else
                       origin[] -> super.setUpOrigin; 
                   if)
                else
                   origin[] -> super.setUpOrigin;                    
               if);
               origin[] -> IS.setUpOrigin;
               this(ObjectGenerator)[] -> IS.OT[];
               sig[] -> IS.sig[];
            #); 
          check::
            (# emptySignature:
                 (# sig: ^Signature
                 do Signature -> sig[];
                    origin[] -> sig.origin[]
                 exit sig[]
                 #);
               eItems:
                 (# IT: ^Items;
                 do Items -> IT[];
                    origin[] -> IS.origin[];
                    Properties -> IT.props[];
                    Include -> IT.incl[];
                    ObjectGenerator -> IT.OT[];
                    sig[] -> IT.sig[]; (* is none *)
                 exit IT[]
                 #);
            do (if traceCheck then
                   '*** Check ObjectGenerator:' -> puttext; 
                   doPT -> putline if);
               (if super.ATd[] = none then 
                   (* else implict super that has been setUp*)
                   (if sig[] = none then
                       (if father## = pattern## then 'Is pattern' -> putline if);
                       (if traceCheck then
                           '*** sig is none: '->puttext;
                           super.doPT -> putline;
                       if);
                       (* A singular statement:
                        *     bar(a,...) { ... }
                        * isObjectDesc: IS not empty or has virtual arguments
                        * else: just a pattern invocation
                        * Note! isObjectDesc is not defined before super.check 
                        *       has been executed
                        *)
                       (none,basicScope[],basicScope[],true) -> super.check;
                       (if false and fixSuperon and isObjectDesc then super.IncrOn if)
                    else
                       (if father## <> pattern## then 'Not pattern' -> putline if);
                       (* A pattern:
                        *     foo(a: ?int, ...): bar(a, ...){ ... } 
                        * where
                        *     super = bar(a,...) 
                        *)
                       (if traceCheck then 
                           '*** sig is not none: '->puttext;
                           super.doPT -> putline;
                       if);
                       (if fixSuperOn then
                           (none,sig[],sig[],true) -> super.check
                        else
                           (none,basicScope[],sig[],true) -> super.check
                       if)
                   if);                   
               if);      
               (if isObjectDesc then
                   (if traceCheck then 'isObjectDesc' -> putline if);
                   this(ObjectGenerator)[] -> newDesc -> IS.descNo;
               if);
               (origin[],super[],super.hasVirtualArgs) -> IS.checkItems;
            #);
          isSimpleValue: BooleanValue
            (* ObjectGeneration in (the rightside)
             * C: = integer(12)   -- refer to pattern integer
             * C: = 12
             * C: = a + b         -- pattern +
             * C: = foo(e1,e2,e3) -- pattern foo
             * C: = X             -- data-item X
             * V: ? a + b         -- and simialr for variable
             * V:= foo(e1,e2,e3)  -- and assignment
             * And they may be singular
             * 1:   OG - non-singular
             * 1.1  OG - integer, boolean, char ==> true
             * 1.2     - else get possible return value
             * 2:   {...} - singular, no super
             * 2.1        - primno = integer, char, boolean
             * 3:   OG{...} - singular with super
             * 3.1          -- return value of OG
             * 3.2          -- OG not simpleValue?
             *)
            (# q: ^ObjectGenerator; pNo: @integer
            do (* '*** isImpleValue: ' -> puttext; primNo -> putint; newline;
               doPT -> putline;
               '>>> super:qual:'->putline;
               (if (super.getQual -> q[]) = none then 'none' -> putline
                else
                   q.doPT -> putline;
                if);*)
               (if (super.getQual -> q[]) <> none then
                   q.primNo -> pNo
                else
                   primNo -> pNo
               if);
               (if pNo
                // integer_prim
                // char_prim
                // boolean_prim  then
                   true -> value
               if)
            #);
          isObjectDesc: booleanValue
            (* this can be a singular or pattern defined ObjectDesc:
             *    IS.hasItems
             * It can also be an ObjectInvocation with virtual arguments
             *     super.hasVirtualArguments
             * that has to treated as an ObjectDesc
             * And super is not a basic pattern
             *     not super.isBasic
             *)
            (#
            do hasItems or (super.hasVirtualArgs and not super.isBasic)
               -> value
            #);          
          alloc::
            (#
            do IT[] -> super.alloc;
               (if isObjectDesc then 
                   IT[] -> IS.alloc 
               if)
            #);
          hasCode:: (# do true -> value #);

          getNameForOff::
            (#do (attOff,descNo,isRef,isIndexed) -> IS.getNameForOff -> NM[] #);
          getDescNo:: (# do IS.descNo -> dNo #);
          objDescEq:: (# do DN -> IS.objDescEq -> value #);
       #);
     Invocation::<
       (# setupOrigin:: 
            (# do scanSons(# do origin[] -> current.setUpOrigin #)#);
          check::
            (# 
            do (if traceCheck then '*** Invocation:check: ' -> puttext; doPT -> putline if);
               (* basicScope.doP -> putline;
               argscope.doP -> putline;*)
               scanSons
               (# E: ^Exp; i: @integer
               do i + 1 -> i;
                  (rec[],basicScope[],argScope[],isFirst) 
                    -> current.check -> basicScope[];
                  false -> isFirst;
                  current[] -> rec[];
                  (if isLast then
                      current[] -> E[]; (* use rec *)
                      E.ATd[] -> ATd[];
                      E.on -> on;
                      i -> lgth;
                  if)
               #)
            #);
          incrOn:
            (#
            do '***** incrOn: ' -> putline; doPT -> putline;
               scanSubTree
               (# doIt::
                    (# AP: ^Apl
                    do (if current## <= Apl## then
                           current.doPT -> putline;
                           current[] -> AP[];
                           AP.on + 1 -> AP.on;
                           AP.doPT -> putline;
                       if);
               #)#)
            #);
          alloc:: (# do scanSons(# do IT[] -> current.alloc #)#);
       #);
     ObjectInvocation::<
       (# setUpOrigin:: 
            (# 
            do origin[] -> ptnId.setUpOrigin; 
               origin[] -> args.setUpOrigin
            #);
          check::
            (# elm:: scope; org: ^Items
            do (if traceCheck then
                   '*** ObjectInvocation:check: ' -> puttext; ptnId.T[] -> putline if);
               (* ' :scope: ' -> puttext; basicScope.doPT ->putline;*)
               (if basicScope[] <> none then (* ad hoc *)
                   (if traceSearch then
                       '>>>ObjectInvocation:search: ' -> puttext;
                       ptnId.T[] -> putline
                   if);
                   (if (1 -> ptnId.T.inxGet) = '#' then
                       ((2,ptnId.T.length) -> ptnId.T.sub,isFirst) 
                         -> basicScope.search -> (ATd[],on,pn);
                    else
                       (ptnId.T[],isFirst) 
                         -> basicScope.search -> (ATd[],on,pn);
                   if);
                   (if ATd[] <> none then 
                       on -> ptnId.on; (* just for debugging *)
                       (ptnId.T[],on,ATd[]) -> found;
                    else
                       this(TopNode)[] -> SemanticError
                       (#
                       do 'Did NOT find a declaration of: "'-> msg;
                          ptnId.T[] -> msg;
                          '"' -> msg;
                       #);
                       errorDecl[] -> ATd[]
                   if);
                   
                   this(Exp)[] -> ATd.checkVirtualArgs;
                   
                   (if ATd.primNo = this_prim then
                       (* ad hoc - must be fixed *)
                       (# A: ^Item
                       do args.scanArgs(# do current[] -> A[] #);
                          (none,argScope[],argScope[],true) -> A.check;
                          A.desc -> basicScope[];
                       #);
                       leave check  
                   if);
                   (args[],argScope[]) -> argBuf.add;
                   
                   (* ok if static/dynamicObject - what does this mean?
                    * If pattern, scope is the desc of the return value
                    * ATd.desc <> none is before we used getQual - can be eliminated
                    *)
                   (if ATd[] = thisCoreDecl[] then (* perhaps move to getQual!?*)
                       coreDecl.desc -> basicScope[]
                    else
                       (if (ATd.getqual <> none) then
                           (ATd.getQual).IS -> basicScope[];
                        else
                           'getQual:none:' -> puttext; ATd.doPT -> putline
                       if)
                   if)
                else
                   'Variable:check: scope is none: '->puttext; dopt -> putline
               if)
            #);
          alloc:: 
            (#
            do (if ATd[] = none then 
                   'Atd is none: '->puttext; label -> putline; dopp -> putline; if);               
               (IT[],args[]) -> ATd.isInner ;
               scanSons(#do IT[] -> current.alloc #);
               
            #);
       #);
     BracketedExp::<
       (# setUpOrigin:: (# do origin[] -> IV.setUpOrigin #);
          check:: 
            (# 
            do (rec[],basicScope[],argScope[],isFirst) -> IV.check -> basicScope[];
               IV.ATd[] -> ATd[];
               IV.on -> on
            #);
          alloc:: (# do IT[] -> IV.alloc #)
       #);
     const::<
       (# check:: (# do integerDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     charObj::<
       (# check:: (# do charDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     stringObj::<
       (# check:: (# do stringDecl[] -> ATd[]; ATd.desc -> basicScope[] #)
       #);
     found:
       (# id: ^text; on: @integer; ATd: ^Decl
       enter(id[],on,ATd[])
       do (if traceSearch then
              '***** Found: ' -> puttext; id[] -> puttext; 
              ' on: ' -> puttext; on -> putint;
              (if ATd[] <> none then
                  ' Decl: ' -> puttext; ATd.sig.doPT -> putline
               else 
                  newline
          if)if)
       #);
     argBuf:  @
       (# argElm:
            (# #);
          add:
            (# A: ^Arguments; S: ^Scope; next: ^add
            enter(A[],S[])
            do (if head[] = none then
                   this(add)[] -> head[] -> last[]
                else
                   this(add)[] -> last.next[] -> last[]
               if)
            #);
          head,last: ^add;
          check:
            (# H: ^Add;
            do head[] -> H[];
               none -> head[] -> last[];
               Loop: 
                 (if H[] <> none then
                     (none,H.S[],H.S[],true)  -> H.A.check;
                     H.next[] -> H[];
                     restart Loop
                 if);
               (if head[] <> none then restart check if)
            #)          
          
       #);
     
     getObjectDesc:: 
       (# OD: ^ObjectGenerator
       do descNo -> newDesc.getOD -> OD[];
          OD.IS[] -> D[] 
       #);
     
     newDesc: @
       (# OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;
          getOD: 
            (* only used from minienv *)
            (# descNo: @integer; anODx: ^ObjectGenerator
            enter descNo 
            do (if descNo > 0 then 
                   OD[descNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline
               if)
            exit anODx[]
            #);
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     notification: 
       (#  msg: @
            (# T: ^text;
            enter T[]
            do (*T[] -> puttext;*)
               T[] -> lex.errorStream.puttext;
            #);
          n: ^TopNode;
          thisModule: ^module;          
          printHeading:< (# do '\n' -> puttext;inner #);
          printLines:
            (# first,last,p: @integer; ch: @char; Lines: ^Text;
            do true -> (n.theModule).doPT -> Lines[];
               n.beginPos -> p;
               L:
                 (if (first < 4) and (p > 1) then
                     p - 1 -> p;
                     (if  (p -> Lines.inxGet) = ascii.newline then 
                         first + 1 -> first if);
                     restart L
                 if);
               L:
                 (if (0 < p) and ((p <= n.endpos) or (ch <> ascii.newline))
                     and (p <=Lines.length) then
                     Lines.T[p] -> ch -> put;
                     p + 1 -> p;
                     restart L
                 if);
               newline;
            #);         
          report:< BooleanValue(#do inner #);
       enter n[] 
       do (*n.theModule -> errorModule[];*)
          (if report then
              (if lex.errorStream[] = none then &text[] -> lex.errorStream[] if);
              (if not withPos then 
                  printHeading;
                  ' in module: "' -> puttext; 
                  (if n.theModule <> none then                  
                      (n.theModule->thisModule[]).DI.sig.doPT -> puttext; 
                      '"' -> put; newline;
                      printLines;;
                      (*n.father.doPT -> putline*)
                   else
                      'n.theModule = none"'->putline
                  if);
                  '**** ' -> puttext;
                  &text[] -> lex.errorStream[]
              if);
          
              (if withPos then
                  n.beginPos + 1 (* see worldWindow:handleSyntaxErrors *)
                    -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;
                  n.endPos -> lex.errorStream.putint; 
                  ' ' -> lex.errorStream.put;          
              if);
              INNER;              
              lex.errorStream.newline;
              (if not withPos then
                  lex.errorStream[] -> putline
              if);
          if)
       #);
     SemanticError: Notification
       (# report:: (# do reportSemErr -> value #);
          printHeading::
            (#
            do 'Semantic error' -> puttext;
            #);
       do INNER;
          true -> semanticErrors
       #);
     QuaCheck: Notification
       (# report:: (# do reportQuaCheck -> value #);
          printHeading:: 
            (# 
            do 'Run-time check needed' -> puttext
            #)
       do (if reportQuaCheck then inner if)
       #);
     semanticErrors: @boolean;
     
  do '**** CHECKER ****' -> putline;
     0 -> newDesc.noOfDescs; (* needed when exe from minienv
                              * we must find a way to compile changed modules
                              * currently we compile all modules
                              *)
     false -> semanticErrors;
     (*true -> traceCheck;*)
     (*true -> traceSearch;*)
     
     rootModule.setUpOrigin;

     rootModule.check;
     argBuf.check;
     (*main.doPP -> putline;*)
     '**** ALLOC     ****'->putline;
     rootModule.alloc;
     (*main.doPT -> putline;*)

     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline
      else
         inner
     if)
  #)
