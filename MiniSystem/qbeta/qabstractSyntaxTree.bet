ORIGIN '~beta/basiclib/betaenv';
INCLUDE '../compiler_IF/compiler_IF';
---lib:attributes---
AbstractSyntaxTree: Tree
  (# Node: TopNode
       (# vNode::< Node;
          alloc:<
            (# IT: ^items
            enter IT[]
            do inner
            #);
          gen:<
            (# useReturnValue: @boolean; superAdj,staticOff: @integer
            enter(useReturnValue,superAdj,staticOff)
            do inner 
            #);
          adjustON:< 
            (# 
            do inner;
               scanSons(# do current.adjustOn #);               
            #);
          findNodeAtPos::
            (# 
            do L:
                 (if (beginPos <= pos) and (pos <= endPos) then
                     scanSons
                     (#
                     do  pos -> current.findNodeAtPos -> N[];
                        (if N[] <> none then 
                            (if trace then '>'-> put if);
                            leave L 
                        if)
                     #);
                     (if N[] = none then 
                         this(TopNode)[] -> N[]; 
                         (if trace then
                             newline; 
                             '[' -> put; beginPos -> putint; 
                             ',' -> put; endPos -> putint; ']' -> put;
                         if)
                     if)
                 if)
            #);
          doMapBCposToCharRange::
            (# bPos1,ePos1: @integer; trace: (# exit false #)
            do (if trace then
                   '\ndoMapBCposToCharRange: ' -> puttext; label -> putline; 
                   'Lsc: ' -> puttext; lsc -> putint; 
                   ' in: '->puttext;
                   beginBCP -> putint; ','->put; endBCP -> putint; newline;
               if);
               
               (if (beginBCP < lsc) and (lsc <= endBCP) then
                   (if trace then
                       'Inside: ' -> puttext;
                   if);
                   beginPos -> B; endPos -> E;
                   (if trace then 
                       B -> putint; ','->put; E -> putint; newline 
                   if);
                   L:
                     scanSons
                     (#
                     do (if true (*not current.isObjDesc*) then (* do not go into singular*)
                            lsc -> current.doMapBCposToCharRange -> (bPos1,ePos1);
                            (if bPos1 > 0 then 
                                bPos1 -> B; ePos1 -> E;
                                leave L 
                        if)if)
                     #)
               if)
            #);
          theModule::<
            (#
            do inner;
               (if md[] = none then 
                   (if father[] = none then
                       'theModule:father is none: ' -> puttext;
                    else 
                       father.theModule -> md[];                        
                   if)
               if)
            #);
       do inner
       #);     
     Module:< Node
       (# SO: ^StaticObject;
          PT:: 
            (# 
            do (0,length) -> block
               (#
               do (0,break) -> SO.PT 
               #)
            #);
          length:: (# do SO.length -> value #);
          label:: (# do 'Module' -> lab[] #);
          PP:: (# do label -> lx.append #);
                         
          (* Bindings from tree *)
          moduleName:: (# do SO.sig.id[] -> N[] #);
          getEntries:: (# do SO.getEntries -> (names[],entries[]) #);
          entity:: (# do SO.entity -> E[] #);
          theModule::(# do this(Module)[] -> MD[] #);
          isAmodule:: (# do &iModule[] -> M[]; this(Module)[] -> M.M[] #);
          getOrigin:: (# do origin[] -> org[] #);
          pathToModuleFN:: (# do pathToFN[] -> path[] #);
          innFile:: 
            (# 
            do (if F[] = none then inFile[] -> F[] else F[] -> inFile[] if) 
            #);
          pathToFN: ^Text;
          inFile: ^File;
          myDesc:: (# do desc -> OD[] #);
          desc:<
            (# D: ^Items
            do inner
            exit D[]
            #);
          kind:: (# do '/' -> ch #);
          skind:: (# do ': /' -> S[] #);
          handleDirModules:
            (# pDirModule:<
                 (# moduleDir: ^text; (* name of direcory with BETA module *)
                    md: ^Module
                 enter moduleDir[]
                 do inner;
                 exit md[]
                 #);
               findModuleItems:
                 (# 
                 do (if trace then
                        'FindDir: find directories in:\n   ' -> puttext; 
                        path.append -> putline; 
                    if);
                    (path.append,false) -> getBETAdirectories
                    (#
                    do scan
                       (#
                       do (if not currentIsFile then
                              current[] -> addDirModuleN;
                          if)
                       #)
                    #);
                 #);
               
               dirModuleN: [4] ^text; dcTop: @integer;
               addDirModuleN:
                 (# dir: ^text
                 enter dir[]
                 do (if (dcTop + 1 -> dcTop) > dirModuleN.range then 
                        dirModuleN.range -> dirModuleN.extend;
                        dirModule.range -> dirModule.extend
                    if);
                    dir[] -> dirModuleN[dcTop][]
                 #);
               (* Perhaps save ModuleItemDecl instead?
                * Perhaps factor appendModule out of scanDir
                *)
               dirModule: [4] ^ModuleItem;
               scanDir:
                 (# currentModule: ^Module;
                    N: ^text; (* module on path to ...*)
                 do (*'ScanDir:'->putline; dctop->putint; newline;*)
                    (for i: dcTop repeat
                         (*dirModuleN[i][] -> N[] -> putline;*)
                         (* See also Checker:ModuleItem:doCheck *)
                         dirModuleN[i][] -> N[] -> pDirModule -> currentModule[];
                         (N[],currentModule[]) -> ModuleItem -> dirModule[i][];
                         dirModule[i][] -> mkModuleItemDecl -> appendModule; 
                         (if currentModule[] = none then 'currentModule none' -> putline if);
                         true -> dirModule[i].isParsed; (* eliminate *)
                         INNER;
                    for);
                 #);              
               appendModule:
                 (# dcl: ^Decl 
                 enter dcl[] 
                 do (* 'AppendModule: ' -> putline; dcl.doPT -> putline; *)
                    dcl[] -> SO.OG.IS.append
                 #);                
               main,m: ^Module;
            do (if trace then
                   'HandleDirModules: '->puttext; 
                   SO.sig.doPt -> putline;
               if);
               0 -> dcTop;
               (if (dirCh->(path.append).put) -> locateWorld.CWD.equal then
                   this(Module)[] -> main[];
                   (*'Found main: ' -> putline; main.doPT -> putline*)
               if);
               
               findModuleItems;
               
               scanDir 
               (#
               do currentModule.SO.sig.id[] -> path.push;
                  (if trace then
                      'EQ:'->putline; path.append-> putline; 
                      locateWorld.CWD[] -> putline; 
                  if);
                  &currentModule.handleDirModules
                  (# pDirModule::
                       (#
                       do moduleDir[] -> this(handleDirModules).pDirModule -> md[]
                       #)
                  #) -> m[];
                  (if m[] <> none then m[] -> main[] if);
                  path.pop
               #);

            exit main[]
            #);
              
          imports: @
            (# L: [4] ^module; top: @integer;
               init:< (# do 0 -> top;(* ' imports:init ' -> puttext; *) #);
               addM:
                 (# mi: ^module
                 enter mi[]
                 do (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi[] -> L[top][];
                    (*'Add:' -> putline; mi.doPT -> putline*)
                 #);
               add:
                 (# mi: ^moduleItem
                 enter mi[]
                 do (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi.md[] -> L[top][]
                 #);               
               scan:
                 (# current: ^module
                 do (for i: top repeat
                         L[i][] -> current[]; inner
                 for)#);
               mark: scan
                 (# 
                 do (if trace then
                        current.SO.sig.doPT -> putText; ' descNo: '->putText; 
                        (current.desc).DescNo -> putint; ' ' -> put;
                    if);
                    current.mark 
                 #);
            #);
          trace: (# exit false #);
          mark: 
            (# 
            do (if trace then 'MarkImports: '->puttext; SO.sig.doPT ->putline if);
               (if not isIncluded then (* avoid circularity *)
                   true -> isIncluded; 
                   imports.mark 
               if);
            #); 
          objDescEQ:: (# do DN -> SO.objDescEQ -> value #);
          isAdded,isIncluded: @boolean;
       enter SO[] -> append
       #);
     ModuleItem:< Decl
       (# label:: (# do 'Module' -> lab[] #);
          PP:: (# do label -> lx.append #);
          PT:: 
            (#
            do (if true then
                   '--' -> lx.puttext; sig.id[] -> lx.puttext
                else
                   (pos,break) -> MD.PT 
               if)
            #);
          length:: (# do MD.length -> value #);
          getEntries:: (# do md.getEntries -> (names[],entries[]) #);
          Entity:: (# do md.entity -> E[]#);
          kind:: (# do (if true then md.kind -> ch else '/' -> ch if)#);
          skind:: (# do MD.skind -> S[] #);
          isaModule:: (# do &iModule[] -> M[]; md[] -> M.M[] #);
          isParsed: @boolean;
          myDesc:: (# do MD.desc -> OD[] #);
          objDescEQ:: (# do DN -> MD.objDescEQ -> value #);
          
          MD: ^Module; (*SO: ^StaticObject - perhaps just StaticObject?*)
       enter(Name -> append,MD[]->append)
       #);
     Items:< Scope 
       (# PT::< 
            (# 
            do (pos,length) -> block
               (#
               do (if props[] <> none then 
                      (pos,break) -> props.PT;
                      (pos,break) -> mkbreak
                  if);
                  inner PT;
                  scanSons
                  (# 
                  do (if not isFirst or (incl[] <> none) and (incl.son[] <> none) then
                         (pos,break) -> current.PT; 
                         (if not isLast then
                             (pos,true) -> mkbreak
                     if)if)
               #)#)
            #);
          length::
            (#
            do (if props[] <> none then props.length -> value if);
               scanSons(# do current.length + value -> value #)
            #);
          label:: (# do 'Items' -> lab[] #); 
          PP:: (# do label -> lx.append #);
          display:: (# do 'Items:'->putline #);
          scanDecls:
            (# currentDcl: ^decl;
            do scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if I.isDecl then
                      I[] -> currentDcl[];
                      inner scanDecls
                  if);
               #)               
            #);  
          scanAllDecls:
            (# currentDcl: ^Decl;
               superOrgOff,level: @integer
            do (if (superDesc[] <> none) and (superDesc[] <> objectDecl.desc) then
                   &superDesc.scanAllDecls
                   (#
                   do currentDcl[] -> this(scanAllDecls).currentDcl[];
                      inner scanAllDecls
                   #) -> (superOrgOff,level)
               if);
               (if sig[] <> none then
                   sig.scanParameters
                   (#
                   do currentArg[] -> this(scanAllDecls).currentDcl[];
                      inner scanAllDecls
               #)if);
               scanDecls
               (#
               do currentDcl[] -> this(scanAllDecls).currentDcl[];
                  inner scanAllDecls
               #)
            exit(superOrgOff,level) 
            #);
          collectSimple::
            (# SimpleKind: (# exit 1 #);
               PatternKind: (# exit 2 #);
               ReferenceKind: (# exit 3 #);
               RepetionKind: (# exit 4 #);
               VirtualKind: (# exit 5 #);
               off: @integer
            do scanAllDecls
               (# name: ^Text;
                  off,kind: @integer
               do '???'-> name[];
                  currentDcl.sig.ID[] -> name[];
                  currentDcl.off -> off;
                  (if off > 0 then
                      (if currentDcl.isBasic then
                          SimpleKind -> kind
                       else
                          (if currentDcl.isVirtual then
                              virtualKind -> kind
                           else
                              ReferenceKind -> kind
                          if)
                      if)
                   else
                      (* chef isIndexed -  see parser:collectSimple *)
                      patternKind -> kind
                  if);
                  'Collect: ' -> puttext; name[] -> puttext;
                  ' ' ->put; off -> putint;
                  ' ' -> put; kind -> putint; newline;
                  (name[],off,kind,currentDcl[]) -> addSimple
               #);
            #);
          getEntries:: 
            (# 
            do scanDecls(# do (currentDcl.sig.id[],currentDcl[]) -> add #)
            #);
          ifBasic: BooleanValue
            (#
            do (if props[] <> none then
                   props.findBasic -> value -> isBasic                 
               if)
            #);
 
          doCall:<
            (# N: ^text; LMR: @char
            enter(N[],LMR)
            do inner; 
            #);
          descNo: @integer;
          isBasic,
          isEmpty: @boolean;
          isCore: integerValue
            (#
            do (if (props[] <> none) and (props.basicProp[] <> none) then
                   props.basicProp.coreNo  -> value
               if)
            #);
          sig: ^Signature; (* if pattern, the signature else none *)
          OT: ^ObjectGenerator;
          props: ^Properties;
          incl: ^Include;
          doHasCode:@boolean;
          superDesc: ^Items; 
          (* Item's are appended
           * But sometimes not so clean/smart that some attributes
           * are both explicit and appended as 'incl' and others like Item's
           * are appended
           *)
       #);
     Item: Node 
       (# isDecl:< BooleanValue;
          isVirtual:< BooleanValue;
          isBasic:< BooleanValue(# do inner #);
          desc:<
            (# elm:< Node; D: ^Items
            do inner
            exit D[]
            #);
          sort:: (# do this(Item)[] -> S[] #);
          hasCode:< BooleanValue;
          findNextImp::<
            (#
            do inner;
               (if impx[] <> none then
                   (if beginBCP > bcp then
                       this(Item)[] -> impx[]
                    else
                       L:
                         scanSons
                         (# 
                         do (if (bcp -> current.findNextImp -> impx[]) <> none then
                                leave L 
               if)#)if)if)
            #)
       do inner 
       #);
     Properties:< Node
       (# PT::
            (#
            do '['->lx.put;
               scanSons
               (#
               do (pos,break) -> current.PT; 
                  (if not isLast then ','->lx.put if) 
               #);
               ']'->lx.put;
            #);
          length:: (# do scanSons(#do current.length + value -> value #)#);
          scanProps:
            (# currentProp: ^Property
            do scanSons
               (#
               do current[] -> currentProp[];
                  inner scanProps
               #)
            #);
          findBasic: booleanValue
            (#
            do scanProps
               (#
               do L:
                    (if true
                     // 'basic' -> currentProp.P.T.equalNCS then
                        currentProp[] -> basicProp[];
                        basicProp.getPrimNo -> basicProp.primNo;
                        true -> value;
                        leave L
                     // 'core' -> currentProp.P.T.equalNCS then
                        currentProp[] -> basicProp[];
                        basicProp.getPrimNo -> basicProp.coreNo;
                        false -> value; (* OBS - clean-up*)
                        leave L 
                    if)
               #)
            #);         
          basicProp: ^Property
       do
       #);
     Property:< Node
       (# PT:: 
            (# 
            do (pos,break) -> P.PT; 
               (if arg[] <> none then (pos,break) -> arg.PT if) 
            #);
          length:: 
            (# 
            do P.length -> value; (if arg[] <> none then arg.length + value -> value if) 
            #);
          P: ^Lexem;
          arg: ^Properties;
          
          getPrimNo:
            (# V: ^Const; res: @integer
            do L:
                 (if arg[] <> none then
                     arg.ScanSons
                     (# prp: ^Property
                     do current[] -> prp[];
                        prp.P[] -> V[];                   
                        V.T.setPos; V.T.getInt -> res;
                        leave L
                     #);
                 if)
            exit res
            #);
          primNo,coreNo: @integer; (* clean-up here *)
       enter append
       #);
     Include:< Item
       (# PT:: 
            (# 
            do '%include ' -> lx.append;
               scanSons
               (#do (pos,break) -> current.PT; 
                  (if not isLast then ',' -> lx.put if)#)
            #);
          length:: 
            (#
            do 9 -> value;
               scanSons(# do current.length + 1 + value -> value #)
            #);
          Label:: (# do 'include' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          encModule:
            (# m: ^Node; md: ^moduleItem
            do father[] -> m[];
               L:
                 (if not (m## <= moduleItem##) then 
                     (*newline; 
                     M.doPT -> putline;*)
                     m.father[] -> m[];
                     restart L
                 if);
               m[] -> md[]
            exit md[]
            #);

       #);
     Decl: Item
       (# PT::< 
            (# 
            do (*'('->lx.put; off -> lx.putint; ')'-> lx.put;*)
               inner 
            #);
          sig: ^Signature;
          off: @integer;
          isDecl:: TrueValue;
          isInner:< 
            (# basicScope: ^items; args: ^Arguments enter(basicScope[],args[]) do inner #);
          checkVirtualArgs:
            (# aArgs: [6] ^ObjectGenerator; top: @integer;
               E: ^Exp
            enter E[]
            do (if not isBasic then
                   E.args.scanArgs
                   (#
                   do (if (top + 1 -> top) > aArgs.range then
                          aArgs.range -> aArgs.extend
                      if);
                      current[] -> aargs[top][]
                   #);
                   sig.args.scanArgs
                   (# i: @integer
                   do i + 1 -> i;
                      (if current.isVirtual then
                          (*'Arg: ' -> puttext; current.doP -> putline;
                          aArgs[i].doP -> putline;*)
                          current[] -> aArgs[i].super.ATd[];
                          1 -> aArgs[i].super.pn;
                          true -> aArgs[i].super.isImplSuper;
                          (if not aArgs[i].IS.isEmpty then
                              true -> aArgs[i].super.isSingularImplSuper;
                              (* ' isSingularImplSuper=T ' -> puttext; *)
                          if);
                      (*aArgs[i].adjustON;*)
               if)#)if)
            #);
          getQual:<
            (# qual: ^ObjectGenerator
            do inner
            exit qual[]
            #);
          checkQual:<
            (# OG: ^ObjectGenerator
            enter OG[]
            do inner 
            #);
          pushThis:< (# do inner #);
          loadAdr:< (# E: ^Exp enter E[] do inner #);
          load:< 
            (# E: ^Exp; useReturnValue: @boolean; staticOff: @integer
            enter(E[],useReturnValue,staticOff)
            do inner 
            #);
          loadX:< (# do inner #);
          loadArgs:< 
            (# E: ^Exp; superAdj: @integer  enter(E[],superAdj) do inner #);
          isPrim:< IntegerValue(# do inner #);
          isCore:< integerValue(# do inner #);
          pushOff:< (# next: ^exp enter next[] do inner #);
          store:< (# noSwap: @boolean enter noSwap do inner #);
          popReturn:< (# do inner #);
       #);
     Scope: Node
       (# display:<
            (# org: ^Scope
            do '>>>Scope:' -> puttext; inner;
               doP -> putline;
               (if (origin[] -> org[]) <> none then org.display if)
            #);
          localSearch:<
            (# CS: ^ Text; trySig: @boolean; ATd: ^Decl; pn: @integer
            enter(CS[],trySig)
            do(* 'localSearch: ' -> puttext; CS[] -> puttext;
               ' in: ' -> puttext; doP -> putline; *)
               inner               
            exit(ATd[],pn)
            #);
          search:<
            (# CS: ^ Text; isFirst: @boolean; 
               ATd: ^Decl; on,pn: @integer
            enter(CS[],isFirst)
            do (*'Search: ' -> puttext; CS[] -> puttext;
               ' in: ' -> puttext; doPP -> putline;*)
               inner;
            exit(ATd[],on,pn)
            #); 
       #);
     Signature:< Scope
       (* In xbeta, Signature have subpatterns UnarySignature, etc *)
       (# PT:: 
            (# 
            do scanSons
               (#do (pos,break) -> current.PT; 
                  (if not isLast then ' ' -> lx.put if)
               #);
               (*(if val[] <> none then val.PT if)*)
            #);
          length:: (# do scanSons(#do current.length + value -> value #)#);
          Label:: (# do 'Signature' -> lab[] #);
          PP::(# do Label -> lx.append #);
          display:: (# do 'Signature:'->putline #);
          xS: ^Lexem; (* Arguments, and fatCommas are just appended *)
          args: ^Arguments;
          val: ^Value;
          id: ^text;
          isKeyWord: @boolean;
          init:
            (# 
            enter(id[],isKeyWord)
            do (if not isKeyWord then
                   id[] -> Name -> Append
                if);
            #);
          setId:
            (# 
            do ''-> id[];
               args.scanSons
               (# B: @boolean; L: ^Lexem
               do (if not B then 
                      current[] -> L[];
                      L.T[] -> id.append;
                  if);
                  not B -> B
               #);
               true -> args.isKeyWord
            #);
          hasVirtualArgs: BooleanValue
            (#
            do (if args[] <> none then
                   args.hasVirtualArgs -> value
            if)#);
          scanParameters:
            (# currentArg: ^Decl
            do (if args[] <> none then
                   args.scanSons
                   (# isPar: @Boolean
                   do (if isKeyWord then (* not tested *)
                          (if isPar then
                              current[] -> currentArg[];
                              inner scanParameters
                          if);
                          not isPar -> isPar
                       else
                          current[] -> currentArg[];
                          inner scanParameters
                      if)
               #)if)
            #);
          scanParametersReverse:
            (# currentPar: ^Decl; first: @boolean
            do (if args[] <> none then 
                   (if isKeyword then
                       args.scanReverse
                       (# isPar: @boolean
                       do not isPar -> isPar;
                          (if isPar then
                              current[] -> currentPar[];
                              inner scanParametersReverse;
                          if)
                       #)
                    else
                       true -> first;
                       args.scanReverse
                       (# 
                       do (*'Arg: ' -> puttext; 
                           * current.doPT -> puttext; ' ' -> put;
                           *)
                          current[] -> currentPar[];
                          inner scanParametersReverse;
                          false -> first
                       #);
                       (*newline*)
               if)if)
            #);
       enter(init) 
          (* OBS! (init[with only enter id[]],isKeyWord) does not work 
           * Perhpas compiler error!?
           *)
       #);     
     Arguments:< Node
       (# elm:< Item;
          PT:: 
            (# 
            do (if true
                // isBinary then 
                   scanSons(# do (pos,break) -> current.PT #);
                // isKeyWord then 
                   scanSons
                   (# 
                   do (pos,break) -> current.PT; (if not isLast then ' ' -> lx.put if) 
                   #)
                // isFunction then
                   '(' -> lx.put;
                    scanSons
                   (# 
                   do (pos,break) -> current.PT; (if not isLast then ',' -> lx.put if) 
                   #);
                   ')' -> lx.put
                else
                   (* unary *) 
                   scanSons(# do (pos,break) -> current.PT #);
               if)
            #);
          length:: (# do scanSons(# do current.length + 1 -> value #)#);
          Label:: (# do 'Arguments' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          isBinary,isKeyWord,isFunction: @boolean;
          scanArgs:
            (# current: ^Elm; isLast: @boolean
            do (if isKeyWord then
                   scanSons
                   (# isArg: @boolean
                   do (if isArg then
                          current[] -> this(scanArgs).current[]; 
                          isLast -> this(scanArgs).isLast;
                          inner scanArgs
                      if);
                      not isArg -> isArg
                   #)
                else
                   scanSons
                   (# do current[] -> this(scanArgs).current[]; 
                      isLast -> this(scanArgs).isLast;
                      inner scanArgs #)
               if)
            #);
          hasVirtualArgs: BooleanValue
            (#
            do(* 'HVA:' -> puttext; dopt -> putline;*)
               L:
                 scanArgs
                 (# D: ^Decl 
                 do current[] -> D[];
                    (*'HasVirtualArgs: ' -> puttext; D.doPT -> putline;*)
                    (if D.isVirtual then
                        true -> value;
                        leave L
                    if)
                 #)
            #)
       #);
     Value:< Node
       (* A list of Decl's *)
       (# PT::
            (#
            do (if son[] <> none then 
                   ' -> ' -> lx.append;
                   scanSons
                   (# 
                   do (pos,break) -> current.PT; 
                      (if not isLast then 
                          ','-> lx.put;
                          ' '-> lx.put
                      if) 
                   #)
               if)
            #);
          length:: 
            (# 
            do 4 -> value;
               scanSons(# do current.length + value -> value #)
            #);
          Label:: (# do 'Value' -> lab[] #);
          PP:: (# do Label -> lx.append #)
       #);
     StaticObject:< Decl
       (# OG: ^ObjectGenerator;
          PT:: 
            (# 
            do (pos,break) -> sig.PT;
               ':' -> lx.put;
               ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; 
               (pos,break) -> OG.PT 
            #);
          length:: (# do sig.length + 4 + OG.length -> value #);
          Label:: (# do 'StaticObject' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          getEntries:: (# do OG.getEntries -> (names[],entries[]) #);
          entity:: (# do OG[] -> E[] #);
          isBasic:: (#do OG.isBasic -> value #);
          skind:: (# do ': @' -> S[] #);
       enter(sig[] -> append,OG[] -> append)
       #);
     DynamicObject:< Decl
       (# PI: ^PatternId;
          PT:: 
            (# 
            do (pos,break) -> sig.PT;
               ':' -> lx.put;
               ' ' -> lx.put; '^' -> lx.put; ' ' -> lx.put; 
               (pos,break) -> PI.PT 
            #);
          length:: (# do 3 + PI.length -> value #);
          Label:: (# do 'DynamicObject' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          entity:: (# do PI[] -> E[] #);
          skind:: (# do ': ^' -> S[] #);
       enter(sig[] -> append,PI[] -> append)
       #);     
     Pattern: Decl
       (# label:: (# do 'pattern' -> lab[] #); 
          PT::< 
            (# 
            do (pos,break) -> sig.PT; 
               inner;
               ' ' -> lx.put;
               (pos,break) -> OD.PT
            #);
          length:: (# do sig.length + 3 + OD.length -> value #);
          setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin;
               sig[] -> OD.sig[];
               origin[] -> OD.setupOrigin;
            #);
          check::< 
            (# setImplSuper:< (# do inner #)
            do (*'\n>>Pattern: ' -> puttext; sig.id[] -> putline; *)
               setImplSuper;
               (* Must check sig before OD;
                * Items in OD may refer Decl's in sig
                * Allocation of storage for sig must be in OD.IS
                * Scope for Decl's in sig must be basicScope
                *)
               (OD.IS[],OD.IS[],true) -> sig.check; 
               (basicScope[],basicScope[],true) -> OD.check;
               inner
            #);
          alloc::< (# do IT[] -> OD.alloc; inner #);
          desc::<
            (# elm:: items
            do (if OD.IS.isEmpty then
                   (* V: < A, V::< B, or V:: C *)
                   OD.super.desc -> D[]
                else
                   OD.IS[] -> D[]
               if);
               inner
            #);
          isBasic:: (# do OD.IS.isBasic -> value #);
          isCore:: (#do OD.IS.isCore -> value #);
          entity:: (#do OD.entity -> E[] #);
          skind:: (# do ': ' -> S[] #);
          getEntries:: (# do OD.getEntries -> (names[],entries[]) #);
          objDescEQ:: (# do DN -> OD.objDescEQ -> value #);
          OD: ^ObjectGenerator
       #);
     UnaryPattern:< Pattern
       (# (*Label:: (# do 'UnaryPtn' -> lab[] #);*)
          PP:: (# do 'UnaryPtn'  -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter (sig[]->append,OD[]->append)
       #);
     BasicUnaryPattern:< Pattern
       (# PP:: (# do 'UnaryPtn:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter (sig[]->append,OD[]->append)
       #);
     BinaryPattern:< Pattern
       (# PP:: (#do 'BinaryPtn:'-> lx.append; sig.id[]-> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[]->append,OD[]->append)
       #);
     BasicBinaryPattern:< Pattern
       (# PP:: (#do 'BasicBinaryPtn:'-> lx.append; sig.id[]-> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[]->append,OD[]->append)
       #);
     FunctionalPattern:< Pattern
       (# PP:: (# do 'FunctionalPtn:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append,OD[]->append)
       #);
     BasicFunctionalPattern:< Pattern
       (# PP:: (# do 'BasicFunctionalPtn:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append,OD[]->append)
       #);     
     KeywordPattern:< Pattern
       (# PP:: (# do 'KeywordPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #);
     BasicKeywordPattern:< Pattern
       (# PP:: (#do 'BasicKeywordPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #);     
     VirtualPattern:< Pattern
       (# isVirtual:: TrueValue;
          PP:: (# do 'VirtualPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put; '<' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #);
     FurtherPattern:< Pattern
       (# isVirtual:: TrueValue;
          PP:: (# do 'FurtherPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put; ':' -> lx.put; '<' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #); 
     FinalPattern:< Pattern
       (# isVirtual:: TrueValue;
          PP:: (# do 'FinalPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put; ':' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #);  
     ObjectGenerator:< item
       (# label:: (# do 'ObjectGenerator' -> lab[] #); 
          PP:: (# do label -> lx.append #);
          PT:: 
            (# ind: @integer
            do (pos,break) -> super.PT;
               (if (lx.length > 0) or (super.length > 0) then 
                   (* lx.length = 0 -> do not indent first line 
                    * unless super.length > 0
                    *)
                   4 -> ind 
               if);
               (if not IS.isEmpty then 
                   (pos + ind,true) -> mkBreak;
                   (pos + ind, length) -> block
                   (#
                   do (pos,true) -> IS.PT;
                   #);
               if)
            #);
          length :: (# do super.length + IS.length -> value #);
          isBasic: booleanValue
            (#
            do (if IS.isEmpty then
                   super.ATd.isBasic -> value; 
                else
                   IS.isBasic -> value
               if);
            #); 
          getEntries:: (# do IS.getEntries -> (names[],entries[]) #);
          entity:: (# do IS[] -> E[] #);
          desc:: 
            (# 
            do (if IS.isEmpty and not hasVirtualArgs then 
                   super.desc -> D[]
                else
                   this(ObjectGenerator).IS[] -> D[]
               if)
            #);
          hasVirtualArgs: BooleanValue(# do super.hasVirtualArgs -> value #);
          collectSimple:: (# do addSimple## -> IS.collectSimple #);
          genClass:< 
            (# N: ^text; sig: ^Signature; super: ^Invocation
            enter(N[],sig[],super[])
            do inner 
            #);
          super: ^Invocation;
          IS: ^Items;
          sig: ^Signature; (* Signature if part of Pattern - none otherwise *)
          singularName: ^text;
       enter(super[] -> append,IS[] -> append)
       #);
     PatternId:< Apl
       (# PT:: 
            (# 
            do (pos,break) -> IV.PT; (if id[] <> none then id[] -> lx.append if)
            #);
          length:: (# do IV.length -> value #);
          Label:: (# do 'PatternId' -> lab[] #);
          PP:: (#do Label -> lx.append #);
          desc:
            (# D: ^Items
            do ATd.desc -> D[]
            exit D[]
            #);
          IV: ^Invocation;
          id: ^text;
       enter IV[] -> append
       #);
     Invocation:< Apl
       (* <Exp> '.' <Exp> '.' ... *)
       (# label:: (# do 'Invocation' -> lab[] #);
          PP::(#do label -> lx.append #);
          PT:: 
            (#
            do scanSons
               (# E: ^Exp
               do                   
                  (if (*not isLast and *) not isFirst then
                      current[] -> E[];
                      (*'.' *) E.dot -> lx.puttext
                  if);
                  (pos,break) -> current.PT; 
            #)#);
          length:: (# do scanSons(#do current.length + value -> value #)#);
          isBasic: booleanValue
            (#
            do scanSons
               (# E: ^Exp
               do (if isLast then 
                      current[] -> E[]; E.isBasic -> value;
                  if)
               #);
            #);
          desc: 
            (# D: ^Items
            do (if ATd[] = none then
                   'Invocation:desc:ATd is none: ' -> puttext; 
                   father.father.dopt -> putline
                else
                   ATd.desc -> D[]
               if)
            exit D[]
            #);
          hasVirtualArgs: BooleanValue
            (#
            do (*'Inv:hasVA: ' -> puttext; dopt -> putline;*)
               L:
                 scanSons
                 (# E: ^Exp 
                 do current[] -> E[]; 
                    (*(if E.ATd[] = none then 'ATd is none' -> putline if);*)
                    (if (E.ATd[] <> none) and (E.ATd.sig.hasVirtualArgs -> value) then
                        leave L
                 if)#)
            #);
       #);
     Apl: Node
       (# PT::< 
            (# 
            do (if false then
                   '(' -> lx.put; on -> lx.putint; ')' -> lx.put; 
               if);
               inner
            #);
          ATd: ^Decl;
          isEmpty: @boolean;
          on,pn: @integer;
          lgth: @integer; (* length of this invocation 
                             * foo  , length = 1
                             * R.foo, length = 2
                             * A + B, length = 2
                             * etc
                             *)
          isImplSuper,  (* as in V ::< { ... } *)
          isSingularImplSuper (* where super is as in V:< foo{...}
                                   * and not as in V: < A *)
          : @boolean; 
          isThisBlockLevel: BooleanValue
            (#
            do (if false and ((length > 1) or isImplSuper) then
                   '\n*** isThisBlockLevel: ON:' -> puttext; on -> putInt;
                   ' PN:' -> puttext; pn -> putint;
                   ' length = ' -> puttext; lgth -> putint; 
                   (if isImplSuper then 
                       ' implSuper=T' -> puttext 
                   if);
                   (if isSingularImplSuper then 
                       ' implSingularSuper=T' -> puttext 
                   if);
                   ' thisSuper:\n' -> puttext;
                   doPT -> putline;
               if);
               (lgth <= 1) and (on = 0) -> value
            #);
          adjustON::
            (#
            do (if ON > 0 then
                   (*'adjustON: ' -> puttext; doP -> putline;*)
                   ON + 1 -> ON;
               if)
            #);
          isNameApl:: (# do this(Apl)[] -> NA[] #);
          getDeclModule::
            (# d: ^Decl;
               item: ^ModuleItem
            do (if ATd[] <> none then
                   ATd.theiModule -> to[]; 
                   ATd[] -> d[]; 
                   (if d.sort <> none then
                       (if d## <= ModuleItem## then
                           (*'MI: ' -> puttext; d.IT.doPT -> putline;*)
                           (*d.IT[] -> item[];*)
                           d[] -> item[];
                           &iModule[] -> to[];
                           item.md[] -> to.M[]; 
                        else
                           ATd[] -> dclx[]
                       if);
                    else
                       '\n****NameApl:getDeclModule:sort is none'->putline
                   if)
                else
                   (if this(node)## <= lexem## then
                       father.getDeclModule -> (to[],dclx[])
                    else
                       '\n****NameApl:getDeclModule:dcl is none'->putline;
                       doPP -> putline;
               if)if)
            #)          
       #);
     Exp: Apl
       (# args: ^Arguments;
          isAssign: @boolean;
          dot:< (# T: ^text do '.' -> T[]; inner exit T[] #);
          (*isBasic:< BooleanValue(# do inner #);*)
          isBasic: BooleanValue
            (# do (if ATd[] <> none then  ATd.isBasic -> value if) #);
          desc: (# D: ^Items do ATd.desc -> D[] exit D[] #);
          pushThis:< (# do inner #);
          loadAdr:< (# do inner #);
          loadOrigin:< (# superAdj: @integer enter superAdj do inner #);
          pushOff:< (# next: ^Exp enter next[] do inner #);
          loadArgs:< (# superAdj: @integer enter superAdj do inner #);
          execute:< 
            (# rec: ^Exp; useReturnValue: @boolean; staticOff: @integer
            enter(rec[],useReturnValue,staticOff) 
            do inner 
            #);
       #);
     Unary:< Exp
       (# Label:: (# do 'Unary' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          PT:: (# do (pos,break) -> M.PT; (pos,break) -> args.PT #);
          length:: (# do M.length + args.length -> value #);
          M: ^Name
       enter(M[] -> append,args[] -> append)
       #);
     Binary:< Exp
       (# Label:: (# do 'Binary' -> lab[] #);
          PP:: (# do  Label -> lx.append #);
          PT::
            (#
            do (pos,break) -> operator.PT; ' '-> lx.put;
               (pos,break) -> args.pt
            #);
          length:: (# do operator.length + 1 + args.length -> value #);
          dot:: (# do ' ' -> T[] #);
          operator: ^Name;
          (*argument: ^ObjectGenerator*)
       enter(operator[]->append, args[]->append)
       #);
     Function:< Exp
       (# label:: (# do  'Function' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          PT::(#do scanSons(#do (pos,break) -> current.PT #) #);
          length:: (# do scanSons(# do current.length + value -> value #)#);
          F: ^Name
       enter(Name -> F[] -> append,args[] -> append)
       #);
     KeyWord:< Exp
       (# Label:: (# do 'KeyWord' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          PT:: 
            (# 
            do (* first element in sons is receiver - may be empty *)
               scanSons
               (#
               do (pos,break) -> current.PT;
                  (if not isLast then ' ' -> lx.put if);
               #)
            #);
          length:: (# do scanSons(# do current.length + value -> value #)#);
          id: ^Text
       enter(id[],args[] -> append)
       #);
     BracketedExp:< Exp
       (# Label:: (# do 'BracketedExp' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          PT:: (# do '(' -> lx.put; (pos,break) -> E.PT; ')' -> lx.put #);
          length:: (# do 2 + E.length -> value #);
          E: ^Exp
       enter E[] -> append
       #);
     Lexem: Exp
       (# T: ^text
       enter T[]
       #);
     Name:< Lexem
       (# PT:: (# do T[] -> lx.append #);
          length:: (#do  T.length -> value #);
          label:: (# do 'name:' -> lab[] #);
          PP:: (# do label -> lx.append; T[] -> lx.append #);
       #);
     Const:< Lexem
       (# PT:: (# do T[] -> lx.append #);
          length:: (#do  T.length -> value #);
          Label:: (# do 'Const:' -> lab[] #);
          PP:: (# do Label -> lx.append; T[] -> lx.append #);
       #);
     CharObj:< Lexem
       (# PT::  (# do '\'' -> lx.put;  T[] -> lx.append; '\'' -> lx.put #);
          length:: (#do  T.length + 2 -> value #);
          label:: (# do 'Char:' -> lab[] #);
          PP:: (# do label -> lx.append; T[] -> lx.append #);
       #);     
     StringObj:< Lexem
       (# PT::< (# do '"' -> lx.put;  T[] -> lx.append; '"' -> lx.put #);
          length:: (#do  T.length + 2 -> value #);
          Label:: (# do 'String:' -> lab[] #);
          PP:: (# do label -> lx.append; T[] -> lx.append #);
       #);
     
     objectDecl,integerDecl,charDecl,StringDecl,errorDecl
     ,thisDecl,thisCoreDecl,coreDecl: ^Decl;
     
     locateWorld: @
       (# trace: (# exit false #);
          entries: [8] ^text; top,worldPos: @integer;          
          init:< (# do 0 -> top -> worldPos #);
          deComp:
            (# last,worldPosInCWD: @integer
            do (* CWD = .../beta/.../MiniSystem/.../BETAworld/.../XXX *)
               dirCh -> CWD.put;
               CWD.setPos;
               CWD.scanAll
               (# pos: @integer; N: ^text
               do pos + 1 -> pos; 
                  (if ch // '/' // dirCh then 
                      (if (top + 1 -> top) > entries.range then
                          entries.range -> entries.extend 
                      if);
                      (if pos > 1 then 
                          (last+1,pos-1) -> CWD.sub -> N[] -> entries[top][];
                          (if 'BETAworld' -> N.equalNCS then
                              top -> worldPos;
                              pos -> worldPosInCWD;
                          if)
                      if);
                      pos -> last;
                  if)
               #);
               (*  (last+1,CWD.length) -> CWD.sub -> entries[top+1][];*)
               (if trace then
                   'Entries: ' -> putline;
                   (for i: top repeat entries[i][] -> putline for);
               if);
               (if worldPos = 0 then '\n*** BETAworld not found' -> putline if); 
               (1,worldPosInCWD - 1) -> CWD.sub -> topPath[];
               topPath.copy -> path.push;
               dirCh -> topPath.put;
               topPath.copy -> pathToBetaWorld[];
               (if trace then
                   'pathToWorld: ' -> puttext; topPath[] -> putline;
               if);
               'BETAworld.xbeta' -> topPath.append;
               (if trace then
                   'Module: ' -> puttext; (last+1,CWD.length) -> CWD.sub -> putline;
                   'topPath: ' -> puttext;  topPath[] -> putline;
               if)
            #);
          CWD: ^Text;
          topPath: ^text;
          fullPath: @boolean; FN: ^text
       enter(fullpath,FN[])
       do init;
          (if fullPath then (* from miniEnv *)
              '\nFrom minienv: ' -> puttext;
              FN[] -> putline;
              FN.copy -> CWD[];
              (if false then
                  'locateWorld: ' ->puttext; CWD[] -> putline;
                  'dirC: "'->puttext; dirCh -> put; '"' -> put; newline;
              if);
              (# pos,lastDir: @integer 
              do (*CWD.setPos;*)
                 CWD.scanAll
                 (# 
                 do pos + 1 -> pos; 
                    (if ch // '/' //  dirCh then pos -> lastDir if)
                 #);
                 (* lastdir -> putint; newline;*)
                 (lastDir,CWD.length) -> CWD.delete;
                 (*CWd[] -> putline;*)
                 deComp;

                 (* deComp defines topPath = ' ...../BETAworld/BETAworld.bet',
                  * since we need to 
                  * compile from BETAworld when using compile foo.bet
                  * Here we need to compile just the module/module
                  * being executed from miniEnv
                  * We thus overwrite topPath as done below
                  *)
                 (*  FN[] -> topPath[]*)
              #)
           else
              getCurrentDir -> CWD[];
              (*'CWD: ' -> puttext; CWD[] -> putline;*)
              deComp;
          if)
       exit topPath[]
       #);
     mkModuleItemDecl:
       (# MI: ^ModuleItem;
       enter MI[]
       do MI.MD.SO.sig[] -> MI.sig[]; (* clumsy*)
          (*MI[] -> MI.MD.father[];*)
          (*'mkModuleItemDecl: ' -> putline; MI.doPT -> putline;*)
       exit MI[]
       #);
  do
     inner
  #)
