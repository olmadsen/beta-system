ORIGIN '~beta/basiclib/betaenv';
INCLUDE '../xbeta/Tree';
INCLUDE '../miniCompiler/directoryComponents'
---lib:attributes---
AbstractSyntaxTree: Tree
  (#  Module:< node
       (# SO: ^StaticObject;
          PT:: 
            (# 
            do (0,length) -> block
               (#
               do (0,break) -> SO.PT 
               #)
            #);
          length:: (# do SO.length -> value #);
          PP:: (# do 'Module' -> lx.append #);
          desc:<
            (# D: ^Items
            do inner
            exit D[]
            #);
          handleDirModules:
            (# pDirModule:<
                 (# moduleDir: ^text; (* name of direcory with BETA module *)
                    md: ^Module
                 enter moduleDir[]
                 do inner;
                 exit md[]
                 #);
               findModuleItems:
                 (# 
                 do (if trace then
                        'FindDir: find directories in:\n   ' -> puttext; 
                        path.append -> putline; 
                    if);
                    (path.append,false) -> getBETAdirectories
                    (#
                    do scan
                       (#
                       do (if not currentIsFile then
                              current[] -> addDirModuleN;
                          if)
                       #)
                    #);
                 #);
               
               dirModuleN: [4] ^text; dcTop: @integer;
               addDirModuleN:
                 (# dir: ^text
                 enter dir[]
                 do (if (dcTop + 1 -> dcTop) > dirModuleN.range then 
                        dirModuleN.range -> dirModuleN.extend;
                        dirModule.range -> dirModule.extend
                    if);
                    dir[] -> dirModuleN[dcTop][]
                 #);
               (* Perhaps save ModuleItemDecl instead?
                * Perhaps factor appendModule out of scanDir
                *)
               dirModule: [4] ^ModuleItem;
               scanDir:
                 (# currentModule: ^Module;
                    N: ^text; (* module on path to ...*)
                 do (*'ScanDir:'->putline; dctop->putint; newline;*)
                    (for i: dcTop repeat
                         (*dirModuleN[i][] -> N[] -> putline;*)
                         (* See also Checker:ModuleItem:doCheck *)
                         dirModuleN[i][] -> N[] -> pDirModule -> currentModule[];
                         (N[],currentModule[]) -> ModuleItem -> dirModule[i][];
                         dirModule[i][] -> mkModuleItemDecl -> appendModule; 
                         (if currentModule[] = none then 'currentModule none' -> putline if);
                         true -> dirModule[i].isParsed; (* eliminate *)
                         INNER;
                    for);
                 #);
               XaddModuleItems: 
                 (#
                 do (for i: dcTop repeat
                        dirModule[i][] -> mkModuleItemDecl -> appendModule
                    for)
                 #);               
               appendModule:
                 (# dcl: ^Decl 
                 enter dcl[] 
                 do (* 'AppendModule: ' -> putline; dcl.doPT -> putline; *)
                    dcl[] -> SO.OG.IS.append
                 #);                
               main,m: ^Module;
            do (if trace then
                   'HandleDirModules: '->puttext; 
                   SO.sig.doPt -> putline;
               if);
               0 -> dcTop;
               (if (dirCh->(path.append).put) -> locateWorld.CWD.equal then
                   this(Module)[] -> main[];
                   (*'Found main: ' -> putline; main.doPT -> putline*)
               if);
               
               findModuleItems;
               
               scanDir 
               (#
               do currentModule.SO.sig.id[] -> path.push;
                  (if trace then
                      'EQ:'->putline; path.append-> putline; 
                      locateWorld.CWD[] -> putline; 
                  if);
                  &currentModule.handleDirModules
                  (# pDirModule::
                       (#
                       do moduleDir[] -> this(handleDirModules).pDirModule -> md[]
                       #)
                  #) -> m[];
                  (if m[] <> none then m[] -> main[] if);
                  path.pop
               #)
            exit main[]
            #);
              
          imports: @
            (# L: [4] ^module; top: @integer;
               init:< (# do 0 -> top;(* ' imports:init ' -> puttext; *) #);
               addM:
                 (# mi: ^module
                 enter mi[]
                 do (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi[] -> L[top][];
                    (*'Add:' -> putline; mi.doPT -> putline*)
                 #);
               add:
                 (# mi: ^moduleItem
                 enter mi[]
                 do (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi.md[] -> L[top][]
                 #);               
               scan:
                 (# current: ^module
                 do (for i: top repeat
                         L[i][] -> current[]; inner
                 for)#);
               mark: scan
                 (# 
                 do (if trace then
                        current.SO.sig.doPT -> putText; ' descNo: '->putText; 
                        (current.desc).DescNo -> putint; ' ' -> put;
                    if);
                    current.mark 
                 #);
            #);
          trace: (# exit false #);
          mark: 
            (# 
            do (if trace then 'MarkImports: '->puttext; SO.sig.doPT ->putline if);
               (if not isIncluded then (* avoid circularity *)
                   true -> isIncluded; 
                   imports.mark 
               if);
            #); 
          isAdded,isIncluded: @boolean;
       enter SO[] -> append
       #);
     ModuleItem:< Decl
       (# PP:: (# do 'ModuleItem' -> lx[] #);
          PT:: (#do (pos,break) -> MD.PT #);
          isParsed: @boolean;
          MD: ^Module; (*SO: ^StaticObject - perhaps just StaticObject?*)
       enter(Name -> append,MD[]->append)
       #);
     Items:< node 
       (# PT:: 
            (# 
            do (if props[] <> none then 
                   props.PT;
                   (pos,break) -> mkbreak
               if);
               scanSons
               (# 
               do (pos,break) -> current.PT; 
                  (if not isLast then
                      (pos,break) -> mkbreak
                  if)
               #)
            #);
          PP:: (# do 'Items' -> lx.append #);

          ifBasic: BooleanValue
            (#
            do (if props[] <> none then
                   props.findBasic -> value -> isBasic                 
               if)
            #);
           localSearch:
            (# CS: ^ Text; ATd: ^Decl
            enter CS[]
            do search:
                 scanSons
                 (# I: ^Item; AT: ^Decl
                 do (*'LocalSearch: ' -> puttext; current.doPT -> putline;*)
                    current[] -> I[];
                    (if I.isDecl then
                        I[] -> AT[]; 
                        (* 'Try: ' -> puttext; AT.id[] -> putline;*)
                        (if (CS[] -> AT.sig.id.equalNCS) then
                            (* 'Found in: ' -> puttext;
                             doPT -> putline;*)
                            AT[] -> ATd[];
                            Leave search
                            (*else
                             'No match:'->puttext; AT.id[] -> putline*)
                 if)if)#)
            exit ATd[]
            #);      
          search:
            (# CS: ^ Text; org: ^Items; ATd: ^Decl; on: @integer
            enter CS[]
            do (*'OT:Search:'->puttext; CS[] -> putline;*)
               (if (CS[] -> localSearch -> ATd[]) = none then
                   (*'Items:search ' -> puttext; CS[] -> putline;*)
                   (if OT[] <> none then
                       CS[] -> OT.SearchSuperAndSig -> ATd[];
                   if);
                   (if ATd[] = none then
                       (if incl[] = none then 
                           '!!!!!Items:search:incl=none - search for: '->puttext;
                           CS[] -> putline
                        else
                           CS[] -> incl.searchInclude -> ATd[];
                       if);
                       (if ATd[] = none then
                           (if (origin[] -> org[]) <> none then
                               CS[] -> org.search -> (ATd[],on);
                               on + 1 -> on
               if)if)if)if)
            exit(ATd[],on)
            #);
           genClass:< 
            (# N: ^text; sig: ^Signature
            enter(N[],sig[])
            do inner 
            #);
          doCall:<
            (# N: ^text; LMR: @char
            enter(N[],LMR)
            do inner; 
            #);
          descNo: @integer;
          isBasic,
          isEmpty: @boolean;
          OT: ^ObjectTemplate;
          props: ^Properties;
          incl: ^Include
       #);
     Item: node 
       (# (*sig: ^Signature; (* Should be eliminated - also sig in Decl *)
          isDecl:< BooleanValue;
          isBasic:< BooleanValue(# do inner #);
          desc:<
            (# elm:< node; D: ^Items
            do inner
            exit D[]
            #);
       do inner 
       #);
     Properties:< node
       (# PT::
            (#
            do '['->lx.put;
               scanSons
               (#
               do current.pt; (if not isLast then ','->lx.put if) 
               #);
               ']'->lx.put;
            #);
          scanProps:
            (# currentProp: ^Property
            do scanSons
               (#
               do current[] -> currentProp[];
                  inner scanProps
               #)
            #);
          findBasic: booleanValue
            (#
            do scanProps
               (#
               do L:
                    (if 'basic' -> currentProp.P.T.equalNCS then
                        currentProp[] -> basicProp[];
                        basicProp.setPrimNo;
                        true -> value;
                        leave L
                    if)
               #)
            #);         
          basicProp: ^Property
       do
       #);
     Property:< node
       (# PT:: 
            (# 
            do P.pt; (if arg[] <> none then arg.PT if) 
            #);
          P: ^Lexem;
          arg: ^Properties;
          setPrimNo:
            (# V: ^Const
            do (if arg[] <> none then
                   arg.ScanSons
                   (# prp: ^Property
                   do current[] -> prp[];
                      prp.P[] -> V[];                   
                      V.T.setPos; V.T.getInt -> primNo
                   #);
               if)
            #);
          primNo: @integer;
       enter append
       #);
     Include:< Item
       (# PT:: 
            (# 
            do '%include ' -> lx.append;
               scanSons(#do current.PT; (if not isLast then ',' -> lx.put if)#)
            #);
          PP:: (# do 'include' -> lx.append #);
          encModule:
            (# m: ^node; md: ^moduleItem
            do father[] -> m[];
               L:
                 (if not (m## <= moduleItem##) then 
                     (*newline; 
                     M.doPT -> putline;*)
                     m.father[] -> m[];
                     restart L
                 if);
               m[] -> md[]
            exit md[]
            #);
          searchInclude:
            (# CS: ^Text; ATd: ^Decl
            enter CS[]
            do scanSons
               (# IV: ^Invocation; MI: ^ModuleItem
               do 'Include:search: ' -> puttext; current.doPT -> putline;
                  current[] -> IV[];
                  (if IV.ATd[] = none then 'IV.ATd=none'->putline if);
                  (if IV.ATd.desc = none then 'IV.ATd.desc=none'->putline if);
                  CS[] -> (IV.ATd.desc).localSearch -> ATd[];
                  (if ATd[] <> none then
                      (*'Found: ' -> puttext; CS[] -> puttext;
                      ' in %include: ' -> puttext; IV.doPT -> putline;*)
                      (*(if IV.ATd##
                       // ModuleItem## then 'ModuleItem' -> putline
                      if);*)
                      IV.ATd[] -> MI[]; 
                      (if not MI.MD.isAdded then
                          MI[] -> (encModule).MD.imports.add;
                          true -> MI.MD.isAdded
                      if);
                      (*IV.ATd.doPT -> putline*)
                  if)
               #)
            exit ATd[]
            #)
       #);
     Decl: Item
       (# PT::< 
            (# 
            do (*'('->lx.put; off -> lx.putint; ')'-> lx.put;*)
               inner 
            #);
          sig: ^Signature;
          off: @integer;
          isDecl:: TrueValue;
          SearchSig:
            (# CS: ^text; ATd: ^Decl
            enter CS[]
            do (* '\nAttribute:SearchSig: '->puttext; CS[] -> puttext; 
                *                '\n in: '->puttext; sig.dopT -> putline;
                *                ' of: ' -> puttext; dopt->putline;
                *                ' father: ' -> puttext; dopt->putline;
                *)
               CS[] -> sig.searchSig -> ATd[]
            exit ATd[]
            #);
          pushThis:< (# do inner #);
          loadAdr:< (# do inner #);
          load:< (# isStaticObj: @boolean enter isStaticObj do inner #);
          store:< (# do inner #);
          swapr:< (# do inner #);
       #);
     Signature:< node
       (* In xbeta, Signature have subpatterns UnarySignature, etc 
        * Consider including arguments in the Signature
        *)
       (# PT:: 
            (# 
            do scanSons
               (#do (pos,break) -> current.PT; 
                  (if not isLast then ' ' -> lx.put if)
               #);
               (*(if val[] <> none then val.PT if)*)
            #);
          PP::(# do 'Signature'-> lx.append #);
          xS: ^Lexem; (* Arguments, and fatCommas are just appended *)
          args: ^Items;
          val: ^Value;
          id: ^text;
          isKeyWord: @boolean;
          setId:
            (# 
            do ''-> id[];
               args.scanSons
               (# B: @boolean; L: ^Lexem
               do (if not B then 
                      current[] -> L[];
                      L.T[] -> id.append;
                  if);
                  not B -> B
               #);
               true -> isKeyword
            #);
          scanParameters:
            (# currentArg: ^Decl
            do scanSons
               (# isPar: @Boolean
               do
                  (if isPar then
                      current[] -> currentArg[];
                      inner scanParameters
                  if);
                  not isPar -> isPar
               #)
            #);
          scanParametersReverse:
            (# currentPar: ^Decl; first: @boolean
            do (if args[] <> none then 
                   (if isKeyword then
                       scanReverse
                       (# isPar: @boolean
                       do 
                       #)
                    else
                       true -> first;
                       args.scanReverse
                       (# 
                       do 
                          'Arg: ' -> puttext; current.doPT -> puttext; ' ' -> put;
                          current[] -> currentPar[];
                          inner scanParametersReverse;
                          false -> first
                       #);
                       newline
               if)if)
            #);
          SearchSig:
            (# CS: ^text; ATd: ^Decl; isArg: @boolean
            enter CS[]
            do (*'\Signature:SearchSig: '->puttext; CS[] -> puttext;
               ':'->put; id[] -> putline;*)
               Loop:
                 (if args[] <> none then       
                     (if not isKeyword then true -> isArg if);
                     args.scanSons
                     (# D: ^Decl
                     do (if isArg then
                            (*(if isLast and (val[] <> none) then leave Loop if);*)
                            (*current.doPT -> putline;*)
                            current[] -> D[];
                            (if CS[] -> D.sig.id.equalNCS then 
                                D[] -> atD[];
                                leave Loop
                            if);
                            (if isKeyWord then false -> isArg if)
                         else
                            true -> isArg
                        if)
                 #)if);
               Loop:
               (if val[] <> none then
                   val.scanSons
                   (# D: ^Decl
                   do current[] -> D[];
                      (if CS[] -> D.sig.id.equalNCS then 
                            D[] -> atD[];
                            leave Loop
                        if);
                   #)
               if)
            exit ATd[]
            #); 
       enter id[] -> Name -> (*S[] ->*) append
       #);     
     Value:< node
       (* A list of Decl's *)
       (# PT::
            (#
            do (if son[] <> none then 
                   ' -> ' -> lx.append;
                   scanSons
                   (# 
                   do current.PT; 
                      (if not isLast then 
                          ','-> lx.put;
                          ' '-> lx.put
                      if) 
                   #)
               if)
            #);
          PP:: (# do 'Value' -> lx.append #)
       #);
     StaticObject:< Decl
       (# OG: ^ObjectGeneration;
          PT:: 
            (# 
            do (pos,break) -> sig.PT;
               ':' -> lx.put;
               ' ' -> lx.put; '@' -> lx.put; ' ' -> lx.put; 
               (pos,break) -> OG.PT 
            #);
          length:: (# do 3 + OG.length -> value #);
          PP:: (# do 'StaticObject'-> lx.append #);
          isBasic:: (# do OG.isBasic -> value #)
       enter(sig[] -> append,OG[] -> append)
       #);
     DynamicObject:< Decl
       (# PI: ^PatternId;
          PT:: 
            (# 
            do (pos,break) -> sig.PT;
               ':' -> lx.put;
               ' ' -> lx.put; '^' -> lx.put; ' ' -> lx.put; 
               (pos,break) -> PI.PT 
            #);
          length:: (# do 3 + PI.length -> value #);
          PP:: (# do 'StaticObject'-> lx.append #)
       enter(sig[] -> append,PI[] -> append)
       #);     
     Pattern: Decl
       (# PT::< 
            (# 
            do (pos,break) -> sig.PT; 
               inner;
               ' ' -> lx.put;
               (*(pos+4,true) -> mkBreak;*)
               (pos+4,true) -> OD.PT
            #);
          setUpOrigin::
            (#
            do origin[] -> sig.setUpOrigin;
               origin[] -> OD.setupOrigin
            #);
          check:: 
            (# 
            do (*'\n>>Pattern: ' -> puttext; sig.id[] -> puttext; ':'->put;
               sig.doPT -> puttext; *)
               (* (if scope[] = none then
                *     '\nPattern:check:scope is none!'->putline;
                * if);
                *)
               (*scope[] -> sig.check;*)
               OD.IS[] -> sig.check;
               scope[] -> OD.check ;
            #);
          desc::
            (# elm:: items
            do OD.IS[] -> D[]
            #);
          isBasic:: (# do OD.IS.isBasic -> value #);
          OD: ^ObjectDesc
       #);
     UnaryPattern:< Pattern
       (# PP:: (# do 'UnaryPtn:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter (sig[]->append,OD[]->append)
       #);
     BasicUnaryPattern:< Pattern
       (# PP:: (# do 'UnaryPtn:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter (sig[]->append,OD[]->append)
       #);
     BinaryPattern:< Pattern
       (# PP:: (#do 'BinaryPtn:'-> lx.append; sig.id[]-> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[]->append,OD[]->append)
       #);
     BasicBinaryPattern:< Pattern
       (# PP:: (#do 'BasicBinaryPtn:'-> lx.append; sig.id[]-> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[]->append,OD[]->append)
       #);
     FunctionalPattern:< Pattern
       (# PP:: (# do 'FunctionalPtn:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append,OD[]->append)
       #);
     BasicFunctionalPattern:< Pattern
       (# PP:: (# do 'BasicFunctionalPtn:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append,OD[]->append)
       #);     
     KeywordPattern:< Pattern
       (# PP:: (# do 'KeywordPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #);
     BasicKeywordPattern:< Pattern
       (# PP:: (#do 'BasicKeywordPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #);     
     VirtualPattern:< Pattern
       (# PP:: (# do 'VirtualPattern:' -> lx.append; sig.id[] -> lx.append #);
          PT:: (# do ':' -> lx.put; '<' -> lx.put #);
       enter(sig[] -> append, OD[]->append)
       #);
     ObjectTemplate: item
       (# IS: ^Items;
          searchSuperAndSig:<
            (# CS: ^ Text; ATd: ^Decl
            enter CS[]
            do inner
            exit ATd[]
            #);
          genClass:< 
            (# N: ^text; sig: ^Signature
            enter(N[],sig[])
            do inner 
            #);
       #);
     ObjectGeneration:< ObjectTemplate
       (# PT:: 
            (# 
            do (pos,break) -> IV.PT;
               (if not IS.isEmpty then 
                   (pos+4,true) -> mkBreak;
                   (pos+4,true) -> IS.PT;
               if)
            #);
          PP:: (# do 'ObjectGeneration' -> lx.append #);
          searchSuperAndSig:: (* needs to be fixed*)
            (# (*CS: ^text; ATd: ^Decl
            enter CS[]*)
            do (*'OG:SearchSuperAndSig:'->putline;*)
               (if IV.ATd[] <> none then
                   (*IV.doPt -> putline;*)
                   CS[] -> (IV.ATd.desc).localSearch -> ATd[]
               if)
            #); 
          isBasic: booleanValue
            (#
            do (if IS.isEmpty then
                   IV.ATd.isBasic -> value; 
                else
                   IS.isBasic -> value
               if);
            #);          
          IV: ^Invocation;
          singularName: ^text;
       enter(IV[] -> append,IS[] -> append)
       #);
     PatternId:< Node
       (# PT:: (# do IV.PT; (if id[] <> none then id[] -> lx.append if) #);
          PP:: (#do 'PatternId'->lx.append #);
          desc:
            (# D: ^Items
            do ATd.desc -> D[]
            exit D[]
            #);
          IV: ^Invocation;
          id: ^text;
          ATd: ^Decl;
       enter IV[] -> append
       #);
     ObjectDesc:< ObjectTemplate
       (# PP:: (# do 'ObjectDesc' -> lx.append #);
          PT:: 
            (#
            do superPI.PT;
               (pos,true) -> mkBreak;
               (pos,break) -> IS.PT 
            #);
          searchSuperAndSig:: (* needs to be fixed*)
            (# P: ^pattern;(* CS: ^text; ATd: ^Decl
            enter CS[]*)
            do (*'OG:SearchSuperAndSig:'->puttext; *)
               (if father[] <> none then
                   (*father.doPT -> puttext;*)
                   (if father## <= pattern## then
                       CS[] -> (father[] -> P[]).searchSig -> ATd[]
                    else
                       '\n!!! searchSuperAndSig: father is not sub of pattern'->putline
                   if);
                   (if (ATd[] = none) and (superPI.ATd[] <> none) then
                       (* search super *)
                       CS[] -> (superPI.ATd.desc).localSearch -> ATd[]
                   if)
               if)
            #);
          isBasic: BooleanValue
            (#
            do IS.isBasic -> value
            #);
          superPI: ^PatternId;
     
       enter(superPI[] -> append,IS[] -> append)
       #);
     
     Invocation:< Item
       (* <Exp> '.' <Exp> '.' ... *)
       (# PP::(#do 'Invocation' -> lx.append #);
          PT:: 
            (#
            do scanSons
               (# E: ^Exp
               do                   
                  (if (*not isLast and *) not first then
                      current[] -> E[];
                      (*'.' *) E.dot -> lx.puttext
                  if);
                  (pos,break) -> current.PT; 
            #)#);
          isBasic: booleanValue
            (#
            do
               scanSons
               (# E: ^Exp
               do (if isLast then 
                      current[] -> E[]; E.isBasic -> value;
                  if)
               #)
            #);
          desc: (# exit ATd.desc #);
          ATd: ^Decl;
          swapr: 
            (# 
            do (if ATd[] <> none then 
                   (* none for e.g. Const *)
                   ATd.swapr 
               if) 
            #)
       #);
     Exp: node
       (# ATd: ^Decl;
          on: @integer;
          isAssign: @boolean;
          dot:< (# T: ^text do '.' -> T[]; inner exit T[] #);
          isBasic:< BooleanValue(# do inner #);
          pushThis:< (# do inner #);
          loadAdr:< (# do inner #);
          execute:< 
            (# rec: ^Exp; isStaticObj: @boolean
            enter(rec[],isStaticObj) 
            do inner 
            #);
          swapr: (# do ATd.swapr #)
       #);
     Unary:< Exp
       (# PP:: (# do 'Unary' -> lx.append #);
          PT:: (# do M.PT #);
          isBasic:: (# do ATd.isBasic -> value #);
          M: ^Name
       enter M[] -> append
       #);
     Binary:< Exp
       (# PP:: (# do 'Binary' -> lx.append #);
          PT::
            (#
            do operator.PT; ' '-> lx.put;
               argument.PT
            #);
          dot:: (# do ' ' -> T[] #);
          operator: ^Name;
          argument: ^ObjectGeneration
       enter(operator[]->append, argument[]->append)
       #);
     Function:< Exp
       (# PP:: (# do 'Function' -> lx.append #);
          PT:: 
            (# 
            do scanSons
               (#
               do current.PT; 
                  (if not isLast then ' ' -> lx.put if)
            #)#);
          F: ^Name
       enter(Name -> F[] -> append)
       #);
     KeyWord:< Exp
       (# PP:: (# do 'KeyWord' -> lx.append #);
          PT:: 
            (# first: @boolean
            do (* first element in sons is receiver - may be empty *)
               true -> first;
               scanSons
               (#
               do (pos,break) -> current.PT;
                  (if not isLast (* and not first*) then ' ' -> lx.put if);
                  false -> first
               #)
            #);
          id: ^Text
       #);
     Lexem: Exp
       (# T: ^text
       enter T[]
       #);
     Name:< Lexem
       (# PT:: (# do T[] -> lx.append #);
          PP:: (# do T[] -> lx.append #);
       #);
     Textt:< Lexem
       (# PT::< (# do '\'' -> lx.put;  T[] -> lx.append; '\'' -> lx.put #);
          PP:: (# do T[] -> lx.append #);
       #);
     Const:< Lexem
       (# PT:: (# do T[] -> lx.append #);
          PP:: (# do T[] -> lx.append #);
       #);
     path: @
       (# P: [8] ^text;
          top: @integer;
          init:< (# do 0 -> top #);
          push:
            (# dir: ^text
            enter dir[]
            do (if (top + 1 -> top) > P.range then P.range -> P.extend if);
               dir[] -> P[top][];
            #);
          pop: (# do top - 1 -> top #);
          append:
            (# pth: @text
            do (for i: top repeat 
                    P[i][] -> pth.append;
                    (if i < top then dirCh -> pth.put if)
               for)
            exit pth[]
            #)
       #);
     
     locateWorld: @
       (# trace: (# exit false #);
          entries: [8] ^text; top,worldPos: @integer;          
          init:< (# do 0 -> top -> worldPos #);
          deComp:
            (# last,worldPosInCWD: @integer
            do (* CWD = .../beta/.../MiniSystem/.../BETAworld/.../XXX *)               
               dirCh -> CWD.put;
               CWD.setPos;
               CWD.scanAll
               (# pos: @integer; N: ^text
               do pos + 1 -> pos; 
                  (if ch // '/' // dirCh then 
                      (if (top + 1 -> top) > entries.range then
                          entries.range -> entries.extend 
                      if);
                      (if pos > 1 then 
                          (last+1,pos-1) -> CWD.sub -> N[] -> entries[top][];
                          (if 'BETAworld' -> N.equalNCS then
                              top -> worldPos;
                              pos -> worldPosInCWD;
                          if)
                      if);
                      pos -> last;
                  if)
               #);
               (*  (last+1,CWD.length) -> CWD.sub -> entries[top+1][];*)
               (if trace then
                   'Entries: ' -> putline;
                   (for i: top repeat entries[i][] -> putline for);
               if);
               (if worldPos = 0 then '\n*** BETAworld not found' -> putline if); 
               (1,worldPosInCWD - 1) -> CWD.sub -> topPath[];
               topPath.copy -> path.push;
               dirCh -> topPath.put;
               topPath.copy -> pathToBetaWorld[];
               (if trace then
                   'pathToWorld: ' -> puttext; topPath[] -> putline;
               if);
               'BETAworld.xbeta' -> topPath.append;
               (if trace then
                   'Module: ' -> puttext; (last+1,CWD.length) -> CWD.sub -> putline;
                   'topPath: ' -> puttext;  topPath[] -> putline;
               if)
            #);
          CWD: ^Text;
          pathToBetaWorld,
          topPath: ^text;
          fullPath: @boolean; FN: ^text
       enter(fullpath,FN[])
       do init;
          (if fullPath then (* from miniEnv *)
           else
              getCurrentDir -> CWD[];
              (*'CWD: ' -> puttext; CWD[] -> putline;*)
              deComp;
          if)
       exit topPath[]
       #);
     mkModuleItemDecl:
       (# MI: ^ModuleItem;
       enter MI[]
       do MI.MD.SO.sig[] -> MI.sig[]; (* clumsy*)
          (*MI[] -> MI.MD.father[];*)
          (*'mkModuleItemDecl: ' -> putline; MI.doPT -> putline;*)
       exit MI[]
       #);
  do
     inner
  #)
