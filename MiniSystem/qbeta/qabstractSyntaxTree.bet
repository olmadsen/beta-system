ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qprimitives';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE '../VM/objectcode'
---lib:attributes---
printOffOn: (# exit false #);
AbstractSyntaxTree: Tree
  (# traceAlloc: @boolean;
     traceCheckQual: (# exit false #);
     reportSemErr: (# exit true #);
     reportQuaCheck: (# exit false #);
     reportNone: (# exit false #);
     verbose: @boolean;
     display:
       (# T: ^text; S: ^Node
       enter(T[],S[])
       do (if traceCheckQual then
              T[] -> puttext; ':' -> put; ' ' -> put;
              (if S[] <> none then S.doPT -> putline 
               else ' is none' -> putline if)
          if)
       #);
     displayB:
       (# T: ^text; S: ^ObjectGenerator
       enter(T[],S[])
       do (if traceCheckQual then
              T[] -> puttext; ':' -> put; ' ' -> put; 
              (if S[] <> none then
                  S.primNo -> putint; ' ' -> put;
                  (if true 
                   // S.super.isBasic then
                      (if S.IS.isEmpty then
                          'super is basisc and IS is empty' -> putline
                       else
                          'super is basisc and IS is NOT empty' -> putline
                      if)
                   // S.isBasic then
                      (if S.IS.isEmpty then
                          'is basisc and IS is empty' -> putline
                       else
                          'is basisc and IS is NOT empty' -> putline
                      if)
                   // S.IS.isEmpty then
                      'IS is empty' -> putline
                   else
                      'Not basic and IS not empty'->putline
                  if)
               else
                  'is none' -> putline;
              if)if)
       #);

     Node: TopNode
       (# vNode::< Node; 
          debug:
            (# lx: ^text
            do label -> lx[]; ':' -> lx.put;
               inner;
               lx[] -> cd.comment
            #);
          check:<
            (* check is called recursively when needed
             * Controlled by isChecked and beingChecked
             * beingChecked may be redundant!?
             * We stille need to catch loops in in patterns/objectGenerators!?
             * - As 2 patterns having each other as super!?
             *)
            (# elm:< TopNode; 
               rec: ^Exp; basicScope,argScope: ^elm; 
               isFirst: @boolean;
               wasChecked: @boolean
            enter(rec[],basicScope[],argScope[],isFirst)
            do (if not isChecked and not beingChecked then
                   true -> beingChecked -> wasChecked;
                   inner; 
                   wasChecked -> isChecked;
                   false -> beingChecked
               if)
            exit basicScope[]
            #);
          alloc:<
            (# IT: ^items
            enter IT[]
            do (if traceAlloc then doPT -> putline if); 
               inner
            #);
          semCheck:<
            (# rec: ^Node
            enter rec[]
            do inner;
               (if not noArgsCheck then
                   scanSons(# do rec[] -> current.semCheck; current[] -> rec[] #)
               if)
            #);
          gen:<
            (# gdb:< debug(# do 'gen: '->lx.puttext; inner #);
               useReturnValue: @boolean; superAdj,staticOff: @integer
            enter(useReturnValue,superAdj,staticOff)
            do gdb; inner 
            #);
          findNodeAtPos::
            (# 
            do L:
                 (if (beginPos <= pos) and (pos <= endPos) then
                     scanSons
                     (#
                     do  pos -> current.findNodeAtPos -> N[];
                        (if N[] <> none then 
                            (if trace then '>'-> put if);
                            leave L 
                        if)
                     #);
                     (if N[] = none then 
                         this(TopNode)[] -> N[]; 
                         (if trace then
                             newline; 
                             '[' -> put; beginPos -> putint; 
                             ',' -> put; endPos -> putint; ']' -> put;
                         if)
                     if)
                 if)
            #);
          doMapBCposToCharRange::
            (# bPos1,ePos1: @integer; trace: (# exit false #)
            do (if trace then
                   '\ndoMapBCposToCharRange: ' -> puttext; label -> putline; 
                   'Lsc: ' -> puttext; lsc -> putint; 
                   ' in: '->puttext;
                   beginBCP -> putint; ','->put; endBCP -> putint; newline;
               if);
               
               (if (beginBCP < lsc) and (lsc <= endBCP) then
                   (if trace then
                       'Inside: ' -> puttext;
                   if);
                   beginPos -> B; endPos -> E;
                   (if trace then 
                       B -> putint; ','->put; E -> putint; newline 
                   if);
                   L:
                     scanSons
                     (#
                     do (if true (*not current.isObjDesc*) then (* do not go into singular*)
                            lsc -> current.doMapBCposToCharRange -> (bPos1,ePos1);
                            (if bPos1 > 0 then 
                                bPos1 -> B; ePos1 -> E;
                                leave L 
                        if)if)
                     #)
               if)
            #);
          theModule::<
            (#
            do inner;
               (if md[] = none then 
                   (if father[] = none then
                       'theModule:father is none: ' -> puttext;
                    else 
                       father.theModule -> md[];                        
                   if)
               if)
            #);
          noArgsCheck: @boolean
       do inner
       #);     
     Module:< Node
       (# DI: ^DataItem;
          PT:: 
            (# 
            do (0,length) -> block
               (#
               do (0,break) -> DI.PT 
               #)
            #);
          length:: (# do DI.length -> value #);
          label:: (# do 'Module' -> lab[] #);
          PP:: (# do label -> lx.append #);
               
          (* Bindings from tree *)
          moduleName:: (# do DI.sig.id[] -> N[] #);
          getEntries:: (# do DI.getEntries -> (names[],entries[]) #);
          entity:: (# do DI.entity -> E[] #);
          theModule::(# do this(Module)[] -> MD[] #);
          isAmodule:: (# do &iModule[] -> M[]; this(Module)[] -> M.M[] #);
          getOrigin:: (# do origin[] -> org[] #);
          pathToModuleFN:: (# do pathToFN[] -> path[] #);
          innFile:: 
            (# 
            do (if F[] = none then inFile[] -> F[] else F[] -> inFile[] if) 
            #);
          pathToFN: ^Text;
          inFile: ^File;
          myDesc:: (# do desc -> OD[] #);
          desc:<
            (# D: ^Items
            do inner
            exit D[]
            #);
          kind:: (# do '/' -> ch #);
          skind:: (# do ': /' -> S[] #);
          handleDirModules:
            (# pDirModule:<
                 (# moduleDir: ^text; (* name of direcory with BETA module *)
                    md: ^Module
                 enter moduleDir[]
                 do inner;
                 exit md[]
                 #);
               findModuleItems:
                 (# 
                 do (if trace then
                        'FindDir: find directories in:\n   ' -> puttext; 
                        path.append -> putline; 
                    if);
                    (path.append,false) -> getBETAdirectories
                    (#
                    do scan
                       (#
                       do (if not currentIsFile then
                              current[] -> addDirModuleN;
                          if)
                       #)
                    #);
                 #);
               
               dirModuleN: [4] ^text; dcTop: @integer;
               addDirModuleN:
                 (# dir: ^text
                 enter dir[]
                 do (if (dcTop + 1 -> dcTop) > dirModuleN.range then 
                        dirModuleN.range -> dirModuleN.extend;
                        dirModule.range -> dirModule.extend
                    if);
                    dir[] -> dirModuleN[dcTop][]
                 #);
               (* Perhaps save ModuleItemDecl instead?
                * Perhaps factor appendModule out of scanDir
                *)
               dirModule: [4] ^ModuleItem;
               scanDir:
                 (# currentModule: ^Module;
                    N: ^text; (* module on path to ...*)
                 do (*'ScanDir:'->putline; dctop->putint; newline;*)
                    (for i: dcTop repeat
                         (*dirModuleN[i][] -> N[] -> putline;*)
                         (* See also Checker:ModuleItem:doCheck *)
                         dirModuleN[i][] -> N[] -> pDirModule -> currentModule[];
                         (N[],currentModule[]) -> ModuleItem -> dirModule[i][];
                         dirModule[i][] -> mkModuleItemDecl -> appendModule; 
                         (if currentModule[] = none then 'currentModule none' -> putline if);
                         true -> dirModule[i].isParsed; (* eliminate *)
                         INNER;
                    for);
                 #);              
               appendModule:
                 (# dcl: ^Decl 
                 enter dcl[] 
                 do (* 'AppendModule: ' -> putline; dcl.doPT -> putline; *)
                    dcl[] -> DI.OG.IS.append
                 #);                
               main,m: ^Module;
            do (if trace then
                   'HandleDirModules: '->puttext; 
                   DI.sig.doPt -> putline;
               if);
               0 -> dcTop;
               (if (dirCh->(path.append).put) -> locateWorld.CWD.equal then
                   this(Module)[] -> main[];
                   (*'Found main: ' -> putline; main.doPT -> putline*)
               if);
               
               findModuleItems;
               
               scanDir 
               (#
               do currentModule.DI.sig.id[] -> path.push;
                  (if trace then
                      'EQ:'->putline; path.append-> putline; 
                      locateWorld.CWD[] -> putline; 
                  if);
                  &currentModule.handleDirModules
                  (# pDirModule::
                       (#
                       do moduleDir[] -> this(handleDirModules).pDirModule -> md[]
                       #)
                  #) -> m[];
                  (if m[] <> none then m[] -> main[] if);
                  path.pop
               #);

            exit main[]
            #);
              
          imports: @
            (# L: [4] ^module; top: @integer;
               init:< (# do 0 -> top;(* ' imports:init ' -> puttext; *) #);
               addM: 
                 (# M: ^module; MI: ^ModuleItem
                 enter M[]
                 do (if (M.father[] -> MI[]) <> none then
                        (*'***imports.addM: ' -> puttext;
                         * M.moduleName -> putline;
                         * *)
                        MI[] -> add
                    if)
                 #);
               add:
                 (# mi: ^moduleItem
                 enter mi[]
                 do (*'Imports.add: ' -> puttext; mi.md.moduleName -> puttext;*)
                    (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi.md[] -> L[top][];
                    (if not mi.md.isChecked then 
                       (* ':check'->putline;*)
                        (none,MI.MD.origin[],MI.MD.origin[],true) 
                          -> MI.MD.check;
                        true -> MI.isChecked
                     (*else
                        newline*)
                    if);
                    addEnclosingModules
                 #);   
               addEnclosingModules:
                 (# org: ^Items; M: ^Module; MI: ^ModuleItem
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                        (if M[] <> none then
                            (*'**** AddEnclosingModule: ' -> puttext; 
                             * M.moduleName -> putline;
                             *)
                            M[] -> M.imports.addM
                    if)if)
                 #);
               scan:
                 (# current: ^module
                 do (for i: top repeat
                         L[i][] -> current[]; inner
                 for)#);
               mark: scan
                 (# 
                 do (if false then
                        current.DI.sig.doPT -> putText; ' descNo: '->putText; 
                        (current.desc).DescNo -> putint; ' ' -> put;
                    if);
                    current.mark 
                 #);
            #);
          trace: (# exit false #);
          mark: 
            (# 
            do (if false then
                   'MarkImports: '->puttext; DI.sig.doPT ->putline if);
               (if not isIncluded then (* avoid circularity *)
                   true -> isIncluded; 
                   imports.mark 
               if);
            #); 
          objDescEQ:: (# do DN -> DI.objDescEQ -> value #);
          isAdded,isIncluded: @boolean;
       enter DI[] -> append
       #);
     ModuleItem:< Decl
       (# label:: (# do 'Module' -> lab[] #);
          PP:: (# do label -> lx.append #);
          PT:: 
            (#
            do (if true then
                   '--' -> lx.puttext; sig.id[] -> lx.puttext
                else
                   (pos,break) -> MD.PT 
               if)
            #);
          length:: (# do MD.length -> value #);
          getEntries:: (# do md.getEntries -> (names[],entries[]) #);
          Entity:: (# do md.entity -> E[]#);
          kind:: (# do (if true then md.kind -> ch else '/' -> ch if)#);
          skind:: (# do MD.skind -> S[] #);
          isaModule:: (# do &iModule[] -> M[]; md[] -> M.M[] #);
          isParsed: @boolean;
          myDesc:: (# do MD.desc -> OD[] #);
          objDescEQ:: (# do DN -> MD.objDescEQ -> value #);
          
          MD: ^Module; (* perhaps DataItem? *)
       enter(Name -> append,MD[]->append)
       #);
     Items:< Scope 
       (# PT::< 
            (# 
            do (pos,length) -> block
               (#
               do (if props[] <> none then 
                      (pos,break) -> props.PT;
                      (pos,break) -> mkbreak
                  if);
                  inner PT;
                  scanSons
                  (# 
                  do (if not isFirst or (incl[] <> none) and (incl.son[] <> none) then
                         (pos,break) -> current.PT; 
                         (if not isLast then
                             (pos,true) -> mkbreak
                     if)if)
               #)#)
            #);
          length::
            (#
            do (if props[] <> none then props.length -> value if);
               scanSons(# do current.length + value -> value #)
            #);
          label:: (# do 'Items' -> lab[] #); 
          PP:: (# do label -> lx.append (* what about props?*) #);
          display:: (# do 'Items:'->putline #);
          scanDecls:
            (# currentDcl: ^decl;
            do scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if I.isDecl then
                      I[] -> currentDcl[];
                      inner scanDecls
                  if);
               #)               
            #);  
          scanAllDecls:
            (# currentDcl: ^Decl;
               superOrgOff,level: @integer
            do (if (superDesc[] <> none) and (superDesc[] <> objectDecl.desc) then
                   &superDesc.scanAllDecls
                   (#
                   do currentDcl[] -> this(scanAllDecls).currentDcl[];
                      inner scanAllDecls
                   #) -> (superOrgOff,level)
               if);
               (if sig[] <> none then
                   sig.scanArgs
                   (#
                   do currentArg[] -> this(scanAllDecls).currentDcl[];
                      inner scanAllDecls
               #)if);
               scanDecls
               (#
               do currentDcl[] -> this(scanAllDecls).currentDcl[];
                  inner scanAllDecls
               #)
            exit(superOrgOff,level) 
            #);
          collectSimple::
            (# SimpleKind: (# exit 1 #);
               PatternKind: (# exit 2 #);
               ReferenceKind: (# exit 3 #);
               RepetionKind: (# exit 4 #);
               VirtualKind: (# exit 5 #);
               off: @integer
            do scanAllDecls
               (# name: ^Text;
                  off,kind: @integer
               do '???'-> name[];
                  currentDcl.sig.ID[] -> name[];
                  currentDcl.off -> off;
                  (if off > 0 then
                      (if currentDcl.isBasic then
                          SimpleKind -> kind
                       else
                          (if currentDcl.isVirtual then
                              virtualKind -> kind
                           else
                              ReferenceKind -> kind
                          if)
                      if)
                   else
                      (* chef isIndexed -  see parser:collectSimple *)
                      patternKind -> kind
                  if);
                  'Collect: ' -> puttext; name[] -> puttext;
                  ' ' ->put; off -> putint;
                  ' ' -> put; kind -> putint; newline;
                  (name[],off,kind,currentDcl[]) -> addSimple
               #);
            #);
          getEntries:: 
            (# 
            do scanDecls(# do (currentDcl.sig.id[],currentDcl[]) -> add #)
            #);
          primNo: integerValue
            (#
            do (if props[] <> none then 
                   (if props.basicProp[] <> none then
                       props.basicProp.primNo -> value 
                    else
                       0 -> value
                   if)
               if)
            #);
          ifBasic: BooleanValue
            (#
            do (if props[] <> none then
                   (* props.findBasic must be called to define props.basicProp.primNo *)
                   props.findBasic -> value -> isBasic                 
               if)
            #);
          isBasic: @ Boolean;
          doCall:<
            (# N: ^text; LMR: @char
            enter(N[],LMR)
            do inner; 
            #);
          descNo: @integer;
          isEmpty: @boolean;
          isCore: integerValue
            (#
            do (if (props[] <> none) and (props.basicProp[] <> none) then
                   props.basicProp.coreNo  -> value
               if)
            #);
          isExternal: integerValue
            (#
            do (if (props[] <> none) and (props.basicProp[] <> none) then
                   props.basicProp.externalNo  -> value
               if)
            #);
          scanProps:
            (# current: ^Property
            do props.scanProps
               (# 
               do current[] -> This(scanProps).current[]; 
                  inner scanProps
               #)
            #);
          sig: ^Signature; (* if pattern, the signature else none *)
          OT: ^ObjectGenerator;
          props: ^Properties;
          incl: ^Include;
          doHasCode:@boolean;
          superDesc: ^Items; 
          (* Item's are appended
           * But sometimes not so clean/smart that some attributes
           * are both explicit and appended as 'incl' and others like Item's
           * are appended
           *)
       #);
     Item: Node 
       (# isDecl:< BooleanValue;
          isVirtual:< BooleanValue;
          isVirtualObject:< BooleanValue;
          isBasic:< BooleanValue(# do inner #);
          primNo:< IntegerValue(# do inner #);
          desc:<
            (# elm:< Node; D: ^Items
            do inner
            exit D[]
            #);
          getQual:<
            (# qual: ^ObjectGenerator
            do inner
            exit qual[]
            #);
          sort:: (# do this(Item)[] -> S[] #);
          hasCode:< BooleanValue;
          findNextImp::<
            (#
            do inner;
               (if impx[] <> none then
                   (if beginBCP > bcp then
                       this(Item)[] -> impx[]
                    else
                       L:
                         scanSons
                         (# 
                         do (if (bcp -> current.findNextImp -> impx[]) <> none then
                                leave L 
               if)#)if)if)
            #)
       do inner 
       #);
     Properties:< Node
       (* Properties = [Lexem[Properties],Lexem[Properties],...]
        * where Lexem[Properties] may be juts Lexem, ie no arguments
        *)
       (# Label:: (# do 'Properties' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          PT::
            (#
            do (if length > 0 then
                   '['->lx.put;
                   scanSons
                   (#
                   do (pos,break) -> current.PT; 
                      (if not isLast then ','->lx.put if) 
                   #);
                   ']'->lx.put;
               if)
            #);
          length:: (# do scanSons(#do current.length + value -> value #)#);
          scanProps:
            (# currentProp: ^Property
            do scanSons
               (#
               do current[] -> currentProp[];
                  inner scanProps
               #)
            #);
          findBasic: booleanValue
            (#
            do scanProps
               (#
               do L:
                    (if true
                     // 'basic' -> currentProp.P.T.equalNCS then
                        currentProp[] -> basicProp[];
                        basicProp.getPrimNo -> basicProp.primNo;
                        true -> value;
                        leave L
                     // 'external' -> currentProp.P.T.equalNCS then
                        currentProp[] -> basicProp[];
                        basicProp.getPrimNo -> basicProp.externalNo;
                        false -> value; (* OBS - clean-up*)
                     // 'resume' -> currentProp.P.T.equalNCS then
                        currentProp[] -> basicProp[];
                        resume_Prim -> basicProp.primNo;
                        (if resumeDecl <> none then
                            'Resume pattern: ' -> puttext; 
                            resume_prim -> putint; ' ' -> put;
                            doPT -> putline;
                         else
                            'resumeDecl none' -> putline
                        if);
                     // 'core' -> currentProp.P.T.equalNCS then
                        currentProp[] -> basicProp[];
                        basicProp.getPrimNo -> basicProp.coreNo;
                        false -> value; (* OBS - clean-up*)
                        leave L 
                     // 'globals' -> currentProp.P.T.equalNCS then
                        currentProp.arg[] -> globals[]
                     // 'interface' -> currentProp.P.T.equalNCS then
                     // 'signature' -> currentProp.P.T.equalNCS then
                    if)
               #)
            #);         
          basicProp: ^Property;
          globals: ^Properties;
          inSub: @boolean
       do
       #);
     Property:< Node
       (# Label:: (# do 'Property:' -> lab[]; P.T[] -> lab.append #);
          PP:: (# do label -> lx.append #);
          PT:: 
            (# 
            do (if P[] <> none then (pos,break) -> P.PT;  if);
               (if arg.length > 0 then (pos,break) -> arg.PT if) 
            #);
          length:: 
            (# 
            do (if P[] <> none then
                   P.length -> value
               if); 
               (if arg[] <> none then arg.length + value -> value if) 
            #);
          P: ^Lexem;
          arg: ^Properties;
          
          getPrimNo:
            (# V: ^Const; res: @integer
            do L:
                 (if arg[] <> none then
                     arg.ScanSons
                     (# prp: ^Property
                     do current[] -> prp[];
                        prp.P[] -> V[];                   
                        V.T.setPos; V.T.getInt -> res;
                        leave L
                     #);
                 if)
            exit res
            #);
          primNo,coreNo,externalNo: @integer; (* clean-up here *)
       enter P[] -> append
       #);
     Include:< Item
       (# PT:: 
            (# 
            do '%include ' -> lx.append;
               scanSons
               (#do (pos,break) -> current.PT; 
                  (if not isLast then ',' -> lx.put if)#)
            #);
          length:: 
            (#
            do 9 -> value;
               scanSons(# do current.length + 1 + value -> value #)
            #);
          Label:: (# do 'Include' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          encModule:
            (# m: ^Node; md: ^moduleItem
            do father[] -> m[];
               L:
                 (if not (m## <= moduleItem##) then 
                     (*newline; 
                     M.doPT -> putline;*)
                     m.father[] -> m[];
                     restart L
                 if);
               m[] -> md[]
            exit md[]
            #);

       #);
     Decl: Item
       (# PT::< 
            (# 
            do (if printOffOn then
                   '('->lx.put; off -> lx.putint; ')'-> lx.put;
               if);
               inner 
            #);
          sig: ^Signature;
          off: @integer;
          isDecl:: TrueValue;
          isPatternDecl:< BooleanValue;
          isInner:< 
            (# basicScope: ^items; args: ^Arguments enter(basicScope[],args[]) do inner #);
          checkVirtualArgs:
            (* Similar to checher::Pattern:check:setImplSuper
             * Should be unified
             *)
            (# aArgs: [6] ^ObjectGenerator; top: @integer;
               E: ^Exp
            enter E[]
            do L: 
                 (if not isBasic and (sig[] <> none) then
                     E.args.scanArgs
                     (#
                     do (if (top + 1 -> top) > aArgs.range then
                            aArgs.range -> aArgs.extend
                        if);
                        current[] -> aargs[top][]
                     #);
                     (if sig.args[] <> none then 
                         sig.args.scanArgs
                         (# i: @integer; OI: ^ObjectInvocation; E: ^Exp
                         do i + 1 -> i;
                            (if i > top then
                                (*  '\n *** Too many actual arguments' -> putline;
                                 E.dopt -> putline;
                                 sig.doPT -> putline;*)
                                leave L
                            if);
                            HandleVirtual:
                              (if current.isVirtual then
                                  (* 'FormalArg: ' -> puttext; current.doPT -> putline;
                                   * 'ActualArg: ' -> puttext;
                                   * aArgs[i].label -> puttext; ' ' -> put;
                                   * aArgs[i].doPT -> putline; *)
                                  (if aArgs[i].super.isEmpty then
                                      (* Implicit super *)
                                      (*'*** super:no:sons: ' -> puttext;
                                       aArgs[i].doPP -> putline;*)
                                   else
                                      (* Exlicit super
                                       *    foo{...}
                                       * Must check that foo is sub of virtual qual
                                       *)
                                      (*'*** super:Has:sons: ' -> puttext;*)
                                      (if aArgs[i].IS.isEmpty then
                                          (* ' IS empty: ' -> puttext;
                                           * current.doPT -> putline;
                                           * aArgs[i].doPT -> putline; *)
                                          L:
                                            aArgs[i].super.scanSons
                                          (# do current[] -> E[]; leave L #);
                                          (if E## = ObjectInvocation## then
                                              (*'Try: ' -> puttext; E.doPT -> putline;*)
                                              E[] -> OI[];
                                              (if (1 -> OI.ptnId.T.inxGet) = '#' then
                                                  (*'Checker:got: ' -> puttext;
                                                  OI.ptnId.doPT -> putline;*)
                                                  leave HandleVirtual
                                              if)
                                          if);
                                      if);
                                      aArgs[i][] -> mkObjectGenerator -> aArgs[i][];
                                  if);
                                  current[] -> aArgs[i].super.ATd[];
                                  1 -> aArgs[i].super.pn;
                                  true -> aArgs[i].super.isImplSuper;
                                  (* This seems wrong - check setmplSuper
                                   * where it seems we are testing for an
                                   * empty IS of the declaration
                                   *)
                                  (if not aArgs[i].IS.isEmpty then
                                      true -> aArgs[i].super.isSingularImplSuper;
                                      (*' isSingularImplSuper=T ' -> puttext;*)
                                   else
                                      (* ' CatImplSuper=T ' -> puttext;*)
                                  if);                                
                                  (*newline;*)
                                  (*aArgs[i].adjustON;*)
                              if)
                 #)if)if)
            #);
          checkQual:<
            (# lOG: ^ObjectGenerator (* PatternId *);
               isAssign: @boolean
            enter(lOG[],isAssign)
            do inner 
            #);          
          checkActualArgs:<
            (# actualArgs: ^Arguments; 
            enter actualArgs[]
            do inner
            #);
          handleArgs:< (# E: ^Exp enter E[] do inner #);
          pushThis:< 
            (# gdb:< debug(# do 'pushThis: '->lx.puttext; inner #);
            do inner
            #);
          loadArgs:< 
            (# gdb:< debug(# do 'loadArgs: '->lx.puttext; inner #);
               E: ^Exp; superAdj: @integer  
            enter(E[],superAdj)
            do gdb; inner 
            #);
          invoke:< 
            (# gdb:< debug(# do 'load: '->lx.puttext; inner #);
               rec,E: ^Exp; useReturnValue: @boolean; staticOff: @integer
            enter(rec[],E[],useReturnValue,staticOff)
            do gdb; inner 
            #);          
          isCore:< integerValue(# do inner #);
          store:< (# noSwap: @boolean enter noSwap do inner #);
          popReturn:< (# do inner #);
       #);
     Scope: Node
       (# display:<
            (# org: ^Scope
            do '>>>Scope:' -> puttext; inner;
               doP -> putline;
               (if (origin[] -> org[]) <> none then org.display if)
            #);
          localSearch:<
            (# CS: ^ Text; trySig: @boolean; ATd: ^Decl; pn: @integer
            enter(CS[],trySig)
            do(* 'localSearch: ' -> puttext; CS[] -> puttext;
               ' in: ' -> puttext; doP -> putline; *)
               inner               
            exit(ATd[],pn)
            #);
          search:<
            (# CS: ^ Text; isFirst: @boolean; 
               ATd: ^Decl; on,pn: @integer
            enter(CS[],isFirst)
            do (*'Search: ' -> puttext; CS[] -> puttext;
               ' in: ' -> puttext; doPP -> putline;*)
               inner;
            exit(ATd[],on,pn)
            #); 
       #);
     Signature:< Scope
       (* In xbeta, Signature have subpatterns UnarySignature, etc *)
       (# PT:: 
            (# 
            do (if type[] <> none then
                   (pos,break) -> type.PT;
                   (if val[] <> none then val.PT if)
                else
                   scanSons
                   (#do (pos,break) -> current.PT; 
                      (if not isLast then ' ' -> lx.put if)
                   #);
                      (*(if val[] <> none then val.PT if)*)
               if)
            #);
          length:: 
            (# 
            do (if type[] <> none then
                   type.length -> value;
                   (if args[] <> none then value + args.length -> value if);
                   (if val[] <> none then val.length +value -> value if);
                else
                   scanSons(#do current.length + value -> value #)
               if)
            #);
          Label:: (# do 'Signature' -> lab[] #);
          PP::(# do Label -> lx.append #);
          display:: (# do 'Signature:'->putline #);
          type: ^SigType;
          SigType: Node (# id: ^text enter id[] do id[] -> name -> append #);
          Unary:< SigType
            (# Label:: (# do 'UnaryPtn' -> lab[] #);
               PT:: (# do id[] -> lx.puttext #);
            #);
          Binary:< SigType
            (# label :: (# do 'Binary' -> lab[] #);
               PT:: (# do id[] -> lx.puttext; ' ' -> lx.put; args.PT #);
            #);
          Function:< SigType
            (# label:: (# do 'Function' -> lx[] #);
               PT:: (# do id[] -> lx.puttext; args.PT #)
            #);
          KeyWord:< SigType
            (# label :: (# do 'KeyWord' -> lab[] #);
               PT:: (#do args.PT #);
            #);
          args: ^Arguments;
          val: ^Value;
          id: ^text; (* should be a NAme *)
          isKeyWord: @boolean;
          init:
            (# 
            enter(id[],args[],isKeyWord)
            do (if not isKeyWord then
                   id[] -> Name -> Append;
                   (if args[] <> none then args[] -> append if)
                else 
                   true -> args.isKeyword;
                   this(Signature)[] -> args.father[]
                if);
            #);
          setId:
            (# 
            do ''-> id[];
               args.scanSons
               (# B: @boolean; L: ^Lexem
               do (if not B then 
                      current[] -> L[];
                      L.T[] -> id.append;
                  if);
                  not B -> B
               #);
            #);
          hasVirtualArgs: BooleanValue
            (#
            do (* 'Signature:hasVirtualArgs: '->puttext; doPT -> putline;*)
               (if args[] <> none then
                   args.hasVirtualArgs -> value
            if)#);
          scanArgs:
            (# currentArg: ^Decl
            do (if args[] <> none then
                   args.scanArgs(# do current[] -> currentArg[]; inner scanArgs #)
               if)
            #);
          scanArgsReverse:
            (# currentPar: ^Decl; first: @boolean
            do (if args[] <> none then 
                   args.scanArgsReverse
                   (#do current[] -> currentPar[]; inner scanArgsReverse #)
               if)
            #);
          getQual:<
            (# qual: ^objectGenerator
            do inner
            exit qual[]
            #);          
       enter(init) 
          (* OBS! (init[with only enter id[]],isKeyWord) does not work 
           * Perhaps compiler error!?
           *)
       #);     
     Sig_Generator:
       (# id: ^Text; args: ^Arguments; isKeyword: @boolean; sig: ^Signature
       enter(id[],args[],isKeyWord)
       do (id[],args[],isKeyWord) -> Signature -> sig[];
          inner;
       exit sig[]
       #);
     UnarySigGen: Sig_Generator(# do id[] -> sig.Unary -> sig.type[] #);
     FunctionSigGen: Sig_Generator(# do id[] -> sig.Function -> sig.type[] #);
     KeyWordSigGen: Sig_Generator(# do id[] -> sig.KeyWord -> sig.type[] #);
     BinarySigGen: Sig_Generator(# do id[] -> sig.Binary -> sig.type[] #);     
     Arguments:< Node
       (# elm:< Item;
          PT:: 
            (# 
            do (if true
                // isBinary then 
                   scanSons(# do (pos,break) -> current.PT #);
                // isKeyWord then 
                   scanSons
                   (# 
                   do (pos,break) -> current.PT; (if not isLast then ' ' -> lx.put if) 
                   #)
                // isFunction then 
                   '(' -> lx.put;
                    scanSons
                   (# 
                   do (pos,break) -> current.PT; (if not isLast then ',' -> lx.put if) 
                   #);
                   ')' -> lx.put
                else
                   (* unary *) 
                   scanSons(# do (pos,break) -> current.PT #);
               if)
            #);
          length:: (# do scanSons(# do current.length + 1 -> value #)#);
          Label:: (# do 'Arguments' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          isBinary,isKeyWord,isFunction: @boolean;
          scanArgs:
            (# current: ^Elm; isLast: @boolean
            do (if isKeyWord then
                   scanSons
                   (# isArg: @boolean
                   do (if isArg then
                          current[] -> this(scanArgs).current[]; 
                          isLast -> this(scanArgs).isLast;
                          inner scanArgs
                      if);
                      not isArg -> isArg
                   #)
                else
                   scanSons
                   (# do current[] -> this(scanArgs).current[]; 
                      isLast -> this(scanArgs).isLast;
                      inner scanArgs #)
               if)
            #);
          scanArgsReverse:
            (# current: ^Decl; first: @boolean
            do (if isKeyword then 
                   scanReverse
                   (# isPar: @boolean
                   do not isPar -> isPar;
                      (if isPar then
                          current[] -> this (scanArgsReverse).current[];
                          inner scanArgsReverse;
                      if);
                   #)
                else
                   true -> first;
                   scanReverse
                   (# 
                   do (*'Arg: ' -> puttext; 
                       * current.doPT -> puttext; ' ' -> put;
                       *)
                      current[] -> this (scanArgsReverse).current[];
                      inner scanArgsReverse;
                      false -> first
                   #);
                   (*newline*)
               if)
            #);
          hasVirtualArgs: BooleanValue
            (#
            do (*'Arguments:hasVirtualArgs:' -> puttext; dopt -> putline;*)
               L:
                 scanArgs
                 (# D: ^Decl 
                 do current[] -> D[];
                    (*'HasVirtualArgs: ' -> puttext; D.doPT -> putline;*)
                    (if D.isVirtual then
                        true -> value;
                        leave L
                    if)
                 #)
            #)
       enter isKeyword
       #);
     Value:< Node
       (* A list of Decl's *)
       (# PT::
            (#
            do (if son[] <> none then 
                   ' -> ' -> lx.append;
                   scanSons
                   (# 
                   do (pos,break) -> current.PT; 
                      (if not isLast then 
                          ','-> lx.put;
                          ' '-> lx.put
                      if) 
                   #)
               if)
            #);
          length:: 
            (# 
            do 4 -> value;
               scanSons(# do current.length + value -> value #)
            #);
          Label:: (# do 'Value' -> lab[] #);
          PP:: (# do Label -> lx.append #)
       #);
     DataItem:< Decl
       (# PT:: 
            (# 
            do (pos,break) -> sig.PT;
               ':' -> lx.put;
               ' ' -> lx.put;
               (if isConst then
                   '=' -> lx.put
                else
                   '?' -> lx.put
               if);
               ' ' -> lx.put; 
               (pos,break) -> OG.PT 
            #);
          length:: (# do sig.length + 4 + OG.length -> value #);
          Label:: 
            (# 
            do (if isConst then
                   'ConsRef' -> lab[] 
                else
                   'VarRef' -> lab[] 
               if)
            #);
          PP:: (# do Label -> lx.append #);
          getEntries:: (# do OG.getEntries -> (names[],entries[]) #);
          entity:: (# do OG[] -> E[] #);
          isBasic:: (#do OG.isBasic -> value #);
          skind:: 
            (# 
            do (if isConst then ': @' -> S[] else ': ^' -> S[] if)
            #);
          OG: ^ObjectGenerator;
          isConst: @boolean
       enter(isConst,sig[] -> append,OG[] -> append)
       #);

     plainPtn: (# exit 0#);
     virtualPtn: (# exit 1 #);
     furtherPtn: (# exit 2 #);
     finalPtn: (# exit 3 #);
     Pattern:< Decl
       (# label::< (# do 'pattern' -> lab[]; inner #);
          PP:: (# do label -> lx.append #);
          PT::< 
            (# 
            do (pos,break) -> sig.PT; ':' -> lx.put;
               (if ptnKind
                // virtualPtn then '<' -> lx.put
                // furtherPtn then ':' -> lx.put; '<' -> lx.put
                // finalPtn then ':' -> lx.put
               if);
               inner;
               ' ' -> lx.put;
               (pos,break) -> OD.PT
            #);
          length:: (# do sig.length + 3 + OD.length -> value #);
          ptnKind: @integer;
          isBasicPtn: @boolean;

          isBasic:: (# do OD.IS.isBasic -> value #);
          primNo:: 
            (#
            do (if OD.IS.props[] <> none then 
                   (if  OD.IS.props.basicProp[] <> none then
                       OD.IS.props.basicProp.primNo -> value 
                    else
                       0 -> value
                   if)
               if)
            #);
          isCore:: (#do OD.IS.isCore -> value #);
          scanArgs:
            (# current: ^Decl; superPtn: ^Pattern
            do 
               (if (OD.super <> none) and
                   not OD.super.lastHasActualArgs and
                   (OD.super.ATd[] <> none )then
                   &(OD.super.ATd[]->superPtn[]).scanArgs
                   (# do current[] -> this(scanArgs).current[]; inner scanArgs #)
               if);
               sig.scanArgs(# do currentArg[] -> current[] ;inner scanArgs #);
            #);
          OD: ^ObjectGenerator
       enter (sig[]->append,OD[]->append)
       #);
     ObjectGenerator:< item
       (# label:: (# do 'ObjectGenerator' -> lab[] #); 
          PP:: (# do label -> lx.append #);
          PT:: 
            (# ind: @integer
            do (pos,break) -> super.PT;
               (if (lx.length > 0) or (super.length > 0) then 
                   (* lx.length = 0 -> do not indent first line 
                    * unless super.length > 0
                    *)
                   4 -> ind 
               if);
               (if not IS.isEmpty then 
                   (pos + ind,true) -> mkBreak;
                   (pos + ind, length) -> block
                   (#
                   do (pos,true) -> IS.PT;
                   #);
               if)
            #);
          length :: (# do super.length + IS.length -> value #);
          isBasic: booleanValue
            (#
            do (if IS.isEmpty then
                   (if super.ATd[] <> none then
                       super.ATd.isBasic -> value
                   if); 
                else
                   IS.isBasic -> value
               if);
            #); 
          primNo:: 
            (# 
            do (if (super.primNo -> value) = 0 then
                   IS.primNo -> value
               if)
            #);
          isSingular: BooleanValue(# do sig[] = none -> value#);
          scanActualArgs:
            (* all actual args in superchain and main 
             * Rather complicated: should be scanVirtualBindings
             * In arguments and subpatterns
             * Must be a list in each pattern keepimng track of bindings
             * Like the omne for VDT - start by copying from super
             * Then update for each binidng in arguments and main
             *)
            (# current: ^ObjectGenerator; OI: ^ObjectInvocation
            do (if super[]  <> none then
                   super.scanSons(# do current[] -> OI[] #);
                   OI.args.scanArgs
                   (#
                   do current[] -> this(scanActualArgs).current[];
                      inner scanActualArgs
                   #)
               if)
            #);
          getEntries:: (# do IS.getEntries -> (names[],entries[]) #);
          entity:: (# do IS[] -> E[] #);
          desc:: 
            (# 
            do (if IS.isEmpty and not hasVirtualArgs then 
                   super.desc -> D[]
                else
                   this(ObjectGenerator).IS[] -> D[]
               if)
            #);
          hasVirtualArgs: BooleanValue(# do super.hasVirtualArgs -> value #);
          collectSimple:: (# do addSimple## -> IS.collectSimple #);
          genClass:< 
            (# N: ^text; sig: ^Signature; super: ^Invocation
            enter(N[],sig[],super[])
            do inner 
            #);
          hasItems: BooleanValue(#do not IS.isEmpty -> value #);
          OGid:
            (# T: ^text
            do (if sig[] <> none then 
                   sig.ID.copy -> T[]
                else 
                   (if singularName[] <> none then
                       singularName.copy -> T[]
                    else
                       (if super.ATd[] = none then 
                           '' -> T[]
                        else
                           Super.ATd.sig.id.copy -> T[]
                       if);
                       '#S#' -> T.append;
                       IS.descNo -> T.putint;
               if)if);
            exit T[]
            #);
          super: ^Invocation;
          IS: ^Items;
          sig: ^Signature; (* Signature if part of Pattern - none otherwise *)
          singularName: ^text;
       enter(super[] -> append,IS[] -> append)
       #);
     Invocation:< Apl
       (* <Exp> '.' <Exp> '.' ... *)
       (# label:: (# do 'Invocation' -> lab[] #);
          PP::(#do label -> lx.append #);
          PT:: 
            (#
            do scanSons
               (# E: ^Exp
               do                   
                  (if (*not isLast and *) not isFirst then
                      current[] -> E[];
                      (*'.' *) E.dot -> lx.puttext
                  if);
                  (pos,break) -> current.PT; 
            #)#);
          length:: (# do scanSons(#do current.length + value -> value #)#);
          last: 
            (# E: ^Exp
            do scanSons
               (# 
               do (if isLast then 
                      current[] -> E[]
                  if)
               #);
            exit E[]
            #);               
          isBasic: booleanValue
            (#
            do scanSons
               (# E: ^Exp
               do (if isLast then 
                      current[] -> E[]; E.isBasic -> value;
                  if)
               #);
            #);
          primNo: IntegerValue
            (#
            do scanSons
               (# E: ^Exp
               do (if isLast then
                      current[] -> E[]; 
                      (if E.ATD[] <> none then E.ATd.primNo-> value if);
                  if)
               #);
            #);
          desc: 
            (# D: ^Items
            do (if ATd[] = none then
                   'Invocation:desc:ATd is none: ' -> puttext; 
                   primNo -> putint; newline;
                   doPT -> putline; '---'->putline;
                   doPP -> putline; '---'->putline;
                   father.father.doPT -> putline
                else
                   ATd.desc -> D[]
               if)
            exit D[]
            #);
          hasVirtualArgs: BooleanValue
            (#
            do (*'Invocation:hasVirtualArguments: ' -> puttext; dopt -> putline;*)
               L:
                 scanSons
                 (# E: ^Exp 
                 do current[] -> E[]; 
                    (*(if E.ATd[] = none then 'ATd is none' -> putline if);*)
                    (if (E.ATd[] <> none) and (E.ATd.sig.hasVirtualArgs -> value) then
                        leave L
                 if)#)
            #);
          lastHasActualArgs: BooleanValue
            (# lastE: ^Exp
            do ((last -> lastE[]).args[] <> none) and (lastE.args.length > 0) -> value
            #)
       #);
     Apl: Node
       (# PT::< 
            (# 
            do inner
            #);
          ATd: ^Decl;
          isEmpty: @boolean;
          on,pn: @integer;
          lgth: @integer; (* length of this invocation 
                             * foo  , length = 1
                             * R.foo, length = 2
                             * A + B, length = 2
                             * etc
                             *)
          isImplSuper,  (* as in V ::< { ... } *)
          isSingularImplSuper (* where super is as in V:< foo{...}
                                   * and not as in V: < A *)
          : @boolean; 
          isThisBlockLevel: BooleanValue
            (#
            do (lgth <= 1) and (on = 0) -> value
            #);
          getQual:<
             (# qual: ^ObjectGenerator 
             do inner;
                (if qual[] = none then
                   (if ATd[] <> none then
                       ATd.getQual -> qual[]
                    (*else apparantly none if empty super??
                       'Apl:getQual:ATd is none '->putline;
                       doPT -> putline*)
               if)if)
             exit qual[]                 
             #);
          isNameApl:: (# do this(Apl)[] -> NA[] #);
          getDeclModule::
            (# d: ^Decl;
               item: ^ModuleItem
            do (if ATd[] <> none then
                   ATd.theiModule -> to[]; 
                   ATd[] -> d[]; 
                   (if d.sort <> none then
                       (if d## <= ModuleItem## then
                           (*'MI: ' -> puttext; d.IT.doPT -> putline;*)
                           (*d.IT[] -> item[];*)
                           d[] -> item[];
                           &iModule[] -> to[];
                           item.md[] -> to.M[]; 
                        else
                           ATd[] -> dclx[]
                       if)
                    else
                       '\n****NameApl:getDeclModule:sort is none'->putline
                   if)
                else
                   (if this(node)## <= lexem## then
                       father.getDeclModule -> (to[],dclx[])
                    else
                       '\n****NameApl:getDeclModule:dcl is none'->putline;
                       doPP -> putline;
               if)if)
            #)
       #);
     Exp: Apl
       (# dot:< (# T: ^text do '.' -> T[]; inner exit T[] #);
          (*isBasic:< BooleanValue(# do inner #);*)
          isBasic: BooleanValue
            (# do (if ATd[] <> none then  ATd.isBasic -> value if) #);
          desc: (# D: ^Items do ATd.desc -> D[] exit D[] #);
          pushThis:< 
            (# gdb:< debug(# do 'pushThis: '->lx.puttext; inner #);
            do gdb; inner 
            #);
          loadOrigin:< 
            (# gdb:< debug(# do 'loadOrigin: '->lx.puttext; inner #);
               superAdj: @integer; rec,E: ^Exp
            enter superAdj 
            do gdb; 
               this(Exp)[] -> E[] -> rec[];
               inner 
            exit(rec[],E[])
            #);
          loadArgs:< 
            (# gdb:< debug(# do 'loadArgs: '->lx.puttext; inner #);
               superAdj: @integer
            enter superAdj 
            do gdb; inner 
            #);
          invoke:< 
            (# gdb:< debug(# do 'invoke: '->lx.puttext; inner #);
               rec,E: ^Exp; useReturnValue: @boolean; staticOff: @integer
            enter(rec[],E[],useReturnValue,staticOff)
            do gdb; inner 
            #);
          args: ^Arguments;
       #);
     ObjectInvocation:< Exp
       (# PP:: (# do label -> lx.append #);
          PT:: (# do type.PT  #);
          length:: (# do type.length  -> value #);
          label:: (# do type.label -> lab[] #);
          dot:: (# do type.dot -> T[] #);
          ptnId: ^Name;
          (*args: ^Arguments; currently in Exp - elim*)
          type: ^InvType;
          InvType: Node(# dot:< (# T: ^text do '.' -> T[]; inner exit T[] #) #);
          Unary: InvType 
            (# Label:: (# do 'Unary' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT:: (# do (pos,break) -> ptnId.PT; (pos,break) -> args.PT #);
               length:: (# do ptnId.length + args.length -> value #);
            #);
          Binary: InvType
            (# Label:: (# do 'Binary' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT::
                 (#
                 do (pos,break) -> ptnId.PT; ' '-> lx.put;
                    (pos,break) -> args.pt
                 #);
               length:: (# do ptnId.length + 1 + args.length -> value #);
               dot:: (# do ' ' -> T[] #);
            #);
          Function: InvType
            (# label:: (# do 'Function' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT:: 
                 (# 
                 do (pos,break) -> ptnId.PT; (pos,break) -> args.PT #);
               length:: 
                 (# do scanSons(# do current.length + value -> value #)#);
            #);
          KeyWord: InvType
            (#Label:: (# do 'KeyWord' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT:: 
                 (# 
                 do (* first element in sons is receiver - may be empty *)
                    (pos,break) -> args.PT
                    (*
                    args.scanSons
                    (#
                    do (pos,break) -> current.PT;
                       (if not isLast then ' ' -> lx.put if);
                    #)*)
                 #);
               length:: 
                 (# do scanSons(# do current.length + value -> value #)#);
            #);
       enter(name -> ptnId[] -> append,args[] -> append)
       #);
     OI_Generator:
       (# ptnId: ^Text;
          args: ^Arguments;
          OI: ^ObjectInvocation
       enter(ptnId[],args[])
       do (ptnId[],args[]) -> ObjectInvocation -> OI[];
          inner
       exit OI[]
       #);
     UnaryGen: OI_Generator(#do OI.unary -> OI.type[] #);
     BinaryGen: OI_Generator(# do OI.Binary -> OI.type[] #);
     FunctionGen: OI_Generator(# do OI.Function -> OI.type[] #);
     KeyWordGen:  OI_Generator(# do OI.KeyWord -> OI.type[] #);

     BracketedExp:< Exp
       (# Label:: (# do 'BracketedExp' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          PT:: (# do '(' -> lx.put; (pos,break) -> IV.PT; ')' -> lx.put #);
          length:: (# do 2 + IV.length -> value #);
          IV: ^Invocation; 
       enter IV[] -> append
       #);
     Lexem: Exp
       (# T: ^text
       enter T[]
       #);
     Name:< Lexem
       (# PT:: 
            (# 
            do (if printOffOn then
                   '(' -> lx.put; on -> lx.putint; ')' -> lx.put 
               if);
               T[] -> lx.append 
            #);
          length:: (#do  T.length -> value #);
          label:: (# do 'name:' -> lab[] #);
          PP:: (# do label -> lx.append; T[] -> lx.append #);
       #);
     Const:< Lexem
       (# PT:: (# do T[] -> lx.append #);
          length:: (#do  T.length -> value #);
          Label:: (# do 'Const:' -> lab[] #);
          PP:: (# do Label -> lx.append; T[] -> lx.append #);
       #);
     CharObj:< Lexem
       (# PT::  (# do '\'' -> lx.put;  T[] -> lx.append; '\'' -> lx.put #);
          length:: (#do  T.length + 2 -> value #);
          label:: (# do 'Char:' -> lab[] #);
          PP:: 
            (# 
            do label -> lx.append; 
               '\''->lx.put; T[] -> lx.append; '\'' ->lx.put; #);
       #);     
     StringObj:< Lexem
       (# PT::< (# do '"' -> lx.put;  T[] -> lx.append; '"' -> lx.put #);
          length:: (#do  T.length + 2 -> value #);
          Label:: (# do 'String:' -> lab[] #);
          PP:: (# do label -> lx.append; T[] -> lx.append #);
       #);
     mkObjectGenerator:
       (# Itm: ^Item;
          itmFather: ^Arguments;
          IV: ^Invocation;
          IT: ^Items;
          OG,OGx: ^ObjectGenerator;              
       enter Itm[]
       do (*'mkOG: ' -> putline; Itm.doPP -> putline;*)
          Itm.father[] -> ItmFather[];
          
          (*'Father:'->putline; itmFather.doPP -> putline;*)
          
          Invocation -> IV[];
          true -> IV.isEmpty;
          Items -> IT[];
          Properties -> IT.props[];
          Include -> IT.incl[] -> IT.append;
          Itm[] -> IT.append;
          (IV[],IT[]) -> ObjectGenerator -> OG[] ;

          ReplaceNode:
            (* This code should be a general op in compiler_IF: replaceNode *)
            itmFather.scanSons
            (# pred: ^Node
            do (*':'->put;current.doPT -> putline;*)
               (if current[] = Itm[] then (* 'Found'->putline;*)
                   (if pred[] = none then
                       (* 'mkObjectGenerator: pred is none ' ->putline;
                        * itmFather.doPT -> putline;
                        * Itm.doPT -> putline;*)
                       OG[] -> itmFather.son[];
                    else                       
                       OG[] -> pred.next[];                      
                   if);
                   current.next[] -> OG.next[];
                   none -> Itm.next[];
                   leave ReplaceNode                  
               if);
               current[] -> pred[]
            #);
          itmFather.father.father.father[] -> OGx[];
          OGx.IS[] -> OG.setUpOrigin;
          (*OG.doPP -> putline; itmFather.doPP -> putline*)
       exit OG[]
       #);
     
     objectDecl,noneDecl,integerDecl,charDecl,booleanDecl,StringDecl,errorDecl
     ,thisDecl,thisCoreDecl,coreDecl,resumeDecl,ifThenDecl: ^Decl;
     
     locateWorld: @
       (# trace: (# exit false #);
          entries: [8] ^text; top,worldPos: @integer;          
          init:< (# do 0 -> top -> worldPos #);
          deComp:
            (# last,worldPosInCWD: @integer
            do (* CWD = .../beta/.../MiniSystem/.../BETAworld/.../XXX *)
               dirCh -> CWD.put;
               CWD.setPos;
               CWD.scanAll
               (# pos: @integer; N: ^text
               do pos + 1 -> pos; 
                  (if ch // '/' // dirCh then 
                      (if (top + 1 -> top) > entries.range then
                          entries.range -> entries.extend 
                      if);
                      (if pos > 1 then 
                          (last+1,pos-1) -> CWD.sub -> N[] -> entries[top][];
                          (if 'BETAworld' -> N.equalNCS then
                              top -> worldPos;
                              pos -> worldPosInCWD;
                          if)
                      if);
                      pos -> last;
                  if)
               #);
               (*  (last+1,CWD.length) -> CWD.sub -> entries[top+1][];*)
               (if trace then
                   'Entries: ' -> putline;
                   (for i: top repeat entries[i][] -> putline for);
               if);
               (if worldPos = 0 then '\n*** BETAworld not found' -> putline if); 
               (1,worldPosInCWD - 1) -> CWD.sub -> topPath[];
               topPath.copy -> path.push;
               dirCh -> topPath.put;
               topPath.copy -> pathToBetaWorld[];
               (if trace then
                   'pathToWorld: ' -> puttext; topPath[] -> putline;
               if);
               'BETAworld.xbeta' -> topPath.append;
               (if trace then
                   'Module: ' -> puttext; (last+1,CWD.length) -> CWD.sub -> putline;
                   'topPath: ' -> puttext;  topPath[] -> putline;
               if)
            #);
          CWD: ^Text;
          topPath: ^text;
          fullPath: @boolean; FN: ^text
       enter(fullpath,FN[])
       do init;
          (if fullPath then (* from miniEnv *)
              '\nFrom minienv: ' -> puttext;
              FN[] -> putline;
              FN.copy -> CWD[];
              (if false then
                  'locateWorld: ' ->puttext; CWD[] -> putline;
                  'dirC: "'->puttext; dirCh -> put; '"' -> put; newline;
              if);
              (# pos,lastDir: @integer 
              do (*CWD.setPos;*)
                 CWD.scanAll
                 (# 
                 do pos + 1 -> pos; 
                    (if ch // '/' //  dirCh then pos -> lastDir if)
                 #);
                 (* lastdir -> putint; newline;*)
                 (lastDir,CWD.length) -> CWD.delete;
                 (*CWd[] -> putline;*)
                 deComp;

                 (* deComp defines topPath = ' ...../BETAworld/BETAworld.bet',
                  * since we need to 
                  * compile from BETAworld when using compile foo.bet
                  * Here we need to compile just the module/module
                  * being executed from miniEnv
                  * We thus overwrite topPath as done below
                  *)
                 (*  FN[] -> topPath[]*)
              #)
           else
              getCurrentDir -> CWD[];
              (*'CWD: ' -> puttext; CWD[] -> putline;*)
              deComp;
          if)
       exit topPath[]
       #);
     mkModuleItemDecl:
       (# MI: ^ModuleItem;
       enter MI[]
       do MI.MD.DI.sig[] -> MI.sig[]; (* clumsy*)
          (*MI[] -> MI.MD.father[];*)
          (*'mkModuleItemDecl: ' -> putline; MI.doPT -> putline;*)
       exit MI[]
       #);
     
     cd: @ObjectCode;
  do (*true -> traceAlloc;*)
     inner
  #)
