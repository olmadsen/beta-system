ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qprimitives';
INCLUDE 'qlexer';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE '../VM/objectcode'
---lib:attributes--- 
newOutGen: (#exit true #);
coArg: (#exit false #);
checkInModule: (# exit true #);
putHead:
  (# T: ^text; n: @integer
  enter T[]
  do 5 -> n;
     inner;
     L:
       T.scanAll
       (#
       do ch -> put;
          (if ch = ascii.newline then n - 1 -> n if);
          (if n = 0 then '...'->puttext; leave L if)
       #);
     newline
  #);
Ttrace: (#exit true #);

traceIsBasicValue: (#exit false #);
traceImports: (# exit false #);
traceSingularFunc: (# exit false #);
traceUE: (# exit false #); (* trace Unit Exp *)

acc_domain: (# exit 0 #);
acc_public: (# exit 1 #);
acc_publicInSub: (# exit 2 #);
acc_private: (# exit 3 #);

AbstractSyntaxTree: Tree
  (# <<SLOT astlib:attributes>>;
     traceGetVqual,
     traceUnit,
     toFix, (* if true then print warnings at places where the code 
             * must be fixed; can be set via option qbeta -f
             *)
     trx,trxA: @boolean; (* for dynamic on/off of selective checks *)
     traceAlloc: @boolean;
     printOffOn: (# exit false #);
     traceProps: (# exit false #);
     traceGetQual: (# exit false #);
     reportSemErr: (# exit true #);
     reportQuaCheck: (# exit false #);
     reportNone: (# exit false #);
     verbose: @boolean;
     putPT:
       (# T: ^Text; N: ^Node
       enter(T[],N[])
       do '**** ' -> puttext; T[] -> puttext; ':' -> put; 
          (if N[] <> none then 
              newline;
              N.doPT -> puthead
           else
              ' none' -> putline
          if)
       #);   
     putDoPT:
       (# N: ^Node
       enter N[]
       do (if N[] <> none then 
              N.doPT -> puthead
           else
              'none' -> puttext
          if)
       #);
     display:
       (# T: ^text; S: ^Node
       enter(T[],S[])
       do (if trx or traceGetQual then
              T[] -> puttext; ':' -> put; newline;
              (if S[] <> none then S.doPT -> puthead 
               else ' is none' -> putline if)
          if)
       #);
     displayB:
       (# T: ^text; S: ^ObjectGenerator
       enter(T[],S[])
       do (if trx or traceGetQual then
              T[] -> puttext; ':primNo:' -> puttext;
              (if S[] <> none then
                  S.primNo -> putint; ' ' -> put;
                  (if true 
                   // S.super.isPrimitive then
                      (if S.IS.isEmpty then
                          'super is basic and IS is empty' -> putline
                       else
                          'super is basic and IS is NOT empty' -> putline
                      if)
                   // S.isPrimitive then
                      (if S.IS.isEmpty then
                          'is basisc and IS is empty' -> putline
                       else
                          'is basic and IS is NOT empty' -> putline
                      if)
                   // S.IS.isEmpty then
                      'IS is empty' -> putline
                   else
                      'Not basic and IS not empty'->putline
                  if)
               else
                  'is none' -> putline;  
          if)if)  
       #);
     SuperOGsequence:
       (# thisOGS:< SuperOGsequence; 
          DOG: ^ObjectSpecification;
          isNest: @Boolean;
          pred: ^thisOGS;
          FB:<
            (# qual: ^ObjectSpecification
            do inner
            exit qual[]
            #);
          print:< object;
       enter DOG[]
       do inner
       #);
     Node: TopNode
       (# vNode::< Node; 
          PT::<
            (# atEol: BooleanValue
                 (#
                 do (lx.length > 0) 
                    and ((lx.length -> lx.inxGet) = ascii.newline)
                      -> value
                 #);
               standAlone: BooleanValue
                 (# ch: @char; ix: @integer
                 do lx.length -> ix;  (*'"' -> put;*)
                    L:
                      (if ix > 0 then                        
                          ix -> lx.inxGet -> ch; 
                          (*ch -> put;
                           (if commentBefore then 'B'->put else 'A' -> put if);
                           *)
                        (if true
                         // ch = ascii.newline then
                            true -> value;
                            leave standAlone
                         // ch <= ' ' then;
                            ix - 1 -> ix;
                            restart L
                        if)
                     else
                        true -> value
                      if);
                    (*'"'->put*)
                 #);
               printCommentX:
                 (# ix,xpos: @integer
                 do (if comment[] <> none then
                        (if false then
                            '\n1234567890 comment:pos:'->puttext; 
                            pos -> putint;
                            ' commentBefore:' -> puttext; 
                            commentBefore -> putboolean;
                            newline;
                            comment[] -> puttext; '"\n'->puttext;
                        if);
                        comment.setPos;                   
                        1 -> ix;
                        emit:
                          (# doBreak,isAlone: @boolean; oldPos: @integer
                          do (* pos -> oldPos;*)
                             standAlone -> isAlone;
                             (ix -> comment.inxGet) = '<' -> doBreak;

                             (if doBreak then 
                                 comment.get;
                                 comment.getint - 3 -> xpos;
                                 (if not commentBefore then
                                     (pos,true) -> mkBreak;
                                 if)
                              else
                                 comment.getint;
                                 (if not isAlone then
                                     ' ' -> lx.put
                                 if)
                             if);
                             comment.get; (* read '>' *)
                             '--' -> lx.puttext;
                             comment.scan
                             (# 
                             do 
                                (if ch <> ascii.newline then 
                                    ch -> lx.put;
                                 else
                                    comment.pos + 1 -> ix;
                                    (pos,true) -> mkBreak;
                                    restart emit 
                             if) #);
                             (if doBreak (*and commentBefore *)
                                 or isAlone (*or (oldPos = 0)*) then
                                 (pos ,true) -> mkBreak;
                             if)
                          #)
                    if);
                 #)
            do (if not noComments and commentBefore then printComment if);
               inner;
               (if not noComments and not commentBefore then printComment if);
            #);
          HTML::<
            (# printCommentX:
                 (#
                 do (if comment[]  <> none then 
                        comment.scanAll(# do ch -> lx.put #);
                    if)
                 #)
            do (if not noComments and  commentBefore then 
                   printComment;
               if);
               inner;
               (if not noComments and not commentBefore then 
                   printComment 
               if);
            #);
          PP::<
            (#
            do inner;
               (if comment[] <> none then  
                   ' --' -> lx.puttext; comment[] -> lx.puttext if)
            #);
          debug:
            (# lx: ^text;
               TT: (# enter lx.puttext #);
               TQ: 
                 (# S: ^Text enter S[] 
                 do '"'->lx.put; S[] -> TT; '"'->lx.put 
                 #);
               II: (# enter lx.putint #);
               BB:
                 (# B: @boolean
                 enter B
                 do (if B then 'True' -> TQ else 'False' -> TQ if);
                 #)
            do &text[] -> lx[]; '$' ->lx.put; label -> lx.append; ':' -> lx.put;
               '"' -> lx.put; dopt -> lx.puttext; '"' -> lx.put;
               cd.com(#do lx[] -> TT #);               
               &text[] -> lx[];
               inner;
               cd.com(#do lx[] -> TT #);
            #);
          isDecl:< BooleanValue;
          isNewProp:< BooleanValue;
          isPattern:< BooleanValue;
          isDataItem:< BooleanValue;
          isArguments:< BooleanValue;
          isObjectGenerator:< BooleanValue;
          isObjectInvocation:< BooleanValue;
          isConstLiteral:< BooleanValue;
          isStringLiteral:< BooleanValue;
          isInteger:< BooleanValue;
          isFloat:< BooleanValue;
          enclosingDomain:
            (# MD: ^Module; prop: ^NewProperty
            do father.theModule -> MD[];
               L:
                 (if MD[] <> none then
                     MD.OG.IS.scanSons
                     (#
                     do (if current.isNewProp then
                            current[] -> prop[];
                            (if '%Domain_boundary' -> prop.propId.T.equalNCS then
                                (if false then
                                    'Found domain_boundary: ' -> puttext; 
                                    MD.sig.dopt -> puttext; ' ' -> put;
                                if);
                                leave L
                     if)if)#);
                     (if MD.father[] <> none then
                         MD.father.theModule -> MD[];
                         restart L
                      else
                         (if false then
                             'Default domain: ' -> puttext; 
                             MD.sig.dopt -> puttext; ' ' -> put;
                 if)if)if)
            exit MD[]
            #);
          enclosingObjectGenerator:
            (* see specialEnclosingObjectGenerator below
             * Is specEncOG = origin.encOG?
             * No! if specEncOG.IS.isEmpty then origin <> specEncOG.IS,
             * see enclosingOGwithIS below 
             *)
            (# N: ^Node; theOG: ^ObjectGenerator; ptn: ^Pattern
            do (if false and trx then
                   '**** enclosingObjectGenerator: ' -> putline;
                   dopt -> putline;
               if);
               father[] -> N[];
               L: (if N[] <> none then
                      (if true
                       // N.isObjectGenerator then 
                          N[] -> theOG[];
                          (if false and theOG.IS.isEmpty 
                              and (theOG.enclosingObjectGenerator <> none) then
                              theOG.father[] -> N[];
                              (*
                              (if theOG[] <> none then
                                  '**** theOG is none: ' -> putline;
                                  dopt -> putline
                               if)*)
                              restart L
                          if)
                       // N.isArguments then
                          (if N.father## = Signature## then
                              N.father.father[] -> ptn[];
                              ptn.OG[] -> theOG[]
                           else
                              N.father[] -> N[];
                              restart L
                          if)
                       else
                          N.father[] -> N[];
                          restart L
                      if)
                  if);
               (if false and trx then
                   '**   enclosingOG:got: ' -> putline;
                   theOG.doPT -> putline
               if)
            exit theOG[]
            #);
          enclosingOGwithIS:
            (* this is a variant of enclosingObjectGenerator above
             * where we skip OGs with no Items - it is used in qsemchecker.bet
             * objectGenerator::semCheck; if replacing enclosinObjectGenerator
             * above, a semantic error will happen in TST - dont know why?
             *)
            (# org: ^Items; theOG: ^ObjectGenerator;
            do (if trx and false then
                   '**** specialEnclosingObjectGenerator: ' -> putline;
                   dopt -> putline;
               if);
               (origin[]->org[]).encOG[] -> theOG[];
               (if trx and false then
                   '**   specialEnclosingOG:got: ' -> putline;
                   theOG.doPT -> putline
               if);
            exit theOG[]
            #);
          clear::<
            (#
            do false -> isChecked -> noArgsCheck -> genIsDone;
               inner;
            #);
          setUpOrigin::<
            (#
            do (if false then
                   '!!!! setUpOrigin:' -> puttext; label -> putline
               if);
               false -> noArgsCheck; 
               inner
            #);
          check:<
            (* check is called recursively when needed
             * Controlled by isChecked and beingChecked
             * beingChecked may be redundant!?
             * We stille need to catch loops in in patterns/objectGenerators!?
             * - As 2 patterns having each other as super!?
             *)
            (# elm:< TopNode; 
               rec: ^Exp; basicScope,argScope: ^Scope(*Items*);
               isFirst: @boolean;
               wasChecked: @boolean;
               beingCheckedX:< (# do inner #);
            enter(rec[],basicScope[],argScope[],isFirst)
            do (if beingChecked then 
                   beingCheckedX 
                else
                   (if not isChecked then
                       true -> beingChecked -> wasChecked;
                       inner; 
                       wasChecked -> isChecked;
                       false -> beingChecked
               if)if)
            exit basicScope[]
            #);
          checkOI:<
            (# rec: ^Exp; basicScope,argScope: ^Items;
               isFirst: @boolean;
               OGS: ^SuperOGsequence
            enter(rec[],basicScope[],argScope[],isFirst,OGS[])
            do (if false then
                   '**** checkOI:'->puttext; label -> puttext;
                   ' ' -> put; dopt -> putline;
               if);
               inner
            exit(basicScope[],OGS[])
            #);

          checkRequires:<
            (# done: @boolean
            do inner;
               (if not done then
                   scanSons(# do 
                              (*'*** CR: ' -> puttext; current.dopt->puthead;*)
                              current.checkRequires #)
               if)
            #);
          importRequires:<
            (# 
            do inner;
               scanSons(# N: ^Node do (current[]->N[]).importRequires #)
            #); 
          getUnitProp:<
            (# un: ^NewProperty
            do inner
            exit UN[]
            #);
          getExpUnit:<
            (# recU,U: ^text
            enter recU[]
            do inner
            exit U[]
            #);
          getConstLiteral:< IntegerValue;
          getVqual:<
            (# encOG: ^ObjectGenerator;
               OGS: ^superOGsequence; isNest: @boolean; qual: ^ObjectGenerator
             enter(encOG[],isNest,OGS[])
             do inner
             exit(OGS[],qual[])
             #);
          getActualReceiver:<
            (# rec: ^Node
            do this(node)[] -> rec[];
               inner
            exit rec[]
            #);
          alloc:<
            (# enclIT: ^items
            enter enclIT[]
            do (if traceAlloc then doPT -> putline if); 
               inner
            #);
          setVirtualBindings:<
            (# done: @Boolean
            do inner;
               (if done then
                   scanSons(#do current.setVirtualBindings #)
               if)
            #);
          semCheckDone: @boolean;
          semCheck:<
            (# rec: ^vNode; encOG,eOG: ^ObjectGenerator; 
               doCheck,done: @boolean
            enter(rec[],encOG[])
            do (if not semCheckDone then
                   true -> semCheckDone;
                   true -> doCheck; (* becomes false for modules not included
                                     * see semChecker
                                     *)
                   (if false then
                       '**** semCheck: ' -> putline; dopt -> putline;
                       '**** encOG: ' -> putline; 
                       (if encOG[] <> none then encOG.doPT -> putline if);
                   if);
                   encOG[]  -> eOG[];
                   (* eOG may be overwritten in inner and then done = true *)
                   inner;
                   (* encOG: scope/qual for this node *)

                   (if not noArgsCheck and doCheck and not done then
                       scanSons
                       (# 
                       do (rec[],eOG[]) 
                            -> current.semCheck
                            -> eOG[];
                          current[] -> rec[]
                       #);
                   if);
                   (if false then
                       '**** Node:semCheck:label:' -> puttext; label -> putline;
                       (if eOg[] <> none then eOG.doPT -> puthead if);
                       ('**   Node:semcheck:eOG:',eOG[]) -> display;
                   if)
               if)
            exit eOG[] (* qual of this(node) *)
            #);
          addConvFactor:<
            (# CF: @real; done: @boolean
            enter CF
            do 'addCF: ' -> puttext; label -> puttext; ' to: ' -> puttext;
               dopt -> putline;
               inner;
               (if not done then
                   L:
                     scanSons
                     (# 
                     do CF -> current.addConvFactor -> done;
                        (if done then 
                            leave L
                        if)
                     #)
               if)
            exit done
            #);
          hasConvFactor:< BooleanValue;
          int2floatDone:< BooleanValue
            (#
            do inner;
               L:
                 (if not value then
                     scanSons(# do current.int2floatDone -> value;
                                (if value then leave L if)#)
                 if)
            #);
          markedForCG: @boolean;
          markForCodeGen:<
            (# Ex: ^Exp
            enter Ex[]
            do (if not markedForCG then
                   inner;
                   true -> markedForCG
               if)
            #);
          allocInProgress,allocDone: @boolean;
          Qalloc:<
            (# varNo: @integer; IT: ^Items
            enter(varNo,IT[])
            do (if allocInProgress then
                   '!!!! allocInProgress:'->putline; dopt -> putline;
               if);
               true -> allocInProgress;
               inner;
               false -> allocInProgress;               
            #);
          classDef:<
            (#
            do inner;
               scanSons(#do current.classDef #)
            #);
          Qgen:<
            (# gdb:< debug(# do 'gen:'->lx.puttext; inner #);
               useReturnValue: @boolean; superAdj,staticOff: @integer;
               CC: ^CallChain; (* superflous*)
               mainPathModule: ^Module
            enter(useReturnValue,superAdj,staticOff)
            do gdb;               
               inner
            exit mainPathModule[]               
            #);
          bracketedListLength:< IntegerValue(#do 0-> value; inner #);
            (* For an exp L := (e1,e2,e3) where L: ref Indexed...;
             *  (e1,e2,e3) generates an 
             *  ObjectGenerator(Invocation(BracketedExp...) Items(...)
             * This method returns the length of the BE
             *)
          copyAST:<
            (# nAST: ^Node
            do (*'--copyAST: ' -> puttext; label -> putline;*)
               inner
            exit nAST[]
            #);
          replaceEntity::<
            (#
            do inner
            #);
          insert:
            (# N,atN: ^Node; oldSon,oldSonX: ^Node;
               addTail:
                 (# tail,tailX: ^Node
                 enter tail[]
                 do (if tail[] <> none then
                        tail.next[] -> tailX[];
                        none -> tail.father[] -> tail.next[];
                        tail[] -> append;
                        tailX[] -> tail[];
                        restart addTail
                    if);
                 #);
            enter(N[],atN[])
            do (if false then
                   '**** Node:insert: ' -> putline;
                   N.dopt -> putline;
                   '**** In: ' -> putline;
                   doPt -> putline; '---'->putline;
               if);
               (if true 
                // last[] = none then
                   (*'**** last none:' -> putline;*)
                   N[] -> append
                // atN[] = none then
                   (*'**** atN none:' -> putline;*)
                   N[] -> append
                // atN[] = son[] then
                   (*'**** atN none:' -> putline;*)
                   son[] -> oldSon[];               
                   none -> son[] -> last[];
                   N[] -> append;
                   oldSon[] -> addTail
                else
                   (*'**** else:' -> putline;*)
                   son[] -> oldSon[];
                   L:
                     (if oldSon[] <> atN[] then
                         oldSon.next[] -> oldSon[];
                         restart L
                      else 
                         (*'**** found: ' -> putline;*)
                         oldSon.next[] -> oldSonX[];
                         none -> oldSon.next[];
                         oldSon[] -> last[];
                         N[] -> append;
                         oldSonX[] -> addTail
                     if)
               if);

            #);
          findNodeAtPos::
            (# 
            do L:
                 (if (beginPos <= pos) and (pos <= endPos) then
                     scanSons
                     (#
                     do  pos -> current.findNodeAtPos -> N[];
                        (if N[] <> none then 
                            (if trace then '>'-> put if);
                            leave L 
                        if)
                     #);
                     (if N[] = none then 
                         this(TopNode)[] -> N[]; 
                         (if trace then
                             newline; 
                             '[' -> put; beginPos -> putint; 
                             ',' -> put; endPos -> putint; ']' -> put;
                         if)
                     if)
                 if)
            #);
          doMapBCposToCharRange::
            (# bPos1,ePos1: @integer; trace: (# exit false #)
            do (if trace then
                   '\ndoMapBCposToCharRange: ' -> puttext; label -> putline; 
                   'Lsc: ' -> puttext; lsc -> putint; 
                   ' in: '->puttext;
                   beginBCP -> putint; ','->put; endBCP -> putint; newline;
               if);
               
               (if (beginBCP < lsc) and (lsc <= endBCP) then
                   (if trace then
                       'Inside: ' -> puttext;
                   if);
                   beginPos -> B; endPos -> E;
                   (if trace then 
                       B -> putint; ','->put; E -> putint; newline 
                   if);
                   L:
                     scanSons
                     (#
                     do (if true (*not current.isObjDesc*) then (* do not go into singular*)
                            lsc -> current.doMapBCposToCharRange -> (bPos1,ePos1);
                            (if bPos1 > 0 then 
                                bPos1 -> B; ePos1 -> E;
                                leave L 
                        if)if)
                     #)
               if)
            #);
          theModule::<
            (# ModulePtn :: Module
            do inner;
               (if md[] = none then 
                   (if father[] = none then
                       'theModule:father is none: ' -> puttext;
                       doPT -> putline
                    else 
                       father.theModule -> md[];                        
                   if)
               if)
            #);
          addComment:
            (# T: ^text
            enter T[]
            do (if comment[] <> none then
                   ascii.newline -> comment.put;
                   T[] -> comment.append
                else
                   T[] -> comment[]
               if)
            #);
          clearQual:
            (#
            do (if trx and (theQual[] <> none) then
                   '**** clearQual: '->puttext; label->puttext; 
                   ' ' -> put; dopt -> puthead
               if);
               none -> theQual[];
               scanSons(#do current.clearQual #)
            #);
          theQual: ^ObjectGenerator;
          noArgsCheck,genIsDone: @boolean; 

       do inner;
          lex.getComment -> comment[];
          (if false and (comment[] <> none) then
              'Comment: ' -> puttext; label -> putline;
              comment[] -> putline
          if)
       #);     
     SuperDataItem: Decl
       (# PP:: (# do Label -> lx.append #);
          isConst: @boolean;
          NewOff:
            (# V: @integer
            do qoff[1] -> V
            exit V
            #);
       #);
     Module:< SuperDataItem
       (# PT:: 
            (# 
            do (pos,break,true) -> sig.PT;
               ': obj ' -> lx.puttext;
               (pos,break) -> OG.PT 
            #);
          length:: (# do sig.length + 5 + OG.length -> value #);
          label:: (# do 'obj' -> lab[] #);
          emitHTML::
            (# F: @File; FN,T: ^Text
            do (*pathToModuleFN -> putline;  *)
               (pathToModuleFN).copy -> FN[];
               '/' -> FN.append;
               sig.id[] -> FN.append;
               '.html' -> FN.append;
               FN[] -> F.name;
               F.openWrite;
               doHTML -> T[];
               T[] -> F.putline;
               F.close;
               OG.IS.scanSons
               (# I:^Item; D: ^Decl;
                  M: ^ModuleItem
               do (if ((current[]->I[]).isDecl) 
                      and ((I[]->D[]).isModuleItem) then
                      D[] -> M[];
                      (*'BÅT: ' -> puttext; M.sig.id[] -> putline;*)
                      M.MD.emitHTML
                  if)
               #)
            #);
          HTML::
            (# M: ^Module
            do '<!DOCTYPE html>\n'
               '<html>\n'
               '<head>\n'
               '<title>'
               'Public interface of qBeta module object\n' -> lx.append;
               '</title>\n'
               '</head>\n'
               '<body>\n'
               '<h1>'
               'Interface for qBeta module object\n' -> lx.append;
               '</h1>\n' -> lx.append;
               (if (encModule -> M[]) <> none then
                   '<h3><a href="../' -> lx.append; 
                   M.sig.id[] -> lx.append; 
                   '.html">' -> lx.append;
                   'Origin: ' -> lx.append; M.sig.id[] -> lx.append;
                   '</a></h3>\n' -> lx.append
               if);
               '<code>' -> lx.append;
               (pos,false) -> sig.HTML;
               ': <b>obj</b>  ' -> lx.append;
               (3,false) -> OG.HTML;
               '</code></body>\n</html>\n' -> lx.append;
            #);
          (* Bindings from compiler_IF *)
          moduleName:: (# do sig.id.copy -> N[] #);
          getEntries:: (# do OG.getEntries -> (names[],entries[]) #);
          entity:: (# do this(module)[] -> E[] #);
          theModule::(# do this(Module)[] -> MD[] #);
          isAmodule:: (# do &iModule[] -> M[]; this(Module)[] -> M.M[] #);
          getOrigin:: (# do origin[] -> org[] #);
          pathToModuleFN:: (# do pathToFN[] -> path[] #);
          innFile:: 
            (# 
            do (if F[] = none then inFile[] -> F[] else F[] -> inFile[] if) 
            #);
          myDesc:: (# do desc -> OD[] #);
          doHandleDirModules:: (# do handleDirModules #);
          
          pathToFN: ^Text;
          inFile: ^File;
          encModule:
            (# org: ^Items; M: ^Module
            do (if origin[] <> none then
                   (origin[] -> org[]).theModule -> M[];
               if) 
            exit M[]
            #);
          desc:<
            (# D: ^Items
            do inner
            exit D[]
            #);
          xkind:: (# do kinds.objModule -> K #);
          kind:: (# do '/' -> ch #);
          skind:: (# do ': /' -> S[] #);
                     (*sort:: (# do DI.sort -> S[] #);*)
          copyAST::
            (# 
            do (*'\n!!! Copy of Module is not implemented' -> putline *)
               (isConst,sig.copyAST,OG.copyAST) -> Module -> nAST[]
            #);
          replaceEntity::
            (# DIx: ^DataItem
            do ('Module:replaceEntity:with',T[]) -> LG.TnTn;
               
               T[] -> parseDeclTextX -> (errors[],DIx[]);

               (if errors[] = none then
                   none -> son[];
                   DIx.sig[] -> sig[] -> append;
                   DIx.OG[] -> OG[] -> append;                   
               if);
               path.init;
               (* handleDirModules;*)
               findDirModules;
               (*(path2Module[],T[]) -> DI.replaceEntity -> errors[]*)
            #);
          doInsert::
            (#
            do (if false then
                   '**** Module: doInsert: ' -> puttext; 
                   sig.doPT -> putline;
               if);
               (N[],atN[]) -> OG.IS.Insert
            #);          
          findDirModules:
            (*OBS! We need to do this recursively in all subdirectories! *)
            (#
            do (if false then
                   '**** findDirModules:\n' -> puttext;
               if);
               (pathToFN[],false) -> getBETAdirectories
               (#
               do scan
                  (# fullN: ^text; currentModule: ^Module; dcl: ^Decl
                  do (* current is a directory with a qBeta file like foo.xbeta *)
                     (if not currentIsFile then
                         (if false then
                             '**   dir: ' -> puttext; current[] -> putline;
                             '**   pathToFN: ' -> puttext; pathToFN[] -> putline;
                         if);
                         
                         pathToFN.copy -> fullN[];
                         '\\' -> fullN.put;
                         current[] -> fullN.append;
                         (if false then
                             '**   fullN: ' -> puttext; fullN[] -> putline;
                         if);
                         (fullN[],current[]) -> pDirModuleX -> currentModule[];
                         (true,fullN[],currentModule[]) -> ModuleItem -> addSigFromDI
                           -> dcl[];
                         dcl[] -> OG.IS.append;
                     if)
                  #)
               #)
            #);
          handleDirModules:
            (# pDirModule:<
                 (# moduleDir: ^text; (* name of direcory with BETA module *)
                    md: ^Module
                 enter moduleDir[]
                 do inner;
                 exit md[]
                 #);
               findModuleItems:
                 (# 
                 do (if trace then
                        'FindDir: find directories in:\n   ' -> puttext; 
                        path.append -> putline; 
                    if);
                    (path.append,false) -> getBETAdirectories
                    (#
                    do scan
                       (#
                       do (if not currentIsFile then
                              current[] -> addDirModuleN;
                 if)#)#)#);
               
               dirModuleN: [4] ^text; dcTop: @integer;
               addDirModuleN:
                 (# dir: ^text
                 enter dir[]
                 do (if (dcTop + 1 -> dcTop) > dirModuleN.range then 
                        dirModuleN.range -> dirModuleN.extend;
                        dirModule.range -> dirModule.extend
                    if);
                    dir[] -> dirModuleN[dcTop][]
                 #);
               (* Perhaps save ModuleItemDecl instead?
                * Perhaps factor appendModule out of scanDir
                *)
               dirModule: [4] ^ModuleItem;
               scanDir:
                 (# currentModule: ^Module;
                    N: ^text; (* module on path to ...*)
                 do (*'ScanDir:'->putline; dctop->putint; newline;*)
                    (for i: dcTop repeat
                         (*dirModuleN[i][] -> N[] -> putline;*)
                         (* See also Checker:ModuleItem:doCheck *)
                         dirModuleN[i][] 
                           -> N[] -> pDirModule -> currentModule[];
                         (true,N[],currentModule[]) -> ModuleItem -> dirModule[i][];
                         dirModule[i][] -> addSigFromDI -> appendModule; 
                         (if currentModule[] = none then 
                             'currentModule none' -> putline if);
                         true -> dirModule[i].isParsed; (* eliminate *)
                         INNER;
                    for);
                 #);              
               appendModule:
                 (# dcl: ^Decl 
                 enter dcl[] 
                 do (* 'AppendModule: ' -> putline; dcl.doPT -> putline; *)
                    dcl[] -> OG.IS.append
                 #);
               main,m: ^Module;
               isNotWorld: @boolean
            enter isNotWorld
            do (if trace then
                   '**** HandleDirModules: '->puttext; 
                   sig.doPt -> putline;
                   '**   path: ' -> puttext; path.append -> putline;
                   '**   CWD: ' -> puttext; pathToFN[] ->  getCWD -> putline;
               if);
               0 -> dcTop;
               (if (dirCh->(path.append).put) -> locateWorld.CWD.equal then
                   this(Module)[] -> main[];
                   (if trace then
                       'Found main: ' -> putline; main.doPT -> putline
                   if)
               if);
               
               findModuleItems;
               
               scanDir 
               (#
               do currentModule.sig.id[] -> path.push;
                  (if trace then
                      'EQ:'->putline; path.append-> putline; 
                      locateWorld.CWD[] -> putline; 
                  if);
                  &currentModule.handleDirModules
                  (# pDirModule::
                       (#
                       do (* calling pDirModule in enclosing handleDirModule,
                           * which is called from parser and parser has
                           * a binding of pDirModule
                           *)
                          moduleDir[] 
                            -> this(handleDirModules).pDirModule 
                            -> md[]
                       #)
                  #) -> m[];
                  (if m[] <> none then m[] -> main[] if);
                  path.pop
               #)
            exit main[]
            #);
          requires: @
            (* Modules required by this  module *)
            (# L: [4] ^Module; top: @integer;
               codeGenDone: @boolean;
               init:< (# do 0 -> top; #);
               add:
                 (# M: ^module
                 enter M[]
                 do (if not (M[] -> has) then
                        (if traceImports then
                            'requires.add: ' -> puttext; 
                            M.moduleName -> puttext;
                            ' to: ' -> puttext; 
                            (theModule).moduleName -> putline;
                        if);
                        (if (top+1->top) > L.range then 
                            L.range->L.extend if);
                        M[] -> L[top][];
                        (if false and not M.isChecked then 
                            (none,M.origin[],M.origin[],true) -> M.check;
                            true -> M.isChecked
                        if);
                        (* So if module M is required, we apprenly also
                         * require all enclosing modules! 
                         * Is this what we mean?
                         *)
                        addEnclosingModules
                    if)
                 #);
               addEnclosingModules:
                 (# org: ^Items; M: ^Module; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                        (if M[] <> none then
                            (if false then
                                '**** AddEnclosingModule: ' -> puttext; 
                                M.moduleName -> puttext;
                                ' of: ' -> puttext; 
                                (theModule).moduleName -> putline;
                            if);
                            (*M.requires.scan
                            (# 
                            do '**   addQEncReq: ' -> puttext;
                               current.sig.dopt -> putline;
                              *current[] -> requires.add 
                            #);*)
                            M[] -> requires.add;
                    if)if)
                 #);
               scan:
                 (# current: ^module
                 do (for i: top repeat
                         L[i][] -> current[]; inner
                 for)#);
               has: BooleanValue
                 (# M: ^Module
                 enter M[]
                 do L:
                      scan
                      (#
                      do  (if (M[] = current[]) -> value then
                              leave L
                      if)#)
                 #);
               import:
                 (# org: ^Items; M: ^Module; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                        (if M[] <> none then
                            (if false then
                                '**** import: ' -> puttext; 
                                M.moduleName -> puttext;
                                ' of: ' -> puttext; 
                                (theModule).moduleName -> putline;
                            if);
                            M.requires.scan
                            (#
                            do (if false then
                                   '**   addQEncReq: ' -> puttext;
                                   current.sig.dopt -> putline;
                               if);
                               current[] -> requires.add 
                            #);
                            M[] -> requires.add;
                    if)if)
                 #);
               print:
                 (#
                 do '**** Module: "' -> puttext;
                    moduleName -> puttext; 
                    '" requires: ' -> puttext;
                    scan
                    (#
                    do current.moduleName -> puttext; ' ' -> put
                    #);
                    newline
                 #)
            #);
          imports: @
            (# L: [4] ^module; top: @integer;
               init:< (# do 0 -> top;(* ' imports:init ' -> puttext; *) #);
               addM: 
                 (# M: ^module; MI: ^ModuleItem
                 enter M[]
                 do (if (M.father[] -> MI[]) <> none then
                        (*'***imports.addM: ' -> puttext; 
                         * M.moduleName -> putline; *)
                        MI[] -> add
                    if)
                 #);
               add:
                 (# mi: ^moduleItem
                 enter mi[]
                 do (if traceImports then
                        'Imports.add: ' -> puttext; 
                        mi.md.moduleName -> puttext; ' ' ->put;
                        mi.md.label -> puttext; ' ' -> put;
                        mi.label -> putline
                    if);
                    (if (top+1-> top) > L.range then L.range -> L.extend if);
                    mi.md[] -> L[top][];
                    (if not mi.md.isChecked then 
                        (none,MI.MD.origin[],MI.MD.origin[],true) 
                          -> MI.MD.check;
                        true -> MI.isChecked
                    if);
                    addEnclosingModules
                 #);   
               addEnclosingModules:
                 (# org: ^Items; M: ^Module; MI: ^ModuleItem
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[];
                        (if M[] <> none then
                            (*'**** AddEnclosingModule: ' -> puttext; 
                             * M.moduleName -> putline;
                             *)
                            M[] -> M.imports.addM
                    if)if)
                 #);
               scan:
                 (# current: ^module
                 do (for i: top repeat
                         L[i][] -> current[]; inner
                 for)#);
               mark: scan
                 (# 
                 do (if false then
                        current.sig.doPT -> putText; ' descNo: '->putText; 
                        (current.desc).DescNo -> putint; ' ' -> put;
                    if);
                    current.markModule
                 #);
            #);
          trace: (# exit false #);
          markModule: 
            (# inMainP: @boolean
            enter inMainP
            do (if traceImports then
                   'MarkImports: '->puttext; sig.doPT ->putline if);
               (if inMainP then
                   (*'Module in main path: ' -> puttext; 
                    * DI.sig.doPT ->putline;  *)
                   inMainP -> inMainPath
               if);
               
               (if not isIncluded then (* avoid circularity *)
                   true -> isIncluded; 
                   (if not inModuleProp then
                       '*** Module not in %module prop: ' -> puttext;
                       sig.dopt -> putline
                   if);
                   imports.mark
               if);
            #); 
          markInModuleProp:
            (# org: ^Items; M: ^Module; MI: ^ModuleItem
            do (if not InModuleProp then
                   (if false then
                       '**   markInModuleProp: ' -> puttext; 
                       sig.dopt-> puttext;
                   if);
                   true -> inModuleProp;
                   (if (origin[] <> none) and
                       (((origin[]->org[]).theModule -> M[]) <> none) then
                       (if false then
                           ', markOrigin: ' -> puttext;
                           M.sig.dopt -> putline;
                       if);
                       M.markInModuleProp
                    else
                       (if false then 'origin is none' -> putline if);
               if)if)
            #);
      
          objDescEQ:: (# do DN -> OG.objDescEQ -> value #);
          clear::<
            (#
            do (*'Module:clear: ' -> puttext; sig.dopt -> putline;*)
               imports.init;
               false -> isAdded -> isIncluded -> inMainPath ->inModuleProp;
               inner
            #);
          inMainPath: @boolean; (* Module in origin path of main program *)
          isAdded,isIncluded,inModuleProp: @boolean;
       enter(isConst,sig[] -> append,OG[] -> append)
       #);
     ModuleItem:< SuperDataItem
       (# label:: (# do 'ModuleItem' -> lab[] #);
          PT:: 
            (#
            do (if true then
                   '--' -> lx.puttext; sig.id[] -> lx.puttext; lx.newline
                else
                   (pos,break) -> MD.PT 
               if);
            #);
          length:: (# do MD.length -> value #);
          HTML::
            (# F: @File; FN: ^Text
            do (if break then
                   '<br>\n' -> lx.append;
                   pos -> indent;
               if);
               '<b>%Module</b> ' -> lx.puttext; 
               '<a href="' -> lx.append;
               sig.id[] -> lx.puttext;
               '/' -> lx.put;
               sig.id[] -> lx.append; '.html'-> lx.append;
               '">'-> lx.append;
               sig.id[] -> lx.puttext;
               '</a>\n' -> lx.append;
            #);
          isModuleItem:: TrueValue;
          getEntries:: (# do MD.getEntries -> (names[],entries[])#);
          Entity:: (# do MD.entity -> E[]#);
          xKind:: (# do MD.xkind -> K #);
          kind:: (# do MD.kind -> ch #);
          skind:: (# do MD.skind -> S[] #);
          isaModule:: (# do &iModule[] -> M[]; md[] -> M.M[] #);
          isParsed: @boolean;
          myDesc:: (# do MD.desc -> OD[] #);
          copyAST::
            (# do '\n!!! Copy of ModuleItem is not implemented' -> putline #);
          objDescEQ:: (# do DN -> MD.objDescEQ -> value #);
          replaceEntity::
            (#
            do ('ModuleItem:replaceEntity',MD.sig.dopt) -> LG.TTn;
               (path2Module[],T[]) -> MD.replaceEntity -> errors[]
            #);
          doInsert::
            (#
            do (*'**** ModuleItem:doInsert: ' -> putline;*)
               (N[],atN[]) -> MD.doInsert
            #);
          visibility:: (* used to be configure *)
            (#
            do (if ((desc).newBasicProp.OSDvisibility ->  VI) = 0 then if) 
            #);
          clear::<
            (#
            do MD.clear;
               inner
            #);
          MD: ^Module; (* perhaps DataItem? *)
          N:  ^Name;
          inModuleProp: @boolean; (* true if this MI is in a %module prop *)
       enter(isConst,Name -> N[] -> append,MD[]->append)
       #);
     Items:< Scope 
       (# PT::< 
            (# D: ^Decl;
            do (if false then
                   '['->lx.put; pos -> lx.putint;']'->lx.put;
               if);
               (pos,length) -> block
               (# 
               do (* '{' -> lx.put; beginPos -> lx.putint; ' ' -> lx.put;*)
                  inner PT;
                  scanSons
                  (#
                  do (pos,break) -> current.PT; 
                     (if not isLast then
                         (if current.isDecl then
                             (if not (current[]->D[]).isModuleItem then
                                 (pos,true) -> mkbreak
                             if)
                          else
                             (pos,true) -> mkbreak
                         if)
               if)#)#);
               (*'}'-> lx.put*)
            #);
          length::
            (#
            do (if (son[] <> none) and (son.length > 1) then
                   lineWidth + 10 -> value
                else
                   scanSons(# do current.length + value -> value #)
               if)
            #);
          label:: (# do 'Items' -> lab[] #); 
          PP::< (# do label -> lx.append; inner (* what about props?*) #);
          copyAST::
            (#
            do (*'Items:' -> putline;*)
               Items -> nAST[];
               scanSons
               (#
               do current.copyAST -> nAST.append
               #)
            #);
          scanDecls:
            (# currentDcl: ^decl;
            do (if sig[] <> none then
                   sig.scanSons
                   (#do (if current.isDecl then
                            current[] -> currentDcl[];
                            inner scanDecls
                   if)#)
               if);
               scanSons
               (# I: ^Item
               do current[] -> I[];
                  (if I.isDecl then
                      I[] -> currentDcl[];
                      inner scanDecls
                  if);
               #)               
            #);  
          scanAllDecls:
            (# currentDcl: ^Decl;
               superOrgOff,level: @integer
            do (if (superDesc[] <> none) and (superDesc[] <> objectDecl.desc) then
                   &superDesc.scanAllDecls
                   (#
                   do currentDcl[] -> this(scanAllDecls).currentDcl[];
                      inner scanAllDecls
                   #) -> (superOrgOff,level)
               if);
               scanDecls
               (#
               do currentDcl[] -> this(scanAllDecls).currentDcl[];
                  inner scanAllDecls
               #)
            exit(superOrgOff,level) 
            #);
          scanAllItemDecls:
            (# currentDcl: ^Decl;
               superOrgOff,level: @integer
            do (if (superDesc[] <> none) and (superDesc[] <> objectDecl.desc) then
                   &superDesc.scanAllItemDecls
                   (#
                   do currentDcl[] -> this(scanAllItemDecls).currentDcl[];
                      inner scanAllItemDecls
                   #) -> (superOrgOff,level)
               if);
               (if sig[] <> none then
                   sig.scanSons
                   (#do (if current.isDecl then
                            current[] -> currentDcl[];
                            inner scanAllItemDecls
                   if)#)
               if);
               scanDecls
               (#
               do currentDcl[] -> this(scanAllItemDecls).currentDcl[];
                  (*'scanAllItemDecls: ' -> puttext;
                  this(scanAllItemDecls).currentDcl.doPT -> putline;*)
                  inner scanAllItemDecls
               #)
            exit(superOrgOff,level) 
            #);
          scanNonBoundItemArgs:
            (* scan arguments not bound in a super as in
             *  foo:bar(e1,e2,e3){...}
             * when scanning args of foo, args in bar shall not be included
             * since they are bound to e1,e2,e3
             *)
            (# skipMain: @boolean;
               currentArg: ^Decl; E: ^Exp; BE: ^BracketedExp
            enter skipMain
            do (if (super.ATd[] <> none) then
                   (super.last) -> E[];
                   (if (E[] <> none) and ('BracketedExp' ->(E.label).equal) then
                       (*'**** scanNonBoundItemArgs: ' -> puttext;*)
                       ((E[]-> BE[]).IV.last) -> E[]; (* hack, must scan IV *)
                       (*E.dopt -> putline*)
                   if);
                   (if false then
                       '**** KUK: '->puttext; 
                       (if E.args[] <> none then E.args.noOfSons -> putint;
                           newline
                        else
                           ' E.args is none' -> putline
                       if);
                       E.dopt -> putline;
                       dopt -> putline;
                   if);
                   (if (E[] <> none) and (E.args[] <> none)
                       and (E.args.noOfSons > 0) then
                       (if false then
                           '**** scanNonBoundItemArgs:Bound in super:'->puttext;
                           (if sig[] <> none then 
                               sig.dopt -> putline else newline if);
                           E.doPT -> putline;
                       if);
                    else
                       &superDesc.scanNonBoundItemArgs
                       (#
                       do currentArg[] 
                            -> this(scanNonBoundItemArgs).currentArg[];
                          inner scanNonBoundItemArgs
                       #)
                   if);
               if);
               (if not skipMain then
                   (if false and (sig[] <> none) then 
                       (* OBS! do we need to scan sig with new syntax? *)
                       (* sig is included in scanDecls *)
                       sig.scanSons
                       (#
                       do (if current.isDecl then
                              current[] -> currentArg[];
                              inner scanNonBoundItemArgs
                          if)
                       #)
                   if);
                   scanDecls
                   (#
                   do currentDcl[] -> currentArg[];
                      (if currentArg.isInArg then
                          inner scanNonBoundItemArgs
                      if)
               #)if)
            #);
          scanItemArgs:
            (# currentArg: ^Decl; vn,rn: @integer
            do (if sig[] <> none then
                   (*'**** scanItemArgs: ' -> puttext; sig.dopt -> putline;
                   *)
               if);
               scanAllItemDecls
               (# DI: ^DataItem
               do currentDcl[] -> this(scanItemArgs).currentArg[];
                  (if currentArg.isInArg then
                      (if currentArg.isDataItem then
                          currentArg[] -> DI[];
                          (if DI.isValue then
                              vn + 1 -> vn
                           else
                              rn + 1 -> rn
                      if)if);
                      inner scanItemArgs
                  if)
               #)
            exit(vn,rn)
            #);
          scanItemArgsReverse:
            (# currentArg: ^Decl; args: [4] ^DataItem; top: @integer
            do scanReverse
               (# OT: ^Item
               do (if (current[] -> OT[]).isDecl then
                      current[] -> this(scanItemArgsReverse).currentArg[];
                      (*current.doPT -> putline;*)
                      (if currentArg.isInArg and not currentArg.isVirtual then
                          inner scanItemArgsReverse
                  if)if)
               #);
               (if sig[] <> none then
                   sig.scanSons
                   (# 
                   do (if current.isDataItem then
                          (if (top + 1 -> top) > args.range then
                              args.range -> args.extend
                          if);
                          current[] -> args[top][]
                   if)#);
                   (for i: top repeat
                        args[top - i + 1][] -> currentArg[];
                        inner scanItemArgsReverse
               for)if)
            #);
          noOfRefArgs: 
            (# N: @integer
            do true -> scanNonBoundItemArgs
               (# DI: ^DataItem
               do (if currentArg.isDataItem 
                      and not (currentArg[]->DI[]).isValue then
                      N + 1 -> N;
                  if)
               #)
            exit N
            #);
          theObjectGenerator:: (# do father[] -> OGx[] #);
          isImmutable::
            (#
            do (if superDesc[] <> none then
                   superDesc.isImmutable -> value
               if);
               (if not value then
                   (if not (newBasicProp.immutable -> value) then

               if)if)
           #);
          isUnique: BooleanValue
            (#
            do (if superDesc[] <> none then
                   superDesc.isUnique -> value
               if);
               (if not value then
                   (if not (newBasicProp.unique -> value ) then

               if)if)
            #);
          collectSimple::
            (# off: @integer
            do scanAllDecls
               (# name: ^Text;
                  off,kind: @integer
               do '???'-> name[];
                  currentDcl.sig.ID[] -> name[];
                  (if true then
                      currentDcl.qoff[1] -> off
                   else
                      currentDcl.off -> off;
                  if);
                  (if off > 0 then
                      (if currentDcl.isPrimitive then
                          SimpleKind -> kind
                       else
                          (if currentDcl.isVirtual then
                              virtualKind -> kind
                           else
                              ReferenceKind -> kind
                          if)
                      if)
                   else
                      (* chef isIndexed -  see parser:collectSimple *)
                      patternKind -> kind
                  if);
                  (* 'Collect: ' -> puttext; name[] -> puttext;
                   ' off:'  -> puttext; off -> putint;
                  ' kind:' -> puttext; kind -> putint; newline;*)
                  (name[],off,kind,currentDcl[]) -> addSimple
               #);
            #);
          getEntries:: 
            (# 
            do scanDecls(# do (currentDcl.sig.id[],currentDcl[]) -> add #)
            #);
          doInsert::
            (#
            do '\n*** items:doInsert: ' -> putline;
               N.dopt -> putline;
               atN.dopt -> putline;
            #);
          primNo: integerValue
            (#
            do (if (newBasicProp.primno -> value) > 0 then
                   (* '**** primNo:got: ' -> puttext; value -> putint; newline;
                    dopt -> putline*)
               if)
            #);
          handleNewProps:
            (#
            do scanSons
               (# N: ^NewProperty
               do (if current.isNewProp then
                      current[] -> N[];
                      (if true
                       // '%basic' -> N.propID.T.equalNCS then
                          (* '**** found %basic: ' -> puttext; 
                           * current.dopt -> putline; *)
                          N.args.scanSons
                          (# INV: ^Invocation; first:@boolean 
                          do current[] -> INV[];
                             isFirst -> first;
                             INV.scanSons
                             (# C: ^Const
                             do (if current.isConstLiteral then
                                    (if first then
                                        current[] -> C[];
                                        C.T.setPos;
                                        C.T.getInt 
                                          -> N.primno -> newBasicProp.primNo;
                                        true -> isPrimitive;
                                        (* 'primno: ' -> puttext; 
                                         newBasicProp.primNo -> putint;
                                         newline*)
                                    if)
                                 else
                                    '**** must be constliteral' -> putline
                                if)
                          #)#)
                       // '%arguments' -> N.propID.T.equalNCS then
                          N[] -> newBasicProp.arguments[];
                       // '%interface' -> N.propID.T.equalNCS then
                          N[] -> newBasicProp.interface[];
                          true -> newBasicProp.hasIFR
                       // '%globals' -> N.propID.T.equalNCS then
                          N[] -> newBasicProp.globals[]
                       // '%requires' -> N.propID.T.equalNCS then
                          N[] -> newBasicProp.requires[]
                       // '%module' -> N.propID.T.equalNCS 
                       // '%modules' -> N.propID.T.equalNCS then
                          (*'**** got modules:prop: ' -> puttext;
                          N.dopt -> putline;*)
                       // '%unit' -> N.propID.T.equalNCS then
                          N[] -> newBasicProp.unit[];
                       // '%associations' -> N.propID.T.equalNCS then
                          '**** Association: ' -> puttext; dopt -> putline;
                       // '%locals' -> N.propID.T.equalNCS then
                          N[] -> newBasicProp.locals[]
                       // '%unique' -> N.propID.T.equalNCS then
                          true -> newBasicProp.unique
                       // '%immutable' -> N.propID.T.equalNCS then
                          true -> newBasicProp.immutable    
                       // '%external' -> N.propID.T.equalNCS then
                          N.getArg1 -> newBasicProp.externalNo
                       // '%core' -> N.propID.T.equalNCS then
                          N.getArg1 -> newBasicProp.coreNo 
                       // '%OSDvisibility' -> N.propID.T.equalNCS then
                       // '%ID'  -> N.propID.T.equalNCS then
                      if)
                  if)
               #)
            #);
          doSearch:<
            (#  NA: ^Lexem;  ATd: ^Decl; on,pn: @integer
            enter NA[]
            do inner
            exit ATd[]
            #);
          isPrimitive: @ Boolean; (* we also have isBasic - unite *)
          doCall:<
            (# N: ^text; LMR: @char
            enter(N[],LMR)
            do inner; 
            #);
          isCore: integerValue
            (#
            do (if (newBasicProp.coreNo -> value) > 0 then if)
            #);
          isExternal: integerValue
            (#
            do (if (newBasicProp.externalNo -> value) = 0 then
               if)
            #);
          visibility::
            (#
            do (if (newBasicProp.OSDvisibility -> VI) = 0 then if)
            #);
          sig: ^Signature; (* if pattern, the signature else none *)
          (*encOG: ^ObjectGenerator;*)
          newBasicProp: @
            (# primNo,coreNo,externalNo,OSDvisibility: @ integer; 
               hasIFR,unique,immutable: @boolean;
               interface,arguments,unit
               ,globals,locals,requires: ^NewProperty;
               hasArguments: booleanValue
                 (#
                 do (if superDesc[] <> none then
                        superDesc.newBasicProp.hasArguments -> value
                    if);
                    (If not value then
                        arguments[] <> none -> value
                    if)
                 #);
               scanArguments:
                 (# current: ^Invocation
                 do (if superDesc[]  <> none then
                        &superDesc.newBasicProp.scanArguments
                        (#
                        do current[] -> this(scanArguments).current[];
                           inner scanArguments
                    #)if);
                    (if arguments[] <> none then 
                        arguments.scanSons
                        (#do 
                           (if not isFirst then
                               current.scanSons
                               (#do
                                  current[] -> this(scanArguments).current[];
                                  inner scanArguments
                               #)
                           if)
                    #)if)
                 #);
               scanProp:
                 (# prop: ^NewProperty; current: ^Invocation
                 enter prop[]
                 do (if superDesc[]  <> none then
                        prop[] -> &superDesc.newBasicProp.scanProp
                        (#
                        do current[] -> this(scanProp).current[];
                           inner scanProp
                    #)if);
                    (if prop[] <> none then 
                        prop.scanSons
                        (#do
                           (if not isFirst then
                               current.scanSons
                               (#do
                                  current[] -> this(scanProp).current[];
                                  inner scanProp;
                               #)
                           if)
                    #)if)
                 #);
               scanGlobals:
                 (# current: ^Invocation
                 do (if superDesc[]  <> none then
                        &superDesc.newBasicProp.scanGlobals
                        (#
                        do current[] -> this(scanGlobals).current[];
                           inner scanGlobals;
                    #)if);
                    (if globals[] <> none then 
                        globals.scanSons
                        (#do 
                           (if not isFirst then
                               current.scanSons
                               (#do
                                  current[] -> this(scanGlobals).current[];
                                  inner scanGlobals;
                               #)
                           if)
                    #)if)
                 #);
            #);
          doHasCode:@boolean;
          super: ^Invocation;
          (*superDesc: ^Items; *)
          sort:: (# do this(Items)[] -> S[] #);
          getOrigin:: (#do origin[] -> org[] #);
          (* Item's are appended
           * But sometimes not so clean/smart that some attributes
           * are both explicit and appended as 'incl' and others like Item's
           * are appended
           *)
          isEmpty: @boolean;
          objSize: IntegerValue(#do qsize[1] -> value #);
          clear::< 
            (# 
            do 0 -> QDNtop -> descNo;
               none -> superDesc[];
               (for i: QdescNo.range repeat 0 -> QdescNo[i] for);
               inner 
            #);          
          descNo: @integer; (* Why is descNo in Items and not in OG?
                             * Perhaps to avoid a descNo for a 
                             * non-singular invocation!?
                             *)
          QdescNo: [1] @integer; QDNtop: @integer;
          qsize: [1] @integer; 
       #);
     Item: Node 
       (# 
          isVirtual:< BooleanValue;
          isVirtualObject:< BooleanValue;
          isVirtualObjectX:< BooleanValue;
          isPrimitive:< BooleanValue(# do inner #);
          primNo:< IntegerValue(# do inner #);
          desc:<
            (# elm:< Node; D: ^Items
            do inner
            exit D[]
            #);
          getQual:<
            (# qual: ^ObjectGenerator
            do inner
            exit qual[]
            #);
          sort:: (# do this(Item)[] -> S[] #);
          hasCode:< BooleanValue;
          findNextImp::<
            (#
            do inner;
               (if impx[] <> none then
                   (if beginBCP > bcp then
                       this(Item)[] -> impx[]
                    else
                       L:
                         scanSons
                         (# 
                         do (if (bcp -> current.findNextImp -> impx[]) <> none then
                                leave L 
               if)#)if)if)
            #)
       do inner 
       #);
     newProperty:< Item
       (# PT::
            (#
            do propId.T[] -> lx.puttext;
               (pos,break) -> args.PT
            #);
          length:: (# do propId.length + args.length -> value #);
          label:: (# do 'Property' -> lab[] #);
          PP:: (#do label -> lx.append #);
          done: @boolean;
          HTML:: 
            (# 
            do 
               (if true 
                // '%public' -> propId.T.equalNCS then
                   acc_public -> accL;
                // '%private' -> propId.T.equalNCS then
                   acc_private -> accL;
                   leave HTML
                // '%publicInSub' -> propId.T.equalNCS then
                   acc_publicInSub -> accL; 
                // '%domain' -> propId.T.equalNCS then
                   acc_domain -> accL;  
               if);
               (if not done then
                   (if break then 
                       '<br>\n' -> lx.append;
                       pos -> indent; 
                   if);
                   '<b>' -> lx.append;
                   propId.T[] -> lx.append; 
                   '</b> ' -> lx.puttext;
                   (pos,false) -> args.HTML;
                   (*'<br>'->lx.append;*)
                   true -> done
               if)
            #);
          isNewProp:: TrueValue;
          copyAST::<
            (#
            do (propID.copyAST,args.copyAST) -> NewProperty -> nAST[];
            #);
          getArg1: integerValue
            (#
            do args.scanSons
               (# INV: ^Invocation; first:@boolean 
               do current[] -> INV[];
                  isFirst -> first;
                  INV.scanSons
                  (# C: ^Const
                  do (if current.isConstLiteral then
                         (if first then
                             current[] -> C[];
                             C.T.setPos;
                             C.T.getInt -> value
               if)if)#)#)
            #);
          getSarg1:
            (# U: ^text
            do L:
                 args.scansons
                 (# INV: ^Invocation; 
                 do current[] -> INV[];
                    INV.scanSons
                    (# S: ^StringObj
                    do (if current.isStringLiteral then
                           (current[] -> S[]).T[] -> U[];
                           leave L
                 if)#)#)
            exit U[]
            #);
          primNo,coreNo,externalNo: @integer; (* clean-up here *)
          propId: ^Name; args: ^NewPropertyArguments
       enter(propId[]->append,args[]->append)
       #);
     NewPropertyArguments:< Node
       (# PT::
            (# 
            do scanSons
               (# n: @integer
               do (if (n + 1 -> n) > 1 then 
                      ',' -> lx.put
                  if);
                  ' ' -> lx.put;
                  (pos,break) -> current.PT
               #);
            #);
          length:: 
            (# do scanSons(# do current.length + 2 + value -> value #)#);
          label:: (# do 'NewPropertyArguments' -> lab[] #);
          PP:: (# do label -> lx.append #);
          HTML::
            (# hasBr: @boolean
            do scanSons
               (# n: @integer
               do (if (n + 1 -> n) >  1 then ',' -> lx.put if);
                  (pos,false) -> current.HTML;
                  (*true -> hasBr;*)
               #);
               (if false and not hasBr then '<br>\n' -> lx.append if)
            #);
          copyAST::<
            (#
            do NewPropertyArguments -> nAST[];
               scanSons(# do current.copyAST -> nAST.append #)
            #);
          inModulePropX: @boolean
       #);
     Decl: Item
       (# PT::< 
            (# 
            do (if printOffOn then
                   '('->lx.put; off -> lx.putint; ')'-> lx.put;
               if);
               (if isInArg then 'in ' -> lx.puttext if);
               (if isOutArg then 'out ' -> lx.puttext if);
               inner 
            #);
          isArg: @boolean;
          sig: ^Signature;
          OG: ^(*ObjectGenerator*)ObjectSpecification;
          off: @integer;
          qoff: [1] @integer; noOfVar: @integer;
          isInArg,isOutArg: @boolean;
          setNewId:< (#do inner #);
          objSize:< IntegerValue;
          isDecl:: TrueValue;
          isModuleItem:< BooleanValue;
          isPatternDecl:< BooleanValue;
          isBasicPattern:< BooleanValue;
          isBasicValue:< BooleanValue;
          isSubOfBasicValue:< BooleanValue;
          isImmutable:< BooleanValue;
          isUnique:< BooleanValue;
          accessLevel: @integer;
          changeAttName:: 
            (# do '!!!! Decl:changeAttName: no binding' -> putline #);
          isInner:< BooleanValue
            (# basicScope: ^items; args: ^Arguments 
            enter(basicScope[],args[]) 
            do inner 
            #);
          checkVirtualArgs:<
            (# E: ^Exp; hasVirtualArgs: @boolean
            enter E[]
            do inner
            exit hasVirtualArgs
            #);
          checkQual:<
            (# srcOS: ^ObjectSpecification; srcQual,dstQual: ^ObjectGenerator;
               isAssign: @boolean
            enter(srcOS[],srcQual[],dstQual[],isAssign)
            do inner 
            #);          
          checkActualArgs:<
            (# actualArgs: ^Arguments; 
               encOG,singleUnitArgQual: ^ObjectGenerator;
               theOI: ^ObjectInvocation; 
            enter(actualArgs[],encOG[],theOI[])
            do inner
            exit singleUnitArgQual[]
            #);

          handleArgs:< (# E: ^Exp enter E[] do inner #);
          markIfVirtualDataItem:<
            BooleanValue(# IT: ^Items enter IT[] do inner #);
          hasVirtualObjectQual:< BooleanValue;
          pushThis:< 
            (# gdb:< debug(# do '>pushThis:'->lx.puttext; inner #);
            do inner
            #);
          loadArgs:< 
            (# gdb:< debug(# do '>loadArgs:'->lx.puttext; inner #);
               E: ^Exp; superAdj,staticOff: @integer; 
               CC: ^CallChain;
               isResume: @boolean
            enter(E[],superAdj,staticOff,CC[])
            do gdb; inner 
            exit isResume
            #);
          getAdr:< 
            (# gdb:< debug(#do '>getAdr:'-> TT; inner #); 
               A: ^superAdr; loadRec: @boolean
            enter A[] do gdb; inner exit(loadRec,A[] )
            #);
          load:< 
            (# rec: ^Exp; A: ^SuperAdr enter(rec[],A[]) do inner #);
          invoke:< 
            (# gdb:< debug(# do '>invoke:'->lx.puttext; inner #);
               rec,E: ^Exp; useReturnValue: @boolean; 
               staticOff: @integer;
               CC: ^CallChain;
               adr: ^SuperAdr;
               isResume: @boolean
            enter(rec[],E[],useReturnValue,staticOff,CC[],adr[],isResume)
            do gdb; inner 
            #);          
          isCore:< integerValue(# do inner #);
          store:< 
            (# gdb:< debug(#do '>store:' -> TT; inner #);
               noSwap: @boolean;  
            enter noSwap 
            do inner 
            #);
          popReturn:< (# do inner #);
          (*sort:: (# do theObjectGenerator -> S[] #)*)
       do inner
       #);
     Scope: Node
       (# theObjectGenerator:< (# OGx: ^ObjectGenerator do inner exit OGx[]#);
          encOG: ^ObjectGenerator;
          superDesc: ^Items; 
          search:<
            (# NA: ^Lexem; isFirst: @boolean; ATd: ^Decl; on,pn: @integer
            enter(NA[],isFirst)
            do inner
            exit(ATd[],on,pn) 
            #);
          isImmutable:< BooleanValue;
       do inner
       #);
     Signature:< Scope
       (* In xbeta and qbeta, Signature have subpatterns UnarySignature, etc.
        * For all sub of Signature, arguments are in-declarations in Items.
        * The args: ^Arguments DI is no longer used
        * The DI id is the unique identifier for the Signature
        * id is not represented as a son
        * For the new fat comma keyword, arguments are represented as
        * sons of Signature; this includes fat commas and declarations
        * Additional attributes:
        *    type: ^SigType
        *    isKeyWord,isNewFatCommaSig: @Boolean
        *)
       (# PT:: 
            (# inDecl: @boolean
            enter inDecl
            do (if false then
                   '**** signature:pt: ' -> puttext; id[] -> putline;
               if);
               id[] -> type.id[];
               (if inDecl then (* called  from Pattern DataItem,  etc. *)
                   (if isNewFatCommaSig then
                       (if true then
                           scanSons(#do (pos,break) -> current.PT #)
                        else
                           (pos,break,inDecl) -> type.PT
                       if)
                    else                           
                       type.id[] -> lx.puttext; 
                   if);
                   (if type## = Binary## then ' '-> lx.put if)
                else
                   (*(pos,break,inDecl) -> type.PT;*)
                   scanSons(#do (pos,break) -> current.PT #)
               if)
            #);
          length:: 
            (# 
            do (if type[] <> none then
                   type.length -> value;
                else
                   scanSons(#do current.length + value -> value #)
               if)
            #);
          Label:: (# do 'Signature' -> lab[] #);
          PP::
            (# 
            do Label -> lx.append; 
               ' id="' -> lx.append; id[] -> lx.append; '"' -> lx.put;
               ' isKW=' -> lx.append; 
               (if isKeyWord then 'T' -> lx.put else 'F' -> lx.put if);
               ' isNewFatKW=' -> lx.append; 
               (if isNewFatCommaSig then 'T' -> lx.put else 'F' -> lx.put if);
               ' L=' -> lx.append; type.label -> lx.append
            #);
          HTML::
            (#
            do '<i id="' -> lx.append;
               id[] -> lx.append;
               '" style="color:MediumSeaGreen;">' -> lx.append;
               id[] -> lx.append;
               '</i>' -> lx.append
            #);
          type: ^SigType;
          SigType: Node 
            (# id: ^text;
               PT::< (# inDecl: @boolean enter inDecl do inner #);
               copyAST:<
                 (# id: ^Text; args: ^Arguments; isKeyword: @boolean; 
                    sig: ^Signature;
                    nAST: ^Node
                 enter(id[],args[],isKeyWord)
                 do inner
                 exit nAST[]
                 #);
            enter id[] 
            do id[] -> name -> append 
            #);
          Unary:< SigType
            (# Label:: (# do 'UnaryPtn' -> lab[] #);
               PT:: (# do id[] -> lx.puttext #);
               copyAST::
                 (#
                 do (id[],args[],isKeyWord) -> UnarySigGen -> nAST[]
                 #);
            #);
          Binary:< SigType
            (# label :: (# do 'Binary' -> lab[] #);
               PT:: 
                 (#
                 do id[] -> lx.puttext; ' ' -> lx.put; 
                    (pos,break,inDecl) -> args.PT 
                 #);
               copyAST::
                 (#
                 do (id[],args[],isKeyWord) -> BinarySigGen -> nAST[]
                 #);               
            #);
          Function:< SigType
            (# label:: (# do 'Function' -> lab[] #);
               PT:: (#do id[] -> lx.puttext; (pos,break,inDecl) -> args.PT #);
               copyAST::
                 (#
                 do (id[],args[],isKeyWord) -> FunctionSigGen -> nAST[]
                 #);               
            #);
          KeyWord:< SigType
            (# label :: (# do 'KeyWord' -> lab[] #);
               PT:: (#do (pos,break,inDecl) -> args.PT #);
               copyAST::
                 (#
                 do (id[],args[],isKeyWord) -> KeywordSigGen -> nAST[]
                 #);               
            #);
          copyAST::<
            (#
            do (*'signature:' -> puttext; dopt -> putline; *)
               (id.copy,args.copyAST,isKeyword) ->  type.copyAST -> nAST[]
            #);
          args: ^Arguments;
          id: ^text; (* should be a Name *)
          isKeyWord,isNewFatCommaSig: @boolean;
          (*encOG: ^ObjectGenerator;*)
          init:
            (# 
            enter(id[],args[],isKeyWord)
            do (if false then
                   '**** Signature: "' -> puttext; id[] -> puttext; 
                   '" args: "' -> puttext; args.dopt -> puttext;
                   '" isKW=' -> puttext; isKeyWord -> putboolean; newline;
               if);
               (if not isKeyWord then
                   id[] -> Name -> Append
                else 
                   true -> args.isKeyword;
                   (*this(Signature)[] -> args.father[]*)
               if);
               (if args[] <> none then args[] -> append if);
            #);
          (* Keyword = Signature(args)
           * else    = Signature(name(id),args?)
           *)
       enter(init) 
          (* OBS! (init[with only enter id[]],isKeyWord) does not work 
           * Perhaps compiler error!?
           *)
       #);     
     Sig_Generator:
       (# id: ^Text; args: ^Arguments; isKeyword: @boolean; sig: ^Signature
       enter(id[],args[],isKeyWord)
       do (id[],args[],isKeyWord) -> Signature -> sig[];
          inner;
       exit sig[]
       #);
     UnarySigGen: Sig_Generator (# do id[] -> sig.Unary -> sig.type[] #);
     FunctionSigGen: Sig_Generator(# do id[] -> sig.Function -> sig.type[] #);
     KeyWordSigGen: Sig_Generator(# do id[] -> sig.KeyWord -> sig.type[] #);
     BinarySigGen: Sig_Generator(# do id[] -> sig.Binary -> sig.type[] #);
     Arguments:< Node
       (# elm:< Item;
          PT:: 
            (# inDecl: @boolean
            enter inDecl
            do (*'**** arguments:PT: ' -> puttext; isKeyword -> putboolean;
               ' ' -> put; *)
               (if true
                // isBinary then
                   (if inDecl then
                       scanSons
                       (#
                       do 'in ' -> lx.puttext;
                          (pos,break) -> current.PT;
                          (pos,true) -> mkBreak
                       #)
                    else
                       scanSons(# do (pos,break) -> current.PT #);
                   if)
                // isKeyWord then
                   (if not isNewKeyWord or true then
                       scanSons
                       (# 
                       do (pos,break) -> current.PT; 
                          (if not isLast then ' ' -> lx.put if) 
                       #);
                   if)
                // isFunction then
                   (if inDecl then
                       scanSons
                       (# 
                       do 'in ' -> lx.puttext; 
                          (* if current.isDataItem then current is not marked
                           * as inArg since it is in the arg list
                           * Only dataitems in maipart are marked as inArg
                           *)
                          (pos,break) -> current.PT; 
                          (pos,true) -> mkBreak
                       #);
                    else
                       '(' -> lx.put;
                       scanSons
                       (# 
                       do (pos,break) -> current.PT; 
                          (if not isLast then ',' -> lx.put if) 
                       #);
                       ')' -> lx.put
                   if)
                else
                   (* unary *) 
                   scanSons(# do (pos,break) -> current.PT #);
               if);
               (*newline*)
            #);
          length:: (# do scanSons(# do current.length + 1 -> value #)#);
          HTML::
            (#
            do (if true
                // isBinary then
                // isKeyWord then
                // isFunction then
                   '(' -> lx.put;
                   scanSons
                   (# 
                   do (pos,false) -> current.HTML;
                      (if not isLast then ',' -> lx.put if) 
                   #);
                   ')' -> lx.put
                else
                   (* unary *)
               if)
            #);
          Label:: (# do 'Arguments' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          isBinary,isKeyWord,isFunction,inBraces: @boolean;
          (* inBraces: experiment with new fat comma syntax: 
           *   if(be)then{S1}else{S2}
           * {S1} and {S2} parse to Argumens with inBraces = true
           *)
          isArguments:: TrueValue;
          isNewKeyWord: @boolean; (*as in @if: ... with only >>args are used*)
          copyAST::<
            (# nArgs: ^Arguments
            do (*'arguments:'->puttext; dopt -> putline;*)
               Arguments -> nArgs[];
               scanSons(#do current.copyAST -> nArgs.append #);
               isFunction -> nArgs.isFunction;
               isKeyWord -> nArgs.isKeyWord;
               isNewKeyWord -> nArgs.isNewKeyWord;
               isBinary -> nArgs.isBinary;
               nArgs[] -> nAST[];
            #);
          scanArgs:
            (# current: ^Elm; isLast: @boolean
            do (if isKeyWord then
                   (if false then
                       'arguments:length: ' -> puttext; 
                       noOfSons -> putint; newline;
                   if);
                   scanSons
                   (# isArg: @boolean
                   do (if false then current.dopt -> puttext; ',' -> put; 
                          CURRENT.Label -> puttext; ';'->put;
                      if);
                      (if isArg then
                          current[] -> this(scanArgs).current[]; 
                          isLast -> this(scanArgs).isLast;
                          inner scanArgs
                       (*else
                          'isNotArg:' -> puttext; 
                          current.dopt -> putline*)
                      if);
                      not isArg -> isArg
                   #); (*newline*)
                else
                   scanSons
                   (# 
                   do current[] -> this(scanArgs).current[]; 
                      isLast -> this(scanArgs).isLast;
                      inner scanArgs
                   #)
               if);
            #);
          hasVirtualArgsX: BooleanValue
            (#
            do (*'Arguments:hasVirtualArgs:' -> puttext; dopt -> putline;*)
               L:
                 scanArgs
                 (# D: ^Decl 
                 do current[] -> D[];
                    (*'HasVirtualArgs: ' -> puttext; D.doPT -> putline;*)
                    (if D.isVirtual and not D.isPrimitive then
                        true -> value;
                        leave L
                    if)
                 #)
            #);
          hasVirtualArgs: BooleanValue
            (#
            do (*'Arguments:hasVirtualArgs:' -> puttext; dopt -> putline;*)
               L:
                 scanArgs
                 (# D: ^Decl 
                 do current[] -> D[];
                    (*'HasVirtualArgs: ' -> puttext; D.doPT -> putline;*)
                    (if D.isVirtual then
                        true -> value;
                        leave L
                    if)
                 #)
            #)
       enter isKeyword
       #);
     DataItem:< SuperDataItem
       (#  PT:: 
            (# 
            do (pos,break,true) -> sig.PT;
               ':' -> lx.put;
               ' ' -> lx.put;     
               label -> lx.puttext;
               ' ' -> lx.put; 
               (pos,break) -> OG.PT 
            #);
          length:: (# do sig.length + 4 + OG.length -> value #);
          Label:: 
            (# D: ^Decl
            do (if true
                // isValue and isConst then 'val' -> lab[]
                // isValue and not isConst then 'var' -> lab[]
                // not isValue and isConst then 'obj' -> lab[] 
                // not isValue and not isConst then 
                   'ref' -> lab[] ;
                   (# E: ^Exp; N: ^ObjectInvocation
                      (* ad hoc to get old syntax x: ?integer pretty-printed
                       * as x: var integer and not as x: ref integer
                       *)
                   do (if OG.IS.isEmpty and ((OG.super.last -> E[]) <> none) then
                          (if E## = ObjectInvocation## then
                              E[] -> N[];
                              (if true 
                               // 'integer' -> N.ptnID.T.equalNCS 
                               // 'char' -> N.ptnID.T.equalNCS
                               // 'boolean' -> N.ptnID.T.equalNCS then
                                  'var' -> lab[]
               if)if)if)#)if)
            #);
          HTML::
            (#
            do (if accL
                // acc_public // acc_domain then
                   (if break then
                       '<br>\n' -> lx.append;
                       pos -> indent;      
                   if);
                   (*(if accL
                    // acc_public then '<i>public</i>' -> lx.append
                    // acc_domain then '<i>domain</i>' -> lx.append
                   if);
                   ' ' -> lx.put; *)
                   (if true
                    // isInArg then
                       '<b>' -> lx.append;
                       'in ' -> lx.append;
                       '</b>' -> lx.append;
                    // isOutArg then
                       '<b>' -> lx.append;                   
                       'out ' -> lx.append;
                       '</b>' -> lx.append;                   
                   if);
                   (pos,break) -> sig.HTML; ': <b>' -> lx.append;
                   label -> lx.append;
                   '</b> ' -> lx.append;
                   (pos + 3,false) -> OG.HTML;
                   
               if)
            #);
          isDataItem:: TrueValue;
          getEntries:: (# do OG.getEntries -> (names[],entries[]) #);
          entity:: (# do OG[] -> E[] #);
          isPrimitive:: (#do OG.isPrimitive -> value #);
          isBasicPattern:: (# do OG.isBasicPattern -> value #);
          isBasicValue:: 
            (# 
            do (if traceIsBasicValue then
                   '**** Dataitem:isBasicValue: ' -> puttext; dopt -> putline
               if);
               OG.isBasicValue -> value
            #);
          isImmutable::
            (#
            do OG.IS.isImmutable -> value
            #);
          isUnique::
            (#
            do OG.IS.isUnique -> value
            #);  
          copyAST::<
            (# D: ^DataItem
            do (*'DataItem:'->puttext; sig.dopt -> puttext; ' og: ' -> puttext;
                OG.label -> putline;
                *)
               (isConst,isValue,sig.copyAST,OG.copyAST) -> DataItem -> D[];
               isInArg -> D.isInarg; isOutArg -> D.isOutArg;
               D[] -> nAST[];               
            #);          
          replaceEntity::
            (# DIx: ^DataItem
            do ('DataItem:replaceItem', sig.dopt) -> LG.TTn;
               (if true then
                   T[] -> parseDeclTextX -> (errors[],DIx[]);
                   none -> son[];
                   DIx.sig[] -> sig[] -> append;
                   DIx.OG[] -> OG[] -> append;
                else
                   (path2Module[],T[]) -> OG.replaceEntity -> errors[]
               if)
            #);
          xkind::
            (#
            do (if isConst then
                   (if isValue then
                       kinds.constVal -> K
                    else
                       kinds.constRef -> K
                   if)
                else
                   (if isValue then
                       kinds.varVal -> K
                    else
                       kinds.varRef -> K
                   if)
               if)
            #);
          skind:: 
            (# 
            do (if isConst then ': @' -> S[] else ': ^' -> S[] if)
            #);
          (*OG: ^ObjectGenerator;*)
         isValue: @boolean
       enter(isConst,isValue,sig[] -> append,OG[] -> append)
       #);

     plainPtn: (# exit 0#);
     virtualPtn: (# exit 1 #);
     furtherPtn: (# exit 2 #);
     finalPtn: (# exit 3 #);
     Pattern:< Decl
       (# label::< (# do 'pattern' -> lab[]; inner #);
          PP:: (# do label -> lx.append #);
          PT::< 
            (# 
            do (if false then 
                   (if sig.type[] <> none then
                       sig.type.id[] -> lx.puttext;
                       ':' -> lx.put;
                   if)
                else
                   (*'**** pattern: ' -> puttext; sig.id[] -> putline;*)
                   (pos,break,true) -> sig.PT; ':' -> lx.put;
               if);
               (if ptnKind
                // virtualPtn then '<' -> lx.put
                // furtherPtn then ':' -> lx.put; '<' -> lx.put
                // finalPtn then ':' -> lx.put
               if);
               inner; 
               ' ' -> lx.put;
               (pos,break) -> OG.PT
            #);
          length:: (# do sig.length + 3 + OG.length -> value #);
          HTML::
            (#
            do (if break then 
                   '<br>\n' -> lx.append;
                   pos -> indent; 
               if);
               (pos,false) -> sig.HTML;
               ':' -> lx.put;
               (if ptnKind
                // virtualPtn then '&lt' -> lx.append
                // furtherPtn then ':' -> lx.put; '&lt' -> lx.append
                // finalPtn then ':' -> lx.put
               if);
               ' ' -> lx.put;
               (pos + 3,false) -> OG.HTML
            #);          
          setNewId::
            (# T,first: ^text; N: ^name
            do (if false then
                   '**** setNewId:sig: "' -> puttext; sig.dopt -> puttext;
                   '" sig.id:"' -> puttext; sig.id[] -> puttext; '"' -> put;
               if);
               sig.id.copy -> T[]; ':' -> T.put; 
               (2,T.length) -> T.sub -> first[];
               OG.IS.scanSons
               (# D: ^Decl; inx: @integer; arg: ^text
               do L:
                    (if current.isDecl then
                        (if (current[] -> D[]).isInArg then
                            D.sig.id.copy -> arg[]; 
                            ':' -> arg.put; 
                            (if (inx + 1 -> inx) = 1 then
                                (*'arg 1: "' -> puttext; arg[] -> puttext;
                                 '"  ' -> puttext; first[] -> putline;
                                 *)
                                ':' -> T.put;
                                (if arg[] -> first.equalNCS then
                                    leave L
                            if)if);

                            arg[] -> T.append; 
                            (*' ' -> put; T[] -> puttext;*)
                    if)if)
               #);

               (1,T.length - 1) -> T.sub -> sig.id[];
               (*T[] -> (sig._a_rgs.son[] -> N[]).T[]; (* why? *)
               (if false then
                   ' setNewId:T: "' -> puttext; T[] -> puttext; 
                   '" sig.id: "' -> puttext; sig.id[] -> puttext; '"'->putline
               if)
            #);
          isPattern:: TrueObject;
          isPatternDecl:: TrueObject;
          ptnKind: @integer;
          xkind:: (# do kinds.ptn -> K (* should differ if virtual *) #);
          kind:: (# do ' ' -> ch #);
                    (*kind:: (# do ': ' -> s[] #);*)
          
          copyAST::<
            (#
            do (sig.copyAST,OG.copyAST,ptnKind) 
                 -> currentPtnKind.copyAST -> nAST[]
            #);
          isPrimitivePtn: @boolean; (* probably any primitive *)
          vDcl: ^Pattern;
          primNo:: 
            (#
            do (if (OG.IS.newBasicProp.primno -> value) > 0 then
                    (* '**** OG.ISnewBasicProp.primno: ' -> puttext;
                     value -> putint; newline;
                     '**   org: ' -> putline; OG.dopt -> putline*)
                if)
            #);
          isPrimitive:: (# do OG.IS.isPrimitive -> value #);
          isBasicPattern::
            (#
            do (if OG.IS.isEmpty then
                   (if OG.super.ATD[] <> none then
                       OG.super.ATd.isBasicPattern -> value;
                       leave isBasicPattern
               if)if);
               OG.isBasicPattern -> value
            #);
          isBasicValueCalled: @boolean;

          isBasicValue:: 
            (# DI: ^DataItem; 
            do (if traceIsBasicValue then
                   '**** pattern:isBasicValue' -> putline; dopt -> putline;
               if);
               (if OG.IS.isEmpty then
                   (if traceIsBasicValue then
                       '**** pattern:isBasicValue:is.isEmpty:  ' -> puttext; 
                       dopt -> putline;
                   if);
                   (if (OG.super.ATd[] <> none) then
                       (if OG.super.ATd.isBasicValue then
                           (if traceIsBasicValue then
                               '**   isBasicValue'->putline;
                           if);
                           true -> value;
                           leave isBasicValue
                   if)if)
               if);
               (if not isBasicValueCalled then
                   (*  For a pattern
                    *    foo(...) -> res: ? foo ...
                    * isBasicValue is called on the foo return value
                    * giving a recursive call of isBasicValue
                    *)
                   true -> isBasicValueCalled;
                   (if (getReturnDecl -> DI[]) <> none then
                       (if DI.isBasicValue -> value then
                           (if traceIsBasicValue then
                               ' return value is basic value'->putline;
                           if);
                           false -> isBasicValueCalled;
                           leave isBasicValue
               if)if)if);
               true -> isBasicValueCalled;
               OG.isBasicValue -> value;
               false -> isBasicValueCalled;
            #);
          isSubOfBasicValue::
            (#
            do (if not (OG. isBasicValue -> value) then
                   (if OG.super.ATd[] <> none then
                       OG.super.ATd.isSubOfBasicValue -> value
               if)if)
            #);
          isInteger::
            (#
            do OG.isInteger -> value
            #);
          isFloat::
            (#
            do (if false then 
                   '**** pattern:isFloat: ' -> puttext; 
                   sig.dopt -> putline; if);
               OG.isFloat -> value
            #);
          SpecialPattern:
            (# invoke:< 
                 (# rec,E: ^Exp; useReturnValue: @boolean; 
                    staticOff: @integer;
                    CC: ^CallChain;
                    adr: ^SuperAdr
                 enter(rec[],E[],useReturnValue,staticOff,CC[],adr[])
                 do inner 
                 #); 
               copyAST:<
                 (# sig: ^Signature;
                    OG: ^ObjectGenerator;
                    ptnKind: @integer;
                    ptn: ^Pattern
                 enter(sig[],OG[],ptnKind) 
                 do inner
                 exit ptn[]
                 #);
            exit this(SpecialPattern)[]
            #);
          currentPtnKind: ^SpecialPattern;
          GeneralPattern:< SpecialPattern
            (# copyAST::
                 (# 
                 do (sig.copyAST,OG.copyAST,ptnKind) -> GeneralPtnGen -> ptn[]
                 #);
            #);
          AssignmentPattern:< SpecialPattern
            (# isValueAssign: @boolean;
               copyAST::
                 (# 
                 do (sig[],OG[],ptnKind) -> assignmentPtnGen -> ptn[]
                 #);
            #);
          IndexedPattern:< SpecialPattern
            (# copyAST::
                 (# 
                 do (sig[],OG[],ptnKind) -> indexedPtnGen -> ptn[]
                 #);
            #);
          BreakPattern:< SpecialPattern
            (# copyAST::
                 (# 
                 do (sig[],OG[],ptnKind) -> BreakPtnGen -> ptn[]
                 #);               
            #);
          OtherPrimPattern:< SpecialPattern
            (# copyAST::
                 (# 
                 do (sig[],OG[],ptnKind) -> otherPrimPtnGen -> ptn[]
                 #);
            #);
          isCore:: (#do OG.IS.isCore -> value #);
          scanArgs:
            (# currentArg: ^Decl; superPtn: ^Pattern
            do (*'pattern:scanArgs:isNK:'->puttext; 
                * sig._a_rgs.isNewKeyWord -> putboolean; newline;*)
               (if true (*or sig._a_rgs.isNewKeyWord*) then
                   (* Formal args may be declared as: in A:  var integer *)
                   sig.scanSons
                   (#
                   do (if current.isDecl then
                          current[] -> currentArg[]; inner scanArgs 
                   if)#);
                   OG.IS.scanItemArgs
                   (#
                   do currentArg[] -> this(scanArgs).currentArg[];
                      inner scanArgs 
                   #)
               else (* Formal args in signature as in foo(A: ?integer, ...) *)
                   (if (OG.super <> none) and
                       not OG.super.lastHasActualArgs and
                       (OG.super.ATd[] <> none) then
                       &(OG.super.ATd[]->superPtn[]).scanArgs
                       (#
                       do currentArg[] -> this(scanArgs).currentArg[]; 
                          inner scanArgs 
                       #)
               if)if)
            #);
          getReturnOG:
            (# DI: ^DataItem
            do getReturnDecl -> DI[]
            exit DI.OG[]
            #);
          getReturnDecl:
            (# ptn: ^Pattern; DI: ^DataItem
            do L:
                 (if true then (* Use OG.getReturnDecl -> DI[] *)
                     OG.IS.scanAllItemDecls
                     (#
                     do (if currentDcl.isOutArg then
                            currentDcl[] -> DI[];
                            leave L
                     if)#);
                     (if (OG.superPtn -> ptn[]) <> none then 
                         ptn.getReturnDecl -> DI[]                         
                 if)if)
            exit DI[]
            #);

          checkVirtualArgs::
            (* Similar to checher::Pattern:check:handleVirtualBinding
             * and generator::Pattern:handleVirtualArg
             * Should be unified
             *)
            (# aArgs: [6] ^ObjectSpecification; top: @integer; Ex: ^Exp
            do L: 
                 (if not isPrimitive and (sig[] <> none) then
                     E[] -> Ex[];
                     (*'**** E: ' -> puttext; e.dopt -> putline;*)
                     E.args.scanArgs
                     (#
                     do (if (top + 1 -> top) > aArgs.range then
                            aArgs.range -> aArgs.extend
                        if);
                        current[] -> aArgs[top][];
                     #);
                     scanArgs
                     (# i: @integer; OI: ^ObjectInvocation; E: ^Exp
                     do i + 1 -> i;
                        (if i > top then
                            (* '\n *** Too many actual arguments' -> putline;
                             E.dopt -> putline; sig.doPT -> putline;*)
                            leave L
                        if);
                        HandleVirtual:
                          (if currentArg.isVirtual then
                              true -> hasVirtualArgs;
                              (if false and 
                                  ('ObjectCall' -> (Ex.father.father.label).equalNCS) then
                                  '**** FormalArg: ' -> puttext; 
                                  currentArg.doPT -> putline;
                                  '**   ActualArg: ' -> puttext; 
                                  aArgs[i].doPT -> putline; 
                                  '**   Ex.label: ' -> puttext;
                                  Ex.label -> putline;
                                  Ex.father.label -> putline;
                                  Ex.father.father.label -> putline;
                                  '**   Ex: ' -> puttext; Ex.doPT -> putline;
                                  
                                  (*Ex.doPP -> putline;*)
                              if);
                              (if aArgs[i].super.isEmpty then
                                  (* Implicit super *)
                                  (*'*** super:no:sons: ' -> puttext;
                                   aArgs[i].doPP -> putline;*)
                               else
                                  (* Exlicit super: foo{...}
                                   * Must check that foo is sub of virtual qual
                                   *)
                                  (*'*** super:Has:sons: ' -> puttext;*)
                                  (if aArgs[i].IS.isEmpty then
                                      (* ' IS empty: ' -> puttext;
                                       * current.doPT -> putline;
                                       * aArgs[i].doPT -> putline; *)
                                      L:
                                        aArgs[i].super.scanSons
                                      (# do current[] -> E[]; leave L #);
                                      (if E## = ObjectInvocation## then
                                          (*'Try: ' -> puttext;
                                           * E.doPT -> putline;*)
                                          E[] -> OI[];
                                          (if (1 -> OI.ptnId.T.inxGet) 
                                              = '#' then
                                              (*'Checker:got: ' -> puttext;
                                               OI.ptnId.doPT -> putline;*)
                                              leave HandleVirtual
                                          if)
                                      if);
                                  if);
                                 
                                  aArgs[i][] -> mkObjectGenerator -> aArgs[i][];
                              if);
                              currentArg[] -> aArgs[i].super.ATd[];
                              1 -> aArgs[i].super.pn;
                              true -> aArgs[i].super.isImplSuper;
                              (* This seems wrong - check setmplSuper
                               * where it seems we are testing for an
                               * empty IS of the declaration
                               *)
                              (if not aArgs[i].IS.isEmpty then
                                  true -> aArgs[i].super.isSingularImplSuper;
                                  (*' isSingularImplSuper=T ' -> puttext;*)
                               else
                                  (* ' CatImplSuper=T ' -> puttext;*)
                              if);                                
                              (*newline;*)
                              (*aArgs[i].adjustON;*)
                          if)
                 #)if)
            #);
          replaceEntity::
            (# P: ^Decl;
            do ('ptn:replaceEntity',sig.dopt) -> LG.TTn;
               ('ptn:with',T[]) -> LG.TTn;
               T[] -> parseDeclTextX -> (errors[],P[]);
               (if true 
                // errors[] <> none then
                   '\n!!!!! Pattern:replaceEntity:parse errors: '->putline;
                     errors[] -> putline
                // not P.isPattern then
                   '\n!!!!! Pattern:replaceEntity:must be a pattern: '->putline;
                   T[] -> putline
                else
                   none -> son[];
                   P.sig[] -> sig[] -> append;;
                   P.OG[] -> OG[] -> append
               if)                   
            #);
       enter (sig[]->append,OG[]->append,ptnKind)
       #);
     PatternGen:
       (# sig: ^Signature;
          OG: ^ObjectGenerator;
          ptnKind: @integer;
          ptn: ^Pattern
       enter(sig[],OG[],ptnKind)
       do (sig[],OG[],ptnKind) -> Pattern -> ptn[];
          inner
       exit ptn[]
       #);
     GeneralPtnGen: PatternGen
       (# 
       do ptn.generalPattern -> ptn.currentPtnKind[]
       #);
     AssignmentPtnGen: PatternGen
       (# P: ^Pattern.AssignmentPattern
       do ptn.assignmentPattern -> P[] -> ptn.currentPtnKind[];
          (ptn.primNo = vAssign_prim) -> P.isValueAssign
       #);
     BreakPtnGen: PatternGen
       (#
       do ptn.BreakPattern -> ptn.currentPtnKind[]
       #);
     IndexedPtnGen: PatternGen(#do ptn.IndexedPattern -> ptn.currentPtnKind[] #);
     OtherPrimPtnGen: PatternGen(#do ptn.OtherPrimPattern -> ptn.currentPtnKind[] #);

     ObjectSpecification: Item
       (# isPrimitive: booleanValue
            (* seems inconsistent - IS.isPrimitive is all primitives *)
            (#
            do (* perhaps return true if primNo > 0
                * I.e. return most specific primno
                *)
               (if primNo 
                // integer_prim // char_prim // boolean_prim // float_prim then
                   true -> value
                else
                   (if IS.isEmpty then
                       (if super.ATd[] <> none then
                           super.ATd.isPrimitive -> value
                       if); 
                    else
                       IS.isPrimitive -> value
               if)if)
            #); 
          isBasicPattern: BooleanValue
            (#
            do (if primNo
                // integer_prim // char_prim // boolean_prim // float_prim then
                   true -> value;
               if)
            #);
          isInteger::
            (#
            do (if primNo
                // integer_prim
                // 61 (*+ etc *)// 62 // 66 // 67 // 68 // 69 then
                   true -> value
               if)
            #);
          isFloat::
            (#
            do (if primNo
                // float_prim
                // 109 (* + *) // 110 // 112// 121 then
                   true -> value
               if)
            #);
          isUnitValueObj:< BooleanValue;
          getUnitPropShort:<
            (# U: ^Text; propNo: @integer
            enter propNo
            do inner
            exit U[]
            #);
         checkNumberConvert:
            (# I2F:< (# do inner #);
               F2I:< (# do inner #);
               D: ^DataItem; 
               srcOG: ^ObjectSpecification
            enter D[]
            do super.ATd.OG[] -> srcOG[];
               (* left is always a dataitem - D.OG.isInteger can thus be 
                * replace by D.OG.primNo = integer_prim
                *)
               (if true 
                // D.OG.isInteger and srcOG.isFloat then
                   (if false then
                       '*** convert float to int: ' -> puttext;
                       D.OG.primNo -> putint; ' ' -> put;
                       srcOG.primNo -> putint; ' ' ->put;
                       D.dopt -> puttext; ' ' -> put;
                   if);
                   F2I
                // ((D.OG.primNo = float_prim) or D.OG.isUnitValueObj) 
                   and srcOG.isInteger then
                   (if false then
                       '*** convert int2float: ' -> puttext;
                       dopt -> puttext; ' ' -> put; label -> puttext;  ' ' -> put;
                       D.OG.primNo -> putint; ' ' -> put;
                       srcOG.primNo -> putint; ' ' ->put;
                       D.dopt -> puttext; 
                       ' hasConvFactor: ' -> puttext; 
                       (super.last).hasConvFactor->putBoolean;
                       newline;
                   if);
                   (if not (super.last).hasConvFactor then
                       I2F
                   if)
               if)
            #);
          isBasicValue: BooleanValue
            (* This OG is a basic value like integer, boolean of char
             * or exp/function returning a basic value: a + b, (max(a,b), ...
             * ObjectGeneration in (the rightside)
             * C: = integer(12)   -- refer to pattern integer
             * C: = 12
             * C: = a + b         -- pattern +
             * C: = foo(e1,e2,e3) -- pattern foo
             * C: = X             -- data-item X
             * V: ? a + b         -- and simialr for variable
             * V:= foo(e1,e2,e3)  -- and assignment
             * And they may be singular
             * 1:   OG - non-singular
             * 1.1  OG - integer, boolean, char ==> true
             * 1.2     - else get possible return value
             * 2:   {...} - singular, no super
             * 2.1        - primno = integer, char, boolean
             * 3:   OG{...} - singular with super
             * 3.1          -- return value of OG
             * 3.2          -- OG not simpleValue?
             *)
            (# 
            do (if traceIsBasicValue then
                   '*** isBasicValue:primNo:' -> puttext; 
                   primNo -> putint; newline; 
                   doPT -> putline;
               if);
               (if IS.isEmpty then
                   (if traceIsBasicValue then
                       '\nsuper.ATd:'->puttext; super.ATd.dopt -> putline;
                   if);
                   (if super.ATd.isBasicValue -> value then
                       (if traceIsBasicValue then
                           ' super is basic' -> putline
                       if)
                   if)
                else
                   (if IS.primNo
                    // integer_prim
                    // 61 (* + *)
                    // 62 (* - *)
                    // char_prim
                    // boolean_prim 
                    // float_prim
                    // 109 (* + *)
                       then
                       true -> value; 
                   if);   
               if);
               (if traceIsBasicValue then
                   (if value then
                       '** is basicValue'->putline;
                    else
                       '** is not basicValue'->putline;
               if)if)
            #);
          
          (* Super is never none, super.ATd[] = none implies no super pattern*)
          
          (* isValue (in DataItem) and isValueObj (here) is also a mess
           * isValueObj should be a property of OG and Decl
           * clean-it up
           *)
          isSubOfBasicValue: BooleanValue
            (#
            do 
               (if isValueObj then
                   (* meter: integer
                    *    ...
                    *)
                   (if not IS.isEmpty then
                       super.ATd.isSubOfBasicValue -> value
                   if)
               if);
               (if false and value then
                   '**** isSubOfBasicValue:\n' -> puttext;
                   dopt -> putline
               if)
            #);
          isNonBasicValueObj: BooleanValue
            (#
            do not isBasicValue and isValueObj -> value;
               (if false then
                   '**** isNonBasicValueObj: ' -> puttext; value -> putboolean;
                   ' isBasicValue: ' -> puttext; isBasicValue -> putboolean;
                   ' isValueObj: ' -> puttext; isValueObj -> putboolean;
                   ' ' -> put; dopt->puthead;
               if)
            #);
          isValueObj: BooleanValue
            (# D: ^Decl;  P: ^Pattern; DI: ^DataItem
            do (if (super.ATd[] -> D[]) = none then
                   primNo = value_prim -> value (* Value pattern *)
                else 
                   (if true
                    // D.isPatternDecl then
                       D[] -> P[];
                       P.OG.isValueObj -> value
                    // D.isDataitem then
                       D[] -> DI[];
                       DI.isValue and not DI.isPrimitive -> value
                       (* do we mean isPrimitive or isBasicPattern? *)
               if)if);
            #);
          inValueObj: BooleanValue
            (# D: ^Decl; org: ^Items; F: ^Node; ptn: ^Pattern
            do (*'InValueObj:' -> puttext;*)               
               (if isSingularX then
                   'isSingular:' -> puttext;
                   (* {             <---- check if valueObj
                    *     foo{ ... } 
                    * }
                    *)
                else
                   (*'isPtn:' -> puttext;*)
                   (super.ATd[]-> D[]).father.father[] -> F[];
                   (if F##
                    // ObjectGenerator## then
                       (*'ObjectGen:' -> puttext;*)
                       (* super.ATd.origin *)
                       (if ((D.origin[]->org[]).theObjectGenerator).isValueObj then
                           true -> value
                        else
                           (* try super *)
                       if)
                    else
                       '\n***inValueObj: KOKS' -> puttext; 
               if)if);
               (* (if value then 'inValue:' -> puttext if);
                * doPt -> putline;
                *)
            #); 
          isConstLiteral::
            (#
            do (if IS.isEmpty then
                   (super.last).isConstLiteral -> value
               if)
            #);
          superPtn:
            (# D: ^Decl; P: ^Pattern
            do (if ((super.ATd[]-> D[]) <> none) and D.isPatternDecl then
                   D[] -> P[]
               if)
            exit P[]
            #);
          inSuper: BooleanValue
            (# lQ: ^ObjectGenerator
            enter lQ[]
            do (if false then
                   ('**** inSuper:lQ',lQ[]) -> display;
                   ('**** rQ',this(ObjectSpecification)[]) -> display;
               if);
               L:
                 (if lQ[] = this(ObjectSpecification)[] then
                     true -> value 
                  else
                     (if (lQ[] <> none) then
                         (if (lQ.primNo <> object_prim) then
                             lQ.super.getQual -> lQ[];
                             (*'**   inSuper:super:lQ:\n' -> puttext;*)
                             (if lQ[] =  none then
                                 objectDecl.getQual -> lQ[];
                                 (* 'none' -> putline*)
                              else
                                (* lQ.dopt -> puthead*)
                             if);
                             restart L;
                 if)if)if)
            #);
          returnsThis: BooleanValue
            (# qual: ^ObjectGenerator
            do getQual -> qual[];
               (*  '\n*** returnsThis: ' -> puttext;
                *  (if sig[] <> none then sig.dopt -> putline else newline if);
                *  qual.dopt -> putline;
                *)
               (this(ObjectSpecification)[] -> qual.inSuper) -> value;
               (*(if value then 'true' -> putline else 'false' -> putline if)*)
            #);
          primNo:: 
            (# 
            do (*'**** OG:primNo: ' -> puttext;
                IS.primNo -> putint;; newline;*)
               (if (IS[] <> none) then
                   (if ((IS.primNo -> value) > 0) then
               if)if);
               (if value = 0 then
                   super.primNo -> value
               if)
            #);
          isSingularX: BooleanValue
            (#
            do (not IS.isEmpty) or hasVirtualArgs -> value;
            #);
          isSingular: (* This does nyt seem correct;
                       * any ptn or DI has sig[] = none as in
                       * { ...; P1 := P2; foo; ...}
                       * Use isSingularX above
                       *)
            BooleanValue(# do sig[] = none -> value#);
          isPtnOrSingular: BooleanValue
            (* We need to check if this pattern is complete/sufficient
             * and cover all cases
             *)
            (#
            do (if super.ATd[] <> none then
                   (if not (super.ATd.isPatternDecl -> value) then
                      
                   if)
                else
                   (* no super - must be singular *)
                   not IS.isEmpty -> value
               if)
            #);
          scanActualArgs:
            (* all actual args in superchain and main 
             * Rather complicated: should be scanVirtualBindings
             * In arguments and subpatterns
             * Must be a list in each pattern keeping track of bindings
             * Like the one for VDT - start by copying from super
             * Then update for each binidng in arguments and main
             *)
            (# current: ^ObjectSpecification; OI: ^ObjectInvocation
            do (if true (* super[]  <> none*) then
                   super.last -> OI[];
                   OI.args.scanArgs
                   (#
                   do current[] -> this(scanActualArgs).current[];
                      inner scanActualArgs
                   #)
               if)
            #);
          getEntries:: (# do IS.getEntries -> (names[],entries[]) #);
          entity:: (# do IS[] -> E[] #);
          desc:: 
            (# 
            do (if false then
                   '**** ObjectSpecification:desc:\n'->puttext; dopt -> puthead
               if);
               (if IS.isEmpty and not hasVirtualArgs then 
                   super.desc -> D[]
                else
                   this(ObjectSpecification).IS[] -> D[]
               if)
            #);
          hasVirtualArgsX: BooleanValue
            (# 
            do L:
                 (if super.hasVirtualArgsX -> value then
                  else
                     IS.scanAllDecls
                     (#
                     do (if currentDcl.isVirtual and currentDcl.isInArg 
                            and not currentDcl.isPrimitive
                            then
                            true -> value;
                            leave L
                     if)#)
                 if)    
            #);
          hasVirtualArgs: BooleanValue
            (# 
            do L:
                 (if super.hasVirtualArgs -> value then
                  else
                     IS.scanAllDecls
                     (#
                     do (if currentDcl.isVirtual and currentDcl.isInArg then
                            true -> value;
                            leave L
                     if)#)
                 if)    
            #);
          isObject: booleanValue(# do primNo = object_prim -> value #);          
          collectSimple:: (# do addSimple## -> IS.collectSimple #);
          objSize:< IntegerValue;

          genClass:< 
            (# N: ^text; sig: ^Signature; super: ^Invocation; CC: ^CallChain
            enter CC[]
            do inner 
            #);
          hasItems: BooleanValue(#do not IS.isEmpty -> value #);
          OGid:
            (# T: ^text
            do (if traceId then '**** OGid: ' -> puttext;
                   (if sig[] <> none then sig.dopt -> puttext if); 
                   newline;
                   dopt -> puthead;
               if);
               (if sig[] <> none then 
                   sig.ID.copy -> T[]
                else 
                   (if singularName[] <> none then
                       singularName.copy -> T[]
                    else
                       (if super.ATd[] = none then 
                           '' -> T[]
                        else
                           Super.ATd.sig.id.copy -> T[]
                       if);
                       '#S#' -> T.append;
                       IS.qDescNo[1](*descNo*) -> T.putint;
               if)if);
               (if traceId then T[] -> putline if)
            exit T[]
            #);
          OGidv:
            (# T: ^text
            do (if IS.isEmpty and not super.hasVirtualArgs then
                   (if super.ATd[] = none then 
                       '' -> T[] (* should not happen ? *)
                    else
                       Super.ATd.sig.id.copy -> T[];
                   if)
                else 
                   (* singular *);
                   (if sig[] <> none then
                       sig.ID.copy -> T[]
                    else
                       (if singularName[] <> none then
                           singularName.copy -> T[]
                        else
                           (if super.ATd[] = none then 
                               '' -> T[]
                            else
                               Super.ATd.sig.id.copy -> T[]
                           if);
                           '#S#' -> T.append;
                           IS.qDescNo[1](*descNo*) -> T.putint;
               if)if)if);
            exit T[]
            #);            
          traceId: (# exit false #);
          OGidy:
            (# T: ^text
            do OGidx -> T[];
            exit T[]
            #);
          OGidx: (* for LLVM - but unite with OGid! *)
            (# T: ^text; dn: @integer; 
            do (if traceId then
                   '**** OGidx: ' -> puttext; 
                   (if sig[] <> none then sig.dopt -> puttext if); 
                   newline;
                   dopt -> puthead;
               if);
               (if IS.isEmpty and not super.hasVirtualArgs then
                   (if super.ATd[] = none then 
                       '' -> T[] (* should not happen ? *)
                    else
                       (if super.Atd.isVirtual then
                           '**   virtual:' -> puttext; 
                           super.ATd.dopt -> putline;
                           super.ATd.OG.OGidx -> putline;
                           (* V:< hest or V::< hest, V:: hest *)
                       if);
                       (if true and (super.ATd[] <> objectDecl[]) then
                           super.ATd.OG.OGidx -> T[];
                           leave OGidx
                        else
                           Super.ATd.sig.id.copy -> T[];
                           super.ATd.OG.IS.qDescNo[1] -> dn
                       if);
                   if)
                else (*'singular' -> putline;*)
                   (* singular *)
                   IS.qDescNo[1] -> dn;
                   (if traceId then
                       IS.qDescNo[1] -> putint; ' ' -> put;
                       (if 2 <= IS.qdescno.range then
                           IS.qDescNo[2]  -> putint;
                       if);
                       newline;
                   if);
                   (if sig[] <> none then
                       sig.ID.copy -> T[]
                    else
                       (if singularName[] <> none then
                           singularName.copy -> T[]
                        else
                           (if super.ATd[] = none then 
                               '' -> T[]
                            else
                               Super.ATd.sig.id.copy -> T[]
                           if);
                           '$S$' -> T.append; dn -> T.putint;
               if)if)if);
               (if dn = 0 then
                   '\n!!!! dn = 0: '  -> puttext;
                   T[] -> putline; 
                   '!!   father: ' -> puttext; father.dopt -> puthead
               if);
               '$' -> T.put; dn -> T.putint;
               (if traceId then T[] -> putline if)
            exit T[]
            #);
          checkVirtualSuper:
            (# checkVirtualArgs:
                 (# S: ^invocation; OI: ^ObjectInvocation
                 enter S[]
                 do (if S.ATd[] <> none then
                        S.scanSons
                        (# E: ^Exp; ptn: ^Pattern; i: @integer
                        do current[] -> E[]; i + 1 -> i;
                           (if E## = objectInvocation## then
                               E[] -> OI[]; 
                               (if OI.ATd.isPattern then
                                   OI.Atd[] -> ptn[];
                                   ptn.scanArgs
                                   (# OG: ^objectGenerator
                                   do (if currentArg.isVirtual then
                                          '**   virtualarg: ' -> puttext;
                                          currentArg.dopt -> puttext;
                                          ' actual: ' -> puttext;
                                          E.args.scanArgs
                                          (# j: @integer
                                          do (if (j + 1 -> j) = i then
                                                 current.dopt -> putline;
                    if)#)if)#)if)if)#)if)
                 #);
               doPrint:
                 (#
                 do '**** has virtual argument: ' -> puttext;
                    OGid -> putline;
                 #);
               hasVirtualObjects: @boolean;
               vDcl,binding: [4] ^Pattern;
               isObject: [4] @boolean; top: @integer;
               add:
                 (# VD: ^Pattern
                 enter VD[]
                 do (if (top + 1 -> top) > vDcl.range  then
                        vDcl.range -> vDcl.extend;
                        binding.range -> binding.extend;
                        isObject.range -> isObject.extend
                    if);
                    VD[] -> vDcl[top][];
                    true -> hasVirtualObjects
                 #);
               addB:
                 (# VB: ^Pattern
                 enter VB[]
                 do L:
                      (for i: top repeat
                           (if vDcl[i][] = VB.vDcl[] then
                               (*'**   found: ' -> puttext; 
                               vDcl[i].dopt -> putline;*)
                               VB[] -> binding[i][];
                               leave L
                      if)for)
                 #);
               print:
                 (#
                 do (if hasVirtualObjects then
                        '\n**** Has virtual objects: ' -> puttext;
                        OGid -> putline;
                        father.dopt -> putline;
                        (for i: top repeat
                             '**   VD: ' -> puttext; vDcl[i].dopt -> puttext;
                             ' VB: ' -> puttext; 
                             (if binding[i][] <> none then
                                 binding[i].doPT  -> putline
                              else
                                 ' no binding' -> putline
                        if)for);
                        newline;
                    if)
                 #);
               Ex: ^Exp
            enter Ex[]
            do (*'**** checkVirtualSuper: ' -> puttext; OGid -> puthead*)
               IS.scanAllDecls
               (# ptn: ^Pattern
               do 
                  (if currentDcl.isVirtualObjectX then
                      currentDcl[] -> add;
                      (*doPrint;
                      '**   arg: ' -> puttext;
                      currentDcl.dopt -> puthead;
                      (if ex[] <> none then
                          '** ex: ' -> puttext; ex.dopt -> putline;
                      if)*)
                  if);
               #);
               IS.scanAllDecls
               (# ptn: ^Pattern
               do  
                  (if currentDcl.isVirtual then
                      currentDcl[] -> ptn[];
                      (if ptn.ptnKind // FinalPtn // FurtherPtn then
                          (*'**   binding: ' -> puttext; 
                          currentDcl.dopt -> putline;
                          ptn.vDcl.dopt -> putline;*)
                          ptn[] -> addB
                      if)
                  if)
               #);
               (if super.ATd[] <> none then
                   super[] -> checkVirtualArgs
               if);
               print;
            #);
          addBB:< 
            (# valueOrObject:< IntegerValue
                 (# ptn: ^Pattern; 
                 enter ptn[]
                 do inner
                 #);
               checkForVirtualObject:< Object;
               checkSuperVariant:< Object;
               VD: ^Pattern; E: ^ObjectSpecification;
               vDecl: [2] ^Pattern; (* not defined? *)
               vTop: @integer;
               bindings: [2] ^ObjectSpecification;
               objectRefs: [2] ^Decl; rTop: @integer;
               scanObjectRefs:
                 (# current: ^Decl; 
                 do (for i: rTop repeat '???'->putline;
                         objectRefs[i][] -> current[];
                         inner
                    for)
                 #);
            enter(VD[],E[])
            do inner
            #);
          replaceEntity::
            (# superX: ^Invocation; 
            do ('OG:replaceEntity', sig.dopt) -> LG.TTn;
               ('OG:with:',T[]) -> LG.TTn;
               T[] -> parseItemsText -> (errors[],IS[]);
               (* Old IS is replaced by parsed IS
                * All sons must be re-built using append
                * append also defines te father of super and new IS
                *)
               (if errors[] <> none then
                   '\n**** Parse errors' -> putline;
                   errors[] -> putline;
                else
                   super[] -> superX[];
                   none -> son[];
                   superX[] -> append; 
                   IS[] -> append;
               if);
            #);
          enclosingImperative::
            (#
            do this(ObjectSpecification)[] -> imp[];
            #);
          getODorigin::
            (#
            do enclosingObjectGenerator -> OD[]
            #);
          adjustForSingularImp_X::<
            (# adjust:
                 (#
                 do L:
                      OD.scanSubTree
                      (# doIT::
                           (#
                           do (if current[] = this(objectSpecification)[] then
                                  '** got it:' -> putline;
                                  current.beginPos -> bPos;
                                  current.endPos -> ePos;
                                  leave L
                      if)#)#)
                 #);
               N: ^node
            do '\n**** AdjustForSingularImp: ' -> puttext; label -> puttext;
               ' beginPos: ' -> puttext; beginPos -> putint;
               ' endPos: ' -> puttext; endPos -> putint; newline;
               (*dopt -> putline;*)
               (if isSingular then
                   '**   singular'->putline;
                   bPos + beginPos -> bPos;
                   ePos + beginPos -> ePos;
                   getODorigin -> OD[];
                   true -> OD.doPT;
                   L: (if not (OD.father[]->N[]).isDecl then
                          OD.getODorigin -> OD[];
                          true -> OD.doPT;
                          '**   ODorg:beginPos,endPos:' -> puttext;
                          OD.beginPos -> putint; ',' -> put; OD.endPos -> putint; newline;

                          bPos + OD.beginPos -> bPos;
                          ePos + OD.beginPos -> ePos;
                       restart L
                   if);
                   (*OD.dopt -> putline*)
                   adjust
               if)
            #);
          addBinding: @ addBB;
          XaddB: @ XaddBptn;
          XaddBPtn:<
            (# offsets: [2] @integer;               
               bindingType: [2] @integer; (* 0: inner; 1: ref; 2: value *)
               bindings: [2] ^ObjectSpecification;
               top: @integer;
            do inner
            #);
          Qvariants: @ QvarPtn;
          QvarPtn:< 
            (# VarType:< SuperVariant;
               top: @integer; 
               computeVariantX:<
                 (# H:< Object; 
                    DI: ^DataItem; 
                    var: ^VarType; 
                 enter DI[] (* contextOG[]*)
                 do inner
                 exit var[]
                 #);
               findBinding:<
                 (# vDcl,binding: ^Pattern
                 enter vDcl[]
                 do inner
                 exit binding[]
                 #);
                findSuperVar:<
                 (# V,sV: ^VarType
                 enter V[]
                 do inner
                 exit SV[]
                 #)
            #);
          computeVariant:<
            (# contextOG: ^ObjectGenerator;
               var: ^VarTYpe; 
               VarType:< SuperVariant
            enter contextOG[]
            do inner
            exit var[]
            #);
          super: ^Invocation; (* Never none - super.ATd[] = none if no super *)
          IS: ^Items;
          sig: ^Signature; (* Signature if part of Pattern - none otherwise *)
          singularName: ^text;
          vDescNo: @integer;
          isCompositeValueObj,
          nonVirtualBinding,      (* Like fool(#Ko), elm::< Record, etc. *)
          isVirtualArg: @boolean; (* as in foo(...,#bar,...) *)
          (* for patterns with one argument, like 
           * sqrt{%unit "X","X/X"; in V: var Float; ... }
           * arg1Qual is the qual of the one argument of sqrt
           * And arg1Unit is the unit - arh1Qual can probably be eliminated
           *)
          arg1Qual: ^ObjectGenerator; 
          arg1Unit: ^Text
       #);
     SuperVariant: (# do inner #);
     ObjectGenerator:< ObjectSpecification
       (# PT:: 
            (# ind: @integer
            do (if false then 
                   '<'->lx.put;
                   pos -> lx.putint; ','->lx.put;
                   super.length->lx.putint; '>' -> lx.put;
               if);
               (if (*true or *)(lx.length > 0) or (super.length > 0) then 
                   (* lx.length = 0 -> do not indent first line 
                    * unless super.length > 0
                    *)
                   (pos,break) -> super.PT;(* '!' -> lx.put;*)
                   3 -> ind 
               if);
               (if not IS.isEmpty then
                   (pos + ind,true) -> mkBreak;
                   (pos + ind, length) -> block
                   (#
                   do (pos,true) -> IS.PT;
                   #);
               if)
            #);
          length :: 
            (# 
            do super.length -> value;
               (if not IS.isEmpty and (IS.son[] <> none) and (IS.son.length > 1)
                   then
                   lineWidth + 10 + value -> value
               if)
            #);
          label:: (# do 'ObjectGenerator' -> lab[] #); 
          PP:: (# do label -> lx.append #);
          HTML::
            (# oldAccL,currentAccL: @integer; done: @Boolean;
               emitAccProp:
                 (# i: @integer
                 enter i
                 do 
                    (if not done then
                        pos -> indent;
                        (if i 
                         // 1 then '<b>%public</b><br>' -> lx.append
                         // 2 then '<b>%domain</b><br>' -> lx.append
                         // 3 then '<b>%publicInSub</b><br>' -> lx.append
                        if);
                        true -> done
                    if)
                 #);
               emitBR: @boolean
            do accL -> oldAccL; 
               acc_domain -> accL;
               (pos,break) -> super.HTML;
               IS.comment[] -> comment[];
               none -> IS.comment[];

               (*(if comment[] <> none then
                '**** A: ' -> puttext; comment[] -> putline; 
                if);*)
               true -> IS.commentBefore;
               (*true -> commentBefore;*)
               printcomment;
               comment[] = none -> emitBR;
               none -> comment[];
               
               (if not IS.isEmpty then
                   IS.scanSons
                   (#
                   do 
                      (if true 
                       // current.isNewProp then
                          (if false and emitBR then
                              ' true:  '->lx.append 
                          if);
                          (pos,emitBR) -> current.HTML;
                          true -> emitBR;
                       // current.isDecl then
                          (if accL
                           // acc_public 
                           // acc_domain 
                           // acc_publicInSub then
                              (pos,emitBR) -> current.HTML;
                              true -> emitBR;
                      if)if)
                   #);
                   acc_domain -> accL;                    
                   false -> done
               if);
               oldAccL -> accL;
            #);
          isObjectGenerator:: TrueValue;
          objSize::
            (#
            do (if not IS.isEmpty then
                   IS.objSize -> value
                else
                   (if IS.superDesc[] <> none then 
                       IS.superDesc.objSize -> value
                   if)
               if);
            #);
          copyAST::<
            (# nSuper: ^Invocation; nIS: ^Items
            do (*'OG:' -> putline;*)
               super.copyAST -> nSuper[]; IS.copyAST -> nIS[];
               IS.isEmpty -> nIS.isEmpty;
               (nSuper[],nIS[]) -> ObjectGenerator -> nAST[]
            #);
          getReturnDecl:
            (# ptn: ^Pattern; DI: ^DataItem
            do L:
                 (if true then
                     IS.scanAllItemDecls
                     (#
                     do (if currentDcl.isOutArg then
                            currentDcl[] -> DI[];
                            leave L
                     if)#);
                     (if (superPtn -> ptn[]) <> none then 
                         ptn.getReturnDecl -> DI[]                         
                 if)if)
            exit DI[]
            #);
          bracketedListLength:: 
            (# do 1 -> value; super.bracketedListLength -> value #);
       enter(super[] -> append,IS[] -> append)
       #);
     ObjectCall:< ObjectSpecification
       (# PT:: (# do (pos,break) -> super.PT #);
          length :: (#do super.length -> value #);
          label:: (# do 'ObjectCall' -> lab[] #); 
          PP:: (# do label -> lx.append #);
          objSize::
            (#
            do (super.last).ATd.OG.objSize -> value;
               (if false then
                   '*** ObjCall:objSize: ' -> puttext; value -> putint;
                   ' ' -> put; dopt -> putline
               if)
            #);
          copyAST::<
            (# nSuper: ^Invocation; nIS: ^Items
            do 'OC:' -> putline;
               super.copyAST -> nSuper[]; IS.copyAST -> nIS[];
               (nSuper[],nIS[]) -> ObjectCall -> nAST[]
            #);          
       enter(super[] -> append, IS[] -> append)
       #);
     Invocation:< Apl
       (* <Exp> '.' <Exp> '.' ... *)
       (# label:: (# do 'Invocation' -> lab[] #);
          PP::(#do label -> lx.append #);
          PT:: 
            (#
            do (* pos -> lx.putint;'>'->lx.put;*)
               scanSons
               (# E: ^Exp
               do                   
                  (if (*not isLast and *) not isFirst then
                      current[] -> E[];
                      (*'.' *) E.dot -> lx.puttext
                  if);
                  (pos,break) -> current.PT; 
            #)#);
          length:: (# do scanSons(#do current.length + value -> value #)#);
          HTML::
            (#
            do scanSons
               (# E: ^Exp
               do (if not isFirst then (current[] -> E[]).dot -> lx.append if);
                  (pos,break) -> current.HTML;
               #);
               (*'<br>\n' -> lx.append*)
            #);
          last: 
            (# E: ^Exp
            do scanSons
               (# 
               do (if isLast then 
                      current[] -> E[]
                  if)
               #);
            exit E[]
            #);               
          isPrimitive: booleanValue
            (#
            do scanSons
               (# E: ^Exp
               do (if isLast then 
                      current[] -> E[]; E.isPrimitive -> value;
                  if)
               #);
            #);
          primNo: IntegerValue
            (#
            do scanSons
               (# E: ^Exp
               do (if isLast then
                      current[] -> E[]; 
                      (if E.ATD[] <> none then E.ATd.primNo-> value if);
                  if)
               #);
            #);
          copyAST::<
            (#
            do (*'Inv:' -> puttext; dopt -> putline;*)
               Invocation -> nAST[];
               scanSons(#do current.copyAST -> nAST.append #);
            #);
          desc: 
            (# D: ^Items
            do (if false then
                   '**** Invocation:desc:\n'->puttext; dopt -> puthead
               if);
               (if (ATd[] = none) and ((last).ATd[] = none)  then 
                   (last).ATd[] = none ->putboolean;
                   (if toFix then
                       (* May happen in circular definitions like
                        *    BaseUnit:< Unit
                        *    unit: Value
                        *        toBase:<
                        *            out base: var BaseUnit
                        *            ...
                        * check(BaseUnit:< Unit) implies
                        * check(Unit: Value ...) implies
                        * check(out base: var BaseUnit) implies
                        * check(BaseUnit) which is beingChecked and thus not
                        *                 completed
                        * desc is called from checker.ObjectCall
                        *)
                       '!!!! FIX:Invocation:desc:ATd is none: ' -> puttext; 
                       primNo -> putint; newline;
                       doPT -> putline; '---'->putline;
                       doPP -> putline; '---'->putline;
                       father.father.doPT -> putline;
                   if)
                else
                   (if ATd[] = none then
                       (last).ATd.desc -> D[]
                    else
                       ATd.desc -> D[]
                   if)
               if)
            exit D[]
            #);
          hasVirtualArgsX: BooleanValue
            (# 
            do
               L:
                 scanSons
                 (# E: ^Exp
                 do current[] -> E[]; 
                    (if (E.ATd[] <> none) and E.ATD.isPattern then
                        E.ATd.OG.IS.scanAllDecls
                        (#
                        do (if currentDcl.isInArg 
                               and currentDcl.isVirtual 
                               and not currentDcl.isPrimitive then
                               true -> value;
                               leave L
                 if)#)if)#)
            #);
          hasVirtualArgs: BooleanValue
            (# 
            do L:
                 scanSons
                 (# E: ^Exp
                 do current[] -> E[];
                    (if (E.ATd[] <> none) and E.ATD.isPattern then
                        E.ATd.OG.IS.scanAllDecls
                        (#
                        do (if currentDcl.isInArg 
                               and currentDcl.isVirtual then
                               true -> value;
                               leave L
                 if)#)if)#)
            #);
          lastHasActualArgs: BooleanValue
            (# lastE: ^Exp                                (* length is for PT!*)
            do ((last -> lastE[]).args[] <> none) and (lastE.args.length > 0) 
                 -> value
            #); 
          bracketedListLength:: 
            (* if BE, assume exactly one element *)
            (# do (last).bracketedListLength -> value #);
       #);
     Apl: Node
       (# PT::< 
            (# 
            do inner
            #);
          ATd: ^Decl;
          isEmpty: @boolean;
          on,pn: @integer;
          viaIncl: ^Invocation; 
          lgth: @integer; (* length of this invocation 
                             * foo  , length = 1
                             * R.foo, length = 2
                             * A + B, length = 2
                             * etc
                           *)

          isImplSuper,  (* as in V ::< { ... } *)
          isSingularImplSuper (* where super is as in V:< foo{...}
                               * and not as in V: < A *)
          : @boolean; 
          inModulePropX: @boolean;
          isThisBlockLevel: BooleanValue
            (#
            do (lgth <= 1) and (on = 0) -> value;
               (if false then
                   '**** isThisBlockLevel:length: ' -> puttext; 
                   lgth -> putint;
                   ' on: ' -> puttext; on -> putint; newline;
               if)
            #);
          getQual:<
             (# qual: ^ObjectGenerator 
             do inner;
                (if qual[] = none then
                   (if ATd[] <> none then
                       ATd.getQual -> qual[]
                    (*else apparantly none if empty super??
                       'Apl:getQual:ATd is none '->putline;
                       doPT -> putline*)
               if)if)
             exit qual[]                 
             #);
          isNameApl:: (# do this(Apl)[] -> NA[] #);
          getDeclModule::
            (# d: ^Decl;
               item: ^ModuleItem
            do (if ATd[] <> none then
                   ATd.theiModule -> to[]; 
                   ATd[] -> d[]; 
                   (if d.sort <> none then
                       (if d## <= ModuleItem## then
                           (*'MI: ' -> puttext; d.IT.doPT -> putline;*)
                           (*d.IT[] -> item[];*)
                           d[] -> item[];
                           &iModule[] -> to[];
                           item.md[] -> to.M[]; 
                        else
                           ATd[] -> dclx[]
                       if)
                    else
                       '\n****NameApl:getDeclModule:sort is none'->putline
                   if)
                else
                   (if this(node)## <= lexem## then
                       father.getDeclModule -> (to[],dclx[])
                    else
                       '\n****NameApl:getDeclModule:dcl is none'->putline;
                       doPP -> putline;
               if)if)
            #);         
          load:< (# rec: ^Exp; A: ^SuperAdr enter(rec[],A[]) do inner #);
          clear:: (# do none -> ATd[] #);
       #);
     superAdr: 
       (# rec,E: ^Exp;
          superAdj,
          off,size,descNo,valDescNo: @integer;
          isValue,isFloat,originIsValue,isAdr, isCompositeValueObj,
          srcIsVal,destIsVal,isUnique,isUnitVal: @boolean;
          loadAdr:< (#do inner #);
          load:< (#do inner #);
          store:< (# do inner #);
          print:< (# T: @text do inner exit T[] #);
       do inner 
       #);
     Exp: Apl
       (# dot:< (# T: ^text do '.' -> T[]; inner exit T[] #);
          (*isPrimitive:< BooleanValue(# do inner #);*)
          isPrimitive: BooleanValue
            (# do (if ATd[] <> none then  ATd.isPrimitive -> value if) #);
          mustBeObject:< BooleanValue;
          expUnit: ^Text;   (* computed unit of an exp *)
          unit: ^StringObj; (* unit attached to a literal *)
          copyAST::<
            (#
            do Exp -> nAST[];
               inner
            #);
          convFactor: @ real;
          desc: (# D: ^Items do ATd.desc -> D[] exit D[] #);
          pushThis:< 
            (# gdb:< debug(# do '>pushThis:'->lx.puttext; inner #);
            do gdb; inner 
            #);
          getAdr:<
            (# gdb:< debug(# do '>getAdr:'->lx.puttext; inner #);
               adr: ^SuperAdr; loadRec: @boolean
            enter adr[]
            do gdb; inner
            exit(loadRec,adr[])
            #);
          loadOrigin:< 
            (# gdb:< debug(# do '>loadOrigin:'->lx.puttext; inner #);
               superAdj: @integer; rec,E: ^Exp; CC: ^CallChain;
               orgIsVal: @boolean
            enter(superAdj,CC[])
            do gdb; 
               this(Exp)[] -> E[] -> rec[];
               inner 
            exit(rec[],E[],orgIsVal)
            #);
          loadArgs:< 
            (# gdb:< debug(# do '>loadArgs:'->lx.puttext; inner #);
               superAdj,staticOff: @integer; CC: ^CallChain; isResume: @boolean
            enter(superAdj,staticOff,CC[])
            do gdb; inner 
            exit isResume
            #);
          handleVargs:< 
            (#  stubDescNo: @integer
            enter stubDescNo
            do inner 
            #);
          invoke:< 
            (# gdb:< debug(# do '>invoke:'->lx.puttext; inner #);
               rec,E: ^Exp; useReturnValue: @boolean; 
               staticOff: @integer;
               CC: ^CallChain; adr: ^SuperAdr; isResume: @boolean
            enter(rec[],E[],useReturnValue,staticOff,CC[],adr[],isResume)
            do gdb; inner 
            #);
          args: ^Arguments;
          isCompositeValueObj: @boolean
       #);
     ObjectInvocation:< Exp
       (# PP:: (# do label -> lx.append #);
          PT:: (# do (pos,break) -> type.PT  #);
          length:: (# do type.length  -> value #);
          label:: (# do (if type[] <> none then type.label -> lab[] else
                        'anOI'->lab[] if)#);
          dot:: (# do type.dot -> T[] #);
          HTML::
            (#
            do (pos,break) -> type.HTML
            #);
          isObjectInvocation:: TrueValue;
          ptnId: ^Name;
          type: ^InvType;
          copyAST::<
            (#
            do (*'OI:' -> puttext; dopt -> putline;*)
               (ptnId.T.copy,args.copyAst) -> type.copyAST -> nAST[]
            #);
          mkOG:
            (* used with new syntax for fat comma: foo{...}
             * where foo{...} may be a subpattern or an invocation.
             * The latter requires that foo has an in parameter
             * If foo{...} appears in a pattern we assume that foo is
             * a super pattern and {...} is a mainpart
             * This may just be a preliminary solution
             *)
            (# id,rB: ^Name; IS: ^Items; 
               OGa: ^ObjectGenerator; IV: ^Invocation
            do (if args.noOfSons <> 3 then
                   '\n!!!! ObjectInvocation:mkOG: must have 3 sons!\n'
                     -> putline;
                   leave mkOG
               if);
               args.scanSons
               (# i: @integer
               do (if i + 1 -> i
                   // 1 then current[] -> id[]
                   // 2 then (current[] -> OGa[]).IS[] -> IS[]
                   // 3 then current[] -> rB[]
                  if)
               #);
               (if false then
                   '**** OI:mkOG: ' -> puttext;
                   (1,id.length - 1) -> id.T.sub -> puttext; ' ' -> put;
                   rB.T[] -> puttext; ' ' -> put;
                   '}' -> rB.T.equal -> putBoolean; newline;
                   IS.dopt -> putline; 
               if);
               ((1,id.length - 1) -> id.T.sub, Arguments) 
                 -> UnaryGen
                 -> (Invocation->IV[]).append
            exit(IV[],IS[])
            #);
          InvType: Node
            (# dot:< (# T: ^text do '.' -> T[]; inner exit T[] #);
               isOp:< (# op:^text do inner exit op[] #);
               copyAST:<
                 (# ptnId: ^Text;
                    args: ^Arguments;
                    nAST: ^ObjectInvocation
                 enter(ptnId[],args[])               
                 do (ptnId[],args[]) -> ObjectInvocation -> nAST[];
                    (* we need to copy the comment!?*)
                    inner
                 exit nAST[]
                 #);
            #);
          Unary: InvType 
            (# Label:: (# do 'ObjectInvocation_Unary' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT:: (# do (pos,break) -> ptnId.PT; 
                       (pos,break,false) -> args.PT #);
               length:: (# do ptnId.length + args.length -> value #);
               HTML:: 
                 (#
                 do (pos,break)  -> ptnId.HTML;
                    (pos,break) -> args.HTML (* weird! *)
                 #);
               isOP:: 
                 (#do(*this(ObjectInvocation).getUnit*) ''-> op[]#);
               copyAST::<
                 (#
                 do nAST.unary -> nAST.type[] 
                 #)
            #);
          Binary: InvType
            (# Label:: (# do 'ObjectInvocation_Binary' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT::
                 (#
                 do (pos,break) -> ptnId.PT; ' '-> lx.put;
                    (pos,break,false) -> args.pt
                 #);
               length:: (# do ptnId.length + 1 + args.length -> value #);
               HTML:: (# do (pos,break) -> ptnId.HTML #);
               copyAST::
                 (#
                 do nAST.Binary -> nAST.type[]
                 #); 
               dot:: (# do ' ' -> T[] #);
               isOp::
                 (#
                 do (if true
                     // '^' -> ptnID.T.equal then '^' -> op[]
                     // '*' -> ptnID.T.equal then '*' -> op[]
                     // '/' -> ptnID.T.equal then '/' -> op[]
                     // '-' -> ptnID.T.equal then '-' -> op[]
                     // '+' -> ptnID.T.equal then '+' -> op[]
                    if)
                 #)
            #);
          Function: InvType
            (# label:: (# do 'ObjectInvocation_Function' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT:: (# do (pos,break) -> ptnId.PT; (pos,break,false) -> args.PT #);
               HTML:: 
                 (# 
                 do (pos,break) -> ptnId.HTML;
                    (pos,false) -> args.HTML
                 #);
               length:: (#do ptnId.length + args.length -> value #);
               copyAST::
                 (#
                 do nAST.Function -> nAST.type[]
                 #)
            #);
          KeyWord: InvType
            (# Label:: (# do 'ObjectInvocation_KeyWord' -> lab[] #);
               PP:: (# do Label -> lx.append #);
               PT:: 
                 (# 
                 do (* first element in sons is receiver - may be empty *)
                    args.scanSons
                    (# no: @integer; even: @boolean; n: ^Name
                    do no + 1 -> no;
                       (if true
                        // no = 1 then (* first keyword *)
                           current[] -> N[];
                           (if (1->N.T.inxGet) = '%' then
                               (*N.T[] -> puttext; ' ' -> put;*)
                               ('@',1) -> N.T.inxPut;
                               (*N.T[] -> puttext; ',' -> put;*)
                           if);
                        // (no > 1) and not even then (* 2,3, ... keyword *)
                           current[] -> N[];
                           (if (1->N.T.inxGet) = '%' then
                               (*N.T[] -> puttext; ' ' -> put;*)
                               (':',1) -> N.T.inxPut;
                               (1,N.T.length - 1) -> N.T.sub -> N.T[];
                               (*N.T[] -> puttext; ',' -> put;*)
                           if);
                       if);
                       not even -> even
                    #);
                    (if (pos + length) < lineWidth then  
                        (* 'KW: < lineWidth: pos: '-> puttext; pos -> putint;
                         ' length: ' -> puttext; length -> putint ; newline;*)
                        (pos,false,false) -> args.PT
                     else                            
                        (* 'KW: > lineWidth:pos: ' -> puttext; pos -> putint;
                        ' length: '->puttext; length -> putint; newline;*)
                        args.scanSons
                        (# no: @integer; even: @boolean; doBreak: @boolean
                        do no + 1 -> no; 
                           (*current.label -> puttext; ' ' -> put;*)
                           (*pos -> lx.putint;':'->lx.put;*)
                           (if true
                            // no = 1 then 
                               (* first keyword: 
                                *    if '@foo:' then ':' is not printed by name.doPT
                                * we should perhaps avoid the ':' in '@foo:'!?
                                *)
                               (pos,false) -> current.PT;
                            // (no > 1) and not even then (* 2,3, ... keyword *)
                               (if not doBreak then
                                   pos > lineWidth -> doBreak
                               if);
                               (pos,doBreak) -> mkBreak0;
                               (pos,true) -> current.PT;
                               true -> doBreak;
                            else (* arguments *)
                               (* (pos ,true) -> mkBreak0;*)
                               (pos,doBreak) -> current.PT;
                           if);
                           (if not isLast then ' ' -> lx.put if);
                           not even -> even
                        #);
                        (*newline*)
                    if)            
                 #);
               length:: 
                 (# do args.scanSons(# do current.length + value -> value #)#);
               HTML:: (# do ptnId.T[] -> lx.append #); 
               copyAST::
                 (#
                 do nAST.KeyWord -> nAST.type[]
                 #)
            #);
          savedOGS: ^SuperOGsequence; savedOI: ^ObjectInvocation
       enter(name -> ptnId[] -> append,args[] -> append)
       #);
     OI_Generator:
       (# ptnId: ^Text;
          args: ^Arguments;
          OI: ^ObjectInvocation
       enter(ptnId[],args[])
       do (*(if lex.skipcomment.comment.length > 0  then 
              '*** got comment:C:' -> putline;
              lex.skipcomment.comment[] -> putline
          if);*)
          (ptnId[],args[]) -> ObjectInvocation -> OI[];
          (if OI.ptnID.comment[] <> none then
              (* '*** got comment:D:' -> putline;
               OI.ptnID.comment[] -> putline;*)
               OI.ptnID.comment[] -> OI.comment[];
               none -> OI.ptnID.comment[]
           if);
          inner
       exit OI[]
       #);
     UnaryGen: OI_Generator(#do OI.unary -> OI.type[] #);
     BinaryGen: OI_Generator(# do OI.Binary -> OI.type[] #);
     FunctionGen: OI_Generator(# do OI.Function -> OI.type[] #);
     KeyWordGen:  OI_Generator(# do OI.KeyWord -> OI.type[] #);
     
     IfThen:< Exp
       (# Label:: (#do 'IfThen' ->  lab[] #);
          PP:: (# do Label -> lx.append #);
          length:: (# do 4 + 7 + cond.length + thenPart.length -> value #);
          PT::
            (#
            do '@if ' -> lx.puttext; 
               (pos,break) -> cond.PT;
               ' :then ' -> lx.puttext;
               (pos,break) -> thenPart.PT;               
            #);
          cond: ^ObjectSpecification;
          thenPart: ^objectSpecification;            
       enter(cond[] -> append, thenPart[] -> append)
       #);
     IfThenElse:< Exp
       (# Label:: (#do 'IfThenElse' ->  lab[] #);
          PP:: (# do Label -> lx.append #);
          length:: 
            (# 
            do 4 + 7 + 6 + cond.length + thenPart.length + elsePart.length
                 -> value 
            #);
          PT::
            (#
            do '@if ' -> lx.puttext; 
               (pos,break) -> cond.PT;
               ' :then ' -> lx.puttext;
               (pos,break) -> thenPart.PT; 
               (pos,true) -> mkBreak;
               ':else ' -> lx.puttext;
               (pos,break) -> elsePart.PT;   
            #);
          cond: ^ObjectSpecification;
          thenPart,elsePart: ^objectSpecification;            
       enter(cond[] -> append, thenPart[] -> append,elsePart[] -> append)
       #);
     BracketedExp:< Exp
       (# Label:: (# do 'BracketedExp' -> lab[] #);
          PP:: (# do Label -> lx.append #);
          PT:: 
            (# 
            do '(' -> lx.put; 
               (if noOfSons = 1 then
                   (pos,break) -> IV.PT;
                else
                   scanSons
                   (#
                   do (pos,break) -> current.PT;
                      (if not isLast then ',' -> lx.put
               if)#)if);
               ')' -> lx.put 
            #);
          bracketedListLength:: (# do noOfSons -> value #);
          length:: (# do 2 + IV.length -> value #);
          copyAST::
            (#
            do IV.copyAST -> BracketedExp -> nAst[]
            #);
          IV: ^Invocation; 
       enter IV[] -> append
       #);
     Lexem: Exp
       (# T: ^text;
          PU: 
            (#
            do (if unit.T[] <> none then
                   '"' -> lx.put;
                   unit.T[] -> lx.append;
                   '"' -> lx.put
               if)
            #)
       enter T[]
       #); 
     findFilePath:
       (# apl,dcl,N: ^text;
          getCh:
            (# T: ^text; ch: @char; lastSep: @integer;
            do T.setPos;
               L: 
                 (if not T.eos then
                     T.get -> ch; 
                     (*'"'->put; ch -> put; '"'->put;*)
                     (if ch //  '/' // '\\' then
                         T.pos -> lastSep
                     if);
                     suspend;
                     restart L
                 if);
               0 -> ch;
               suspend
            exit ch
            #);
          aplScanner,dclScanner: @ | getCh;
          appendFile:
            (# P,T,S: ^text; inx: @integer
            enter P[]
            do (if trace then
                   '**   appendFile: ' -> putline;
                   P[] -> putline
               if);
               0 -> inx;
               P.scanAll
               (# i: @integer
               do i + 1 -> i;
                  (if ch // '/' // '\\' then i -> inx if)
               #);
               P.copy -> T[];
               '/' -> T.put;
               (inx + 1,P.length) -> P.sub -> S[];
               (if trace then
                   '**   file: ' -> puttext; inx -> putint;
                   ' ' ->put; P.length -> putint; newline;
                   S[] -> putline
               if);
               S[] -> T.append;
               '.html' -> T.append;
            exit T[]
            #);
          cha,chd: @char; up: @integer; aplS,dclS,link: ^text;
          trace: @boolean; org: ^Items; nm: ^Name
       enter(nm[],apl[],dcl[],N[])
       do (if false then
              '**** findPath:N: '-> puttext; N[] -> putline;
              '**   apl: ' -> putline; apl[] -> putline; 
              '**   dcl: ' -> putline; dcl[] -> putline;
          if);
          apl.copy -> aplScanner.T[];
          dcl.copy -> dclScanner.T[];
          (if false and ('string'->N.equalNCS) -> trace then
              '\n**** name: ' -> putline;
              N[] -> putline;
              aplScanner.T[] -> putline;
              dclScanner.T[] -> putline
          if);
          1 -> cha -> chd;
          L:
            (if (cha = chd) 
                and (cha <> 0) and (chd <> 0)
                then 
                aplScanner -> cha;
                dclScanner -> chd;
                (if false and trace then
                    cha -> put; ',' -> put; chd -> put; '.' -> put;
                if);
                restart L 
            if);
          (if trace then newline; if);
          (if trace then
              '****** ' -> puttext;
              cha -> put; ' ' -> put; chd -> put; ' ' -> put;
              '('->put; aplScanner.T.pos -> putint; 
              ',' -> put; apl.length -> putint;
              ', cha=' -> puttext; cha -> putint;
              ')'->put;
          if);
          (aplscanner.lastSep + 1 ,apl.length) 
            -> apl.sub 
            -> appendFile
            -> aplS[];
          '' -> link[];
          (if (cha = 0) then
              (if chd <> 0 then
                  '**** inconsistence: ' -> puttext; 
                  N[] -> putline;
                  apl[]->putline;
                  dcl[] -> putline;
                  (*(NM.origin[] -> org[]).encOG.dopt -> putline;*)
              if)
           else
              (aplscanner.lastSep + 1 ,dcl.length) 
                -> dcl.sub 
                -> appendFile
                -> dclS[];
              (if false then
                  '**** ' -> puttext; 
                  aplScanner.T.pos -> putint; 
                  ',' -> put; aplscanner.lastSep -> putint;
                  ',' -> put; apl.length -> putint; newline;
                  apl[] -> putline;
                  aplS[] -> putline; 
                  
                  'dcl: ' -> putline;
                  dcl[] -> putline;
                  dclS[] -> putline
              if);
              aplS.scanAll
              (#
              do (if ch = '\\' then up + 1 -> up if)
              #);
              (for i: up + 1 repeat '..\\' -> link.append for);
              dclS[] -> link.append;
          if);
          (if trace then 
              '**** ' -> puttext; 
              aplScanner.T.pos -> putint; 
              ',' -> put; aplscanner.lastSep -> putint;
              ',' -> put; apl.length -> putint; newline;
              '**   apl:\n' -> puttext; apl[] -> putline;
              aplS[] -> putline;                   
              '**   dcl: ' -> putline;
              dcl[] -> putline;
              dclS[] -> putline;
              'link: ' -> putline;
              link[] -> putline; 

              false -> trace
          if);
          '<a href="' -> lx.append; link[] -> lx.append;
          '#' -> lx.append;
          N[] -> lx.append;
          '">' -> lx.append;
          '<i style="color:DodgerBlue;">' -> lx.append;
          N[] -> lx.append;
          '</i></a>' -> lx.append
       exit link[]
       #);
     Name:< Lexem
       (# PT:: 
            (# 
            do (if false and ('SSS'->T.equalNCS) or printOffOn then
                   '(' -> lx.put; on -> lx.putint; ')' -> lx.put 
               if);
               (if (T.length -> T.inxGet) = ':' then
                   (1,T.length - 1) -> T.sub -> lx.append
                else
                   T[] -> lx.append;
               if);
            #);
          length:: (#do  T.length -> value #);
          label:: (# do 'name:' -> lab[] #);
          PP:: 
            (# 
            do label -> lx.append; ' ' -> lx.put; 
               '"' -> lx.put; T[] -> lx.append; '"' -> lx.put
            #);
          HTML::
            (# to: ^iModule; dclx: ^Decl; M: ^Module
            do (*'name: ' -> puttext; T[] -> putline; *)
               
               (if ATd[] <> none then 
                   (if false then 
                       ' ATd:' -> putline;
                       ' [ATd: <br>' -> lx.append;
                       (theModule->M[]).pathToModuleFN -> lx.append;
                       '<br>' -> lx.append;
                   if);
                   getDeclModule -> (to[],dclx[]);
                   (if false then
                       '\n**** getDeclModule:to.name:  ' -> puttext;
                       (if to[]<> none then 
                           to.name -> puttext; 
                        else
                           'to:???' -> lx.append;
                       if); 
                       '\nto.pathToFN: ' -> puttext;
                       to.pathToFN -> putline;
                   if);
                   (if ((theModule->M[]).pathToModuleFN <> none)
                       and (to.pathToFN <> none) then
                       (this(name)[],
                       (theModule->M[]).pathToModuleFN
                       ,to.pathToFN,T[])
                         -> findFilePath;
                   if);
                   (if false then ']<br>' -> lx.puttext; if);
                else
                   (* some names as in %module BufferModule
                    * are currently not checked
                    *)
                   T[] -> lx.append;
               if)
            #);
          copyAST:: (#do T.copy -> Name -> nAST[] #)
       #);
     Const:< Lexem
       (# PT:: (# do T[] -> lx.append; PU  #);
          length:: (#do  T.length -> value #);
          Label:: (# do 'ConstLiteral' -> lab[] #);
          PP:: (# do Label -> lx.append; ' ' -> lx.put; T[] -> lx.append #);
          isConstLiteral:: TrueValue;
          copyAST:: 
            (# L: ^Lexem 
            do T.copy -> Const -> nAST[] -> L[]; unit[] -> L.unit[]
            #)
       #);
     FloatConst:< Lexem
       (# PT:: (# do T[] -> lx.append; PU #);
          length:: (#do  T.length -> value #);
          Label:: (# do 'FloatLiteral' -> lab[] #);
          PP:: (# do Label -> lx.append; ' ' -> lx.put; T[] -> lx.append #);
          isConstLiteral:: TrueValue;
          copyAST:: 
            (# L: ^Lexem 
            do T.copy -> FloatConst -> nAST[] -> L[]; unit[] -> L.unit[]
            #)
       #);
     CharObj:< Lexem
       (# PT::  (# do '\'' -> lx.put;  T[] -> lx.append; '\'' -> lx.put #);
          length:: (#do  T.length + 2 -> value #);
          label:: (# do 'Char:' -> lab[] #);
          PP:: 
            (# 
            do label -> lx.append; ' ' -> lx.put;
               '\''->lx.put; T[] -> lx.append; '\'' ->lx.put
            #);
          isConstLiteral:: TrueValue;
          copyAST:: (#do T.copy -> CharObj -> nAST[] #)
       #);     
     StringObj:< Lexem
       (# PT::< (# do '"' -> lx.put;  T[] -> lx.append; '"' -> lx.put #);
          length:: (#do  T.length + 2 -> value #);
          Label:: (# do 'String:' -> lab[] #);
          PP:: (# do label -> lx.append; ' ' -> lx.put; T[] -> lx.append #);
          HTML:: (#do '"' -> lx.put;  T[] -> lx.append; '"' -> lx.put #);
          isStringLiteral:: TRueValue;
          copyAST:: (#do T.copy -> StringObj -> nAST[] #)
       #);
     argBuf:  @
       (# init: (# do none -> head[] -> last[] #);
          add:
            (# A: ^Arguments; S: ^Scope; next: ^add;
               print:
                 (# N,M: @integer
                 enter N
                 do (if false then
                        (if A.noOfSons > 0 then
                            '**** argBuf:elm:'->puttext; A.dopt -> putline;
                        if);
                        (if next[] <> none then N + 1 -> next.print -> M else N ->M if)
                    if);
                    (if false and (N = 0) then 
                        '**  argBuf:noOfElm='->puttext; M -> putint; newline if);
                 exit M
                 #);
            enter(A[],S[])
            do (if false then
                   '**** argBuf:add: ' -> puttext; A.label -> putline;
                   A.dopt -> putline;
                   ('**   scope:',S[]) -> putPT;
                   (if head[] <> none then head.print if)
               if);
               (if A.noOfSons > 0 then
                   (if head[] = none then
                       this(add)[] -> head[] -> last[]
                    else
                       this(add)[] -> last.next[] -> last[]
                   if);
                   head.print
               if)
            #);
          head,last: ^add;
          scan:
            (# current: ^Add;
            do head[] -> current[];
               Loop: 
                 (if current[] <> none then
                     (if false and (current.A.noOfSons > 0) then
                         '**** argBuf:scan: ' -> puttext; current.A.dopt -> putline;
                     if);
                     inner scan;
                     current.next[] -> current[];
                     restart Loop
                 if);
            #); 
          check:
            (# H: ^Add;
            do head[] -> H[];
               none -> head[] -> last[];
               Loop: 
                 (if H[] <> none then
                     (if false then
                         '**** argBuf:check:\n' -> puttext; H.A.dopt -> putline;
                         ('**   scope:',H.S[]) -> putPT
                     if);
                     (none,H.S[],H.S[],true)  -> H.A.check;
                     H.next[] -> H[];
                     restart Loop
                 if);
               (if head[] <> none then restart check if)
            #);          
          remove:
            (# A: ^Arguments; pred,oldHead: ^add
            enter A[]
            do (if false then
                   '**** argBuf:remove: ' -> puttext; A.label -> putline;
                   A.dopt -> putline;
                   (if head[] <> none then
                       head.print;
                    else
                       '!!!! head is none'->putline
                   if)
               if);
               (if (A.noOfSons > 0) and (head[] <> none) then
                   (if A[] = head.A[] then 
                       (if false then
                           '**** argBuf:remove:found:head: ' -> putline; 
                           A.dopt -> putline;
                       if);
                       head[] -> oldHead[];
                       head.next[] -> head[]; 
                       (if last[] = oldHead[] then head[] -> last[] if);
                       (if false then
                           (if head[] <> none then head.print if)
                       if)
                    else
                       head[] -> pred[];
                       L:
                         scan
                         (#
                         do (if (A[] = current.A[]) then
                                (if false and (A.noOfSons >= 0) then
                                    '**** argBuf:remove:found: ' -> putline; A.dopt -> putline;
                                if);
                                current.next[] -> pred.next[];
                                (if last[] = current[] then 
                                    (* pred.next[] = none *)
                                    pred[] -> last[]
                                if);
                                head.print;
                                leave L
                            if);
                            current[] -> pred[];
                         #)
               if)if)
            #)
       #);

     CallChain:
       (# elm:
            (# OG: ^ObjectGenerator;
               next: ^elm;
               valueOrObject: IntegerValue
                 (# ptn: ^Pattern
                 enter ptn[]
                 do ptn[] -> OG.addBinding.valueOrObject -> value;
                    (if (value = 0) and (next[] <> none) then
                        ptn[] -> next.valueOrObject -> value
                    if)
                 #);
            do
            #);
          top: ^elm;
          ValueOrObject: IntegerValue
            (# ptn: ^Pattern
            enter ptn[]
            do '*** CallChain:valueOrObject: "' -> puttext;
               ptn.doPT -> puttext; '"' -> put;
               (if ptn.isVirtualObject then
                   ' isVirtual Object\n'->puttext;
                   (if top[] <> none then
                       ptn[] -> top.valueOrObject -> value
                    else
                       'Top none'->putline
                   if)
               if);
               newline
            #);
          add:
            (# OG: ^ObjectGenerator; CC: ^CallChain; E: ^Elm               
            enter OG[]
            do &CallChain[] -> CC[];
               &elm[] -> E[];
               OG[] -> E.OG[];
               top[] -> E.next[];               
               E[] -> CC.top[]
            exit CC[]
            #)
       #);
     mkObjectGenerator:
       (# Itm: ^Item;
          itmFather: ^Arguments;
          IV: ^Invocation;
          IT: ^Items;
          OG,OGx: ^ObjectGenerator;              
       enter Itm[]
       do (if false then
              'mkObjectGenerator: ' -> putline; Itm.doPT -> putline;
          if);
          Itm.father[] -> ItmFather[];          
          (if false then
              'Father:'->putline; itmFather.doPT -> putline;
          if);
          Invocation -> IV[];
          true -> IV.isEmpty;
          Items -> IT[];
          Itm[] -> IT.append;
          (IV[],IT[]) -> ObjectGenerator -> OG[] ;          
          itmFather[] -> OG.father[]; (* OLM: 28.02.2020 
                                       * otherwise null ref in qenv TST *)
          
          ReplaceNode:
            (* This code should be a general op in compiler_IF: replaceNode *)
            itmFather.scanSons
            (# pred: ^Node
            do (if false then
                   ':label:'->puttext; current.label -> puttext;
                   ' ' -> put; current.doPT -> putline;
               if);
               (if current[] = Itm[] then (* 'Found'->putline;*)
                   (if pred[] = none then
                       (* 'mkObjectGenerator: pred is none ' ->putline;
                        * itmFather.doPT -> putline;
                        * Itm.doPT -> putline;*)
                       OG[] -> itmFather.son[];
                   else                       
                       OG[] -> pred.next[];                      
                   if);
                   current.next[] -> OG.next[];
                   none -> Itm.next[];
                   leave ReplaceNode                  
               if);
               current[] -> pred[]
            #);
          (* 'label:'->puttext;
           itmFather.father.father.father.label -> puttext; ' ' -> put;
           itmFather.father.father.father.doPT -> puttext; ' ' -> put;*)

          (if true then
              itmFather.enclosingObjectGenerator -> OGx[]
           else
              itmFather.father.father.father[] -> OGx[];              
          if);
          OGx.IS[] -> OG.setUpOrigin;
          (if false then
              OG.doPT -> putline; itmFather.doPT -> putline
          if)
       exit OG[]
       #);

     mkOGforOI:
       (# OI: ^ObjectInvocation; OG: ^ObjectGenerator; 
          super: ^Invocation; IS: ^Items;
          ocFather: ^Node; sons: ^node; N: @Node
       enter OI[]
       do (if true  then 
              '****  mkOGforOI: ' -> putline; OI.dopt -> puthead;
          if);
          OI.args[] -> argBuf.remove;
          OI.father.father.father[] -> ocFather[];
          Invocation ->  super[];
          OI[] -> super.append;
          Items -> IS[];
          true -> IS.isEmpty;
          (super[],IS[]) -> ObjectGenerator -> OG[];
          ocFather[]  -> OG.father[];
          ocFather.son[] -> N.son[];
          OG[]  -> ocFather.append;
          (if true then
              '**    GOT:OG:'->putline; OG.dopt -> puthead
          if);
       exit OG[]
       #);
     convertObjectCallToGenerator:
       (# OC: ^ObjectCall; OG: ^ObjectGenerator; IS: ^Items;
          ocFather: ^Node; sons: ^node; N: @Node
       enter OC[]
       do (if false  then 
              '**** convertCG: ' -> putline; OC.dopt -> puthead;
          if);
          OC.super.scanSons
          (# E: ^Exp
          do (current[] -> E[]).args[] -> argBuf.remove
          #);
          OC.father[] -> ocFather[];
          Items -> IS[];
          true -> IS.isEmpty;
          (OC.super[],IS[]) -> ObjectGenerator -> OG[];
          ocFather[]  -> OG.father[];
          ocFather.son[] -> N.son[];
          none -> ocFather.son[];
          N.scanSons
          (#
          do (if current[] = OC[] then
                 OG[] -> ocFather.append
              else
                 current[] -> ocFather.append
             if)
          #);
       exit OG[]
       #);
     
     parseDeclTextX:< (* see also binding i parser.bet *)
       (# inn: ^text; errors: ^Stream; DI: ^Decl
       enter inn[]          
       do inner
       exit(errors[],DI[])
       #);     
     parseItemsText:<
       (# inn: ^text; errors: ^Stream; IS: ^Items
       enter inn[]          
       do inner
       exit(errors[],IS[])
       #);
     pDirModuleX:<
       (# pathToDir,moduleDir: ^text; (* name of direcory with BETA module *)
          md: ^Module
       enter(pathToDir[],moduleDir[])
       do inner;
       exit md[]
       #);
     objectDecl,noneDecl,errorDecl,IndexedDecl
     ,thisDecl,thisCoreDecl,coreDecl,resumeDecl,ifThenDecl: ^Decl;
     floatDecl,
     charDecl,booleanDecl,
     integerDecl,StringDecl: ^Pattern; 
     
     locateWorld: @
       (# trace: (# exit false #);
          entries: [8] ^text; top,worldPos: @integer;          
          init:< (# do 0 -> top -> worldPos #);
          deComp:
            (# last,worldPosInCWD: @integer
            do (* CWD = .../beta/.../MiniSystem/.../BETAworld/.../XXX *)
               dirCh -> CWD.put;
               CWD.setPos;
               CWD.scanAll
               (# pos: @integer; N: ^text
               do pos + 1 -> pos; 
                  (if ch // '/' // dirCh then 
                      (if (top + 1 -> top) > entries.range then
                          entries.range -> entries.extend 
                      if);
                      (if pos > 1 then 
                          (last+1,pos-1) -> CWD.sub -> N[] -> entries[top][];
                          (if 'BETAworld' -> N.equalNCS then
                              top -> worldPos;
                              pos -> worldPosInCWD;
                          if)
                      if);
                      pos -> last;
                  if)
               #);
               (if trace then
                   'Entries: ' -> putline;
                   (for i: top repeat entries[i][] -> putline for);
               if);
               (if worldPos = 0 then '\n*** BETAworld not found' -> putline if);
               (1,worldPosInCWD - 1) -> CWD.sub -> topPath[];
               topPath.copy -> path.push;
               dirCh -> topPath.put;
               topPath.copy -> pathToBetaWorld[];
               (if trace then
                   'pathToWorld: ' -> puttext; topPath[] -> putline;
               if);
               'BETAworld.xbeta' -> topPath.append;
               (if trace then
                   'Module: ' -> puttext; 
                   (last+1,CWD.length) -> CWD.sub -> putline;
                   'topPath: ' -> puttext;  topPath[] -> putline;
               if)
            #);
          CWD: ^Text;
          topPath: ^text; (* Path to .../BETAworld/BETAworld.xbeta *)
          fullPath: @boolean; (* true: FN is a full path 
                               * false: FN is just the file name *)
          FN: ^text; (* path to /file name of module to be executed *)
       enter(fullpath,FN[])
       do init;
          (if fullPath then (* from miniEnv *)
              '\n**** From minienv:' -> putline; FN[] -> putline;
              true -> withPos;
              FN[] -> getCWD -> CWD[];
           else
              false -> withPos;
              getCurrentDir -> CWD[];
          if);
          deComp; (* topPath = ' ...../BETAworld/BETAworld.bet'*)
       exit topPath[]
       #);
     addSigFromDI:
       (# MI: ^ModuleItem;
       enter MI[]
       do MI.MD.sig[] -> MI.sig[]; (* clumsy*)
       exit MI[]
       #);
     lex: ^lexer;
     cd: ^ObjectCode;
     newFatComma,pNewFatCommaFile: @boolean
  do (*true -> traceAlloc;*)
     &ObjectCode[] -> cd[];
     inner
  #)

