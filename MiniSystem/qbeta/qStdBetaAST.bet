ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaLexer';
INCLUDE 'qStdBetaTopAST';
INCLUDE '~beta/containers/list';  
--Lib:attributes--
StdBetaAst: StdBetaTopAST
  (# (* We should perhaps also define lexems to be used by both ASTs *)
     LexerType:: StdBetaLexer;
     traceChecker: @Boolean;
     type: 
       (# isValue:< booleanValue;
          isRef:< booleanValue;
          isStrucRef:< booleanValue;
          isNone:< booleanValue;
          isPrimitive:< booleanValue;
          isSingle:< booleanValue;
          theDesc:< (# D: ^node do inner exit D[] #);
          print:<  (# out: @text do inner exit out[] #);
          append:<
            (# TP,returnTP: ^type
            enter TP[]
            do (if TP[] <> none then 
                   inner 
                else
                  this(type)[] -> returnTP[]
               if)
            exit returnTP[]
            #);
          appendToList:<
            (# TPx,returnTP: ^type
            enter TPx[]
            do inner
            exit returnTP[]
            #);
          match:< integerValue
            (# left: ^type
            enter left[]
            do inner
            #);     
          matchList:< integerValue
            (# TPx: ^Type
            enter TPx[]
            do inner
            #);
       do inner 
       exit this(type)[]
       #);
     StdBetaNode: StdBetaTop
       (# vNode::< StdBetaNode;
          SuperScope:: StdBetaNode; (*ObjectDesc;*)
          isVirtualPtn:< BooleanValue;
          isNull: BooleanValue(#do noOfSons = 0 -> value #);
          setUpOrigin::<
            (# done: @boolean
            do inner;
               (if not done then
                   scanSons(# do origin[] -> current.setUpOrigin #)
               if)
            #); 
          theDesc:<
            (# aDesc: ^ObjectDesc
            do (*label->dumpT; ':theDesc'->dumpTN;*)
               inner;
               (if (aDesc[] = none) and (theEncOD <> objDesc[]) then
                   '\n!!!! Potential compiler error:' -> putline;
                   '!!   The virtual theDesc returns none' -> putline;
                   label -> putline;
                   doPT -> putHeadN;
                   '!!   enclosing objectDesc:'->dumpT;
                   (theEncOD).dopt -> putheadN
               if)
            exit aDesc[]
            #);
          theEncOD:
            (# aDesc: ^ObjectDesc; F: ^StdBetaNode
            do father[] -> F[];
               loop:
                 (if F## = ObjectDesc## then
                     F[] -> aDesc[];
                  else
                     F.father -> F[];
                     (if F[] <> none then
                         restart loop
                 if)if)
            exit aDesc[]
            #);
          isChecked,beingChecked: @boolean;
          check:< 
            (# done: @Boolean
            do (if beingChecked then
                   '**** check:beingChecked:true:'->dumpt; dopt -> putheadN;
                else
                   true -> beingChecked;
                   inner;
               if);
               (if not done then
                   scanSons(#do current.check
               #)if);
               false -> beingChecked; true -> isChecked
            #); 
          searchBetaDecl:<
            (# N: ^Text; ATd: ^BetaNameDecl
            enter N[]
            do (*'**** SearcBetaDecl:'->dumpt; N[]->putline;*)
               inner searchBetaDecl
            exit ATd[]
            #);
          localSearch:<
            (# NA: ^Name; dcl: ^BetaNameDecl; pn: @integer
            enter NA[]
            do inner
            exit(dcl[],pn)
            #);
          superSearch:<
            (# NA: ^Name; dcl: ^BetaNameDecl; pn: @integer
            enter NA[]
            do inner
            exit(dcl[],pn)
            #);
          search:<
            (# NA: ^Name; dcl:  ^BetaNameDecl; pn,on: @integer
            enter NA[]
            do inner
            exit(dcl[],pn,on)
            #);
          enterType:< 
            (# TP: ^Type 
            do inner; 
               (if TP[] = none then
                   '!!!! enterType is none:'->dumpT; dopt -> dumpTN
               if)
            exit TP[] 
            #);
          exitType:< 
            (# TP: ^Type 
            do inner;
               (if false and (TP[] = none) then
                   '!!!! exitType is none:'->dumpT; dopt -> dumpTN;
                   label -> dumpTN;
                   father.father.dopt -> dumpTN
               if)
            exit TP[] 
            #);
          alloc:< 
            (# done: @boolean
            do (*'**** alloc:'->dumpt; label -> dumptN;*)
               inner;
               (if not done then
                   scanSons(#do current.alloc #);
                   true -> done
            if)#);  
          gen:<
            (# 
            do inner;
            #);
          
          goOrigin:<
            (# on : @integer
            enter on
            do inner
            #);
          load:< 
            (# 
            do inner;
            #);
          store:< 
            (# 
            do inner;
            #);
          doAlloc:< (* allocation of an object from pattern ND *)
            (# ND: ^BetaNameDecl
            enter ND[]
            do inner
            #);
          activate:< (* alloc and execute *)
            (# ND: ^BetaNameDecl; LMR: @char; isLocal,isRef: @boolean 
            enter(ND[],LMR,isLocal,isRef)
            do inner 
            #);
          
          dumpAlloc:< 
            (# indent: (#do (for i: aLevel repeat ' ' -> put for) #);
               newOD:
                 (#
                 do aLevel + 3 -> aLevel; true -> inOD;
                 #);
               inOD: @boolean
            do inner;
               scanSons(#do current.dumpAlloc #);
               (if inOD then aLevel - 3 -> aLevel; false -> inOD if)
            #);
          getPrimNo:< IntegerValue;
          traceCheck:
            (# T: ^text;
            enter T[]
            do (if false then
                   T[] -> puttext;
                   inner
               if)
            #);
          traceCheckN: traceCheck
            (#
            do newline
            #);
       do inner
       #);
     aLevel: @integer;
     StdBetaModule:< StdBetaNode 
       (# PT::
            (#
            do 'StdBetaModule: '->lx.append;
               moduleName.PT;
               (pos,true) -> mkBreak;
               (pos,break) -> BPS.PT;
               (pos,break) -> frags.PT;
               (*slots.print*)
            #);
          Label:: (#do 'StdBetaModule'->lab[] #);
          findSlot:
            (# slotName,cat: ^text; slt: ^Slot;
            enter(slotName[],cat[])
            do (if false then
                   '**** findSlot:'->dumpT; slotName[]->dumpt; cat[] -> dumpTN;
               if);
               L:
                 slots.scan
                 (#
                 do (if (slotName[] -> current.theName.T.equalNCS) then
                        (if false then
                            '**** found: ' -> dumpT; current.doPT -> dumpTN;
                        if);
                        (* check category *)
                        current[] -> slt[];
                        leave L
                 if)#);
               (if slt[] = none then
                   (if moduleOrigin[] <> none then
                       (slotName[],cat[]) -> moduleOrigin.findSlot -> slt[];
                       (if slt[] = none then
                           '!!!! Found no slot with the name: ' -> puttext;
                           slotName[] -> putline
               if)if)if)
            exit slt[]
            #);
          searchBetaDecl::
            (#
            do (*'**   StdBetaModule:searchBetaDecl:'->dumpTN;*)
               frags.scanSons(#do N[] -> current.searchBetaDecl -> ATd[] #);
            #);
          moduleName:  ^NameApl; inFile: ^file;
          fragPath: ^text;
          BPS: ^BetaProperties; 
          frags: ^BetaFragments;
          slots: ^SlotList;
          moduleOrigin: ^StdBetaModule;
       enter(Name->NameApl->moduleName[]->append,BPS[]->append,frags[]->append)
       #);
     
     BetaModule: StdBetaNode 
       (# moduleName:  ^Name; inFile: ^file;
       enter moduleName[]
       #);
          
     FragmentModule: BetaModule
       (* Perhaps eliminate - only in openFragmentFile *)
       (# PT::
            (#
            do 'FragmentModule: ' -> lx.append; (pos,break) -> frag.PT 
            #);
          Label:: (#do 'FragmentDModule'->lab[] #);
          frag: ^FragmentEntry
       enter frag[] -> append
       #);
     
     Item: StdBetaNode
       (# isValItem:<
            (# size: @integer
            do inner
            exit size
            #);
          isVirtualDecl:< BooleanValue;
          isSingular:< BooleanValue;
          isPrimitive: @boolean;
          setPrimitive:< (# do inner #);
          storeItem:<
            (# id: ^Text; off: @integer
            enter(id[],off)
            do inner
            #);
          loadItem:<
            (# id: ^Text; off: @integer
            enter(id[],off)
            do inner
            #);
          NS: ^NameDecls
       #);
     BetaDecl:< StdBetaNode
       (# PP::< (# do 'Decl' -> lx.append; inner #);
          length::<
            (#
            do NS.length + 2 -> value; inner
            #);
          PT::<
            (#
            do (pos,break) -> NS.PT;  ':' -> lx.put;   
               (pos,break) -> IT.PT;
               inner PT
            #);
          Label:: (#do 'Decl'->lab[] #);
          isPrimitive: @boolean;
          NS: ^NameDecls;        
          IT: ^Item 
       enter(NS[]->append,IT[]->append)
       #);
     BetaDataItem:< Item
       (# PP:: (#do 'DataItem'-> lx.append #);
          length:: (#do (*IT.length + value -> value*) #);
          PT::< (#do (*(pos,break) -> IT.PT; inner PT *)#);
          Label:: (#do 'DataItem' -> lab[] #);
       #);
     NameDecls:< StdBetaNode
       (# PP:: (#do 'NameDecls'-> lx.append #);
          length:: 
            (# 
            do scanSons
               (#
               do current.length + value  -> value;
                  (if not isLast then value + 1 -> value if)
               #)
            #);
          PT:: 
            (# 
            do scanSons
               (#do (pos,break) -> current.PT; 
                  (if not isLast then ','->lx.put 
               if)#)
            #);
          Label:: (#do 'NameDecls'->lab[] #);
       #);
     BetaNameDecl:< StdBetaNode
       (# PP:: (#do 'NameDecl:'-> lx.append; N.T[] -> lx.append #);
          length:: (# do N.length -> value #);
          PT:: (# do N.T[] -> lx.append #);
          label:: (#do 'NameDecl' -> lab[]; N.T[] -> lx.append #);
          isDataItem:< booleanValue(# do inner #);
          isPtn:< booleanValue(# do inner #);
          N: ^Name;
          isSimple,isForInx: @boolean;
          forNo: @integer;
          off: @integer
       enter N[]
       #);
     BetaLexem: StdBetaNode
       (# T: ^text;
       enter T[]
       #);
     BetaString:< BetaLexem
       (# PP:: (#do 'String:'-> lx.append; T[] -> lx.append #);
          PT:: (#do '\'' -> lx.put; T[] -> lx.append; '\'' -> lx.put #);
          Length:: (#do T.length -> value #);
          Label:: (#do 'String'->lab[] #);
       #);
    
     BetaProperties: StdBetaNode
       (# PT::
            (#
            do 'BetaProperties: ' -> lx.append; (pos,true)->mkBreak;
               scanSons(#do (pos,break)->current.PT; (pos,true)->mkBreak #);
            #);
          Label:: (#do 'BetaProperties'->lab[] #);
       #);
     BetaProperty: StdBetaNode
       (# PT::
            (#
            do (*'BetaProperty: '->lx.append; *)
               scanSons(#do (pos,break)->current.PT; ' ' -> lx.put #);
            #);
          Label:: (#do 'BetaProperty'->lab[] #);
       #);
     BetaFragments:< StdBetaNode
       (# PT::
            (#
            do 'BetaFragments:'->lx.append; (pos,true)->mkBreak;
               scanSons(#do (pos,break)->current.PT #)
            #);       
          Label:: (#do 'BetaFragments'->lab[] #);
       #);
     BetaFragment: StdBetaNode
       (# PT::<
            (#
            do 'BetaFragment:'->lx.append; (pos,true)->mkBreak;
               (*'---' -> lx.append;
                scanSons(#do (pos,break)->current.PT; ':' -> lx.put #);*)
               inner PT
            #);
          markNamesAsSlot:
            (#
            do true -> theName.isSlot -> cat.isSlot -> language.isSlot
            #);
          matchingSlot: ^Slot;
          theName,cat,language: ^NameApl;
       enter(NameApl->theName[]->append,NameApl->cat[]->append,NameApl->language[]->append)
       #);

     (* FragmentEntry, FragmentDir, and FragmentFile are not used *)
     FragmentEntry: BetaModule
       (# PT::<
            (#
            do (pos,length) -> block
               (#
               do '\nBetaFragmentEntry:path:' -> lx.append;
                  path[] -> lx.append; 
                  ' name:'->lx.append; fileName[]->lx.append;
                  inner PT
            #)#);
          path,fileName: ^text; (* Perhaps superflous since 
                                 * we have name and pathToFN in Module;
                                 * Module also has inFile
                                 * fileName and inFile are defined during
                                 * parsing in FragmentFile
                                 * Are not defined for a FragmentDirectory
                                 *)
       enter(path[],fileName[])
       #);
     FragmentDir: FragmentEntry
       (# PT::
            (#
            do (if false and ( not expand) then
                   true -> expand; doExpand 
               if);
               '  dir: '->lx.append; 
               (pos,true) -> mkBreak;
               scanSons
               (# 
               do (pos,break) -> current.PT;
                  (pos,break) -> mkBreak
            #)#);  
          Label:: (#do 'FragmentDir'->lab[] #);
          doExpand:
            (# trace: (#exit false #);
               D: @directory;  FN,ext: ^text;
            do (if trace then
                   '**** expand:'->dumpT; path[] -> dumpTN
               if);
               (if true then
                   path[] -> D.name;
                   D.scanEntries
                   (# N: ^Name; FG: ^FragmentEntry
                   do found.path -> FN[];
                      (if true
                       // '.' -> FN.equal
                       // '..' -> FN.equal
                       // (1 -> FN.inxGet) = '.'
                       // (fn.length -> FN.inxGet) = '~' then
                       else           
                          select
                          (# whenFile:: 
                               (# 
                               do 'file:'->dumpT;
                                  FN[] -> Name -> N[];
                                  (N[],FN[] -> (path.copy).append ,FN[])
                                    -> FragmentFile -> FG[]
                                    -> append;
                                  (if false and (FG.inFile[] = none) then
                                      '**** FG.inFile is none' -> putline
                                  if)
                               #);
                             whenDir:: 
                               (# 
                               do 'dir:'->dumpT;
                                  FN[] -> Name -> N[];
                                  (N[],FN[] -> (path.copy).append,FN[],false) 
                                    -> FragmentDir
                                    -> append
                               #);
                          #);
                          FN[] -> dumpT
                      if)
                   #);
                   newline
                else
                   (path[],true) -> getBetaDirectories
                   (#
                   do scan
                      (# N: ^Name; FG: ^FragmentEntry
                      do (if currentIsFile then
                             (if trace then
                                 'File: ' -> puttext; 
                                 current[] -> (path.copy).append -> putline;
                             if);
                             current[] -> Name -> N[];
                             (N[],current[] -> (path.copy).append ,current[])
                               ->  FragmentFile -> FG[]
                               -> append;
                             (if FG.inFile[] = none then
                                 '**** FG.inFile is none' -> putline
                             if)
                          else
                             (if trace then
                                 'Dir: ' -> puttext;
                             if);
                             (*current[] -> (path.copy).append -> dirs.add;*)
                             'FragmentDir' -> Name -> N[];
                             (N[],current[] 
                               -> (path.copy).append,current[],false) 
                               -> FragmentDir -> append
                         if);
                         (if trace then  current[] -> putline if);
               #)#);if);
            #);
          expand: @boolean
       enter expand
       #);
     FragmentFile: FragmentEntry
       (# PP:: (# do 'FragmentFile' -> lx.puttext #);
          PT:: 
            (# 
            do ' file:'->lx.append;
               (pos,break) -> mkBreak;          
               (if props[] <> none then (pos,break) -> props.PT; if);
               (if pos > 0 then 
                   (* A comment with no linebreak may have been printed in props *)
                   (pos,true) -> mkBreak
               if);
               (* basiclib has no framents ==> frag[] = none *)
               (if frags[] <> none then (pos,break) -> frags.PT if)
            #);
          label:: (#do 'fragmentFile:' -> lab[] #);
          Props:  ^BetaProperty;
          Frags: ^Fragments;
          trace: (# exit false #)
       #);

     Fragments: StdBetaNode
       (# theName,cat,language: ^Name;      frag: ^Fragment
       do loop:
            (if lex.symb = lex.symbols.idf then
                lex.sym[] -> Name -> theName[];
                lex; 
                (if lex.symb = lex.symbols.colon then
                    lex;
                    (if lex.symb = lex.symbols.idf then
                        lex.sym[] -> Name -> cat[];
                        lex;
                        (if lex.symb = lex.symbols.colon then
                            lex;
                            (if lex.symb = lex.symbols.idf then 
                                (* --- x:objectDesc:beta --- *)
                                lex.sym[] -> Name -> language[];
                                lex;                          
                             else
                                SyntaxError
                            if)
                         else
                            'BETA'-> Name -> language[];
                        if);
                        (if lex.symb = lex.symbols.frag then
                            lex;
                            (if true 
                             // 'descriptor' -> cat.T.equalNCS 
                             // 'descriptorForm' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> ObjDescFrag -> frag[] -> append;
                             // 'attributes' -> cat.T.equalNCS 
                             // 'attribute' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> AttFrag -> frag[] -> append
                             // 'doPart' -> cat.T.equalNCS then 
                                (theName[],cat[],language[]) 
                                  -> doPartFrag -> frag[] -> append
                             // 'mainPart' -> cat.T.equalNCS then
                                '\n!!!! MainPart category is not implemented' 
                                  -> putline
                             else
                                'Unknown category: ' -> puttext; 
                                cat.T[] -> putline
                            if);
                            (if lex.symb = lex.symbols.frag then 
                                lex;
                                restart loop
                            if);
                         else
                            SyntaxError
                        if)
                     else
                        SyntaxError
                    if)
                 else
                    SyntaxError
                if)
             else
                SyntaxError
            if);
          (if frag[] <> none then (*frag.addCommentAfter*) if)
       #);
     Fragment: StdBetaNode
       (* Super pattern for ObjDescFrag, AttFrag and doPartFrag *)
       (# PT::< 
            (#
            do(* breakIfNotAtEol;*) inner  
            #);
          Label:: (#do 'Fragment'->lab[] #);
          entity:: (# do this(Fragment)[] -> E[] #);
                      (*sort:: (# do this(Fragment)[] -> S[] #);*)
          kind:: (# do '-' -> ch #);
          skind:: (# do ': -' -> S[] #);
          replaceEntity::<
            (#
            do '**** Fragment:replaceEntry: ' -> putline;
               inner
            #);
          theName,cat,language: ^Name
       enter(theName[]->append,cat[]->append,language[]->append)
          (*do inner*)
       #);
     ObjDescFrag:< BetaFragment
       (# PT:: 
            (# 
            do '---' -> lx.append; theName.PT;
               ':descriptor---' -> lx.append;
               (pos,break) -> OD.PT
            #);
          label:: (# do 'ObjDescFrag' -> lab[] #);
          getentries::(#do OD.getentries -> (names[],entries[]) #);
                         (*entity:: (# do this(ObjDescFrag)[] -> E[] #);
                          sort:: (# do this(ObjDescFrag)[] -> S[] #);*)
          replaceEntity::
            (#
            do '**** ObjDescFrag:replaceEntry: ' -> putline;
               inner
            #);
          OD: ^ObjectDesc
       #);
     AttFrag:< BetaFragment
       (# PP:: (# do 'AttFrag'->lx.append #);
          PT:: 
            (# 
            do '---' -> lx.append; 
               theName.PT;
               ':attributes---\n' -> lx.append;
               (if att[] <> none then (pos,break) -> att.PT;  if)
            #);
          label:: (#do 'AttFrag'->lab[] #);
          length:: (# do att.length -> value #);
          getentries::(#do att.getEntries -> (names[],entries[]) #);
                         (* entity:: (# do this(AttFrag)[] -> E[] #);
                          sort:: (# do this(AttFrag)[] -> S[] #);*)
          replaceEntity::
            (#
            do '**** AttFrag:replaceEntry: ' -> putline;
               inner
            #);
          searchBetaDecl::
            (# pn: @integer
            do (*'**   AttFrag:searchBetaDecl:'->dumpT; N[] -> dumpTN;
               att.dopt -> putheadN;*)
               N[] -> Name -> att.localSearch -> (Atd[],pn);
               (if false and (ATd[] <> none) then
                   '**** found: '->dumpTN; 
                   Atd.dopt -> dumpTN
               if);
            #);
          att: ^Attributes
       #);
     doPartFrag:< BetaFragment
       (# PP:: (#do 'DoPart'-> lx.append #);
          PT:: 
            (# 
            do '---' -> lx.append; theName.PT;
               ':doPart---\n' -> lx.append;
               (pos,break) -> DP.PT 
            #);
          label:: (# do 'doPartFrag' -> lab[] #);
          length::(# #);
          getEntries:: (# do ('Do-part',DP[]) -> add #);
                          (*entity:: (# do this(DoPartFrag)[] -> E[] #);
                           sort:: (# do this(DoPartFrag)[] -> S[] #);*)
          replaceEntity::
            (#
            do '**** doPartFrag:replaceEntry: ' -> putline;
               inner
            #);
          DP: ^DoPart
       #);
     BetaObjectSpecification: StdBetaNode
       (# PT::< (#do inner PT #);
          setImplicitSuper:<
            (# superOD: ^ObjectDesc;
            enter superOD[]
            do inner
            #);
          getDescNo:< (# DN: @integer do inner exit DN #);
          objSize:<
            (# size: @integer
            do inner
            exit size
            #);
          isSingular:< BooleanValue;
          isPrimitive: @boolean;
          NS: ^NameDecls
       #);
     ObjectDesc:< BetaObjectSpecification
       (# PP:: (#do 'ObjectDesc'-> lx.append #);
          length::
            (#
            do (if slt[] = none then
                   sup.length + 3 -> value;
                   (*props.length + value -> value;*)
                   (if att[] <> none then att.length + value -> value if);
                   value + acp.length + 3 -> value
                else
                   slt.length + 4 -> value
               if)
            #);
          PT::
            (#
            do (pos,break) -> sup.PT;
               (pos,length) -> block
               (#
               do (if slt[] = none then
                      (pos,break) -> mkBreak0;
                      '('->lx.put; '#'->lx.put; ' ' -> lx.put;
                      (pos + 3,break) -> att.PT;
                      (pos,break) -> acp.PT;
                      (pos,break) -> mkBreak1; 
                      '#'->lx.put; ')'->lx.put
                   else
                      (pos,break) -> slt.PT
            if)#)#);
          label:: (#do 'ObjectDesc'-> lab[] #);
          setImplicitSuper::
            (#
            do (if false then
                   'ObjectDesc:setImplicitSuper:'->dumpTN;
                   doPT -> dumpTN;
               if);
               superOD[] -> sup.setImplicitSuper
            #);
          isSingular:: TrueValue;
          hasDoPart: BooleanValue
            (#
            do (if acp.imps[] <> none then
                   not acp.imps.isNull -> value (* check for slt[] <> none *)
               if)
            #);
          
          sup: ^PatternDen;
          props: ^BetaProperties;
          restricts: ^Restrictions;
          att: ^Attributes;
          acp: ^ActionPart;
          slt: ^Slot;
       enter(sup[]->append,att[]->append,acp[]->append)
       #);
     Restrictions: StdBetaNode(##);
     BetaPattern:< Item
       (# PP:: (#do 'Pattern'-> lx.append #);
          length:: (#do value + 1 + OD.length -> value #);
          PT:: (# do ' ' -> lx.put; (pos + 2 ,break) -> OD.PT #);
          label:: (#do 'PTN'-> lab[] #);
          setPrimitive:: (#do true -> isPrimitive -> OD.isPrimitive #);
          isSingular:: TrueValue;
          OD: ^ObjectDesc;
       enter(OD[]->append)
       #);
     BetaVirtualPattern:< Item
       (# PT::
            (#
            do '<' -> lx.put; ' ' -> lx.put; (pos + 2,break) -> OS.PT;
            #);
          length:: (#do value + 1 + OS.length -> value #);
          label:: (#do 'Virtual'-> lab[] #);
          isVirtualPtn:: TrueValue;
          isSingular:: TrueValue;
          OS: ^BetaObjectSpecification;
       enter(OS[]->append)
       #);
     VirtualBinding: Item
       (# PT::< (#do inner PT;  (pos + 2,break) -> OS.PT #);
          length:: (#do value + 1 + OS.length -> value #);
          isVirtualPtn:: TrueValue;
          isSingular:: TrueValue; (* need to do OS.isSingular ... *)
          OS: ^BetaObjectSpecification;
          NS: ^NameDecls; (* name(s) of this virtual *)
          superNS: ^NameDecls; (* name(s) of virtual bound by this virtual*)
       enter(NS[],OS[]->append)
       #);
     FurtherBinding:< VirtualBinding
       (# PT:: (#do ':< ' -> lx.append #);
          label:: (#do 'Further' -> lab[] #);
       #);
     FinalBinding:< VirtualBinding
       (# PT:: (#do ': ' -> lx.append #);          
          label:: (#do 'Final' -> lab[] #);
       #);
     PatternDen:< BetaObjectSpecification
       (# (* lex.symb = idf *)
          PP:: (#do 'PatternDen' -> lx.puttext #);
          length:: (# do AD.length -> value #);
          PT:: (# do (if AD[] <> none then (pos,break) -> AD.PT if) #);
          label:: (# do 'PatternDen' -> lab[] #);
          setImplicitSuper:: 
            (#
            do (if AD.isEmpty then 
                   (if false then
                       'PatternDen:setImplicitSuper:'->dumpTN;
                       AD.isEmpty -> putboolean; newline;
                   if);
                   superOD[] -> AD.setImplicitSuper 
                (*else 'isEmpty:NO!'-> dumpTN *)
               if)
            #);
          markAsSuper:
            (# 
            do (*'patternDen:markAsSuper:'->puttext; dopt -> putline;*)
               AD.markAsSuper 
            #);
          isSameBlockLevel: BooleanValue
            (#
            do (if false then
                   '**** PatternDen:'->dumpT; dopt -> dumpT;
                   'AD.on:'->dumpT; AD.on->putint;  ' AD.isRemote: ' -> dumpT;
                   AD.isRemote -> putBoolean; 
                   newline;
               if);
               (AD.on = 0) and not AD.isRemote -> value
            #);
          isExternal: BooleanValue(#do AD.isExternal -> value #);
          AD: ^AttributeDenotation;
       enter AD[] -> append
       #);
     Attributes:< StdBetaNode
       (# PP:: (#do 'Attributes'-> lx.append #);
          length::
            (#
            do scanSons
               (#
               do current.length + value -> value;
                  (if not isLast then
                      value + 2 -> value
                  if)
               #)
            #);
          PT:: 
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then
                         ';' -> lx.put;
                         (pos,true) -> mkBreak
            if)#)#)#);
          label:: (#do 'Attributes'-> lab[] #);
       #);
     Attribute: StdBetaNode
       (#
       #);
     ActionPart:< StdBetaNode
       (# PP:: (#do 'ActionPart' -> lx.puttext #);
          length::
            (#
            do (if enterP[] <> none then enterP.length -> value; if);
               (if imps[] <> none then
                   3 + imps.length + value -> value
               if);
               (if exitP[] <> none then 
                   exitP.length + value -> value 
               if)
            #);
          PT::
            (#
            do (if enterP[] <> none then (pos,break) -> enterP.PT if);
               (if (imps[] <> none) and (imps.noOfSons > 0) then
                   (pos,break) -> mkBreak1;
                   'do ' -> lx.append;
                   (pos + 3,break) -> imps.PT ;
               if);
               (if exitP[] <> none then (pos,break) -> exitP.PT if)
            #);
          label:: (#do 'ActionPart'-> lab[] #);
          enterP: ^ EnterPart;
          imps: ^Imperatives;
          exitP: ^ExitPart
       enter(enterP[]->append,imps[]->append,exitP[]->append)
       #);
     DoPart:< StdBetaNode
       (# PP: (# do 'doPart' -> lx.append #);
          length:: (# do imps.length + 3 -> value #);
          PT::
            (#
            do (if (imps[] <> none) and (imps.noOfSons > 0) then
                   (pos,break) -> mkBreak1;
                   'do ' -> lx.append;
                   (pos + 3,break) -> imps.PT ;
               if);
            #);
          label:: (# do 'doPart'->lab[] #);
          imps: ^Imperatives;
       enter imps[] -> append
       #);
     EnterPart:< StdBetaNode
       (# PP:: (#do 'Enter' -> lx.puttext #);
          length:: (# do (if eval[] <> none then 6 + eval.length -> value if)#);
          PT::
            (#
            do (if eval.noOfSons > 0 then
                   (pos,break) -> mkBreak1;
                   'enter' -> lx.append;
                   (pos,false) -> mkBreak1;
                   (pos,break) -> eval.PT 
               if)
            #);
          label:: (#do 'EnterPart'-> lab[] #);          
          eval: ^Evaluation; 
       enter eval[]->append
       #);
     ExitPart:< StdBetaNode
       (# PP:: (#do 'Exit' -> lx.puttext #);
          length:: (# do (if eval[] <> none then 5 + eval.length -> value if)#);
          label:: (#do 'ExitPart'-> lab[] #);
          PT::
            (#
            do (if eval.noOfSons > 0 then                   
                   (pos,break) -> mkBreak1;
                   'exit' -> lx.append;
                   (pos,false) -> mkBreak1;
                   (pos,break) -> eval.PT 
            if)#);
          eval: ^Evaluation; 
       enter eval[]->append
       #);
     Imperatives:< StdBetaNode
       (# PP:: (#do 'Imperatives' -> lx.puttext#);
          length::
            (# l: @integer
            do scanSons(# do current.length + 2 + l -> l #);
               l -> value
            #);
          PT:: 
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT ;
                     (if not isLast then
                         ';' -> lx.put;
                         (pos,break) -> mkBreak1;
            if)#)#)#);
          label:: (#do 'Imperatives'-> lab[] #);
       #);
     Slot: StdBetaNode
       (# length:: (# do theName.length + cat.length + 10 -> value #);
          PT:: 
            (# 
            do '<<SLOT ' -> lx.puttext; theName.PT; ':' -> lx.put;
               cat.PT; '>>' -> lx.puttext 
            #);
          label :: (#do 'Slot' -> lab[] #);
          isAtt:< BooleanValue;
          isObjDesc:< BooleanValue;
          isDoPart:< BooleanValue;
          bindings: @
            (# frags: [1] ^BetaFragment; top: @integer;
            #);
          addBinding:<
            (# frag: ^BetaFragment;
            enter frag[]
            do (if (bindings.top + 1 -> bindings.top) > bindings.frags.range then
                   bindings.frags.range -> bindings.frags.extend
               if);
               frag[] -> bindings.frags[bindings.top][];
               inner                    
            #);
          scanBindings:
            (# current: ^BetaFragment;
            do (for i: bindings.top repeat
                    bindings.frags[i][] -> current[];
                    inner
            for)#);
          theName,cat: ^Name;
       enter(Name->theName[],Name->cat[])
       #);
     AttSlot:< Slot (*Attribute*)
       (# (*PT:: (#do (pos,break) -> theSlot.PT #);*)
          isAtt:: TrueValue
       #);
     ObjDescSlot:< Slot
       (# isObjDesc:: TrueValue;
          addBinding::
            (#
            do (if bindings.top > 1 then
                   '!!!! Too many bindings of ObjDesc slot:'->puttext; dopt -> dumpTN;
            if)#);
       #);
     DoPartSlot:< Slot
       (# 
          isDoPart:: TrueValue;
          addBinding::
            (#
            do (if bindings.top > 1 then
                   '!!!! Too many bindings of DoPart slot:'->puttext; dopt -> dumpTN;
            if)#);
       #);
     Evaluation:< Imperative (*StdBetaNode*)
       (# PP::(#do 'Eval'->lx.puttext #);
          length::
            (#
            do scanSons
               (#
               do current.length + value -> value; 
                  (if not isLast then 4 + value -> value if)
            #)#);
          PT::
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then
                         (pos + 2,break) -> mkBreak0; 
                         ' -> ' -> lx.append;
            if)#)#)#);
          label:: (#do 'Evaluation'-> lab[] #);
       #);
     Imperative: StdBetaNode
       (#
       #);
     IfImp:< Imperative
       (# PP:: (#do 'If'->lx.puttext #);
          length::
            (# 
            do (if true then
                   100000 -> value;
                   (* for break imn implist with ifImp *)
                else
                   4 + eval.length -> value;
                   (if not thenPart.isNull then
                       6 + thenPart.length + value -> value
                    else
                       alt.length + value -> value
                   if);
                   (if elsePart[] <> none then
                       5 + elsePart.length + value -> value
                   if);
                   4 + value -> value
            if)#);
          PT::
            (#
            do (pos,length) -> block
               (#
               do '(' 'if ' -> lx.append; 
                  (pos,break) -> eval.PT ;
                  (if not thenPart.isNull then
                      ' then' -> lx.append;
                      (pos+4,break) -> mkBreak1;
                      (pos+4,break) -> thenPart.PT
                   else
                      (pos + 1,break) -> mkBreak1;
                      (pos+1,break) -> alt.PT 
                  if);
                  (if not elsePart.isNull then
                      (pos + 1,break) -> mkBreak1;
                      'else' -> lx.append;
                      (pos + 4,break) -> mkBreak1;
                      (pos+4,break) -> elsePart.PT 
                  if);
                  (pos,break) -> mkBreak1;
                  'if' ')' -> lx.append;
            #)#);
          label:: (#do 'IfImp'-> lab[] #);          
          eval: ^Evaluation;
          thenPart,elsePart: ^Imperatives;
          alt: ^Alternatives
       enter(eval[]->append,thenPart[]->append,elsePart[]->append,alt[]->append)
       #);
     Alternatives:< StdBetaNode
       (# PP:: (# do 'Alternatives' -> lx.puttext #);
          length:: 
            (# l: @ integer 
            do scanSons(# do current.length + l -> l #); l -> value 
            #);
          PT::
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then (pos,break) -> mkBreak1 if);
            #)#)#);
          Label:: (#do 'Alternatives' -> lab[] #);
       #);
     Alternative:< StdBetaNode
       (# PP:: (# do 'Alternative' -> lx.puttext #);
          length::
            (#
            do (if true then
                   10000 -> value (* ensure break at alternatives in if *)
                else
                   (if imps[] = none then
                       sel.length  -> value
                    else
                       sel.length  + 6 + imps.length -> value
            if)if)#);
          PT:: (#
               do (pos,length) -> block
                  (#
                  do (pos,break) -> sel.PT;
                     (if imps.noOfSons > 0 then 
                         ' then' -> lx.append;
                         (pos+3,break) -> mkBreak1;
                         (pos+3,break) -> imps.PT 
               if)#)#);
          Label:: (#do 'Alternative' -> lab[] #);
          sel: ^Selections;
          imps: ^Imperatives
       enter(sel[]->append,imps[]->append)
       #);
     Selections:< StdBetaNode
       (# PP:: (# do 'Selections' -> lx.puttext #);
          length::
            (# 
            do scanSons(#do 3 + current.length + value -> value #)
            #);
          PT:: 
            (#
            do (pos,length) -> block
               (#
               do scanSons
                  (#
                  do '// ' -> lx.append; (pos,break) -> current.PT;
                     (if not isLast then
                         (pos,break) -> mkBreak1
            if)#)#)#);
          Label:: (#do 'Selections' -> lab[] #);
       #);
     Selection:< StdBetaNode
       (# PP:: (# do 'Selection' -> lx.puttext #);
          length:: (# do EV.length -> value #);
          PT:: (# do (pos,break) -> EV.PT  #);
          Label:: (#do 'Selection'->lab[] #);
          EV: ^Evaluation
       enter EV[] -> append
       #);
     ForImp:< Imperative
       (# PP:: (#do 'For' -> lx.puttext #);
          length::
            (#
            do (if true then
                   100000 -> value
                else
                   5 + 2 + inxDecl.length + 8 + imps.length + 5 -> value
            if)#);
          PT::
            (#
            do (pos,length) -> block
               (#
               do '(' -> lx.put; 'for ' -> lx.append; (* avoid cunfusing Beta PP *)
                  (*(if inx[] <> none then
                      (pos,break) -> inx.PT ;
                      
                   if);*)
                  (pos,break) -> inxDecl.PT;
                  ':' -> lx.put; ' ' -> lx.put;
                  (if rangee[] <> none then
                      (pos,break) -> rangee.PT ; 
                  if);
                  ' repeat' -> lx.append;
                  (pos + 5,break) -> mkBreak1;
                  (pos + 5,break) -> imps.PT ;
                  (pos,break) -> mkBreak1;
                  'for' -> lx.append; ')' -> lx.put
            #)#);
          Label:: (#do 'ForImp'->lab[] #);
          (* inx: ^NameDecl (*Lexem*);
          inxDecl: ^BetaDecl;
          (*inxItem: ^ForImpItem;*)
          rangee: ^Evaluation;
          imps: ^Imperatives;
          (* ( for i: E repeat ... for )
           * ( for E repeat ... for )
           * ( for a + b repeat ... for )
           * ( for -a + b repeat ... for )
           *)
          emit:
            (# N: ^StdBetaNode;
            enter N[]
            do N.noOfSons -> putint; ' ' -> put;
               N.scanSons(#do current.label -> dumpT #);
               newline;
            #);
          test:
            (# T: ^Text;
            enter T[]
            do T[] -> dumpTN;
               (*inx[] -> emit;*) inxDecl[] -> emit;
               rangee[] -> emit; imps[] -> emit;
            #);
          init:
            (#
            enter(inxDecl[],rangee[],imps[])
            do inxDecl[] -> append; rangee[] -> append; imps[] -> append;
            #)
       enter init
       #);
     ForImpItem: Item (*StdBetaNode*)
       (# PP:: (# do 'ForImpItem' -> lx.puttext #);
          PT:: (# do ' @ ForImpItem' -> lx.puttext #);
          label:: (#do 'ForImpItem' -> lab[] #);
          kind:: (# do 'F' -> ch #);
       #);
     LabelledImp:< Imperative
       (# PP:: (# do 'LabelledImp' -> lx.puttext #);
          length:: 
            (# 
            do (if true then 
                   100000 -> value 
                else lab.length + 2 + imp.length -> value
               if)
            #);
          PT::
            (#
            do (pos,break) -> lab.PT ; ':' -> lx.put;
               (pos,length) -> block
               (#
               do (pos+2,break) -> mkBreak1;
                  (pos+2,break) -> imp.PT 
               #)
            #);
          label:: (#do 'LabelledImp'-> lab[] #);          
          lab: ^BetaNameDecl;
          imp: ^Imperative
       enter(lab[]->append,imp[]->append)
       #);
     Break: Imperative
       (# PT::< (# do inner; (pos,break) -> lab.PT  #);
          length::< (# do inner; lab.length + value -> value #);
          lab: ^NameApl 
       enter lab[] -> append
       #);
     LeaveImp: Break
       (# PP::(#do 'leave '->lx.puttext #);
          length:: (# do 6 -> value #);
          PT::(#do 'leave ' -> lx.append #);
          label:: (#do 'Leave'-> lab[] #);
       #);
     RestartImp: Break
       (# PP::(#do 'restart'->lx.puttext #);
          length:: (# do 8 -> value #);
          PT:: (#do 'restart ' -> lx.append #);
          label:: (#do 'Restart'-> lab[] #);
       #);     
     InnerImp: Imperative
       (# length:: 
            (# 
            do 5 -> value; 
               (if N[] <> none then N.length + 1 + value -> value if)#);
          PT:: 
            (# 
            do 'inner' -> lx.append; 
               (if N[] <> none then 
                   ' ' -> lx.put;
                   (pos,break) -> N.PT
               if)
            #);
          label:: (#do 'Inner'-> lab[] #);
          N: ^NameApl
       enter N[] -> append
       #);
     Transaction: StdBetaNode
       (# PP::< (#do 'Transaction:'-> lx.append; inner #);
       #);
     Exp: Transaction (#  #);
     BetaBinaryExp:< Exp
       (# PP::
            (#
            do 'BinExp:'->lx.puttext; op->lex.symbols.asText -> lx.append
            #);
          length:: (# do lE.length + 4 + rE.length -> value #);
          PT::
            (#
            do (pos,break) -> lE.PT; ' ' -> lx.put;
               op -> lex.symbols.asText -> lx.append;
               ' ' -> lx.put; (pos,break) -> rE.PT ;
            #);
          label:: (#do 'BinayExp'->lab[] #);
          lE,rE: ^Exp; op: @integer
       enter(lE[]->append,op,rE[]->append) 
       #);
     BetaUnaryExp: Exp
       (# PP::
            (#
            do 'UnaryExp:'->lx.puttext; op -> lex.symbols.asText -> lx.puttext
            #);
          length:: (# do 2 + E.length -> value #);
          PT:: 
            (# 
            do op -> lex.symbols.asText -> lx.append; ' ' -> lx.put;
               (pos,break) -> E.PT  
            #);
          Label:: (#do 'UnaryExp'-> lx.append #);
          E: ^Exp; op: @integer 
       enter(op,E[]->append)
       #);
     BetaTerm:< Exp
       (# PP:: (#do 'Term'->lx.append #);
          PT:: (# do (pos,break) -> T.PT #);
          length:: (# do T.length -> value #);
          label:: (#do 'Term'->lab[] #);
          T: ^transaction
       enter T[]->append
       #);

     ObjectEvaluation:< Transaction
       (# PP:: (#do 'ObjEval' -> lx.append #);
          PT:: (# do (pos,break) -> OS.PT #);
          length:: (#do OS.length -> value #);
          label:: (#do 'ObjEval'->lab[] #);
          OS: ^BetaObjectSpecification;
       enter OS[]->append
       #);
     ObjectReference:< Transaction
       (# PP:: (#do 'Reference' -> lx.puttext #);
          length:: (# do OV.length + 2 -> value #);
          PT:: (# do (pos,break) -> OV.PT; '[]' -> lx.append #);
          label:: (#do 'Reference'->lab[] #);
          OV: ^StdBetaNode (*AttributeDenotation*)
       enter OV[] -> append
       #);
     StructureRef: Transaction
       (# PP:: (#do 'StructureRef' -> lx.puttext #);
          length:: (# do OV.length + 2 -> value #);
          PT:: (# do (pos,break) -> OV.PT; '##' -> lx.append #);
          label:: (#do 'StrucRef'->lab[] #);
          OV:  ^StdBetaNode (*AttributeDenotation*)
       enter OV[] -> append
       #);
     AttributeDenotation: BetaObjectSpecification (*Transaction*)
       (# (*vNode:: AttributeDenotation; - problem with Indexed *)
          isEmpty:< BooleanValue;
          isRemote:< BooleanValue;
          isExternal:< BooleanValue;
          
          updateOrigin:<
            (# org: ^SuperScope;
            enter org[]
            do inner
            #);
          setImplicitSuper:: 
            (#
            do (if false then
                   'AttributeDen:setImplicitSuper:'->dumpTN;
               if);
               superOD[] -> implicitSuperOD[]
            #);
          implicitSuperDesc:
            (# aDesc: ^ObjectDesc;
            do (if false then
                   'implicitSuperDesc:'->dumpt; isEmpty->putBoolean; 
                   ' ' -> put;
                   implicitSuperOD[] <> none -> putBoolean;
                   newline;
               if);
               (if implicitSuperOD[] <> none then
                   implicitSuperOD[] -> aDesc[]
               if)
            exit aDesc[]
            #);
          lastDen:< 
            (# last: ^AttributeDenotation
            do inner
            exit last[]
            #);
          implicitSuperOD: ^ObjectDesc;  
          ATd: ^BetaNameDecl; (*BetaDecl; *)
          pn,on: @integer
       #);
     ConstExp:< Exp
       (# PP:: (#do 'ConstExp:'-> lx.append; cst.T[] -> lx.append #);
          PT:: (#do cst.T[] -> lx.append #);
          Length:: (#do cst.length -> value #);
          Label :: (#do 'ConstExp:'->lab[] #);
          cst: ^Const
       enter Const -> cst[]
       #);
     CharExp: Exp (*Transaction*)
       (# PT:: (#do theCh.PT #);
          length:: (# do 3 -> value #);
          PP:: (#do label -> lx.append #); 
          Label:: (#do 'CharExp:'->lab[]; theCh.T[] -> lab.append #);
          getPrimNo::
            (#
            do theCh.T.setPos; theCh.T.getInt -> value;
            #);
          theCh: ^String
       enter String -> theCh[] 
       #);
     TextExp: Exp (*Transaction*)
       (# PT:: (#do theTxt.PT #);
          Length:: (#do theTxt.length -> value #);
          Label:: (#do 'TextExp'->lab[] #);
          theTxt: ^String
       enter String -> theTxt[] 
       #);
     EvaluationList:< Transaction
       (# PP:: (# do 'EvalList' -> lx.puttext #);
          length:: 
            (#
            do 2 -> value;
               scanSons
               (#
               do current.length + value -> value;
                  (if not isLast then 1 + value -> value if)
               #)
            #);
          PT:: 
            (#
            do '(' -> lx.put;
               (pos,length) -> block
               (#
               do scanSons
                  (#
                  do (pos,break) -> current.PT;
                     (if not isLast then 
                         (pos + 1, break) -> mkBreak0;
                         ',' -> lx.put 
                     if)
                  #);
                  ')' -> lx.put;
            #)#);
          Label:: (#do 'EvalList' -> lab[] #);   
       #);
     NoneValue:< Exp (*Transaction*)
       (# PP:: (# do 'none' -> lx.puttext #);
          length:: (# do 6 -> value #);
          Label:: (#do 'None'->lab[] #);
          PT:: (# do ' none' -> lx.puttext #);
       #);
     NameApl:< AttributeDenotation
       (# PP:: (#do  'NameApl:'->lx.puttext; N.T[]->lx.puttext #);
          length:: (# do (if N[] <> none then N.length -> value if) #);
          PT:: 
            (# 
            do (if N[] <> none then 
                   N.T[] -> lx.append;
                   (*(if not isImplicitSuper then N.PT if) *)
               if)
            #);
          Label:: (#do 'NameApl'->lab[] #);
          isEmpty::
            (#
            do N.T.length = 0 -> value
            #);
          lastDen:: (# do this(NameApl)[] -> last[] #);
          isSlot: @Boolean;
          isExternal:: (# do 'external' -> N.T.equalNCS -> value #);
          N: ^Name (*BetaLexem;*)
       enter N[]
       #);
     Remote:< AttributeDenotation
       (# PP:: (# do 'Remote' -> lx.append #);
          length :: 
            (#do scanSons(# do current.length + 1 + value -> value #)#);
          PT:: 
            (#
            do scanSons
               (#do (pos,break) -> current.PT;
                  (if not isLast then '.' -> lx.put if)
            #)#);
          Label:: (#do 'Remote' -> lab[] #);
          isRemote:: TrueValue;
          lastDen::
            (# AD: ^AttributeDenotation (* does this work  for Indexed?*)
            do scanSons(# do (current[]->AD[]).lastDen -> last[] #);
            #)
       #);
     ComputedRemote:< Transaction
       (# PP:: (# do 'ComputedRemote'-> lx.puttext #);
          label::(#do 'ComputedRemote' -> lab[] #);
          length:: (# do evl.length + NA.length -> value (* ??*)#); 
          PT:: 
            (# 
            do (pos,break) -> evl.PT; 
               '.' -> lx.put;
               NA.PT
            #);          
          evl: ^EvaluationList;
          NA: ^NameApl
       enter(evl[]->append,NA[]->append)
       #);
     ComputedRemoteX:< Transaction 
       (# tra: ^Transaction
       enter tra[] -> append
       #);
     ComputedRemoteAsDenotation:< AttributeDenotation
       (# CR: ^ComputedRemote
       enter CR[] -> append
       #);
     thisObject:< (*Transaction *) AttributeDenotation
       (# PT::
            (#
            do 'this'->lx.append;
               (if AD[] <> none then
                   '(' -> lx.put; (pos,break) -> AD.PT; ')'->lx.put
               if)
            #);
          Label:: (#do 'ThisObject'->lab[] #);
          AD: ^NameApl; 
       enter AD[] -> append
       #);
     Indexed:< AttributeDenotation
       (# PP:: (# do 'Indexed' -> lx.puttext #);
          PT:: 
            (# 
            do (pos,break) -> NA.PT ;
               '[' -> lx.put; (pos,break) -> EV.PT ; ']' -> lx.put
            #);
          length:: (# do NA.length + 1 + EV.length + 1 -> value #); 
          Label:: (#do 'Indexed'-> lab[] #);
          NA: ^AttributeDenotation; (* was NameApl; but gives sem error *)
          EV,uE: ^Evaluation
       enter(NA[] -> append,EV[]->append,uE[]->append)
       #);
     DynamicObjectGeneration:< Transaction
       (# PP:: (#do 'DynObjGen'-> lx.puttext #);
          length:: (# do 1 + OS.length -> value #);
          PT:: 
            (# 
            do '&'->lx.put;
               (pos,break) -> OS.PT;
               (if isRef and (EV[] <> none) then 
                   (pos,break) -> EV.PT
               if);
               (if isRef then '[' -> lx.put; ']' -> lx.put if);
            #);
          Label:: (#do 'DynamicObjectGeneration'->lab[] #);
          isRef: @boolean; 
          OS: ^BetaObjectSpecification;
          EV: ^Evaluation
       enter(OS[] -> append, EV[] -> append)
       #);
     StaticItem:< Item
       (# PP:: (#do label -> lx.append #);
          PT:: 
            (# 
            do ' '-> lx.put; '@' -> lx.put; 
               (if isComponent then '|'-> lx.put if);
               ' ' -> lx.put;  
               (if OS[] <> none then
                   (pos + 2,break) -> OS.PT
                else
                   '-none-' -> lx.append
               if);
            #);
          (* not really how to do it: ch: @char
           * char: (# #) is primitive
           * we should check  ATd.isPrimitivw
           *)
          setPrimitive:: (# do true -> isPrimitive -> OS.isPrimitive #);
          length:: (# do OS.length + 3 -> value #);
          Label:: (# do 'StaticItem' -> lab[] #);
          OS: ^BetaObjectSpecification; isComponent: @Boolean
       enter(OS[]->append,isComponent)
       #);
     DynamicItem:< Item
       (# PT:: 
            (# 
            do ' '-> lx.put; '^' -> lx.put;
               (if isComponent then '|'-> lx.put if);
               ' ' -> lx.put;  
               (if OS[] <> none then
                   (pos + 2,break) -> OS.PT
                else
                   '-none-' -> lx.append
               if);
            #);
          length:: (# do OS.length + 3 -> value #);
          Label:: (# do 'DynamicItem' -> lab[] #);
          setPrimitive:: (# do true -> isPrimitive -> OS.isPrimitive #);
          OS: ^BetaObjectSpecification;  isComponent: @Boolean
       enter(OS[]->append,isComponent)
       #);
     Repetition:< Item
       (# PP:: (#do 'rep' -> lx.puttext #);
          PT:: 
            (#
            do (pos,break) -> inx.PT ; (pos,break) -> IT.PT  
            #);
          length:: (# do inx.length + IT.length -> value #);
          label:: (#do 'Repetition' -> lab[] #);
          kind:: (# do '[' -> ch #);
          inx: ^Index;
          IT: ^StdBetaNode
       enter(inx[]->append, IT[]->append)
       #);
     Index:< StdBetaNode
       (# PP:: (#do 'Index' -> lx.puttext #);
          PT:: (# do '[' -> lx.put; (pos,break) -> EV.PT ; ']' -> lx.put #);
          length:: (# do 2 + EV.length -> value #);
          label:: (#do 'Index' -> lab[] #);
          EV: ^Evaluation
       enter EV[] -> append
       #);
     VarPtn:< Item
       (# PP: (# do 'VarPtn' -> lx.puttext #);
          length:: (# do AD.length + 3 -> value #);
          PT:: (# do ' ##' -> lx.append; (pos + 3,break) -> AD.PT #);
          Label:: (#do 'VarPtn'->lab[] #);
          kind:: (# do '*' -> ch #);
          Entity:: (# do AD.entity -> E[] #);
          AD: ^NameApl
       enter AD[] -> append
       #);
     SlotList: List
       (# element:: Slot;
          print:
            (#
            do (if not empty then
                   '**** Collected slots:'->dumpTN; 
                   scan(#do current.dopt -> dumpTN #);
                   newline;
               if)
            #)
       #);
     syntaxError:
       (# no: @integer
       enter no
       do
          '**** syntax error: '->puttext; no -> putint; newline;
          (if true then
              5 -> lex.printlines
           else
              (for i: 100 repeat
                   (if (lex.bTop - 99 + i > 0 )
                       and (lex.bTop - 99 + i < lex.buffer.range) then
                       lex.buffer[lex.bTop - 99 + i] -> put
                   if)
          for)if);
          stop
       #);
     objDesc,repetitionDesc: ^ObjectDesc;
     errorDecl: ^BetaDecl;
  do inner
  #)

