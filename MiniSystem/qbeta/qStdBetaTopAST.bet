ORIGIN '~beta/basiclib/betaenv';
INCLUDE '../compiler_IF/compiler_IF';
INCLUDE 'qStdBetaLexer'
---lib:attributes---
newVM: (# exit true #);

TrueValue: BooleanValue(# do true -> value #);
StdBetaTopAST: Tree
  (# level: @integer;
     NX_error: (# exit 1 #);
     QUA_error: (# exit 2 #);
     QUA_runTimeCheck: (# exit 3 #);
     type: 
       (# isValue:< booleanValue;
          isRef:< booleanValue;
          isStrucRef:< booleanValue;
          isNone:< booleanValue;
          isPrimitive:< booleanValue;
          isSingle:< booleanValue;
          theDesc:< (# D: ^node do inner exit D[] #);
          print:<  (# out: @text do inner exit out[] #);
          append:<
            (# TP,returnTP: ^type
            enter TP[]
            do (if TP[] <> none then 
                   inner 
                else
                  this(type)[] -> returnTP[]
               if)
            exit returnTP[]
            #);
          appendToList:<
            (# TPx,returnTP: ^type
            enter TPx[]
            do inner
            exit returnTP[]
            #);
          match:< integerValue
            (# left: ^type
            enter left[]
            do inner
            #);     
          matchList:< integerValue
            (# TPx: ^Type
            enter TPx[]
            do inner
            #);
       do inner 
       exit this(type)[]
       #);
     
     node: TopNode
       (# PT::<
            (#  hasNL: BooleanValue
                 (# comm: ^text
                 enter comm[]
                 do L: comm.scanAll
                      (# 
                      do (if ch = ascii.newline then 
                             true -> value;
                             leave L
                         if)
                      #)
                 #);
               atEol: BooleanValue
                 (#
                 do (lx.length > 0) 
                    and ((lx.length -> lx.inxGet) = ascii.newline)
                    -> value
                 #);
               breakIfNotAtEol:
                 (#
                 do (if not atEol then
                        (pos,true) -> mkBreak
                    if)
                 #);
               printComment:
                 (# NL, indented: @boolean; firstPos: @integer;
                    comm: ^Text
                 enter comm[]
                 do (if comm[] <> none then                        
                        comm.setPos;
                        pos -> firstPos;
                        pos > 0 -> indented;
                        (if comm[] -> hasNL -> NL then
                            (pos,true) -> mkBreak
                        if);
                        '(' -> lx.put; '*' -> lx.put; (* pos + 2 -> pos;*)
                        comm.scanAll
                        (#
                        do (if ch = ascii.newline then
                               firstPos -> pos;
                               (pos,true) -> mkBreak;
                               ' ' -> lx.put;
                               pos + 1 -> pos
                            else
                               ch -> lx.put; (*pos + 1 -> pos*)
                        if)#);
                        '*' -> lx.put; ')' -> lx.put; (*pos + 2 -> pos;*)
                        (if NL or indented then 
                            firstPos -> pos;
                            (pos,true) -> mkBreak 
                 if)if)#)
            do comment[] -> printComment;
               inner;
               commentAfter[] -> printComment;
            #);        
          comment,commentAfter: ^Text;
          cat: @ integer;
          sons: ^nodeList;
          addCommentAfter:
            (#
            do (if lex.skipComment.comment.length > 1 then
                   (if commentAfter[] <> none then
                       ascii.newline -> commentAfter.put;
                       lex.skipComment.get -> commentAfter.append
                    else
                       lex.skipComment.get -> commentAfter[]
               if)if)
            #);
          markAsSuper:< (# do inner #);
          getODorigin:: 
            (# ODx: ^Node;
            do origin[] -> ODx[];
               L:
                 (if not ODx.isObjDesc then 
                     ODx.getODorigin -> ODx[];
                     restart L
                 if);
               ODx[] -> OD[]
            #); 
          isObjDesc:< booleanValue;
          hasAttributes:< booleanValue; (* true for all Decl's that define
                                         * attributes: x: @ (# ... #), etc *)
          enterType:< (# TP: ^Type do inner exit TP[] #);
          exitType:< (# TP: ^Type do inner exit TP[] #);
                  
          doInsert::<
            (# 
            do this(node)[] -> N.father[]; inner
            #);
          
          findNodeAtPos::
            (#
            do L:
                 (if (beginPos <= pos) and (pos <= endPos) then
                     scanSons
                     (#
                     do  pos -> current.findNodeAtPos -> N[];
                        (if N[] <> none then 
                            (if trace then '>'-> put if);
                            leave L 
                        if)
                     #);
                     (if N[] = none then 
                         this(TopNode)[] -> N[]; 
                         (if trace then
                             newline; 
                             '[' -> put; beginPos -> putint; 
                             ',' -> put; endPos -> putint; ']' -> put;
            if)if)if)#);
          theModule::<
            (#
            do inner;
               (if md[] = none then
                   (if origin[] = none then
                       'thModule:origin is none: ' -> puttext;
                       doPT -> putline
                    else
                       origin.theModule -> md[]; 
               if)if)
            #);
          handlePrimitives:< 
            (# dcl: ^TopNode enter dcl[] do inner exit dcl[] #);
          search:< 
            (# N: ^text; dcl,withAd,withP: ^TopNode; on: @integer  
            enter N[] 
            do inner 
            exit(withAD[],withP[],dcl[],on) 
            #);
          localSearch:< 
            (# N: ^text; dcl: ^TopNode enter N[] do inner exit dcl[] #);
          hasInner:< (# on,value: @integer enter on do inner exit value #);
          goOrigin:< 
            (# ON: @integer; OD: ^TopNode; AD: ^TopNode (*AttributeDenotation*)
            enter(ON,AD[])
            do inner 
            exit OD[] 
            #);
          gen:< (# do inner #);
          emitForFields:< (# forNo: @integer enter forNo do inner #);
          (*origin: ^node; See Tree:TopNode:origin*)
          vNode::< Node;
          theStream: ^stream; 
          T: ^Text;
          

          (*lex.getComment -> comment[];*)
       do inner
       #);
     NodeList: TopNode
       (# Elm:< Node; (* Not used - we need a top super for Node and NodeList *)
          son: ^ elm (*Node*);
          next, last: ^NodeList;
          length: @integer;
       do inner
       #);
     lex: ^StdBetaLexer;     
  do
     inner
  #)
