ORIGIN '~beta/basiclib/betaenv';
(*INCLUDE '../compiler_IF/compiler_IF';*)
INCLUDE 'qCommonAST';
INCLUDE 'qStdBetaLexer'
---lib:attributes---
StdBetaTopAST: CommonAst
  (# hasNL: BooleanValue
       (# comm: ^text
       enter comm[]
       do L: comm.scanAll
            (# 
            do (if ch = ascii.newline then 
                   true -> value;
                   leave L
       if)#)#);
     atEol: BooleanValue
       (#
       do (lx.length > 0) and ((lx.length -> lx.inxGet) = ascii.newline)
            -> value
       #);
     
     StdBetaTop: Node
       (# PT::<
            (# breakIfNotAtEol:
                 (#
                 do (if not atEol then (pos,true) -> mkBreak if)
                 #);
               printComment:
                 (# NL, indented: @boolean; firstPos: @integer;
                    comm: ^Text
                 enter comm[]
                 do (if comm[] <> none then                        
                        comm.setPos;
                        pos -> firstPos;
                        pos > 0 -> indented;
                        (if comm[] -> hasNL -> NL then
                            (pos,true) -> mkBreak
                        if);
                        '(' -> lx.put; '*' -> lx.put; (*pos + 2-> pos;*)
                        comm.scanAll
                        (#
                        do (if ch = ascii.newline then
                               firstPos -> pos;
                               (pos,true) -> mkBreak;
                               ' ' -> lx.put;
                               pos + 1 -> pos
                            else
                               ch -> lx.put; (*pos + 1 -> pos*)
                        if)#);
                        '*' -> lx.put; ')' -> lx.put; (*pos + 2-> pos;*)
                        (if NL or indented then 
                            firstPos -> pos;
                            (pos,true) -> mkBreak 
                 if)if)#)
            do comment[] -> printComment;
               inner;
               commentAfter[] -> printComment;
            #);        
          comment,commentAfter: ^Text;
          addCommentAfter:
            (#
            do (if lex.skipComment.comment.length > 1 then
                   (if commentAfter[] <> none then
                       ascii.newline -> commentAfter.put;
                       lex.skipComment.get -> commentAfter.append
                    else
                       lex.skipComment.get -> commentAfter[]
            if)if)#);
          markAsSuper:< (# do inner #);

          doInsert::< (# do this(StdBetaTop)[] -> N.father[]; inner #);
          
          findNodeAtPos::
            (#
            do L:
                 (if (beginPos <= pos) and (pos <= endPos) then
                     scanSons
                     (#
                     do  pos -> current.findNodeAtPos -> N[];
                        (if N[] <> none then 
                            (if trace then '>'-> put if);
                            leave L 
                        if)
                     #);
                     (if N[] = none then 
                         this(TopNode)[] -> N[]; 
                         (if trace then
                             newline; 
                             '[' -> put; beginPos -> putint; 
                             ',' -> put; endPos -> putint; ']' -> put;
            if)if)if)#);
          theModule::<
            (#
            do inner;
               (if md[] = none then
                   (if origin[] = none then
                       'thModule:origin is none: ' -> puttext;
                       doPT -> putline
                    else
                       origin.theModule -> md[]; 
            if)if)#);
          vNode::< StdBetaTop;
       do inner;
          lex.getComment -> comment[]
       #);
  do
     inner
  #)
