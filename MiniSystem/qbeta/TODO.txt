
2. Check/fix return values from functions
   One simple value works - check multiple values and ref values
   If values are returned, then RTN should perhaps not retunr this!
   See return values below
4. Handle superpattern
   -- need to test/verify super patterns with arguments
   -- Origin for implicit super: see below
5. Module -> Decl, eliminate ModuleItem (perhaps needed for
   PrettyPrint!?) But should be sub of module or have common super?
6. Virtual patterns - and %if%then, etc
7. Further bindings
8. Complete checker - 
9. Unite encModule and FindModule
11. Fix included modules - the current solution is a hack
    Search via %include works
    Direct access of module name, like BLOCK.do does not work
    The current hack, marks BLOCK always, since we check all modules
    Perhaps we should just mark all Decl's that are accessed 
    This might avoid unused code from all modules!?
16. TopSuper is now just super - rename TopSuper to goSuper
 
    
Problem:
--------
All modules gets executed

For
	compiler myModule
myModule is executed at an arbitray place in between all other modules

The problem is that modules are static objects that gets executed when
allocated

%while BE %do S
----------------

If one or more arguments are virtual patterns, then the invocation is
a singular object:

   %while BE %do S {}

For invocatios like %while a < 0 %do a := a + 1, a := a + 1 must be treated
as a singular object { a := a + 1}

ObjectGeneration:
------------------
  OG = IV = %while BE % do S
       IS = {}

  IS.descNo = the descNo
  IS.superDesc = %while cond:< BooleanValue %do doPart:< Object

 Codegen for OG.IS
   must add BE.desc and S.desc to VDTable


Construction og Singular 
------------------------

   E = %while a < 0 %do a := a +1

   ObjectGeneration -> OG[];
   Invocation -> IV[];
   E -> IV.append;
   IV[] -> OG.IV[] -> OG.append;
   Items -> OG.IS[] -> OG.append;

Must setup various checker attributes
   superDesc
   descNo
   vsize, ...?
   
Perhaps we shuld do this in the checker?

For-loop
--------

For i: 1 to 10 repeat x := x + i

%for i %from first: @integer %to last: @integer %do body:< Object:
    ...



Inner:
------

msg1:
   x: @integer
   f: @Foo
   innerA - code generated - exe alloc of sub
   rtn A  - code
   x:= 12
   f.bar;
   inner
   x:=13
   rtn D  - code

msg2: msg1
   TopSuper msg1 - goto alloc of topSuper
 enterE:
   z: @integer
   innerA
   rtnInner
 doE:
   z:= 14
   inner
   z:= z + 1
   rtnInner

msg3:
   topSuper msg1
 enterE:
   q: @integer
   rtnInner
 doE:
   q := 17
   rtnInner

Origin for objectDesc:
----------------------
R: { foo: bar { ...}
   }

R.foo  -- non singular

   LoadOrigin = R
   Alloc foo

Code for foo: bar{ ... }
   store foo.origin
   LoadOrigin Bar
   exe bar.alloc
   
R.foo{ ... } -- singular

   loadOrigin = thisObject
   Alloc foo

Implicit super
---------------
Consider

(1)	V:< { ... }
(2)	V:< A

   	Vf::< { ... } or Vf::  {...}

which both have V/A as an implicit super

We need to compute origin for the implicit super of V

Case (1) is trivial since V and Vf has the same origin

Consider case (2)

     A: {...}
...
     Q: { ... }
...
     QQ: Q{ V:< A; ... }          -- A.on = n
...
     QQQ: QQ{ ... }              -- 
....
     QQQQ: QQQ{ Vf:: {... } ... } --

Given an instance of QQQ, we have
     QQQQ.originOff
     QQQ.originOff
     QQ.originOff
     Q.originOff

Origin for Vf.super may be computed by
     load QQ.originOff
     goOrigin(n)

  
Super
------

Foo: bar { ... }
Foo: R.bar { ... }
Foo: max(1,2) { ... }
Foo(x: @integer, y: @integer): max(x,y) { ... }
Foo(x: @integer): max(x,y + 100) { ... }

Does this work for virtuals?
-----------------------------

%put V: @integer %at inx: @integer :< ...

%put V: @integer %at inx: @integer:: { ... }

%put%at :: { ... }

It must be the same signature - i.e the signature cannot be extended!?

Scope for super
------------------

Foo: R.S.bar{ ... }

R, should be defined in origin of Foo

Foo(x: @integer): R.Bar(x + 2){ ... }

R and Bar has scope  = Foo.origin
Argument of Bar (x) has scope Foo.signature!

So do we ned more than one scope argument:
   thisScope
   enclosingScope = thisScope.origin
   signatureScope

For both R and x (in R.bar(x + 1 )), we must add 1 (one) to origin
(on)

How do we know which scope to search?

Normal invocations

   R.Bar(X + 2)

R and X in thisScope

Boolean: inSuper

(if inSuper then 
    use enclosingScope for an nvocation
    use signatureScope for arguments of Binary,Function and KeyWord

Return Values
-------------
Currently a return value is defined as follows
   max(x: @intger, y: @integer) -> z: @integer: 
       ...
       z := exp

Forcontrol structures like

   %while a < b %do ...

a < b should be the value of cond

   cond:< BooleanValue

   BooleanValue -> value: @Boolean
       inner

So either
   
    BooleanValue -> Boolean
        value := inner

or

   last Exp is always the value - we must then declare the type of the
   value

LoadAdr/origin
--------------

Foo
   - pushThis
   - foo.ON -> goOrigin

R.S.Foo
   - pushThis
   - R.ON -> goOrigin
   - push R.off
   - push S.off

Consider
--------

R.foo(e1,e2).S.Bar(e3,e4) -- here we must execute foo

   -- pushThis
   -- push R.off
   -- eval e1, e2
   -- Alloc foo - and execute - must return a ref to obj with S attribute
   -- push S.off
   -- eval e3, e4
   -- Alloc Bar
   
Singular

R.foo(e1,e2).S.Bar(e3,e4){ ... } = X

   -- pushThis
   -- push R.off
   -- eval e1, e2
   -- Alloc foo - and execute - must return a ref to obj with S attribute
   -- push S.off
   -- Alloc X - includes alloc of Bar

X: -- store origin
   -- eval e3,e4  - but in context of the call: R.foo(e1,e2) ... 
   -- goSuper Bar

hest(a,b: @integer): R.foo(e1,e2).S.Bar(e3,e4){ ... } = X
   super of X must be evaluated in the context of X, i.e. where hst is declared

hest(f1,f2) 


Execute
-------

Foo
   - loadAdr
   - Alloc Foo

V -- SimpleValue
   - loadAdr
   - push V

Recursive patterns
------------------

Consider

   MyPtn:
      ...
      MyPtn
      ...

   MySub: MyPtn
      ...

When executing MySub, a recursive call of MyPtn is invoced.
   * Is this just an instance of MySub
   * Or is this an invocation of MySub!?

How do we implement this!?
   * A copy of thisObject - need to follow origin
   * What if MySub has arguments? We dont know the formal parameters
     but if we just execute Alloc, the code storing the arguments will
     be executed 
   * Perhaps we just skip the origin, argument part
     - make a copy
     - execute starts at enterE!?
   * But MyPtn may have arguments - and then strange not to be able 
     to supply them
     - In principle we may allow MyPtn arguments and just copy MySub
       arguments
     - But more tricky to implement!?
     - Perhaps not! If we execute MyPtn.Alloc, then it seems to work
       Normally we would start at MySub, but by executing MyPtn,
       we just store origin and arguments for MyPtn and then proceed
       to the remaining alocation code and do an innerA

But what is a recursive call?

    MyPtn:
      ...
      foo:
         ... MyPtn   -- through a remote execution, but ok?
      bar:
         ... MyPtn   --  MyPtn is on the stack, so ok
      ...
      MyPtn
      bar

    MySub        -- OK
    R: @ MySub  
    R.foo        -- Seems ok!?
    
Labels
------

   MyPtn:
      ...
      $loop:
         ...
         %restart $loop
      loop:
         ...
         %restart loop

Strong similarity between a pattern and a labelled imperative

A pattern should not be an imperative

   MyPtn:
      ...
      loop:
         ...
         %restart loop
      loop   --- a bit clumsy


   MyPtn:
      ...
      loop
         ...
         %restart loop

    -- loop refers to superpattern of enclosing object!?

Using static object as labelled statement:

   MyPtn:
      ...
      loop: @
         ...
         %restart loop

    while:
       cond:< BooleanValue
       doPart:< Object
       loop: @
          %if cond %then
              doPart
              %restart loop

 Reconsider if this works with super/subpatterns

Origin search
-------------
As of now ON is counted when we search an enclosing singular

     %foo e %at { x := x + 1} {}

IS is empty for %foo%at ..

%foo%at generates an object so it is probably ok

For 

   %if e %then { x := x + 1}{}

there is no object since %if%then is primitive. We should thus not
increment on here. Cond and thenPart might be referred!?

New Alloc - Invoke
-----------------

Invoke = Alloc:
    - dont pop origin from thisStack
    - callee -> thisObj - dont assign thisStack
    - dont push origin

Code
    - store arguments
    - store origin - always
    - push super arguments - use thisObj.origin + on
    - push super.origin - same 
    - doSuper
    - enterE: mvStack - but only necessary in topSuper
    - ...
call foo(e1,e2,e3)
    -push foo.origin
    -push e1,e2,e3
    - invoke
