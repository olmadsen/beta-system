
2. Check/fix return values from functions
   One simple value works - check multiple values and ref values
   If values are returned, then RTN should perhaps not retunr this!
4. Handle superpattern
   -- need to test/verify super patterns with arguments
   -- need to test super with
      myClass: %put%at
          ...
   -- Origin for implicit super: see below
5. Module -> Decl, eliminate ModuleItem (perhaps needed for
   PrettyPrint!?) But should be sub of module or have common super?
6. Virtual patterns - and %if%then, etc
7. Further bindings
8. Complete checker - 
9. Unite encModule and FindModule
10. Fix PT to handle Arguments for Functional and KeyWord
11. Fix included modules - the current solution is a hack
    Search via %include works
    Direct access of module name, like BLOCK.do does not work
    The current hack, marks BLOCK always, since we check all modules
    Perhaps we should just mark all Decl's that are accessed 
    This might avoid unused code from all modules!?
12. Make load2 replace load
13. Clean-up loadOrigin - not used for super in items:genClass
14. Fix searchSuperAndSig , localSearch
    In super both locals and sig must be searched
15. If we use super as an invocation (see below), 
    then clean-up syntax for
    ObjectGeneration and ObjectDesc
16. TopSuper is now just super - renmae TopSuper to Super - which
    perhaps is already used!?
 
    
Problem:
--------
All modules gets executed

For
	compiler myModule
myModule is executed at an arbitray place in between all other modules

The problem is that modules are static objects that gets executed when
allocated

%while BE %do S
----------------

If one or more arguments are virtual patterns, then the invocation is
a singular object:

   %while BE %do S {}

For invocatios like %while a < 0 %do a := a + 1, a := a + 1 must be treated
as a singular object { a := a + 1}

ObjectGeneration:
------------------
  OG = IV = %while BE % do S
       IS = {}

  IS.descNo = the descNo
  IS.superDesc = %while cond:< BooleanValue %do doPart:< Object

 Codegen for OG.IS
   must add BE.desc and S.desc to VDTable


Construction og Singular 
------------------------

   E = %while a < 0 %do a := a +1

   ObjectGeneration -> OG[];
   Invocation -> IV[];
   E -> IV.append;
   IV[] -> OG.IV[] -> OG.append;
   Items -> OG.IS[] -> OG.append;

Must setup various checker attributes
   superDesc
   descNo
   vsize, ...?
   
Perhaps we shuld do this in the checker?

For-loop
--------

For i: 1 to 10 repeat x := x + i

%for i %from first: @integer %to last: @integer %do body:< Object:
    ...



Inner:
------

msg1:
   x: @integer
   f: @Foo
   innerA - code generated - exe alloc of sub
   rtn A  - code
   x:= 12
   f.bar;
   inner
   x:=13
   rtn D  - code

msg2: msg1
   TopSuper msg1 - goto alloc of topSuper
 enterE:
   z: @integer
   innerA
   rtnInner
 doE:
   z:= 14
   inner
   z:= z + 1
   rtnInner

msg3:
   topSuper msg1
 enterE:
   q: @integer
   rtnInner
 doE:
   q := 17
   rtnInner

Origin for objectDesc:
----------------------
R: { foo: bar { ...}
   }

R.foo  -- non singular

   LoadOrigin = R
   Alloc foo

Code for foo: bar{ ... }
   store foo.origin
   LoadOrigin Bar
   exe bar.alloc
   
R.foo{ ... } -- singular

   loadOrigin = thisObject
   Alloc foo

Implicit super
---------------
Consider

(1)	V:< { ... }
(2)	V:< A

   	Vf::< { ... } or Vf::  {...}

which both have V/A as an implicit super

We need to compute origin for the implicit super of V

Case (1) is trivial since V and Vf has the same origin

Consider case (2)

     A: {...}
...
     Q: { ... }
...
     QQ: Q{ V:< A; ... }          -- A.on = n
...
     QQQ: QQ{ ... }              -- 
....
     QQQQ: QQQ{ Vf:: {... } ... } --

Given an instance of QQQ, we have
     QQQQ.originOff
     QQQ.originOff
     QQ.originOff
     Q.originOff

Origin for Vf.super may be computed by
     load QQ.originOff
     goOrigin(n)

  
Super
------

Foo: bar { ... }
Foo: R.bar { ... }
Foo: max(1,2) { ... }
Foo(x: @integer, y: @integer): max(x,y) { ... }
Foo(x: @integer): max(x,y + 100) { ... }

Does this work for virtuals?
-----------------------------

%put V: @integer %at inx: @integer :< ...

%put V: @integer %at inx: @integer:: { ... }

%put%at :: { ... }

It must be the same signature - i.e the signature cannot be extended!?



