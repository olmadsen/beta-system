ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/guienv';
INCLUDE '../compiler_IF/directoryComponents';
INCLUDE 'qgenerator';
INCLUDE '../VM/betaVM'
---program:descriptor---
SystemEnv
(# compile: @generator;
   VM: @ betaVM
     (# putCH:: (# do ch -> put #);
        getCh:: (# do get -> ch #);
        (*errorEvent:: (# do msg[] -> putline; done #);*)
        scanEvent::
          (#  IS: ^compile.Items; 
          do '\nscanEvent: ' -> puttext; 
             (obj.myObjDesc).descInx -> compile.getObjectDesc -> IS[];
             IS.doPT -> putline
          #);
        dumpObjEvent::
          (# length: IntegerValue
               (# lengthOfDcl: integerValue
                    (# D: ^compile.DataItem; 
                    enter D[]
                    do value 
                       + D.sig.id.length + 1 (* sig.id + zero *)
                       + 4 (* off, kind, size, descNo *)
                         -> value;
                       (if D.OG.isValueObj then
                           (if D.OG.IS.isEmpty then
                               (if D.OG.primNo 
                                // integer_prim
                                // char_prim
                                // boolean_prim 
                                // value_prim then
                                   value + 1 -> value
                                else
                                   ((D.OG.superPtn).OG.IS[] -> length) + value 
                                     -> value
                               if)
                            else
                               (D.OG.IS[] -> length) + value -> value
                           if)
                        else
                           value + 1 -> value
                       if);
                       (*'lengthOf: ' -> puttext; D.doPT -> puttext; ' ' -> put;
                       value -> putint; newline*)
                    #);
                  
                  IS: ^compile.Items; ptn: ^compile.Pattern
               enter IS[]
               do (if (IS.sig[] <> none) and (IS.sig.args[] <> none) then
                      IS.sig.args.scanSons
                      (#
                      do (current[] -> lengthOfDcl) + value -> value
                      #);
                  if);
                  (if false and IS.encOG.isSubOfBasicValue then
                      (* add $1 length = 2 + 1 + 4 + 1 = *)
                      8 -> value;
                  if);
                  (if IS.super.ATd[] <> none then
                      (if true
                       // IS.super.ATD.isPattern then
                          IS.super.ATd[] -> ptn[];
                          (ptn.OG.IS[] -> length) + value -> value
                  if)if);
                  IS.scanSons
                  (# D: ^compile.DataItem; size: @integer
                  do (if current.isDataItem then
                         (current[] -> lengthOfDcl) + value -> value
                  if)#);
                  (*'length: ' -> puttext; value -> putint; newline*)
               #);
             add:
               (# V: @integer
               enter V
               do v -> items[top + 1 -> top];
               #);
             top: @integer;
             
             decode:
               (# decodeDcl:
                    (# D: ^compile.DataItem; size,kind: @integer
                    enter D[]
                    do (if false then 
                           D.newOff -> putint; ':' -> put;
                           D.objSize -> size;
                           (if size = 0 then 1 -> size if);
                           size -> putint; ' ' -> put;
                           D.sig.id[] -> puttext; 
                           (if D.isConst then ' const' -> puttext
                            else ' var' -> puttext
                           if);
                           (if true
                            // D.OG.isPrimitive then ' primitive' -> puttext
                            // D.OG.isValueObj then ' value' -> puttext;
                            else ' ref' -> puttext;
                           if);
                           ' descNo:' -> puttext;
                           D.OG.IS.newDescNo -> putint;
                           newline;
                       if);
                       (for i: D.sig.id.length repeat 
                            i -> D.sig.id.inxGet -> add
                       for);
                       0 -> add;
                       D.newOff -> add;
                       D.objSize -> size;
                       (if (size = 0) then 1 -> size if);
                       size -> add;
                       (if true
                        // D.OG.isPrimitive and (D.primNo <> indexed_prim) then 
                           (if D.isConst then 0 -> kind -> add
                            else 1 -> kind -> add;
                           if);
                        // D.OG.isValueObj then
                           (if D.isConst then 2 -> kind -> add
                            else 3 -> kind -> add;
                           if)
                        else
                           (if D.isConst then 4 -> kind -> add
                            else 5 -> kind -> add;
                           if);
                       if);
                       D.OG.IS.newDescNo -> add; (* May not be ok, since we changed
                                                  * from callimg descNo in 
                                                  * qvariants
                                                  *)
                       (if kind // 2 // 3 then
                           (if D.OG.IS.isEmpty then
                               (D.OG.superPtn).OG.IS[] -> decode
                            else
                               D.OG.IS[] -> decode; 
                           if)
                        else
                           0 -> add
                       if);
                    #);
                  IS: ^compile.Items; ptn: ^compile.pattern
               enter IS[]
               do (if (IS.sig[] <> none) and (IS.sig.args[] <> none) then
                      IS.sig.args.scanSons(#do current[] -> decodeDcl #);
                  if);
                  (if false and IS.encOG.isSubOfBasicValue then 
                      (* add $1 *)
                      '$' -> add; '1' -> add; 0 -> add;
                      1 -> add; 1 -> add; 1 -> add; 0 -> add;
                      0 -> add;
                  if);
                  (if IS.super.ATd[] <> none then
                      (if true
                       // IS.super.ATD.isPattern then
                          IS.super.ATd[] -> ptn[];
                          ptn.OG.IS[] -> decode
                  if)if);
                  IS.scanSons
                  (# 
                  do (if current.isDataItem then
                         current[] -> decodeDcl;         
                     if)
                  #);
               #);
             IS: ^compile.Items; 
          do (*'\ndumpObjEvent:'->putline; *)
             (obj.myObjDesc).descInx -> compile.getObjectDesc -> IS[];
             (*IS.doPT -> putline; '---' -> putline;*)
             IS[] -> length -> items.new;
             IS[] -> decode
          #);
        done:: 
          (# descInx,objId,lsc: @integer; IS: ^compile.Items
          do (if VM.stopErrors[] <> none then
                 0 -> stopErrors.setPos;
                 stopErrors.getInt -> descInx;
                 stopErrors.getInt -> objId;
                 stopErrors.getInt -> lsc;
                 stopErrors.getLine;
                 newline;
                 stopErrors.scan(#do ch -> put #);
                 newline;
                 descInx -> compile.getObjectDesc -> IS[];
                 '**** at:\n       ' -> puttext;
                 IS.father.doPT -> putline; newline;
             if);
             stop 
          #)
     #);
   setWindowEnv:: (# do myWindowEnv[] -> theWindowEnv[]#);
   myWIndowEnv: @ guienv;

   readArguments:
     (# arg: ^text
     do run_Beta_INT -> runMode;
        (for i: noOfArguments - 2 repeat
             i + 1 -> arguments -> arg[];
             (if true
              // ('-x' -> arg.equalNCS) then      
                 ' ' -> put;
                 true -> compile.onlyLex
              // ('-c' -> arg.equal) then   
                 run_C_INT -> runMode;
              // ('-C' -> arg.equal) then   
                 save_BC_Image -> runMode;
              // ('-v' -> arg.equalNCS) then   
                 true -> compile.verbose
              // ('-t' -> arg.equalNCS) then
                 true -> compile.traceEmbedding
              // ('-f' -> arg.equalNCS) then
                 true -> compile.toFix
              // '-l' -> arg.equalNCS then
                 true -> compile.emitLLVM
              // '-a' -> arg.equalNCS then
                 true -> compile.emitCom  
              // '-d' -> arg.equal then
                 true -> compile.traceLLVMcalls
              // '-D' -> arg.equal then
                 true -> compile.traceLLVMcalls -> compile.dumpLLVMobjs
              // (arg.length > 2) and ('-d'-> ((1,2)->arg.sub).equalNCS) 
                 then
                 '\n**** debug:'->puttext; arg[] -> puttext;
                 (for i: arg.length - 2 repeat
                      (if (i + 2) -> arg.inxGet
                       // 'c' then 
                          ':checker' -> puttext; true -> compile.traceCheck
                       // 's' then 
                          ':search'->puttext; true -> compile.traceSearch
                       // 'u' then 
                          ':unit'->puttext; true -> compile.traceUnit
                       // 'g' then 
                          ':generator'-> puttext
                       // 'p' then true -> compile.mainPT
                       // 'P' then true -> compile.mainPP
                       // 'q' then true -> compile.traceGetVqual
                       else
                          ':invalid argument: '->puttext; 
                          (i + 2) -> arg.inxGet -> put;
                          newline
                 if)for);
                 newline
              else
                 '\n\n**** invalid argument: ' -> puttext; 
                 arg[] -> putline;
             if);             
        for);
        noOfArguments  -> arguments -> FN[];
     #);
   linkLLVM:
     (# llvmLib,cmd: ^text; res: @integer;
        system: external
          (# cmd: [0] @char; res: @integer
          enter cmd
          do callC
          exit res
          #)
     do BetaLib -> llvmLib[];
        (*compile.dirCh*) 
        '/MiniSystem/VM/qbeta_llvm_lib.c' -> llvmLib.append;
        (* Note! clang is a link to clang-8, but system can apparently 
         * not handle links - we thus use clang-8 directly
         *)
        'clang-8 ' -> cmd[];
        (FN[],'.ll') -> mkAuxName -> cmd.append;
        ' '  -> cmd.put;
        llVmlib[] -> cmd.putline;
        cmd[] -> putline;
        cmd -> system -> res
     #);
   runMode: @integer;
   FN,FNx: ^text;
   F: @file
     (# NoSuchFileError ::< (# do true -> continue; false -> OK #); 
     #);
   OK: @boolean
do 'qBETA COMPILER: ' -> puttext;
   readArguments;
   ('/MiniSystem/qbeta/BETAworld/','.xbeta','.qbeta') 
     -> compile.initDirectoryModules;
   FN[] -> compile.fixExtension_xbeta -> FN[] -> putline;
   FN[] -> F.name;
   true -> OK;
   F.openRead;
   (if OK then 'file exists' -> putline 
    else
       FN[] -> FNx[];
       '.qbeta' -> ((1,FN.length - 6) -> FN.sub).append -> FN[];
       FN[] -> putline;
       FN[] -> F.name;
       true -> OK -> compile.altParser;
       F.openRead;
       (if not ok then
           '\n!!!! No such file: ' -> puttext; FNx[] -> putline;
           '!!   or : ' -> puttext; FN[] -> putline;
           stop
       if)
   if);
            
   (none,false,none,FN[]) -> compile; 
   
   (if compile.emitLLVM then
       linkLLVM;
       stop
    else
       (runMode,true) -> VM.init;
       (if not compile.onlyLex 
           and not compile.hasSyntaxError
           and not compile.semanticErrors 
           then
           (compile.runtimeDescs,compile.mainDescNo,FN[],runMode) 
             -> VM.execute.init;
           VM.execute[] -> fork;
        else
           stop
       if)
   if)
#)
