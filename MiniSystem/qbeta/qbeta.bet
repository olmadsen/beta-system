ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/guienv';
INCLUDE '../compiler_IF/directoryComponents';
INCLUDE 'qgenerator';
INCLUDE '../VM/betaVM'
---program:descriptor---
SystemEnv
(# compile: @generator;
   VM: @ betaVM
     (# putCH:: (# do ch -> put #);
        getCh:: (# do get -> ch #);
        errorEvent:: (# do msg[] -> putline; done #);
        dumpObjEvent::
          (# length: IntegerValue
               (# lengthOfDcl: integerValue
                    (# D: ^compile.DataItem; size: @integer
                    enter D[]
                    do value 
                       + D.sig.id.length + 1 (* sig.id + zero *)
                       + 4 (* off, kind, size, descNo *)
                         -> value;
                       D.objSize -> size;
                       (if size = 0 then 1 -> size if);
                       (if D.OG.isValueObj then
                           (if false then 
                               value + size -> value;
                            else
                               (if D.OG.IS.isEmpty then
                                   ((D.OG.superPtn).OG.IS[] -> length) + value -> value
                                else
                                   (D.OG.IS[] -> length) + value -> value
                               if)
                           if)
                        else
                           value + 1 -> value
                       if);
                       (*'lengthOf: ' -> puttext; D.doPT -> puttext; ' ' -> put;
                       value -> putint; newline*)
                    #);
                  
                  IS: ^compile.Items
               enter IS[]
               do (if (IS.sig[] <> none) and (IS.sig.args[] <> none) then
                      IS.sig.args.scanSons
                      (#
                      do (current[] -> lengthOfDcl) + value -> value
                      #);
                  if);
                  IS.scanSons
                  (# D: ^compile.DataItem; size: @integer
                  do (if current.isDataItem then
                         (if true then
                             (current[] -> lengthOfDcl) + value -> value
                          else
                             current[] -> D[];
                             value 
                             + D.sig.id.length + 1 (* sig.id + zero *)
                             + 4 (* off, kind, size, descNo *)
                               -> value;
                             D.objSize -> size;
                             (if size = 0 then 1 -> size if);
                             (if D.OG.isValueObj then
                                 (if false then 
                                     value + size -> value;
                                  else
                                     (D.OG.IS[] -> length) + value -> value
                                 if)
                              else
                                 value + 1 -> value
                             if)
                         if)
                  if)#);
                  'length: ' -> puttext; value -> putint; newline
               #);
             add:
               (# V: @integer
               enter V
               do v -> items[top + 1 -> top];
               #);
             top: @integer;
             
             decode:
               (# decodeDcl:
                    (# D: ^compile.DataItem; size,kind: @integer
                    enter D[]
                    do 
                       D.newOff -> putint; ':' -> put;
                       D.objSize -> size;
                       (if size = 0 then 1 -> size if);
                       size -> putint; ' ' -> put;
                       D.sig.id[] -> puttext; 
                       (if D.isConst then ' const' -> puttext
                        else ' var' -> puttext
                       if);
                       (if true
                        // D.OG.isBasic then ' basic' -> puttext
                        // D.OG.isValueObj then ' value' -> puttext;
                        else ' ref' -> puttext;
                       if);
                       ' descNo:' -> puttext;
                       D.OG.descNo -> putint;
                       newline;
                       (for i: D.sig.id.length repeat 
                            i -> D.sig.id.inxGet -> add
                       for);
                       0 -> add;
                       D.newOff -> add;
                       D.objSize -> size;
                       (if (size = 0) then 1 -> size if);
                       size -> add;                       
                       (if true
                        // D.OG.isBasic and (D.primNo <> indexed_prim) then
                           (if D.isConst then 0 -> kind -> add
                            else
                               1 -> kind -> add;
                           if);
                        // D.OG.isValueObj then
                           (if D.isConst then 2 -> kind -> add
                            else
                               3 -> kind -> add;
                           if)
                        else
                           (if D.isConst then 4 -> kind -> add
                            else
                               5 -> kind -> add;
                           if)
                       if);
                       D.OG.descNo -> add; 
                       (if kind // 2 // 3 then
                           (if true then
                               (if D.OG.IS.isEmpty then
                                   (D.OG.superPtn).OG.IS[] -> decode
                                else
                                   D.OG.IS[] -> decode; 
                               if)
                            else
                               (for i: size repeat 
                                    0 -> add; (* value *)
                               for)
                           if)
                        else
                           0 -> add
                       if)
                    #);
                  IS: ^compile.Items; 
               enter IS[]
               do (if (IS.sig[] <> none) and (IS.sig.args[] <> none) then
                      IS.sig.args.scanSons(#do current[] -> decodeDcl #);
                  if);
                  IS.scanSons
                  (# 
                  do (if current.isDataItem then
                         current[] -> decodeDcl;         
                     if)
                  #);
               #);
             IS: ^compile.Items; 
          do (*'\ndumpObjEvent:'->putline;*)
             (obj.myObjDesc).descInx -> compile.getObjectDesc -> IS[];
             IS[] -> length -> items.new;
             IS[] -> decode
          #);
        done:: (# do stop #)
     #);
   setWindowEnv:: (# do myWindowEnv[] -> theWindowEnv[]#);
   myWIndowEnv: @ guienv;
   runMode: @integer;
   FN: ^text;
   F: @file;
   readArguments:
     (# arg: ^text
     do run_Beta_INT -> runMode;
        (for i: noOfArguments - 2 repeat
             i + 1 -> arguments -> arg[];
             (if true
              // ('-x' -> arg.equalNCS) then      
                 ' ' -> put;
                 true -> compile.onlyLex
              // ('-c' -> arg.equal) then   
                 run_C_INT -> runMode;
              // ('-C' -> arg.equal) then   
                 save_BC_Image -> runMode;
              // ('-v' -> arg.equalNCS) then   
                 true -> compile.verbose
              // ('-t' -> arg.equalNCS) then
                 true -> compile.traceEmbedding
             if);             
        for);
        noOfArguments  -> arguments -> FN[];
     #);
do 'qBETA COMPILER: ' -> puttext;
   readArguments;
   ('/MiniSystem/qbeta/BETAworld/','.xbeta') -> compile.initDirectoryModules;
   FN[] -> compile.fixExtension_xbeta -> FN[] -> putline;
   FN[] -> F.name;
   F.openRead;
   
   (none,false,none,FN[]) -> compile; 
   
   (runMode,true) -> VM.init;
   (if not compile.onlyLex and not compile.semanticErrors then
       (compile.runtimeDescs,compile.mainDescNo,FN[],runMode) -> VM.execute.init;
       VM.execute[] -> fork;
    else
       stop
   if);
#)
