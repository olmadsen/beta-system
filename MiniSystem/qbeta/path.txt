  pathToDcl:<
   (# P: ^SuperPath
   enter P[]
   do inner
   exit P[]
   #);
 pathToDclX:<
   (# P: ^SuperPath; i: @integer; qual: ^ObjectGenerator
   enter(P[],i)
   do inner
   exit qual[] !!!! should not exit qual
   #);

Invocation::
    pathToDcl::
       ...
    pathToDclX::
       ...

ObjectInvocation:
   getV_qual::
      ...
      (if (father[]->INV[]).rN > 1 then
           (none,rN) -> INV.pathToDclX -> qual[]
       else
          (encOG[],ATd[],this(ObjectInvocation)[],on,pn,none) 
           -> OGpath 
           -> ATd.pathToDcl 
           -> Px[];
           Px.findQual -> qual[];
      if)
    pathToDcl::
        ...
       (if true then
           !!! Move non-include case code to here and only call viaInclude
	   !!! if it is in fact via include
           (this(ObjectInvocation)[],on,P[],true) -> viaIncludeX -> P[]
        else
	   viaInclude -> (onx,nest);
           (origin.father[],ATd[],this(ObjectInvocation)[],on+onx,pn,P[])
            -> OGpath -> ATd.pathToDcl -> P[];
       if)
       ...
    pathToDclX::
       (if n = 1 then
           P[] -> OI.pathToDcl -> P[];
	   P.computeOGSeq -> S[];
	else
	   (enclosingObjectGenerator,E.ATd[],E[],E.on,E.pn,none)
            -> OGpath
	    -> E.ATd.pathToDcl
	    -> P[];
           (S[],true) -> P.appendSeq -> (S[],qual[]);	    
      if);
      (if n = i then leave if)
      ...
    viaInclude:
       ...
    viaIncludeX:
       ...
       (OI[],on + onx,P[],false) -> viIncludeX -> P[]
	  
qvirtual:
    OGPath:
       getSeqAndQual::
       (#
       enter Sx[]
       do
       exit(Sx[],qual[])
       #);
       appendSeq::
          (#
	  enter(Sx[],first)
             ...
             findbinding -> ...
           exit Sx[]
           #)


       
       
