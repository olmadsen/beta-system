ORIGIN 'qabstractSyntaxTree'
---astlib:attributes---
(* the patterns here are called from semchecker via 
 * semchecker::ObjectInvocationgetV_qual, which is called from
 * checker::ObjectInvocation:check to get the qualification of a given OI
 *)
traceGetV_qual: (# exit false #);
OGsequence:
  (* Represents a pattern sequence as described in the OOPSLA article:
   *   Semantic Analysis of Virtual Classes and Nested Classes
   * Here we actually have a sequence of ObjectGenerators
   * OG1, OG2, ... OGn
   * where OG2 is super of OG1, OG3 of OG2, ... and OGn of OGn-1
   * OG1 is enclosing the application qualified by the virtual
   * where we want to find the most specific binding
   *)
  (# DOG: ^ObjectGenerator;
     pred: ^OGsequence;
     isRemote: @boolean;
     isNest: @Boolean;
     pathToSuper:
       (# OGsuper: ^ObjectGenerator; on,pn: @integer; E: ^Exp; 
          D: ^Decl; ptn: ^Pattern;
          i: @integer;
          isRemote: @boolean
       do (if DOG[] = none then 'DOG is none'->putline if);
          (if trx then '*** pathToSuper:' -> putline;  DOG.doPT -> putline if);
          (if not DOG.isChecked then
              (* this happens*) (*'!!! DOG is not checked' -> putline*)
          if);
          (if trx  then
              '**  pathToSuper:DOG.super: "' -> puttext;
              DOG.super.dopt -> puttext; '"\n' -> puttext
          if);
          DOG.super.scanSons
          (# 
          do current[] -> E[];
             i + 1 -> i
          #);
          (if false then
              i -> putint; newline;
              E.label -> putline;
              (DOG.super).doPP -> putline;
              E.doPP -> putline;
          if);
          i > 1 -> isRemote;      (* try noOfSons - implicitPre? *)  
          (if E[] = none then '!!! E is none'->putline if);
          (if trx then
              '**  pathToSuper:E:"' -> puttext; E.dopt -> puttext; 
              '" E.on: ' -> puttext; E.on -> putint;
              ' E.pn: ' -> puttext; E.pn -> putint;
              ' isRemote: ' -> puttext; isRemote -> putboolean; newline;
          if);
          E.ATd[] -> D[];
          (if D[] = none then
              (* Perhaps an implicit super of a virtual pattern *)
              (if trx then
                  '!!!! E.ATd is none DOG:'->putline;
                  DOG.doPT -> putline;
                  '**** isChecked: ' -> puttext; DOG.isChecked -> putboolean;
                  '\n DOG.super.pn: ' -> puttext; DOG.super.pn -> putint;
                  newline
              if);
              (* not a good way to test that DOG is part of virtual ptn*)
              (if DOG.father## <> Pattern## then
                   '!!!! pathToSuper:DOG.father is not Pattern or is empty: '
                    -> puttext; 'label: ' -> puttext; DOG.label -> putline;
                  DOG.doPT -> putline;
                  leave pathToSuper
               else
                  DOG.father [] -> ptn[];
                  (if ptn.vdcl[] = none then 
                      '!!!! pathToSuper:ptn.vdcl is none:A:'->putline;
                      ptn.doPT -> putline;
                  if);
                  ptn.vDcl[] -> ptn[];
              if)
           else
              (if D## <> Pattern## then
                  '!!!! pathToSuper:super.ATd is not Pattern or is empty: '
                    -> putline;
                  DOG.doPT -> putline;
                  leave pathToSuper
               else
                  D[] -> ptn[];
          if)if);
          (if ptn[] = none then '!!!! pathToSuper: ptn is none:B:'->putline if);
          ptn.OG[] -> OGsuper[];
          (if trx then
              '**  pathToSuper:isVirtual:' -> puttext;
              ptn.isVirtual -> putBoolean; ':ptn:\n' -> puttext;
              ptn.doPT -> putline;
              print
          if);
          E.on -> on; E.pn -> pn; DOG.super.pn -> pn
       exit(OGsuper[],on,pn,isRemote)
       #);
     ENC:
       (* ENC[D] = [D.origin]
        * ENC[D1,D2,...,Dn] = PRE(j) o ENC(i) 0 ENC[D1,D2,...,Dn-1]
        *    where Path(Dn) = (i,j)
        *)
       (# S: ^OGsequence; 
          OGsuper: ^ObjectGenerator; onx,pnx: @integer; isRemote: @boolean
       do (if trx or traceGetV_qual then
              '**** ENC: ****'->putline;
              print
          if);
          (if isNest then
              (if trx then '**   isNest: ' -> putline if);
              pred[] -> S[]
           else
              (if pred[] = none then (* head *)
                  (if trx then
                      '--  ENC:pred=none:before:origin:'->putline;
                      DOG.dopt -> putline
                  if);
                  (* this(OGsequence) is super of S *)
                  DOG.origin.father[] -> OGsequence -> S[];
                  (*this(OGsequence)[] -> S.pred[];*)
                  (if trx then
                      '**   ENC:pred=none:\n' -> puttext;
                      S.print
                  if);
               else
                  pred.pathToSuper -> (OGsuper[],onx,pnx,isRemote);
                  (if trx then
                      '**   ENC:after:pathToSuper:onx:' -> puttext;
                      onx -> putint; ':pnx:' -> puttext; pnx -> putint; 
                      ':isRemote:' -> puttext; isRemote -> putBoolean;
                      '\n**   OGsuper:' -> putline; 
                      (if OGsuper[] <> none then 
                          OGsuper.dopt -> putline else 'none'->puttext if);
                      '**   thisOGsuper:'->putline; print;
                  if);
                  (* thisOGS = [D1,D2,...,Dn-1,Dn], Dn = DOG *)
                  pred.ENC -> S[];
                  (if trx then 
                      '**   pred.ENC:onx: ' -> puttext; onx -> putint;
                      ' pnx: ' -> puttext; pnx -> putint;
                      ' isRemote: ' -> puttext; isRemote -> putboolean; newline;
                      S.print;
                  if);
                  (* S = ENC([D1,D2,...,Dn-1]) *)
                  (if false and isRemote then
                      (* Dn-1: R.P{...}, where R.P = Dn 
                       * onx = 0, pnx >= 0                  
                       *)
                   else
                      (for i: onx repeat S.ENC -> S[] for);
                      (for i: pnx  repeat S.PRE -> S[] for);
                      (if trx or traceGetV_qual then
                          '**   ENC:result:' -> putline;
                          S.print
                      if)
                  if);
          if)if)
       exit S[]
       #);
     PRE:
       (# S,Sx: ^OGsequence; 
          OGs,OGx: ^ObjectGenerator; onx,pnx: @integer; isRemote: @boolean;
          ptn: ^Pattern; MI: ^ModuleItem
       do (if trx or traceGetV_qual then
              '**** PRE: ****'->putline; print
          if);
          pathToSuper -> (OGs[],onx,pnx,isRemote);
          (if false and trx then '**   pathToSuper:D:' -> putline if);
          (if isRemote then
               (if traceGetV_qual then
                   '*** isRemote: ' -> puttext; 
               if);
              this(OGsequence)[] -> S[];
              DOG.super.scanSons
              (# E: ^Exp; D: ^SuperDataItem
              do current[] -> E[]; 
                 (if trx then
                     '**   PRE:scanSons:current: ' -> puttext; 
                     E.dopt -> puttext; ' ' -> put;
                     E.ATd.label -> putline;
                 if);
                 L:
                   (if isLast then
                       E.ATd[] -> ptn[];
                       PTN.OG[] -> OGx[]
                    else   
                       (if E.ATd## 
                        // DataItem## then
                           E.ATd[] -> D[]
                        // ModuleItem## then
                           (E.ATd[] -> MI[]).MD[] -> D[]
                        // pattern## then
                           (* ptn in x.P.r where P is pattern
                            * compiler error:
                            *  P resturns object - whic is not handled, 
                            *  see mustBeObject in qchecker
                            * semantic error: catched by checker
                            *) 
                           E.ATd[] -> ptn[];
                           PTN.OG[] -> OGx[];
                           leave L
                        else
                           E.ATd[] -> D[];
                       if);
                       (if D.OG.hasItems then
                           D.OG[] -> OGx[]
                        else
                           (D.OG.super.desc).father[] -> OGx[]
                   if)if);
                 OGx[] -> OGsequence -> Sx[];
                 true -> Sx.isNest;
                 S[] -> Sx.pred[];                 
                 Sx[] -> S[];
                 (if traceGetV_qual then
                     '***Remote-PRE:'->putline;
                     S.print
                 if)
              #);              
           else
              OGs[] -> OGsequence -> S[]; 
              this(OGsequence)[] -> S.pred[]
          if);
          (if trx or traceGetV_qual then
              '**   end:PRE'->putline;
              S.print
          if)
       exit S[]
       #);
       
     FB: 
       (# qual: ^ObjectGenerator
       do (if isNest then
              DOG[] -> qual[]
           else
              (if pred[] <> none then
                  pred.FB -> qual[]
               else
                  DOG[] -> qual[]
          if)if)
       exit qual[]
       #);
     print:
       (# L: @integer
       enter L 
       do (if L = 0 then
              '*** OGsequence[:'->puttext;
           else
              '**  OGS:sub[:' -> puttext;
          if);
          (if isRemote then 'isRemote:'->puttext if);
          (if isNest then 'isNest:'->puttext if);
          newline;
          (if DOG[] <> none then
              DOG.dopt -> putline;
           else
              'none'->putline
          if);
          (if pred[] <> none then
              L + 1 -> pred.print
          if);
          (if L = 0 then
              ']*** OGsequence\n' -> putline
           else
              ']** OGs:sub' -> putline
          if)
       #)
  enter DOG[]
  exit this(OGsequence)[]
  #);
OGPath: SuperPath
  (* Represents a path as described in the OOPSLA paper:
   *   path = (on,pn) from pred to OG 
   * for first element, pred = none, (on,pn) = (0,0)
   *)
  (# OG: ^ObjectGenerator;
     dcl: ^Decl;
     vDcl: ^Pattern; (* Is vDcl always the same as dcl? Probably yes!? *)
     OI: ^ObjectInvocation; (* Only included for debugging purposes *)
     on,pn: @integer; 
     isNest: @boolean; (* remote path - as e.g. for out R: ... *)
     pred: ^OGPath; (* sub of OG *);
     
     qual: ^ObjectGenerator; (* should be eliminated -! *)

     getQual:
       (# S: ^OGsequence; 
       do (if (trx) or traceGetV_qual then
              '\n**** OGpath:getQual:of:vDcl: "'-> puttext; 
              vDcl.doPT -> puttext; '"\n' -> putline;
              print
          if);
          computeOGseq -> S[];
          (if trx or traceGetV_qual then
              '\n*** before findBinding:' -> putline;
              S.print;
          if);
          (*false -> trx;*)
          S.FB -> findBinding -> qual[];
          (if qual.IS.isEmpty then
              (if trx then
                  '**** OGpath:getQual:qual is pattern: ' -> puttext; 
                  qual.dopt -> putline;
              if);
              qual.super.ATd.getQual -> qual[];
              (if trx then
                  '**   OGpath:getQual:of:super: ' -> putline; 
                  qual.dopt -> putline
              if)
          if)
       exit qual[]
       #);
     computeOGseq:
       (# S: ^OGsequence; OGx: ^ObjectGenerator; onx: @integer
       do (if trx or traceGetV_qual then
               '\n**** computeOGseq: on: ' -> puttext; on -> putint;
               ' pre: ' -> puttext; pn -> putint; 
               ' pred=none: ' -> puttext; pred[] = none -> putboolean;
               ' isNest: ' -> puttext; isNest -> putBoolean;
               newline; 
              '**   OG:' -> putline; OG.dopt -> putline;
              (*OG.doPP -> putline;*)
           if);
          (if isNest then on - 1 -> onx else on -> onx if);
          (if pred[] <> none then
              (if trx then 
                  '**   computeOGsequence:go:pred: ' -> putline;
              if);
              pred.computeOGseq -> S[]; 
              (for i: onx repeat S.ENC -> S[] for); 
              (for i: pn repeat S.PRE -> S[] for);
              (if trx or traceGetV_qual then
                  '**   computeOGseq:got:OGseq:plain(head<>none):'->putline;
                  S.print
              if)
           else
              (if trx then
                  '**   computeOGsequence:pred is none:onx: ' -> puttext;
                  onx -> putint; newline
              if);
              OG[] -> OGx[];
              (if trx and false then OGx.doPT -> putline; if);
              (for i: onx repeat 
                   OGx.origin.father[] -> OGx[];
                   (if trx then
                       '**   gorigin:' -> putline;
                       OGx.doPT -> putline;                   
                   if)
              for);
              (if trx then '///'->putline; if);
              OGx[] -> OGsequence -> S[];
              (if trx then 
                  S.print; 
                  '**   goPre:pn:' -> puttext; pn -> putint; newline
              if);
              (for i: pn repeat S.PRE -> S[] for);
              (if trx  then
                  '** computeOGseq:got:OGseq:single(pred=none):' -> putline;
                  S.print
              if)
          if)
       exit S[]
       #);
     findBinding:
       (# OGx: ^ObjectGenerator; qual: ^ObjectGenerator
       enter OGx[]
       do (if (trx) or traceGetV_qual then
              '***  findBindingOf:vDcl: ' -> puttext; vDcl.doPT -> puttext;
              ' in: ' -> putline;
              OGx.doPT -> putline;
          if);
          L:
            (# P: ^Pattern
            do OGx.IS.scanDecls
               (# ptn: ^Pattern; DI: ^DataItem
               do (if currentDcl.isPatternDecl (*isVirtual?*)then
                      (if trx  then
                          '**   try:ptnDcl:' -> putline; 
                          currentDcl.doPT -> putline;
                      if);
                      currentDcl[] -> ptn[];
                      (if false and (trx or traceGetV_qual) then
                          (if ptn.vDcl[] <> none then
                              'ptn.vDcl: ' -> putline;
                              ptn.vDcl.doPT -> putline;
                          if);
                          (if vDcl[] <> none then
                              '**   vDcl: ' -> putline;
                              vDcl.doPT -> putline;
                              (if (vDcl.getReturnDecl -> DI[]) <> none then
                                  '**   return: ' -> puttext;
                                  DI.doPT -> putline
                              if)
                      if)if);
                      ptn[] -> P[];
                      loop:
                        (if P.vDcl[] = vDcl[] then
                            (if trx or traceGetV_qual then
                                '***  FOUND BINDING: ' -> putline;
                                ptn.doPT -> putline;
                                (if not ptn.isChecked then
                                    '!!! ptn is not checked '->putline
                                if);
                            if);
                            (if ptn.OG.IS.isEmpty then
                                ptn.OG.super.ATd[] -> ptn[]
                            if);
                            ptn.OG[] -> qual[]-> this(OGpath).qual[];
                            leave L
                         else
                            P.vDcl[] -> P[];
                            (if P[] <> none then 
                                restart loop
                            if)
                        if)
                  if)
               #);

               (if OGx.IS.superDesc[] <> none then (* seems odd!? *)
                   OGx.IS.superDesc.father[] -> OGx[];
                   (if trx or traceGetV_qual then
                       '**   findBinding:go super'->putline;
                       OGx.dopt -> putline;
                   if);
                   restart L
                else
                   (if trx or traceGetV_qual then
                       '!!!! No binding found:using vDcl:' -> putline;
                   if);
                   vDcl.OG[] -> qual[]
               if)
            #)
       exit qual[]
       #);   
     print::
       (# L: @integer; DI: ^DataItem
       do '**** Path: on = ' -> puttext; on -> putint;
          ' pn = ' -> puttext; pn -> putint;  
          ' isNest: ' -> puttext; isNest -> putBoolean; newline;         
          (if vDcl[] <> none then
              '**   to:vDcl: ' -> puttext; vDcl.doPT -> putline
          if);
          (if dcl[] <> none then
              '**   to:Decl: ' -> puttext; dcl.doPT -> putline
          if);
          '**   from: ' -> puttext; 
          (if OI[] <> none then OI.doPT -> putline else 'none' -> putline if);
          (if OG[] <> none then
              '**   in:OG: ' -> putline;
              OG.doPT -> putline
           else
              'OG:none' -> putline
          if);

          (if pred[] <> none then 
              (*'\n**   pathToDcl:pred:' -> putline;*)
              newline;
              pred.print 
           else 
              '\n=== end:pathToDcl' -> putline 
          if)
       #)
  enter(OG[],dcl[],OI[],on,pn,pred[])
  exit this(OGPath)[]
  #);


