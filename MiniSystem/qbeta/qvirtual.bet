ORIGIN 'qabstractSyntaxTree'
---astlib:attributes---
OGsequence:
  (# DOG: ^ObjectGenerator;
     pred: ^OGsequence;
     isRemote: @boolean;
     isNest: @Boolean;
     pathToSuper:
       (# OGs: ^ObjectGenerator; on,pn: @integer; E: ^Exp; ptn: ^Pattern;
          i: @integer;
          isRemote: @boolean
       do '*** pathToSuper:'->puttext;
          DOG.super.dopt -> puttext;
          ' ' -> put; DOG.super.length -> putint; newline;

          DOG.super.scanSons
          (# 
          do current[] -> E[];
             i + 1 -> i
          #);
          i > 1 -> isRemote;          
          E.ATd[] -> ptn[];
          (if ptn[] <> none then
              ptn.OG[] -> OGs[];
              E.on -> on; E.pn -> pn
          if);
       exit(OGs[],on,pn,isRemote)
       #);
     ENC:
       (# S: ^OGsequence; 
          OGs: ^ObjectGenerator; onx,pnx: @integer; isRemote: @boolean
       do (if isNest then
              pred[] -> S[]
           else
          (if pred[] = none then (* head *)
              DOG.origin.father[] -> OGsequence -> S[];
              this(OGsequence)[] -> S.pred[]
           else
              pathToSuper -> (OGs[],onx,pnx,isRemote);
              (* thisOGS = [D1,D2,...,Dn-1,Dn], Dn = DOG *)
              pred.ENC -> S[];
              (* S = ENC([D1,D2,...,Dn-1]) *)
              (if false and isRemote then
                  (* Dn-1: R.P{...}, where R.P = Dn 
                   * onx = 0, pnx >= 0                  
                   *)
               else
                  (for i: onx repeat S.ENC -> S[] for);
                  (for i: pnx  repeat '**pre loop'->putline;
                       S.PRE -> S[]; '***end pre-loop' -> putline for);
                  '***KOKS:'->putline;
                  S.print
              if);
          if)if)
       exit S[]
       #);
     PRE:
       (# S,Sx: ^OGsequence; 
          OGs,OGx: ^ObjectGenerator; onx,pnx: @integer; isRemote: @boolean;
          ptn: ^Pattern
       do '*** PRE:'->putline;
          pathToSuper -> (OGs[],onx,pnx,isRemote);
          (if isRemote then
              '*** isRemote: ' -> puttext; 
              this(OGsequence)[] -> S[];
              DOG.super.scanSons
              (# E: ^Exp; D: ^DataItem
              do current[] -> E[]; current.dopt -> putline;
                 (if isLast then
                     E.ATd[] -> ptn[];
                     PTN.OG[] -> OGx[]
                  else                     
                     E.ATd[] -> D[];
                     (if D.OG.hasItems then
                         D.OG[] -> OGx[]
                      else
                         (D.OG.super.desc).father[] -> OGx[]
                 if)if);
                 OGx[] -> OGsequence -> Sx[];
                 true -> Sx.isNest;
                 S[] -> Sx.pred[];                 
                 Sx[] -> S[];
                 '***Remote-PRE:'->putline;
                 S.print
              #);              
           else
              OGs[] -> OGsequence -> S[]; 
              this(OGsequence)[] -> S.pred[]
          if);
          '***end:PRE'->putline;
          S.print
       exit S[]
       #);
       
     FB: 
       (# qual: ^ObjectGenerator
       do (if isNest then
              DOG[] -> qual[]
           else
              (if pred[] <> none then
                  pred.FB -> qual[]
               else
                  DOG[] -> qual[]
          if)if)
       exit qual[]
       #);
     print:
       (#
       do '*** OGsequence:'->puttext;
          (if isRemote then 'isRemote:'->puttext if);
          (if isNest then 'isNest:'->puttext if);
          newline;
          (if DOG[] <> none then
              DOG.dopt -> putline;
           else
              'none'->putline
          if);
          (if pred[] <> none then
              pred.print
          if)
       #)
  enter DOG[]
  do
  exit this(OGsequence)[]
  #);
OGPath: SuperPath
  (# OI: ^ObjectInvocation; 
     OG: ^ObjectGenerator;
     on,pn: @integer; (* path frem pred to OG i (0,0) for first element*)
     hasRemoteSuper: @boolean;
     pred: ^OGPath; (* sub ptn/OG *);
     qual: ^ObjectGenerator;
     vDcl: ^Pattern;
     checkForRemoteSuper:
       (#
       do OG.super.noOfSons > 1 -> hasRemoteSuper
       #);
     getQual:
       (# S: ^OGsequence
       do '*** OGpath:getQual'-> putline;
          computeOGseq -> S[];
          S.print;
          S.FB -> findBinding -> qual[]
       #);
     computeOGseq:
       (# S: ^OGsequence; OGx: ^ObjectGenerator
       do '*** computeOG: on: ' -> puttext; on -> putint;
          ' pre: ' -> puttext; pn -> putint; newline;
          (if pred[]  <> none then
              pred.computeOGseq -> S[];
              (for i: on repeat S.ENC -> S[] for);
              (for i: pn repeat S.PRE -> S[] for);
              '***computeOGseq'->putline;
              S.print
           else
              OG[] -> OGx[];
              (for i: on repeat OGx.origin.father[] -> OGx[] for);
              OGx[] -> OGsequence -> S[];
              (for i: pn repeat S.PRE -> S[] for);
          if)
       exit S[]
       #);
     getQualX:
       (# qual,OGx,OGs: ^ObjectGenerator; DI: ^dataitem; OGm: ^ObjectGenerator;
          onx,pnx: @integer; ptn: ^Pattern
       enter(onx,pnx,OGs[])
       do (if hasRemoteSuper then
              '** hasRemoteSuper' -> putline;
              (if OGs[] = none then 
                  'OGs is none!?' -> putline;
                  OG.doPT -> putline
              if);
              (for i: onx repeat OGs.origin.father[] -> OGs[] for);
              OGs.dopt -> putline;
              OG.super.scanSons
              (# E: ^Exp
              do (if not isLast then
                     'C: ' -> puttext; current.doPT -> putline;
                     'dcl: ' -> putline;
                     (current[]->E[]).ATd[] -> DI[];
                     DI.OG.dopt -> putline;
                     DI.OG.super.atd.dopt -> putline;
                     DI.OG.super.ATd[] -> ptn[];
                     (if (ptn.OG[] -> OGs.inSuper) then
                         'Found nested/remote' -> putline;
                         ptn.OG[] -> OGm[]
                     if)
                 if);
                 OGm[] -> findBinding -> qual[]
              #)
           else
              (if pred[] <> none then
                  vDcl[] -> pred.vDcl[];
                  (on,pn,OG[]) -> pred.getQualX -> qual[] -> this(OGpath).qual[];
               else
                  '*** path:getQual:'-> putline;
                  OG[] -> OGx[];
                  (for i: on repeat
                       OGx.origin.father[] -> OGx[]
                  for);
                  OGx[] -> findBinding -> qual[]
          if)if) 
       exit qual[]
       #);
     findBinding:
       (# OGx: ^ObjectGenerator; qual: ^ObjectGenerator
       enter OGx[]
       do '*** find binding in : ' -> putline;
          OGx.doPT -> putline;
          L:
            (#
            do OGx.IS.scanDecls
               (# ptn: ^Pattern
               do (if currentDcl.isPatternDecl then
                      currentDcl[] -> ptn[];
                      (if ptn.vDcl[] = vDcl[] then
                          'Found binding: ' -> putline;
                          ptn.doPT -> putline;
                          ptn.OG[] -> qual[] -> this(OGpath).qual[];
                          leave L
                      if)
                  if)
               #);
               '---findBinding:go super'->putline;
               (if OGx.IS.superDesc[] <> none then
                   OGx.IS.superDesc.father[] -> OGx[];
                   restart L
                else
                   'findBinding: super is none - no binding found:using vDcl'
                     ->putline;
                   vDcl.OG[] -> qual[]
               if)
            #)
       exit qual[]
       #);     
     print::
       (#
       do '*** Path: on = ' -> puttext; on -> putint;
          ' pn = ' -> puttext; pn -> putint; 
          (if hasRemoteSuper then
              ' hasRemoteSuper' -> puttext
          if);
          newline;
          (*'OI: ' -> putline;
          (if OI[] <> none then
              OI.doPT -> putline;
           else
              'none'->putline
          if);*)

          (if OG[] <> none then
              '*** OG: ' -> putline;
              OG.doPT -> putline
           else
              'OG:none' -> putline
          if);
          (if vDcl[] <> none then
              'vDcl: ' -> putline; vDcl.doPT -> putline
          if);
          (if pred[] <> none then pred.print if)
       #)
  enter(OI[],OG[],on,pn,pred[])
  do checkForRemoteSuper
  exit this(OGPath)[]
  #);


