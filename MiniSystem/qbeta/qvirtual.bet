ORIGIN 'qabstractSyntaxTree'
---astlib:attributes---
(* The patterns here are called from semchecker via 
 * semchecker::ObjectInvocation::getVqual, which is called from
 * checker::ObjectInvocation:check to get the qualification of a given OI
 * or is it Pattern?
 *)
OGsequence: SuperOGsequence
  (* Represents a pattern sequence as described in the OOPSLA article:
   *    Semantic Analysis of Virtual Classes and Nested Classes
   * 
   * In the qBeta implementation, we use a sequence of ObjectGenerators
   *    [OG1, OG2, ... OGn]
   * where in the simple form
   *    OG1.super = OG2, OG2.super = OG3, ..., OGn-1.super = OGn
   * OG1 is enclosing the application qualified by the virtual
   * where we want to find the most specific binding.
   * To handle remote access, an OGsequence may in general have nested OGs:
   *       [OG1, OG2, ..., OGn-1, nest(OGn)]
   * meaning that OGn is nested within OGn-1.
   * OGn within nest(OGn) may have super patterns:
   *       [OG1, OG2, ..., OGn-1, nest(OGn),OGn+1, ...,OGm]
   *)
  (# thisOGS:: OGsequence;
     (*DOG: ^ObjectSpecification;*)
     (*pred: ^OGsequence;*)
     isRemote: @boolean;
     (*isNest: @Boolean;*)
     innerDOG: ^ObjectGenerator;
     pathToSuper:
       (# OGsuper: ^ObjectGenerator; on,pn: @integer; E: ^Exp; 
          D: ^Decl; ptn: ^Pattern; i: @integer; isR: @boolean;
       do (if traceGetVqual then 
              '**** pathToSuper: "'->puttext; 
              DOG.super.dopt -> puthead; 
              '" of:DOG:' -> puttext; DOG.doPT -> putheadN;
              (if innerDOG[] <> none then
                  '**   innerDOG: ' -> puttext; innerDOG.doPT -> putheadN
          if)if);
          (if not DOG.isChecked then
              (* this happens*) (*'!!! DOG is not checked' -> putline;
              DOG.dopt  -> putheadN;*)
              (none,DOG.origin[],DOG.origin[],true) -> DOG.check;
          if);
          (*'****KUK:'->dumptn; DOG.super.dopp->dumptn;*)
          L:
            DOG.super.scanSons
            (# binE: ^BinaryExp
            do current[] -> E[];
               (if E.isBinaryExp then
                   E[] -> binE[];
                   '**** pathToSuper:got:BinaryExp:'->dumpTN;
                   DOG.super.doPT -> dumpTN;
                   (if innerDOG[] <> none then
                       '**** innerDog:'->dumpT; innerDOG.doPT -> dumpTN
                   if);
                   (if (innerDOG[] <> none)  then 
                       binE.leftRec.scanSons
                       (# OI: ^ObjectInvocation
                       do '**   leftRef:son:'->dumpT;
                          current.doPT -> dumpTN;
                          (if current.isObjectInvocation then
                              current[] -> OI[];
                              (if OI.args[] <> none then
                                  OI.args.scanSons
                                  (#
                                  do '**   leftRef:arg:X:'->dumpT;
                                     current.label -> dumpT; 
                                     current.doPT -> dumpTN;
                                     (if current.isObjectGenerator then
                                         (i + 1 -> i) > 1 -> isR;
                                     if);
                                     (if (current[] = innerDOG[]) then
                                         (if true or traceGetVqual then
                                             '*** got:innerDOG:leftRec:'->puttext;
                                             i->putint; 
                                             ' '-> put; current.dopt -> puthead;
                                         if);
                                         leave L
                                     if)
                                  #)
                              if)
                          if)
                       #)
                   if);
                   (if (innerDOG[] <> none) 
                       and (binE.M.args[] <> none) then 
                       binE.M.args.scanSons
                       (#
                       do '**   M:arg:'->dumpT;
                          current.doPT -> dumpTN;
                          (if (current[] = innerDOG[]) then
                              (if true or traceGetVqual then
                                  '*** got:innerDOG:M:'->puttext;
                                  i->putint; 
                                  ' '-> put; current.dopt -> puthead;
                              if);
                              leave L
                          if)
                       #)
                   if);
               if);

               (i + 1 -> i) > 1 -> isR;
               (if (innerDOG[] <> none) and (E.args[] <> none) then 
                   (if false and traceGetVqual then
                       '**   args:'->puttext; E.args.dopt -> putline;
                   if);
                   E.args.scanSons
                   (#
                   do (if (current[] = innerDOG[]) then
                          (if traceGetVqual then
                              '*** got:innerDOG:'->puttext; i->putint; 
                              ' '-> put; current.dopt -> puthead;
                          if);
                          leave L
               if)#)if);
               (if traceGetVqual then
                   '**   pathToSuper:DOG.super.scanSons:i=' -> puttext;
                   i -> putint; ':E:'->puttext; E.doPT -> puthead; 
                   ' :isImplSuper='->puttext; DOG.super.isImplSuper->putboolean;
                   newline
               if)
            #);
          (if traceGetVqual then
              (* if E.isEmpty, we have DOG = (OG(Invocation('???') ...)*)
              '**   pathToSuper:E:"' -> puttext; 
              E.dopt -> puthead; 
              '" E.on=' -> puttext; E.on -> putint;
              ' E.pn=' -> puttext; E.pn -> putint;
              ' DOG.super.pn='->puttext; DOG.super.pn -> putint;
              ' isR=' -> puttext; isR -> putboolean; newline;
          if);
          (if DOG.super.isImplSuper then
              DOG.super.ATd[] -> D[];
              0 -> on;
              DOG.super.pn -> pn; 
           else
              E.ATd[] -> D[];
              E.on -> on; 
              E.pn -> pn; 
          if);
          L:
          (if true
           // D[] = none then 
              (*'!!!! pathToSuper:super.ATd is none' -> putline;*)
              ObjectDecl[] -> D[] -> ptn[]
           // D.isPattern then D[] -> ptn[]
           // D.isNameDecl then 
              (# ND: ^NameDecl
              do (*'****nameDecl:'->puttext; D.dopt -> putline;*)
                 (* only if nameListInDcl *)
                 D[] -> ND[];
                 ND.ATd[] -> D[]; 
                 restart L
              #)
           else 
              '!!!! pathToSuper:super.ATd is not Pattern or is empty: ' 
                -> putline;
              DOG.doPT -> puthead;
              leave pathToSuper
          if);
          ptn.OG[] -> OGsuper[];
          (if traceGetVqual then
              '**   pathToSuper:end:super.last: "'->puttext;E.dopt -> puthead;
              '" :on='->puttext; on ->putint;
              ':pn='->puttext; pn -> putint;
              ':isR='->puttext; isR->putboolean;
              ':ptn.isVirt=' -> puttext; ptn.isVirtual -> putBoolean; 
              ' ptn:' -> puttext; ptn.doPT -> puthead;
              (* print*)
          if);
       exit(OGsuper[],on,pn,isR)
       #);
     encLevel: @integer;
     ENC:
       (* ENC[D] = [D.origin]
        * ENC[D1,D2,...,Dn] = PRE(j) o ENC(i) 0 ENC[D1,D2,...,Dn-1]
        *    where Path(Dn) = (i,j)
        *)
       (# S: ^OGsequence; OGsuper,OGx: ^ObjectGenerator; 
          level,onx,pnx: @integer; isR: @boolean; id: ^Text; org: ^Scope
       enter(id[],level)
       do (if traceGetVqual then 
              ('**** ENC:'->(id.copy).prepend,0,level) -> print 
          if);
          (if true 
           // isNest then
              (if pred[] = none then
                  ('!!!! ENC:isNest:pred is none',0,level) -> print
              if);
              (* ENC([D1,D2,...,Dn-1,nest(Dn)]) = [D1,D2,...,Dn-1] *)
              pred[] -> S[];
           // isRemote then
              (* ENC([D1,D2,...,Dn-1,R.Q]) = remote(ENC[D1,D2,...,Dn-1],R) *)
              pred.DOG[] -> OGx[]; (* pred <> none always! *)
              (DOG[],OGx[],pred[],level) -> Remote -> S[]
           // pred[] = none then (* head *)
              (* ENC([D]) = [D.origin] *)
              (if DOG.origin[] = none then 
                  '!!!! ENC: DOG.origin is none!'->putline; print;
                  this(OGsequence)[] -> S[];
                  stop
               else                  
                  (if (DOG.origin[]->org[]).encOG[] = none then 
                      '!!!! ENC: DOG.origin.encOG is none!'->putline if);
                  (org.encOG[],false,none) -> OGsequence -> S[];
                  DOG[] -> S.innerDOG[]
              if);
           else
              (* ENC([D1,D2,...,Dn-1,Dn]) 
               *          = PRE[j] o ENC[on] o ENC([D1,D2,...,Dn-1])
               * where path(Dn-1.super) = (on,pn)
               *)
              pred.pathToSuper -> (OGsuper[],onx,pnx,isR);
              (* thisOGS = [D1,D2,...,Dn-1,Dn], Dn = DOG *)
              (if traceGetVqual then
                  '**   ENC:pred: '-> puttext; 
                  ' pred.DOG: ' -> puttext; pred.DOG.doPT -> putheadN;
                  '**   OGsuper: ' -> puttext; OGsuper.dopt -> PutheadN
              if);
              (id[],level + 1) -> pred.ENC -> S[];
              (if traceGetVqual then 
                  '**   ENC:[pnx=' -> puttext;  pnx -> putint;
                  ']oENC[onx=' -> puttext; onx -> putint; 
                  ']' -> put;newline 
              if);
              (if isR then '!!!! ComputeOGs:isR:Check it!'->putline if);
              (for i: onx repeat (id[],level + i) -> S.ENC -> S[] for);
              (for i: pnx repeat level -> S.PRE -> S[] for);
          if);
          (if traceGetVqual then ('**   ENC:result:',0,level) -> S.print if)
       exit S[]
       #);

     Remote:
       (* this(OGs) = [D1,D2,...,Dn,R] or
        *           = [D1,D2,...,Dn,R.Q]
        * remote([D1,D2,...,Dn],R)
        *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa),Rd)
        *    where path(Ra) = (Rd,0,j)
        *    Rd: ref Sa
        *  remote([D1,D2,...,Dn],R.Q)
        *    = nest(app(super[j] o remote([D1,D2,...,Dn,R),Ta,Td)))
        *    where path(Qa) = (Qd,0,j)
        *    Qd: ref Ta
        *)
       (# superDOG,DOGx,OGx: ^ObjectGenerator; S,Sx: ^OGsequence; level: @integer
       enter(superDOG[],DOGx[],S[],level)
       do (if traceGetVqual then 
              ('**** Remote:',0,level) -> S.print;
              '**   DOGx: '->puttext; DOGx.dopt -> puthead; 
          if);
          L: 
          DOGx.super.scanSons
          (# E: ^Exp; D: ^SuperDataItem
          do current[] -> E[]; 
             (if (E.ATd.asDecl).OG[] = superDOG[] then (* move to if not isLast below*)
                 (if traceGetVqual then
                     '**** remote:got:superDOG:' -> puttext;
                     superDOG.dopt -> puthead;
                     ('remote:',0,level) -> S.print;
                 if);
                 leave L;
             if);
             (if traceGetVqual then
                 '**   remote:scanSons:E:"' -> puttext; 
                 E.dopt -> puttext; '" E.ATd.label:' -> puttext;
                 E.ATd.label -> puttext;
                 ' E.on: '->puttext; E.on ->putint;
                 ' E.pn: ' -> puttext; E.pn -> putint;
                 ' E.ATd:' -> putline; E.ATd.dopt -> putline;
             if);
             (if not isLast then
                 (* remote([D1,D2,...,Dn],R)
                  *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa),Sd)
                  *    where path(Ra) = (Rd,i,j)
                  *    Rd: ref Sa;
                  *    Sd: ...
                  *)
                 (* DOG = R.Q where Q is not remote  and R = R1.R2.Rn, n >= 1 *)
                 (if traceGetVqual then '**   remote:first:'-> putline if);
                 (for i: E.on repeat ('remote:',level + i) -> S.ENC -> S[] for);
                 (for i: E.pn repeat level -> S.PRE -> S[] for);
                 (* Is E.ATd ok? We have Ra => Rd: ref Sa; ... Sa => Sd: ...
                  * E.ATd = Rd: ref Sa - should perhaps be?
                  * But append seems ok!?
                  * Is OGx below ok?
                  *);
                 (E.ATd.asDecl,level) -> S.append -> (S[],OGx[]);
                 S[] -> Sx[];                 
                 (OGx[],true,Sx[]) -> OGsequence -> S[];
             if);
          #);
          (if traceGetVqual then ('**** remote:END',0,level) -> S.print if)
       exit S[]
       #);  
     append:
       (# D: ^Decl(*SuperDataItem*); S,Sx: ^OGsequence; OGx: ^ObjectGenerator; 
          MI: ^ModuleItem; ATd: ^decl; level: @integer; DI: ^DataItem
       enter(D[],level)
       do  (if traceGetVqual then
              '**** append:label: '->puttext; D.label -> puttext; 
               ' dcl: ' -> puttext; D.dopt -> putheadN;
               '**   isEmpty: '  -> puttext; D.OG.IS.isEmpty -> putboolean;
               '\n**   hasVargs: ' -> puttext; D.OG.hasVirtualArgs ->putboolean;
               newline
          if);
          (if D.isModuleItem then (D[]->MI[]).MD[] -> D[] if); 
          this(OGsequence)[] -> S[];
          (if D.OG.IS.isEmpty
              and
              (not D.OG.hasVirtualArgs
              or D.isDataItem and not (D[]->Di[]).isConst)
              (* We need to understand this! 
               * For ChemicalPlantSystem, not isConst is needed
               * For CityLink, we dont need it!?
               *)
              then
              D.OG.super.scansons
              (# i: @integer; E: ^Exp
              do (if (i + 1 -> i) > 1 then
                     (if toFix then
                         '!!!!  append:dataItem:remote not implemented:'
                           ->putline;
                         D.dopt -> putline;
                     if);
                     S[] -> Sx[];
                     (OGx[],true,Sx[]) -> OGsequence -> S[];
                 if);
                 current -> E[];
                 (if (E.ATd.asDecl).isModuleItem then
                     (E.ATd.asDecl->MI[]).MD[] -> ATd[]
                  else
                     E.ATd.asDecl -> ATd[];
                 if);
                 (if traceGetVqual then
                     '**   append:scan:E: "'->puttext; E.doPT -> puttext;
                     '" on=' -> puttext; E.on -> putint;
                     ' E.pn='->puttext; E.pn -> putint; ' E.ATd.OG: "'->puttext;
                     (if E.ATd[] <> none then                         
                         ATd.OG.dopt -> puthead
                      else
                         'none:'->putline
                     if)
                 if);
                 (for i: E.on repeat ('append:',level + i) -> S.ENC -> S[] for);
                 (for i: E.pn repeat level -> S.PRE -> S[] for);
                 (ATd.asDecl).OG[] -> OGx[]
              #)
           else
              D.OG[] -> OGx[]
          if);          
          (if traceGetVqual then '**   append:END:\n' -> puttext if);
       exit(S[],OGx[])
       #);
     PRE:
       (# S: ^OGsequence; 
          OGx,qual: ^ObjectGenerator; onx,pnx: @integer; isR: @boolean;
          level: @integer
       enter level
       do (if traceGetVqual then ('**** PRE: ',0,level) -> print if);
          pathToSuper -> (OGx[],onx,pnx,isR);
          (OGx[],false, this(OGsequence)[]) -> OGsequence -> S[]; 
          isR -> S.isRemote;
          (if traceGetVqual then 
              '**   PRE:onx,pnx,isR:'->puttext; onx->putint; ','->put; 
              pnx->putint;','->put; isR->putBoolean; 
              ' OGx:'->putline; OGx.dopt -> putheadN;
              ('**   PRE:result:',0,level) -> S.print
          if)
       exit S[]
       #);
     newFindBinding::
       (# OGx: ^ObjectGenerator
       do (if traceGetVqual then
              '**** newFindBinding: ' -> puttext;
              vDcl.dopt -> putheadN;
          if);
          vDcl[] -> searchBinding -> qual[];
          (if false then
              '**** newFindBinding:end: ' -> puttext;
              vDcl.dopt -> putheadN;
          if);
          (if qual[] = none then
              (if traceGetVqual then
                  '!!!! No binding found in OGsequence! Use: '->puttext;
                  vDcl.doPT -> putheadN
              if);
              vDcl.OG[] -> qual[];
           else
              (if traceGetVqual then
                  '**** newFindBinding:found: ' -> puttext; qual.dopt ->putheadN
              if)
          if)
       #);
     searchBinding:
       (# vDcl: ^Pattern; qual: ^ObjectGenerator
       enter vDcl[] 
       do (if traceGetVqual then
              '**** searchBinding: ' -> puttext; vDcl.dopt -> putheadn; print;
          if);
          (if isNest or (pred[] = none) then
           else
              vDcl[] -> pred.searchBinding -> qual[]
          if);
          (if qual[] = none then
              (vDcl[],DOG[]) -> checkDOG -> qual[]
          if)
       exit qual[]
       #);
     checkDOG:
       (* check for binding of vDcl in DOG *)
       (# vDcl: ^Pattern; DOG,qual: ^ObjectGenerator;
       enter(vDcl[],DOG[])
       do (if traceGetVqual then
              '**   checkDOG: ' -> puttext; DOG.OGid-> puttext; ' ' -> put;
              dog.doPT -> puthead;
              'father:'->puttext;
              DOG.father.dopt -> puthead
          if);
          (if false then
              '**** beingChecked:'->dumpt; dog.beingchecked->putboolean;
              ' isChecked:'->dumpt; dog.isChecked -> putboolean; newline;
              (none,DOG.origin[],DOG.origin[],true) -> DOG.check;
          if);
          checkForBinding:
            (# Ex:^Exp; OGs: ^ObjectGenerator; argNo: @integer; ND: ^NameDecl
            do DOG.IS.scanDecls
               (# ptn,P: ^Pattern
               do (if currentDcl.isPatternDecl then
                      currentDcl[] -> ptn[];
                      (if false and not ptn.isChecked and not ptn.beingChecked then
                          '**** qvirtual:doCheck: ' -> dumpT; 
                          ptn.dopt -> putheadN;
                          (none,ptn.origin[],ptn.origin[],true) -> ptn.check;
                      if);
                      (if ptn.isVirtual then
                          (if false and traceGetVqual then
                              '**   try: ' -> puttext; ptn.dopt -> puthead
                          if);
                          ptn[] -> P[];
                          loop: 
                            (if vDcl[] = P[] then
                                (if traceGetVqual then
                                    '\n ==== FOUND BINDING: =====' -> putline;
                                    ptn.dopt -> putheadn;
                                if);
                                (if ptn.OG.IS.isEmpty then
                                    (* Should we include 
                                     * not ptn.OG.hasVirtualArgs?
                                     *)
                                    (if ptn.beingChecked then
                                        ptn.OG.super.scanSons
                                        (# OI: ^ObjectInvocation; D: ^Decl
                                        do (current[]->OI[]).ptnID[]
                                             -> DOG.IS.doSearch -> D[];
                                           D.asDecl -> ptn[];
                                        #)
                                     else
                                        (if nameListInDcl then
                                            (ptn.OG.super.ATd[]-> ND[]).ATd[]
                                              -> ptn[];
                                         else
                                            ptn.OG.super.ATd[] -> ptn[];
                                        if);
                                if)if);
                                ptn.OG[] -> qual[];
                                true -> hasBinding;
                                (*print; qual.dopt -> puthead;*)
                                leave checkForBinding
                             else
                                (* probably check ptn.vDcl recursively *)
                                (if P.vDcl[] = none then
                                    (if P.ptnKind // FinalPtn // FurtherPtn then
                                        (if false then
                                            '**** virtual:Binding:P.vDcl:none:'
                                              ->dumpTN;
                                            P.dopt -> putheadN;
                                            '**** beingChecked:'->dumpt; 
                                            ptn.beingchecked->putboolean;
                                            ' isChecked:'->dumpt; 
                                            ptn.isChecked -> putboolean;
                                            newline;
                                        if);
                                        (none,ptn.origin[],ptn.origin[],true) 
                                          -> P.check;
                                if)if);
                                (if (P.vDcl[] -> P[]) <> none then
                                    restart loop
               if)if)if)if)#);
               (* check possible binding in arguments of DOG.super.last *)
               LLL:
                 (if DOG.IS.superDesc[] <> none then
                     DOG.super.last -> Ex[];
                     DOG.IS.superDesc.father[] -> OGs[];
                     (if traceGetVqual then
                         '**   Ex: ' -> puttext; Ex.dopt -> putheadN;;
                         '**   Ex.OGs.super:'->putline;
                         OGs.dopt -> putheadN;
                     if);
                     (if (Ex.args[] <> none) and (Ex.args.noOfSons > 0) then
                         OGs.IS.scanNonBoundItemArgs
                         (# 
                         do argNo + 1 -> argNo;
                            (if traceGetVqual then
                                '**   currentArg: ' -> puttext;
                                currentArg.dopt->putheadN;
                            if);
                            (if currentArg[] = vDcl[] then
                                Ex.args.scanArgs
                                (# i: @integer
                                do i + 1 -> i;
                                   (if i = argNo then
                                       (if traceGetVqual then
                                           '**   superArg: ' -> puttext; 
                                           current.label -> puttext;
                                           ' '->put; current.dopt-> putline;
                                       if);
                                       (if traceGetVqual then
                                           '\n==== FOUND BINDING IN ARG: ' 
                                             -> putline;
                                           current.dopt -> putheadn;
                                       if);
                                       current.getQual -> qual[];
                                       true -> hasBinding;
                                       (*print; qual.dopt -> putline;*)
                                       leave LLL
            if)#)if)#)if)if)#)
       exit qual[]
       #);
     getOGstart:: 
       (* Return the start OG of this OGsequence from where a virtual binding
        * has to be searched. For a simple OGs with no nesting:
        *    [OG1, OG2, ... OGn]
        * the start is OG1.
        * If nesting appers:
        *    [OG1, OG2, ..., OGn-1, nest(OGn),OGn+1, ...,OGm]
        * the start is OGn asssuming no isNest(OGk), n < k and k <= m
        *)
       (#
       do (if traceGetVqual then
              '**** getOGstart: ' -> putline; print
          if);
          (if isNest then
              DOG[] -> qual[]
           else
              (if pred[] <> none then
                  pred.getOGstart -> qual[]
               else
                  DOG[] -> qual[]
          if)if);
          (if traceGetVqual then
              '**** getOGstart:isNest: ' -> puttext; isNest -> putboolean;
              ' qual: ' -> puttext; qual.doPT -> puthead;
          if)
       #);     
     print::
       (# (*msg: ^text; L,level: @integer
       enter(msg[],L,level)*)
       do (*(if (level = 0) and (L = 0) then newline if);*)
          (if msg[] <> none  then msg[] -> puttext if);
          (if L = 0 then 
              '[' -> put; level -> putint; ':'->put;
              (*(if true
               // isRemote then 'isRemote' -> puttext;
               // isNest then 'isNest' -> puttext;
               // pred[] = none then 'head'->puttext;
               else 
                  'super' -> puttext
              if);
              '>' -> put *)
          if);
          (if pred[] <> none then
              (none, L + 1,level) -> pred.print
          if);
          (if isRemote then 'r:' -> puttext if);
          (if isNest then
              'nest(' -> puttext;
          if);
          DOG.OGid -> puttext;
          (if hasBinding then '&' -> put if);
          (if isNest then ')' -> put if);
          (if L = 0 then
              ']' -> put; newline;
              (*(if level = 0 then newline if);*)
           else
              ',' -> put
          if);
       #);
  exit this(OGsequence)[]
  #);

