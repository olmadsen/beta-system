ORIGIN 'qabstractSyntaxTree'
---astlib:attributes---
(* The patterns here are called from semchecker via 
 * semchecker::ObjectInvocation::getVqualX, which is called from
 * checker::ObjectInvocation:check to get the qualification of a given OI
 * or is it Pattern?
 *)
OGsequence: SuperOGsequence
  (* Represents a pattern sequence as described in the OOPSLA article:
   *    Semantic Analysis of Virtual Classes and Nested Classes
   * Here we actually have a sequence of ObjectGenerators
   * OG1, OG2, ... OGn
   * where OG2 is super of OG1, OG3 of OG2, ... and OGn of OGn-1
   * OG1 is enclosing the application qualified by the virtual
   * where we want to find the most specific binding
   *)
  (# thisOGS:: OGsequence;
     (*DOG: ^ObjectSpecification;*)
     (*pred: ^OGsequence;*)
     isRemote: @boolean;
     (*isNest: @Boolean;*)
     innerDOG: ^ObjectGenerator;
     pathToSuper:
       (# OGsuper: ^ObjectGenerator; on,pn: @integer; E: ^Exp; 
          D: ^Decl; ptn: ^Pattern;
          i: @integer;
          isR: @boolean;
       do (if traceGetVqual-> trx then '*** pathToSuper:DOG:' -> putline;  
              DOG.doPT -> puthead;
              (if innerDOG[] <> none then
                  '**   innerDOG: ' -> putline; innerDOG.doPT -> puthead
          if)if);
          (if not DOG.isChecked then
              (* this happens*) (*'!!! DOG is not checked' -> putline*)
          if);
          (if trx  then
              '**  pathToSuper:DOG.super: "' -> puttext;
              DOG.super.dopt -> puttext; '"\n' -> puttext
          if);
          L:
            DOG.super.scanSons
            (# 
            do current[] -> E[];
               (i + 1 -> i) > 1 -> isR;
               (if (innerDOG[] <> none) and (E.args[] <> none) then 
                   (*'**   args:'->puttext; E.args.dopt -> putline;*)
                   E.args.scanSons
                   (#
                   do (*current.label -> puttext; ' ' -> put; current.dopt -> putline;*)
                      (if traceGetVqual and (current[] = innerDOG[]) then
                          '*** got:innerDOG:' -> puttext; i -> putint; ' '-> put;
                          current.dopt -> puthead;
                          leave L
               if)#)if);
               (if trx then
                   '**  pathToSuper:DOG.super.scanSons:i=' -> puttext;
                   i -> putint; ':E:"'->puttext; E.doPT -> puttext; 
                   '":isImplSuper='->puttext; DOG.super.isImplSuper -> putboolean;
                   newline
               if)
            #);
          (if trx then
              '**  pathToSuper:E:"' -> puttext; E.dopt -> puttext; 
              '" E.on=' -> puttext; E.on -> putint;
              ' E.pn=' -> puttext; E.pn -> putint;
              ' DOG.super.pn='->puttext; DOG.super.pn -> putint;
              ' isR=' -> puttext; isR -> putboolean; newline;
          if);
          (if DOG.super.isImplSuper then
              DOG.super.ATd[] -> D[];
              0 -> on;
              DOG.super.pn -> pn; 
           else 
              E.ATd[] -> D[];
              E.on -> on; 
              E.pn -> pn; 
          if);
          (if true
           // D[] = none then 
              (*'!!!! pathToSuper:super.ATd is none' -> putline;*)
              ObjectDecl[] -> D[] -> ptn[]
           // D.isPattern then D[] -> ptn[]
           else 
              '!!!! pathToSuper:super.ATd is not Pattern or is empty: ' 
                -> putline;
              DOG.doPT -> puthead;
              leave pathToSuper
          if);
          ptn.OG[] -> OGsuper[];

          (if trx then
              '**** pathToSuper:end: "'->puttext;(DOG.super).dopt -> puttext;
              '":E: "'->puttext; E.dopt -> puttext;
              '" :on='->puttext; on ->putint;
              ':pn='->puttext; pn -> putint;
              ':isRemote:'->puttext; isR->putboolean;
              ':DOG.super.pn='-> puttext; DOG.super.pn -> putint;
              ':isVirtual=' -> puttext; ptn.isVirtual -> putBoolean; 
              '\n**   ptn:\n' -> puttext;
              ptn.doPT -> puthead;
              print
          if);
       exit(OGsuper[],on,pn,isR)
       #);
     ENC:
       (* ENC[D] = [D.origin]
        * ENC[D1,D2,...,Dn] = PRE(j) o ENC(i) 0 ENC[D1,D2,...,Dn-1]
        *    where Path(Dn) = (i,j)
        *)
       (# S: ^OGsequence; 
          OGsuper,OGx: ^ObjectGenerator; onx,pnx: @integer; isR: @boolean
       do (if (trx) or traceGetVqual then ('**** ENC: ****',0) -> print if);
          (if true 
           // isNest then
              (if pred[] = none then
                  ('!!!! ENC:isNest:pred is none',0) -> print
              if);
              (* ENC([D1,D2,...,Dn-1,nest(Dn)]) = [D1,D2,...,Dn-1] *)
              pred[] -> S[];
           // isRemote then
              (* ENC([D1,D2,...,Dn-1,R.Q]) = remote(ENC[D1,D2,...,Dn-1],R) *)
              (if true then
                  pred.DOG[] -> OGx[]; (* pred <> none always! *)
                  (if false then
                      pred.ENC -> S[]; 
                      (OGx[],S[]) -> RemoteX -> S[]
                   else
                      (OGx[],pred[]) -> RemoteX -> S[]
                  if)
               else
                  Remote -> S[]
              if)
           // pred[] = none then (* head *)
              (* ENC([D]) = [D.origin] *)
              (if DOG.origin[] = none then 
                  '!!!! ENC: DOG.origin is none!'->putline; print if);
              (if DOG.origin.father[] = none then 
                  '!!!! ENC: DOG.origin.father  is none!'->putline if);
              DOG.origin.father[] -> OGsequence -> S[];
              DOG[] -> S.innerDOG[]
           else
              (* ENC([D1,D2,...,Dn-1,Dn]) 
               *          = PRE[j] o ENC[on] o ENC([D1,D2,...,Dn-1])
               * where path(Dn-1.super) = (on,pn)
               *)
              pred.pathToSuper -> (OGsuper[],onx,pnx,isR);
              (* thisOGS = [D1,D2,...,Dn-1,Dn], Dn = DOG *)
              (if trx then '**   ENC:pred.ENC'->putline if);
              pred.ENC -> S[];
              (if isR then '!!!! ComputeOGs:isR:Check it!'->putline if);
              (if trx then '**   ENC:go:onx='->puttext; onx -> putint; newline if);
              (for i: onx repeat S.ENC -> S[] for);
              (if trx then '**   ENC:go:pnx:'->puttext; pnx -> putint; newline if);
              (for i: pnx repeat S.PRE -> S[] for);
          if);
          (if trx or traceGetVqual then ('**   ENC:result:',0) -> S.print if)
       exit S[]
       #);
     RemoteX:
       (* this(OGs) = [D1,D2,...,Dn,R] or
        *           = [D1,D2,...,Dn,R.Q]
        * remote([D1,D2,...,Dn],R)
        *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa),Rd)
        *    where path(Ra) = (Rd,0,j)
        *    Rd: ref Sa
        *  remote([D1,D2,...,Dn],R.Q)
        *    = nest(app(super[j] o remote([D1,D2,...,Dn,R),Ta,Td)))
        *    where path(Qa) = (Qd,0,j)
        *    Qd: ref Ta
        *)
       (# DOGx,OGx: ^ObjectGenerator; S,Sx: ^OGsequence
       enter(DOGx[],S[])
       do (if trx or traceGetVqual then 
              ('**** RemoteX:',0) -> S.print;
              '**   DOGx: '->putline; DOGx.dopt -> puthead; 
          if);
          DOGx.super.scanSons
          (# E: ^Exp; D: ^SuperDataItem
          do current[] -> E[]; 
             (if trx or traceGetVqual then
                 '**   remote:scanSons:E:"' -> puttext; 
                 E.dopt -> puttext; '" E.ATd.label:' -> puttext;
                 E.ATd.label -> puttext;
                 ' E.on: '->puttext; E.on ->putint;
                 ' E.pn: ' -> puttext; E.pn -> putint;
                 ' E.ATd:' -> putline; E.ATd.dopt -> putline;
             if);
             (if not isLast then
                 (* remote([D1,D2,...,Dn],R)
                  *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa),Sd)
                  *    where path(Ra) = (Rd,i,j)
                  *    Rd: ref Sa;
                  *    Sd: ...
                  *)
                 (* DOG = R.Q where Q is not remote  and R = R1.R2.Rn, n >= 1 *)
                 (if traceGetVqual then '**   remote:first:'-> putline if);
                 (for i: E.on repeat S.ENC -> S[] for);
                 (for i: E.pn repeat S.PRE -> S[] for);
                 (* Is E.ATd ok? We have Ra => Rd: ref Sa; ... Sa => Sd: ...
                  * E.ATd = Rd: ref Sa - should perhaps be?
                  * But append seems ok!?
                  * Is OGx below ok?
                  *)
                 E.ATd[] -> S.append -> (S[],OGx[]);
                 S[] -> Sx[];                 
                 OGx[] -> OGsequence -> S[];
                 true -> S.isNest;
                 Sx[] -> S.pred[]
             if);
          #);
          (if trx or traceGetVqual then ('**** remote:END',0) -> S.print if)
       exit S[]
       #);     
     Remote:
       (* this(OGs) = [D1,D2,...,Dn,R] or
        *           = [D1,D2,...,Dn,R.Q]
        * remote([D1,D2,...,Dn],R)
        *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa)Rd)
        *    where path(Ra) = (Rd,0,j)
        *    Rd: ref Sa
        *  remote([D1,D2,...,Dn],R.Q)
        *    = nest(app(super[j] o remote([D1,D2,...,Dn,R),Ta,Td)))
        *    where path(Qa) = (Qd,0,j)
        *    Qd: ref Ta
        *)
       (# OGx: ^ObjectGenerator; S,Sx: ^OGsequence
       do (if trx or traceGetVqual then ('**** Remote:',0) -> print if);
          pred[] -> S[];
          pred.DOG.super.scanSons
          (# E: ^Exp; D: ^SuperDataItem
          do current[] -> E[]; 
             (if trx or traceGetVqual then
                 '**   remote:scanSons:E:"' -> puttext; 
                 E.dopt -> puttext; '" E.ATd.label:' -> puttext;
                 E.ATd.label -> puttext;
                 ' E.on: '->puttext; E.on ->putint;
                 ' E.pn: ' -> puttext; E.pn -> putint;
                 ' E.ATd:' -> putline; E.ATd.dopt -> putline;
             if);
             (if not isLast then
                 (* remote([D1,D2,...,Dn],R)
                  *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa),Rd)
                  *    where path(Ra) = (Rd,i,j)
                  *    Rd: ref Sa
                  * but append seems ok here1?
                  *)
                 (* DOG = R.Q where Q is not remote  and R = R1.R2.Rn, n >= 1 *)
                 (if traceGetVqual then '**   remote:first:'-> putline if);
                 (for i: E.on repeat S.ENC -> S[] for);
                 (for i: E.pn repeat S.PRE -> S[] for);

                 E.ATd[] -> S.append -> (S[],OGx[]);
                 S[] -> Sx[];                 
                 OGx[] -> OGsequence -> S[];
                 true -> S.isNest;
                 Sx[] -> S.pred[]
             if);
          #);
          (if trx or traceGetVqual then ('**** remote:END',0) -> S.print if)
       exit S[]
       #);
     append:
       (# D: ^Decl(*SuperDataItem*); S,Sx: ^OGsequence; OGx: ^ObjectGenerator; 
          MI: ^ModuleItem; Atd: ^decl
       enter D[]
       do (if (trx) or traceGetVqual then
              '**** append:label:'->puttext; D.label -> puttext; 
              ':dcl:\n' -> puttext; D.dopt -> putline 
          if);
          (if D.isModuleItem then (D[]->MI[]).MD[] -> D[] if); 
          this(OGsequence)[] -> S[];
          (if D.OG.IS.isEmpty then
              D.OG.super.scansons
              (# i: @integer; E: ^Exp
              do (if (i + 1 -> i) > 1 then
                     (if toFix then
                         '!!!!  append:dataItem:remote not implemented:'->putline;
                         D.dopt -> putline;
                     if);
                     S[] -> Sx[];
                     OGx[] -> OGsequence -> S[];
                     true -> S.isNest;
                     Sx[] -> S.pred[];
                     (*S.print; print; *)
                 if);
                 current -> E[];
                 (if E.ATd.isModuleItem then
                     (E.ATd[]->MI[]).MD[] -> ATd[]
                  else
                     E.ATd[] -> Atd[];
                 if);
                 (if trx then
                     '**   append:scan:E: "'->puttext; E.doPT -> puttext;
                     '" on=' -> puttext; E.on -> putint;
                     ' E.pn='->puttext; E.pn -> putint; ' E.ATd.OG: "'->puttext;
                     (if E.ATd[] <> none then                         
                         ATd.OG.dopt -> puthead
                      else
                         'none:'->putline
                     if)
                 if);
                 (for i: E.on repeat S.ENC -> S[] for);
                 (for i: E.pn repeat S.PRE -> S[] for);
                 (if true then
                     ATd.OG[] -> OGx[]
                  else
                     ATd.OG.origin.father[] -> OGx[]
                 if)
              #)
           else
              D.OG[] -> OGx[]
          if);          
          (if trx or traceGetVqual then '**   append:END:\n' -> puttext if);
       exit(S[],OGx[])
       #);
     PRE:
       (# S: ^OGsequence; 
          OGs,qual: ^ObjectGenerator; onx,pnx: @integer; isR: @boolean;
       do (if trx or traceGetVqual then ('**** PRE: ****',0) -> print if);
          pathToSuper -> (OGs[],onx,pnx,isR);
          OGs[] -> OGsequence -> S[]; 
          this(OGsequence)[] -> S.pred[];
          isR -> S.isRemote;
          (if trx or traceGetVqual then ('**   end:PRE',0) -> S.print if)
       exit S[]
       #);
     FB:: 
       (#
       do (if isNest then
              DOG[] -> qual[]
           else
              (if pred[] <> none then
                  pred.FB -> qual[]
               else
                  DOG[] -> qual[]
          if)if);
          (if traceGetVqual then
              '**** FB:isNest: ' -> puttext; isNest -> putboolean;
              newline; qual.doPT -> putline 
          if)
       #);     
     print::
       (# msg: ^text; L: @integer
       enter(msg[],L)
       do (if msg[] <> none  then
              msg[] -> putline;
          if);
          (if L = 0 then 
              '**** OGsequence:'->puttext;
           else
              '***  OGseq:sub:' -> puttext;
          if);
          'isRemote:' -> puttext; isRemote -> putBoolean;
          ':isNest:' -> puttext; isNest -> putBoolean; ' ********'->putline;
          (if DOG[] <> none then
              DOG.dopt -> puthead
           else
              'DOG=NONE' -> putline
          if);
          (if pred[] <> none then
              (none,L + 1) -> pred.print;
          if);
          (if L = 0 then
              (if pred[] = none then '**** ' -> puttext if);
              ':END:OGsequence ****\n' -> putline
           else
              '**** END:SUB:' -> puttext
          if)
       #)
  exit this(OGsequence)[]
  #);

findBinding:
  (# vDcl: ^pattern; OGx: ^ObjectGenerator; qual: ^ObjectGenerator
  enter(vDcl[],OGx[])
  do (if (trx) or traceGetVqual then
         '****  findBindingOf:vDcl:\n' -> puttext; vDcl.doPT -> puthead;
         '**    in: ' -> putline;
         OGx.doPT -> puthead
     if);
     L:
       (# P: ^Pattern
       do OGx.IS.scanDecls
          (# ptn: ^Pattern; DI: ^DataItem
          do (*currentDcl.dopt -> putline;*)             
             (if currentDcl.isPatternDecl (*isVirtual?*)then
                 (if trx then
                     '**   try:ptnDcl:' -> putline; 
                     currentDcl.doPT -> putline;
                 if);
                 currentDcl[] -> ptn[];
                 (if (trx or traceGetVqual) then
                     (if ptn.vDcl[] <> none then
                         '**   ptn.vDcl: ' -> putline;
                         ptn.vDcl.doPT -> putline;
                     if);
                     (if vDcl[] <> none then
                         (if trx then
                             '**   vDcl: ' -> putline;
                             vDcl.doPT -> putline;
                         if);
                         (if (vDcl.getReturnDecl -> DI[]) <> none then
                             '**   return: ' -> puttext;
                             DI.doPT -> putline
                         if)
                 if)if);
                 ptn[] -> P[];
                 loop:
                   (if (P.vDcl[] = vDcl[]) or (vDcl[] = ptn[]) then
                       (if trx or traceGetVqual then
                           '\n==== FOUND BINDING: =====' -> putline;
                           ptn.doPT -> puthead; 
                           (if false and not ptn.isChecked then
                               '!!! ptn is not checked '->putline;
                               (* TST::vclass fails if check is lled as below!*)
                               (none,OGx.IS[],OGx.IS[],true) -> ptn.check;
                               (none,OGx.IS[],OGx.IS[],true) -> ptn.OG.super.check;
                           if);
                           newline
                       if);
                       (if ptn.OG.IS.isEmpty then   
                           (if ptn.beingChecked then
                               ptn.OG.super.scanSons
                               (# OI: ^ObjectInvocation
                               do (current[]->OI[]).ptnID[]
                                    -> OGx.IS.doSearch -> ptn[];
                               #)
                            else
                               ptn.OG.super.ATd[] -> ptn[]
                           if);
                       if);
                       ptn.OG[] -> qual[];
                       (if qual.IS.isEmpty then
                           '******* >>>>> empty: '->puttext;
                           qual.dopt -> putline
                       if);
                       leave L
                    else
                       P.vDcl[] -> P[];
                       (if P[] <> none then 
                           restart loop
                       if)
                   if)
             if)
          #);
          LLL:
            (if OGx.IS.superDesc[] <> none then (* seems odd!? *)
                (# Ex: ^Exp; argNo: @integer; OGs: ^ObjectGenerator
                do (if trx then
                       '***** super:OGx.isChecked:'->puttext; 
                       OGx.isChecked -> putBoolean;
                       newline;                        
                       OGx.dopt -> putline;
                   if);
                   (OGx.super.last) -> Ex[];
                   OGx.IS.superDesc.father[] -> OGs[];
                   (if false then
                       '**   Ex: ' -> puttext; Ex.dopt -> putline;
                       Ex.doPP -> putline; '---'->putline;
                       OGs.dopt -> putline;
                   if);
                   (if (Ex.args[] <> none) and (Ex.args.noOfSons > 0) then
                       (if trx then
                           '*** try super:'->putline;
                           OGx.super.dopt -> putline;
                           vDcl.dopt -> putline;
                       if);
                       OGs.IS.scanNonBoundItemArgs
                       (#
                       do argNo + 1 -> argNo;
                          (if trx then currentArg.dopt -> putline; if);
                          (if currentArg[] = vDcl[] then
                              (if false then
                                  '**** vDcl:argNo: ' -> puttext; 
                                  argNo -> putint; ' ' -> put; vDcl.dopt -> putline;
                              if);
                              Ex.args.ScanArgs
                              (# i: @integer
                              do i + 1 -> i; 
                                 (if i = argNo then
                                     (if trx then
                                         '**** vDcl bound to: ' -> puttext;
                                         current.doPT -> putline;
                                         current.isChecked -> putboolean; 
                                         ' Ex.isChecked: ' -> puttext;
                                         Ex.isChecked -> putboolean;
                                         ' Ex.args.isChecked='->puttext;
                                         Ex.args.isChecked -> putboolean;
                                         ' OGx.isChecked='->puttext;
                                         OGs.isChecked -> putboolean; 
                                         ' OGs.super.isChecked='->puttext;
                                         OGx.super.isChecked -> putboolean;
                                         ' OGx.isChecked='->puttext;
                                         OGx.isChecked -> putboolean;
                                         newline;
                                         OGx.dopt -> putline
                                     if);
                                     (none,OGx.origin[],OGx.origin[],true) -> ex.args.check;
                                     current.getQual -> qual[];
                                     leave LLL;
                                 if)
                              #); 
                              (*newline*)
                          if)
                       #)
                   if);
                   
                   (if false and trx or traceGetVqual then
                       '**   findBinding:go super'->putline;
                       OGs.dopt -> puthead
                   if);
                   OGs[] -> OGx[]
                #);
                restart L
             else
                (if trx or traceGetVqual then
                    '!!!! No binding found:using vDcl:' -> putline;
                    vDcl.dopt -> puthead
                if);
                vDcl.OG[] -> qual[]
            if)
       #)
  exit qual[]
  #); 
