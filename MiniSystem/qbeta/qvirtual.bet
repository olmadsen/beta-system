ORIGIN 'qabstractSyntaxTree'
---astlib:attributes---
OGPath: SuperPath
  (# OI: ^ObjectInvocation; 
     OG: ^ObjectGenerator;
     on,pn: @integer; (* path frem pred to OG i (0,0) for first element*)
     hasRemoteSuper: @boolean;
     pred: ^OGPath; (* sub ptn/OG *);
     qual: ^ObjectGenerator;
     vDcl: ^Pattern;
     checkForRemoteSuper:
       (#
       do OG.super.noOfSons > 1 -> hasRemoteSuper
       #);
     getQual:
       (# qual,OGx,OGs: ^ObjectGenerator; DI: ^dataitem; OGm: ^ObjectGenerator;
          onx,pnx: @integer; ptn: ^Pattern
       enter(onx,pnx,OGs[])
       do (if hasRemoteSuper then
              '** hasRemoteSuper' -> putline;
              (if OGs[] = none then 'OGs is none!?' -> putline if);
              (for i: onx repeat OGs.origin.father[] -> OGs[] for);
              OGs.dopt -> putline;
              OG.super.scanSons
              (# E: ^Exp
              do (if not isLast then
                     'C: ' -> puttext; current.doPT -> putline;
                     'dcl: ' -> putline;
                     (current[]->E[]).ATd[] -> DI[];
                     DI.OG.dopt -> putline;
                     DI.OG.super.atd.dopt -> putline;
                     DI.OG.super.ATd[] -> ptn[];
                     (if (ptn.OG[] -> OGs.inSuper) then
                         'Found nested/remote' -> putline;
                         ptn.OG[] -> OGm[]
                     if)
                 if);
                 OGm[] -> findBinding -> qual[]
              #)
           else
              (if pred[] <> none then
                  vDcl[] -> pred.vDcl[];
                  (on,pn,OG[]) -> pred.getQual -> qual[] -> this(OGpath).qual[];
               else
                  '*** path:getQual:'-> putline;
                  OG[] -> OGx[];
                  (for i: on repeat
                       OGx.origin.father[] -> OGx[]
                  for);
                  OGx[] -> findBinding -> qual[]
          if)if) 
       exit qual[]
       #);
     findBinding:
     (# OGx: ^ObjectGenerator; qual: ^ObjectGenerator
     enter OGx[]
     do '*** find binding in : ' -> putline;
        L:
          (#
          do OGx.IS.scanDecls
             (# ptn: ^Pattern
             do (if currentDcl.isPatternDecl then
                    currentDcl[] -> ptn[];
                    (if ptn.vDcl[] = vDcl[] then
                        'Found binding: ' -> putline;
                        ptn.doPT -> putline;
                        ptn.OG[] -> qual[] -> this(OGpath).qual[];
                        leave L
                    if)
                if)
             #);
             '---go super'->putline;
             OGx.IS.superDesc.father[] -> OGx[];
             restart L
          #)
     exit qual[]
     #);
     
     print::
       (#
       do '*** Path: on = ' -> puttext; on -> putint;
          ' pn = ' -> puttext; pn -> putint; 
          (if hasRemoteSuper then
              ' hasRemoteSuper' -> puttext
          if);
          newline;
          (*'OI: ' -> putline;
          (if OI[] <> none then
              OI.doPT -> putline;
           else
              'none'->putline
          if);*)

          (if OG[] <> none then
              '*** OG: ' -> putline;
              OG.doPT -> putline
           else
              'OG:none' -> putline
          if);
          (if vDcl[] <> none then
              'vDcl: ' -> putline; vDcl.doPT -> putline
          if);
          (if pred[] <> none then pred.print if)
       #)
  enter(OI[],OG[],on,pn,pred[])
  do checkForRemoteSuper
  exit this(OGPath)[]
  #);
     
       
DescriptorChain:
  (#
  #);


