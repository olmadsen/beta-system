ORIGIN 'qabstractSyntaxTree'
---astlib:attributes---
(* The patterns here are called from semchecker via 
 * semchecker::ObjectInvocation::getV_qual, which is called from
 * checker::ObjectInvocation:check to get the qualification of a given OI
 *)
traceGetV_qual: (# exit false #);
OGsequence: SuperOGsequence
  (* Represents a pattern sequence as described in the OOPSLA article:
   *    Semantic Analysis of Virtual Classes and Nested Classes
   * Here we actually have a sequence of ObjectGenerators
   * OG1, OG2, ... OGn
   * where OG2 is super of OG1, OG3 of OG2, ... and OGn of OGn-1
   * OG1 is enclosing the application qualified by the virtual
   * where we want to find the most specific binding
   *)
  (# thisOGS:: OGsequence;
     (*DOG: ^ObjectSpecification;*)
     pred: ^OGsequence;
     isRemote: @boolean;
     isNest: @Boolean;
     pathToSuper:
       (# OGsuper: ^ObjectGenerator; on,pn: @integer; E: ^Exp; 
          D: ^Decl; ptn: ^Pattern;
          i: @integer;
          isR: @boolean
       do (if trx then '*** pathToSuper:DOG:' -> putline;  
              DOG.doPT -> putline if);
          (if not DOG.isChecked then
              (* this happens*) (*'!!! DOG is not checked' -> putline*)
          if);
          (if trx  then
              '**  pathToSuper:DOG.super: "' -> puttext;
              DOG.super.dopt -> puttext; '"\n' -> puttext
          if);
          DOG.super.scanSons
          (# 
          do current[] -> E[];
             (i + 1 -> i) > 1 -> isR;
             (if trx then
                 '**  pathToSuper:DOG.super.scanSons:i=' -> puttext;
                 i -> putint; ':E:"'->puttext; E.doPT -> puttext; 
                 '":isImplSuper='->puttext; DOG.super.isImplSuper -> putboolean;
                 newline
             if)
          #);
          (if trx then
              '**  pathToSuper:E:"' -> puttext; E.dopt -> puttext; 
              '" E.on=' -> puttext; E.on -> putint;
              ' E.pn=' -> puttext; E.pn -> putint;
              ' DOG.super.pn='->puttext; DOG.super.pn -> putint;
              ' isR=' -> puttext; isR -> putboolean; newline;
          if);
          (if DOG.super.isImplSuper then
              DOG.super.ATd[] -> D[];
              0 -> on;
              DOG.super.pn -> pn; 
           else 
              E.ATd[] -> D[];
              E.on -> on; 
              E.pn -> pn; 
          if);
          (if true
           // D[] = none then '!!!! pathToSuper:super.ATd is none' -> putline
           // D.isPattern then D[] -> ptn[]
           else 
              '!!!! pathToSuper:super.ATd is not Pattern or is empty: ' 
                -> putline;
              DOG.doPT -> putline;
              leave pathToSuper
          if);
          ptn.OG[] -> OGsuper[];

          (if trx then
              '**  pathToSuper:end:on='->puttext; on ->putint;
              ':pn='->puttext; pn -> putint;
              ':DOG.super.pn='-> puttext; DOG.super.pn -> putint;
              ':isVirtual=' -> puttext; ptn.isVirtual -> putBoolean; 
              ':ptn:\n' -> puttext;
              ptn.doPT -> putline;
              print
          if);
       exit(OGsuper[],on,pn,isR)
       #);
     ENC:
       (* ENC[D] = [D.origin]
        * ENC[D1,D2,...,Dn] = PRE(j) o ENC(i) 0 ENC[D1,D2,...,Dn-1]
        *    where Path(Dn) = (i,j)
        *)
       (# S: ^OGsequence; 
          OGsuper: ^ObjectGenerator; onx,pnx: @integer; isR: @boolean
       do (if (trx) or traceGetV_qual then ('**** ENC: ****',0) -> print if);
          (if true 
           // isNest then
              (* ENC([D1,D2,...,Dn-1,nest(Dn)]) = [D1,D2,...,Dn-1] *)
              pred[] -> S[];
           // isRemote then
              (* ENC([D1,D2,...,Dn-1,R.Q]) = remote([D1,D2,...,Dn-1],R) *)
              Remote -> S[]
           // pred[] = none then (* head *)
              (* ENC([D]) = [D.origin] *)
              (if DOG.origin[] = none then 
                  '!!!! ENC: DOG.origin is none!'->putline; print if);
              (if DOG.origin.father[] = none then 
                  '!!!! ENC: DOG.origin.father  is none!'->putline if);
              DOG.origin.father[] -> OGsequence -> S[];
           else 
              (* ENC([D1,D2,...,Dn-1,Dn]) 
               *          = PRE[j] o ENC[on] o ENC([D1,D2,...,Dn-1])
               * where path(Dn-1.super) = (on,pn)
               *)
              pred.pathToSuper -> (OGsuper[],onx,pnx,isR);
              (* thisOGS = [D1,D2,...,Dn-1,Dn], Dn = DOG *)
              pred.ENC -> S[];
              (if isR then '!!!! ComputeOGs:isR:Check it!'->putline if);
              (for i: onx repeat S.ENC -> S[] for);
              (for i: pnx repeat S.PRE -> S[] for);
          if);
          (if trx or traceGetV_qual then ('**   ENC:result:',0) -> S.print if)
       exit S[]
       #);
     Remote:
       (* this(OGs) = [D1,D2,...,Dn,R] or
        *           = [D1,D2,...,Dn,R.Q]
        * remote([D1,D2,...,Dn],R)
        *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa)Rd)
        *    where path(Ra) = (Rd,0,j)
        *    Rd: ref Sa
        *  remote([D1,D2,...,Dn],R.Q)
        *    = nest(app(super[j] o remote([D1,D2,...,Dn,R),Ta,Td)))
        *    where path(Qa) = (Qd,0,j)
        *    Qd: ref Ta
        *)
       (# OGx: ^ObjectGenerator; S: ^OGsequence
       do (if trx or traceGetV_qual then ('**** Remote:',0) -> print if);
          pred[] -> S[];
          pred.DOG.super.scanSons
          (# E: ^Exp; D: ^SuperDataItem
          do current[] -> E[]; 
             (if traceGetV_qual then
                 '**   remote:scanSons:E:"' -> puttext; 
                 E.dopt -> puttext; '" E.ATd.label:' -> puttext;
                 E.ATd.label -> puttext;
                 ' E.on: '->puttext; E.on ->putint;
                 ' E.pn: ' -> puttext; E.pn -> putint;
                 ' E.ATd:' -> putline; E.ATd.dopt -> putline;
             if);
             (if not isLast then
                 (* remote([D1,D2,...,Dn],R)
                  *    = nest(app(super[j] o enc[i]([D1,D2,...,Dn]),Sa),Rd)
                  *    where path(Ra) = (Rd,i,j)
                  *    Rd: ref Sa
                  *)
                 (* DOG = R.Q where Q is not remote  and R = R1.R2.Rn, n >= 1 *)
                 (if traceGetV_qual then '**   remote:first:'-> putline if);
                 (for i: E.on repeat S.ENC -> S[] for);
                 (for i: E.pn repeat S.PRE -> S[] for);
                 E.ATd[] -> S.append -> (S[],OGx[]);
                 OGx[] -> OGsequence -> S[];
                 true -> S.isNest;
             if);
          #);
          (if trx or traceGetV_qual then ('**** remote:END',0) -> S.print if)
       exit S[]
       #);
     append:
       (# D: ^SuperDataItem; S: ^OGsequence; OGx: ^ObjectGenerator; 
          MI: ^ModuleItem
       enter D[]
       do (if trx or traceGetV_qual then
              '**** append:label:'->puttext; D.label -> puttext; 
              'D:\n' -> puttext; D.dopt -> putline 
          if);
          (if D.isModuleItem then (D[]->MI[]).MD[] -> D[] if); 
          this(OGsequence)[] -> S[];
          (if D.OG.IS.isEmpty then
              D.OG.super.scansons
              (# i: @integer; E: ^Exp
              do (if (i + 1 -> i) > 1 then
                     '!!!!  append:dataItem:remote not implemented:'->putline;
                     D.dopt -> putline;
                 if);
                 current -> E[];
                 (if trx then
                     '**   append:scan:E: "'->puttext; E.doPT -> puttext;
                     '" on=' -> puttext; E.on -> putint;
                     ' E.pn='->puttext; E.pn -> putint; ' E.ATd.OG: "'->puttext;
                     E.ATd.OG.dopt -> putline
                 if);
                 (for i: E.on repeat S.ENC -> S[] for);
                 (for i: E.pn repeat S.PRE -> S[] for);
                 E.ATd.OG[] -> OGx[]
              #)
           else
              D.OG[] -> OGx[]
          if);          
          (if trx or traceGetV_qual then '**   append:END:\n' -> puttext if);
       exit(S[],OGx[])
       #);
     nestSuper::
       (#
       do (if trx then 
               '**** nestSuper:'->putline; 
          if);
          OGs[] -> OGsequence -> S[]; 
          this(OGsequence)[] -> S.pred[];
          true -> S.isNest;
       #);
     PRE:
       (# S: ^OGsequence; 
          OGs: ^ObjectGenerator; onx,pnx: @integer; isR: @boolean;
       do (if trx or traceGetV_qual then ('**** PRE: ****',0) -> print if);
          pathToSuper -> (OGs[],onx,pnx,isR);
          OGs[] -> OGsequence -> S[]; 
          this(OGsequence)[] -> S.pred[];
          isR -> S.isRemote;
          (if trx or traceGetV_qual then ('**   end:PRE',0) -> S.print if)
       exit S[]
       #);
     
     FB: 
       (# qual: ^ObjectSpecification
       do (if isNest then
              DOG[] -> qual[]
           else
              (if pred[] <> none then
                  pred.FB -> qual[]
               else
                  DOG[] -> qual[]
          if)if);
          (if traceGetV_qual then
              '**** FB:isNest: ' -> puttext; isNest -> putboolean;
              newline; qual.doPT -> putline 
          if)
       exit qual[]
       #);     
     print::
       (# msg: ^text; L: @integer
       enter(msg[],L)
       do (if msg[] <> none  then
              msg[] -> putline;
          if);
          (if L = 0 then 
              '**** OGsequence:'->puttext;
           else
              '***  OGseq:sub:' -> puttext;
          if);
          'isRemote:' -> puttext; isRemote -> putBoolean;
          ':isNest:' -> puttext; isNest -> putBoolean; ' ********'->putline;
          (if DOG[] <> none then
              DOG.dopt -> puthead
           else
              'DOG=NONE' -> putline
          if);
          (if pred[] <> none then
              (none,L + 1) -> pred.print;
          if);
          (if L = 0 then
              (if pred[] = none then '**** ' -> puttext if);
              ':END:OGsequence ****\n' -> putline
           else
              '**** END:SUB:' -> puttext
          if)
       #)
  exit this(OGsequence)[]
  #);
OGPath: SuperPath
  (* Represents a path as described in the OOPSLA paper:
   *   path = (on,pn) from pred to OG 
   * for first element, pred = none, (on,pn) = (0,0)
   * enter(OG[],dcl[],OI[],on,pn,pred[])
   * OGy:
   *    dcl2 = TTT: ... | TTT:< ...
   * OGx:
   *    dcl1 = OI: ref TTT   path(TTT) = (OGx,dcl2,TTT,on2,pn2)
   * ...
   * OG:
   *    OI     path(OI) = (OG,dcl1,OI,on,pn)
   * 
   * OGz:
   *    T: { S: ref V = dcl3 }             path(V) = (OGz,Vdcl,V,on3,pn3)
   *    T: { S: obj{ F: ...= dcl3} = dcl3} path(V) = (nest(F),dcl3,V,on3,pn3)
   * OGy:
   *    TT: T{ ... } = dcl2  path(S) = (nest(TT),dcl3,S,0,pn3)
   * OGx: 
   *    R: ref TT  = dcl1    path(TT) = (OGx,dcl2,TT,on2,pn2)
   * OG:
   *    R.S.F                path(R) = (OG,dcl1,R,on1,pn1)
   *)
  (# (*OG: ^ObjectGenerator;*)
     (*dcl: ^Decl;*)
     (*vDcl: ^Pattern; (* Is vDcl always the same as dcl? Probably yes!? *)
     OI: ^Exp(*ObjectInvocation*); (* Only included for debugging purposes *)
     on,pn: @integer; 
     (* isNest: @boolean;  dcl in SuperPath *)
     pred: ^OGPath; (* sub of OG *);
     
     qual: ^ObjectGenerator; (* should be eliminated -! *)

     findQual:
       (# S: ^OGsequence; 
       do traceGetV_qual -> trx;
          (if (trx) or traceGetV_qual then
              '\n**** OGpath:findQual:of:vDcl: \n"'-> puttext; 
              vDcl.doPT -> puttext; '"\n' -> putline;
              print
          if);
          computeOGseq -> S[];
          (if trx or traceGetV_qual then
              ('\n*** before:findBinding:',0) -> S.print
          if);
          (*false -> trx;*)
          S.FB -> findBinding -> qual[];
          (if qual.IS.isEmpty then
              (if trx then
                  '**** OGpath:findQual:qual is pattern: ' -> puttext; 
                  qual.dopt -> putline;
              if);
              qual.super.ATd.getQual -> qual[];
              (if trx then
                  '**   OGpath:findQual:of:super: ' -> putline; 
                  qual.dopt -> putline
              if)
          if)
       exit qual[]
       #);
     computeOGseq::
       (# S: ^OGsequence; OGx: ^ObjectGenerator; onx: @integer
       do (if trx or traceGetV_qual then
              '\n**** OGpath:computeOGseq: on=' -> puttext; on -> putint;
              ' pn=' -> puttext; pn -> putint; 
              ' (pred=none)=' -> puttext; pred[] = none -> putboolean;
              ' isNest= ' -> puttext; isNest -> putBoolean;
              newline; 
              '**   OG:' -> putline; OG.dopt -> puthead;
          if);
          
          (* OBS! Perhaps in ENC! There is already a test for isNest in ENC!*)
          (if isNest then
             (* '!!!! computeOGseq:isNest!' -> putline;*)
              on - 1 -> onx else on -> onx if); 
          
          (if pred[] <> none then
              (if trx or traceGetV_qual then 
                  '**   computeOGsequence:go:pred:on=' -> puttext; on -> putint; newline
              if);
              pred.computeOGseq -> S[]; 
              (if trx then
                  '**   computeOGs:after pred.computeOG:onx='->puttext; 
                  onx -> putint; ':pn=' -> puttext; pn -> putint; newline;
                  S.print
              if);
              (for i: onx repeat S.ENC -> S[] for); 
              (if trx then 
                  '**   computeQGs:after:ENC:pn=' -> puttext; pn -> putint; newline;
                  S.print 
              if);
              (for i: pn repeat S.PRE -> S[] for);
              (if trx or traceGetV_qual then
                  '**   computeOGseq:got:OGseq:plain(head<>none):'->putline;
                  S.print
              if)
           else
              (if trx or traceGetV_qual then
                  '**   computeOGsequence:pred is none:onx=' -> puttext;
                  onx -> putint; newline
              if);
              OG[] -> OGx[];
              (if trx and false then OGx.doPT -> putline; if);
              (for i: onx repeat 
                   OGx.origin.father[] -> OGx[];
                   (if trx or traceGetV_qual then
                       '**   gorigin:' -> putline;
                       OGx.doPT -> putline;                   
                   if)
              for);
              (if trx or traceGetV_qual then '///'->putline; if);
              OGx[] -> OGsequence -> S[];
              (if trx or traceGetV_qual then 
                  S.print; 
                  '**   goPre:pn=' -> puttext; pn -> putint; newline
              if);
              (for i: pn repeat S.PRE -> S[] for);
              (if trx or traceGetV_qual then
                  '**   computeOGseq:GOT:OGseq:single(pred=none):' -> putline;
                  S.print
              if)
          if);
          S[] -> SS[]
       #);
     getSeqAndQual::
       (# S: ^OGsequence
       do (if trx then
              '**** OGpath:getSeqAndQual: ' -> putline;
              Sx.print; print
          if);
          Sx[] -> appendSeq -> Sx[];
          (Sx[]->S[]).FB -> findBinding -> qual[];
          (if trx then 
              '**** OGpath:getSeqAndQual:GOT: ' -> putline;
              Sx.print;
              '**** OGpath:getSeqAndQual:qual: ' -> putline;
              qual.dopt -> putline
          if)
       #);
     appendSeq::
       (* append to Sx this(OGpath): return Sx o Seq(this(OGpath)) *)
       (# S: ^OGsequence; 
       do (if trx then 
              '**** appendSeq:'->putline;
              print;
              '**   appendSeq:TO:'->putline;
              Sx.print
          if);
          sX[] -> S[]; 
          (if pred[] <> none then
              S[] -> pred.appendSeq -> S[];
              (if trx then
                  '**   appendSeq:after:pred.appendSeq:'->putline;
                  S.print
              if)
          if);
          (for i: on repeat S.ENC -> S[] for);
          (for i: pn repeat S.PRE -> S[] for); 
          (if false and first and (vDcl[] <> none) then
              S.FB -> findBinding -> qual[];
              (if trx then
                  '**** appendSeq:found:' -> putline; qual.doPT -> putline;
              if);
              (* (if qual.IS.isEmpty then
               qual.super.ATd.getV_Qual -> qual[];
               (if trx then 
               '**** appendSeq:super:qual:' -> puttext; 
               qual.dopt -> putline
               if)
               if);*)
          if);
          S[] -> Sx[]
       #);
     getB::
       (# Sx: ^OGsequence
       do (if trx then 
              '**** getB:'->putline; 
          if);
          S[] -> Sx[]; Sx.FB -> findBinding -> qual[]; 
          (*(if qual.IS.isEmpty then
              qual.super.ATd.getV_Qual -> qual[];
              (if trx then 
                  '**** getB:super:qual:' -> puttext; qual.dopt -> putline
              if)
          if);*)
       #);
     findBinding:
       (# OGx: ^ObjectGenerator; qual: ^ObjectGenerator
       enter OGx[]
       do (if (trx) or traceGetV_qual then
              '****  findBindingOf:vDcl:\n' -> puttext; vDcl.doPT -> putline;
              '**    in: ' -> putline;
              OGx.doPT -> putline;
          if);
          L:
            (# P: ^Pattern
            do OGx.IS.scanDecls
               (# ptn: ^Pattern; DI: ^DataItem
               do (if currentDcl.isPatternDecl (*isVirtual?*)then
                      (if false and trx  then
                          '**   try:ptnDcl:' -> putline; 
                          currentDcl.doPT -> putline;
                      if);
                      currentDcl[] -> ptn[];
                      (if (trx or traceGetV_qual) then
                          (if ptn.vDcl[] <> none then
                              'ptn.vDcl: ' -> putline;
                              ptn.vDcl.doPT -> putline;
                          if);
                          (if vDcl[] <> none then
                              (if false and trx then
                                  '**   vDcl: ' -> putline;
                                  vDcl.doPT -> putline;
                              if);
                              (if (vDcl.getReturnDecl -> DI[]) <> none then
                                  '**   return: ' -> puttext;
                                  DI.doPT -> putline
                              if)
                      if)if);
                      ptn[] -> P[];
                      loop:
                        (if (P.vDcl[] = vDcl[]) or (vDcl[] = ptn[]) then
                            (if trx or traceGetV_qual then
                                '\n==== FOUND BINDING: =====' -> putline;
                                ptn.doPT -> putline; 
                                (if not ptn.isChecked then
                                    '!!! ptn is not checked '->putline;
                                    (none,OGx.IS[],OGx.IS[],true) -> ptn.check;
                                    (none,OGx.IS[],OGx.IS[],true) -> ptn.OG.super.check;
                                if);
                                newline
                            if);
                            (if ptn.OG.IS.isEmpty then   
                                (if ptn.beingChecked then
                                    ptn.OG.super.scanSons
                                    (# OI: ^ObjectInvocation
                                    do (current[]->OI[]).ptnID[]
                                         -> OGx.IS.doSearch -> ptn[];
                                    #)
                                 else
                                    ptn.OG.super.ATd[] -> ptn[]
                                if);
                            if);
                            ptn.OG[] -> qual[]-> this(OGpath).qual[];
                            leave L
                         else
                            P.vDcl[] -> P[];
                            (if P[] <> none then 
                                restart loop
                            if)
                        if)
                  if)
               #);
               LLL:
                 (if OGx.IS.superDesc[] <> none then (* seems odd!? *)
                     (# Ex: ^Exp; argNo: @integer; OGs: ^ObjectGenerator
                     do (if false then
                            '***** super:OGx.isChecked:'->puttext; 
                            OGx.isChecked -> putBoolean;
                            newline;                        
                            OGx.dopt -> putline;
                        if);
                        (OGx.super.last) -> Ex[];
                        OGx.IS.superDesc.father[] -> OGs[];
                        (if (Ex.args[] <> none) and (Ex.args.noOfSons > 0) then
                            (if false then
                                '*** try super:'->putline;
                                OGx.super.dopt -> putline;
                                vDcl.dopt -> putline;
                            if);
                            OGs.IS.scanNonBoundItemArgs
                            (#
                            do argNo + 1 -> argNo;
                               (if false then currentArg.dopt -> putline; if);
                               (if currentArg[] = vDcl[] then
                                   (if false then
                                       '**** vDcl:argNo: ' -> puttext; 
                                       argNo -> putint; ' ' -> put; vDcl.dopt -> putline;
                                   if);
                                   Ex.args.ScanArgs
                                   (# i: @integer
                                   do i + 1 -> i; 
                                      (if i = argNo then
                                          (if false then
                                              '**** vDcl bound to: ' -> puttext;
                                              current.doPT -> putline;
                                              current.isChecked -> putboolean; 
                                              ' Ex.isChecked: ' -> puttext;
                                              Ex.isChecked -> putboolean;
                                              ' Ex.args.isChecked='->puttext;
                                              Ex.args.isChecked -> putboolean;
                                              ' OGx.isChecked='->puttext;
                                              OGs.isChecked -> putboolean; 
                                              ' OGs.super.isChecked='->puttext;
                                              OGx.super.isChecked -> putboolean;
                                               ' OGx.isChecked='->puttext;
                                              OGx.isChecked -> putboolean;
                                              newline;
                                              OGx.dopt -> putline
                                          if);
                                          (none,OGx.origin[],OGx.origin[],true) -> ex.args.check;
                                          current.getQual -> qual[];
                                          leave LLL;
                                      if)
                                   #); 
                                   (*newline*)
                               if)
                            #)
                        if);
                        
                        (if false and trx or traceGetV_qual then
                            '**   findBinding:go super'->putline;
                            OGs.dopt -> puthead
                        if);
                        OGs[] -> OGx[]
                     #);
                     restart L
                  else
                     (if trx or traceGetV_qual then
                         '!!!! No binding found:using vDcl:' -> putline;
                     if);
                     vDcl.OG[] -> qual[]
                 if)
            #)
       exit qual[]
       #);   
     print::
       (# L: @integer; DI: ^DataItem; isPred: @boolean; D: ^Decl
       do inner;
          (if isPred then
              '\n**** Path:PRED: on=' -> puttext; on -> putint;
           else
              '\n**** Path:HEAD: on=' -> puttext; on -> putint;
          if);
          ' pn=' -> puttext; pn -> putint;  
          ' isNest=' -> puttext; isNest -> putBoolean; newline;         
          (if vDcl[] <> none then
              '**   to:vDcl: ' -> puttext; 
              (if vDcl.OG.IS.isEmpty then
                  vDcl.doPT -> puthead
               else
                  vDcl.sig.dopt -> putline
              if);
          if);
          (if dcl[] <> none then
              '**   to:Decl: ' -> puttext; 
              (if (dcl.OG[] <> none) and dcl.OG.IS.isEmpty then
                  dcl.doPT -> puthead
               else
                  newline;
                  dcl.doPT -> puthead
              if)
          if);
          '**   from:OI: ' -> puttext; 
          (if OI[] <> none then OI.doPT -> putline else 'none' -> putline if);
          (if OG[] <> none then
              '**   in:OG: ' -> puttext;
              (if OG.father## < Decl## then
                  (OG.father[] -> D[]).sig.dopt -> puttext; ':'->put
              if);
              newline;
              OG.doPT -> putHead
           else
              'OG:none' -> putline
          if);

          (if pred[] <> none then 
              &pred.print(# do true -> isPred #) 
           else 
              '=== end:pathToDcl\n' -> putline 
          if)
       #)
  enter(OG[],dcl[],OI[],on,pn,pred[])
  exit this(OGPath)[]
  #);


