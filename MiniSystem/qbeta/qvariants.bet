ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qrestrictions';
---lib:attributes---
variants: restrictions
  (# traceEmbedding: @boolean; 
     Module::<
       (# Qalloc:: 
            (#
            do cd.com(#do 'Qalloc:module:'->TT; moduleName -> TT #);
               (if traceAlloc then
                   'Module:QALLOC: ' -> puttext; sig.dopt -> putline;
               if);
               (if IT[] <> none then (* IT is none if top module *)
                   (if not nameListInDcl then
                       IT.qsize[1] + 1 -> IT.qsize[1] -> qoff[1];
                   if);
                   cd.com(#do 'Module:alloc:off:'->TT; qOff[1]->II; dopt->TT #)
               if);
               (1,IT[]) -> sig.Qalloc;
               (* OG.Qalloc is called from generator *)
            #)
       #);
     ModuleItem::<
       (# Qalloc:: 
            (# 
            do cd.com(#do 'ModuleItem:Qalloc: ' ->TT; doPT ->TT #); 
               (if isChecked then 
                   (if traceAlloc then
                       'ModuleItem:QALLOC: ' -> puttext; sig.dopt -> putline;
                   if);
                   (1,IT[]) -> MD.Qalloc;
                   (*MD.qOff[1] -> qOff[1]*)
               if)
            #)
       #);
     DataItem::<
       (# Qalloc:: 
            (# diSize: @integer
            do (if traceAlloc then
                   '**** DataItem:qalloc: ' -> puttext; dopt -> putheadN
               if);
               cd.com
               (#
               do 'dataitem:qalloc:'->TT; sig.id[] ->TQ; 
                  'isValue:'->TT;  isValue -> BB;
                  ' isPrimitive:' -> TT; OG.isPrimitive -> BB;
                  ' isValObj: ' -> TT; OG.isValueObj -> BB;
                  ' isBasicValue:' -> TT; isBasicValue -> BB
               #);
               (if stringAsVal and (OG.primNo = String_prim) then
                   (if false then
                       '**** DataItem:qAlloc:got.String: ' -> puttext;
                       isValue->putBoolean; ' ' -> put; dopt -> putheadN;
                   if);
                   false -> isValue
               if);
               (if isValue or isBasicValue then
                   (* We must alloc and generate all patterns 
                    * and OGs to be embedded *)
                   (if true
                    // OG.primNo = this_prim then
                       (*'**** DI:this:'->putline; dopt -> putline;*)
                       1 -> diSize; (* is this just a hack? *)
                       (if false then
                           '!!!! BUM:'->dumpT; sig.dopt -> dumpT;
                           IT.objSize -> dumpI; IT.encOG.objSize -> dumpI;
                           dumpNL;
                       if)
                    // OG.isPrimitive // OG.isBasicValue then
                       (* isPrimitive should probaly be removed *)
                       (if (OG.primNo = float_prim) or OG.isFloat then
                           2 -> diSize
                        else
                           1 -> diSize
                       if)
                    // not OG.IS.isEmpty then
                       OG.IS.qsize[1] -> diSize;
                       cd.com(#do 'A:'->TT; diSize->II#);
                    else
                       (# ptn: ^pattern
                       do OG.super.ATd.asDecl -> ptn[];
                          (if ptn.OG.primNo = indexed_prim then
                              '**** indexed: ' -> puttext; dopt -> putline;
                                ptn.dopt -> puthead
                          if);
                          (if ptn.OG.IS.newDescNo = 0 then
                              (1,ptn.origin[]) -> ptn.OG.qAlloc;
                          if);
                          (if traceAlloc then
                              dopt -> putline;
                              ptn.dopt -> putline
                          if);
                          ptn.new_size -> diSize;
                          cd.com(#do 'B:'->TT; diSize->II; 
                                   'ptn:'->TT;ptn.dopt->TQ#);
                          cd.com(#do 'newDescNo:'->TT; ptn.OG.IS.newDescNo->II#)
                       #)
                   if);

                   (if not nameListInDcL then
                       IT.qsize[1] + 1 -> qoff[1];
                       IT.qsize[1] + diSize -> IT.qsize[1];
                   if);
                   cd.com(#
                         do 'diSize:'->TT; diSize->II; 
                            'IT.qSize:'->TT; IT.qsize[1]->II 
                         #);
                   (if traceEmbedding then
                       '*** Alloc:value:size:' -> puttext; diSize ->putint; 
                       ':off:' -> puttext; qoff[1] -> putint;
                       ' ' -> put; dopt -> putline;
                   if)
                else
                   1 -> diSize;
                   (if not nameListInDcL then                   
                       IT.qsize[1] + diSize -> IT.qsize[1] 
                         -> qoff[1];
                   if);
                   cd.com(#do 'DI:Qalloc:off:'->TT; qOff[1]->II; dopt->TQ#);
                   (if isConst then
                       (* For R: ref T, dont call T.Qalloc *)
                       (*'**** DI:Qalloc: '->puttext; dopt -> puthead;*)
                       (1,IT[]) -> OG.Qalloc
                   if)
               if);
               diSize -> diXsize;
               (1,IT[]) -> sig.Qalloc;
               (* OG.Qalloc is called from qgenerator *)
            #);
          diXsize: @integer;
          objSize:: (#do OG.objSize -> value  #)
       #);
     NameDecl::<
       (# Qalloc::
            (# DI: ^DataItem;; diSize: @integer;
            do L:
                 (if (ATd[] <> none) then
                   (if (ATd.asDecl).isSuperDataItem then
                       (if (ATd.asDecl).isDataItem then
                           (ATd[]->DI[]).dixSize -> diSize
                        else
                           1 -> diSize
                       if);
                       (if false and ('BETA' -> T.equal) then
                           '**** NameDecl:Qalloc:A:'->dumpT; dopt->dumpT;
                           IT.qsize[1]->dumpI; 
                           off -> dumpI; dumpNL;
                       if);
                       IT.qsize[1] + 1 -> off;
                       IT.qsize[1] + diSize -> IT.qsize[1];
                       (if false and
                           (('BETA' -> T.equal)  or ('Beq' -> T.equal)) then
                           '**** NameDecl:Qalloc:B:'->dumpT;; 
                           dopt -> puthead; ' ' -> put;
                           IT.encOG.OGid -> dumpT; 
                           'off:' -> dumpT;
                           off -> dumpI; 'diSize:' -> dumpT;
                           diSize -> dumpI; 'IT.qSize:'->dumpT; 
                           IT.qsize[1] -> dumpI; IT.objSize -> dumpI;
                           IT.encOG.objSize -> dumpI;
                           'IT:'->dumpT; IT.encOG.OGid -> dumpT;
                           dumpNL;               
                   if)if)
                  else
                     (if false then
                         '!!!! NameDecl:Qalloc:ATd is none: '->puttext;
                         dopt -> putline;
                         father.label -> puttext; ' '-> put;
                         father.father.father.label -> putline;
                         (* shall be done in AST after parsing *)
                     if);
                     father.father.father[] -> ATd[];
                     restart L
               if)
            #)
       #);
     NameList::<
       (# Qalloc::
            (#
            do (if traceAlloc then
                   '**** NameList:Qalloc:'->puttext; dopt -> putline;
               if);
               scan(#do (1,IT[]) -> current.Qalloc #)
            #)
       #);
     Signature::< 
       (# Qalloc:: 
            (# 
            do (if not isAllocated then
                   (if traceAlloc then
                       '**** Signature:Qalloc:'->puttext; dopt -> dumpT;
                       names[] = none->dumpB;
                       names.dopt -> dumpT;;
                       names.firstDecl = none->dumpB;
                       (if names.firstDecl <> none then
                           (names.firstDecl).off -> dumpI;

                       if);
                       dumpNL
                   if);
                   (if type[] <> none then
                       (1,IT[]) -> type.Qalloc
                   if);
                   (if args[] <> none then
                       (1,IT[]) -> args.Qalloc
                   if);
                   scanSons(#do (1,IT[]) -> current.Qalloc #);
                   (*'**   Signature:Qalloc:end:'-> dumpT;
                   (names.firstDecl).off -> dumpI;     dumpNL ;  *)            
                   true -> isAllocated
               (* else
                   '**** isAllocated:'-> dumpT; dopt -> dumpTN*)
               if)
            #);
          clear::< (# do false -> isAllocated #);
          isAllocated: @Boolean
       #);
      Arguments::<
       (# Qalloc:: 
            (# 
            do (if traceAlloc then
                    '**** Arguments:Qalloc: ' ->puttext; dopt -> putline
               if);
               scanSons
               (#
               do (if traceAlloc then
                      '**** Arg:Qalloc: ' ->puttext; current.label -> puttext;
                      ' ' -> put;
                      current.dopt -> putline;
                  if);
                  (if current## = DataItem## then
                      (* hack due to parsing of new syntax:
                       *    + V: var Integer: { ... }
                       * Fix the parser!
                       *)
                      (1,IT[]) -> current.Qalloc
                  if);
                 (* (1,IT[]) -> current.Qalloc*)
               #)
            #)
       #);
     AssignmentStatement::<
       (# Qalloc::
            (#
            do (if traceAlloc then
                   '**** AssinmentStatement:alloc:'->puttext; dopt -> putline
               if);
               (1,IT[]) -> left.Qalloc;
               (1,IT[]) -> right.Qalloc
            #);
       #);
     ObjectCall::<
       (# marked: @boolean;
          Qalloc:: 
            (# 
            do (if traceAlloc then
                   '**** ObjectCall:Qalloc:'->puttext; dopt -> puthead
               if);
               cd.com(#do 'OC:Qalloc:'->TT; dopt -> TQ; #);
               (1,none) -> super.Qalloc;
                '**** Qalloc:OC: ' -> puttext; OGid -> puttext; ' '-> put;
               marked -> putBoolean; newline;
               father.dopt -> puthead;               
            #);
          clear::< (# do false -> marked #)
       #);
     ObjectGenerator::<
       (# marked: @boolean;
          Qalloc::
            (* Should be called when genClass for this OG is called *)
            (# E:^Exp; ptn: ^Pattern
            do (if traceAlloc then
                   '**** OG:Qalloc:'->dumpT; doPT -> putheadN;
                   '**   IT=none:'-> dumpT; IT[] = none -> dumpB;
                   dumpNL
               if);
               cd.com(#do 'OG:Qalloc:' -> TT; dopt ->TQ; 
                        'qDescno: ' -> TT; IS.QdescNo[1] -> II
                     #);

               (if IS.QdescNo[1] > 0 then
                   (* Must find out why Qalloc is called a second time
                    * Perhaps because we for R: ref T used to call T.Qalloc;
                    * For R: obj T, we still call T.Qalloc for all such R!
                    *)
                   (if false then
                       '!!!! Qalloc: IS.QdescNo[1] > 0 : ' 
                         -> puttext;
                       IS.QdescNo[1] -> putint; newline;
                       dopt -> putline;
                   if);
                   leave Qalloc
               if);
               cd.com(#do 'OG:Qalloc:A: ' -> TT; OGid -> TQ;
                        ' super: ' -> TT; super.dopt -> TQ;
                        ' marked: '-> TT; marked -> BB; 
                        father.dopt -> TQ; 
                        'super: ' -> TT; super.doPT -> TT
                     #);
               (1,none) -> super.Qalloc;
               (* super.Qalloc above may make the if below superflous?*)
               cd.com(#do 'IS.superDesc<>none: ' -> TT;
                        IS.superDesc[] <> none -> BB;
                        ' IS.superDesc.newDescNo: ' -> TT;
                        (if IS.superDesc[] <> none then
                            IS.superDesc.newDescNo -> II; 
                            IS.superDesc.objSize -> II;
                            IS.superDesc.dopt -> TT
                        if);
                     #);
               (if (IS.superDesc[] <> none) 
                   and (IS.superDesc.newDescNo = 0) then
                   (* superDesc is always a pattern *)
                   IS.superDesc.father.father[] -> ptn[];
                   cd.com(#do'OG:Qalloc:SuperAlloc:'->TT;ptn.dopt->TQ#);
                   
                   (if ptn[] <> objectDecl[] then
                       (1,none) -> ptn.OG.Qalloc;
               if)if);
               (* some addBinding in checker:OG:alloc *)
               (if (super.last -> E[]) <> none then
                   (if E.isEmpty then
                    else
                       (if (E[] <> none) and (E.ATd[] <> none) then 
                           cd.com(#do'OG:super: '->TT; E.ATd.dopt->TQ#);
                           E[] -> (E.ATd.asDecl).handleArgs  
                           (* !!! Imply call of old newDesc below!? *)
               if)if)if);
               
               cd.com(#do 'OG:Qalloc:isObjectDesc: ' -> TT; 
                        isObjectDesc->BB;
                        ' isObjectDesc: ' -> TT; isObjectDesc->BB;
                        ' hasItems: ' -> TT; hasItems -> BB;
                     #);
               cd.com(#do
                        ' super.hasVirtualArgs: ' -> TT;
                        super.hasVirtualArgs -> BB;
                        ' not super.isPrimitive: ' -> TT;
                        not super.hasVirtualArgs -> BB
                     #);
               cd.com(#do dopt -> TQ; nl;
                        'super: ' -> TT; super.dopt -> TQ; nl;
                        (if E[] <> none then
                            'E: ' -> TT; E.dopt -> TQ
                        if)
                     #);
               (if isObjectDesc then 
                   cd.com(#do 'OG:Qalloc:B:'->TT;  OGid->TQ;
                            'newDescNo:' -> TT; IS.newDescNo -> II;
                            'objSize:' -> TT; objSize -> II #);
                   
                   this(ObjectGenerator)[] 
                     -> QnewDesc -> IS.QdescNo[1];
                   
                   cd.com(#do 'OG:isObjectDesc:NewDescNo:' ->TT; 
                            IS.QdescNo[1] -> II;
                            'IS.newDescNo:'->TT; IS.newDescNo -> II;
                            'objSize:' -> TT; objSize -> II;
                            '1:' ->TT; 1 -> II; IS.dopt ->TQ #);
                   (1,IT[]) -> IS.Qalloc ;
                   cd.com(#do 'IS.newDescNo:'->TT; IS.newDescNo -> II; 
                            'IS.objSize:' -> TT; objSize -> II; 
                            IS.dopt ->TQ #);
               if);
               cd.com(#do 'OG:Qalloc:end: IS.newDescNo: ' -> TT;
                        IS.newDescNo -> II; doPT -> TQ #);
            #);
          reAlloc:
            (# org: ^Items
            do cd.fcom(#do 'OG:reAlloc:'->TT; 
                         'descNo:'->TT; IS.descNo -> II;
                         (origin[]->org[]).encOG.primno -> II;
                         doPT -> TQ
                      #);
               (if stringAsVal
                   and ((origin[]->org[]).encOG.primNo = String_prim) then
                   cd.fcom(#do 'OG:reAlloc:String:'->TT; #);
                   IS.scanAllDecls(#do 0 -> currentDcl.qOff[1] #);
                   1 -> IS.qSize[1]; (* origin *)
                   IS.scanAllDecls
                   (#
                   do (if currentDcl.OG.primNo = this_prim then
                          cd.fcom(#do   'currentDcl:this:' -> TT#);
                          IS.qsize[1] + 1 -> currentDcl.qoff[1];
                          IS.qsize[1] + 1 -> IS.qsize[1];
                       else
                          (1,IS[]) -> currentDcl.Qalloc;
                      if);
                      cd.fcom(#do 'reAllocatedOff:'->TT; 
                                currentDcl.sig.dopt->TQ; 
                                currentDcl.qoff[1]->II
                             #)
                   #)
                else
                   (if IS.superDesc[] = none then
                       (if (origin[]->org[]).encOG.primno = String_prim then
                           (* remove - is handled in then-part *)
                           (* String is a value obj, but treated as a reference
                            * The size of origin is thus 1 *)
                           1 -> IS.qSize[1];
                           '!! GotString'->putline;
                        else
                           (* Other value objects: size of origin = 3 *)
                           3 -> IS.qSize[1]; 
                           (if false then
                               '**   setqSize ='->dumpT; IS.qSize[1]->dumpI;
                               dopt -> putheadN;
                               '**   IS:'-> dumpT; IS.dopt -> putHeadN
                           if)
                       if)
                    else
                       IS.superDesc.encOG.reAlloc;
                       IS.superDesc.qSize[1] -> IS.qSize[1];
                       (if (origin[]->org[]).encOG.primno = String_prim then
                           1 -> IS.qSize[1];
                       if);
                       (if false then
                           '**   withSuper:qSize:'->dumpT; IS.qsize[1]->dumpI;
                           dumpNL
                       if)
                   if);
                   IS.scanDecls
                   (#
                   do (*'**   clear:'->dumpT; currentDcl.dopt -> dumpTN*)
                      0 -> (currentDcl.asDecl).qOff[1];
                      false -> currentDcl.sig.isAllocated
                   #);
                   (*true  ->tracealloc;*)
                   IS.scanDecls
                   (#
                   do (*'**   reAlloc:'->dumpT; currentDcl.label -> dumpT;
                       currentDcl.dopt -> dumpTN;*)
                      (if nameListInDcl then 
                          (1,IS[]) -> (currentDcl.asDecl).Qalloc;
                       else                          
                          (1,IS[]) -> currentDcl.Qalloc;
                   if)#)
               if);
               (if false then
                   '**** newSize: '->puttext; IS.encOG.OGid -> dumpT;
                   IS.qSize[1]->dumpI;
                   IS.dopt -> putheadN;
                   IS.scanAllDecls
                   (#
                   do currentDcl.dopt -> putHead;  ' '->put; 
                      (if nameListInDcl then
                          currentDcl.sig.names.scan(#do current.off -> dumpI #);
                          dumpTN
                       else
                          currentDcl.qOff[1]  -> putint; newline
                      if)
               #)if);
               (*false -> tracealloc;*)
            #);          
          clear::<
            (#
            do false -> marked;
               inner
            #);
       #);
     items::<
       (# PP:: 
            (# org: ^Items
            do ' descNo: ' -> lx.puttext; newDescNo -> lx.putint;
               ' origDescNo: ' -> lx.puttext; 
               newDescNo -> lx.putint;
               (*(origin[] -> org[]).newDescNo -> lx.putint*)
            #);
          objDescEq::
            (#
            do ' items:objDescEq:newDescNo: ' -> puttext; newDescNo -> putint
            #);
          theDescNo:
            (# dNo: @integer
            do (if isEmpty and not super.hasVirtualArgs then
                   (super.ATd.asDecl).OG.IS.newDescNo -> dNo
                else
                   newDescNo -> dNo
               if)
            exit dNo
            #);
          newDescNo:
            (# dNo: @integer
            do (if false and isEmpty then
                   '**** Items:IS.isEmpty:' -> puttext;
                   encOG.doPT -> putline;
               if);
               QdescNo[1] -> dNo
            exit dNo 
            #);   

          OriginIsValue: BooleanValue
            (# org: ^Items
            enter org[] (* do we need an enter arg? 
                         * Is it always origin of this(Items)? *)
            do (if (org[] <> none)then
                   (if org.encOG.primNo = String_prim then
                       leave OriginISValue
                   if);
                   (if org.encOG.isValueObj then
                       true -> value
                    else
                       (if superDesc[] <> none then
                           (* No enter arg here!? 
                            * statement below is thus just skip!?
                            * Perhaps org.encOG.isValueObj above,
                            * handles a possible super?*)
                           superDesc.originIsValue -> value
               if)if)if);
            #);
          Qalloc:: 
            (# allocOrigin:
                 (# org: ^Items; N: ^Node
                 do (if globalRestrictionsInMain and not inVirtualptn then
                        (if false then
                            '!!! Qalloc: globalRestrictionsInMain:'-> puttext;
                            encOG.father.label -> dumpT;
                            (encOG.father[]->N[]).isPattern -> putBoolean;
                            encOG.dopt  -> putheadN;
                        if)
                     else
                        (*'**   allocOrigin:'->dumpT; sig.dopt -> dumpT;
                        qsize[1] -> dumpI; dumpNL;*)
                        qsize[1] + 1 -> qsize[1] -> qOriginOff[1];
                        origin[] -> org[]; 
                        (if (origin[] -> originIsValue) then
                            qsize[1] + 2 -> qsize[1];
                        if);
                    if);
                    (*'**   allocOrigin:B:'->dumpT; sig.dopt -> dumpT;
                    qsize[1] -> dumpI; dumpNL;*)
                 #);
               isVirtualObject: booleanValue
                 (# P:^Pattern
                 do (if (super.ATd.asDecl).isPattern then (* should be *)
                        super.ATd.asDecl -> P[];
                        (if P.ptnKind <> plainPtn then (* virtuaï *)
                            (if P.OG.IS.isEmpty then (* P = V :< Q *)
                                P.OG.super.ATd.asDecl = objectDecl[] -> value
                    if)if)if)
                 #);                     
               superNotImplOrSingularImpl: @boolean
            do (if traceALLOC THEN
                   '**** Items:Qalloc: ' -> puttext; dopt -> puthead
               if);
               cd.com
               (#do 'Items:Qalloc:objSize:'->TT;  objSize -> II; 
                  ' newDescNo:'->TT; newDescNo -> II; dopt->TQ;
               #);
               (if super.ATd[] <> none then
                   (if false and ((newDescNo = 35) or (newDescNo = 78)) then
                       '**   hasSuper:'->putline; super.atd.dopt -> putline;
                       '*** super.Atd:'->putline; super.ATd.dopt ->puthead;
                   if);
                   (* We have
                    *    OG = Super { ... }
                    * (1) super is a Name: normal case
                    * (2) Super is empty as in
                    *     V::< { ... } => super.isImplSuper == True
                    *     where V:< A{ ... } or V:< A
                    *     In bot cases A may be on a different block level
                    * (3) If V:< A{ ... } and not V:< A
                    *     => super.isSingularImplSuper == True
                    *        And thus on the same block level
                    * 
                    *)
                   cd.com(#do 'Items:Qalloc:super:' -> TT; super.dopt -> TQ;
                            'size:' -> TT; superDesc.qsize[1] -> II;
                            encOG.OGid -> TQ; #);

                   superDesc.qsize[1] -> qsize[1];
                   (if super.isImplSuper then
                       super.isSingularImplSuper 
                         -> superNotImplOrSingularImpl
                    else
                       true -> superNotImplOrSingularImpl
                   if);
                   cd.com(#do 'super.isThisBlockLevel:'-> TT;
                            super.isThisBlockLevel -> BB;
                            'superNotImplOrSingularImpl:' -> TT; 
                            superNotImplOrSingularImpl -> BB;
                         #);                   
                   (if super.isThisBlockLevel and superNotImplOrSingularImpl
                      (* and (not super.isImplSuper) 
                       and (not super.isSingularImplSuper)*)
                       then
                       (if globalRestrictionsInSuper
                           and not globalRestrictionsInMain then
                           (* This conditiona has to be checked! 
                            * Added not NoGlobalsInMain. Old comment below: *)
                           (* this looks wrong! 
                            * Only if globalRestrictionsMain = false ? *)
                           qsize[1] + 1 -> qsize[1] -> qOriginOff[1]
                        else
                           superDesc.qOriginOff[1] -> qOriginOff[1]
                       if)
                    else
                       (if isVirtualObject then
                           (if false then
                               '**** super isVirtualObject: ' -> puttext;
                               encOG.OGid -> putline;
                               encOG.father.dopt -> putline; '---'->putline;
                               super.atd.dopt -> puthead;
                           if);
                           superDesc.qOriginOff[1] -> qOriginOff[1];
                           (if false then
                               'newOriginOff: ' -> puttext; 
                               newOriginOff -> putint; ' ' -> put;
                               qOriginOff[1] -> putint; ' ' -> put; 
                               1 -> putint; newline
                           if)
                        else
                           allocOrigin
                   if)if);
                   cd.com
                   (# do 'Items:Qalloc:super:B:objSize:'->TT;  objSize -> II;
                      'originOff:'->TT; qOriginOff[1] -> II;
                   #)
                else
                   allocOrigin;
                   cd.com
                   (# do 'Items:Qalloc:Super:C:objSize:'->TT;  objSize -> II;
                      'originOff:'->TT; qOriginOff[1] -> II;
                   #);
                   (if false and ((newDescNo = 35) or  (newDescNo = 78)) then
                       '**** Items:Qalloc:noSuper:objSize:'->puttext;
                       objSize -> putint; ' newdescNo: ' -> puttext;
                       newdescno -> putint;
                       newline; dopt -> putline;
                   if);
               if);
               (if false and encOG.isBasicValue 
                   and isPrimitive
                   and (primNo <> value_prim)
                   then
                   cd.com
                   (#
                   do 'Items:Alloc:isBasicValue:' -> TT;
                      (if sig[] <> none then sig.dopt -> TQ if);
                      ':qsize:'->TT; qsize[1] -> II; 
                      qsize[1] + 1 -> qsize[1]; (* !!! ??? *)
                      ':size:' -> TT; objSize -> II;
                      ':qsize:'->TT; qsize[1] -> II; 
                   #)
               if);
               labelHandler.init; 
               restartLab.new;
               leaveLab.new;
               (if true or not nameListInDcl then
                   (if sig[] <> none then
                       (* why here?
                        * We dont allocate a pattern 
                        * its OG is allocated if used!
                        * This means we need to allocate its signature
                        * We might skip sig.Qalloc in dataItem and then
                        * do it here also for DataItem
                        *)
                       (if this(Items).origin[] <> none then
                           (* IT[] = none for BETAworld and we need not
                            * allocate address for BETAworld!
                            *)
                           (if 'Pattern' -> (sig.father.label).equalNCS then
                               (1,this(items)[]) -> sig.Qalloc
                            else
                               (1,this(Items).origin[]) -> sig.Qalloc;
                           if);
                        else
                           (if false then
                               '**** OG:sig:IT=none:'->dumpT;
                               sig.dopt -> putheadN;
                               '**   items:'->dumpT; 
                               this(Items).dopt -> putheadN;
                               '**   items:origin:'->dumpT; 
                               (if this(Items).origin[] <> none then
                                   this(Items).origin.dopt -> putheadN
                       if)if)if);
                       (*(1,this(items)[]) -> sig.Qalloc*)
               if)if);
               scanSons (#do (1,this(items)[]) -> current.Qalloc #);
               cd.com(#do 'Items:Qalloc:END:objSize:'->TT; qsize[1] -> II;
                        ' newDescNo:'->TT; newDescNo -> II;  dopt->TQ;#);
            #);
          newOriginOff:: 
            (# 
            do qOriginOff[1] -> value
            #);

          qOriginOff: [1] @integer;
          restartLab,leaveLab: @LabelHandler.label;  
          
          clear::< (# do 0 -> qsize[1]; inner #);
       #);
     Pattern::<
       (# Qalloc:: 
            (# allocStub:
                 (# P: ^Pattern; OGs: ^ObjectGenerator; dNo: @integer; 
                    errs: ^Stream; T: ^text
                 do (*leave allocStub;*)
                    (if false then
                        '**** Qalloc:allocStub:' -> dumpT; sig.dopt->dumpT;
                        ' vdescNo: ' -> puttext; 
                        OG.vDescNo -> putint; newline;
                    if);
                    '' -> T[];
                    sig.dopt -> T.append;
                    ': { %id stub }' 
                      -> T.append
                      -> parseDeclText -> (errs[],P[]);
                    (* P.doPt -> putline;*)
                    P.OG[] -> OGs[]; 
                    P.setUpOrigin;
                    P.check;
                    OGs[] -> QnewDesc -> dNo -> OGs.IS.QdescNo[1];
                    '$' -> OGs.sig.type.id.put;
                    dNo -> OGs.sig.type.id.putint;
                    dNo  -> OG.vDescNo;
                    (1,none) -> P.Qalloc;
                 #)
            do cd.com(#do 'Pattern:Qalloc:'->TT; sig.id[] ->TT #);
               (if traceAlloc then
                   '**** ptn:qalloc: ' -> puttext; sig.dopt -> puttext;
                   ' ' -> put; ptnKind -> putint;  ' ' -> put;
                   isprimitive -> putBoolean;  ' ' -> put;
                   OG.isBasicValue -> putboolean;                 
                   newline;
               if);
               (if true 
                // isPrimitive then
                   (if OG.IS.newDescNo = 0 then
                       (*(1,IT[]) -> OG.Qalloc;*)
                       (* more stuff in checker:ptn:alloc *)
                   if);
                // OG.isBasicValue and not isVirtual then   
                   (if false then 
                       '\n*** pattern:qalloc:SimpleValue: ' -> putline;
                       doPT -> printHead;
                   if);
                   (if OG.IS.newDescNo = 0 then
                      (* (1,IT[]) -> OG.Qalloc*)
                   if); 
                else
                   cd.com(#do 'Pattern:Qalloc:B:'->TT; sig.id[] ->TT #);
                   (if ptnKind
                    // plainPtn then                 
                    // virtualPtn then
                       (* Is there a more general way to handle this *)
                       (if not OG.hasItems then
                           (if (OG.super.ATd[] <> none) 
                               and ((OG.super.desc).newDescNo = 0) then
                               cd.com(#do '(OG.super.desc).newDescNo = 0'->TT#);
                               (# ptn: ^Pattern
                               do OG.super.ATd.asDecl -> ptn[];
                                  (1,none) -> ptn.OG.Qalloc;
                                  cd.com(#
                                        do 'Pattern:qalloc:super:descNo:'->TT;
                                           (OG.super.desc).newDescNo -> II;
                                           doPt ->TT
                                        #);
                               #);
                           if);
                           allocStub 
                       if)
                    // furtherPtn // finalPtn then 
                       (if not OG.hasItems then allocStub if)
               if)if)
            #);
          new_descNo:< IntegerValue
            (# ptn: ^Pattern
            do (if OG.IS.isEmpty then
                   (if (OG.super.ATd.asDecl -> ptn[]) <> none then 
                       ptn.new_descNo -> value
                   if)
                else
                   OG.IS.newDescNo -> value
               if)
            #);          
          new_size:< IntegerValue
            (# ptn: ^Pattern
            do cd.com(#do 'new_size:A:'->TT; isChecked->BB;' '->TT;dopt->TQ #);
               (if OG.IS.isEmpty then
                   (if (OG.super.ATd.asDecl -> ptn[]) <> none then 
                       ptn.new_size -> value;
                       cd.com(#do 'new_size:B:'->TT; value->II; 
                                ' objSize: ' -> TT; ptn.OG.IS.ObjSize -> II;
                                ' newDescNo: '->TT; ptn.OG.IS.newDescNo->II #);
                   if)
                else
                   OG.IS.qsize[1] -> value;
                   cd.com(#do 'new_size:C:'->TT; value->II; 
                            ' qSize:' -> TT; OG.IS.qsize[1] -> II; 
                         #)
               if)
            #)
       #);
     Invocation::<
       (# Qalloc:: 
            (# 
            do cd.com(#do 'Invocation:Qalloc:' ->TT; dopt ->TQ #);
               scanSons
               (# E: ^Exp
               do current[] -> E[];
                  (1,IT[]) -> current.Qalloc;
                (*  (if E.args[]  <> none then
                      E.args.scanArgs(#do (1,none) -> current.Qalloc #)
                 if)*)
               #)
            #);
       #);
     ObjectInvocation::<
       (# Qalloc:: 
            (# ptn: ^Pattern
            do (if traceAlloc then
                   '**** OI:Qalloc:'->dumpT; doPT->putheadN;
               if);
               cd.com(#do 'ObjectInvocation:Qalloc:' ->TT; dopt ->TQ; #);
               scanSons
               (#do cd.com(#do current.label -> TT; current.dopt -> TQ  #);
                  (1,IT[]) -> current.Qalloc 
               #);
               (if hasVirtualArgs then     
                   (if false then
                       'false OI:Qalloc:hasVirtualArgs:\n' -> puttext; 
                       dopt -> putline;
                   if);
                   ATd.asDecl -> ptn[];
                   ptn.scanArgs
                   (# OGx: ^ObjectGenerator; argInx: @integer
                   do argInx + 1 -> argInx;
                      (if currentArg.isVirtual then
                          (if false then
                              '**   OI:Qalloc:got: ' -> puttext; 
                              currentArg.dopt -> putline;
                          if);
                          (*QnewDesc -> currentArg.OG.vDescNo*)
                          (*  it is actualArg that must be assigned vDescNo  *)
                          args.scanArgs
                          (# i: @integer
                          do i + 1 -> i;
                             (if argInx = i then
                                 (if false then
                                     '**** aArg: ' -> puttext; 
                                     current.label -> putline;
                                     current.dopt -> putline;
                                     '**   formalArg: ' -> putline;
                                     currentArg.dopt -> puthead;
                                     currentArg.OG.vDescNo -> putint; ' '->put;
                                     currentArg.OG.OGid -> Putline
                                 if);
                                 current[] -> OGx[];
                                 (if OGx.IS.isEmpty then
                                     OGx[] -> QnewDesc -> OGx.vDescNo;
                                     (if false then
                                         '**   setvDescNo: '->puttext;
                                         OGx.vDescNo -> putint; newline
               if)if)if)#)if)#)if)
            #);
       #);
     IfThen::<
       (# Qalloc::
            (#
            do (if false then
                   '**** IfThen:Qalloc: ' -> puttext; dopt -> putline;
               if);
               (1,IT[]) -> cond.Qalloc;
               (1,IT[]) -> thenPart.Qalloc  
            #);
       #);
     IfThenElse::<
       (# Qalloc::
            (#
            do (if false then
                   '**** IfThenElse:Qalloc: ' -> puttext; dopt->putline;
               if);
               (1,IT[]) -> cond.Qalloc;
               (1,IT[]) -> thenPart.Qalloc;
               (1,IT[]) -> ElsePart.Qalloc;  
            #);
       #);
     BracketedExp::<
       (# Qalloc:: (# do (1,IT[]) -> IV.Qalloc #);
       #);
     Const::< (# #);
     CharObj::< (# #);
     StringObj::< 
       (# Qalloc:: 
            (# 
            do scanSons(# do (1,IT[]) -> current.Qalloc #) 
            #);
       #);
     Slot::<
       (# Qalloc::
            (#
            do (if traceSlots then
                   '**** Slot:Qalloc: ' -> puttext; id[] -> putline;
               if);
               slotItems.scanSons(#do (1,IT[]) -> current.Qalloc #);
            #)
       #);
     getObjectDesc:: 
       (# OG: ^ObjectGenerator
       do descNo -> QnewDesc.getOD -> OG[];
          OG.IS[] -> D[];
       #);     
     QnewDesc: @
       (# init: 
            (# 
            do 0 -> noOfDescs; (for i: OD.range repeat none -> OD[i][] for) 
            #);
          getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectGenerator; ptn: ^Pattern
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[];
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   (if false then
                       (* do we have a problem here? *)
                       '\n!!! newDesc:getOD:no repetitionDesc:'->putline;
                   if);
                   (IndexedDecl[]->ptn[]).OG[] -> anODx[]
               if);
            exit anODx[]
            #);
          OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;          
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that anOD[] has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     labelHandler: @
       (# labCount: @integer;
          label:
            (# labNo: @integer;
               new: (# do  labCount + 1 -> labCount -> labNo #);
            enter labNo
            exit labNo
            #);
          init: (# do 0 -> labCount #);
       #);
  do QNewDesc.init;
     
     inner
  #)
