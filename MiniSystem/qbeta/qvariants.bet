ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qrestrictions';
---lib:attributes---
variants: restrictions
  (# traceEmbedding: @boolean; 
     Module::<
       (# Qalloc:: 
            (#
            do cd.com(#do 'Qalloc:module:'->TT; moduleName -> TT #);
               (if IT[] <> none then (* IT is none if top module *)
                   (if varNo < IT.qsize.range then
                       1 -> IT.qsize.extend;
                       1 -> qoff.extend
                   if);
                   IT.qsize[varNo] + 1 -> IT.qsize[varNo] -> qoff[varNo];
                   cd.com(#do 'Module:alloc:off:' ->TT; qOff[varNo] -> II; dopt ->TT #)
               if);
               (varNo,IT[]) -> sig.Qalloc;
               (* OG.Qalloc is called from generator *)
            #)
       #);
     ModuleItem::<
       (# Qalloc:: 
            (# 
            do cd.com(#do 'ModuleItem:Qalloc: ' ->TT; doPT ->TT #); 
               (if isChecked then 
                   'ModuleItem:Qalloc:B:'->cd.comment;
                   (varNo,IT[]) -> MD.Qalloc if)
            #)        
       #);
     DataItem::<
       (# Qalloc:: 
            (# diSize: @integer
            do (if varNo < IT.qsize.range then
                   1 -> IT.qsize.extend;
                   1 -> qoff.extend
               if);
               cd.com
               (#
               do 'dataitem:qalloc:'->TT; sig.id[] ->TQ; 
                  'isValue:'->TT;  isValue -> BB;
                  ' isPrimitive:' -> TT; OG.isPrimitive -> BB;
                  ' isValObj: ' -> TT; OG.isValueObj -> BB;
                  ' isBasicValue:' -> TT; isBasicValue -> BB
               #);
               (if isValue or isBasicValue then
                   (* We must alloc and generate all patterns and OGs to be embedded *)
                   (if true
                    // OG.isPrimitive // OG.isBasicValue then
                       (* isPrimitive should probaly be removed *)
                       (if (OG.primNo = float_prim) or OG.isFloat then
                           2 -> diSize
                        else
                           1 -> diSize
                       if)
                    // not OG.IS.isEmpty then
                       OG.IS.qsize[1(*OG.IS.thisVar.thisVarNo*)] -> diSize;
                       cd.com(#do 'A:'->TT; diSize->II#);
                    else
                       (# ptn: ^pattern
                       do OG.super.ATd[] -> ptn[];
                          (if ptn.OG.primNo = indexed_prim then
                              '**** indexed: ' -> puttext; dopt -> putline;
                                ptn.dopt -> puthead
                          if);
                          (if ptn.OG.IS.newDescNo = 0 then
                              (varNo,ptn.origin[]) -> ptn.OG.qAlloc;
                          if);
                          ptn.new_size -> diSize;
                          cd.com(#do 'B:'->TT; diSize->II; ' ptn:'->TT;ptn.dopt->TQ#);
                          cd.com(#do 'newDescNo:'->TT; ptn.OG.IS.newDescNo -> II #)
                   #)if);
                   IT.qsize[varNo] + 1 -> qoff[varNo];
                   IT.qsize[varNo] + diSize -> IT.qsize[varNo];
                   cd.com(#
                         do 'diSize:'->TT; diSize->II; 
                            'IT.qSize:'->TT; IT.qsize[varNo]->II 
                         #);
                   (if traceEmbedding then
                       '*** Alloc:value:size:' -> puttext; diSize ->putint; 
                       ':off:' -> puttext; qoff[varNo] -> putint;
                       ':varNo:' -> puttext; varNo -> putint;
                       ' ' -> put; dopt -> putline;
                   if)
                else
                   IT.qsize[varNo] + 1 -> IT.qsize[varNo] -> qoff[varNo];
                   cd.com(#do 'DI:Qalloc:off:' ->TT; qOff[varNo] -> II; dopt ->TQ #);
                   (varNo,IT[]) -> OG.Qalloc
               if);
               (varNo,IT[]) -> sig.Qalloc;
               (* OG.Qalloc is called from qgenerator *)
            #);
          objSize:: (#do OG.objSize -> value  #)
       #);
     Signature::<
       (# Qalloc:: 
            (# 
            do (if type[] <> none then
                   (varNo,IT[]) -> type.Qalloc
               if);
               (if args[] <> none then
                   (varNo,IT[]) -> args.Qalloc
               if);
               scanSons(#do (varNo,IT[]) -> current.Qalloc #)
             #);
       #);
     Arguments::<
       (# Qalloc:: 
            (# 
            do (if false then
                    '**** Arguments:Qalloc: ' ->puttext; dopt -> putline
               if);

               scanSons
               (#
               do (if false then
                      '**** Arg:Qalloc: ' ->puttext;
                      current.dopt -> putline;
                  if);
                 (* (varNo,IT[]) -> current.Qalloc*)
               #)
            #)
       #);
     ObjectCall::<
       (# marked: @boolean;
          Qalloc:: 
            (# 
            do cd.com(#do 'OC:Qalloc:'->TT; dopt -> TQ; #);
               (if true then
                   (1,none) -> super.Qalloc;
                else
                   scanSons(#do (varNo,IT[]) -> current.Qalloc #)
               if);
                '**** Qalloc:OC: ' -> puttext; OGid -> puttext; ' '-> put;
               marked -> putBoolean; newline;
               father.dopt -> puthead;               
            #)
       #);
     ObjectGenerator::<
       (# marked: @boolean;
          Qalloc::
            (* Should be called when genClass for this OG is called *)
            (# E:^Exp; ptn: ^Pattern
            do cd.com(#do 'OG:Qalloc:' -> TT; dopt ->TQ; nl;
                        'qDescno: ' -> TT; IS.QdescNo[varNo] -> II;
                        'varNo:'->TT; varNo -> II;
                        ':allocDone:'->TT;
                        (if qvariants.var[varNo][] <> none then
                            Qvariants.var[varNo].allocDone -> BB;
                        if);
                     #);

               (if IS.QdescNo[varNo] > 0 then
                   (* Must find out why Qalloc is called a second time*)
                   (if false then
                       '!!!! Qalloc: IS.QdescNo[varNo] > 0 : ' 
                         -> puttext;
                       IS.QdescNo[varNo] -> putint; newline;
                       dopt -> putline;
                   if);
                   leave Qalloc
               if);
               cd.com(#do 'OG:Qalloc:A: ' -> TT; OGid -> TQ;
                        ' super: ' -> TT; super.dopt -> TQ;
                        ' marked: '-> TT; marked -> BB; nl;
                        father.dopt -> TQ; nl;
                        'super: ' -> TT; super.dopp -> TT
                     #);
               (1,none) -> super.Qalloc;
               (* super.Qalloc above may make the if below superflous?*)
               cd.com(#do 'IS.superDesc<>none: ' -> TT;
                        IS.superDesc[] <> none -> BB;
                        ' IS.superDesc.newDescNo: ' -> TT;
                        (if IS.superDesc[] <> none then
                            IS.superDesc.newDescNo -> II if)
                     #);
               (if (IS.superDesc[] <> none) 
                   and (IS.superDesc.newDescNo = 0) then
                   (* superDesc is always a pattern *)
                   IS.superDesc.father.father[] -> ptn[];
                   cd.com(#do'OG:Qalloc:SuperAlloc:'->TT;ptn.dopt->TQ#);
                   
                   (if ptn[] <> objectDecl[] then
                       (1,none) -> ptn.OG.Qalloc;
               if)if);
               (* some addBinding in checker:OG:alloc *)
               (if (super.last -> E[]) <> none then
                   (if E.isEmpty then
                    else
                       (if (E[] <> none) and (E.ATd[] <> none) then 
                           cd.com(#do'OG:super: '->TT; E.ATd.dopt->TQ#);
                           E[] -> E.ATd.handleArgs  
                           (* !!! Imply call of old newDesc below!? *)
               if)if)if);
               
               cd.com(#do 'OG:Qalloc:isObjectDesc: ' -> TT; 
                        isObjectDesc->BB;
                        ' isObjectDescX: ' -> TT; isObjectDescX->BB;
                        ' hasItems: ' -> TT; hasItems -> BB;
                     #);
               cd.com(#do
                        ' super.hasVirtualArgs: ' -> TT;
                        super.hasVirtualArgs -> BB;
                        ' not super.isPrimitive: ' -> TT;
                        not super.hasVirtualArgs -> BB
                     #);
               cd.com(#do dopt -> TQ; nl;
                        'super: ' -> TT; super.dopt -> TQ; nl;
                        (if E[] <> none then
                            'E: ' -> TT; E.dopt -> TQ
                        if)
                     #);
               (if isObjectDesc then 
                   (*'\n*** OG:Qalloc: ' -> putline; dopt -> putline;*)
                   (*  'QnewDesc:varNo: ' -> puttext; varNo -> putint;*)
                   (if varNo > IS.qDescNo.range then
                       (* should be done in items:Qalloc*)
                       1 -> IS.QDescNo.extend
                  if);
                   cd.com(#do 'OG:Qalloc:B:'->TT;  OGid->TQ;
                            'newDescNo:' -> TT; IS.newDescNo -> II;
                            'objSize:' -> TT; objSize -> II #);
                   
                   this(ObjectGenerator)[] 
                     -> QnewDesc -> IS.QdescNo[varNo];
                   
                   cd.com(#do 'OG:isObjectDesc:NewDescNo:' ->TT; 
                            IS.QdescNo[varNo] -> II;
                            'IS.newDescNo:'->TT; IS.newDescNo -> II;
                            'objSize:' -> TT; objSize -> II;
                            'varNo:' ->TT; varNo -> II; IS.dopt ->TQ #);
                   (varNo,IT[]) -> IS.Qalloc ;
                   cd.com(#do 'IS.newDescNo:'->TT; IS.newDescNo -> II; 
                            'IS.objSize:' -> TT; objSize -> II; 
                            IS.dopt ->TQ #);
               if);
               cd.com(#do 'OG:Qalloc:end: IS.newDescNo: ' -> TT;
                        IS.newDescNo -> II; nl;
                        doPT -> TQ #);
            #);   

          hasVariants: BooleanValue
            (# do not Qvariants.isEmpty -> value #);
          clear::<
            (#
            do 0 -> Qvariants.top;
               inner
            #);
          QvarPtn::
            (# VarType:: Variant;
               var: [1] ^Variant;
               new:
                 (# V: ^Variant
                 do (* '\n***** ObjectGenerator: Qgen:Computing variants:' 
                     * -> putline; doPT -> printhead ; *)
                    (if (top + 1 -> top) > var.range then
                        var.range -> var.extend;
                    if);
                    Variant -> var[top][] -> V[];
                    top -> V.thisVarNo;
                 exit V[]
                 #);
               computeVariantX::
                 (# H:< Object; notEmpty: @boolean;
                    V: ^Variant; 
                    contextOG: ^ObjectGenerator (* not used? *)
                 do new -> var[];
                    'ComputeVariantX' -> cd.comment;
                    IS.scanSons
                    (# I: ^Item; DI: ^DataItem
                    do current[] -> I[];
                       (if I.isDecl then
                           (if (not I.isPattern or I.isVirtual) and I.isDataItem then
                               I[] -> DI[];
                               (*var[] -> DI.markForCodeGen*)
                    if)if)#);  
                    
                    listObjQual
                    (# B: ^Pattern;
                    do (* Why do we call H here? Os there a problem? *)
                       (if false then H;  if);                       
                       true -> notEmpty;
                       current[] -> DI.OG.Qvariants.findBinding -> B[];
                       
                       (*'\ncontextOG:'->putline;
                       contextOG.dopt -> putline;
                       '\ncurrent: '->putline; 
                       current.dopt -> putline;
                       '\ncurrentNode: '->putline; 
                       currentNode.doPT -> puttext;
                       '\ncurrentVdcl: ' -> putline;
                       currentVdcl.dopt -> putline;
                       '\ncurrentBinding: ' -> puttext;
                       B.dopt -> putline;
                       ('\n---Item: "',currentNode.doPT
                       ,'" hasVirtual Object: ',' binding: ',B.dopt)
                         -> putTextL;*)
                       (currentVdcl[],B[] ) -> var.add;
                    #);
                    (if notEmpty then (*newline*) if);
                    (*'---done'->putline;
                    print;*)
                    (* top -1 -> top*)
                    checkIfTopIsNew -> V[];
                    (if V[] = var[] then
                        cd.com(#do 'V=var' -> TT #);
                        (*'var is new: top: ' -> puttext; V.top -> putint;
                         ' OG: ' -> puttext; OGid -> putline;*)
                        
                        (V.thisVarNo,none) -> Qalloc
                        
                     else
                        (* 'var is not new' -> putline;*)
                        cd.com(#do '<>var' -> TT #);
                        V[] -> var[]                     
                    if);
                    (if var.top = 0 then
                        (* none -> var[];top - 1 -> top*) if);
                 #);
               listObjQual:
                 (# current,currentVdcl: ^pattern; currentNode: ^Node;
                    getVdcl:
                      (# B,V: ^Pattern
                      enter B[]
                      do L:
                           (if B.isVirtual then
                               B[] -> V[]
                            else
                               B.vDcl[] -> B[];
                               restart L
                           if)
                      exit V[]
                      #);
                 do addBinding.scanObjectRefs
                    (# DI: ^DataItem
                    do current[]-> currentNode[] -> DI[];
                       (*'\n>>dataItem: ' -> puttext;
                        current.dopt -> putline;
                        DI.OG.super.ATd.dopt -> putline;*)
                        DI.OG.super.ATd[] -> getVdcl -> currentVdcl[];
                       DI.OG.super.ATd[] -> this(listObjQual).current[];
                       inner listObjQual
                    #);
                    addBinding.scanObjectInvs
                    (# DI: ^DataItem
                    do current[] -> currentNode[];
                       (* '\n>>>IO: ' -> puttext;
                       current.dopt -> putline;
                       current.ATd.dopt -> putline;*)
                       (if current.ATd.isPattern then
                           (* current.ATd is the virtual decl *)
                           current.ATd[] -> this(listObjQual).current[];
                        else
                           current.ATd[] -> DI[];
                           (*DI.OG.super.ATd.doPT -> putline;*)
                           DI.OG.super.ATd[] -> this(listObjQual).current[];
                       if);
                       inner listObjQual
                    #)
                 #);
               findBinding::
                 (#
                 do (for i: top repeat
                         (for j: var[i].top repeat
                              (if var[i].vDcl[j][] = vDcl[] then
                                  var[i].binding[j][] -> binding[]
                              if)
                         for)
                    for)
                 #);
               scanObjectRefs:
                 (# trace: (# exit true #);
                    head: @boolean;         
                    ATd: ^Decl; on,pn: @integer; (*Px: ^OGpath;*)
                    callingOG: ^ObjectGenerator; V: ^Variant
                 enter(callingOG[],V[])
                 do 
                    addBinding.scanObjectRefs
                    (# DI: ^DataItem; OGx,qual: ^ObjectGenerator; org: ^Items
                    do '!!!!scanOR:'->putline;
                       (if true or trace and not head then                          
                           '\n**** ObjectGenerator:Qgen:scanObjectRefs:'->putline; 
                           dopt -> printhead;
                           '\>>> callingOG:'->putline;
                           callingOG.dopt -> printhead;
                           true -> head
                       if);
                       (if trace then
                          '>>>> DataItem:with:ObjectQ:\n    ' -> puttext;
                          current.doPT -> putline;
                       if);
                       current[] -> DI[];
                       (* DI = R: ? elm where elm :< Object 
                        * Find actual binding of elm in the context of this OG
                        * Execute getV_ qual (Invocation(R)) in this(OG)
                        *)
                       (if trace then
                           '>>>> theOG: ' -> putline;
                           this(ObjectGenerator).doPT -> putline;
                       if); 
                       (* DI.sig.id = R *)
                       (*(DI.sig.id[],true) -> IS.search -> (ATd[],on,pn);*)
                       (* (on,pn) = path from IS to R: ? elm where on = 0 
                        * But why do we need this path?
                        * It seems that if on=0, we dont need it
                        * But do we have a case where on > 0? Probably yes:
                        *    List:
                        *       elm:< Object
                        *       item:
                        *          E: ? elm   
                        *          next: ? item
                        * Looks like the case with R:= V in insert
                        * Must have a closer look here!?
                        *)
                       (if trace then
                           'Search: ' -> puttext; DI.sig.id[] -> puttext;
                           ' '-> put; on -> putint; 
                           ' ' -> put; pn -> putint; newline;
                       if);
                       (* the code below is the same as in
                        * Invocation:getV_ qual
                        * Should be unified
                        *)
                       (if true then
                           (*(DI.sig.id[],true) -> IS.search -> (ATd[],on,pn);*)
                           (DI.sig.id[]->name,true)
                             -> IS.search -> (ATd[],on,pn);
                           callingOG[] -> OGx[];
                           (for i: on repeat
                                OGx[] -> encOG -> OGx[]
                           for);
                           (* the code in the enclosing ppatern seems to only be 
                            * called from the old alloc - more or less indrictly
                            * and we should thus not come here!
                            * (OGx[],none,none,0,0,none) 
                            *  -> OG path
                            *  -> DI.OG.super.ATd.pathToDcl 
                            *  -> px[];
                            *)
                       if);
                       (*px.qual[] -> qual[];*)
                       (DI.OG.super.ATd[],qual.father[]) -> V.add;
                       (if trace then
                           '>>>> Qual:'->puttext; qual.doPT -> putline; newline;
                       if)
                    #);
                    V[] -> scanObjectInvs
                 #);
               encOG:
                 (# OG: ^ObjectGenerator; N: ^Node
                 enter OG[]
                 do OG.father[] -> N[];
                    L:
                      (if N## = ObjectGenerator## then
                          N[] -> OG[]
                       else
                          N.father[] -> N[];
                          (if N[] = none then
                              '\n\nOBS! encOG:no enclosing OG: ' -> puttext; 
                           else
                              restart L
                          if);
                      if)
                 exit OG[]
                 #);
               addPair:
                 (# V: ^Variant; OI: ^OBjectInvocation;
                    
                    DI: ^DataItem; ptn: ^Pattern; ITx: ^Items;
                    OGx,qual: ^ObjectGenerator;
                    ATd: ^Decl; on,pn: @integer; (*Px: ^OGpath;*)
                 enter(V[],OI[])
                 do '\n\n****Addpair: '->puttext;  OI.doPT -> puttext;
                    (' on: ',OI.on) -> putTI;
                    (' pn: ',OI.pn) -> putTI;
                    '\n---In items: ' -> putline;
                    IS.dopt -> putline;
                    (if OI.ATD.isPattern then
                       (* '\n**OI.ATd is pattern:\n'->puttext;
                        OI.ATd.doPT -> printhead;*)
                        OI.ATd[] -> ptn[];
                        (OI.ptnID[],true) -> IS.search -> (ATd[],on,pn);
                     else
                        (*'\n**OI.ATd is dataitem:\n'->puttext;
                        OI.ATd.doPT -> printhead;*)
                        OI.ATD[] -> DI[];
                        (OI.ptnID[],true) -> IS.search -> (ATd[],on,pn);
                    if);
                    (if atd[] = none then (*'atd is none' ->putline *)
                     else
                        (* '**ATd:'->putline;
                         atd.dopt -> putline;
                         (' on: ',OI.on) -> putTI;
                         (' pn: ',OI.pn) -> putTI;*)
                        (* the code below is the same as in
                         * Invocation:getV_ qual
                         * Should be unified
                         *)
                    if);
                    (if OI.ATD.isPattern then
                     else
                        this(OBjectGenerator)[] -> OGx[];
                        (for i: on repeat
                             OGx[] -> encOG -> OGx[]
                         for);
                        (*  '\nOG^on:\n' -> puttext;
                         OGx.dopt -> printHead;*)
                        (*(OGx[],none,none,on,pn,none) 
                        (*-> OG path
                        (*-> DI.OG.super.ATd.pathToDcl 
                         -> px[];
                         px.qual[] -> qual[];
                         * *)
                        (DI.OG.super.ATd[],qual.father[]) -> V.add;
                        (if false then
                            '\n>>>> Qual:'->puttext; qual.doPT -> putline; newline;
                        if)                    
                    if)
                 #);
               scanObjectInvs:
                 (* addPair is not sufficient as it is for dataIem
                  * Consider
                  * List:
                  *    elm:?Object
                  *    R: ?elm
                  *    insert(V: ?elm):
                  *       R:= V  
                  * When in OG for insert, we are not in the right context
                  * Should probably be
                  *    Lrecord.insert(..)
                  *       ...
                  *       R:= V -- consider this OG as singular
                  *       -- when finding qualification of R and V
                  *)
                 (#
                    V: ^Variant
                 enter V[]
                 do addBinding.scanObjectInvs
                    (#
                    do (* current is an OI as in S := R 
                        * Find S : ^V where V:< Object
                        * Them find binding of V
                        *)
                       (* '\nscanObjectInvs: '-> puttext; 
                        current.father.dopt->putline;*)
                       (* ATd may be a dataItem as in : 'R := V'
                        * or a pattern as in: 'body' *)
                       (V[],current[]) -> addPair

                    #)
                 #);
               findSuperVar::
                 (#
                 do L:
                      (for i: top repeat
                           (if V[] -> var[i].equal then
                               (*'\n*** match:'->putline; print;*)
                               var[i][] -> sV[];
                               leave L
                      if)for)
                 #);
               topVarExists: booleanValue
                 (* Check if var[top] is in var[1], ..., var[top - 1 *)
                 (#
                 do cd.com(#do 'topVarExists:top:' ->TT; top -> II; #);
                    (for i : top - 1 repeat
                         (if (var[i][] -> var[top].equal -> value) then
                             cd.com(#do'var alreday exists'->TT #);
                             top - 1 -> top;
                             leave topVarExists
                    if)for);
                    (*' new var'->putline;*)
                 #);
               propagateToSuper:
                 (# ptn: ^Pattern; superOG: ^ObjectGenerator; 
                    superVar,V: ^Variant
                 do (* we should only propagateToSuper if super has
                     * virtual Objects as in the variant
                     *)
                    'PropagateToSuper:A:'->cd.comment;
                    (if true or (super[] <> none) then           
                        'PropagateToSuper:B:'->cd.comment;
                        (if super.ATd[] = none then
                            cd.com(#do 'super.ATd is none' -> TT #)
                         else
                            (if super.ATd## 
                             // DataItem## then 
                                (* understand this!? apparently in
                                 * X := V
                                 * 'Dataitem:'->putline; dopt -> putline;
                                 * '------------' ->putline;
                                 * father.father.dopt -> putline;
                                 *)
                             // Pattern## then
                                (*'\n** propagateToSuper: ' -> putline;*)
                                super.ATd[] -> ptn[];
                                (if ptn[] = objectDecl[] then
                                    (* do not propagate to Object *)
                                    (*'\n***OBS! No propagation to Object'->putline;*)
                                    leave propagateToSuper
                                if);
                                (*ptn.doPT -> printhead;*)
                                cd.com(#do 'PropagateToSuper:'->TT; ptn.sig.id[] ->TT #);
                                ptn.OG[] -> superOG[];
                                superOG.Qvariants.new -> superVar[];
                                (for i: var[top].top repeat
                                     (var[top].vDcl[i][],var[top].binding[i][]) 
                                       -> superVar.add
                                for);
                                (*superOG.Qvariants.topVarExists;*)
                                superOG.Qvariants.checkIfTopIsNew -> V[];
                                (if V[] = superVar[] then
                                    (*'superVar is new: top: ' -> puttext; 
                                    V.top -> putint; 
                                    ' super: ' -> puttext; super.doPt -> putline;*)
                                    (V.thisVarNo,none) -> superOG.Qalloc
                                 else
                                    (* 'var is not new' -> putline;*)
                                    V[] -> superVar[]                     
                                if);
                    if)if)if)
                 #);
               checkIfTopIsNew:
                 (# TVE: @boolean
                 do topVarExists -> TVE;
                    cd.com(#do 'checkIfTopIsNew:A:topVarExists:'->TT;
                             TVE->BB;' isEmpty: '->TT; isEmpty->BB #);
                    (if not TVE and not isEmpty then
                        cd.com(#do'checkIfTopIsNew:ISNEW'->TT #);
                        (* 'Added new variant' -> putline;*)
                        (* We should add this variant to the ObjTmpStack 
                         * But declared in vgenerator
                         * And we should do it for each superclass
                         *)
                        (if top > IS.QdescNo.range then
                            1 -> IS.QDescNo.extend;
                        if);
                        propagateToSuper
                    else
                        cd.com(#do'Variant already exists' -> TT#);
                    if)
                 exit var[top][]
                 #);
               isEmpty: booleanValue
                 (#
                 do (*not ((top > 0) and (var[1].top > 0)) -> value;*)
                    (if true then
                        top = 0 -> value
                     else
                        true -> value;
                        (for i: top repeat 
                             (if var[i].top > 0 then
                                 false -> value;
                                 leave isEmpty
                    if)for)if)
                 #);
               print:
                 (#
                 do (if (top > 0) and (var[1].top > 0) then 
                        '\n*** OG: ' -> puttext; OGid -> puttext;
                        ' NoOf variants:'-> puttext; top -> putint; newline;
                        (for i: top repeat
                             var[i].print
                    for)if)
                 #) ;
                printAll:
                 (#
                 do 'NoOf variants:'-> puttext; top -> putint; newline;
                    (for i: top repeat
                         var[i].print
                    for)
                 #);
            #);
       #);
     items::<
       (# PP:: 
            (# org: ^Items
            do ' descNo: ' -> lx.puttext; newDescNo -> lx.putint;
               ' origin: ' -> lx.puttext; 
               (*(origin[] -> org[]).newDescNo -> lx.putint*)
            #);
          objDescEq::
            (#
            do ' items:variants:newDescNo: ' -> puttext; newDescNo -> putint
            #);
          theDescNo:
            (# dNo: @integer
            do (if isEmpty and not super.hasVirtualArgs then
                   super.ATd.OG.IS.newDescNo -> dNo
                else
                   newDescNo -> dNo
               if)
            exit dNo
            #);
          newDescNo:
            (# dNo: @integer
            do (if false and isEmpty then
                   '**** Items:IS.isEmpty:' -> puttext;
                   encOG.doPT -> putline;
               if);
               (if thisVar[] <> none then
                   QdescNo[thisVar.thisVarNo] -> dNo
                else
                   QdescNo[1] -> dNo
               if)
            exit dNo 
            #);   

          OriginIsValue: BooleanValue
            (# org: ^Items
            enter org[] (* do we need an enter arg? 
                         * Is it always origin of this(Items)? *)
            do (if (org[] <> none)then
                   (if org.encOG.isValueObj then
                       (* '\n*** Origin is value: ' -> puttext;
                        org.encOG.doPT -> putline;
                        '-----' -> putline;
                        encOG.doPT -> puthead; newline;
                        *)
                       true -> value
                    else
                       (if superDesc[] <> none then
                           (* no enter arg here?? *)
                           superDesc.originIsValue -> value
               if)if)if);                       
               cd.com(#do 'OriginIsValue:' -> TT; value -> BB #)
            #);
          Qalloc:: 
            (# allocOrigin:
                 (# org: ^Items
                 do (if elimOrigin and noGlobals then
                     else
                        qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo];
                        origin[] -> org[];
                        (if (origin[] -> originIsValue) then
                            (if false then
                                '\n*** Origin is value: varNo:' -> puttext;
                                varNo -> putint;
                                ' qsize:' -> puttext; 
                                qSize[varNo] -> putint; newline;
                                org.encOG.doPT -> putline;
                                '-----' -> putline;
                                encOG.doPT -> putline; newline; 
                            if);
                            qsize[varNo] + 1 -> qsize[varNo];
                    if)if)
                 #);
               superNotImplOrSingularImpl: @boolean
            do (if varNo > noOfVar then
                   1 -> qsize.extend;
                   1 -> qOriginOff.extend;
                   noOfVar + 1 -> noOfVar
               if);
               cd.com
               (#do 'Items:Qalloc:objSize:'->TT;  objSize -> II; 
                  ' newDescNo:'->TT; newDescNo -> II; dopt->TQ;
               #);
               (if super.ATd[] <> none then
                   (* We have
                    *    OG = Super { ... }
                    * (1) super is a Name: normal case
                    * (2) Super is empty as in
                    *     V::< { ... } => super.isImplSuper == True
                    *     where V:< A{ ... } or V:< A
                    *     In bot cases A may be on a different block level
                    * (3) If V:< A{ ... } and not V:< A
                    *     => super.isSingularImplSuper == True
                    *        And thus on the same block level
                    * 
                    *)
                   cd.com(#do 'Items:Qalloc:super:' -> TT; super.dopt -> TQ;
                            ':super:size:' -> TT; superDesc.qsize[varNo] -> II;
                            ':noGlobalsInSuper:' -> TT; noGlobalsInSuper -> BB
                         #);

                   superDesc.qsize[varNo] -> qsize[varNo];
                   (if super.isImplSuper then
                       super.isSingularImplSuper 
                         -> superNotImplOrSingularImpl
                    else
                       true -> superNotImplOrSingularImpl
                   if);
                   (if super.isThisBlockLevel and superNotImplOrSingularImpl
                      (* and (not super.isImplSuper) 
                       and (not super.isSingularImplSuper)*)
                       then
                       (if elimOrigin and noGlobalsInSuper and not noGlobals then
                           (* This conditiona has to be checked! 
                            * Added not NoGlobals. Old comment below: *)
                           (* this looks wrong! Only if noGlobals = false ? *)
                           qsize[varNo] + 1 -> qsize[varNo] -> qOriginOff[varNo]
                        else
                           superDesc.qOriginOff[varNo] -> qOriginOff[varNo]
                       if)
                    else
                       allocOrigin
                   if);
                   cd.com
                   (# do 'Items:Qalloc:super:B:objSize:'->TT;  objSize -> II;
                      'originOff:'->TT; qOriginOff[varNo] -> II;
                   #);
                else
                   allocOrigin;
                   cd.com
                   (# do 'Items:Qalloc:Super:C:objSize:'->TT;  objSize -> II;
                      'originOff:'->TT; qOriginOff[varNo] -> II;
                   #);                   
               if);
               (if false and encOG.isBasicValue 
                   and isPrimitive
                   and (primNo <> value_prim)
                   then
                   cd.com
                   (#
                   do 'Items:Alloc:isBasicValue:' -> TT;
                      (if sig[] <> none then sig.dopt -> TQ if);
                      ':qsize:'->TT; qsize[1] -> II; 
                      qsize[varNo] + 1 -> qsize[varNo];
                      ':size:' -> TT; objSize -> II;
                      ':qsize:'->TT; qsize[1] -> II; 
                   #)
               if);
               labelHandler.init; 
               restartLab.new;
               leaveLab.new;
               (if sig[] <> none then
                   (varNo,this(items)[]) -> sig.Qalloc
               if);
               scanSons(#do (varNo,this(items)[]) -> current.Qalloc #);
               cd.com(#do 'Items:Qalloc:END:objSize:'->TT;
                        qsize[varNo] -> II;
                     ' newDescNo:'->TT; newDescNo -> II;  dopt->TQ;#);
            #);
          newOriginOff: 
            (# orgOff: @integer
            do qOriginOff[1] -> orgOff
            exit orgOff
            #);

          qOriginOff: [1] @integer;
          restartLab,leaveLab: @LabelHandler.label;  
          
          clear::< (# do 0 -> noOfVar -> qsize[1]; none -> thisVar[];  inner #);
          thisVar: ^Variant;
          noOfVar: @integer;
       #);
     Pattern::<
       (# Qalloc:: 
            (# 
            do cd.com(#do 'Pattern:Qalloc:'->TT; sig.id[] ->TT;  #);
               (if true 
                // isPrimitive then                   
                   (if OG.IS.newDescNo = 0 then
                       (*(varNo,IT[]) -> OG.Qalloc;*)
                       (* more stuff in checker:ptn:alloc *)
                   if);
                   
                   (if IT[] <> none then
                       (*'descNo:' -> puttext; IT.newDescNo -> putint; newline*)
                   if)
                // OG.isBasicValue then   
                   (if false then 
                       '\n*** pattern:qalloc:SimpleValue: ' -> putline;
                       doPT -> printHead;
                   if);
                   (if OG.IS.newDescNo = 0 then
                      (* (varNo,IT[]) -> OG.Qalloc*)
                   if); 
                else
                   cd.com(#do 'Pattern:Qalloc:B:'->TT; sig.id[] ->TT #);
                   (if ptnKind
                    // plainPtn then                 
                    // virtualPtn then
                       (* Is theere a more genral way to handle this *)
                       (if not OG.hasItems  then
                           (if (OG.super.ATd[] <> none) and ((OG.super.desc).newDescNo = 0) then
                               cd.com(#
                                     do '(OG.super.desc).newDescNo = 0' ->TT
                                     #);
                               (# ptn: ^Pattern
                               do OG.super.ATd[] -> ptn[];
                                  (1,none) -> ptn.OG.Qalloc;
                                  cd.com(#
                                        do 'Pattern:qalloc:super:descNo:'->TT;
                                           (OG.super.desc).newDescNo -> II;
                                           doPt ->TT
                                        #);
                               #);
                       if)if)
                    // furtherPtn // finalPtn then                           
                   if)
               if)
            #);
          new_descNo:< IntegerValue
            (# ptn: ^Pattern
            do (if OG.IS.isEmpty then
                   (if (OG.super.ATd[] -> ptn[]) <> none then 
                       ptn.new_descNo -> value
                   if)
                else
                   OG.IS.newDescNo -> value
               if)
            #);          
          new_size:< IntegerValue
            (# ptn: ^Pattern
            do cd.com(#do 'new_size:A: '->TT; isChecked -> BB; ' ' ->TT;dopt->TQ; #);
               (if OG.IS.isEmpty then
                   (if (OG.super.ATd[] -> ptn[]) <> none then 
                       ptn.new_size -> value;
                       cd.com(#do 'new_size:B:'->TT; value->II; 
                                ' objSize: ' -> TT;
                                ptn.OG.IS.ObjSize -> II;
                                ' newDescNo: '->TT; ptn.OG.IS.newDescNo -> II #);
                   if)
                else
                   OG.IS.qsize[1(*OG.IS.thisVar.thisVarNo*)] -> value;
                   cd.com(#do 'new_size:C:'->TT; value->II; 
                            ' varNo:' -> TT; 
                            OG.IS.qsize[1] -> II; 
                            ' varNo:' -> TT; OG.IS.noOfVar -> II;
                            (*OG.IS.qsize[2] -> II;*)
                         #)
               if)
            #)
       #);
     Invocation::<
       (# Qalloc:: 
            (# 
            do cd.com(#do 'Invocation:Qalloc:' ->TT; dopt ->TQ #);
               scanSons
               (# E: ^Exp
               do current[] -> E[];
                  (varNo,IT[]) -> current.Qalloc;
                (*  (if E.args[]  <> none then
                      E.args.scanArgs(#do (1,none) -> current.Qalloc #)
                 if)*)
               #)
            #);
       #);
     ObjectInvocation::<
       (# Qalloc:: 
            (# 
            do cd.com(#do 'ObjectInvocation:Qalloc:' ->TT; dopt ->TQ #);
               scanSons
               (#do cd.com(#do current.label -> TT; ' ' -> TT;  
                             current.dopt -> TQ; #);
                  (varNo,IT[]) -> current.Qalloc 
               #) 
            #);
       #);
     IfThen::<
       (# Qalloc::
            (#
            do (if false then
                   '**** IfThen:Qalloc: ' -> puttext; dopt -> putline;
               if);
               (varNo,IT[]) -> cond.Qalloc;
               (varNo,IT[]) -> thenPart.Qalloc  
            #);
       #);
     IfThenElse::<
       (# Qalloc::
            (#
            do (if false then
                   '**** IfThenElse:Qalloc: ' -> puttext; dopt->putline;
               if);
               (varNo,IT[]) -> cond.Qalloc;
               (varNo,IT[]) -> thenPart.Qalloc;
               (varNo,IT[]) -> ElsePart.Qalloc;  
            #);
       #);
     BracketedExp::<
       (# Qalloc:: (# do (varNo,IT[]) -> IV.Qalloc #);
       #);
     Const::< (# #);
     CharObj::< (# #);
     StringObj::< 
       (# Qalloc:: 
            (# 
            do  scanSons(# do (varNo,IT[]) -> current.Qalloc #) #);
       #);
     Variant: SuperVariant
       (# thisVarNo: @integer;
          vDcl: [1]  ^Pattern; top: @integer;
          type: [1] @ integer;
          size: [1] @ integer;
          binding: [1] ^Pattern;
          PN: @integer; (* path to super with vDcl *)
          allocDone,genDone: @boolean;
          add:
            (# VD,BD: ^Pattern
            enter(VD[],BD[])
            do L:
                 (if true then
                     (for i: top repeat
                          (if VD[] = vDcl[i][]  then
                              (* already a binding of VD *)
                              (if BD[] <> binding[i][] then
                                  '\n*** inconsistent virtual binding' 
                                    -> putline
                          if)if);
                          leave L
                     for);
                     (if (top + 1 -> top) > vDcl.range then
                         vDcl.range -> vDcl.extend;
                         type.range -> type.extend;
                         size.range -> size.extend;
                         binding.range -> binding.extend; 
                     if);
                     VD[] -> vDcl[top][];
                     -1 -> type[top];
                     -1 -> size[top];
                     BD[] -> binding[top][]
                 if)
            #); 
          noMatch: booleanValue
            (* Currently we only distinguish a areference 
             * (real object) binding from a value binding like integer
             *)
            (# B1,B2: ^Pattern
            enter(B1[],B2[])
            do (* instead of integer_prim we must check if value-type *)
               (if (B1[] <> none) and (B2[] <> none) then
               (if B1.OG.primNo = integer_prim then
                   B2.OG.primNo <>  integer_prim -> value
                else
                   B2.OG.primNo = integer_prim -> value
               if)if)
            #);
          equal: booleanValue
            (# V: ^Variant
            enter V[]
            do (*'\nVariant: equal:top:' -> puttext; top -> putint; newline;*)
               (if top > 0 then
                  (* '\nVariant: equal: ' -> putline;
                   print;
                   '-----' -> putline;
                   V.print;
                   '=====top: '->puttext; top -> putint; ', V.top: ' -> puttext;
                   V.top -> putint; newline;*)
               if);
               (if (top = 0) and (V.top = 0) then
                   true -> value;
                   leave equal
               if);
               (for i: top repeat
                    (for j: V.top repeat
                         (if vDcl[i][] = V.vDcl[j][] then
                            (* '>>>' -> puttext; 
                             binding[i].dopt -> puttext; ' == ' -> puttext;
                             V.binding[j].dopt -> putline;*)
                             (if ((binding[i][],V.binding[j][])) -> noMatch 
                                 then
                                 (*' noMatch: ' ->putline;
                                 false -> value;*)
                                 leave equal
                              else
                                 (*' match'->putline*)
               if)if)for)for);
               true -> value
            #);
          print:
            (# head: @ 
                 (# done: @boolean 
                 do (if not done then
                        true -> done; 
                        (*'Variant:print:head:' -> putline;*)
                    if)
                 #);
            do (for i: top repeat
                    head;
                    vDcl[i].doPT -> puttext; ' :: ' -> puttext;
                    binding[i].doPT -> putline
               for)
            #);
       exit this(Variant)[]
       #);
     getObjectDesc:: 
       (# OG: ^ObjectGenerator
       do descNo -> QnewDesc.getOD -> OG[];
          OG.IS[] -> D[];
       #);     
     QnewDesc: @
       (# init: 
            (# 
            do 0 -> noOfDescs; (for i: OD.range repeat none -> OD[i][] for) 
            #);
          getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectGenerator; ptn: ^Pattern
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[]
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   '\n!!! newDesc:getOD:no repetitionDesc:'->putline;
                   (IndexedDecl[]->ptn[]).OG[] -> anODx[]
               if)
            exit anODx[]
            #);
          OD: [16] ^ObjectGenerator; 
          noOfDescs: @integer;
          anOD: ^ObjectGenerator;          
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that an OD has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     labelHandler: @
       (# labCount: @integer;
          label:
            (# labNo: @integer;
               new: (# do  labCount + 1 -> labCount -> labNo #);
            enter labNo
            exit labNo
            #);
          init: (# do 0 -> labCount #);
       #);
  do QNewDesc.init;
     
     inner
  #)
