ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qrestrictions';
---lib:attributes---
variants: restrictions
  (# traceEmbedding: @boolean; 
     Module::<
       (# Qalloc:: 
            (#
            do cTracer(#do 'Qalloc:module:'->TT; moduleName -> TT #);
               (if traceAlloc then
                   'Module:QALLOC: ' -> puttext; sig.dopt -> putline;
               if);
               (if IT[] <> none then (* IT is none if top module *)
                   (if not nameListInDcl then
                       IT.qsize[1] + 1 -> IT.qsize[1] -> qoff[1];
                   if);
                   cTracer(#do 'Module:alloc:off:'->TT; qOff[1]->II; dopt->TL#)
               if);
               (1,IT[]) -> sig.Qalloc;
               (* OG.Qalloc is called from generator *)
       #)#);
     ModuleItem::<
       (# Qalloc:: 
            (# 
            do cTracer(#do 'ModuleItem:Qalloc:' ->TT; doPT ->TL #); 
               (if isChecked then 
                   (if traceAlloc then
                       'ModuleItem:QALLOC: ' -> puttext; sig.dopt -> putline;
                   if);
                   (1,IT[]) -> MD.Qalloc;
                   (*MD.qOff[1] -> qOff[1]*)
       if)#)#);
     DataItem::<
       (# Qalloc:: 
            (# diSize: @integer
            do (if traceAlloc then
                   '**** DataItem:qalloc: ' -> puttext; dopt -> putheadN
               if);
               cTracer
               (#
               do 'dataitem:qalloc:'->TT; sig.id[] ->TQ; 
                  'isValue:'->TT;  isValue -> BB;
                  ' isPrimitive:' -> TT; OG.isPrimitive -> BB;
                  ' isValObj: ' -> TT; OG.isValueObj -> BB;
                  ' isBasicValue:' -> TT; isBasicValue -> BB
               #);
               (if (OG.primNo = String_prim) then
                   (if false then
                       '**** DataItem:qAlloc:got.String: ' -> puttext;
                       isValue->putBoolean; ' ' -> put; dopt -> putheadN;
                   if);
                   false -> isValue
               if);
               (if isValue or isBasicValue then
                   (* We must alloc and generate all patterns 
                    * and OGs to be embedded *)
                   (if true
                    // OG.primNo = this_prim then
                       1 -> diSize; (* is this just a hack? *)
                       (if false then
                           '!!!! BUM:'->dumpT; sig.dopt -> dumpT;
                           IT.objSize -> dumpI; IT.encOG.objSize -> dumpI;
                           dumpNL;
                       if)
                    // OG.isPrimitive // OG.isBasicValue then
                       (* isPrimitive should probaly be removed *)
                       (if (OG.primNo = float_prim) or OG.isFloat then
                           2 -> diSize
                        else
                           1 -> diSize
                       if)
                    // not OG.IS.isEmpty then
                       OG.IS.qsize[1] -> diSize;
                       cTracer(#do 'A:'->TT; diSize->II#);
                    else
                       (# ptn: ^pattern
                       do OG.super.ATd.asDecl -> ptn[];
                          (if ptn.OG.primNo = indexed_prim then
                              '**** indexed: ' -> puttext; dopt -> putline;
                              ptn.dopt -> puthead
                          if);
                          (if ptn.OG.IS.newDescNo = 0 then
                              (1,ptn.origin[]) -> ptn.OG.qAlloc;
                          if);
                          (if traceAlloc then
                              dopt -> putline; ptn.dopt -> putline
                          if);
                          ptn.new_size -> diSize;
                          cTracer
                          (#do 'B:'->TT; diSize->II; 'ptn:'->TT;ptn.dopt->TL #);
                          cTracer(#do'newDescNo:'->TT; ptn.OG.IS.newDescNo->II#)
                   #)if);

                   (if not nameListInDcL then
                       IT.qsize[1] + 1 -> qoff[1];
                       IT.qsize[1] + diSize -> IT.qsize[1];
                   if);
                   cTracer
                   (#do 'diSize:'->TT; diSize->II; 'IT.qSize:'->TT; 
                      IT.qsize[1]->II 
                   #);
                   (if traceEmbedding then
                       '*** DI:alloc:value:size:' -> puttext; diSize ->putint; 
                       ':off:'->puttext; qoff[1]->putint;' '->put;dopt->putline;
                   if)
                else
                   1 -> diSize;
                   (if not nameListInDcL then                   
                       IT.qsize[1] + diSize -> IT.qsize[1] -> qoff[1];
                   if);
                   cTracer(#do 'DI:Qalloc:off:'->TT; qOff[1]->II; dopt->TL#);
                   (if isConst then
                       (* For R: ref T, dont call T.Qalloc *)
                       (1,IT[]) -> OG.Qalloc
               if)if);
               diSize -> diXsize;
               (1,IT[]) -> sig.Qalloc;
               (* OG.Qalloc is called from qgenerator *)
            #);
          diXsize: @integer;
          objSize:: (#do OG.objSize -> value  #)
       #);
     NameDecl::<
       (# Qalloc::
            (# DI: ^DataItem;; diSize: @integer;
            do L:
                 (if (ATd[] <> none) then
                   (if (ATd.asDecl).isSuperDataItem then
                       (if (ATd.asDecl).isDataItem then
                           (ATd[]->DI[]).dixSize -> diSize
                        else
                           1 -> diSize
                       if);
                       (if false and ('BETA' -> T.equal) then
                           '**** NameDecl:Qalloc:A:'->dumpT; dopt->dumpT;
                           IT.qsize[1]->dumpI; 
                           off -> dumpI; dumpNL;
                       if);
                       IT.qsize[1] + 1 -> off;
                       IT.qsize[1] + diSize -> IT.qsize[1];
                       (if false and
                           (('BETA' -> T.equal)  or ('Beq' -> T.equal)) then
                           '**** NameDecl:Qalloc:B:'->dumpT;; 
                           dopt -> puthead; ' ' -> put;
                           IT.encOG.OGid -> dumpT; 
                           'off:' -> dumpT;
                           off -> dumpI; 'diSize:' -> dumpT;
                           diSize -> dumpI; 'IT.qSize:'->dumpT; 
                           IT.qsize[1] -> dumpI; IT.objSize -> dumpI;
                           IT.encOG.objSize -> dumpI;
                           'IT:'->dumpT; IT.encOG.OGid -> dumpTN;
                   if)if)
                  else
                     (if false then
                         '!!!! NameDecl:Qalloc:ATd is none: '->puttext;
                         dopt -> putline;
                         father.label -> puttext; ' '-> put;
                         father.father.father.label -> putline;
                         (* shall be done in AST after parsing *)
                     if);
                     father.father.father[] -> ATd[];
                     restart L
       if)#)#);
     NameList::<
       (# Qalloc::
            (#
            do (if traceAlloc then
                   '**** NameList:Qalloc:'->puttext; dopt -> putline;
               if);
               scan(#do (1,IT[]) -> current.Qalloc #)
       #)#);
     Signature::< 
       (# Qalloc:: 
            (# D: ^Decl
            do (if not isAllocated then
                   (if traceAlloc then
                       '**** Signature:Qalloc:'->puttext; dopt -> dumpTN
                   if);
                   IT.qsize[1] -> paramItems.qsize[1];
                   (1,IT[]) -> paramItems.Qalloc;
                   paramItems.qsize[1] -> IT.qsize[1];
                   true -> isAllocated;
            if)#);
          clear::< (# do false -> isAllocated #);
          isAllocated: @Boolean
       #);
      Arguments::<
       (# Qalloc:: 
            (# 
            do (if traceAlloc then
                    '**** Arguments:Qalloc: ' ->puttext; dopt -> putline
               if);
               scanSons
               (#
               do (if traceAlloc then
                      '**** Arg:Qalloc: ' ->puttext; current.label -> puttext;
                      ' ' -> put; current.dopt -> putline;
                  if);
                  (if current## // DataItem## then
                      (* hack due to parsing of new syntax:
                       *    + V: var Integer: { ... }
                       * Fix the parser!
                       *)
                      (1,IT[]) -> current.Qalloc
                   // ObjectDescriptor## then
                      (*'!!!! Arg:ptn:qalloc:'->dumpT; current.dopt->putline;*)
                      (1,IT[]) -> current.Qalloc
       if)#)#)#);
     AssignmentStatement::<
       (# Qalloc::
            (#
            do (if traceAlloc then
                   '**** AssignmentStatement:alloc:'->puttext; dopt -> putline
               if);
               (1,IT[]) -> left.Qalloc;
               (1,IT[]) -> right.Qalloc
            #);
       #);
     ObjectCall::<
       (# marked: @boolean;
          Qalloc:: 
            (# 
            do (if traceAlloc then
                   '**** ObjectCall:Qalloc:'->puttext; dopt -> puthead
               if);
               cTracer(#do 'OC:Qalloc:'->TT; dopt -> TQ; #);
               (1,none) -> super.Qalloc;
                '**** Qalloc:OC: ' -> puttext; OGid -> puttext; ' '-> put;
               marked -> putBoolean; newline;
               father.dopt -> puthead;               
            #);
          clear::< (# do false -> marked #)
       #);
     ObjectDescriptor::<
       (# marked: @boolean;
          Qalloc::
            (* Should be called when genClass for this OG is called *)
            (# E:^Exp; ptn: ^Pattern
            do (if traceAlloc then
                   '**** OG:Qalloc:'->dumpT; doPT -> putheadN;
                   '**   IT=none:'-> dumpT; IT[] = none -> dumpB;
                   dumpNL
               if);
               cTracer(#do 'OG:Qalloc:' -> TT;  dopt ->TL; 
                        'qDescno: ' -> TT; IS.QdescNo[1] -> II
                     #);

               (if IS.QdescNo[1] > 0 then
                   (* Must find out why Qalloc is called a second time
                    * Perhaps because we for R: ref T used to call T.Qalloc;
                    * For R: obj T, we still call T.Qalloc for all such R!
                    *)
                   (if false then
                       '!!!! Qalloc: IS.QdescNo[1] > 0 : ' -> puttext;
                       IS.QdescNo[1] -> putint; newline;
                       dopt -> putline;
                   if);
                   leave Qalloc
               if);
               cTracer(#do 'OG:Qalloc:A: ' -> TT; OGid -> TQ;
                        ' super: ' -> TT; super.dopt -> TL;
                        ' marked: '-> TT; marked -> BB; 
                        father.dopt -> TL; 
                        'super: ' -> TT; super.doPT -> TL
                     #);
               (1,none) -> super.Qalloc;
               (* super.Qalloc above may make the if below superflous?*)
               cTracer(#do 'IS.superDesc<>none: ' -> TT;
                        IS.superDesc[] <> none -> BB;
                        ' IS.superDesc.newDescNo: ' -> TT;
                        (if IS.superDesc[] <> none then
                            IS.superDesc.newDescNo -> II; 
                            IS.superDesc.objSize -> II;
                            IS.superDesc.dopt -> TL;
                            IS.superDesc.father.father.label->TT;
                            IS.superDesc.father.father.dopt->TL
                      if)#);
               (if (IS.superDesc[] <> none) 
                   and (IS.superDesc.newDescNo = 0) then
                   (* superDesc is always a pattern *)
                   IS.superDesc.father.father[] -> ptn[];
                   cTracer(#do'OG:Qalloc:SuperAlloc:'->TT;ptn.dopt->TL#);
                   
                   (if ptn[] <> objectDecl[] then
                       (1,none) -> ptn.OG.Qalloc;
               if)if);
               (* some addBinding in checker:OG:alloc *)
               (if (super.last -> E[]) <> none then
                   (if E.isEmpty then
                    else
                       (if (E[] <> none) and (E.ATd[] <> none) then 
                           cTracer(#do'OG:super: '->TT; E.ATd.dopt->TL #);
                           E[] -> (E.ATd.asDecl).handleArgs  
                           (* !!! Imply call of old newDesc below!? *)
               if)if)if);
               
               cTracer(#do 'OG:Qalloc:isObjectDesc: ' -> TT; 
                        isObjectDesc->BB;
                        ' isObjectDesc: ' -> TT; isObjectDesc->BB;
                        ' hasItems: ' -> TT; hasItems -> BB;
                     #);
               cTracer(#do
                        'super.hasVirtualArgs: ' -> TT;
                        super.hasVirtualArgs -> BB;
                        ' not super.isPrimitive: ' -> TT;
                        not super.hasVirtualArgs -> BB
                     #);
               cTracer
               (#do dopt -> TL; nl; 'super: ' -> TT; super.dopt -> TL; nl;
                  (if E[] <> none then 'E: ' -> TT; E.dopt -> TQ
               if)#);
               (if isObjectDesc then 
                   cTracer(#do 'OG:Qalloc:B:'->TT;  OGid->TQ;
                            'newDescNo:' -> TT; IS.newDescNo -> II;
                            'objSize:' -> TT; objSize -> II #);
                   
                   this(ObjectDescriptor)[] 
                     -> QnewDesc -> IS.QdescNo[1];
                   
                   cTracer(#do 'OG:isObjectDesc:NewDescNo:' ->TT; 
                            IS.QdescNo[1] -> II;
                            'IS.newDescNo:'->TT; IS.newDescNo -> II;
                            'objSize:' -> TT; objSize -> II;
                            '1:' ->TT; 1 -> II; IS.dopt ->TL #);
                   (1,IT[]) -> IS.Qalloc ;
                   cTracer(#do 'IS.newDescNo:'->TT; IS.newDescNo -> II; 
                            'IS.objSize:' -> TT; objSize -> II; 
                            IS.dopt ->TL #);
               if);
               cTracer(#do 'OG:Qalloc:end: IS.newDescNo: ' -> TT;
                        IS.newDescNo -> II; doPT -> TL #);
            #);
          reAlloc:
            (# org: ^Items
            do cTracer
               (#do 'OG:reAlloc:'->TT; 'descNo:'->TT; IS.descNo -> II;
                  (origin[]->org[]).encOG.primno -> II; doPT -> TL
               #);
               (if ((origin[]->org[]).encOG.primNo = String_prim) then
                   cTracer(#do 'OG:reAlloc:String:'->TT; #);
                   IS.scanAllDecls(#do 0 -> currentDcl.qOff[1] #);
                   1 -> IS.qSize[1]; (* origin *)
                   IS.scanAllDecls
                   (#
                   do (if currentDcl.OG.primNo = this_prim then
                          cTracer(#do   'currentDcl:this:' -> TT#);
                          IS.qsize[1] + 1 -> currentDcl.qoff[1];
                          IS.qsize[1] + 1 -> IS.qsize[1];
                       else
                          (1,IS[]) -> currentDcl.Qalloc;
                      if);
                      cTracer
                      (#do 'reAllocatedOff:'->TT; currentDcl.sig.dopt->TQ; 
                         currentDcl.qoff[1]->II
                   #)#)
                else
                   (if IS.superDesc[] = none then
                       (if (origin[]->org[]).encOG.primno = String_prim then
                           (* remove - is handled in then-part *)
                           (* String is a value obj, but treated as a reference
                            * The size of origin is thus 1 *)
                           1 -> IS.qSize[1];
                           '!! GotString'->putline;
                        else
                           (* Other value objects: size of origin = 3 *)
                           3 -> IS.qSize[1]; 
                           (if false then
                               '**   setqSize ='->dumpT; IS.qSize[1]->dumpI;
                               dopt -> putheadN;
                               '**   IS:'-> dumpT; IS.dopt -> putHeadN
                       if)if)
                    else
                       IS.superDesc.encOG.reAlloc;
                       IS.superDesc.qSize[1] -> IS.qSize[1];
                       (if (origin[]->org[]).encOG.primno = String_prim then
                           1 -> IS.qSize[1];
                       if);
                       (if false then
                           '**   withSuper:qSize:'->dumpT; IS.qsize[1]->dumpI;
                           dumpNL
                   if)if);
                   IS.scanDecls
                   (#
                   do (*'**   clear:'->dumpT; currentDcl.dopt -> dumpTN*)
                      0 -> (currentDcl.asDecl).qOff[1];
                      false -> currentDcl.sig.isAllocated
                   #);
                   IS.scanDecls
                   (#
                   do (if nameListInDcl then 
                          (1,IS[]) -> (currentDcl.asDecl).Qalloc;
                       else                          
                          (1,IS[]) -> currentDcl.Qalloc;
               if)#)if);
               (if false then
                   '**** newSize: '->puttext; IS.encOG.OGid -> dumpT;
                   IS.qSize[1]->dumpI;
                   IS.dopt -> putheadN;
                   IS.scanAllDecls
                   (#
                   do currentDcl.dopt -> putHead;  ' '->put; 
                      (if nameListInDcl then
                          currentDcl.sig.names.scan(#do current.off -> dumpI #);
                          dumpTN
                       else
                          currentDcl.qOff[1]  -> putint; newline
            if)#)if)#);          
          clear::<
            (#
            do false -> marked;
               inner
            #);
       #);
     items::<
       (# objDescEq::
            (#
            do ' items:objDescEq:newDescNo: ' -> puttext; newDescNo -> putint
            #);
          theDescNo:
            (# dNo: @integer
            do (if isEmpty and not super.hasVirtualArgs then
                   (super.ATd.asDecl).OG.IS.newDescNo -> dNo
                else
                   newDescNo -> dNo
               if)
            exit dNo
            #);
          newDescNo:
            (# dNo: @integer
            do (if false and isEmpty then
                   '**** Items:IS.isEmpty:' -> puttext;
                   encOG.doPT -> putline;
               if);
               QdescNo[1] -> dNo
            exit dNo 
            #);   
          OriginIsValue: BooleanValue
            (# org: ^Items
            enter org[] (* do we need an enter arg? 
                         * Is it always origin of this(Items)? *)
            do (if (org[] <> none)then
                   (if org.encOG.primNo = String_prim then
                       leave OriginISValue
                   if);
                   (if org.encOG.isValueObj then
                       true -> value
                    else
                       (if superDesc[] <> none then
                           (* No enter arg here!? 
                            * statement below is thus just skip!?
                            * Perhaps org.encOG.isValueObj above,
                            * handles a possible super?*)
                           superDesc.originIsValue -> value
            if)if)if)#);
          Qalloc:: 
            (# allocOrigin:
                 (# org: ^Items; N: ^Node
                 do (if globalRestrictionsInMain and not inVirtualptn then
                        (if false then
                            '!!! Qalloc: globalRestrictionsInMain:'-> puttext;
                            encOG.father.label -> dumpT;
                            (encOG.father[]->N[]).isPattern -> putBoolean;
                            encOG.dopt  -> putheadN;
                        if)
                     else
                        qsize[1] + 1 -> qsize[1] -> qOriginOff[1];
                        origin[] -> org[]; 
                        (if (origin[] -> originIsValue) then
                            qsize[1] + 2 -> qsize[1];
                 if)if)#);
               isVirtualObject: booleanValue
                 (# P:^Pattern
                 do (if (super.ATd.asDecl).isPattern then (* should be *)
                        super.ATd.asDecl -> P[];
                        (if P.ptnKind <> plainPtn then (* virtual *)
                            (if P.OG.IS.isEmpty then (* P = V :< Q *)
                                P.OG.super.ATd.asDecl = objectDecl[] -> value
                 if)if)if)#);                     
               superNotImplOrSingularImpl: @boolean
            do (if traceALLOC THEN
                   '**** Items:Qalloc: ' -> puttext; dopt -> putheadN
               if);
               cTracer
               (#do 'Items:Qalloc:objSize:'->TT;  objSize -> II; 
                  ' newDescNo:'->TT; newDescNo -> II; dopt->TL
               #);
               (if isArgs then
                  (* '**** isArgs:'->dumpT; dopt -> dumpTN;*)
               if);
               (if not isArgs then
                   (if (super.ATd[] <> none) then
                       (* We have
                        *    OG = Super { ... }
                        * (1) super is a Name: normal case
                        * (2) Super is empty as in
                        *     V::< { ... } => super.isImplSuper == True
                        *     where V:< A{ ... } or V:< A
                        *     In bot cases A may be on a different block level
                        * (3) If V:< A{ ... } and not V:< A
                        *     => super.isSingularImplSuper == True
                        *        And thus on the same block level
                        * 
                        *)
                       cTracer(#do 'Items:Qalloc:super:' -> TT; super.dopt ->TL;
                                'size:' -> TT; superDesc.qsize[1] -> II;
                                encOG.OGid -> TQ; #);
                       superDesc.qsize[1] -> qsize[1];
                       (if super.isImplSuper then
                           super.isSingularImplSuper 
                             -> superNotImplOrSingularImpl
                        else
                           true -> superNotImplOrSingularImpl
                       if);
                       cTracer(#do 'super.isThisBlockLevel:'-> TT;
                                super.isThisBlockLevel -> BB;
                                'superNotImplOrSingularImpl:' -> TT; 
                                superNotImplOrSingularImpl -> BB;
                             #);                   
                       (if super.isThisBlockLevel and superNotImplOrSingularImpl
                           (* and (not super.isImplSuper) 
                            and (not super.isSingularImplSuper)*)
                           then
                           (if globalRestrictionsInSuper
                               and not globalRestrictionsInMain then
                               (* This conditiona has to be checked! 
                                * Added not NoGlobalsInMain. 
                                * Old comment below: *)
                               (* this looks wrong! 
                                * Only if globalRestrictionsMain = false ? *)
                               qsize[1] + 1 -> qsize[1] -> qOriginOff[1]
                            else
                               superDesc.qOriginOff[1] -> qOriginOff[1]
                           if)
                        else
                           (if isVirtualObject then
                               (if false then
                                   '**** super isVirtualObject: ' -> puttext;
                                   encOG.OGid -> putline;
                                   encOG.father.dopt -> putline; '---'->putline;
                                   super.atd.dopt -> puthead;
                               if);
                               superDesc.qOriginOff[1] -> qOriginOff[1];
                               (if false then
                                   'newOriginOff: ' -> puttext; 
                                   newOriginOff -> putint; ' ' -> put;
                                   qOriginOff[1] -> putint; ' ' -> put; 
                                   1 -> putint; newline
                               if)
                            else
                               allocOrigin
                       if)if);
                       cTracer
                       (# do 'Items:Qalloc:super:B:objSize:'->TT;  objSize ->II;
                          'originOff:'->TT; qOriginOff[1] -> II;
                       #)
                    else
                       allocOrigin;
                       cTracer
                       (# do 'Items:Qalloc:Super:C:objSize:'->TT;  objSize ->II;
                          'originOff:'->TT; qOriginOff[1] -> II;
               #)if)if);
               (if false and encOG.isBasicValue and isPrimitive
                   and (primNo <> value_prim)
                   then
                   cTracer
                   (#
                   do 'Items:Alloc:isBasicValue:' -> TT;
                      (if sig[] <> none then sig.dopt -> TQ if);
                      ':qsize:'->TT; qsize[1] -> II; 
                      qsize[1] + 1 -> qsize[1]; (* !!! ??? *)
                      ':size:' -> TT; objSize -> II;
                      ':qsize:'->TT; qsize[1] -> II; 
                   #)
               if);
               (if not isArgs then
                   labelHandler.init; 
                   restartLab.new;
                   leaveLab.new;
               if);
               (if true or not nameListInDcl then
                   (if sig[] <> none then
                       (* why here?
                        * We dont allocate a pattern 
                        * its OG is allocated if used!
                        * This means we need to allocate its signature
                        * We might skip sig.Qalloc in dataItem and then
                        * do it here also for DataItem
                        *)
                       (if this(Items).origin[] <> none then
                           (* IT[] = none for BETAworld and we need not
                            * allocate address for BETAworld!
                            *)
                           (if 'Pattern' -> (sig.father.label).equalNCS then
                               (1,this(items)[]) -> sig.Qalloc
                            else
                               (1,this(Items).origin[]) -> sig.Qalloc;
                           if);
                        else
                           (if false then
                               '**** OG:sig:IT=none:'->dumpT;
                               sig.dopt -> putheadN;
                               '**   items:'->dumpT; 
                               this(Items).dopt -> putheadN;
                               '**   items:origin:'->dumpT; 
                               (if this(Items).origin[] <> none then
                                   this(Items).origin.dopt -> putheadN
                       if)if)if);
                       (*(1,this(items)[]) -> sig.Qalloc*)
               if)if);
               scanSons (#do (1,this(items)[]) -> current.Qalloc #);
               cTracer(#do 'Items:Qalloc:END:objSize:'->TT; qsize[1] -> II;
                        ' newDescNo:'->TT; newDescNo -> II;  dopt->TL #);
            #);
          newOriginOff:: 
            (# 
            do qOriginOff[1] -> value
            #);
          qOriginOff: [1] @integer;
          restartLab,leaveLab: @LabelHandler.label;  
          clear::< (# do 0 -> qsize[1]; inner #);
       #);
     Pattern::<
       (# Qalloc:: 
            (# allocStub:
                 (# P: ^Pattern; OGs: ^ObjectDescriptor; dNo: @integer; 
                    errs: ^Stream; T: ^text
                 do (*leave allocStub;*)
                    (if false then
                        '**** Qalloc:allocStub:' -> dumpT; sig.dopt->dumpT;
                        ' vdescNo: ' -> puttext; 
                        OG.vDescNo -> putint; newline;
                    if);
                    '' -> T[];
                    sig.dopt -> T.append;
                    ': { %id stub }' 
                      -> T.append
                      -> parseDeclText -> (errs[],P[]);
                    P.OG[] -> OGs[]; 
                    P.setUpOrigin;
                    P.check;
                    OGs[] -> QnewDesc -> dNo -> OGs.IS.QdescNo[1];
                    '$' -> OGs.sig.id.put;
                    dNo -> OGs.sig.id.putint;
                    dNo  -> OG.vDescNo;
                    (1,none) -> P.Qalloc;
                 #)
            do cTracer(#do 'Pattern:Qalloc:'->TT; sig.id[] ->TT #);
               (if traceAlloc then
                   '**** ptn:qalloc: ' -> puttext; sig.dopt -> puttext;
                   ' ' -> put; ptnKind -> putint;  ' ' -> put;
                   isprimitive -> putBoolean;  ' ' -> put;
                   OG.isBasicValue -> putboolean; newline;
               if);
               (if true 
                // isPrimitive then
                   (if OG.IS.newDescNo = 0 then
                       (*(1,IT[]) -> OG.Qalloc;*)
                       (* more stuff in checker:ptn:alloc *)
                   if);
                // OG.isBasicValue and not isVirtual then   
                   (if false then 
                       '\n*** pattern:qalloc:SimpleValue: ' -> putline;
                       doPT -> printHead;
                   if);
                   (if OG.IS.newDescNo = 0 then
                      (* (1,IT[]) -> OG.Qalloc*)
                   if); 
                else
                   cTracer(#do 'Pattern:Qalloc:B:'->TT; sig.id[] ->TT #);
                   (if ptnKind
                    // plainPtn then                 
                    // virtualPtn then
                       (* Is there a more general way to handle this *)
                       (if not OG.hasItems then
                           (if (OG.super.ATd[] <> none) 
                               and ((OG.super.theDesc).newDescNo = 0) then
                               cTracer(#do '(OG.super.theDesc).newDescNo = 0'->TT#);
                               (# ptn: ^Pattern
                               do OG.super.ATd.asDecl -> ptn[];
                                  (1,none) -> ptn.OG.Qalloc;
                                  cTracer
                                  (#do 'Pattern:qalloc:super:descNo:'->TT;
                                     (OG.super.theDesc).newDescNo->II; doPt->TT
                           #)#)if);
                           allocStub 
                       if)
                    // furtherPtn // finalPtn then 
                       (if not OG.hasItems then allocStub if)
            if)if)#);
          new_descNo:< IntegerValue
            (# ptn: ^Pattern
            do (if OG.IS.isEmpty then
                   (if (OG.super.ATd.asDecl -> ptn[]) <> none then 
                       ptn.new_descNo -> value
                   if)
                else
                   OG.IS.newDescNo -> value
            if)#);          
          new_size:< IntegerValue
            (# ptn: ^Pattern
            do cTracer(#do 'new_size:A:'->TT; isChecked->BB;' '->TT;dopt->TL #);
               (if OG.IS.isEmpty then
                   (if (OG.super.ATd.asDecl -> ptn[]) <> none then 
                       ptn.new_size -> value;
                       cTracer
                       (#do 'new_size:B:'->TT; value->II; 
                          ' objSize: ' -> TT; ptn.OG.IS.ObjSize -> II;
                          ' newDescNo: '->TT; ptn.OG.IS.newDescNo->II #);
                   if)
                else
                   OG.IS.qsize[1] -> value;
                   cTracer
                   (#do 'new_size:C:'->TT; value->II; 
                      ' qSize:' -> TT; OG.IS.qsize[1] -> II; 
       #)if)#)#);
     Invocation::<
       (# Qalloc:: 
            (# 
            do cTracer(#do 'Invocation:Qalloc:' ->TT; dopt ->TL #);
               scanSons
               (# E: ^Exp
               do current[] -> E[];
                  (1,IT[]) -> current.Qalloc;
       #)#)#);
     ObjectInvocation::<
       (# Qalloc:: 
            (# ptn: ^Pattern
            do (if traceAlloc then
                   '**** OI:Qalloc:'->dumpT; doPT->putheadN;
               if);
               cTracer(#do 'ObjectInvocation:Qalloc:' ->TT; dopt ->TQ; #);
               scanSons
               (#do cTracer(#do current.label -> TT; current.dopt -> TQ  #);
                  (1,IT[]) -> current.Qalloc 
               #);
               (if hasVirtualArgs then     
                   (if false then
                       'false OI:Qalloc:hasVirtualArgs:\n' -> puttext; 
                       dopt -> putline;
                   if);
                   ATd.asDecl -> ptn[];
                   ptn.scanArgs
                   (# OGx: ^ObjectDescriptor; argInx: @integer
                   do argInx + 1 -> argInx;
                      (if currentArg.isVirtual then
                          (if false then
                              '**   OI:Qalloc:got: ' -> puttext; 
                              currentArg.dopt -> putline;
                          if);
                          (*QnewDesc -> currentArg.OG.vDescNo*)
                          (*  it is actualArg that must be assigned vDescNo  *)
                          args.scanArgs
                          (# i: @integer
                          do i + 1 -> i;
                             (if argInx = i then
                                 (if false then
                                     '**** aArg: ' -> puttext; 
                                     current.label -> putline;
                                     current.dopt -> putline;
                                     '**   formalArg: ' -> putline;
                                     currentArg.dopt -> puthead;
                                     currentArg.OG.vDescNo -> putint; ' '->put;
                                     currentArg.OG.OGid -> Putline
                                 if);
                                 current[] -> OGx[];
                                 (if OGx.IS.isEmpty then
                                     OGx[] -> QnewDesc -> OGx.vDescNo;
                                     (if false then
                                         '**   setvDescNo: '->puttext;
                                         OGx.vDescNo -> putint; newline
       if)if)if)#)if)#)if)#)#);
     IfThen::<
       (# Qalloc::
            (#
            do (if false then
                   '**** IfThen:Qalloc: ' -> puttext; dopt -> putline;
               if);
               (1,IT[]) -> cond.Qalloc;
               (1,IT[]) -> thenPart.Qalloc  
       #)#);
     IfThenElse::<
       (# Qalloc::
            (#
            do (if false then
                   '**** IfThenElse:Qalloc: ' -> puttext; dopt->putline;
               if);
               (1,IT[]) -> cond.Qalloc;
               (1,IT[]) -> thenPart.Qalloc;
               (1,IT[]) -> ElsePart.Qalloc;  
       #)#);
     BinaryExp::<
       (# Qalloc:: 
            (# 
            do cTracer(#do 'BinaryExp:Qalloc:' ->TT; dopt ->TQ #);
               scanSons
               (# E: ^Node(*Exp*)
               do current[] -> E[];
                  (1,IT[]) -> current.Qalloc;
       #)#)#);
     UnaryExp::<
       (# Qalloc:: (# do (1,IT[]) -> trm.Qalloc #);
       #);
     BracketedExp::<
       (# Qalloc:: (# do (1,IT[]) -> IV.Qalloc #);
       #);
     Const::< (# #);
     CharObj::< (# #);
     StringObj::< 
       (# Qalloc:: 
            (# 
            do scanSons(# do (1,IT[]) -> current.Qalloc #) 
       #)#);
     Slot::<
       (# Qalloc::
            (#
            do (if traceSlots then
                   '**** Slot:Qalloc: ' -> puttext; id[] -> putline;
               if);
               slotItems.scanSons(#do (1,IT[]) -> current.Qalloc #);
       #)#);
     getObjectDesc:: 
       (# OG: ^ObjectDescriptor
       do descNo -> QnewDesc.getOD -> OG[];
          OG.IS[] -> D[];
       #);     
     QnewDesc: @
       (# init: 
            (# 
            do 0 -> noOfDescs; (for i: OD.range repeat none -> OD[i][] for) 
            #);
          getOD: 
            (* only used from minienv *)
            (# dNo: @integer; anODx: ^ObjectDescriptor; ptn: ^Pattern
            enter dNo 
            do (if dNo > 0 then 
                   OD[dNo][] -> anODx[];
                else
                   (* probably a valueRep - a hack *)
                   (* repetitionDesc[] -> anODx[]*)
                   (if false then
                       (* do we have a problem here? *)
                       '\n!!! newDesc:getOD:no repetitionDesc:'->putline;
                   if);
                   (IndexedDecl[]->ptn[]).OG[] -> anODx[]
               if);
            exit anODx[]
            #);
          OD: [16] ^ObjectDescriptor; 
          noOfDescs: @integer;
          anOD: ^ObjectDescriptor;          
       enter anOD[] (* Note: since newDesc is a static item,
                     * no enter-part as in genMain
                     * implies that anOD[] has the value from the previous call
                     *)
       do (if (noOfDescs + 1 -> noOfDescs) > OD.range then
              OD.range -> OD.extend
          if);
          anOD[] -> OD[noOfDescs][];
       exit noOfDescs
       #); 
     labelHandler: @
       (# labCount: @integer;
          label:
            (# labNo: @integer;
               new: (# do  labCount + 1 -> labCount -> labNo #);
            enter labNo
            exit labNo
            #);
          init: (# do 0 -> labCount #);
       #);
  do QNewDesc.init;
     inner
  #)
