ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qBetaAST';
INCLUDE 'qStdBetaLexer';
INCLUDE '~beta/sysutils/envstring';
INCLUDE '~beta/dependency/dependency';
INCLUDE '~beta/grammars/beta/betacfl';
INCLUDE '~beta/newmps/grammarinit';
--Lib:attributes--
doTrace: (# exit false #);
doTraceParser: (#exit false #);
parseStdBetaModule: StdBetaAst
  (# superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
       enter fileName[]
       do (path.append).copy -> pathToFN[];
          &StdBetaLexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          lex;
          INNER;
          inFile.close;
       #);
      mkFN:
       (# FN,currentDir,fullFN,BetaLib:  ^text;
       enter(FN[],currentDir[])
       do (if doTrace then
              '**** mkFN:'->dumpTN; FN[] -> dumpTN; currentDir[] -> dumpTN;
          if);
          (if '~beta/' ->((1,6) -> FN.sub).equal then
               '$(BETALIB)' -> expandEnvVar -> BetaLib[] ;
              (if betaLib[] = none then 
                  '!!!! Did not find BETALIB!'->putline 
               else
                  (if doTrace then
                      '**   BetaLib:'->dumpT; BetaLib[] -> dumpTN;
              if)if);          
              '/' -> BetaLib.append -> betaLib[];
              (7,FN.length) -> FN.sub -> BetaLib.append -> fullFN[];
           else
              FN[] -> (currentDir.copy).append -> fullFN[];
          if);
          (if not 
              ('.bet' -> ((fullFN.length - 3,fullFN.length)->fullFN.sub).equal)
              then 
              '.bet' -> fullFN.append
          if);
          (if doTrace then
              '**   fullFN:'->dumpT; fullFN[] -> dumpTN
          if)
       exit fullFN[]
       #);
     mkCurrentDir:
       (# fullPath, currentDir: ^text; lastSlash: @integer
       enter fullPath[]
       do fullPath.scanAll
          (# i: @integer
          do i + 1 -> i; 
             (if ch = '/' then
                 i -> lastSlash
          if)#);
          (1,lastSlash) -> fullPath.sub -> currentDir[];
          (if doTrace then
              '**** mkCurrentDir:' -> dumpTN; fullPath[]->dumpTN;
              currentDir[] -> dumpTN;
          if)
       exit currentDir[]
       #);     
     openBetaModule:
       (# moduleName,currentDir,StdPath,fragPath: ^text;
          FD: ^FragmentDir;
          NM: ^BetaName;
          BM: ^SimpleBetaModule;
          BPS: ^BetaProperties; frags: ^BetaFragments
       enter(moduleName[],currentDir[])
       do 
          (moduleName[],currentDir[]) -> mkFN -> fragPath[];
          fragPath[] -> mkCurrentDir -> currentDir[];
          fragPath[] -> SimpleBetaModule -> BM[];
          (if doTrace then BM.doPT -> dumpTN if);
          BM.filePath[] -> doParse -> (BPS[],frags[]); 
          (if doTraceParser then
              BPS.doPT -> dumpTN;
              frags.doPT -> dumpTN
          if);
          (if doTrace then
              '**** handle Beta properties'->dumpTN;
              BPS.scanSons
              (# 
              do current.scanSons
                 (# n: @integer; propN,propArg: ^text; 
                    isOrigin,isInclude: @boolean
                 do n + 1 -> n;
                    (if n
                     // 1 then
                        current.dopt -> propN[];
                        (if true
                         // 'ORIGIN' -> propN.equalNCS then
                            true -> isOrigin
                         // 'INCLUDE' -> propN.equalNCS then
                            true -> isInclude
                        if)
                     else
                        current.dopt -> propArg[];
                        (if true 
                         // isOrigin then
                            '**** handle origin:'->dumpTN;
                            false -> isOrigin
                         // isInclude then
                            '**** handle include:'->dumpTN;
                        if);
                        (propArg[],currentDir[])
                          -> mkFN 
                          -> doParse (* probably openBetaModule here *)
                          -> (BPS[],frags[]); 
                        (if doTraceParser then
                            BPS.doPT -> dumpTN;
                            frags.doPT -> dumpTN
       if)if)#)#)if)#);
     doParse: superParser
        (# BPS: ^BetaProperties;  frags: ^BetaFragments
        do (if doTrace then
               '**** doParse:' -> dumpT; fileName[] -> dumpTN;
           if);
           pProperties -> BPS[];
           (if doTrace then
               'after:pProperties'->trace;             
               pFragments -> frags[];     
               (if false then
                   'after:pFragments:'->trace;
                   BPS.dopt -> putline;
                   frags.doPT->putline;
               if);
               (if false then frags.setUpOrigin; if)
           if);
        exit(BPS[],frags[])
        #);
     pProperties:
       (# BPS:  ^BetaProperties; prop: ^BetaProperty; symb: ^Text;  
          gotOne: @boolean
       do 'pProperties'->trace;
          BetaProperties -> BPS[];
          L:
            (if lex.symb
             // lex.symbols.idf  then
                lex.sym[] -> symb[];
                lex;
                symb[] -> pProperty -> prop[] -> BPS.append;
                (if lex.symb = lex.symbols.semicolon then 
                    true -> gotOne;
                    lex; 
                    'pProperties:repeat'->trace; 
                    restart L
                if)
             // lex.symbols.frag then (* no properties *)
             // lex.symbols.eos then (* empty file *)
             else
                (if not gotOne then SyntaxError if)
            if)
       exit BPS[]
       #);
     
     pProperty:
       (# symb: ^Text;  prop: ^BetaProperty;
       enter symb[]
       do 'pProperty'->trace;
          BetaProperty -> prop[]; symb.copy -> BetaName -> prop.append;
          L:
            (if lex.symb
             // lex.symbols.textSy then
                lex.sym[] -> BetaString -> prop.append;
                lex;
                restart L
             // lex.symbols.charSy then
                lex.sym.copy -> BetaName -> prop.append;
                lex;
                restart L
             // lex.symbols.idf 

             // lex.symbols.const then
                lex.sym.copy -> BetaName -> prop.append;
                lex;
                restart L
            if);
          'pProperty:end'->trace
       exit prop[]
       #);

     pFragments: 
       (# frags: ^BetaFragments
       do 'pFragments'->trace;
          BetaFragments -> frags[];
          (if lex.symb = lex.symbols.frag then 
              lex;
              pFragment -> frags.append
          if);
          'pFragments:end'->trace
       exit frags[]
       #);
     pFragment:
       (# frag: ^BetaFragment; theName,cat,language: ^BetaLexem;
       do 'pFragment'->trace; 
          loop:
            (if lex.symb = lex.symbols.idf then
                lex.sym.copy -> BetaName -> theName[];
                lex; 
                'pFragment:idf'->trace; 
                (if lex.symb = lex.symbols.colon then
                    lex;
                    'pFragment:colon'->trace; 
                    (if lex.symb = lex.symbols.idf then
                        'pFragment:idf:colon:idf'->trace; 
                        lex.sym.copy -> BetaName -> cat[];
                        lex;
                        (if lex.symb = lex.symbols.colon then
                            'pFragment:idf:colon:idf:colon'->trace; 
                            lex;
                            (if lex.symb = lex.symbols.idf then 
                                (* --- x:objectDesc:beta --- *)
                                lex.sym.copy -> BetaName -> language[];
                                lex;                          
                             else
                                SyntaxError
                            if)
                         else
                            'pFragment:idf:colon:BETA'->trace; 
                            'BETA'-> BetaName -> language[];
                        if);
                        (if lex.symb = lex.symbols.frag then
                            'pFragment:frag:last'->trace; 
                            lex;
                            (if true 
                             // 'descriptor' -> cat.T.equalNCS 
                             // 'descriptorForm' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> pObjDescFrag -> frag[]
                             // 'attributes' -> cat.T.equalNCS 
                             // 'attribute' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> pAttFrag
                                  -> frag[]
                             // 'doPart' -> cat.T.equalNCS then 
                                (theName[],cat[],language[]) 
                                  -> doPartFrag -> frag[]
                             // 'mainPart' -> cat.T.equalNCS then
                                '\n!!!! MainPart category is not implemented' 
                                  -> putline
                             else
                                'Unknown category: ' -> puttext; 
                                cat.T[] -> putline
                            if);
                            (if lex.symb = lex.symbols.frag then 
                                lex;
                                restart loop
                            if);
                         else
                            SyntaxError
                        if)
                     else
                        SyntaxError
                    if)
                 else
                    SyntaxError
                if)
             else
                SyntaxError
            if)
       exit frag[]
       #);
     pObjDescFrag:
       (# theName,cat,language: ^BetaName; ODF: ^ObjDescFrag;
       enter(theName[],cat[],language[])
       do 'pObjDescFrag'->trace;
          (theName[],cat[],language[]) -> ObjDescFrag -> ODF[];
          '' -> BetaName ->  AttributeDenotation -> PatternDen -> pObjectDesc -> ODF.OD[] -> ODF.append
       exit ODF[]
       #);
     pAttFrag:
       (# theName,cat,language: ^BetaName; frag: ^AttFrag;
       enter(theName[],cat[],language[])
       do 'pAttFrag'->trace;
          (theName[],cat[],language[]) -> AttFrag -> frag[];
          (*Attributes -> frag.att[];*)
          pAttributes -> frag.att[] -> frag.append
       exit frag[]
       #);
     pAttributes:
       (# theName,cat,language: ^BetaName; att: ^Attributes;
       enter(theName[],cat[],language[])
       do 'pAttributes'->trace;
          Attributes -> att[];
          Loop:
            (#
            do
               (if lex.symb 
                // lex.symbols.semicolon then
                   lex;
                   restart Loop
                // lex.symbols.nonTbegin then
                   lex;
                   pSlot;
                   'pAttributes:got:SLOT:MUST:FIX'->trace;
                   
                   restart Loop
                // lex.symbols.doSy
                // lex.symbols.end
                // lex.symbols.enterSy
                // lex.symbols.exitSy 
                // lex.symbols.frag
                // lex.symbols.eos (* obs ok if attributes slot not in objDesc *) then 
                   leave Loop 
                else
                   pBetaDecl -> att.append;
                   restart Loop
               if)               
            #)
       exit att[]
       #);
     pActionPart:
       (# acp: ^ActionPart; 
          enterP: ^EnterPart; exitP: ^ExitPart; imps: ^Imperatives; slt: ^Slot;
       do 'pActionPart'->trace;
          pEnterPart -> enterP[];
          Imperatives -> imps[];
          (if lex.symb 
           // lex.symbols.doSy then
              lex;
              pImperatives -> imps[]
           // lex.symbols.nonTbegin then
              lex;
              'pActionPart:slot'->trace;
              pSlot -> slt[] (* we should mark that this is a slot *)
          if);
          pExitPart -> exitP[];
          (enterP[],imps[],exitP[]) -> ActionPart -> acp[];
          'pActionPart:end'->trace;
       exit acp[]
       #);
     pEnterPart:
       (# enterP: ^EnterPart; eval: ^Evaluation; 
       do 'pEnterPart'->trace;
          (if lex.symb = lex.symbols.enterSy then
              lex; 
              pEvaluation -> eval[];
              'pEnterPart:after:pEval'->trace;              
           else
              Evaluation -> eval[]
          if);
          eval[] -> EnterPart -> enterP[]
       exit enterP[]
       #);
     pImperatives:
       (# imps: ^Imperatives;
       do 'pImperatives'->trace;
          Imperatives -> imps[];
          Loop:
            (#
            do (if lex.symb 
                // lex.symbols.semiColon then (* empty imp *) lex; restart Loop 
                // lex.symbols.nonTbegin then
                   lex;
                   pSlot
                // lex.symbols.end 
                // lex.symbols.ifSy
                // lex.symbols.alternative
                // lex.symbols.elseSy
                // lex.symbols.forSy 
                // lex.symbols.exitSy 
                // lex.symbols.eos 
                // lex.symbols.frag then leave Loop 
                   (* perhaps we need to test positive for symbols that may
                    * begin en imperative
                    *)
                else
                   pImperative -> imps.Append
               if);
               restart Loop
            #)
       exit imps[]
       #);
     pImperative:
       (# imp: ^Node
       do 'pImperative'->trace;
          (if lex.symb
           // lex.symbols.leftBrack then
              (if lex.nextIsForOrIf then
                  lex;
                  (if lex.symb
                   // lex.symbols.forSy then
                      lex;
                      pForImp -> imp[]
                   // lex.symbols.ifSy then
                      lex;
                      pIfImp -> imp[]
                  if)
               else
                  pEvaluation -> imp[];
              if)
           // lex.symbols.leaveSy then
              lex; 
              pLeaveImp -> imp[]
           // lex.symbols.restartSy then
              lex; 
              pRestartImp -> imp[]
              (* LabelledImp?
               * L: 3 -> a;
               * A -> B;
               *)
           // lex.symbols.innerSy then
              lex;
              pInnerImp -> imp[]
           // lex.symbols.idf then
              'pImperative:idf'->trace;
              (if lex.peek = ':' then
                  pLabelledImp -> imp[];
               else
                  pEvaluation -> imp[];
              if)
           else 
              pEvaluation -> imp[];
          if); 
          'pImperative:end'->trace;
       exit imp[]
       #);
     pExitPart:
       (# exitP: ^ExitPart; eval: ^Evaluation; 
       do 'pExitPart'->trace; 
          (if lex.symb = lex.symbols.exitSy then
              lex; 
              pEvaluation -> eval[]
           else
              Evaluation -> eval[]
          if);
          eval[] -> ExitPart -> exitP[]
       exit exitP[]
       #);
     pSlot:
       (# slt: ^Slot; name,cat: ^Text;
       do 'pSlot'->trace;
          (if lex.symb = lex.symbols.idf then
              (* must be SLOT *)
              lex;
              'pSlot:A'->trace;
              (if lex.symb = lex.symbols.idf then
                  lex.sym[] -> name[];
                  lex;
                  'pSlot:B'->trace;
                  (if lex.symb = lex.symbols.colon then
                      lex;
                      (if lex.symb = lex.symbols.idf then
                          (* descriptor, attributes, dopart, etc *)
                          lex.sym[] -> cat[];
                          lex;
                          (if lex.symb = lex.symbols.nontEnd then
                              lex
                           else
                              syntaxError
                          if)
                       else
                          syntaxerror
                      if)
                   else
                      syntaxError
                  if)
               else
                  syntaxError
              if)
           else
              syntaxError
          if);
          (name[],cat[]) -> Slot -> slt[]
       exit slt[]
       #);
     pForImp:
       (# fImp: ^ForImp; inx: ^BetaNameDecl (*Lexem*);ND: ^BetaNameDecl;
          inxItem: ^ForImpItem; rangee: ^Evaluation; imps: ^Imperatives;
       do 'pForImp'->trace;
          (if lex.nextISColon then
              pNameDecl -> ND[]; true -> ND.isForInx;
              (if lex.symb = lex.symbols.colon then
                  lex
              if)
           else
              (# 
              do 
                 '-' -> BetaLexem -> BetaNameDecl -> ND[];
                 true -> ND.isForInx;
              #);
          if);
          ND[] -> inx[];
          pevaluation -> rangee[];
          pForImpItem -> InxItem[];
          (if lex.symb = lex.symbols.repeatSy then
              lex; 
              'pForImp:repeat'->trace;
              pImperatives -> imps[];
              'pForImp:after:pImperatives'->trace;
              (if lex.symb = lex.symbols.forSy then
                  lex;
                  (if lex.symb = lex.symbols.rightBrack then
                      lex;
                   else
                      441 -> SyntaxError
                  if)
               else
                  442 -> SyntaxError
              if)
           else
              443 -> SyntaxError
          if);
          (inx[],inxItem[],rangee[],imps[]) -> ForImp -> fImp[]
       exit fImp[]
       #);
     pForImpItem:
       (# fi: ^ForImpItem
       do ForImpItem -> fi[]
       exit fi[]
       #);
     pIfImp:
       (# iImp: ^IfImp; Eval: ^Evaluation;
          thenPart,elsePart: ^Imperatives; alt: ^Alternatives
       do 'pIfImp' -> trace;
          pEvaluation -> eval[];
          (if lex.symb 
           // lex.symbols.thenSy then
              lex;
              pImperatives -> thenPart[];
              Alternatives -> alt[]
           // lex.symbols.alternative then
              lex;
              pAlternatives -> alt[];
              Imperatives -> thenPart[]
           else (* // ... then ... *)
              501 -> SyntaxError
          if);
          (if lex.symb = lex.symbols.elseSy then
              lex;
              pImperatives -> elsePart[] 
           else
              Imperatives -> elsePart[]
          if);
          (if lex.symb = lex.symbols.ifSy then
              lex; 
              (if lex.symb = lex.symbols.rightBrack then
                  lex; 
               else
                  502 -> syntaxerror
              if)
           else
              503 -> syntaxerror
          if);
          (eval[],thenPart[],elsePart[],alt[]) -> IfImp -> iImp[];
       exit iImp[]
       #);
     pAlternatives:
       (# alt: ^Alternatives
       do 'pAlternatives'->trace;
          Alternatives -> alt[];
          L: (# 
             do pAlternative -> alt.append; 
                (if lex.symb = lex.symbols.alternative then 
                    lex;
                    restart L 
                if)
             #)
       exit alt[]
       #);
     pAlternative:
       (# alt: ^Alternative; sel: ^Selections; imps: ^Imperatives
       do 'pAlternative'->trace;
          pSelections -> sel[];
          (if lex.symb = lex.symbols.thenSy then
              lex;
              pImperatives -> imps[];
          if);
          (sel[],imps[]) -> Alternative -> alt[]          
       exit alt[]
       #);
     pSelections:
       (# sel: ^Selections;
       do'pSelections'->trace;
          Selections -> sel[];
          L: (#
             do pSelection -> sel.append;
                (if lex.symb = lex.symbols.alternative then
                    lex;
                    restart L
                if)
             #)
       exit sel[]
       #); 
     pSelection:
       (# sel: ^Selection
       do 'pSelection'->trace;
          pEvaluation -> Selection -> sel[]
       exit sel[]
       #);
     pLabelledImp:
       (# lImp: ^LabelledImp; lab: ^BetaNameDecl; imp: ^Imperative
       do 'pLabelledImp'->trace;
          pNameDecl -> lab[];
          (if lex.symb = lex.symbols.colon then
              lex
           else
              511  -> SyntaxError
          if);
          pImperative -> imp[];
          (lab[],imp[]) -> LabelledImp -> lImp[];
       exit lImp[]
       #);
     pBreak:
       (# bImp: ^Break; symb: ^NameApl
       do 'pBreak' -> trace;
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> BetaName -> NameApl -> symb[];
              lex;
              inner;
           else
              700 -> syntaxError
          if)
       exit bImp[]
       #);
     pLeaveImp: pBreak
       (#
       do 'pLeaveImp'->trace;
          symb[] -> LeaveImp -> bImp[];
       #);
     pRestartImp: pBreak
       (#
       do 'pRestartImp'->trace;
          symb[] -> RestartImp -> bImp[];
       #); 
     pInnerImp:
       (# inImp: ^InnerImp;
       do 'pInner'->trace;
          (if lex.symb = lex.symbols.idf then 
              lex.sym[] -> BetaLexem -> NameApl -> InnerImp -> inImp[];
              lex
           else
              '' -> BetaLexem -> NameApl -> innerImp -> inImp[]
          if)
       exit inImp[]
       #);
     pEvaluation:
       (# eval: ^Evaluation;
       do 'pEvaluation:'->trace;
          Evaluation -> eval[];
          pExp -> eval.append;
          L:
            (if lex.symb = lex.symbols.assign then
                lex;
                'pEvaluation:repeat'->trace;
                pTransaction -> eval.append;
                restart L
            if);
          'pEvaluation:end'->trace;
       exit eval[]
       #);
        
     ExpParser: 
       (# lE,rE: ^Expr; op: @integer;
       do inner 
       exit lE[] 
       #);
     pExp: ExpParser
       (# 
       do 'pExp'->trace;
          pSimpleExp -> lE[];
          (if lex.isRelOp then
              lex.symb -> op;
              lex; 
              pSimpleExp -> rE[];
              (lE[],op,rE[]) -> BetaBinaryExp -> lE[];
          if);
       #);
     pSimpleExp: ExpParser
       (#  
       do 'pSimpleExp'->trace;
          (if lex.isAddOrSub (*or (lex.symb = lex.symbols.adr (* @@X *)
              then 
              lex.Symb -> op;
              lex;
              pTerm -> lE[];
              (op,lE[]) -> BetaUnaryExp -> lE[];
           else
              pTerm -> lE[];
          if);
          Loop:
            (if lex.isAddOp then 
                lex.symb -> op;
                lex; 
                pTerm -> rE[];
                (lE[],op,rE[]) -> BetaBinaryExp -> lE[]; 
                restart Loop
            if);
       #);
     pTerm: ExpParser
       (#
       do 'pTerm'->trace;
          pFactor -> lE[];
          Loop:
            (if lex.isMultOp or (lex.symb = lex.symbols.prim) then
                (if lex.symb = lex.symbols.prim then
                    (* we should mark the operator as primitive for PT *)
                    lex;
                    (if lex.symb <> lex.symbols.idf then
                        SyntaxError
                if)if);
                lex.symb -> op;
                lex; 
                pFactor -> rE[];
                (lE[],op,rE[]) -> BetaBinaryExp -> lE[];
                restart Loop
            if)
       #);
     pFactor: ExpParser
       (* textConst, IntegerConst, NoneExp, 
        *          * not EXP, RepetitionSlice,
        *          * Transaction, UnaryPrimitiveExp
        *          * Are they alle sub of exp/term?
        *          *)
       (#
       do 'pFactor'->trace;
          pTransaction -> BetaTerm -> lE[];
          'pFactor:end'->trace;
       #);     

     pTransaction:
       (* T:: ObjEval 
        *   | ComputedEval     - R.S!
        *   | ObjRef           - R.S[]
        *   | EvalList         - (E1, E2,E3)
        *   | StrucRef         - R.S##
        *   | Primitive        - tos foo
        *   | Address          - @@ X
        * ObjEval :: InsItem   - R.P(# ... #) 
        *          |           - (# ... #) 
        *          | Reference 
        * Reference:: ObjDen    - R.PA
        *           | DynObjGen - R.P&
        * ObjDen:: AttDen       - R.P
        *)
       (# tra: ^Transaction; evl: ^EvaluationList; EV: ^ObjEval;
          op: @integer; lE: ^expr; AD: ^AttributeDenotation; 
       do 'pTransaction'->trace;
          (if lex.symb 
           // lex.symbols.idf // lex.symbols.begin 
           // lex.symbols.textSy then
              pObjEval -> tra[];
              'pTransaction:A'->trace;
              (if lex.symb 
               // lex.symbols.objRef then
                  tra[] -> pReference -> tra[];
                  lex
               // lex.symbols.strucVar then
                  tra[] -> pStructureRef -> tra[];
                  lex
              if);
           // lex.symbols.thisObj then
              'pTransaction:thisObj'->trace; 
              pThisObj -> tra[]
           // lex.symbols.nott then 
              'pTransaction:not'->trace; 
              lex.symb -> op;
              lex;
              pFactor -> lE[];
              (op,lE[]) -> BetaUnaryExp -> tra[]
           // lex.symbols.const then
              'pTransaction:const'->trace;
              lex.sym[] -> BetaLexem -> BetaConst -> tra[];
              lex;
           // lex.symbols.charSy then
              lex.sym[] -> BetaLexem -> aChar -> tra[];
              lex;
           // lex.symbols.textSy then
              lex.sym[] -> aText -> tra[];
              lex;
           // lex.symbols.noneSy then
              noneValue -> tra[];
              lex
           // lex.symbols.leftBrack then
              lex; 
              pEvaluationList -> EVL[] -> tra[];
              (if lex.symb = lex.symbols.dot then 
                  (* We come here in sitations like
                   * (if (e).f ...
                   *)
                  lex;
                  EVL[] -> pComputedRemote -> tra[];
                  (if lex.symb 
                   // lex.symbols.begin then
                      (* '\n!!!!! In module "' -> puttext;           
                       thisModuleName[] -> puttext;
                       '", ComputedRemote as super may not work!\n' -> puttext;
                       3 -> lex.printlines;
                       newline;
                       *)
                      (*tra.markAsSuper;*)
                      (# PD: ^PatternDen; AD: ^AttributeDenotation; OE: ^ObjEval
                      do &PatternDen[] -> PD[];
                         ''->BetaName -> AttributeDenotation -> AD[];
                         &ObjEval[] -> OE[];                         
                         tra[] 
                           -> pComputedRemoteAsDenotation
                           (*-> AD.NA[]
                           -> AD.append;*);
                         AD[] -> PD.AD[] -> PD.append;
                         PD[] -> pObjectDesc -> ObjEval -> OE[];
                         OE[] -> tra[]
                      #)
                   // lex.symbols.leftSquare then
                      '\npTransaction:Got Indexed "[exp]" after:  ' -> puttext; 
                      tra.dopt -> putline;
                      lex;
                      (if true then 'Bingo'->putline;
                          evaluation;
                          'banko' -> putline;
                          (if lex.symb = lex.symbols.rightSquare then
                              lex
                           else
                              201 -> SyntaxError
                          if)
                       else
                          tra[]
                            -> pComputedRemoteAsDenotation
                           (* -> Indexed*)
                      if)
                  if)
              if)
           // lex.symbols.new then
              lex;
              pDynamicObjectGeneration -> tra[]
           // lex.symbols.prim then 
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex;
                  pFactor -> tra[]
              if)
           // lex.symbols.adr then
              lex;
              pFactor -> tra[]
           else 
              200->syntaxError; 
              (*
              (15
              ,(lex.symbols.idf,lex.symbols.thisObj,lex.symbols.const,lex.symbols.charSy
              ,lex.symbols.textSy,lex.symbols.leftBrack,lex.symbols.new)
              ,(lex.symbols.semicolon)) -> syntaxError;*)
              &Transaction[] -> tra[]
          if);
          'pTransaction:end'->trace;
       exit tra[]
       #);
     pObjEval:
       (# objEV: ^ObjEval; OS: ^BetaObjectSpecification; PD: ^PatternDen;
       do 'pObjEval'->trace;
          pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
          OS[] -> ObjEval -> objEV[];
          'pObjEval:end'->trace;
       exit objEv[]
       #);
     pThisObj:
       (# tra: ^Transaction; AD: ^AttributeDenotation; EV: ^ObjEval;
       do 'pThisObjX'->trace; 
          lex;
          (if lex.symb = lex.symbols.leftBrack then
              lex;
              pAttributeDenotation -> AD[];
              (if lex.symb = lex.symbols.rightBrack then
                  lex
               else
                  syntaxError
              if);
           else
              ''->BetaName -> Attributedenotation -> AD[]
          if);
          AD[] -> ThisObject -> tra[];
          'pTransaction:thisObj'->trace; 
          (if lex.symb 
           // lex.symbols.objRef then
              tra[] -> pReference -> tra[];
              lex
           // lex.symbols.strucVar then
              tra[] -> pStructureRef -> tra[];
              lex
          if);
       exit tra[]
       #);
     pReference:
       (# OV: ^Transaction; ref: ^Reference
       enter OV[]
       do OV[] -> Reference -> ref[]
       exit ref[]
       #);
     pStructureRef:
       (# OV: ^Transaction; ref: ^StructureRef
       enter OV[]
       do OV[] -> StructureRef -> ref[]
       exit ref[]
       #);
     pEvaluationList:
       (# evl: ^EvaluationList
       do 'pEvaluationList'->trace; 
          EvaluationList -> evl[];
          Loop:
            (# 
            do
               pEvaluation -> evl.append;
               (if lex.symb = lex.symbols.comma then
                   lex;
                   restart Loop
            if)#);
          (if lex.symb = lex.symbols.rightBrack then 
              lex
           else 
              601 -> syntaxError 
          if)
       exit evl[]
       #);
     pDynamicObjectGeneration:
       (# OS: ^BetaObjectSpecification; DOG: ^DynamicObjectGeneration; 
          EV: ^Evaluation
       do 'pDynamicObjectGeneration'->trace; 
          (if lex.symb = lex.symbols.component then
              lex; (* should mark as Module *)
          if);
          (# PD: ^PatternDen
          do pPatternDen -> PD[];
             (if lex.symb = lex.symbols.begin then
                 PD.markAsSuper;
                 PD[] -> pObjectDesc -> OS[]
              else
                 PD[] -> OS[] 
             if);

             (if lex.symb = lex.symbols.leftBrack then
                 (if true then
                     pEvaluation -> EV[]
                  else
                     lex;
                     pEvaluation -> EV[];
                     (if lex.symb = lex.symbols.rightBrack then
                         lex
                      else                     
                         222 -> syntaxerror
                 if)if)
              else
                 Evaluation -> EV[]
             if);
             (OS[],EV[]) -> DynamicObjectGeneration -> DOG[];
             (if lex.symb = lex.symbols.objRef then (* Note: Only &P[], not &P
                                                     * We allow &P to be able to
                                                     * parse std BETA
                                                     *)
                 lex;
                 true -> DOG.isRef
                 (* else
                  (16,(0),(0)) -> SyntaxError*)
             if)
          #)
       exit DOG[]          
       #);
     pComputedRemote:
       (# EVL: ^EvaluationList; NA: ^NameApl; CR: ^ComputedRemote
       enter EVL[]
       do 'pComputedRemove'->trace;
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> BetaName -> NameApl -> NA[];
              lex
           else
              777 -> syntaxError;
              ''->BetaName -> NameApl -> Na[]
          if);
          (EVL[],NA[]) -> ComputedRemote -> CR[]
       exit CR[]          
       #);
     pComputedRemoteAsDenotation:
       (# tra: ^EvaluationList; CRD: ^ComputedRemoteAsDenotation
       enter tra[]
       do
       exit CRD[]          
       #);
     pBetaDecl:
       (# dcl: ^BetaDecl; symb: ^Text; NS: ^NameDecls; IT: ^Node
       do 'pBetaDecl' -> trace;
          pNameDecls -> NS[]; 
          (if lex.symb = lex.symbols.colon then
              lex;
              'pBetaDecl:colon'->trace;
              (if lex.symb
               // lex.symbols.object then
                  lex;
                  pStaticItem -> IT[];
                  (NS[],IT[]) -> BetaDataItem -> dcl[]
               // lex.symbols.ref then                  
                  lex;
                  pDynamicItem -> IT[];
                  (NS[],IT[]) -> BetaDataItem -> dcl[]
               // lex.symbols.lt then
                  lex;
                  NS[] -> pVirtualPattern -> dcl[]
               // lex.symbols.colon then (* X:: *)
                  lex; 
                  (if lex.symb = lex.symbols.lt then  (* X::< *)
                      lex;
                      NS[] -> pFurtherBinding -> dcl[]
                   else (* X :: *)
                      NS[] -> pFinalBinding -> dcl[] 
                      (* potential syntax problem here 
                       *   V: # (# #)
                       * does not give a syntax error
                       * but should not be caught here
                       *)
                  if)
               // lex.symbols.leftSquare then
                  lex;
                  pRepetition -> IT[];
                  (* OBS!!! Perhaps not ok . not tested ! *)
                  (NS[],IT[]) -> BetaDataItem -> dcl[]
               // lex.symbols.strucVar then
                  lex;
                  pvarPtn -> IT[];
                  (NS[],IT[]) -> BetaDataItem -> dcl[]
               else
                  'pAttribute:idf:colon:PTN'->trace;
                  NS[] -> pPattern -> dcl[];
              if)
           else
              111 -> SyntaxError
          if)
       exit dcl[]
       #);
     pNameDecls:
       (# NS:  ^NameDecls
       do 'pNameDecls'->trace;
          NameDecls -> NS[];
          L:
            (#
            do pNameDecl -> NS.append;
               (if Lex.Symb = Lex.Symbols.Comma Then 
                   Lex;
                   restart L
            if)#)
       exit NS[]
       #);
     pNameDecl:
       (# N: ^BetaNameDecl
       do 'pNameDecl'->trace;
          (if Lex.Symb = Lex.Symbols.Idf Then
              'pNameDecl:idf'->trace;
              Lex.sym[] -> BetaLexem -> BetaNameDecl -> N[];
              Lex;
           else
              199 -> SyntaxError
          if)
       exit N[]
       #);
     pStaticItem:
      (# IT: ^StaticItem; 
         PD: ^PatternDen;  OS: ^BetaObjectSpecification; isComponent: @Boolean
      do 'pStaticItem'->trace;
         (if lex.symb = lex.symbols.component then
             lex; 
             true -> isComponent
         if);
         pPatternDen -> PD[];
         (if lex.symb = lex.symbols.begin then
             PD[] -> pObjectDesc -> OS[]
          else
             PD[] -> OS[]
         if);
         (OS[],isComponent) -> StaticItem -> IT[]
      exit IT[]
      #);     
     pDynamicItem:
       (# IT: ^DynamicItem; isComponent: @Boolean
       do 'pDynamicItem' -> trace;
          (if lex.symb = lex.symbols.component then
              lex; 
              true -> isComponent
          if);
          (pPatternDen,isComponent) -> DynamicItem -> IT[]
       exit IT[]
       #);
     pRepetition:
       (# inx: ^Index;
          IT: ^Node
       do pIndex -> inx[];
          (if lex.symb 
           // lex.symbols.object then
              lex;
              pStaticItem -> IT[] 
           // lex.symbols.ref then
              lex;
              pDynamicItem -> IT[]
           // lex.symbols.strucVar then
              lex;
              pvarPtn -> IT[]
           else
              333 ->  SyntaxError;
              StaticItem -> IT[]
          if);
          (inx[],IT[]) -> Repetition -> IT[]
       exit IT[]
       #);
     pIndex:
       (#  INX: ^Index
       do pEvaluation -> Index -> INX[];
          (if lex.symb = lex.symbols.rightSquare then
              lex
           else
              334 ->  SyntaxError
          if)
       exit INX[]
       #);
     pVarPtn:
       (# VP: ^VarPtn; 
       do 'pVarPtn' -> trace;
          pAttributeDenotation -> VarPtn -> VP[]
       exit VP[]
       #);
     pPattern:
       (# NS: ^NameDecls; OD: ^ObjectDesc; dcl: ^BetaDecl;
       enter NS[]
       do 'pPattern'->trace;
          pPatternDen -> pObjectDesc -> OD[];
          (NS[],OD[]) -> BetaPattern -> dcl[];
       exit dcl[]
       #);
     pVirtualSpec:
       (# PD: ^PatternDen; OS: ^BetaObjectSpecification;
       do pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
       exit OS[]
       #);
     pVirtualPattern:
       (# NS: ^NameDecls; PD: ^PatternDen; dcl: ^BetaDecl; 
          OS: ^BetaObjectSpecification;
       enter NS[]          
       do 'pVirtualPattern'->trace;
          pVirtualSpec -> OS[];
          (NS[],OS[]) -> BetaVirtualPattern -> dcl[];
       exit dcl[]
       #);
     pFurtherBinding:
       (# NS: ^NameDecls; dcl: ^BetaDecl; OS: ^BetaObjectSpecification;
       enter NS[]
       do 'pFurtherBinding'->trace;
          pVirtualSpec -> OS[];
          (NS[],OS[]) -> FurtherBinding -> dcl[];
       exit dcl[]
       #);
     pFinalBinding:
       (# NS: ^NameDecls; dcl: ^BetaDecl; OS: ^BetaObjectSpecification;
       enter NS[]
       do 'pFinalBinding'->trace;
          pVirtualSpec -> OS[];
          (NS[],OS[]) -> FinalBinding -> dcl[];
       exit dcl[]
       #);
     pObjectDesc:
       (# sup: ^PatternDen; symb: ^Text; OD: ^ObjectDesc; slt: ^Slot;
          att: ^Attributes; acp: ^ActionPart;
       enter sup[]
       do 'pObjectDesc'->trace;
          (if lex.symb 
           // lex.symbols.begin then
              lex;
              'pObjectDesc:begin'->trace;
              pAttributes -> att[];
              pActionPart -> acp[];
              'pObjectDesc:after:pActionPart'->trace;
              (sup[],att[],acp[]) -> ObjectDesc -> OD[];
              'pObjectDesc:after:ObjectDesc'->trace;
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  113 -> syntaxError
              if)
           // lex.symbols.nonTbegin then
              lex;
              pSlot -> slt[];
              'pObjdesc:got:SLOT:MUST:FIX!'->trace;
              (sup[],Attributes,ActionPart) -> ObjectDesc -> OD[];
          if);
          'pObjectDesc:end'->trace;
       exit OD[]
       #);
     pPatternDen:
       (# ptnDen: ^PatternDen; 
       do 'pPatternDen'->trace;
          true -> pAttributeDenotation -> PatternDen->ptnDen[]
          (*lex*)
       exit ptnDen[]
       #);
     pAttributeDenotation:
       (# B: @Boolean; NA: ^Denotation; AD: ^AttributeDenotation; 
       enter B
       do 'pAttributeDenotation'->trace;
          (if lex.symb 
           // lex.symbols.idf then
              lex.sym.copy -> BetaName -> AttributeDenotation -> NA[];
              lex;  
           // lex.symbols.thisObj then
              lex;
              pThisObj -> NA[]
           // lex.symbols.textSy then 
              lex.sym[] -> BetaName (*Atext*) -> AttributeDenotation -> NA[];
              lex
           else
              '' -> BetaName -> AttributeDenotation -> NA[]
          if);
          Loop: 
            (#
            do 
               (if lex.symb = lex.symbols.leftSquare then
                   lex;
                   NA[] -> pIndexed -> NA[];
               if);
               (if lex.symb = lex.symbols.dot then
                   lex;
                   NA[] -> pRemote -> NA[];
            if)#);
          'pAttributeDenotation:end'->trace;
       exit NA[]
       #);
     pIndexed:
       (# NA: ^Denotation; inx: ^Indexed; EV,uE: ^Evaluation
       enter NA[]
       do 'pIndexed'->trace;
          pEvaluation -> EV[];
           (if lex.symb = lex.symbols.colon then
              (* R[low:high] *)
              lex;
               pEvaluation -> uE[]
            else
               Evaluation -> uE[]
          if);
          (if lex.symb = lex.symbols.rightSquare then
              lex
           else
              202 -> SyntaxError
          if);
          (NA[],EV[],uE[]) -> Indexed -> inx[];
       exit inx[]
       #);
     pRemote:
       (# den: ^Denotation; rm: ^Remote; 
       enter den[]
       do 'pRemote'->trace;
          Remote -> rm[];
          L:
            (#
            do den[] -> rm.append;
               (if lex.symb = lex.symbols.idf then
                   lex.sym.copy -> BetaName -> AttributeDenotation -> den[];
                   lex;
                   restart L
          if)#)
       exit rm[]
       #);
     trace:
       (# S: ^Text
       enter S[]
       do (if doTraceParser then
              S[] -> puttext; ':'->put; '\t'->put;
              lex.symb -> putint; ' ' -> put;
              lex.symb -> lex.symbols.asText -> puttext;
              ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
              inner trace
          if)
       #);

     openFragmentFile:
       (# S: ^BetaString; StdPath,fragPath: ^text;
          FD: ^FragmentDir;
          NM: ^BetaName;
          betaLib: ^Node;
       enter S[]
       do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
          (if stdpath[] = none then '!!!! Di not find BETALIB!'->putline if);
          '**** BETALIB: ' -> puttext; StdPath[] -> putline;
          'A fragment' -> BetaName -> NM[];
          '/' -> (StdPath.copy).append -> fragPath[];
          S.T[] -> fragPath.append -> fragPath[];
          (NM[],fragPath[],'',true) -> FragmentDir -> FD[];
          (NM[],FD[]) -> FragmentModule -> betaLib[];
          '\n**   FD.dopt:'->dumpTN;
          FD.doPT -> putline;
          '\n**   betaLIB:'->dumpTN;
          betaLib.doPT->dumpT;
       #);
     checkFrag:
       (# AST: @AstInterface(# defaultGrammarFinder:: findgrammar #);
          beta: ^AST.beta; FN,currentDir,name,fragPath: ^Text;
          dg: @AST.DependencyGraph;
       enter(FN[],currentDir[])
       do (* init astlevel *)
          AST.astLevelInit;
          &AST.beta[] -> beta[];
          '~beta/grammars/beta/beta' -> name[];
          (name[],'beta',screen[]) -> beta.betagrammarInit; 
          dg.init;
          (if false then
              'nti'->dg.TargetMachine;      
              'nti_ns'->dg.TargetDirectory;
           else
              'qbeta'->dg.TargetMachine;      
              'qbs'->dg.TargetDirectory;

          if);
          (FN[],currentDir[]) -> mkFN -> fragPath[];
          (if doTrace then
              '**** Extent:'->dumpTN;
              fragPath[] -> dumpTN;
              
              fragPath[] -> dg.scanExtent
              (# 
              do current.name -> dumpTN
              #);
              '**** Domain: ' -> dumpTN;
              fragPath[] -> dg.scanDomain
              (# 
              do current.name -> dumpTN
          #)if);
       #);
     currentDir:  ^Text; (* FN is in the folder currentDir *)
  enter currentDir[]
  do (if FN[] = none then 'FN is none'->putline if);
     (FN[],currentDir[]) -> openBetaModule;
     (FN[],currentDir[]) -> checkFrag;
     inner
  #);
