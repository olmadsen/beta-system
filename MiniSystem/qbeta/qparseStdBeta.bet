ORIGIN 'qabstractSyntaxTree';
INCLUDE 'qBetaAST';
INCLUDE 'qStdBetaLexer';
INCLUDE '~beta/sysutils/envstring';
(*INCLUDE 'qabstractSyntaxTree'*)
--AstLib:attributes--
doTrace: (# exit false #);
parseStdBeta: 
  (# superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)
       enter fileName[]
       do (* all the lex setup stuff *) 
          (*'Pos: ' -> puttext; beginPos -> putint; newline;*)
          (*'Module: ' -> puttext; fileName[] -> putline;*)
          (path.append).copy -> pathToFN[];
          (*lex[] -> oldLex[];*)
          &StdBetaLexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          lex;
          INNER;
          inFile.close;
          (*oldLex[] -> lex[];*)
       #);
     lex: ^StdBetaLexer;
     openBetaModule:
       (# S: ^StringObj; StdPath,fragPath: ^text;
          FD: ^FragmentDir;
          NM: ^BetaName;
          BM: ^SimpleBetaModule;
       enter S[]
       do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
          (if stdpath[] = none then '!!!! Did not find BETALIB!'->putline if);
          (if doTrace then
              '**** BETALIB: ' -> puttext; StdPath[] -> putline;
          if);
          'A fragment' -> BetaName -> NM[];
          '/' -> (StdPath.copy).append -> fragPath[];
          S.T[] -> fragPath.append -> fragPath[];
          fragPath[] -> SimpleBetaModule -> BM[];
          (if doTrace then BM.doPT -> dumpTN if);
          BM.filePath[] -> superParser
          (# BPS: ^BetaProperties;  frags: ^BetaFragments
          do pProperties -> BPS[];
             (if doTrace then
                 'after:pProperties'->trace;             
                 pFragments -> frags[];                 
                 'after:pFragments:'->trace;
                 BPS.dopt -> putline;
                 frags.doPT -> putline;
             if)
          #)
       #);

     pProperties:
       (# BPS:  ^BetaProperties; prop: ^BetaProperty; symb: ^Text;  
          gotOne: @boolean
       do 'pProperties'->trace;
          BetaProperties -> BPS[];
          L:
            (if lex.symb
             // lex.symbols.idf  then
                lex.sym[] -> symb[];
                lex;
                symb[] -> pProperty -> prop[] -> BPS.append;
                (if lex.symb = lex.symbols.semicolon then 
                    true -> gotOne;
                    lex; 
                    'pProperties:repeat'->trace; 
                    restart L
                if)
             // lex.symbols.frag then (* no properties *)
             // lex.symbols.eos then (* empty file *)
             else
                (if not gotOne then SyntaxError if)
            if)
       exit BPS[]
       #);
     
     pProperty:
       (# symb: ^Text;  prop: ^BetaProperty;
       enter symb[]
       do 'pProperty'->trace;
          BetaProperty -> prop[]; symb[] -> BetaName -> prop.append;
          L:
            (if lex.symb
             // lex.symbols.textSy then
                lex.sym[] -> StringObj -> prop.append;
                lex;
                restart L
             // lex.symbols.charSy then
                lex.sym[] -> BetaName -> prop.append;
                lex;
                restart L
             // lex.symbols.idf 

             // lex.symbols.const then
                lex.sym[] -> BetaName -> prop.append;
                lex;
                restart L
            if);
          'pProperty:end'->trace
       exit prop[]
       #);

     pFragments: 
       (# frags: ^BetaFragments
       do 'pFragments'->trace;
          BetaFragments -> frags[];
          (if lex.symb = lex.symbols.frag then 
              lex;
              pFragment -> frags.append
          if);
          'pFragments:end'->trace
       exit frags[]
       #);
     pFragment:
       (# frag: ^BetaFragment; theName,cat,language: ^BetaLexem;
       do 'pFragment'->trace; 
          loop:
            (if lex.symb = lex.symbols.idf then
                lex.sym[] -> BetaName -> theName[];
                lex; 
                'pFragment:idf'->trace; 
                (if lex.symb = lex.symbols.colon then
                    lex;
                    'pFragment:colon'->trace; 
                    (if lex.symb = lex.symbols.idf then
                        'pFragment:idf:colon:idf'->trace; 
                        lex.sym[] -> BetaName -> cat[];
                        lex;
                        (if lex.symb = lex.symbols.colon then
                            'pFragment:idf:colon:idf:colon'->trace; 
                            lex;
                            (if lex.symb = lex.symbols.idf then 
                                (* --- x:objectDesc:beta --- *)
                                lex.sym[] -> BetaName -> language[];
                                lex;                          
                             else
                                SyntaxError
                            if)
                         else
                            'pFragment:idf:colon:BETA'->trace; 
                            'BETA'-> BetaName -> language[];
                        if);
                        (if lex.symb = lex.symbols.frag then
                            'pFragment:frag:last'->trace; 
                            lex;
                            (if true 
                             // 'descriptor' -> cat.T.equalNCS 
                             // 'descriptorForm' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> ObjDescFrag -> frag[]
                             // 'attributes' -> cat.T.equalNCS 
                             // 'attribute' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> pAttFrag
                                  -> frag[]
                             // 'doPart' -> cat.T.equalNCS then 
                                (theName[],cat[],language[]) 
                                  -> doPartFrag -> frag[]
                             // 'mainPart' -> cat.T.equalNCS then
                                '\n!!!! MainPart category is not implemented' 
                                  -> putline
                             else
                                'Unknown category: ' -> puttext; 
                                cat.T[] -> putline
                            if);
                            (if lex.symb = lex.symbols.frag then 
                                lex;
                                restart loop
                            if);
                         else
                            SyntaxError
                        if)
                     else
                        SyntaxError
                    if)
                 else
                    SyntaxError
                if)
             else
                SyntaxError
            if)
       exit frag[]
       #);
     pAttFrag:
       (# theName,cat,language: ^BetaName; frag: ^AttFrag;
       enter(theName[],cat[],language[])
       do 'pAttributes'->trace;
          (theName[],cat[],language[]) -> AttFrag -> frag[];
          Attributes -> frag.att[];
          pAttributes -> frag.att.append
       exit frag[]
       #);
     pAttributes:
       (# theName,cat,language: ^BetaName; att: ^Attributes;
       enter(theName[],cat[],language[])
       do 'pAttributes'->trace;
          Attributes -> att[];
          Loop:
            (#
            do
               (if lex.symb 
                // lex.symbols.semicolon then
                   lex;
                   restart Loop
                // lex.symbols.nonTbegin then
                   lex;
                   (*Slot -> append;*)
                   restart Loop
                // lex.symbols.doSy
                // lex.symbols.end
                // lex.symbols.enterSy
                // lex.symbols.exitSy 
                // lex.symbols.frag
                // lex.symbols.eos (* obs ok if attributes slot not in objDesc *) then 
                   leave Loop 
                else
                   pBetaDecl -> att.append;
                   restart Loop
               if)               
            #)
       exit att[]
       #);
     pBetaDecl:
       (# dcl: ^BetaDecl; symb: ^Text; NS: ^NameDecls; IT: ^StaticItem
       do 'pBetaDecl' -> trace;
          pNameDecls -> NS[]; 
          (if lex.symb = lex.symbols.colon then
              lex;
              'pBetaDecl:colon'->trace;
              (if lex.symb
               // lex.symbols.object then
                  lex;
                  pStaticItem -> IT[];
                  (NS[],IT[]) -> BetaDataItem -> dcl[]
               else
                  'pAttribute:idf:colon:PTN'->trace;
                  NS[] -> pPattern -> dcl[];
              if)
           else
              111 -> SyntaxError
          if)
       exit dcl[]
       #);
     pNameDecls:
       (# NS:  ^NameDecls
       do 'pNameDecls'->trace;
          NameDecls -> NS[];
          L:
            (#
            do pNameDecl -> NS.append;
               (if Lex.Symb = Lex.Symbols.Comma Then 
                   Lex;
                   restart L
            if)#)
       exit NS[]
       #);
     pNameDecl:
       (# N: ^NameDecl
       do 'pNameDecl'->trace;
          (if Lex.Symb = Lex.Symbols.Idf Then
              'pNameDecl:idf'->trace;
              Lex.sym[] -> NameDecl -> N[];
              Lex;
           else
              199 -> SyntaxError
          if)
       exit N[]
       #);
     pStaticItem:
       (# nl:  ^NameList;  IT: ^StaticItem; 
          PD: ^PatternDen;  OS: ^BetaObjectSpecification
       enter nl[]
       do 'pStaticItem'->trace;
          pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
          OS[] -> StaticItem -> IT[]
       exit IT[]
       #);
     pPattern:
       (# NS: ^NameDecls; OD: ^ObjectDesc; dcl: ^BetaDecl;
       enter NS[]
       do 'pPattern'->trace;
          pPatternDen -> pObjectDesc -> OD[];
          (NS[],OD[]) -> BetaPattern -> dcl[];
       exit dcl[]
       #);
     pObjectDesc:
       (# sup: ^PatternDen; symb: ^Text;  OD: ^ObjectDesc;
          att: ^Attributes;
          acp: ^ActionPart;
       enter sup[]
       do 'pObjectDesc'->trace;
          (if lex.symb = lex.symbols.begin then
              lex;
              'pObjectDesc:begin'->trace;
              pAttributes -> att[];
              ActionPart -> acp[];
              (sup[],att[],acp[]) -> ObjectDesc -> OD[];
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  113 -> syntaxError
          if)if)
       exit OD[]
       #);
     pPatternDen:
       (# ptnDen: ^PatternDen; 
       do 'pPatternDen'->trace;
          true -> pAttributeDenotation -> PatternDen->ptnDen[]
          (*lex*)
       exit ptnDen[]
       #);
     pAttributeDenotation:
       (# B: @Boolean; attDen: ^AttributeDenotation; 
       enter B
       do 'pAttributeDenotation'->trace;
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> BetaName -> AttributeDenotation -> attDen[];
              lex;
           else
              '' -> BetaName -> AttributeDenotation -> attDen[]
          if)
       exit attDen[]
       #);
     trace:
       (# S: ^Text
       enter S[]
       do (if doTrace then
              S[] -> puttext; ':'->put; '\t'->put;
              lex.symb -> putint; ' ' -> put;
              lex.symb -> lex.symbols.asText -> puttext;
              ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
              inner trace
          if)
       #);

     prop: ^NewProperty;
  enter prop[]
  do (if doTrace then '**** parseStdBeta:'->dumpT if);
     prop.args.scanSons
     (# INV: ^Invocation; 
     do current[] -> INV[];
        INV.scanSons
        (# S: ^StringObj; 
        do (if current.isStringLiteral then
               current[] -> S[];
               (if doTrace then
                   S.doPT -> dumpTN;
               if);
               S[] -> openBetaModule
     if)#)#)
  #);
trace:
  (# S: ^Text
  enter S[]
  do (if true then
         S[] -> puttext; ':'->put;
         lex.symb -> putint; ' ' -> put;
         lex.symb -> lex.symbols.asText -> puttext;
         ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
         inner trace
     if)
  #);

openFragmentFile:
  (# S: ^StringObj; StdPath,fragPath: ^text;
     FD: ^FragmentDir;
     NM: ^BetaName;
     betaLib: ^Item;
  enter S[]
  do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
     (if stdpath[] = none then '!!!! Di not find BETALIB!'->putline if);
     '**** BETALIB: ' -> puttext; StdPath[] -> putline;
     'A fragment' -> BetaName -> NM[];
     '/' -> (StdPath.copy).append -> fragPath[];
     S.T[] -> fragPath.append -> fragPath[];
     (NM[],fragPath[],'',true) -> FragmentDir -> FD[];
     (NM[],FD[]) -> FragmentModule -> betaLib[];
     '\n**   FD.dopt:'->dumpTN;
     FD.doPT -> putline;
     '\n**   betaLIB:'->dumpTN;
     betaLib.doPT->dumpT;
  #);
