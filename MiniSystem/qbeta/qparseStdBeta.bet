ORIGIN 'qabstractSyntaxTree';
INCLUDE 'qBetaAST';
INCLUDE 'qStdBetaLexer';
INCLUDE '~beta/sysutils/envstring';
(*INCLUDE 'qabstractSyntaxTree'*)
--AstLib:attributes--
doTrace: (# exit false #);
parseStdBeta: 
  (# superParser:
       (# fileName,pathToFN: ^text; 
          inFile: ^file;
          oldLex: ^lexer;
          (*objMd: ^objectModule;*)
       enter fileName[]
       do (* all the lex setup stuff *) 
          (*'Pos: ' -> puttext; beginPos -> putint; newline;*)
          (*'Module: ' -> puttext; fileName[] -> putline;*)
          (path.append).copy -> pathToFN[];
          (*lex[] -> oldLex[];*)
          &StdBetaLexer[] -> lex[];
          &file[] -> inFile[];
          fileName[]  -> inFile.name;
          inFile.openRead;
          (fileName[],inFile[]) -> lex.init;
          lex;
          INNER;
          inFile.close;
          (*oldLex[] -> lex[];*)
       #);
     lex: ^StdBetaLexer;
     openBetaModule:
       (# S: ^StringObj; StdPath,fragPath: ^text;
          FD: ^FragmentDir;
          NM: ^BetaName;
          BM: ^SimpleBetaModule;
       enter S[]
       do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
          (if stdpath[] = none then '!!!! Did not find BETALIB!'->putline if);
          (if doTrace then
              '**** BETALIB: ' -> puttext; StdPath[] -> putline;
          if);
          'A fragment' -> BetaName -> NM[];
          '/' -> (StdPath.copy).append -> fragPath[];
          S.T[] -> fragPath.append -> fragPath[];
          fragPath[] -> SimpleBetaModule -> BM[];
          (if doTrace then BM.doPT -> dumpTN if);
          BM.filePath[] -> superParser
          (# BPS: ^BetaProperties;  frags: ^BetaFragments
          do pProperties -> BPS[];
             (if doTrace then
                 'after:pProperties'->trace;             
                 pFragments -> frags[];                 
                 'after:pFragments:'->trace;
                 BPS.dopt -> putline;
                 frags.doPT -> putline;
             if)
          #)
       #);

     pProperties:
       (# BPS:  ^BetaProperties; prop: ^BetaProperty; symb: ^Text;  
          gotOne: @boolean
       do 'pProperties'->trace;
          BetaProperties -> BPS[];
          L:
            (if lex.symb
             // lex.symbols.idf  then
                lex.sym[] -> symb[];
                lex;
                symb[] -> pProperty -> prop[] -> BPS.append;
                (if lex.symb = lex.symbols.semicolon then 
                    true -> gotOne;
                    lex; 
                    'pProperties:repeat'->trace; 
                    restart L
                if)
             // lex.symbols.frag then (* no properties *)
             // lex.symbols.eos then (* empty file *)
             else
                (if not gotOne then SyntaxError if)
            if)
       exit BPS[]
       #);
     
     pProperty:
       (# symb: ^Text;  prop: ^BetaProperty;
       enter symb[]
       do 'pProperty'->trace;
          BetaProperty -> prop[]; symb[] -> BetaName -> prop.append;
          L:
            (if lex.symb
             // lex.symbols.textSy then
                lex.sym[] -> StringObj -> prop.append;
                lex;
                restart L
             // lex.symbols.charSy then
                lex.sym[] -> BetaName -> prop.append;
                lex;
                restart L
             // lex.symbols.idf 

             // lex.symbols.const then
                lex.sym[] -> BetaName -> prop.append;
                lex;
                restart L
            if);
          'pProperty:end'->trace
       exit prop[]
       #);

     pFragments: 
       (# frags: ^BetaFragments
       do 'pFragments'->trace;
          BetaFragments -> frags[];
          (if lex.symb = lex.symbols.frag then 
              lex;
              pFragment -> frags.append
          if);
          'pFragments:end'->trace
       exit frags[]
       #);
     pFragment:
       (# frag: ^BetaFragment; theName,cat,language: ^BetaLexem;
       do 'pFragment'->trace; 
          loop:
            (if lex.symb = lex.symbols.idf then
                lex.sym[] -> BetaName -> theName[];
                lex; 
                'pFragment:idf'->trace; 
                (if lex.symb = lex.symbols.colon then
                    lex;
                    'pFragment:colon'->trace; 
                    (if lex.symb = lex.symbols.idf then
                        'pFragment:idf:colon:idf'->trace; 
                        lex.sym[] -> BetaName -> cat[];
                        lex;
                        (if lex.symb = lex.symbols.colon then
                            'pFragment:idf:colon:idf:colon'->trace; 
                            lex;
                            (if lex.symb = lex.symbols.idf then 
                                (* --- x:objectDesc:beta --- *)
                                lex.sym[] -> BetaName -> language[];
                                lex;                          
                             else
                                SyntaxError
                            if)
                         else
                            'pFragment:idf:colon:BETA'->trace; 
                            'BETA'-> BetaName -> language[];
                        if);
                        (if lex.symb = lex.symbols.frag then
                            'pFragment:frag:last'->trace; 
                            lex;
                            (if true 
                             // 'descriptor' -> cat.T.equalNCS 
                             // 'descriptorForm' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> ObjDescFrag -> frag[]
                             // 'attributes' -> cat.T.equalNCS 
                             // 'attribute' -> cat.T.equalNCS then
                                (theName[],cat[],language[]) 
                                  -> pAttFrag
                                  -> frag[]
                             // 'doPart' -> cat.T.equalNCS then 
                                (theName[],cat[],language[]) 
                                  -> doPartFrag -> frag[]
                             // 'mainPart' -> cat.T.equalNCS then
                                '\n!!!! MainPart category is not implemented' 
                                  -> putline
                             else
                                'Unknown category: ' -> puttext; 
                                cat.T[] -> putline
                            if);
                            (if lex.symb = lex.symbols.frag then 
                                lex;
                                restart loop
                            if);
                         else
                            SyntaxError
                        if)
                     else
                        SyntaxError
                    if)
                 else
                    SyntaxError
                if)
             else
                SyntaxError
            if)
       exit frag[]
       #);
     pAttFrag:
       (# theName,cat,language: ^BetaName; frag: ^AttFrag;
       enter(theName[],cat[],language[])
       do 'pAttributes'->trace;
          (theName[],cat[],language[]) -> AttFrag -> frag[];
          Attributes -> frag.att[];
          pAttributes -> frag.att.append
       exit frag[]
       #);
     pAttributes:
       (# theName,cat,language: ^BetaName; att: ^Attributes;
       enter(theName[],cat[],language[])
       do 'pAttributes'->trace;
          Attributes -> att[];
          Loop:
            (#
            do
               (if lex.symb 
                // lex.symbols.semicolon then
                   lex;
                   restart Loop
                // lex.symbols.nonTbegin then
                   lex;
                   (*Slot -> append;*)
                   restart Loop
                // lex.symbols.doSy
                // lex.symbols.end
                // lex.symbols.enterSy
                // lex.symbols.exitSy 
                // lex.symbols.frag
                // lex.symbols.eos (* obs ok if attributes slot not in objDesc *) then 
                   leave Loop 
                else
                   pBetaDecl -> att.append;
                   restart Loop
               if)               
            #)
       exit att[]
       #);
     pActionPart:
       (# acp: ^ActionPart; 
          enterP: ^EnterPart; exitP: ^ExitPart; imps: ^Imperatives; slt: ^Slot;
       do 'pActionPart'->trace;
          pEnterPart -> enterP[];
          Imperatives -> imps[];
          (if lex.symb 
           // lex.symbols.doSy then
              lex;
              pImperatives -> imps[]
           // lex.symbols.nonTbegin then
              lex;
              pSlot -> slt[] (* we should mark that this is a slot *)
          if);
          pExitPart -> exitP[];
          (enterP[],imps[],exitP[]) -> ActionPart -> acp[]
       exit acp[]
       #);
     pEnterPart:
       (# enterP: ^EnterPart; eval: ^Evaluation; 
       do (if lex.symb = lex.symbols.enterSy then
              lex; 
              pEvaluation -> eval[]
           else
              Evaluation -> eval[]
          if);
          eval[] -> EnterPart -> enterP[]
       exit enterP[]
       #);
     pImperatives:
       (# imps: ^Imperatives;
       do 'pImperatives'->trace;
          Imperatives -> imps[];
          Loop:
            (#
            do (if lex.symb 
                // lex.symbols.semiColon then (* empty imp *) lex; restart Loop 
                // lex.symbols.nonTbegin then
                   lex;
                   pSlot
                // lex.symbols.end 
                // lex.symbols.ifSy
                // lex.symbols.alternative
                // lex.symbols.elseSy
                // lex.symbols.forSy 
                // lex.symbols.exitSy 
                // lex.symbols.eos 
                // lex.symbols.frag then leave Loop 
                   (* perhaps we need to test positive for symbols that may
                    * begin en imperative
                    *)
                else
                   pImperative -> imps.Append
               if);
               restart Loop
            #)
       exit imps[]
       #);
     pImperative:
       (# imp: ^Item
       do 'pImperative'->trace;
          (if lex.symb
           // lex.symbols.leftBrack then
              (if lex.nextIsForOrIf then
                  lex;
                  (if lex.symb
                   // lex.symbols.forSy then
                      lex;
                      (*pForImp -> imp[] *)
                   // lex.symbols.ifSy then
                      lex;
                      (*pIfImp -> imp[]*)
                  if)
               else
                 pEvaluation -> imp[]
              if)
           // lex.symbols.leaveSy then
              lex; 
              (*pLeaveImp -> imp[] *)
           // lex.symbols.restartSy then
              lex; 
              (*pRestartImp -> imp[] *)
              (* LabelledImp?
               * L: 3 -> a;
               * A -> B;
               *)
           // lex.symbols.innerSy then
              lex;
              (*pInnerImp -> imp[] *)
           // lex.symbols.idf then
              (if lex.peek = ':' then
                  (*pLabelledImp -> imp[] *)
               else
                  pEvaluation -> imp[]
              if)
           else 
              pEvaluation -> imp[]
          if); 
       exit imp[]
       #);
     pExitPart:
       (# exitP: ^ExitPart; eval: ^Evaluation; 
       do 'pExitPart'->trace; 
          (if lex.symb = lex.symbols.exitSy then
              lex; 
              pEvaluation -> eval[]
           else
              Evaluation -> eval[]
          if);
          eval[] -> ExitPart -> exitP[]
       exit exitP[]
       #);
     pSlot:
       (# slt: ^Slot;
       do
       exit slt[]
       #);
     pEvaluation:
       (# eval: ^Evaluation; tra: ^Transaction
       do 'pEvaluation:'->trace;
          Transaction -> tra[];
          pExp -> tra.append;
          L:
            (if lex.symb = lex.symbols.assign then
                lex;
                pTransaction -> tra.append;
                restart L
            if);
          Evaluation -> eval[];
          tra[] -> eval.append;
       exit eval[]
       #);
        
     ExpParser: 
       (# lE,rE: ^Expr; op: @integer;
       do inner 
       exit lE[] 
       #);
     pExp: ExpParser
       (# 
       do pSimpleExp -> lE[];
          (if lex.isRelOp then
              lex.symb -> op;
              lex; 
              pSimpleExp -> rE[];
              (lE[],op,rE[]) -> BetaBinaryExp -> lE[]
          if);
       #);
     pSimpleExp: ExpParser
       (#  
       do (if lex.isAddOrSub (*or (lex.symb = lex.symbols.adr (* @@X *)
              then 
              lex.Symb -> op;
              lex;
              pTerm -> lE[];
              (op,lE[]) -> BetaUnaryExp -> lE[];
           else
              pTerm -> lE[];
          if);
          Loop:
            (if lex.isAddOp then 
                lex.symb -> op;
                lex; 
                pTerm -> rE[];
                (lE[],op,rE[]) -> BetaBinaryExp -> lE[]; 
                restart Loop
            if);
       #);
     pTerm: ExpParser
       (#
       do pFactor -> lE[];
          Loop:
            (if lex.isMultOp or (lex.symb = lex.symbols.prim) then
                (if lex.symb = lex.symbols.prim then
                    (* we should mark the operator as primitive for PT *)
                    lex;
                    (if lex.symb <> lex.symbols.idf then
                        SyntaxError
                if)if);
                lex.symb -> op;
                lex; 
                pFactor -> rE[];
                (lE[],op,rE[]) -> BetaBinaryExp -> lE[];
                restart Loop
            if)
       #);
     pFactor: ExpParser
       (* textConst, IntegerConst, NoneExp, 
        *          * not EXP, RepetitionSlice,
        *          * Transaction, UnaryPrimitiveExp
        *          * Are they alle sub of exp/term?
        *          *)
       (#
       do pTransaction -> Term -> lE[]
       #);     

     pTransaction:
       (* T:: ObjEval 
        *   | ComputedEval     - R.S!
        *   | ObjRef           - R.S[]
        *   | EvalList         - (E1, E2,E3)
        *   | StrucRef         - R.S##
        *   | Primitive        - tos foo
        *   | Address          - @@ X
        * ObjEval :: InsItem   - R.P(# ... #) 
        *          |           - (# ... #) 
        *          | Reference 
        * Reference:: ObjDen    - R.P
        *           | DynObjGen - R.P&
        * ObjDen:: AttDen       - R.P
        *)
       (# tra: ^Transaction;
          op: @integer; lE: ^expr;
       do 'pTransaction'->trace;
          (if lex.symb 
           // lex.symbols.idf // lex.symbols.begin // lex.symbols.thisObj 
           // lex.symbols.textSy then
              pObjEval -> tra[];
              (if lex.symb 
               // lex.symbols.objRef then
                  (*tra[] -> pReference -> tra[];*)
                  lex
               // lex.symbols.strucVar then
                  (*tra[] -> pStructureRef -> tra[];*)
                  lex
              if);
           // lex.symbols.nott then 
              lex.symb -> op;
              lex;
              pFactor -> lE[];
              (*(op,lE[]) -> pUnaryExp -> tra[]*)
           // lex.symbols.const then
              'pTransaction:const'->trace;
              lex.sym[] -> BetaLexem -> BetaConst -> tra[];
              'const:'->puttext; tra.dopt -> dumpTN;
              lex;
           // lex.symbols.charSy then
              lex.sym[] -> BetaLexem -> aChar -> tra[];
              lex;
           // lex.symbols.textSy then
              lex.sym[] -> BetaLexem -> aText -> tra[];
              lex;
           // lex.symbols.noneSy then
              noneValue -> tra[];
           // lex.symbols.leftBrack then
              lex; 
              pEvaluationList -> tra[]; 
              (if lex.symb = lex.symbols.dot then 
                  (* We come here in sitations like
                   * (if (e).f ...
                   *)
                  lex;
                  tra[] -> pComputedRemote -> tra[];
                  (if lex.symb 
                   // lex.symbols.begin then
                      (* '\n!!!!! In module "' -> puttext;           
                       thisModuleName[] -> puttext;
                       '", ComputedRemote as super may not work!\n' -> puttext;
                       3 -> lex.printlines;
                       newline;
                       *)
                      (*tra.markAsSuper;*)
                      (# PD: ^PatternDen; AD: ^AttributeDenotation; OE: ^ObjEval
                      do &PatternDen[] -> PD[];
                         &AttributeDenotation[] -> AD[];
                         &ObjEval[] -> OE[];                         
                         tra[] 
                           -> pComputedRemoteAsDenotation
                           (*-> AD.NA[]
                           -> AD.append;*);
                         AD[] -> PD.AD[] -> PD.append;
                         PD[] -> pObjectDesc -> ObjEval -> OE[];
                         OE[] -> tra[]
                      #)
                   // lex.symbols.leftSquare then
                      '\npTransaction:Got Indexed "[exp]" after:  ' -> puttext; 
                      tra.dopt -> putline;
                      lex;
                      (if true then 'Bingo'->putline;
                          evaluation;
                          'banko' -> putline;
                          (if lex.symb = lex.symbols.rightSquare then
                              lex
                           else
                              201 -> SyntaxError
                          if)
                       else
                          tra[]
                            -> pComputedRemoteAsDenotation
                            -> Indexed
                      if)
                  if)
              if)
           // lex.symbols.new then
              lex;
              pDynamicObjectGeneration -> tra[]
           // lex.symbols.prim then 
              lex;
              (if lex.symb = lex.symbols.idf then
                  lex;
                  pFactor -> tra[]
              if)
           // lex.symbols.adr then
              lex;
              pFactor -> tra[]
           else 
              200->syntaxError;
              (*
              (15
              ,(lex.symbols.idf,lex.symbols.thisObj,lex.symbols.const,lex.symbols.charSy
              ,lex.symbols.textSy,lex.symbols.leftBrack,lex.symbols.new)
              ,(lex.symbols.semicolon)) -> syntaxError;*)
              &Transaction[] -> tra[]
          if)
       exit tra[]
       #);
     pObjEval:
       (# objEV: ^ObjEval; OS: ^BetaObjectSpecification; PD: ^PatternDen;
       do pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
          OS[] -> ObjEval -> objEV[]
       exit objEv[]
       #);
     pEvaluationList:
       (# tra: ^EvaluationList
       do
       exit tra[]
       #);
     pDynamicObjectGeneration:
       (# tra: ^DynamicObjectGeneration
       enter tra[]
       do
       exit tra[]          
       #);
     pComputedRemote:
       (# tra: ^EvaluationList; CR: ^ComputedRemote
       enter tra[]
       do
       exit CR[]          
       #);
     pComputedRemoteAsDenotation:
       (# tra: ^EvaluationList; CRD: ^ComputedRemoteAsDenotation
       enter tra[]
       do
       exit CRD[]          
       #);
     pBetaDecl:
       (# dcl: ^BetaDecl; symb: ^Text; NS: ^NameDecls; IT: ^Item
       do 'pBetaDecl' -> trace;
          pNameDecls -> NS[]; 
          (if lex.symb = lex.symbols.colon then
              lex;
              'pBetaDecl:colon'->trace;
              (if lex.symb
               // lex.symbols.object then
                  lex;
                  pStaticItem -> IT[];
                  (NS[],IT[]) -> BetaDataItem -> dcl[]
               // lex.symbols.ref then                  
                  lex;
                  pDynamicItem -> IT[];
                  (NS[],IT[]) -> BetaDataItem -> dcl[]
               // lex.symbols.lt then
                  lex;
                  NS[] -> pVirtualPattern -> dcl[]
               // lex.symbols.colon then (* X:: *)
                  lex; 
                  (if lex.symb = lex.symbols.lt then  (* X::< *)
                      lex;
                      NS[] -> pFurtherBinding -> dcl[]
                   else (* X :: *)
                      NS[] -> pFinalBinding -> dcl[] 
                      (* potential syntax problem here 
                       *   V: # (# #)
                       * does not give a syntax error
                       * but should not be caught here
                       *)
                  if)
               // lex.symbols.leftSquare then
                  lex;
                  pRepetition -> IT[]
               // lex.symbols.strucVar then
                  lex;
                  pvarPtn -> IT[]
               else
                  'pAttribute:idf:colon:PTN'->trace;
                  NS[] -> pPattern -> dcl[];
              if)
           else
              111 -> SyntaxError
          if)
       exit dcl[]
       #);
     pNameDecls:
       (# NS:  ^NameDecls
       do 'pNameDecls'->trace;
          NameDecls -> NS[];
          L:
            (#
            do pNameDecl -> NS.append;
               (if Lex.Symb = Lex.Symbols.Comma Then 
                   Lex;
                   restart L
            if)#)
       exit NS[]
       #);
     pNameDecl:
       (# N: ^NameDecl
       do 'pNameDecl'->trace;
          (if Lex.Symb = Lex.Symbols.Idf Then
              'pNameDecl:idf'->trace;
              Lex.sym[] -> NameDecl -> N[];
              Lex;
           else
              199 -> SyntaxError
          if)
       exit N[]
       #);
     pStaticItem:
       (# nl:  ^NameList;  IT: ^StaticItem; 
          PD: ^PatternDen;  OS: ^BetaObjectSpecification
       enter nl[]
       do 'pStaticItem'->trace;
          pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
          OS[] -> StaticItem -> IT[]
       exit IT[]
       #);     
     pDynamicItem:
       (# nl:  ^NameList; IT: ^DynamicItem;  PD: ^PatternDen;
       do 'pDynamicItem' -> trace;
          pPatternDen -> PD[] -> DynamicItem -> IT[]
       exit IT[]
       #);
     pRepetition:
       (# IT: ^StaticItem; 
       do
       exit IT[]
       #);
     pVarPtn:
       (# IT: ^StaticItem; 
       do
       exit IT[]
       #);
     pPattern:
       (# NS: ^NameDecls; OD: ^ObjectDesc; dcl: ^BetaDecl;
       enter NS[]
       do 'pPattern'->trace;
          pPatternDen -> pObjectDesc -> OD[];
          (NS[],OD[]) -> BetaPattern -> dcl[];
       exit dcl[]
       #);
     pVirtualSpec:
       (# PD: ^PatternDen; OS: ^BetaObjectSpecification;
       do pPatternDen -> PD[];
          (if lex.symb = lex.symbols.begin then
              PD[] -> pObjectDesc -> OS[]
           else
              PD[] -> OS[]
          if);
       exit OS[]
       #);
     pVirtualPattern:
       (# NS: ^NameDecls; PD: ^PatternDen; dcl: ^BetaDecl; 
          OS: ^BetaObjectSpecification;
       enter NS[]          
       do 'pVirtualPattern'->trace;
          pVirtualSpec -> OS[];
          (NS[],OS[]) -> BetaVirtualPattern -> dcl[];
       exit dcl[]
       #);
     pFurtherBinding:
       (# NS: ^NameDecls; dcl: ^BetaDecl; OS: ^BetaObjectSpecification;
       enter NS[]
       do 'pFurtherBinding'->trace;
          pVirtualSpec -> OS[];
          (NS[],OS[]) -> FurtherBinding -> dcl[];
       exit dcl[]
       #);
     pFinalBinding:
       (# NS: ^NameDecls; dcl: ^BetaDecl; OS: ^BetaObjectSpecification;
       enter NS[]
       do 'pFinalBinding'->trace;
          pVirtualSpec -> OS[];
          (NS[],OS[]) -> FinalBinding -> dcl[];
       exit dcl[]
       #);
     pObjectDesc:
       (# sup: ^PatternDen; symb: ^Text;  OD: ^ObjectDesc;
          att: ^Attributes; acp: ^ActionPart;
       enter sup[]
       do 'pObjectDesc'->trace;
          (if lex.symb = lex.symbols.begin then
              lex;
              'pObjectDesc:begin'->trace;
              pAttributes -> att[];
              pActionPart -> acp[];
              (sup[],att[],acp[]) -> ObjectDesc -> OD[];
              (if lex.symb = lex.symbols.end then
                  lex
               else
                  113 -> syntaxError
          if)if)
       exit OD[]
       #);
     pPatternDen:
       (# ptnDen: ^PatternDen; 
       do 'pPatternDen'->trace;
          true -> pAttributeDenotation -> PatternDen->ptnDen[]
          (*lex*)
       exit ptnDen[]
       #);
     pAttributeDenotation:
       (# B: @Boolean; attDen: ^AttributeDenotation; 
       enter B
       do 'pAttributeDenotation'->trace;
          (if lex.symb = lex.symbols.idf then
              lex.sym[] -> BetaName -> AttributeDenotation -> attDen[];
              lex;
           else
              '' -> BetaName -> AttributeDenotation -> attDen[]
          if)
       exit attDen[]
       #);
     trace:
       (# S: ^Text
       enter S[]
       do (if doTrace then
              S[] -> puttext; ':'->put; '\t'->put;
              lex.symb -> putint; ' ' -> put;
              lex.symb -> lex.symbols.asText -> puttext;
              ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
              inner trace
          if)
       #);

     prop: ^NewProperty;
  enter prop[]
  do (if doTrace then '**** parseStdBeta:'->dumpT if);
     prop.args.scanSons
     (# INV: ^Invocation; 
     do current[] -> INV[];
        INV.scanSons
        (# S: ^StringObj; 
        do (if current.isStringLiteral then
               current[] -> S[];
               (if doTrace then
                   S.doPT -> dumpTN;
               if);
               S[] -> openBetaModule
     if)#)#)
  #);
trace:
  (# S: ^Text
  enter S[]
  do (if true then
         S[] -> puttext; ':'->put;
         lex.symb -> putint; ' ' -> put;
         lex.symb -> lex.symbols.asText -> puttext;
         ' "'->puttext; lex.sym[] -> puttext; '"\n'->puttext;
         inner trace
     if)
  #);

openFragmentFile:
  (# S: ^StringObj; StdPath,fragPath: ^text;
     FD: ^FragmentDir;
     NM: ^BetaName;
     betaLib: ^Item;
  enter S[]
  do '$(BETALIB)' -> expandEnvVar -> StdPath[] ;
     (if stdpath[] = none then '!!!! Di not find BETALIB!'->putline if);
     '**** BETALIB: ' -> puttext; StdPath[] -> putline;
     'A fragment' -> BetaName -> NM[];
     '/' -> (StdPath.copy).append -> fragPath[];
     S.T[] -> fragPath.append -> fragPath[];
     (NM[],fragPath[],'',true) -> FragmentDir -> FD[];
     (NM[],FD[]) -> FragmentModule -> betaLib[];
     '\n**   FD.dopt:'->dumpTN;
     FD.doPT -> putline;
     '\n**   betaLIB:'->dumpTN;
     betaLib.doPT->dumpT;
  #);
