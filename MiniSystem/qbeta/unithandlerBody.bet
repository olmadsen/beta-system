ORIGIN 'qunithandler';
---BaseVectorLib:Attributes--
add:
  (# BV: ^BaseVector
  enter BV[]
  do (for i: noOfBaseUnits repeat 
          theBase[i] + BV.theBase[i] -> theBase[i];
          (if theDim[i][] = none then
              BV.theDim[i][] -> theDim[i][]
          if);
     for);
     BV.convFactor * convFactor -> convFactor
  #);
minus:
  (# BV: ^BaseVector
  enter BV[]
  do (if false then
         '**** BaseVector: left:' -> putline;
         print;
         '**   right: ' -> putline;
         BV.print
     if);
     (for i: noOfBaseUnits repeat 
          theBase[i] - BV.theBase[i] -> theBase[i];
          (if theDim[i][] = none then
              BV.theDim[i][] -> theDim[i][]
          if);
     for)
  #);
mult:
  (# C: @integer
  enter C
  do (for i: noOfBaseUnits repeat 
          theBase[i] * C -> theBase[i]
     for)
  #);
rootN:
  (* In general we have a unit "u"^(left,right)
   * where left  = 1 and right is a positve integer
   * like "m*m"^(1/2), "m*m*m"^(1/3) or similar
   * 
   * all base units in the vector must be a multiply
   * of right or zero
   *)
  (# rootNerror:< 
       (# M: ^text
       enter M[]
       do inner
       #);
     numerator,denumerator: @integer
  enter(numerator,denumerator)
  do (if false then
         '**** baseVector:rootN:'->puttext;
         numerator -> putint; ' ' -> put; denumerator -> putint;
         newline;
     if);
     (if numerator <> 1 then
         'numerator is not 1 (one)' -> rootNerror
     if);
     (for i: noOfBaseUnits repeat
          (if (theBase[i] mod denumerator) = 0 then
              theBase[i] div denumerator -> theBase[i]
           else
              'value of a base unit is not a multiply of the denumerator'
                -> rootNerror
     if)for);
     (*print*)
  #);
---BaseVector_equal:doPart---
do (if traceUnit then
       'BaseVector:equal:'->dumpTN; print->dumpTN; BV.print->dumpTN
   if);
   true -> value;
   (for i: noOfBaseUnits repeat 
        (theBase[i] = BV.theBase[i]) and value -> value
   for);
   (if false and (BV.convFactor <> convFactor) then
       '!!!! Conversion factors differ: ' -> putline;
       'source: ' -> puttext; BV.print -> putline;
       'destination: ' -> puttext; print -> putline;
       nonMatchingCV
   if)
---BaseVector_print:doPart---   
do (if traceUnit then 
       '**** BaseVector:print:noOfBaseUnits:'->puttext;
       noOfBaseUnits-> putint; newline
   if);
   'Cnv[' -> T.puttext; convFactor -> T.putReal; ']' -> T.put;
   (for i: noOfBaseUnits repeat
        (if theBase[i] <> 0 then
            (if i 
             // TimeInx then 'Time[' -> T.puttext
             // LengthInx then 'Lgth[' -> T.puttext
             // MassInx then 'Mass[' -> T.puttext
             // ElectInx then 'Elec[' -> T.puttext
             // TempInx then 'Temp[' -> T.puttext
             // SubstanceInx then 'Subs[' -> T.puttext
             // LuminousInx then 'Lumn[' -> T.puttext
             // 8 then 'Unit[' -> T.puttext
             else
                (*'Inx = ' -> T.puttext;  i -> T.putint; ':' -> T.put;*)
                L:
                  unitTable.scan
                  (#
                  do (if i = current.baseInx then
                         current.dim.sig.dopt -> T.puttext; '[' -> T.put;
                         leave L
                     if)
                  #)
            if);
            theBase[i] -> T.putint; ']' -> T.put
        if)
   for);
   T.newline
---asSymbols:doPart---   
do (for i: noOfBaseUnits repeat
        (if theBase[i] <> 0 then
            (if true 
             // (1 <= i ) and (i <=8) then
                (if theDim[i][] = none then 
                    'none:a:i'->dumpT; i -> dumpI; newline;
                    'NoDim'-> T.puttext
                 else
                    (if theDim[i].name[] = none then 
                        'noName'->T.puttext
                     else
                        (if theDim[i].name.T[] = none then
                            'none:C'->putline if);
                        theDim[i].name.T[] -> T.puttext
                if)if)
             // 8 then 'U' -> T.puttext
             else
                (*'Inx = ' -> T.puttext;  i -> T.putint; ':' -> T.put;*)
                L:
                  unitTable.scan
                  (#
                  do (if i = current.baseInx then
                         current.dim.sig.dopt -> T.puttext; '[' -> T.put;
                         leave L
                     if)
                  #)
            if);
            '[' -> T.put; theBase[i] -> T.putint; ']' -> T.put
        if)
   for);
   '*[' -> T.puttext; convFactor -> T.putReal; ']' -> T.put;
   T.newline
---unitTableLib:attributes---
checkIfSame:
  (* NOT USED! *)
  (# lU,rU: ^text; sameDim: @boolean;
     lDim,rDim: ^Decl;
     lCF,rCF: @real
  enter(lU[],rU[])
  do (if traceUE then
         '**** unitTable:checkIfSame:lU: "' -> puttext; lU[]->puttext;
         '" rU: "' -> puttext; rU[] -> puttext; '"' -> putline;
     if);
     lU[] -> FindInAll
     (#
     do current.dim[] -> lDim[]
     #);
     rU[] -> FindInAll
     (#
     do current.dim[] -> rDim[]
     #); 
     lDim[] = rDim[] -> sameDim;
     (if traceUE then
         '**   checkIfSame:sameDim: ' -> puttext; sameDim -> putBoolean;
         newline
     if)
  exit sameDim
  #);
findU: find
  (# isBase: @boolean; CF: @real
  do current.isBaseDim -> isBase;
     current.convFactor -> CF
  exit(isBase,CF)
  #);
---dimTableAdd:doPart---
do (if traceUE then
       '**** dimTable:add: '-> puttext; prop.dopt -> putline;
   if);
   (prop.enclosingObjectGenerator).father[] -> DI[];

   (if traceUE then
       'Dimension: ' -> puttext;
       DI.sig.dopt -> putheadN;
   if);
   (if noOfBaseDims = 0 then 8 -> noOfBaseDims; if);   
   (if (top + 1 -> top) > DU.range then DU.range -> DU.extend if);   
   (DI[],prop[]) -> dimElm -> DU[top][];
   DU[top].decodeDimProp;
---unitTableAdd:doPart---
do L:
     (# N: ^ObjectGenerator; dim: ^Decl; theDimElm: ^dimTable.DimElm;
        findDimElm:
          (# dElm: ^dimTable.dimElm
          do (if traceUnit then
                 '**** unitTableAdd:findDimElm:dim:'->dumpTN;
                 dim.dopt -> putHeadN
             if);
             L:
               dimTable.scan
               (#
               do (if traceUnit then
                      '**** findDimElm:scan:'->dumpT;
                      current.print; newline
                  if);
                  (if current.dim[] = dim[] then
                      (if traceUnit then
                          '**   found:dimElm:'-> dumpT; current.print;
                      if);
                      current[] -> dElm[];
                      leave L
                  if)
               #)
          exit dElm[]
          #)
        
     do (if traceUnit then
            '**** prop: ' -> puttext; prop.dopt -> puttext;
            ' in:sig: ' -> puttext;
            (prop.enclosingObjectGenerator).sig.dopt ->puttext;
            ' arg1: ' -> puttext; 
            prop.getSArg1 -> puttext;
            newline;
        if);
        (if noOfBaseUnits = 0 then 8 -> noOfBaseUnits; if);   
        (if '$' -> (prop.getSarg1).equal then
            leave L
        if);
        (* perhaps check that father is an OG defining a dimension
         * and prepare for dimensions being patterns
         *)
        (prop.enclosingObjectGenerator).enclosingObjectGenerator -> N[];
        N.father[] -> dim[]; 
        (if withDimProp then 
            (if (findDimElm -> theDimElm[]) = none then
                prop[] -> warning
                (#
                do 'no %dimension found'->msg
            #)if)
        if);
        (if traceUE then 'Dimension: '->puttext; dim.sig.dopt -> putline if);
        (prop.enclosingObjectGenerator).father[] -> unitPtn[]; 
        (if (top + 1 -> top) > DU.range then DU.range -> DU.extend if);
        (dim[],unitPtn[],prop[],theDimElm[]) -> unitElm -> DU[top][];
        DU[top].decodeProp
     #)
---dimTable_dimElm_LIB:attributes---
decodeDimProp:
  (# dimN: ^text
  do (if traceUnit then
         '**** decodeDimProp: '->puttext; prop.dopt->putline
     if);
     true -> isBaseDim; (* may be false beelow *)
     prop.args.scanSons
     (# INV: ^Invocation;  i: @integer;
     do current[] -> INV[];
        i + 1 -> i;
        (if false then
            i -> putint; ':'->put; current.dopt -> puttext; newline;
        if);
        
        INV.scanSons
        (#
        do (if i
            // 1 then 
               (if true 
                // current.isNameLiteral 
                // current.isStringLiteral then
                   current[] -> name[];                   
                   UStop + 1 -> UStop;;
                   name.T.copy -> US[UStop][];
                else
                   '!!!! decodeDimProp:error:'->dumpT; prop.doPT->dumpTN;
               if)
            else
               (if current.isStringLiteral then
                   current[] -> dimExp[];
                   UStop + 1 -> UStop;
                   dimExp.T.copy -> US[UStop][];
                else
                   prop[] -> Warning
                   (#
                   do 'The argument "' -> msg; current.doPT -> msg;
                      '" of %dimension\n' -> msg;
                      '**   must be a String literal defining a dimension'
                        -> msg
               #)if);
               false -> isBaseDim
           if)
     #)#);
     dim.sig.dopt -> dimN[];
     (if isBaseDim then
         (if true 
          // 'Dimension' -> dimN.equalNCS 
          // 'Unit' -> dimN.equalNCS then
             8 -> baseInx
          // 'Time' -> dimN.equalNCS then
             1 -> baseInx
          // 'Length' -> dimN.equalNCS then
             2 -> baseInx
          // 'Mass' -> dimN.equalNCS then
             3 -> baseInx
          // 'ElectricCurrent' -> dimN.equalNCS then
             4 -> baseInx                         
          // 'ThermodynamicTemperature' -> dimN.equalNCS then
             5 -> baseInx                         
          // 'AmountOfSubstance' -> dimN.equalNCS then
             6 -> baseInx
          // 'LuminousImtenmsity' -> dimN.equalNCS then
             7 -> baseInx
          else
             (if true then
                 '!!!! OBS! no matching base dimension: "' -> puttext;
                 dimN[] -> puttext; 
                 '" with dim: ' -> puttext; prop.dopt -> putline;
                 unitTable.print
             if);
             (if traceUnit then
                 '**   decoDimProp:X:'->dumpTN; dimTable.print
             if);
             L: 
               dimTable.scan
               (#
               do current.print;
                  (if (current.dim.sig.dopt -> dimN.equalNCS) then
                      (if traceUnit then
                          '\n**** found:dim:'->dumpT; current.baseInx -> dumpI;
                          current.dim.sig.doPt->dumpTN;
                      if);
                      (if current.baseInx = 0 then
                          noOfBaseDims + 1 -> noOfbaseDims -> current.baseInx
                      if);
                      current.baseInx -> baseInx;
                      leave L
     if)#)if)if)
  #)
---unitTable_unitElm_LIB:attributes---
decodeProp:
  (# n: @integer; dimN: ^text; UT: ^UnitTree; BV: ^BaseVector
  do (if traceUE then
         '**** decodeUnitProp: '->puttext; prop.dopt->putline
     if);
     prop.args.scanSons
     (# INV: ^Invocation; 
     do current[] -> INV[];
        INV.scanSons
        (# C: ^lexem
        do (*current.dopt -> puttext; ',' -> put;*)
           current[] -> C[];
           (if true 
            // current.isNameLiteral 
            // current.isStringLiteral then
               UStop + 1 -> UStop;;
               C.T.copy -> US[UStop][];
            // current.isConstLiteral then
               n + 1 -> n;
               C.T.setPos; C.T.getReal -> convFactor
     if)#)#);
     (if traceUE then UStop -> putint; ' ' -> put; n -> putint if);
     (* a base dimension has a form like
      *    %unit "m", i.e only one unit
      * a derived dimension has a form like
      *    %unit "MpS", "m*s^-1", "m/s", 1
      *        i.e. also a defintion in the form of other units 
      *        and a conversitaion factor of 1 (one)
      *)
     UStop = 1 -> isBaseDim; (* weak spec of base dim! *)
     (if traceUE and isBaseDim then ' base dimension '->puttext if);
     (if isBaseDim then
         (if convFactor = 0 then
             (*'**** OBS! No conversion factor: '->puttext; print;*)
             (*true -> isPrimaryUnit;
             1.0 -> convFactor*)
          else
             (* non base unit of base dim *)
             (if convFactor = 1 then true -> isPrimaryUnit if)
         if)
      else 
         (if convFactor = 1 then
             (* for derived dimensions, we must set a 
              * conversion factor of 1 (one) for the base unit
              *)
             true -> isPrimaryUnit
          else
             (* best to compute here, but some of the dimensions
              * and units have not yet been added to the table; 
              * a seperate scan is necessary
              * Now we just compute it when needed below
              '**** Derived dim: '
              'compute conv factor of non base unit: ' 
              -> puttext; US[2][] -> putline;
              prop.dopt -> putline;
              US[2][] -> parseUnit -> UT[]; UT.print->putline;
              UT[] -> mkBaseVector -> BV[];
              BV.print
              *)
     if)if);
     dim.sig.dopt -> dimN[];
     (if traceUE then ' baseDim:'->puttext; dimN[] -> putline if);
     (if isBaseDim then
         (if true 
          // 'Dimension' -> dimN.equalNCS 
          // 'Unit' -> dimN.equalNCS then
             8 -> baseInx
          // 'Time' -> dimN.equalNCS then
             1 -> baseInx
          // 'length' -> dimN.equalNCS then
             2 -> baseInx
          // 'Mass' -> dimN.equalNCS then
             3 -> baseInx
          // 'ElectricCurrent' -> dimN.equalNCS then
             4 -> baseInx                         
          // 'ThermodynamicTemperature' -> dimN.equalNCS then
             5 -> baseInx                         
          // 'AmountOfSubstance' -> dimN.equalNCS then
             6 -> baseInx
          // 'LuminousImtenmsity' -> dimN.equalNCS then
             7 -> baseInx
          else
             (if false then
                 '!!!! OBS! no matching base dimension: "' -> puttext;
                 dimN[] -> puttext; 
                 '" with unit: ' -> puttext; prop.dopt -> putline;
                 unitTable.scan(#do current.print#);
             if);
             L: 
               unitTable.scan
               (#
               do (if (current.dim.sig.dopt -> dimN.equalNCS) then
                      (if false then
                          '\n**** found:unit:'->dumpT; current.baseInx -> dumpI;
                          current.dim.sig.Dopt->dumpTN;
                      if);
                      (if current.baseInx = 0 then
                          noOfBaseUnits + 1 -> noOfBaseUnits -> current.baseInx
                      if);
                      current.baseInx -> baseInx;
                      leave L
     if)#)if)if);
     (*     '**   baseInx: ' -> puttext; baseInx -> putint; newline*)
  #)
---dimTable_find:dopart--
do (if traceUE then '**   findDim: '->puttext; U[] -> putline;  if);
   L:
     scan
     (# 
     do (if traceUE then '**   current: ' -> puttext; current.print; if);
        (if (current.US[1][] <> none) and (U[] -> current.US[1].equalNCS) then
            (if traceUE then
                '**   dimTable:find:found: "' -> puttext;
                U[] -> puttext; '" -> ' -> puttext; current.print;
            if);
            current[] -> this(find).current[];
            inner find;
            leave L
     if)#);
---unitTable_find:dopart--
do (*'*** findUnit:'->puttext; U[] -> putline; *)
   L:
     scan
     (# 
     do (*'**   current: ' -> puttext; current.print;*)
        (if U[] -> current.US[1].equalNCS then
            (if traceUE then
                '**   found: "' -> puttext;
                U[] -> puttext; '" -> ' -> puttext; current.print;
            if);
            current[] -> this(find).current[];
            inner find;
            leave L
        if);
     #);
   (if this(find).current[] = none then 
       U[] -> dimTable.find
       (#
       do (if current[] <> none then
              (if traceUE then 
                  '**** find:dimFind:got: ' -> puttext;
                  current.print
              if);
          if)
       #)
   if);
---unitTable_findUOG:dopart---
do current.unit.OG[] -> uOG[];
---unitTable_findInAll:doPart---
do U.scanAll(#do (if ch // '(' // ')' then else ch -> U1.put if)#);
   U1[] -> U[];
   L:
     scan
     (# 
     do (for i: current.UStop  repeat
             (if U[] -> current.US[i].equalNCS then
                 (if traceUE then
                     '**   findInAll:found: "' -> puttext;
                     U[] -> puttext; '" -> ' -> puttext;
                     current.print;
                 if);
                 current[] -> this(findInAll).current[];
                 inner findInAll;
                 leave L
     if)for)#)
---unitTable_findUOGall:dopart---
do current.unit.OG[] -> uOG[]   
---unitTable_scan:dopart---
do (for i: top repeat
        DU[i][] -> current[];
        inner scan
   for)  
---dimTable_print:descriptor---
(#
do '**** DimTable: ' -> putline;
   (for i: top repeat DU[i].print for);
#)
---unitTable_print:descriptor---
(#
do '**** UnitTable: ' -> putline;
   (for i: top repeat DU[i].print for)
#)
---dimTable_dimElm_print:descriptor---
(#
do 'Dimension: "' -> puttext; dim.sig.dopt -> puttext;
   '" symbol: \''-> puttext; 
   (if name[] = none then
       'none'-> puttext;
    else
       name.dopt->puttext; 
   if);
   '\''->put;   
   (if isBaseDim then
       ' base:' -> puttext
    else
        ' derived: ' -> puttext; dimExp.dopt -> puttext;
   if);
   
   (if false then
       ' US: ' -> puttext;
       (for i: UStop repeat
            (if US[i][] = none then
                'US[i] is none:'->puttext
             else
                US[i][] -> puttext;  ' ' -> put;
            if)
       for);
       ' baseInx: '->puttext; baseInx -> putint;
   if);
   newline
#)
---unitTable_unitElm_print:descriptor---
(#
do (if isBaseDim then
       'Unit/Base Dimension: "' -> puttext
    else
       'Unit/Derived Dimension: "' -> puttext; 
   if);
   dim.sig.dopt -> puttext;
   (if (convFactor = 1.0) 
       or isBaseDim and (convFactor = 0.0) then
       '" base unit: "' -> puttext;
       unit.sig.dopt -> puttext;
       '" ' -> puttext;
    else
       '" not base unit: ' -> puttext;
   if);
   (for i: UStop repeat 
        '"'->put; US[i][] -> puttext; '"'-> put; ' ' -> put 
   for);
   (if convFactor <> 0 then 
       'convFac: ' -> puttext;
       convFactor -> putReal
   if);
   (if false then
       ' ' -> put; prop.dopt -> putline
   if);
   newline;
#)
---unitTable_findCheck:doPart---
do (if traceUE then
       '**** unitTable.findandCheck:lU: "'->puttext; lU[]->puttext;
       '" rU: "' -> puttext; rU[] -> puttext; '"' -> putline
   if);
   lU[] -> findInAll
   (#
   do current.dim[] -> lDim[];
      current.convFactor -> lCF
   #);
   rU[] -> findInAll
   (#
   do current.dim[] -> rDim[];
      current.convFactor -> rCF
   #);
   lDim[] = rDim[] -> sameDim;
   (if traceUE then
       '**   sameDim: ' -> puttext; sameDim -> putBoolean; newline
   if)   
---mkBaseVector:doPart---
do (# getConstLiteral:
        (# op: ^text; V: @integer; isNeg: @boolean
        enter op[]
        do (if traceUE then 
               '**** getConstLiteral: ' -> puttext; op[] ->puttext if);
           (if (1 -> op.inxGet) = '-' then
               true -> isNeg; 
               2 -> op.setpos;
           if);
           op[] -> readNumber -> V
        exit V
        #);      
   do (if traceUnit then 
          '**** mkBaseVector: ' -> puttext; true -> T.print -> dumpT; 
          'op:'->dumpT; T.op[] -> dumpTN;
      if);
      (* perhaps: if withDimProp use mkBaseVectorDim else mkBaseVectorUnit ?
       * T is a unit tree -> perhaps convert to dim-tree
       * or have parser make a dim-tree?
       * "m" * "s" ^-1 / "A"
       * when we find "A", we get "L*L" from dimTable, and must proceed with
       * dimTable and not untTable
       *)
      
      (if T.token
       // mult then
          (if traceUnit then 
              '**** mkBaseVector:mult:' ->dumpT; true -> T.print -> dumpTN;
              '**   left:'->dumpT; true -> T.left.print->dumpTN;
              '**   right:'->dumpT; true -> T.right.print->dumpTN;
          if);
          T.left[] -> mkBaseVector -> BVl[];
          T.right[] -> mkBaseVector -> BVr[];
          (if traceUnit then 
              '**** mkBaseVector:mult:left:' ->dumpT; 
              true -> T.left.print->dumpTN; 
              BVl.print -> dumpTN;
          if);
          (if traceUnit then 
              '**** mkBaseVector:mult:right:' ->dumpT; 
              true -> T.right.print->dumpTN; 
              BVr.print -> dumpTN;
          if);          
          BVr[] -> BVl.add;          
          (if traceUnit then 
              '**** mkBaseVector:mult:left:add:'->dumpT; true->T.print->dumpTN;
              '**   left:'->dumpT; true -> T.left.print->dumpTN;
              '**   right:'->dumpT; true -> T.right.print->dumpTN; 
              BVl.print -> dumpTN;
          if);
       // divv then
          T.left[] -> mkBaseVector -> BVl[];
          T.right[] -> mkBaseVector -> BVr[];
          BVr[] -> BVl.minus
       // expT then 
          T.left[] -> mkBaseVector -> BVl[];
          (if traceUnit then
              '**   mkBaseVector:expT: ' -> puttext; T.print ->putline;
              BVl.print  -> puttext;
          if);
          (if traceUnit then
              T.print -> putline;
              T.right.print->putline;
              T.right.op[]->putline;
          if);
          (if '/' -> T.right.op.equal then
              (* we assume T.right = (1/2) but should be checked *)
              (T.right.left.op[]->getConstLiteral
              ,T.right.right.op[]->getConstLiteral)
                -> BVl.rootN
              (# rootnError::
                   (#
                   do '\n\n!!! WARNING:'-> puttext;
                      M[] -> putline; '    in: '  -> puttext;
                      T.print -> putline;
                      '\n! This message must be improved!'-> putline
              #)#)
           else
              T.right.op[] -> getConstLiteral -> BVl.mult
          if);
       // idf then
          (if traceUnit then
              '**   MBK:idf: '->puttext; T.op[] -> putline; 
          if);
          L: 
          (if withDimProp then
              (if traceUnit then
                  '**** mkBaseVector:findDimElm:A:'->dumpT; T.op[] ->dumpTN if);
              T.op[] -> findDimElm
              (# noDimensionFound::
                   (#
                   do (if true or traceUnit then
                          '!!!! No dimension found with symbol: '->puttext; 
                          T.print->putline
                      if);
                      notValidUnit;
                      leave L
                   #);
                 BV: ^BaseVector
              do (if traceUnit then
                     '**   mkBaseVector:findDimElm:B:'->dumpT; current.print;
                     'isBaseDim:'->dumpT; current.isBaseDim->putboolean; newline
                 if);
                 (if current.isBaseDim then
                     BaseVector -> BVl[];
                     (if (0 < current.baseInx) 
                         and (current.baseInx <= BVL.theBase.range) then
                         current[] -> BVL.theDim[current.baseInx][];
                         1 -> BVl.theBase[current.baseInx]
                      else
                         '!!!! index error: ' -> puttext;
                         current.baseInx -> putint; ' ' -> put;
                         BVL.theBase.range -> putint; newline
                     if);
                     (if isUnit then theConvFactor -> BVL.convFactor if);
                  else
                     current.US[2][]
                       -> parseUnit 
                       -> mkBaseVector
                       -> BVl[];
                     (if isUnit then
                         theConvFactor -> BVL.convFactor;
                      else (* what if isUnit/not isUnit?*)
                         current.US[2][] 
                           -> parseUnit 
                           -> mkBaseVector 
                           -> BV[];
                         BV.convFactor -> BVl.convFactor;
                 if)if);
              #);
           else
              T.op[] -> unitTable.find
              (* T.op is a unit -> current = unitElm for T.op
               * withDimProp need dimElm for dimension of T.op
               *)
              (# theDim: ^text; UT: ^UnitTree; BV: ^BaseVector
              do current.dim.sig.dopt -> theDim[];
                 (if traceUnit then
                     '**   MBK:idf:unit: ' -> puttext; T.op[] -> puttext;
                     ' thedim: ' -> puttext; theDim[] ->putline;
                     current.print;
                     '**   dim: ' -> puttext; current.dim.sig.dopt -> putline;
                     current.dim.dopt -> putline;
                 if);
                 (if withDimProp then
                     (if current.theDimElm.isBaseDim then
                         '**  baseDim'->putline;
                         BaseVector -> BVl[];
                         1 -> BVl.theBase[current.baseInx];
                         (*current.convFactor -> BVL.convFactor;*)
                      else
                         '**  derivedDim'->putline;
                         current.theDimElm.US[2][]
                           -> parseUnit 
                           -> mkBaseVector (* perhaps mkBaseDimVector ? *)
                           -> BVl[];
                         (if current.isPrimaryUnit then
                             (*current.onvFactor -> BVL.convFactor;*)
                          else
                             current.thedimElm.US[2][] 
                               -> parseUnit 
                               -> UT[]; 
                             UT[] 
                               -> mkBaseVector 
                               -> BV[];
                             BV.convFactor -> BVl.convFactor;
                     if)if)
                  else
                     (if current.isBaseDim then
                         BaseVector -> BVl[];
                         1 -> BVl.theBase[current.baseInx];
                         current.convFactor -> BVL.convFactor;
                         (if (current.convFactor = 0) 
                             and not current.isPrimaryUnit then
                             (if traceUnit then
                                 '**** convFactor is zero:'->putline;
                                 current.print
                         if)if);
                      else (* Derived dimension *)
                         (if traceUnit then
                             '**** mkBaseVector:Derived dimension: ' ->puttext; 
                             theDim[] -> puttext;
                             ' ' -> put; current.US[2][] -> putline;
                             (*current.print*)
                         if);
                         current.US[2][] -> parseUnit -> mkBaseVector -> BVl[];
                         (if current.isPrimaryUnit then
                             (if current.convFactor <> 1.0 then
                                 '**** derived base unit wrong convFactor:' 
                                   -> puttext;
                                 current.convFactor -> putreal; newline; 
                                 current.print
                             if);
                             current.convFactor -> BVL.convFactor;
                          else
                             current.US[2][] -> parseUnit -> UT[];
                             UT[] -> mkBaseVector -> BV[];
                             BV.convFactor -> BVl.convFactor;
                             (if false then
                                 '**** compute convFactor from: ' -> puttext;
                                 current.US[2][] -> putline;
                                 current.print;
                                 UT.print->putline;
                                 BV.print -> putline;
                 if)if)if)if)
          #)if);
          (if BVl[] = none then 
              (if traceUnit then                  
                  '!!!! Unit not found: ' -> puttext; T.print-> putline;
              if);
              BaseVector -> BVl[]; (* not used *)
              notValidUnit
          if);
          (if traceUnit then 'MBK:idf:final: ' ->putline; BVL.print->puttext if)
       // number then
          (if traceUnit then
              'MBK:number: '->puttext; T.op[] -> putline;
          if);
          BaseVector -> BVl[]
       // var then 
          BaseVector -> BVl[]
       else
          '*** token not handled: '->puttext; T.token ->putint; newline
      if);
      (if traceUnit then
          '**** mkBaseVector:res: ' -> puttext; true -> t.print->putline;
          BVL.asSymbols->puttext;
          BVl.print -> putline;
      if)
   #)
   
   
