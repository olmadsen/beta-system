ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaChecker';
---LIB:attributes---
qStdBetaAllocator: qStdBetaChecker
  (# traceAlloc: (#exit false #); 
     StdBetaModule::<
       (# alloc:: 
            (# 
            do (*'StdBetaModule:alloc:'-> dumpT; moduleName.doPT->dumpTN;*)
            #)
       #);
     BetaFragments::<
       (# alloc:: 
            (# 
            do (if false then
                   'BetaFragments:alloc:'-> dumpT; 
                   scanSons
                   (# F: ^BetaFragment;
                   do (current[]->F[]).theName.dopt -> dumpTN #)
            if)#)
       #);
     AttSlot::<
       (# alloc::
            (#
            do scanBindings(#do current.alloc #)
            #);
          dumpAlloc:: (#do scanBindings(#do current.dumpAlloc #)#);
       #);
     ObjDescSlot::<
       (# alloc::
            (#
            do scanBindings(#do current.alloc #)
            #);
          dumpAlloc:: (#do (*scanBindings(#do current.dumpAlloc #)*) #);
       #);
     DoPartSlot::<
       (# alloc::
            (#
            do scanBindings(#do current.alloc #)
            #);
       #);
     ObjectDesc::<
       (# alloc:: 
            (# 
            do (if traceAlloc then
                   '**** ObjectDesc:alloc:'-> dumpTN;  dopt -> putHeadN
               if);
               (if slt[] = none then
                   (if (sup.theDesc = none) or (sup.theDesc = objDesc[])  then
                       1 -> originOff -> diSize;
                       1 -> vSize
                    else
                       (if false then
                           '****' -> dumpT; sup.dopt -> dumpT;
                           (sup.theDesc).dopt -> dumpTN;
                       if);
                       (sup.theDesc).alloc;
                       (if false then
                           ' super: ' -> dumpT; (sup.theDesc).originOff->putint;
                           ' ' -> put;(sup.theDesc).descNo->putint;
                       if);
                       (sup.theDesc).diSize -> diSize;
                       (sup.theDesc).vSize -> vSize;
                       (if sup.isSameBlockLevel then
                           (sup.theDesc).originOff -> originOff
                        else
                           diSize + 1 -> diSize -> originOff
                       if)
                   if);
                   newDescNo -> descNo; 
                   (if false then
                       ' ' -> put; descNo->putint; 
                       ' ' -> put; originOff -> putint; newline;
                   if)
                else
                   slt.scanBindings
                   (# ODF: ^ObjDescFrag
                   do (if false then
                          '**** ObjDesc:alloc:slot:'->dumpT;current.dopt->dumpTN;
                      if);
                      (current[]->ODF[]).OD.alloc;
            #)if)#);
          getDescNo:: (# do descNo -> DN #);
          objSize::
            (#
            do (if false then
                   '**** ObjectDesc:objSize:'->dumpT; dopt -> putheadN;
               if);
               (if isPrimitive then
                   1 -> diSize (* should be set once and for all *)
                else
                   (if diSize = 0 then
                       (if false then
                           '**** objDesc:doAlloc:allocDone:'->dumpT; 
                           allocDone->putboolean; newline
                       if);
                       alloc; (* and done*)
                   if);
               if);
               (if false then
                   '**** objDesc:'->dumpT;  
                   'size:'->dumpT; diSize -> putint; newline;
                   dopt -> putHeadN;
               if);
               diSize -> size;
               (if (size = 0) and (slt[] <> none) then 1 -> size if);
               (if size = 0 then
                   '**** ObjDesc:objSize:zero:'->dumpT; dopt -> putheadN;
               if)
            #);
          dumpAlloc::
            (#
            do (*'ObjectDescriptor:'*)
               ' descNo: ' -> puttext; descNo -> putint;
               ' originOff: ' -> puttext; originOff -> putint;
               ' diSize: ' -> puttext; diSize -> putint;
               ' vSize: ' -> puttext; vSize -> putint; newline;
               newOD;
            #);
          hasInner: IntegerValue
            (#
            do noOfInner + 1 -> noOfInner;
               (if noOfInner = 1 then vsize + 1 -> vsize -> innerInx if);
               innerInx -> value
            #);
          descNo,originOff,diSize,vSize,innerInx,noOfInner: @integer
       #);
     ActionPart::<
       (# alloc::
            (#
            do (if traceAlloc then 
                   '**** ActionPart:alloc:'->dumpT; doPT->putheadN 
               if)
            #);
       #);
     Imperatives::<
       (# alloc:: 
            (# 
            do (if traceAlloc then
                   'Imperatives:alloc:'-> dumpT; dopt -> putheadN;
               if)
            #);
       #);
       
     BetaDecl::<
       (# alloc:: 
            (# 
            do (if traceAlloc then
                   '**** BetaDecl:alloc:'-> dumpT; dopt -> putheadN;
            if)#);
       #);
     StaticItem::<
       (#  alloc:: 
            (# 
            do (*'StaticItem:alloc:'-> dumpTN;*)
            #);
          isValItem::
            (#
            do (if false then
                   '**   isValItem:'->dumpT; dopt->dumpTN;
               if);
               OS.objSize -> size
            #); 
       #);
     DynamicItem::<
       (#  alloc:: 
            (# 
            do (*'DynamicItem:alloc:'-> dumpTN;*)
               true -> done; 
               (* do not alloc T in R: ^T - may imply recursive alloc*)
            #);
          isValItem:: (#do 1 -> size #)
       #);
     ForImpItem::<
       (# isValItem:: (#do 1 -> size #)
       #);
     Repetition::<
       (# isValItem::
            (#
            do (if false then
                   '**** Repetition:isValItem:'->dumpT; dopt -> dumpTN;
               if);
               1 -> size
            #);
       #);
     VarPtn::<
       (# alloc:: (# do true -> done (* as for DynamicItem *) #)
       #);
     BetaPattern::< 
       (# alloc::
            (# 
            do (if traceAlloc then 
                   '**** PTN:alloc:'->dumpT; doPT->putheadN 
            if)#)
       #);
     BetaVirtualPattern::<
       (# isVirtualDecl:: TrueValue;
          isVirtualTopDecl:: TrueValue;
       #);
     FurtherBinding::<
       (# isVirtualDecl:: TrueValue
       #);
     FinalBinding::<
       (# isVirtualDecl:: TrueValue
       #);
     PatternDen::<
       (# getDescNo:: (# do AD.getDescNo -> DN #);
          objSize:: (#do AD.objSize -> size #)
       #);
     BetaNameDecl::<
       (# alloc:: 
            (# size: @integer; OD: ^ObjectDesc; VB: ^VirtualBinding;
            do (if traceAlloc then
                   '**** BetaNameDecl:alloc:'-> dumpT; dopt -> dumpTN;
               if);
               theEncOD -> OD[];
               (if OD[] <> none then
                   (if traceAlloc then
                       '**   objDesc:'->dumpT; OD.disize -> putint; newline;
                       OD.dopt->putheadN;
                   if);
                   (if (theDcl[] <> none) (* label in LabelledImp*) then
                       (*' theDcl ' -> dumpT;*)
                       (if (theDcl.IT.isValItem -> size) > 0 then 
                           (if traceAlloc then
                               '**   after valItem:OD:'->dumpTN;
                               OD.dopt -> putheadN;
                               'BetaNameDecl:alloc:size:'->dumpt;
                               size -> putint; 
                               ' OD.disize:'-> dumpT; OD.disize->putint;
                               ' '-> put; dopt -> dumpTN;
                           if);
                           OD.diSize + 1 -> off;
                           OD.diSize + size -> OD.diSize
                        else 
                           (if false then 'size=0:'->dumpt;  dopt->dumpT if);
                           (if true
                            // theDcl.IT.isVirtualTopDecl then
                               (*'virtual:'->dumpT; dopt->dumpt;*)
                               OD.vSize + 1 -> OD.vSize;
                               OD.vSize -> off;
                               (*off -> putint; newline;*)
                            // theDcl.IT.isVirtualDecl then
                               (*'binding:'->dumpT; dopt->dumpt;*)
                               (theDcl.IT[]->VB[]).vDcl.off -> off;
                               (*off -> putint; newline;*)
                   if)if)if)
                else
                   '!!!! BetaNameDecl:alloc not handled:encOD is none '-> dumpt;
                   origin.label -> dumpT; dopt -> dumpTN;
               if);
               (if traceAlloc then
                   '**   NameDecl:Alloc:off:'->dumpT; off->putint; ' '->put; 
                   dopt->dumpTN;
               if)
            #);
          dumpAlloc::
            (#
            do indent; 
               dopt -> dumpT; 'off: ' -> puttext; off -> putint; 
               (if theDcl.IT.isVirtualDecl then ' virtual:'->dumpT; if);
               (if not theDcl.IT.isSingular then newline if)
            #);
          off: @integer
       #);
     ForImp::<
       (# alloc::
            (# encOD: ^ObjectDesc
            do (if traceAlloc then 
                   '*** ForImp:alloc:'->dumpT; dopt -> dumptn;
               if);
               theEncOD -> encOD[];
               encOD.disize + 1 -> off -> encOD.disize;
               (if traceAlloc then
                   '**   encOD:'->dumpTN; encOD.dopt -> puthead; ' '-> put;
                   encOD.disize -> putint; ' '->put;
                   off -> putint; newline
               if)
            #);
          off: @integer; (* space for range *)
       #);
     InnerImp::<
       (# alloc::
            (# NA:  ^NameApl; on: @integer; org: ^SuperScope;
            do (if false then
                   '**** InnerImp:alloc:'->dumpT; doPT->dumpT; 
               if);
               scanSons(#do (current[]->NA[]).on -> on #); 
               (if false then
                   (if on > 1 then 
                       on -> putint; 
               if)if);
               (if false then newline; if);
               origin[] -> org[];
               (for i: on - 1 repeat org.origin[] -> org[] for);
               (if false and (on > 0) then org.dopt -> dumpTN if);
               (if org## = ObjectDesc## then
                   (org[]->orgOD[]).hasInner
                else
                   (if false then
                       '!!!! InnerImpl:origin is not ObjectDesc:'->dumpT; 
                       org.label -> dumpT;
                       org.dopt->dumpTN
               if)if)
            #);
          orgOD: ^ObjectDesc;
       #);
     ObjectEvaluation::<
       (# alloc::
            (#
            do (if false then 
                   'ObjectEvaluation:alloc:'->dumpT; dopt->dumpT;
                   father.label -> dumpTN
               if)
            #)
       #);
     NameApl::<
       (# objSize::
            (#
            do (if false then
                   '**** NameApl:theSize:'->dumpT; dopt -> dumptn;
               if);
               (theDesc).objSize -> size
            #);
       #);
     Indexed::<
       (# objSize::
            (#
            do (theDesc).objSize -> size
            #)
       #);
     newDescNo: @
       (# dn: @integer
       do dn + 1 -> dn
       exit dn
       #);
     allocStdBeta:
       (#
       do '\n**** Alloc ****'->putline;
          topModule.alloc;
          topModule.dumpAlloc;
       #)
  do
     inner
  #);
          
