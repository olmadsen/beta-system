ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/file';
INCLUDE '../compiler_IF/directoryComponents';
INCLUDE 'aux';
---lib:attributes---
mkAuxName:
  (# FN,ext: ^text; auxF: ^text
  enter(FN[],ext[])
  do (1,FN.length-6) -> FN.sub -> auxF[];
     (*eauxF[] -> screen.putline;*)
     ext[] -> auxF.append;
     (* auxF[] -> screen.putline*)
  exit auxF[]
  #);   

Lexer:
  (# init:< 
       (# 
       enter(fileName[],in[]) 
       do special.init;
          indent.init;
          inner 
       #); 
     initWithText:
       (# inn: ^text
       enter inn[]
       do inn[] -> in[];
          0 -> bTop; 0 -> nextCh.pos; false -> inDecl;
          special.init;
          indent.init;
          &text[] -> errorStream[]; 
       #);
     fileName: ^Text;
     traceParse,
     hasLexError: @boolean;
     errorStream: ^text;
     isXbeta: @boolean;
     buffer: [1000] @ char; bTop: @integer;
     nextCh: @
       (# pos,linePos,posBeforeName: @ integer;
          lastWasCR: @boolean;
          onlyWhiteSpace: @boolean
       do (if in.eos then
              255 -> ch
           else
              in.get -> ch; 
              pos+1 -> pos;
          if);
          (if ch <= 13 then
              0 -> linePos;
              true -> onlyWhiteSpace
           else
              linePos + 1 -> linePos;
              (if (ch > ' ') and onlyWhiteSpace then
                  (if (ch = '-') or (ch = '§') then
                   else
                      false -> onlyWhiteSpace
              if)if)
          if);
          (* pos -> putint; ' ' -> put;   ch -> put; *)
          (if (bTop + 1 -> bTop) > buffer.range then 
              buffer.range -> buffer.extend 
          if);
          ch -> buffer[bTop];
       #);
     printLines:
       (# n,lc,c,top: @integer; ch: @char
       enter n
       do (if tokenBuf.L > 0 then
              tokenBuf.chPos[tokenBuf.L] - 1 -> top;
              (*'***** lines: '->puttext; top -> putint; newline;
           else
               bTop - 1 -> top; 
               * (* last char is white space and may be newline, 
                  * which should not be counted below
                  *)
          if);
          1 -> lc;
          (for i: top repeat 
               (if buffer[i] = ascii.newline then lc + 1 -> lc if)
          for);
          L:
            (for i: top repeat
                 (if (i = top) or (buffer[top - i + 1] = ascii.newline) then
                     n - 1 -> n; lc - 1 -> lc;
                     (if (n = 0) or (i = top) then   
                         (*lc + 1 ->*) lc -> putint; ':' -> put; ' ' -> put; 
                         (for j: i repeat 
                              buffer[top - i + j] -> ch -> put;
                              c + 1 -> c;
                              (if ch = ascii.newline then 
                                  lc + 1 -> lc -> putint; ':' -> put;
                                  0 -> c;
                         if)for);
                         leave L
            if)if)for);
          newline;
          (for i: c + 2 repeat '*'-> put for);
          '^' -> put
       #);      
     peek:
       (#
       do indent.skipBlanks; 
       exit ch
       #);
     
     indent: @
       (# init: (# do 0 -> push ;(* true -> atStartOfLine*) #);
          dumpStack:
            (# inx: @integer
            enter inx
            do '\niStack: ' -> puttext; inx -> putint; ':'->put;
               (for i: top repeat
                    iStack[i] -> putint; ' ' -> put
               for);
               newline;
            #);
          atEos: @boolean; 
          skipBlanks:
            (# i: @ integer; inOut: @integer; 
            do 0 -> i; 
               (if ch = 0 then nextch if); 
               L: (if (ch = 32) then 
                      i + 1 -> i;
                      nextCh; 
                      restart L 
                  if);
               (if ch = '\\' then
                   nextch;
                   L2:
                     (if ch // 13 // ascii.newline then
                         nextch;
                         restart skipBlanks
                      else
                         nextch;
                         restart L2
                     if)
               if);
               (if ch <= 13 then (* newline *)
                   nextCh;
                   (if parenthLevel = 0 then
                       true -> atStartOfLine;
                   if);
                   restart skipBlanks
                else                    
                   (if ch = 255 then
                       (if false then
                           '*** eos: '->puttext; atStartOfLine -> putboolean;
                           ' ' -> put; i -> putint; ' ' -> put;
                           top -> putint; ' ' -> put;
                           fileName[] -> putline;
                       if);
                       (if not atEos then
                           '}' -> ch;
                           - 1 -> InOut;
                           1 -> top; 
                           true -> atEos
                        else
                           0 -> inOut
                       if);
                       leave skipBlanks
                   if);
                   (if atStartOfLine then
                       L:
                         (if true 
                          // i = iStack[top] then
                             0 -> inOut;
                             maxInt -> inOut;
                          // i < iStack[top] then
                             (for j: top - 1 repeat
                                  (if i = iStack[top - j] then
                                      - j -> InOut;
                                      top - j -> top;
                                      leave L
                             if)for);
                             3 -> printlines;
                             '\n   The indentation of this line does not '
                               -> puttext;
                             'match any previous lines\n' 
                               ->puttext; 
                             '   The level here is: ' -> puttext; i -> putint;
                             '. Previous lines are at : ' -> puttext;
                             (for i: top repeat
                                  i -> putint; ' ' -> put
                             for);
                             newline;
                             '   In file: \n   ' -> puttext;
                             fileName[] -> putline;
                             newline;
                             true -> hasLexError;
                          // i > iStack[top] then
                             (if (i - iStack[top]) < 2 then
                                 3 -> printLines;
                                 '\n   The indentation of this line is less than 3 blanks' 
                                   -> putline;
                                 '   It must be at least 3 blanks' -> putline
                             if);
                             i -> push;
                             1 -> InOut
                         if);
                       false -> atStartOfLine;
                   if);
                   (* newline;
                    (if atStartOfLine then 'T:'->puttext else 'F:'->puttext if);
                    i -> putint; ':'->put;
                    (for i: top repeat istack[i] -> putint; ','->put for);
                    newline*)
            if);
       exit inOut 
       #);
     atStartOfLine: @ boolean;

     iStack: [4] @ integer; top: @integer;
     push:
       (# v: @integer enter V 
       do (if (top + 1 -> top) > iStack.range then
              iStack.range -> iStack.extend
          if);
          V -> iStack[top]
       #);
     revert:
       (# ind: @integer
       enter ind
       do top + ind -> top
       #);
       #);
     readName:
       (# c,prevCh: @char;
          isConst: @boolean;
       enter c
       do nextCh.pos - 1 -> nextCh.posBeforeName;
          ch -> ascii.isDigit -> isConst; (* what about c?*)
          &text[] -> sym[];
          (if c > 0 then c -> sym.put if);
          L: (if (ch->ascii.isLetter) or (ch-> ascii.isDigit) 
                 or (ch = '_') or (ch = '$') or (ch = '%') or (ch = '@') then
                 ch -> sym.put;
                 ch -> prevCh;
                 nextCh;
                 restart L;
             if);
          (if isConst and (ch = '.') then
              ch -> sym.put;
              ch -> prevCh;
              nextCh;
              LL:
                (if ch -> ascii.isDigit then
                    ch -> sym.put;
                    ch -> prevCh;
                    nextCh;
                    restart LL
                if);
              symbols.floatConst -> symb
          else
              (if prevCh = '%' then (* not used anymore ? *)
                  symbols.fatComma -> symb 
               else
                  (if isConst then
                      symbols.const -> symb
                   else    
                      (if true
                       // 'var' -> sym.equalNCS then
                          symbols.varVal -> symb
                       // 'val' -> sym.equalNCS then
                          symbols.constVal -> symb
                       // 'ref' -> sym.equalNCS then
                          symbols.varRef -> symb
                       // 'obj' -> sym.equalNCS then
                          symbols.constRef -> symb
                       // 'do' -> sym.equalNCS then
                          symbols.doSy -> symb
                       // 'in' -> sym.equalNCS then
                          symbols.inArg -> symb
                       // 'out' -> sym.equalNCS then
                          symbols.outArg -> symb
                       // 'class' -> sym.equalNCS then
                          symbols.class -> symb
                       else                      
                          symbols.idf -> symb
       if)if)if)if)#);
     
     readText:
       (# symb: @integer
       do &text[] -> sym[];
          nextCh;
          L:
            (if ch
             // '"' then
                (* end  of  text *)
             // '\\' then
                ch -> sym.put;
                nextCh;
                ch -> sym.put;
                nextCh;
                restart L
             // ascii.nl then
                '\n\n*** ERROR: end-of-line when parsing String' -> putline;
                true -> hasLexError;
                3 -> printLines
             else
                ch -> sym.put;
                nextCh;
                restart L
            if);
          symbols.string -> symb
       exit symb
       #);
     getComment:
       (# T: ^text
       do skipComment.get -> T[];
       exit T[]
       #);
     skipComment: @
       (# put:
            (# ch: @char
            enter ch
            do ch -> comment.put;
            #);
          get: 
            (# T: ^text 
            do (if comment.length > 0 then 
                   comment.copy -> T[];
                   comment.clear
               if) 
            exit T[] 
            #);
          comment: @text;
       do (*comment.clear;*)
          (if comment.length > 1 then
              (* multi-line comment? *)
              ascii.newline -> put
          if);
          (if nextCh.onlyWhiteSpace then
              '<' -> put
          if);
          nextCh; (* moved from the place of call of skipComment *)
          nextch.linePos -> comment.putint; '>' -> put;
          ch -> put;
          Loop:
            (#
            do nextCh; 
               (if ch 
                // ascii.newline then
                // 255 then
                else                   
                   ch -> put;
                   restart Loop
       if)#)#);                            
     
     special: @
       (# init:
            (#
            do true -> chars['!'];
               true -> chars['#'];
               true -> chars['$'];
               true -> chars['%'];
               true -> chars['&'];
               true -> chars['?'];
               true -> chars['*'];
               true -> chars['+'];
               true -> chars['-'];
               true -> chars['/'];
               true -> chars['<'];
               true -> chars['='];
               true -> chars['>'];
               true -> chars['<'];
               true -> chars['\\'];
               true -> chars['|'];
               true -> chars['^'];               
            #);
          in: booleanValue
            (# ch: @char
            enter ch
            do chars[ch] -> value 
            #);
          read:
            (# c: @char
            enter c
            do &text[] -> sym[];
               (if c > 0 then c -> sym.put if);
               L:
                 (if (ch -> in) then
                     ch -> sym.put;
                     nextCh;
                     restart L
                 if);
               symbols.special -> symb;
               (*'\nSpecial: ' -> puttext; sym[] -> putline*)
            #);
          chars: [256] @boolean
       #);
     
     in: ^stream;
     symb,oldPos: @integer;
     sym: ^text;
     ch: @ char;
     
     current:
       (# T: ^text
       do symb -> symbols.asText -> T[];
          (if symb
           // symbols.const // symbols.idf // symbols.string
           (*// symbols.keyword*) // symbols.fatComma // symbols.special then
              ' ' -> T.put;
              sym[] -> T.append
          if)
       exit T[]
       #);
     symbols: @ 
       (# isRelOp: BooleanValue
            (# sym: ^text
            enter sym[]
            do ('=' -> sym.equal) or
               ('<>' -> sym.equal) or
               ('<' -> sym.equal) or
               ('<=' -> sym.equal) or
               ('>' -> sym.equal) or
               ('>=' -> sym.equal) or
               ('==' -> sym.equal) or
               ('=/=' -> sym.equal) -> value
            #);
          isAddOp: BooleanValue
            (# sym: ^text
            enter sym[]
            do ('+' -> sym.equal) or
               ('-' -> sym.equal) or
               ('||' -> sym.equal) 
                 -> value
            #);          
          isUnaryAddOp: BooleanValue
            (# sym: ^text; symb: @integer
            enter(sym[],symb)
            do (symb <> charSy) and (symb <> string) and
               (('+' -> sym.equal) or ('-' -> sym.equal))
                 -> value
            #);          
          isMultOp: BooleanValue
            (# sym: ^text
            enter sym[]
            do ('*' -> sym.equal) or
               ('/' -> sym.equal) or
               ('/%' -> sym.equal) or
               ('//' -> sym.equal) or
               ('&&' -> sym.equal) -> value
            #);
          isNotOp: BooleanValue
            (# sym: ^text; symb: @integer
            enter(sym[],symb)
            do (symb <> charSy) and (symb <> string) 
               and ('!' -> sym.equal) -> value
            #);
          
          isTrueSpecial: BooleanValue
            (# sym: ^text
            enter sym[]
            do not ((sym[] -> isRelOp) 
               or (sym[] -> isAddOp) 
               or (sym[]->isMultOp)) and (symb = special)-> value
            #);
          print: 
            (# sy: @integer
            enter sy
            do sy -> astext -> puttext
            #);
          asText:
            (# sy: @integer; T: @text
            enter sy
            do '<<' -> T; sy -> T.putint; '>>' -> T.puttext;
               (if sy
                // 0 then '<zero>' -> T                   
                // begin then '{' -> T
                // end then '}' -> T
                // leftBrack then '(' -> T
                // rightBrack then ')' -> T
                // constRef then 'obj' -> T
                // varRef then 'ref' -> T 
                // colon then ':' -> T
                // comma then ',' -> T 
                // semiColon then ';' -> T
                // varVal then 'var' -> T
                // constVal then 'val' -> T
                // doSy then 'do' -> T
                // dot then '.' -> T
                // objModule then '/' -> T
                // return then '->' -> T
                // leftSquare then '[' -> T          
                // rightSquare then ']' -> T
                   
                // virtual then ':<' -> T
                // further then '::<' -> T
                // final then '::' -> T
                // include then '%include' -> T

                // const then 'const' -> T
                // idf then 'name' -> T
                // special then 'special' -> T
                (*// keyword then 'keyword' -> T*)
                // fatComma then 'fatComma' -> T
                // prim then '%' -> T
                // innerSy then 'inner' -> T          
                // charSy then'char' -> T
                // string then 'text' -> T
                // alternative then '//' -> T
                // thisObj then 'this' -> T
                // comBegin then '(' -> T; '*' -> T.put; (* avoid confusing beta-indent *)
                // eq then '=' -> T
                // lt then '<' -> T                   
                // le then '<= ' -> T
                // gt then '>' -> T
                // ge then '>=' -> T
                // ne then '<>' -> T
                // add then '+' -> T
                // sub then '-' -> T
                // mult then '*' -> T
                // orr then 'or' -> T
                // xorr then 'xor' -> T          
                // rdiv then '/' -> T
                // idiv then 'div' -> T
                // modd then 'mod' -> T
                // andd then 'and' -> T       
                // nott then 'not' -> T
                // inArg then 'in ' -> T
                // outArg then 'out ' -> T
                // class then 'class ' -> T
                // illegalCh then '???' -> T
                // dots then  '...' -> T
                // vAssign then ':= ' -> T
                // rAssign then ':- ' -> T    
                // slotBegin then '<<'-> T
                // slotEnd then '>>'-> T
                // frag then '--'->T 
                // eos then  '-eos-' -> T
                else
                   sy -> T.putint
               if)
            exit T[]
            #);
          asCh:
            (# sy: @integer; ch: @char
            enter sy
            do (if sy
                // leftBrack then '(' -> ch
                // rightBrack then ')' -> ch
                // begin then '{' -> ch
                // end then '}' -> ch
                // leftSquare then '[' -> ch
                // rightSquare then ']' -> ch
                else
                   '?' -> ch
               if)
            exit ch
            #);
            
          begin: (#exit 1 #);
          end: (#exit 2 #);
          leftBrack: (#exit 3 #);
          rightBrack: (#exit 4 #);
          colon: (#exit 5 #);          
          constRef: (# exit 6 #);
          varRef: (# exit 7 #);
          class: (# exit 8 #);
          
          comma: (#exit 9#);
          semiColon: (#exit 10 #);
          (*keyword: (# exit 11 #);*)
          fatComma: (# exit 12 #);
          
          varVal:(# exit 13 #);
          constVal: (# exit 14 #);
          doSy: (# exit 15 #);
          
          dot: (#exit 16 #);
          objModule: (#exit 67 (* 17 - double use here see rdiv *) #);
          return: (#exit 18#); (* return value(s) of pattern *)

          leftSquare: (#exit 20 #);
          rightSquare: (# exit 21 #);
          
          virtual: (# exit 27 #);
          further: (# exit 22 #);
          final: (# exit 26 #);
          
          leaveSy: (#exit 23#);
          restartSy: (#exit 24#);
          
          include: (# exit 25 #);


          property: (#exit 28 #);
          
          special: (#exit 31 #);
          const: (#exit 32 #);
          idf: (#exit 33 #);
          prim: (#exit 34 #);          
          innerSy: (# exit 35 #);
          
          charSy: (# exit 36 #);
          string: (# exit 37 #);
          alternative: (# exit 38 #);
          thisObj: (# exit 39 #);
          comBegin: (# exit 40 #);
          
          inArg: (# exit 41 #);
          outArg: (# exit 42 #);
          
          floatConst: (# exit 43 #);
          eq: (#exit 50#);
          lt: (#exit 51#);
          le: (#exit 52#);
          gt: (#exit 53#);
          ge: (#exit 54#);
          ne: (#exit 55#);          

          add: (#exit 61#);
          sub: (#exit 62#);

          orr: (#exit 63#);
          xorr: (#exit 64 #);
          
          mult: (#exit 66 #);
          rdiv: (#exit 67 #);
          idiv: (#exit 68 #);
          modd: (#exit 69#);
          andd: (#exit 70#);
          nott: (# exit 71 #);
          
          component: (#exit 73 #);
          strucVar: (#exit 74 #);
          nonTbegin: (# exit 75 #);
          nonTend: (# exit 76 #);
          adr: (#exit 77 #);
          frag: (# exit 78 #);
          ptnModule: (# exit 79 #);
          illegalCh: (# exit 81 #);
          dots: (# exit 46 #);
          eos: (# exit 82 #); 
          vAssign: (# exit 83 #);
          rAssign: (# exit 84 #);
          slotBegin: (# exit 85 #);
          slotEnd: (#exit 86 #);
          designator: (# exit 87 #);
          denoter: (# exit 88 #);
          object: (# exit 89 #)
       #);
   tokenBuf: @
        (# bufSize: (#exit 15 #);
          B: [bufSize] @ integer; 
          Sy: [bufSize] ^text;
          chPos: [bufSize] @integer;
          L,R,cnt: @ integer;
          add:
            (# T,oldRange: @integer; S: ^text
            enter(T,S[])
            do (if true then 
                   cnt + 1 -> cnt;
                   (if false then
                       'tokenBuf.add:'->puttext; cnt ->putint; ' '-> put;
                       T->putint; ' ' ->put; T->symbols.asText->puttext; 
                       ' '->put; S[] -> puttext;
                       newline;
                   if);
                   (if cnt > B.range then
                       (if true then
                           'tokenBuf:put:overflow\n'->puttext; 
                           print;
                       if);
                       (* buffer is full: assert R = L *)
                       (R = L, 'lexer:tokenBuf.add:overflow:R<>L') -> assert;

                       B.range -> oldRange -> B.extend;
                       Sy.range -> Sy.extend;
                       chPos.range -> chPos.extend;
                       (* move L + 1, L + 2, ..., L + i = oldRange 
                        *   to oldRange + L + 1, oldRange + L + 2, ...
                        *)
                       (for i: oldRange - L repeat
                            B[L + i] -> B[oldRange + L + i];
                            Sy[L + i][] -> Sy[oldRange  + L + i][];
                            chpos[L + i] -> chPos[oldRange + L + i];
                       for);
                       L + oldRange -> L
                   if);
                   (R mod B.range) + 1 -> R;
                else
                   (if (R + 1 -> R) > B.range then 
                       B.range -> B.extend;
                       Sy.range -> Sy.extend;
                       chPos.range -> chPos.extend
               if)if);
               (*'tokenbuf.add:'->puttext; T -> putint; S[]->putline;*)
               T -> B[R];
               S[] -> Sy[R][];
               nextCh.pos -> chPos[R];
            #);
          get:
            (# T: @integer; S: ^Text
            do (if true then
                   (if false and (L = R) then
                       'lex:tokenBuf:get:empty:'->putline;
                   if);
                   (L mod B.range) + 1 -> L;
                   cnt - 1 -> cnt;
                   (if false then
                       'tokenBuf.get:'->puttext; cnt ->putint; newline
                   if)
                else
                   L + 1 -> L
               if);
               B[L] -> T;
               Sy[L][] -> S[]; ' ' -> Sy[L][]
            exit(T,S[])
            #);
          getTokenNo:
            (# n,pos: @integer
            enter n
            do (if true then 
                   (L + n - 1) mod B.range + 1 -> pos 
                else 
                   L + n -> pos 
               if)
            exit B[pos]
            #);
          isEmpty: 
            booleanValue
            (#
            do (if true then
                   cnt = 0 -> value;
                   (if false then
                       'tokenBuf:empty:\n'->puttext; print
                   if)
                else
                   (if L = R then 0 -> L -> R; true -> value 
            if)if)#);
          print:
            (#
            do '**** tokenBuf: cnt:'->puttext; cnt->putint;
               ' L:' -> puttext; L -> putint; 
               ' R:'->puttext; R -> putint; 
               ' range:'->puttext; B.range -> putint; newline;
               (for i: B.range repeat
                    i->putint; ':' -> put; B[i]->putint; ','-> put;
                    '"'->put;SY[i][]->puttext;'"'->put; 
                    ',pos:'->puttext; chPos[i]->putint; 
                    newline
               for);
            #);
       #);
     inDecl,second: @boolean;
     parenthLevel: @integer;
     readNextToken:
       (# hasComment: @boolean;
          toSym:
            (# ch: @char; 
            enter ch
            do &text[] -> sym[]; ch -> sym.put
            #)
       do nextCh.pos -> oldPos; false -> hasComment;
          (if inDecl then true -> second if);
          &text[] -> sym[]; (* just for debugging - ensure that sym is empty
                             * if lexem is not idf, const, char, text or special
                             *)
          L:
            (if ch
             // '{' then
                symbols.begin -> symb;
                '{' -> toSym;
                parenthLevel + 1 -> parenthLevel;
                nextCh
             // '}' then
                symbols.end -> symb;
                '}' -> toSym;
                parenthLevel - 1 -> parenthLevel;
                nextCh
             // '(' then
                symbols.leftBrack -> symb;
                '(' -> toSym;
                parenthLevel + 1 -> parenthLevel;
                nextCh;
             // ')' then 
                symbols.rightBrack -> symb; 
                ')' -> toSym;
                parenthLevel - 1 -> parenthLevel;
                nextCh;
             // ':' then 
                nextCh;
                (if ch // '=' // '-' then 
                    (if not (in.peek -> special.in) (*(in.peek <= ' ')*) then
                        (* does now work for V :=7 *)
                        &text[] -> sym[];
                        ':'->sym.put; 
                        (if ch = '=' then
                            '=' -> sym.put;
                            symbols.vAssign -> symb;
                         else
                            '-' -> sym.put;
                            symbols.rAssign -> symb;
                        if);
                        nextCh
                     else
                        ':' -> special.read
                    if)
                 // '<' then 
                    symbols.virtual -> symb;
                    nextCh;
                    true -> inDecl
                 // ':' then
                    nextCh;
                    (if ch = '<' then
                        nextCh;
                        symbols.further -> symb
                     else (* dont work as for ::= . must be blank *)
                        symbols.final -> symb
                    if);
                    true -> inDecl
                 else
                    (if (ch -> ascii.isLetter) then
                        ':' -> readName;
                        symbols.fatcomma -> symb
                     else
                        symbols.colon -> symb;
                        true -> inDecl
                    if)
                if)
             // '=' then
                nextCh;
                (if true or (ch -> special.in) then
                    '=' -> special.read
                 else
                    symbols.eq -> symb; '"' -> sym[]
                if)
             // '$' then 
                symbols.denoter -> symb; nextCh
            (* // '?' then 
                nextCh;
                (if ch 
                 // '$' then 
                    symbols.varVal -> symb; nextCh
                 // '^' then 
                    symbols.varRef -> symb; nextch
                 else
                    symbols.varRef -> symb
                if)*)
             // ',' then symbols.comma -> symb; nextCh
             // ';' then symbols.semiColon -> symb; nextCh
             // '.' then
                nextCh;
                (if ch = '.' then
                    nextch;
                    (if ch = '.' then
                        symbols.dots -> symb;
                        nextCh
                     else
                        (* this allows for two dots '..') to be parsed
                         * as three dots ...'; perhaps an error? *)
                        symbols.dots -> symb; 
                    if)
                 else
                    symbols.dot -> symb; 
                if)
             // '-' then
                nextCh;
                (if ch 
                 // '>' then 
                    symbols.return -> symb; nextCh;
                    (*'\n*** got value' -> putline; 5 -> printlines;*)
                 // '-' then
                    Skipcomment; (* nextCh moved to skipComment to avoid
                                  * onlyWhiteSpace being set to false.
                                  * Will happen for: "   --snorf"
                                  * but not for: "   -- snorf"
                                  *)
                    (* We need to call skipBlanks at outer level *)
                    true -> hasComment
                 else 
                    '-' -> special.read
                if)
             // '<' then
                nextCh;
                (if ch = '<' then
                    nextCh;
                    symbols.slotBegin -> symb
                 else
                    '<' -> special.read
                if)
             // '>' then
                nextCh;
                (if ch = '>' then
                    nextCh;
                    symbols.slotEnd -> symb
                 else
                    '>' -> special.read
                if);
             // '§' then
                (*nextCh;*)
                SkipComment;
                true -> hasComment
             // '[' then
                nextCh;
                symbols.leftSquare -> symb;
                '[' -> toSym;                
             // ']' then 
                nextCh;
                symbols.rightSquare -> symb;
                ']' -> toSym;
             // '@' then
                nextCh;
                symbols.designator -> symb
             // '%' then
                nextCh;
                (if (ch -> ascii.isLetter) then
                    '%' -> readName;
                    symbols.property -> symb;
                 else
                    '%' -> special.read
                if);
             // '#' then
                (* something to fix here:*)
                nextCh;
                (if (ch -> ascii.isLetter) 
                    or (ch = '%') or (ch = '@') or (ch = '=') then
                    (if ch <> '=' then
                        '#' -> readName;
                     else
                        (* probably any sequence of special characters *)
                        '#=' -> sym[]
                    if);
                    symbols.idf -> symb
                 else
                    (* what happen here? *)
                if)
             // '\'' then 
                nextch;
                (if ch = '\\' then
                    ch -> sym.put;
                    nextch
                if);
                ch -> sym.put;
                nextCh;
                (if ch = '\'' then
                    symbols.charSy -> symb
                 else
                    symbols.illegalCh -> symb
                if);
                nextCh
             // '"' then
                readText -> symb; nextCh   
             // 255 then symbols.eos -> symb
             else
                (if (ch -> ascii.isLetter) 
                    or ( ch-> ascii.isDigit) or (ch = '_') then
                    ReadName
                 else
                    (if (ch -> special.in) then
                        special.read
                     else
                        '\nIllegal ch: ' -> puttext; ch -> putint; ' ' -> put; 
                        ch -> put; newline;
                        symbols.illegalCh -> symb;
                        nextCh
            if)if)if);
          (if second then false -> second -> inDecl if)
       exit hasComment
       #);
     nextTokens:
       (# inOut,cSymb: @integer
       do indent.skipBlanks -> inOut;
          (*'<'->put; inout -> putint; '>'->put;*)
          (if inOut 
           // 0 then (* continue on current line *)
              (if readNextToken then
                  (* readNextToken parsed a comment *)
                  restart nextTokens
              if);
              (symb,sym[]) -> tokenBuf.add;
           // 1 then (* indent *)
              symbols.begin -> symb;
              (symb,''(*sym[]*)) -> tokenBuf.add;
           // maxInt then (* new line, but same block level *)
              (if readNextToken then
                  (* comment *)
                  restart nextTokens
              if);
              (if symb <> symbols.fatComma then
                  (symbols.semicolon,'') -> tokenBuf.add;
              if);
              (symb,sym[]) -> tokenBuf.add; 
           else (* outdent -inOut levels *)
              (* if nextToken is comment, then skipComment and restart *)
              (if readNextToken then 
                  (* got comment *)
                  -inOut -> indent.revert;
                  restart nextTokens
              if);
              (if inOut < 0 then
                  (for i: - inOut repeat (symbols.end,'') -> tokenBuf.add for);
                  (if symb <> symbols.fatComma then
                      (symbols.semicolon,'') -> tokenBuf.add
                  if);
                  (symb,sym[]) -> tokenBuf.add;
       if)if)#);
     peekNext:
       (* read and return next token
        * put token in tokenBuf
        * keep current value of sym[]
        * peeked token sym[] should also be buffered
        *)
       (# T: @integer; 
          currentSymb: @integer;
          currentSymT: ^text;
          n: @integer
       enter n
       do symb -> currentSymb;
          sym[] -> currentSymT[];
          (for i: n - tokenBuf.cnt + 1 repeat 
               nextTokens
          for);
          n -> tokenBuf.getTokenNo -> T;
          currentSymb -> symb;
          currentSymT[] -> sym[]
       exit T
       #);
  do (if not tokenBuf.isEmpty then
           tokenBuf.get -> (symb,sym[])
      else
         nextTokens;
         tokenBuf.get -> (symb,sym[])
     if);
     (if false then
         'lex: '->puttext;symb -> putint; ' ' -> put;
         symb -> symbols.asText -> puttext; ' ' -> put;
         sym[] -> putline
     if)
#)
