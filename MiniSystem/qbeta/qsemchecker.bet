ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual';
INCLUDE 'qunithandler';

---lib:attributes---
useNewVclass: (# exit false #);
trace_pathToDcl: (# exit false #);
semchecker: UnitHandler
  (# doCheckQual:
       (# srcQual,dstQual: ^ObjectGenerator
       enter(srcQual[],dstQual[])
       do  (* repeat code from DataItem - but perhaps in checkQual in Decl? *)
       #);
     Module::<
       (# semcheck:: 
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[]
                    if)
                 exit M[]
                 #);
               M: ^Module;
            do (*'Module:semCheck:'->puttext; DI.sig.id[] -> putline;*)
               (if (encModule -> M[]) <> none then
                   M.semCheck
               if)
            #);
          getVqualX::
            (#
            do (if trx then
                   '**** Module:getVqualX: ' -> putline; dopt -> puthead
               if);
               OG[] -> qual[]
            #);          
          getQual::
            (#
            do (if trx then
                   '**** Module:getQual: ' -> putline; dopt -> putline
               if);
               OG[] -> qual[]
            #);
       #);
     ModuleItem::<
       (# semCheck::
            (#
            do (if false then
                   '**** ModuleItem:semcheck: ' -> puttext; sig.dopt->putline;
                   ' isIncluded: ' -> puttext; MD.isIncluded -> putboolean;
                   newline
               if);
               (* MD.isIncluded does not seem to work here - a trace shows
                * that no modules are included. It seems that isIncluded is
                * defined via ModulePath in generator. If we delete
                *  false -> doCheck, asemcheck will loop
                * We thus semcheck all modules that have been checked
                * We should fix the compiler to only check, semcheck and
                * generate code for modules actually being used
                *)
               (if not MD.isIncluded then
                   (if false then
                       'Module not included: ' -> puttext; sig.doPT -> putline;
                   if);
                   false -> doCheck
               if);
               (if isChecked then
                   (none,encOG[]) -> MD.OG.semcheck -> encOG[] -> eOG[];
               if)
            #);          
          getVqualX:: 
            (# 
            do (if trx then
                   'ModuleItem:getVqualX: ' -> puttext; dopt -> puthead
               if);
               md.OG[] -> qual[]
            #);
          
          getQual:: 
            (# 
            do (if trx then
                   'ModuleItem:getQual: ' -> puttext; dopt -> puthead
               if);
               md.getQual -> qual[]
            #);
       #);
     NewProperty::<
       (# (*semcheck::(# do false -> doCheck #)*)#);
     DataItem::<
       (# getVqualX::
            (#
            do (if trx then
                   '**** DataItem:getVqualX: ' -> puttext; sig.dopt -> putline;
                   (if OGS[] = none then '!!!! OGS is none' -> putline if);
                   OGS.print
               if);
               (encOG[],false,OGS[]) -> OG.getVqualX -> (OGS[],qual[]);
            #);

          nestPath: @boolean;;  (* true: mark path for inArg as isNest *)
          getVqual::
            (#
            do (if trx then
                   '**** DataItem:getVqual: ' -> puttext; sig.dopt -> putline
               if);
                (encOG[],P[],OGS[]) -> OG.getVqual -> (P[],OGS[],qual[]);
            #);
           getQual:: 
            (# U: ^Text
            do (if trx then
                   '**** DataItem:getQual: ' -> puttext; sig.dopt -> putline
               if);
               OG.getQual -> qual[];
               (if trx then
                   '***** DI:getQual:for: ' -> puttext; sig.doPT -> puttext;
                   ' qual:\n' -> puttext; qual.dopt -> puthead
               if);
            #);
          semCheck::
            (* Check that in S : ? T, V: = T, T is a pattern
             * it seems to work for singular patterns, but check if this is so!
             * And for X: var/val/obj foo(e1,e2,e3) - type(X) = type(foo.return)
             *)
            (# OGqual: ^ObjectGenerator
            do (if trx then
                   '**** DataItem:semCheck:\n' -> puttext; dopt -> puthead;
                   '**   OG.isPtnOrSingular:' -> puttext;
                   OG.isPtnOrSingular -> putBoolean; 
                   ' isValue:' -> puttext; isValue -> putboolean;
                   ' isPrimitive:' -> puttext; isPrimitive -> putBoolean;
                   ' OG.isValueObj: ' -> puttext; OG.isValueObj -> putBoolean;
                   '\n**  OG:'->putline; OG.dopt -> puthead;
                   OG.label -> putline;
                   '\n**   OG.getQual: ' -> puttext; 
                   (OG.getQual).dopt -> puthead;
                   newline;
               if);
               OG.getQual -> OGqual[];
               (if OG.isPtnOrSingular then
                   not isConst or isArg -> noArgsCheck;
                   (* see qabstractSyntaxTree::semCheck
                    * if noArgsCheck, the sons are not checked
                    * Is this correct?
                    *)
                   (if isValue then
                       (if not (OGqual.isValueObj or OGqual.isPrimitive) then 
                           this(DataItem)[] -> SemanticError
                           (#
                           do 'The qualification "' -> msg;
                              OG.doPT -> msg;
                              '" must be a value pattern' -> msg;
                           #)
                       if)
                    else
                       (if OGqual.isValueObj then
                           (if OGqual.isBasicValue then
                               (* while implementing sub of integer, etc
                                * we allow decl of the form I: ?integer
                                *)
                            else
                               this(DataItem)[] -> SemanticError
                               (#
                               do 'The qualification "' -> msg;
                                  OG.doPT -> msg;
                                  '" must be an object pattern' -> msg;
                               #)                           
                   if)if)if)
                else
                   (if false then
                       (if OGqual.super.ATd[] <> none then
                           OGqual.super.ATd.doPT -> putline;
                        else
                           OGqual.father.doPT -> puthead
                   if)if);
                   this(DataItem)[] -> SemanticError
                   (#
                   do 'The qualification "' -> msg;
                      OG.doPT -> msg;
                      '" must be a pattern '-> msg;
                   #)
               if)
            #);
          checkQual::
            (* Check that enter arg srcOS can be assigned to dstOG
             * which is this(DataItem) 
             *)
            (# error:
                 (#
                 do (if reportSemErr then
                        srcOS[] -> semanticError
                        (#
                        do '"'->put; srcOS.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                           '**   in object:\n' -> putline;
                           (enclosingObjectGenerator).father.dopt -> putline;
                           (if false then
                               '**** srcQual:' -> puttext; 
                               (if srcQual[] <> none then
                                   srcQual.dopt -> putline
                                else
                                   'none'->putline
                               if);
                               '**** srcOS.getQual:' -> puttext; 
                               (srcOS.getQual).dopt -> putline;  
                               '**** dstQual:' -> puttext; 
                               (if dstQual[] <> none then
                                   dstQual.dopt -> puthead
                                else
                                   'none' -> putline
                               if);
                               '**** dstOG.getQual:' -> puttext; 
                               (getQual).dopt -> puthead
                           if)
                 #)if)#);
               unitWarning:
                 (# T: ^text
                 enter T[]
                 do srcOS[] -> warning
                    (#
                    do T[] -> msg; 
                       '\n**   source: "'->msg; srcOS.dopt -> msg;
                       '" unit: "' -> msg; srcU[] -> msg; '"\n' -> msg;
                       '**   destination: "' -> msg; dopt -> msg; '"' -> msg;
                       ' unit: "' -> msg; dstU[] -> msg; '"\n' -> msg;
                       'srcQual:'->msg; srcQual.doPT -> msg;
                       '\ndstQual:'->msg; dstQual.doPT -> msg
                    #)
                 #);
               srcU,dstU,Ux,U: ^text; sameDim: @boolean; srcCF,dstCF: @real
            do (if (trx) or traceGetQual then
                   '\n**** DataItem:checkQual:' -> puttext; 
                   (if isConst then ':C:' -> puttext if);
                   (if isAssign then 'assign:' -> puttext if); newline;
                   ('**   dst',this(DataItem)[]) -> display; 
                   ('**   src',srcOS[]) -> display;
                   (if false then
                       '**   dst.lab:dataItem' -> putline;
                       '**   src.lab: ' -> puttext; srcOS.label -> putline;
                   if);
                   '**   dstQual:'->putline; dstQual.dopt -> puthead;
                   '**   srcQual:'->putline; srcQual.dopt -> puthead
               if);
               (* We may come here with 
                * dstU = in base: var Unit
                * I.e. OG = Unit and no items
                * This may be a problem and perhpas we should get Unit.qual!?
                *)
               L:
                 (if true then (* check possible units !*)
                     1 -> dstQual.getUnitPropShort -> dstU[];
                     
                     (if dstU[] = none then
                         (* clean-up here and validate that this is ok *)
                         leave L
                     if);
                     srcOS.getExpUnit -> srcU[];
                     (if trx then
                         '**   dstUnit: ' -> puttext; dstU[] -> putline;
                         '**   srcUnit: ' -> puttext; srcU[] -> putline;
                     if);
                     (if (srcU[] <> none) and (dstU[] <> none) and
                         (srcU.length > 0) and (dstU.length > 0) then
                         (if true
                          // srcU[] -> dstU.equalNCS then
                             floatDecl.OG[] -> srcQual[] -> dstQual[]
                          // '#Float' -> dstU.equalNCS then
                             floatDecl.OG[] -> srcQual[]
                          // ('U' -> srcU.equal) or ('U' -> srcU.equal) then
                             'Should not happen: unit is "U"'->unitWarning
                          else
                             (* Check if srcU and dstU are unitsin the same 
                              * dimension and return possible conversion factors
                              * to the corresponding base unit
                              *)
                             (srcU[],dstU[])
                               -> unitTable.findAndCheck
                               -> (sameDim,srcCF,dstCF);
                             (if sameDim then
                                 (* Not sure the conversions below are correct! *)
                                 (if true
                                  // (srcCF = 0) and (dstCF <> 0) then
                                     (* src is the base unit and srcOs
                                      * must be converted using dstCF
                                      *)
                                     '**** addConvFactor: ' -> puttext;
                                     srcOS.doPT -> puttext; ' ' -> put;
                                     1 / dstCF -> putreal; newline;
                                     1 / dstCF -> srcOS.addConvFactor;
                                     floatDecl.OG[] -> srcQual[] -> dstQual[]
                                  // (srcCF <> 0) and (dstCF = 0) then
                                     '**** addConvFactor: ' -> puttext;
                                     srcOS.doPT -> puttext; ' ' -> put;
                                     srcCF -> putreal; newline;
                                     srcCF -> srcOS.addConvFactor;
                                     floatDecl.OG[] -> srcQual[] -> dstQual[]
                                  // (srcCF <> 0) and (dstCF <> 0) then
                                     '**** addConvFactor: ' -> puttext;
                                     srcOS.doPT -> puttext; ' ' -> put;
                                     srcCF * dstCF -> putreal; newline;
                                     srcCF * dstCF -> srcOS.addConvFactor;
                                     floatDecl.OG[] -> srcQual[] -> dstQual[]
                                  // (srcCF = 0) and (dstCF = 0) then
                                     (* CF = 0 means that srcU and dstU both
                                      * are the base unit of the dimension
                                      *)
                                     floatDecl.OG[] -> srcQual[] -> dstQual[]
                                  else
                                     (*Should not happen! *)
                                     '\n!!!! OBS! Different units in same '
                                     'dimension but'-> putline;
                                     '     the combination of conversion'
                                     ' factors is not handled:' -> putline;
                                     '     srcCF: ' -> puttext;
                                     srcCF -> putreal; ','->put;
                                     'dstCF: ' -> puttext;
                                     dstCF -> putReal; newline;
                                     '     srcU: ' -> puttext; 
                                     srcU[] -> puttext;
                                     ' dstU: ' -> puttext; dstU[] -> putline;
                                     '**   src: ' -> puttext;
                                     srcOs.dopt -> putline;
                                     '**   dst: ' -> puttext; dopt -> putline
                                 if)
                              else
                                 (* do we need matchUnit? 
                                  * We have srcU and dstU from above,
                                  * so just check srcU = dstU ?
                                  * and canonicalize dstU
                                  *)
                                 (# UT: ^UnitTree; dstBV,srcBV: ^BaseVector
                                 do dstU[] 
                                      -> parseUnit 
                                      -> UT[] -> mkBaseVector -> dstBV[];
                                    (if false then
                                        '**   checkqual:parsed:dstU: '->puttext; 
                                        true -> UT.print -> putline;
                                        dstBV.print;
                                    if);
                                    srcU[] 
                                      -> parseUnit 
                                      -> UT[] -> mkBaseVector -> srcBV[];
                                    (if false then
                                        '**   checkqual:parsed:srcU: '->puttext; 
                                        true -> UT.print -> putline;
                                        srcBV.print; 
                                    if);
                                    (if srcBV[] -> dstBV.equal then
                                     else
                                        'non matching unitsNEW:' -> unitWarning;
                                        '*** srcU:'->puttext; srcU[]  -> putline;
                                        true -> UT.print -> putline;
                                        srcBV.print; 
                                        '*** dstU:'->puttext; dstU[]  -> putline;
                                        dstBV.print
                                    if);
                                 #);
                                 floatDecl.OG[] -> srcQual[] -> dstQual[]
                         if)if)
                      else
                         (if false then (* this  case is not complete! *)
                             'ToBeFixed:srcU:' -> puttext; srcU[] -> puttext;
                             ' srcOS: ' -> puttext; srcOs.dopt -> puttext;
                             ' dstU: ' -> puttext; dstU[] -> puttext;
                             ' dst: ' -> puttext; dopt -> putline
                         if)
                 if)if);
               (* if src and dst have units:  srcQual = dstQual = floatDecl *)
               (* We need to call getV_ qual at the point of the 
                * ObjectInvocation: X := exp or R. foo
                * to get the actual binding of possible virtuls
                * at the point of call
                *);
               ('srcQual',srcQual[]) -> displayB; (* there is also a Display *)
               ('dstQual',dstQual[]) -> displayB;
               (if isConst and isAssign then 
                   (* OG is left-part of assign as in aPoint1 := aPoint2 *)
                   (if OG.isValueObj then
                    else
                       error
                   if)
                else
                   (if true
                    // OG.isBasicValue then
                       (* The value_prim cases below is to handle
                        *    _V: ?Value 
                        * in patterns integer, char and boolean
                        *)
                       (if srcQual[] <> none then
                           (if srcQual.primNo
                            // integer_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim 
                                // boolean_prim // float_prim then
                                else
                                   error
                               if)
                            // char_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim // value_prim then
                                else
                                   error
                               if)
                            // boolean_prim then
                               (if dstQual.primNo 
                                // boolean_prim // integer_prim then 
                                else
                                   error 
                               if)
                            // float_prim then
                               (if dstQual.primNo 
                                // float_prim // integer_prim then 
                                else
                                   error 
                               if)
                                                              
                            // value_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim // value_prim then
                                else
                                   error
                               if)                               
                            else
                               error
                           if)
                        else
                           error
                       if)  
                    // OG.isValueObj then
                       (if true
                        // srcQual[] = dstQual[] then (* OK *)
                        // srcQual[] -> dstQual.inSuper then 
                           srcOS[] -> Warning
                           (# 
                           do 'The right-side value: "' -> msg;
                              srcOS.doPT -> msg;
                              '" is truncated ' -> msg;
                              '\n\twhen assigned to the left-side variable: "'
                                -> msg;
                              doPT -> msg;
                              '"' -> msg
                           #);
                        // dstQual[] -> srcQual.inSuper then 
                           '\n**** OBS! source is super of dest: ' -> putline;
                           '**   source: ' -> puttext; srcOS.dopt -> putline;
                           '**   dest  : ' -> puttext; dopt -> putline;
                           srcOS.father.father.father.dopt -> putline
                        // srcQual.isInteger // srcQual.isFloat then
                           srcOS[] -> semanticError
                           (#
                           do 'The integer or float expression: "' -> msg;
                              srcOS.doPT -> msg;
                              '"\n    cannot be assigned to: "' -> msg;
                              doPT -> msg; '"\n' -> msg;
                               (if true then
                                      '**** dstQual: ' -> putline;
                                      dstQual.dopt -> puthead;
                                      '**** srcQual: ' -> putline;
                                      srcQual.doPT -> puthead;
                                      '**   srcQual.father:' -> putline;
                                      srcQual.father.doPT -> puthead;
                                      '**   srcQual.father.father:' -> putline;
                                      srcQual.father.father.doPT -> puthead
                                  if)
                           #);
                        else
                           (if srcOS.primNo = indexedGet_prim then
                               (*'indexGet_prim'->putline*)
                               (* fix that the type of the indexed DI is 
                                * consistent with the left-side
                                *)
                            else
                               (* we should spell out whether or not srcOS, etc
                                * are objectRefs or valueObjs *)
                               srcOS[] -> semanticError
                               (#
                               do 'The expression:\t"' -> puttext;
                                  srcOS.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' 
                                    -> puttext;
                                  doPT -> puttext; '"' -> put; newline;
                                  (if trx then
                                      '**** dstQual: ' -> putline;
                                      dstQual.dopt -> puthead;
                                      '**** srcQual: ' -> putline;
                                      srcQual.doPT -> puthead;
                                      '**   srcQual.father:' -> putline;
                                      srcQual.father.doPT -> puthead;
                                      '**   srcQual.father.father:' -> putline;
                                      srcQual.father.father.doPT -> puthead
                                  if)
                       #)if)if)
                    else
                       (if true
                        // srcOS.isValueObj then
                           srcOS[] -> semanticError
                               (#
                               do 'The value expression: "' -> msg;
                                  srcOS.doPT -> msg;
                                  '"\n     cannot be assigned to '-> msg;
                                  'the object reference: "' -> msg;
                                  doPT -> msg; '"' -> msg
                               #);
                        // srcQual[] = dstQual[] then 
                           (* OK: and may be merged with the case below.
                            * Is splitted for test purposes, see below
                            *)
                        // srcQual[] -> dstQual.inSuper then (* OK *)
                           (* This is just for test purposes: 
                            * for references this is ok, but for values, 
                            * the right-side may be truncated, see above
                            *)
                           (if false then
                               srcOS[] -> Warning
                               (# 
                               do 'The right-side: "' -> msg;
                                  srcOS.doPT -> msg;
                                  '" refers to a subpattern/obj ' -> msg;
                                  'of the left-side: "' -> msg;
                                  doPT -> msg;
                                  '"' -> msg
                               #);
                           if)
                        // (srcQual[] <> none) 
                           and (dstQual[] -> srcQual.inSuper) then
                           srcOS[] -> QuaCheck
                           (# 
                           do 'It must be checked at run-time that "'
                                -> puttext;
                              srcOS.doPT -> puttext;
                              '"\n     is a subpattern of "' -> puttext;
                              doPT -> puttext; '"' -> put; newline
                           #)
                        // (srcQual[] <> none) and (srcQual.primNo = none_prim) then
                        else
                           (if reportSemErr then
                               srcOS[] -> semanticError
                               (#
                               do 'The reference expression:\t"' -> puttext;
                                  srcOS.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #);
                               (if true then
                                   '**** srcQual:' -> putline;
                                   srcQUal.dopt -> puthead;
                                   '**** dstQual: ' -> putline;
                                   dstQual.doPT -> puthead
                               if)
               if)if)if)if);
            #);
       #);
     isPatternDen:< BooleanValue
       (# E: ^Exp
       enter E[]  
       do E.ATd.doPT -> puthead;
          (if E.ATd[] <> none then E.ATd.isPatternDecl -> value if)
       #); 
     pattern::<
       (# checkQual::
            (* We come here for assignments of the form
             *    (this Speed) := exp
             * where 
             *    Speed: integer{... }
             *    Point: Value{ ... }
             *    Record: { ... }
             * This pattern must be a value of sub of basic 
             * - the latter may later be desclared as sub of Value
             *)
            (# trace: (# exit false #)
            do (if trace then
                   '**** Pattern:checkQual:\n' -> puttext; dopt -> puttext;
                   '\n**   :isAssign:' -> puttext; isAssign -> putBoolean;
                   ':srcOS: "' -> puttext; srcOS.dopt -> puttext; 
                   '"\n' -> puttext;
                   '**   isValueObj:' -> puttext; OG.isValueObj -> putBoolean;
                   ':isPrimitive:' -> puttext; isPrimitive -> putBoolean;
                   newline;
               if);
               (if isAssign then
                   (if true 
                    // OG.isValueObj then 
                       '**** pattern:checkQual:isValueObj:' -> putline;
                       '**   check assignTo: \n' -> puttext;
                       doPT -> putline;
                       '**  from: "' -> puttext; srcOS.doPT -> puttext;
                       '"\n\n' -> puttext
                    // isPrimitive then 
                       '**** pattern:checkQual:isPrimitive:shouldNotHappen' 
                         -> putline;
                    // OG.isBasicValue then 
                       '**** pattern:checkQual:isBasicValue:' -> putline;
                       '**   check assignTo: \n' -> puttext;
                       doPT -> putline;
                       '**  from: "' -> puttext; srcOS.doPT -> puttext;
                       '"\n\n' -> puttext
                    else 
                       (* Bad message - should be fixed *)
                       srcOS[] -> SemanticError
                       (#
                       do srcOS.doPT -> msg;
                          ' cannot be assigned to :\n' -> msg;
                          dopt -> msg;
                       #)
                   if)           
               if)
            #);
          checkActualArgs::
            (* theOI is the the ObjectInvocation calling this(Pattern) *)
            (# trace1:
                 (#
                 do (if trx then
                        ')\n--  theOI: "'->puttext; theOI.doPT->puttext;
                        '" theOI.on:'->puttext; theOI.on -> putint;
                        ' theOI.pn:' -> puttext; theOI.pn -> putint; newline;
                        '--  encOG: "' -> puttext; encOG.dopt -> puthead; 
                        '"'->putline;
                        '--  OI_OG: ' -> puttext; OI_OG.doPT -> puthead;
                    if);
                 #);
               T: ^text;
               trace2:
                 (# pn: @integer; ATd: ^Decl
                 do (if trx then
                        '--  got:itm:inx:' -> puttext;  inx -> putint; ' '->put;
                        itm[inx - 1].dopt -> putline;
                        ' on: ' -> puttext; itm[inx - 1].super.on -> putint; 
                        ' pn: ' -> puttext; 
                        (itm[inx - 1].super.last).pn -> putint; 
                        ' ATd: ' -> puttext; 
                        itm[inx - 1].super.ATd.doPT -> putline;
                        T[] -> OI_OG.IS.localSearch 
                          -> (ATd[],pn);
                        atD[] <> none -> putboolean; ' ' -> put; 
                        pn -> putint; 
                        '--  qual:' -> putline;
                        (itm[inx - 1].getQual).doPT -> putline
                    if)
                 #);
               fArgs: [6] ^Decl; inx,top: @ integer; 
               OI_OG: ^ObjectGenerator;
               OI_noMkOg: @boolean;
               mkOG:
                 (# OI: ^ObjectInvocation;
                    OGx: ^ObjectGenerator; IV: ^Invocation; IT: ^Items;
                    ITx: ^text; err: ^Text
                 enter OI[]
                 do (if trx then
                        '\n\n**** mkOG:OI.label:' -> puttext; OI.label -> putline;
                        '**   OI: ' -> puttext; OI.doPT -> putline;
                        '**   OG:\n' -> puttext; OG.doPT -> puthead;
                        (*'**   encOG: ' -> puttext; encOG.doPT -> putline;*)
                    if);
                    (* The code below needs to be cleaned up.
                     * For invocations like map(#FFF) or map({...}), only the latter
                     * is an ObjectGenerator, but we also need to check for matching
                     * signatures for the former.
                     * In addition, in any case for virtual args, we need to check
                     * if the actual binding is a sub of the virtual decl.
                     * And we must find out if OI_noMkOG should always be true
                     * for virtual arguments!? Probably yes!
                     * OBS! If there is a mix of args being data-items and virtuals,
                     * we have to create an OGx! Also we have not solved the problem
                     * for keyword patterns.
                     * Also! Why do checkQual as called below, not catch errors for
                     * virtual arguments?. Does checkQual only handle DataItems?
                     *)
                    L:
                      actualArgs.scanArgs
                      (# OGy: ^ObjectGenerator; i: @integer; ptn: ^Pattern
                      do current.label -> puttext; ' ' ->put;
                         current.dopt -> puttext;  ' ' ->put; newline;
                         i + 1 -> i;
                         (if 'ObjectGenerator' -> (current.label).equal then
                             current[] -> OGy[];
                             (* OGy.IS.isEmpty -> putboolean;*)
                             (if not OGy.IS.isEmpty then
                                 (if fArgs[i].isVirtual then
                                     (if traceSingularFunc then
                                         '** got virtual arg:singular: ' -> puttext; 
                                         fArgs[i].dopt -> putline;
                                         current.doPt -> putline; OI.doPT -> putline;
                                         '** OGy: ' -> puttext; OGy.doPT -> putline;
                                     if);
                                     fArgs[i][] -> ptn[];
                                     true -> OI_noMkOG;
                                     (if ptn.theSig.isSig 
                                         and (OGy[] -> mkSig-> ptn.thesig.equal) then
                                         (if traceSingularFunc then
                                             '**** Singular sub has same sig as super: '
                                               -> putline;
                                             ptn.doPt -> putline;
                                             '**   Singular sub: ' -> putline;
                                             OGy.doPT -> putline;
                                         if);
                                         none -> OGy.super.ATd[]; 
                                         none -> OGy.IS.superDesc[];
                                         leave L
                                      else
                                         (if OGy.getQual -> (ptn.OG.getQual).inSuper
                                             then
                                             (* ok *)
                                          else
                                             OI[] -> SemanticError
                                             (#
                                             do 'The binding: "' -> msg; 
                                                OGy.doPT -> msg;
                                                '" of the virtual pattern: "' -> msg;
                                                ptn.doPT -> msg;
                                                '"\n     must be a subpattern of the virtual pattern'
                                                  -> msg
                                         #)if);
                             if)if)if)
                         if)
                      #); (*newline;*)
                    (if OI_noMkOG then leave mkOG if);
                    (if ('ObjectInvocation_KeyWord' -> (OI.label).equal) then
                        true -> OI_noMkOG;
                        leave mkOG
                     else
                        '(' -> ITx[];
                        (OI.doPTnoComments).scanAll
                        (#
                        do (if ch >= ' ' then ch -> ITx.put else ';' -> ITx.put if)
                        #);                            
                        ') {' -> ITx.puttext;
                        (for i: top repeat
                             ' ' -> ITx.puttext;
                             fArgs[i].sig.dopt -> ITx.puttext; ';' -> ITx.puttext
                        for);
                        '}' -> ITx.puttext;  
                        (if trx then
                            '**   mkOG:ITx:\n'->puttext; ITx[] -> putline;
                        if);
                        ITx[] -> parseObjectGeneratorText -> (err[],OGx[]);
                        (if trx then
                            '\n****  OGx:label:' -> puttext;
                            OGx.label -> putline;
                            OGx.doPT -> putline;
                            (*'**** OG: ' -> putline; OG.dopt -> putline;*)
                            '**** ptn:' -> putline; dopt -> putline;
                            '**** encOG: ' -> putline; encOG.dopt -> putHead
                        if);
                        (if true then
                            encOG[] -> OGx.father[];
                            encOG.IS[] -> OGx.setUpOrigin;
                         else
                            OG[] -> OGx.father[];
                            OG.IS[] -> OGx.setUpOrigin;
                        if);
                        (if trx then '**   check:OGx: ' -> putline if);
                        (if false then
                            (none,OGx.IS[],none,true) -> OGx.check;
                         else
                            (if true then
                                (none,encOG.IS[],none,true) -> OGx.check;
                             else
                                (none,OGx.origin[],none,true) -> OGx.check;
                        if)if)
                    if);
                 exit OGx[]
                 #);
               checkIfSuperIsSig:
                 (# E: ^ObjectSpecification; i: @integer; OGy: ^ObjectGenerator; ptn: ^Pattern
                 enter(E[],i)
                 do (if false then
                        '**** checkIfSuperIsSig:'->puttext; E.dopt -> puthead;
                    if);
                    (if 'ObjectGenerator' -> (E.label).equal then
                        E[] -> OGy[];
                        (* OGy.IS.isEmpty -> putboolean;*)
                        (if not OGy.IS.isEmpty then
                            (if fArgs[i].isVirtual then
                                (if false and traceSingularFunc then
                                    '** got virtual arg:singular:\n' -> puttext; 
                                    fArgs[i].dopt -> puthead;
                                    (*OI.doPT -> putline;*)
                                    '** OGy:\n' -> puttext; OGy.doPT -> puthead;
                                if);
                                fArgs[i][] -> ptn[];
                                (if ptn.theSig.isSig 
                                    and (OGy[] -> mkSig-> ptn.thesig.equal) then
                                    (if traceSingularFunc then
                                        '**** Singular sub has same sig as super: '
                                          -> putline;
                                        ptn.doPt -> putline;
                                        '**   Singular sub: ' -> putline;
                                        OGy.doPT -> putline;
                                    if);
                                    none -> OGy.super.ATd[]; 
                                    none -> OGy.IS.superDesc[];
                    if)if)if)if)
                 #);
               itm: [6] ^ObjectSpecification (*ObjectGenerator*);

            do (if (trx) or traceGetQual then
                   '**** Pattern:checkActualArgs:' -> putline; dopt -> puthead;
                   '**   actualArgs: '->puttext; actualArgs.doPT -> puttext;
                   ' fArgs('->puttext;
                   OG.IS.scanNonBoundItemArgs
                   (#do currentArg.dopt -> puttext; ','  -> put #);
                   ')'->putline;
                   '\n**   encOG:' -> putline; encOG.doPT -> putHead;
               if);  
               OG.IS.scanNonBoundItemArgs
               (#
               do (if (top + 1 -> top) > fArgs.range then 
                      fArgs.range -> fArgs.extend;
                      itm.range -> itm.extend
                  if);
                  currentArg[] -> fArgs[top][];
               #);
               (if useMkOG and (top > 0) then
                   theOI[] -> mkOG -> OI_OG[]; 
                   (if not OI_noMkOG then 
                       trace1;
                       OI_OG.IS.scanSons
                       (# ATd: ^Decl; pn: @integer
                       do (if (inx + 1 -> inx) > 0 then
                              current[] -> itm[inx][];
                              (*trace2;*)
                           else
                              (if trx then newline if)
                   if)#)if)
                else
                   (if useMkOG and trx then 'no formal args)' -> putline if) 
               if);
               0 -> inx;
               actualArgs.scanArgs
               (# srcQual,dstQual: ^ObjectGenerator; DI: ^DataItem; 
                  OGS,OGSx: ^OGsequence; P: ^OGpath; E: ^ObjectCall; 
                  ATdx: ^Decl; pn: @integer; 
               do inx + 1 -> inx; 
                  (if trxA->trx then
                      '**   actualArg:inx:' -> puttext; inx -> putint; 
                      ':arg: ' -> puttext; current.dopt -> puttext;
                      ' :formal: ' -> puttext; fArgs[inx].dopt -> putline;
                  if);
                  
                  (if inx > top then
                      actualArgs[] -> SemanticError
                      (# 
                      do 'More actual parameters:\n\t"' -> msg;
                         actualArgs.doPT -> msg; 
                         '"\n    than formal parameters:\n\t"' -> msg;
                         sig.doPT -> msg; '"' -> msg
                      #)
                   else
                      (if not useMkOg then
                          (*'Xxx' -> (fArgs[inx].sig.dopt).equalNCS -> trxA;*)
                          (current[],inx) -> checkIfSuperIsSig;
                          (if traceUnit or trxA then
                              '**** new argHandler:' -> putline; dopt->puthead;
                              '**** fArg: ' -> puttext; fArgs[inx].dopt -> puthead;
                              '**** aArg: ' -> puttext; current.dopt -> puthead;
                              '**   label: ' -> puttext; current.label -> puthead;
                              fArgs[inx].sig.dopt -> putline;
                              '**   OG:' -> putline; OG.dopt -> puthead;
                              fArgs[inx].sig.dopt 
                                -> OG.IS.localSearch -> (ATdx[],pn);
                              (if ATdx[] <> none then
                                  '**   pn=' -> puttext; pn -> putint; newline
                              if);
                              '**   encOG:' -> putline; encOG.doPT -> puthead;
                          if);
                          (if (theOI.savedOGS[]->OGS[]) <> none then
                              (if trxA then
                                  '**   savedOGS:'->puttext;
                                  (if theOI.savedOI[] <> none then 
                                      theOI.savedOI.dopt -> puthead
                                   else
                                      'noOI'->putline
                                  if);
                                  theOI.savedOGS.print
                              if);
                           else
                              '**   savedOGS is none: '->puttext;
                              theOI.dopt -> puthead;
                          if);
                          (* foo:
                           *    fArgs[inx] = R: ref T
                           *               = S: obj T { ...}
                           *               = ...
                           * current    = exp = ObjectInvocation, const, ...
                           *)
                          (if useGetVqualX then
                              (* Given foo: { in R: ref V; W:< T }, and
                               *    X: ...; foo(S,#TT)
                               * we must get qual as if
                               *    X: ...; foo(S,#TT).R; foo(S,#TT).W
                               *so some form of nest must be used
                               *)
                              (if true then
                                  fArgs[inx].origin.father[]
                                    -> OGsequence -> OGSx[];
                                  OGS[] -> OGSx.pred[];
                                  true -> OGSx.isNest;
                                  OGSx[] -> OGS[];
                                  (for pn repeat OGS.pred -> OGS[] for);
                                  (encOG[],false,OGS[]) 
                                    -> fARgs[inx].getVqualX 
                                    -> (OGS[],dstqual[]);
                                  (if  traceUnit or trx then
                                      '**   :after:fArgs.getVqualX:dstQual: '
                                        -> putline;
                                      dstQual.dopt -> puthead;
                                      '**   OGS:'->putline; OGS.print
                                  if)
                               else
                                  (OG[],true,OGS[]) 
                                    -> fArgs[inx].getVQualX 
                                    -> (OGS[],dstQual[]);
                              if)
                           else
                              (OG[],none,none) 
                                -> fArgs[inx].getVQual 
                                -> (P[],OGS[],dstQual[]);
                          if);
                          (if  traceUnit or trxA then
                              '**   dstQual:OF: ' -> puttext; 
                              fArgs[inx].dopt->puttext;
                              ' IS:' -> putline; dstQual.dopt -> puthead;
                          if);
                          
                          (none,encOG[]) -> current.semcheck -> srcQual[];
                          (if isLast and (inx = 1) and srcQual.isUnitValueObj then
                              (*srcQual[] -> singleUnitArgQual[]*)
                          if);
                          (if traceUnit or trxA then
                              '**   srcQual:OF: ' -> puttext; 
                              current.doPT -> puttext;
                              ' IS:' -> putline; srcQual.dopt -> puthead;
                              (if  singleUnitArgQual[] <> none then
                                  '**   hasOneUnitArg:true:Qual: ' -> putline;
                                   singleUnitArgQual.dopt -> puthead
                              if)
                          if)
                       else 'Tango!'->putline;
                          (if OI_noMkOG then
                              (if true then
                                  (none,encOG[]) -> current.semcheck -> srcQual[]
                               else
                                  current.getQual -> srcQual[];
                              if);
                              fArgs[inx].getQual -> dstQual[];
                           else
                              (if trx then
                                  '**   theOI.theOG:encOG: ' -> putline;
                                  encOG.dopt -> puthead;
                                  '**** current:' -> puttext; current.doPT -> putline
                              if);
                              (if true then
                                  (if true then
                                      (none,theOI.specialEnclosingObjectGenerator)
                                        -> current.semCheck -> srcQual[];
                                   else
                                      (none,encOG[]) -> current.semCheck -> srcQual[];
                                  if);
                                  (*current.getQual -> srcQual[]*)
                               else
                                  (none,theOI.enclosingObjectGenerator) 
                                    -> current.semCheck -> srcQual[]
                              if);
                              (if trx then
                                  '**   srcQual: ' -> putline;;
                                  srcQual.doPT -> putline
                              if);
                              (if fArgs[inx].isVirtual then
                                  (if false then
                                      '**** virtual arg:' -> puttext; 
                                      fArgs[inx].dopt -> putline;
                                      theOI.dopt -> putline;
                                  if);
                                  current.getQual -> srcQual[];
                                  fArgs[inx].getQual -> dstQual[]
                               else
                                  (if fArgs[inx].isDataItem then
                                      fArgs[inx][] -> DI[];
                                      true -> DI.nestPath
                                  if);
                                  (if trx then
                                      '**   before:itm[inx].getV_ qual: ' -> puttext;
                                      itm[inx].doPT -> putline;
                                      '**   EncOG:\n' -> puttext; encOG.dopt -> putHead;
                                  if);
                                  (if true then
                                     (* OI_OG[] 
                                        -> (itm[inx].super.last).getV_?qual
                                        -> dstQual[];*)
                                  if);
                                  (* OBS fArgs may be pattern or data-item *)
                          if)if);
                          (if trx then
                              '*** arg:src:'-> puttext; current.dopt -> putline;
                              '*** srcQual:'->putline; srcQual.doPT -> putline;
                              '*** arg:dst:'-> puttext; fArgs[inx].dopt -> putline;
                              '*** dstQual:'->putline; dstQual.doPT -> putline;
                      if)if);
                      (current[],srcQual[],dstQual[],false) -> fArgs[inx].checkQual;
                  if);
               #); 
               (if (inx < top)  then
                   actualArgs[] -> SemanticError
                   (# 
                   do 'More formal than actual parameters' -> msg;
                      actualArgs.doPT -> msg;
                      '\n'-> msg;
                      sig.doPT -> msg;
                   #)
               if)
            #);
          getVqualX::
            (#
            do (if (trx) or traceGetV_qual then
                   '**** Pattern:getVqualX: ' -> puttext; sig.doPT -> puttext;
                   ' :isVirtual:'-> puttext; isVirtual-> putBoolean; newline;
                   OGS.print
               if);
               (if isVirtual then
                   (if trx then
                       '**   OGS: ' -> putline; OGS.print;
                   if);
                   (this(pattern)[],OGS.FB) -> findBinding -> qual[];
                   (if qual.IS.isEmpty then
                       qual.super.ATd.OG[] -> qual[]
                   if);
                   (if trx then
                       '**** got binding: ' -> putline;
                       qual.dopt ->puthead
                   if)
                else
                   OG[] -> qual[]
               if);
            #);
          getQual::
            (# 
            do (if traceGetQual then
                   '*** Pattern:getQual: '-> puttext; sig.doPT -> putline
               if);
               (none,origin[],origin[],true) -> check;
               (if isRecursive then
                   (* For a pattern
                    *    foo(...) -> res: ? foo ...
                    * getQual is called on the foo return value
                    * giving a recursive call of getQual
                    *)
                   (if traceGetQual then
                       '*** isRecursive' -> putline
                   if);
                   OG[] -> qual[];
                   (*false -> isRecursive;*)
                   leave getQual
               if);
               inner;
               (if traceGetQual then
                   'Pattern:getQual:B: "' -> puttext; 
                   sig.doPT -> puttext; '"' ->put; newline
               if);
               true -> isRecursive;
               (* this is probably just a hack 
                * - we need to handle virtuals as in the Beta compiler
                *)
               L:
                 (if qual[] = none then
                     (if isVirtual then
                         (*'*** Virtual: ' -> puttext; dopt -> puttext; 
                          ' on: ' -> puttext; OG.super.on -> putint;
                          ' pn: ' -> puttext; OG.super.pn -> putint; newline;*)
                         OG.getQual -> qual[];
                         (if traceGetQual then
                             'getQual:Virtual: ' -> puttext; 
                             qual.doPT -> puthead;
                             OG.doPT -> puthead
                         if)
                      else
                         (if traceGetQual then
                             'Pattern:getQual:C: ' -> puttext; sig.dopt -> putline;
                         if);
                         OG.IS.scanAllItemDecls
                         (# DI: ^DataItem
                         do (if currentDcl.isOutArg then
                                (if currentDcl.isDAtaItem then
                                    (currentDcl[] -> DI[]).getQual -> qual[];
                                    leave L;
                                if)
                            if)
                         #);                       
                         OG[] -> qual[];
                 if)if);
               false -> isRecursive;
               (if traceGetQual then
                   'Pattern:getQual:D: "\n' -> puttext; 
                   (if qual[] <> none then 
                       qual.doPT -> puttext
                    else 'none'->puttext
                   if);
                   '"' -> put; newline
               if)
            #);
          semCheck::
            (# lastSuper: ^Exp
            do (if trx then 
                   '**** Pattern:semCheck: '->puttext; sig.dopt -> putline
               if);
               (if ((OG.super.last -> lastSuper[]).args[] <> none) and
                       (lastSuper.args.length = 0) then
                   true -> lastSuper.noArgsCheck
               if);
               (if ptnKind // FinalPtn // FurtherPtn then
                   (if false then
                       '**** PTN:semCheck:binding: ' -> puttext;
                       dopt -> putline;
                       vDcl.dopt -> putline;
                   if);
                   (if vDcl.theSig.isSig and (theSig[]->vDcl.thesig.equal) then
                       (if true then
                           '**** Sub has same sig as super' -> putline;
                           doPT -> putline;
                       if);
                       none -> OG.super.ATd[]; none -> OG.IS.superDesc[]
                    else
                       (if OG.getQual -> (vDcl.OG.getQual).inSuper then
                           (* '**   qual ok'->putline*)
                        else
                           this(Pattern)[] -> SemanticError
                           (#
                           do 'The binding: \n"' -> msg; OG.doPT -> msg;
                              '"\n****of the virtual pattern:\n "' -> msg; 
                              vDcl.doPT -> msg; '"\n'->puttext;
                              '****must be a subpattern of the virtual pattern'
                                -> msg
                           #);
               if)if)if)
            #)
       #);
     ObjectCall::<
       (# semCheck::
            (#
            do (if  traceUnit or trx then
                   '**** ObjectCall:semCheck: ' -> puttext; dopt -> puthead;
               if);
               (rec[],encOG[]) -> super.semCheck -> eOG[];
               true -> done
            #);
          getVqualX::
            (#
            do (if trx then
                   '**** ObjectCall:getVqualX: ' -> puttext; dopt -> puthead;
               if);
               (if false and (thequal[] <> none) then
                   (if trx then
                       '**** ObjectCall:getVqual:use:theQual:'->putline;
                       theQual.dopt -> puthead
                   if);
                   theQual[] -> qual[];
                else
                   (encOG[],false,OGS[]) -> super.getVqualX -> (OGS[],qual[]);
               if)
            #);
          getVqual::
            (#
            do (if trx then
                   '**** ObjectCall:getVqual: ' -> puttext; dopt -> puthead;
               if);
               (if (thequal[] <> none) then
                   (if trx then
                       '**** ObjectCall:getVqual:use:theQual:'->putline;
                       theQual.dopt -> puthead
                   if);
                   theQual[] -> qual[];
                else
                   (encOG[],P[],OGS[]) -> super.getVqual -> (P[],OGS[],qual[]);
               if)
            #);
          getQual::
            (#
            do (if trx then 'ObjCall:getQual: ' -> puttext; doPT -> putline if);
               super.getQual -> qual[];
            #);
       #);
         
     ObjectGenerator::<
       (# semcheck::
            (# D: ^Decl
            do (if trx then
                   '**** ObjectGenerator:semCheck:'->putline; dopt -> puthead;
                   (if trx then
                       '**   encOG: ' -> putline; 
                       (if encOG[] <> none then
                           encOG.doPT -> putHead
                        else
                       'none' -> putline
               if)if)if);
               (if false then
                   (rec[],encOG[]) -> super.semCheck -> eOG[];
                   ('**** ObjGen:semCheck:super:eOG',eOG[]) -> display;
                   (if not IS.isEmpty then 
                       (rec[],this(ObjectGenerator)[]) -> IS.semCheck -> eOG[];
                   if);
                else
                   (rec[],encOG[]) -> super.semCheck -> eOG[];
                   ('**** ObjGen:semCheck:super:eOG',eOG[]) -> display;
                   (if not IS.isEmpty then 
                       (rec[],encOG[]) -> IS.semCheck -> eOG[];
                   if); 
                   (if trx then
                       '**** OI:semcheck:IS not empty:eOG: ' -> putline;
                       eOG.dopt -> puthead;
                   if);
                   (if (getReturnDecl -> D[]) <> none then
                       (if trx then
                           '**** returnDecl: ' -> puttext; D.dopt -> putline
                       if);
                       D.getQual -> eOG[]
                   if)
               if);
               true -> done;
            #);
          getVqualX::
            (#
            do (if trx then
                   '**** ObjectGenerator:getVqualX: ' -> puttext; 
                   dopt -> puthead
               if);
               (if IS.isEmpty then
                   (encOG[],false,OGS[]) -> super.getVqualX -> (OGS[],qual[]);
                else
                   this(ObjectGenerator)[] -> qual[]
               if)
            #);
          getVqual::
            (#
            do (if trx then
                   '**** ObjectGenerator:getVqual: ' -> puttext; sig.dopt -> putline
               if);
               (if IS.isEmpty then
                   (encOG[],P[],OGS[]) -> super.getVqual -> (P[],OGS[],qual[]);
                else
                   this(ObjectGenerator)[] -> qual[]
               if)
            #);       
          getQual::
            (# 
            do (if traceGetQual then
                   '*** ObjectGenerator:getQual:primNo: '->puttext; 
                   primNo -> putint; ' '-> put; 
                   IS.primNo -> putint; ' '-> put; 
                   (if super.ATd[] <> none then
                       super.Atd.primNo -> putint; ' '-> put; 
                   if);
                   ':isPrimitive: ' -> puttext; isPrimitive -> putboolean;
                   ':' -> put; doPT -> putline
               if);
               (* Should only be called for singular OGs
                * If part of pattern decl, argScope may be wrong
                *)
               (none,origin[],origin[],true) -> check;
               (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   L:  IS.scanAllItemDecls
                     (# DI: ^DataItem
                     do (if currentDcl.isOutArg then
                            (if currentDcl.isDAtaItem then
                                (currentDcl[] -> DI[]).getQual -> qual[];
                                leave L
                            if)
                        if)
                     #);
                   (if qual[] = none then
                       this(ObjectGenerator)[] -> qual[]
                   if)
               if);
               (*'qual:' -> putline; qual.dopT -> putline;*)
            #); 
          XinSuper: BooleanValue
            (# lQ: ^ObjectGenerator
            enter lQ[]
            do ('inSuper:lQ',lQ[]) -> display;
               ('rQ',lQ[]) -> display;
               L:
                 (if lQ[] = this(ObjectGenerator)[] then
                     true -> value 
                  else
                     (if (lQ[] <> none) then
                         (if (lQ.primNo <> object_prim) then
                             lQ.super.getQual -> lQ[];
                             (if lQ[] =  none then
                                 objectDecl.getQual -> lQ[]
                             if);
                             restart L;
                 if)if)if)
            #);
       #);
     Items::<
       (# semCheck::
            (# checkInterfaceRestrictions:
                 (* This decl: must be a pattern (or virtual)
                  *    foo: entry(# do ... #)
                  * where entry in interface.rQual
                  * We also need to handle several levels
                  *    M0: (# foo: Q(# ... #); ... #)
                  *    M1: M0(# [interface[E]] E: (# ... #); ... #)
                  *    M2: M1(# [interface[F]] F: (# ... #); ... #)
                  *    M3: M2(# ... #)
                  * Do M1/M2-restrictions apply to M0?
                  * M2 further restricts subpatterns ...
                  * Methods in M2 are restricted by M1 but not M2
                  * For x: ^M3
                  *   x.bar -- if bar in M3 then all restrictions
                  *                   in M2, M1 restrictions
                  *            else no restrictions
                  *            if virtual, then restrictions at point of
                  *            original declaration apply
                  *            Probably different if argument restrictions 
                  *            are added
                  * THE ABOVE IS NOT IMPLEMENTED
                  *)
                 (# 
                 do (if false then
                        '**** checkInterface: ' -> puttext; 
                        (if sig[] <> none then sig.dopt -> putline if);
                    if);
                    (if superDesc[] <> none then
                        (if true -> hasInterfaceRestrictions then
                            (if false then
                                '**** Interface restrictions:\n' -> puttext;
                            if);
                            scanDecls
                            (#
                            do L:
                                 (#
                                 do scanInterface
                                    (# 
                                    do (if false then
                                           '**** check:\n' -> puttext;
                                           currentDcl.dopt -> puttext;
                                           '\n**   isSubOf:\n' -> puttext;
                                           current.dopt -> putline;
                                           current.ATd.OG.dopt -> puthead
                                       if);
                                       (if currentDcl.OG[] -> current.ATd.OG.inSuper then
                                           leave L
                                    if)#);
                                    currentDcl[] -> SemanticError
                                    (#
                                    do 'The pattern: "' -> msg;
                                       currentDcl.sig.dopt -> msg;
                                       '" must be a subppattern of: '
                                         -> msg;
                                       scanInterface
                                       (# i: @integer
                                       do (if (i +1 -> i) > 1 then ' or ' -> msg if);
                                          '"' -> msg;
                                          current.dopt ->msg; '"' -> msg
                    #)#)#)#)if)if)
                 #);               
               checkArgumentRestrictions:
                 (# nl: @boolean
                 do scanAllDecls
                    (# constraintsOK: @boolean
                    do (if currentDcl.isInArg then
                           true -> constraintsOK;  
                           (if newBasicProp.hasArguments then
                               (*'**** new prop:arguments: ' -> puttext;*)
                               (*newBasicProp.arguments.doPT -> putline;*)
                               L: newBasicProp.scanArguments
                                 (# 
                                 do 
                                    current.scanSons
                                    (# OI: ^ObjectInvocation
                                    do current[] -> OI[];
                                    (if false then
                                        '\n** checkARg: ' -> puttext; 
                                        currentDcl.dopt -> puttext;
                                        ' is: ' -> puttext; 
                                        current.dopt -> putline; 
                                    if);
                                    false -> constraintsOK;
                                (if true
                                 // 'immutable' -> OI.ptnId.T.equalNCS then
                                    (if false then
                                        '** isImmutable?' -> puttext;
                                    if);
                                    (if currentDcl.isImmutable then
                                        (if false then
                                            'Yes:immutable: ' -> puttext; 
                                            currentDcl.doPT -> putline;
                                        if);
                                        true -> constraintsOK;
                                        leave L
                                     else
                                        (* need arguments[value] *)
                                        (if currentDcl.OG.isValueObj then
                                            (if false then
                                                'Yes:immutable value: '
                                                  -> puttext;
                                                currentDcl.doPT -> putline;
                                            if);
                                            true -> constraintsOK;
                                            leave L
                                        if)
                                    if);
                                 // 'unique' -> OI.ptnId.T.equalNCS then
                                    (if currentDcl.OG.IS.isUnique then
                                        true -> constraintsOK;
                                        leave L
                                    if)
                                 else
                                    (* not yet complete! *)
                                if)#);
                                 #);
                               (if not constraintsOK then
                                   currentDcl[] -> Warning
                                   (#
                                   do 'Constraints not satisfied in: "' -> msg;
                                      currentDcl.dopt -> msg;
                                      '"\n     must be one of: ' -> msg; 
                                      newBasicProp.scanArguments
                                      (# i: @integer
                                      do (if (i + 1 -> i) > 1 then ' or ' -> msg if);
                                         current.doPT -> qmsg; 
                                      #);
                                      '\n'->msg
                                   #)
                               if);
                       if)if)
                    #);
                 #);               
               checkImmutability:
                 (#
                 do (if newBasicProp.immutable and
                        (super.ATd[] <> none) and
                        not superDesc.isImmutable then 
                        this(items)[] -> semanticError
                        (#
                        do 'An objectGenerator cannot be marked "immutable"'
                             -> msg;
                           '\n     unless its superpattern is immutable'
                             -> msg
                        #)
                    if)
                 #)
            do (if trx then '**** Items:semCheck: ' -> putline if);
               this(Items).encOG[] -> encOG[] -> eOG[]; 
               (* perhaps a bad idea to use the same name here, encOG!? *)
               none -> rec[];
               checkArgumentRestrictions;
               checkInterfaceRestrictions;
               checkImmutability;
               scanSons
                   (# 
                   do (rec[],eOG[]) -> current.semCheck;
                      current[] -> rec[]
                   #);
               true -> done
            #);
          hasInterfaceRestrictions: BooleanValue
            (# isFirst: @boolean
            enter isFirst
            do (if superDesc[] <> none then
                   false -> superDesc.hasInterfaceRestrictions -> value
               if);
               (if not value and not isFirst then
                   (if not (newBasicProp.hasIFR -> value) then

               if)if)
            #);
          scanInterface:
            (# current: ^Lexem(*Property*)
            do (if superDesc[] <> none then
                   &superDesc.scanInterface
                   (#
                   do current[] -> this(scanInterface).current[];
                      inner scanInterface
                   #);
                   (if newBasicProp.hasIFR then
                       newBasicProp.interface.args.scanSons
                       (# INV: ^Invocation; N: ^Name; OI: ^ObjectInvocation
                       do (if false then
                              '** arg: ' -> puttext; current.dopt -> putline;
                          if);
                          current.scanSons
                          (#do (if false then current.label -> putline; if);
                          (if current## = ObjectInvocation## then
                              current[] -> OI[]; OI.ATd[] -> OI.ptnId.ATd[];
                              OI.ptnId[] -> this(scanInterface).current[];
                              inner scanInterface
                          if)#)
                       #);
                    if)
            if)#);
       #);
     Invocation::<
       (# semcheck::
            (#
            do (if trx then
                   '**** Invocation:semCheck: '-> puttext; dopt -> putline;
                   (if false then
                       '**   encOG:' -> putline; 
                       (if encOG[] <> none then
                           encOG.doPT -> puthead
                        else
                           'none' -> putline
                   if)if)
               if);
               none -> rec[]
            #);
          getVqualX::
            (#
            do (if trx then
                   '**** INV:getVqualX:'->puttext; dopt -> puthead;
               if);
               encOG[] -> qual[];
               scanSons
               (#
               do (qual[],not isFirst,OGS[]) -> current.getVqualX -> (OGS[],qual[]);
               #)     
            #);
          getVqual::
            (#
            do (if trxA then
                   '**** INV:getVqual:'->puttext; dopt -> puthead;
               if);
               encOG[] -> qual[];
               scanSons
               (#
               do (if not isFirst then
                      '**** INV:getVqual:remote: '->puttext; dopt -> puthead;  
                      current.dopt -> putline;
                      OGS.print
                  if);
                  (qual[],P[],OGS[]) -> current.getVqual -> (P[],OGS[],qual[]);
               #)
            #);
          pathToDclX::
            (# E: ^Exp; n: @integer; INV: ^Invocation; S: ^SuperOGsequence;
               OI: ^ObjectInvocation; 
            do (if trx or trace_PathToDcl then
                   '**** Invocation:pathToDclX: ' -> puttext; dopt -> putline;
               if);
               L:
                 scanSons
                 (# OC: ^ObjectCall
                 do current[] -> E[];
                    (if ((n + 1 -> n) = 1) and (P[] = none) then
                        (if 'BracketedExp' -> (E.label).equal  then 
                            ((E.son[] -> INV[]).last) -> E[];
                            (if trx then
                                'BracketedExp' -> putline;
                                dopt -> putline;
                                E.doPT -> putline;
                            if)
                        if);
                        (if E.ATd.primNo = this_prim then
                            (if trx then '**   got:@this:'->putline; if);
                            E.args.scanArgs
                            (#
                            do (if trx then 
                                   current.dopt -> puttext; ' ' -> put;
                                   current.label -> puttext;
                               if);
                               ((current[]-> OC[]).super).last-> E[]; 
                            #)
                        if);
                        (if trx then
                            '**** First:E.on='->puttext; E.on ->putint; 
                            ' E:'->puttext; E.doPT -> putline
                        if);
                        (if E.isObjectInvocation then
                            E[] -> OI[];
                          (*  P[] -> OI.pathToDcl -> P[]*)
                        if);
                        (if trx then
                            '**** pathToDclX:beforeComputeOGseq: ' -> puttext;
                            OI.dopt -> putline;
                            P.print
                        if);                        
                        P.computeOGSeq -> S[];
                        (if trx  then
                            '**** pathToDclX:first:OI: '-> puttext; 
                            OI.dopt -> putline; S.print
                        if)
                     else (* remote: n > 1, X as in R.X *)
                        (if trx then
                            '**** in PathToDclX:E: '->puttext; E.dopt -> putline
                        if);
                        (if trx then
                            '**   isVirtual:'->puttext;
                            P.dcl.isVirtual -> putBoolean; newline;
                            '**** P.dcl:'->putline; P.dcl.dopt -> putline;
                            ('P.vDcl',P.vDcl[]) -> putPT;
                            '**** in PathToDclX'->putline; 
                            (if S[] <> none then S.print else 'none'->putline if)
                        if);
                        (if false then
                        (# Q: ^ObjectGenerator
                        do S[] -> P.getB -> Q[];
                           (if false and trx then
                               '****  PathToDclX:next:has:out:'->putline;
                               Q.dopt -> putline;
                               (if (Q.getReturnDecl) <> none then
                                   (Q.getReturnDecl).dopt ->putline
                           if)if)
                        #)if);
                        (if P.dcl.isVirtual then
                            S[] -> P.getB -> qual[];
                            (if false and trx then
                                '**** S.qual: ' -> putline; qual.dopt -> putline
                            if);
                            qual[] -> S.nestSuper -> S[];
                         else
                            P.dcl.OG[] -> S.nestSuper -> S[]
                        if);
                        (if false and trx then
                            '**** in PathToDclX:with:nestSuper:'->putline; 
                            S.print;
                        if);
                        (if false and trx then 
                            '**   PathToDclX:next:path:E: ' -> puttext;
                            E.doPT -> puttext;
                            ' E.on=' -> puttext; E.on -> putint; (* always 0 *)
                            ' E.pn=' -> puttext; E.pn -> putint;
                            ' E.ATd:' -> putline; E.ATd.dopt -> putline;
                        if);
                        (if E.on > 0 then
                            '!!!!!! PathToDclX: E.on > 0 ' -> putline
                        if);
                        (* is encOG here correct or is it R in R.x? - P[] no?*)
                        (enclosingObjectGenerator,E.ATd[],E[],E.on,E.pn,none)
                          -> OGpath
                          -> P[];
                        (if trx then
                            '**   PathToDclX:A:\n'->puttext; P.print;
                        if);
                        (*P[] -> E.ATd.pathToDcl (* shall we do this ? without
                                                * find B fails
                                                * )
                          -> P[];*)
                        true -> P.isNest; (* ???? *)
                        (if trx then
                            '**   PathToDclX:B:\n'->puttext; P.print;
                        if);
                        (if trx then
                            '**   PathToDclX:kuk:on='->puttext; E.on -> putint;
                            newline;
                            E.dopt -> putline;
                            E.Atd.dopt -> putline;
                            '**   PathToDclX:additional path:'->putline;
                            P.print;
                        if);
                        (*S[] -> P.getSeqAnd?Qual -> (S[],qual[]);*)
                        (# Q: ^ObjectGenerator
                        do S[] -> P.getB -> Q[];
                           (if false and trx then
                               '****  PathToDclX:next:has:OUT:'->putline;
                               Q.dopt -> putline;
                               (if (Q.getReturnDecl) <> none then
                                   (Q.getReturnDecl).dopt ->putline
                           if)if)
                        #);                        
                        (if false and trx then
                            '**** final OGseq:n='->puttext; n -> putint;
                            newline;
                            S.print
                        if);
                    if);
                    (if n = i then 
                        true -> P.isNest;
                        '****  PathToDclX:FINAL:'->putline;
                        S.print;
                        leave L                         
                    if)
                 #)
            #);
          getQual::
            (# E: ^Exp; 
            do (if trx then 'Invocation:getQual:' -> puttext; doPT -> putline if);
               scanSons(# do current[] -> E[] #);
               ('Invocation:getQual:E:',E[]) -> display;
               (if E[] <> none then
                   E.getQual -> qual[]
               if);
            #);
          getActualReceiver::
            (#
            do (last).getActualReceiver -> rec[]
            #)
       #);

     ObjectInvocation::<
       (# semCheck::
            (# checkIfReceiverInImmutable:
                 (# org: ^Items;
                 do receiver.ATd.OG.IS.origin[] -> org[];
                    (if org.isImmutable and 
                        ((receiver.on > 0) or (receiver.father.noOfSons > 2)) then
                        (* receiver, X, declared as in: 
                         *  MyPtn: ...
                         *    [immutable]
                         *    X: var integer
                         *    foo:
                         *       X:= 117 -- illegal, X.on > 0
                         *    X: = 118 -- legal X.on = 0
                         *   R: obj MyPtn
                         *   R.X := 119 -- illegal receiver.father.noOfSons > 2
                         *              -- ftaher is invocation with more than 2 sons
                         *              -- this is a fragile test, should be improved
                         *)
                        (if false then
                            '**** dst is in immutable OG ,rec: ' -> puttext;
                            rec.dopt -> putline;
                            (rec.enclosingObjectGenerator).dopt -> putline;
                        if);
                        this(ObjectInvocation)[] -> Warning
                        (#
                        do 'The data-item "' -> msg; rec.dopt -> msg;
                           '" is in an immutable object and cannot be assigned' -> msg
                        #)
                    if)
                 #);               
               receiver: ^Exp; ptn: ^Pattern; org: ^Items; 
               srcQual, dstQual,qual: ^ObjectGenerator; 
               U: ^text;N: ^Node; OGS: ^OGsequence; P: ^OGpath; 
               MI: ^ModuleItem; singleUnitArgQual: ^ObjectGenerator
            do (* rec = none if first OI in Invocation *) 
               (if  traceUnit or trx then
                   '**** ObjectInvocation:semCheck: "' -> puttext;
                   doPT -> puttext; '" rec: "' -> puttext;
                   rec[] -> putDoPT; '"\n' -> puttext;
                   (if false then
                       '**   encOG:\n' -> puttext; 
                       encOG[] -> putDoPT; newline
                   if)
               if);
               (if ATd.primNo // rAssign_prim // vAssign_prim then
                   (* rec = receiver is defined *)
                   (if trx then 
                       '**** assign: ' -> puttext; rec.dopt -> putline;
                       '**   OI: ' -> putline; dopt -> putline;
                       (*'**   encOG: ' -> putline;
                        encOG.doPT -> putline*)
                       (*rec.origin.dopt -> putline*)
                   if);
                   rec[] -> receiver[];                   
                   checkIfReceiverInImmutable;
                   
                   (if receiver.ATd.primNo = this_prim then
                       '**   this:true'->putline
                   if);
                   args.scanArgs
                   (# i: @integer;
                      srcQual,dstQual,srcQual1,dstQual1: ^ObjectGenerator
                   do (if (i + 1 -> i) > 1 then
                          args[] -> semanticError
                          (#
                          do 'List too long to be assigned to: "' -> puttext;
                             receiver.doPT -> puttext; '"' -> put; newline
                          #)
                      if);
                      (* check that current can be assigned to receiver  *)
                      (none,specialEnclosingObjectGenerator)
                        -> current.semCheck 
                        -> srcQual[];
                      (*current.getQual -> srcQual[];*)
                      receiver.getQual -> dstQual[];
                      (if trx  then
                          '**   src: ' -> puttext; current.dopt -> putline;
                          '**   srcQual: ' -> putline; srcQual.dopt -> puthead;
                          '**   dst: ' -> puttext; receiver.dopt -> putline;
                          '**   dstQual: ' -> putline; dstQual.dopt -> puthead
                      if);                      
                      receiver.getActualReceiver -> receiver[];
                      (current[],srcQual[],dstQual[],true) -> receiver.ATd.checkQual; 
                      
                      (if trx then
                          '**** after receiver.ATd.checkQual: ' -> puttext;
                          receiver.dopt -> putline;
                      if);
                      specialEnclosingObjectGenerator -> encOG[] -> eOG[];
                      true -> done
                   #)
                else 
                   (if ATd.primno
                    // inner_prim // restart_prim // leave_prim // indexedPut_prim then
                       true -> noArgsCheck
                    // ifThen_prim then (* OBS! Qwhy domnt we check here ? *)
                    // this_prim then
                       args.scanArgs
                       (#
                       do current.getQual -> srcQual[] -> encOG[] -> eOG[];
                          true -> done
                       #)
                    else
                       (if (1 -> ptnId.T.inxGet) = '#' then
                           (* clean-up *)(*'#PTN: '->puttext; ptnId.T[] -> putline*)
                        else
                           (if not noArgsCheck then
                               (if false then
                                   (args[],specialEnclosingObjectGenerator,this(ObjectInvocation)[]) 
                                     -> ATd.checkActualArgs
                                else
                                   (args[],encOG[],this(ObjectInvocation)[]) 
                                     -> ATd.checkActualArgs
                                     -> singleUnitArgQual[];
                                   (if singleUnitArgQual[] <> none then
                                       '**** OI: '->puttext; dopt -> puthead;
                                       '**   hasSingleUnitArg:Qual: ' -> puttext; 
                                       singleUnitArgQual.doPT -> putline
                               if)if);
                               true -> done
                       if)if);
                       (if (origin[] <> none) then
                           (if trx and useMKOG then 
                               '**   ObjectInvocation:compute:eOG:for: '
                                 -> puttext;
                               dopt -> putline;
                               '**   label: ' -> puttext; label -> puttext;
                               ' from:encOG: ' -> puttext;
                               encOG.dopt -> puthead
                           if);
                           (if useMkOG then
                               (*encOG[] -> getV_?qual -> qual[] -> encOG[] -> eOG[];*)
                            else
                               (if useGetVqualX then
                                   (if trx and ((savedOGS[]->OGS[]) <> none) then
                                       '**** OI:getVqualX:computeQual:OF:'->putline;
                                       dopt -> puthead;
                                       '**   ATd:' -> puttext; Atd.dopt->puthead;
                                       '**   isVirtual: '->puttext;
                                       ATd.isVirtual-> putboolean; newline;
                                       '**** OI:getVqualX:theQual:'->putline;
                                       (if theQual[] <> none then
                                           theQual.dopt -> puthead;
                                        else
                                           'none' -> putline
                                       if);
                                       '**** OI:getVQualX:savedOGS:'->putline;
                                       savedOGS.print
                                   if);
                                   (if true then
                                       (*(if ATd.isModuleItem then
                                        (ATd[] -> MI[]).MD.OG[] -> qual[];
                                        if);*)
                                       (if theQual[] <> none then
                                           (* is theQual always correct for 
                                            * declarations?
                                            *)
                                           theQual[] -> qual[]
                                        else
                                           '\n!!!!! no saved qual:'->puttext;
                                           dopt -> puthead
                                       if);
                                       (if (singleUnitArgQual[] <> none) and 
                                           (qual[] <> singleUnitArgQual[]) then
                                           '****OI:changedQualToSingleUnitArgQual:'
                                             ->putline;
                                           singleUnitArgQual.doPT -> putline;
                                           singleUnitArgQual[] -> qual[]
                                       if)
                                    else
                                       (encOG[],false,OGS[]) 
                                         -> getVqualX 
                                         -> (OGS[],qual[]);
                                   if)
                                else
                                   (encOG[],none,none) 
                                     -> getVqual -> (P[],OGS[],qual[]);
                               if);
                               qual[] -> encOG[] -> eOG[];
                           if);
                           (if trx then
                               '**   ObjInv:semCheck:qualOf: ' -> puttext;
                               dopt -> puthead;
                               '**   qual:\n'-> puttext; qual[] -> putDoPt;
                               '**   hasSingleUnitArg:qual:\n ' -> puttext; 
                               (if singleUnitArgQual[] <> none then
                                   singleUnitArgQual.doPT -> putline
                               if)
               if)if)if)if);
            #);
          viaIncludeX:
            (* X via %include C via %include B via %include A
             * means: A.B.C.X, path = [A,nest(B),nest(C),nest(X)]
             *)
            (# OI,OIx: ^ObjectInvocation; on,pn,onx: @integer; OGS,OGSx: ^OGsequence;
               MI: ^ModuleItem; encOG,OGx: ^ObjectGenerator
            enter(encOG[],OI[],on,pn,OGS[])
            do (if trx then
                   '**** OI:viaIncludeX:on=' -> puttext; on->putint; ' ' ->put;
                   (if ptnID.viaIncl[] <> none then
                       ptnID.viaIncl.dopt -> puttext; ' ' -> put;
                       ptnID.viaIncl.father.dopt -> putline
                    else 
                       'top'->putline
                   if);
                   '**   OI: '->puttext; OI.dopt -> puthead;
                   '**   encOG: '->putline;
                   encOG.doPT -> puthead;
                   (if OGS[] <> none then OGS.print if)
               if);
               (if ptnId.viaIncl[] = none then
                   (* In X via %include C; via %include B; via %include A
                    * we have reached A,
                    * Fall back to B and C
                    *)
                   (if trx then
                       '**** viaIncludeX:top:on='->puttext; on -> putint;
                       newline;
                       (if OGS[] <> none then OGS.print if)
                   if);
                   (*(origin.father[],ATd[],this(OBjectInvocation)[],on,pn,P[])
                    -> OGpath (*-> ATd.pathToDcl* ) -> P[];*)                   
                   (*P.print;*)
                   (if OGS[] = none then
                       encOG[] -> OGsequence -> OGSx[];
                       OGS[] -> OGSx.pred[];
                       OGSx[] -> OGS[];
                   if);
                   (for on repeat OGS.ENC -> OGS[] for);
                   (for pn repeat OGS.PRE -> OGS[] for);
                   (if trx then
                       '**** viaIncludeX:GOT:'->putline;
                       OGS.print
                   if);
                   OGS.DOG[] -> encOG[] (* ???*)
                else
                   (if trx then
                       '**** viaIncludeX:A: ' -> puttext; 
                       ptnId.viaIncl.father.dopt -> putline
                   if);
                   ptnId.viaIncl.scanSons
                   (# i: @integer
                   do (if (i + 1 -> i) > 1 then
                          (if toFix then
                              '!!!! ObjectInvocation:viaIncludeX: ' -> puttext;
                              'remote not handled! ' -> putline;
                              ptnID.viaIncl.dopt -> putline
                      if)if);
                      current[] -> OIx[];
                   #);
                   OIx.ptnId.on + 1 -> onx;
                   (if trx then
                       '**** viaIncludeX:B: '->puttext; OIx.dopt->puttext;
                       ' current.ptnId.on=' ->puttext; onx -> putint; 
                       newline;
                   if);
                   (* In X via %include C via %include B via %include A
                    * go via %include B and/or %include A
                    *)
                   (encOG[],OI[],on + onx,pn,OGS[]) 
                     -> OIx.viaIncludeX 
                     -> (encOG[],OGS[]);
                   (if trx then
                       '*** add OIx:'->puttext; OIx.dopt -> putline;
                   if);
                   (*P[] -> OIx.ATd.pathToDcl -> P[];*)
                   (if OIx.ATd.isModuleItem then
                       (OIx.ATd[] -> MI[]).MD.OG[] -> OGx[];
                    else
                       OIx.ATd.OG[] -> OGx[]
                   if);
                   (*(OGx[],ATd[],this(ObjectInvocation)[],0,0,P[])
                     -> OGpath (*-> ATd.pathToDcl* ) -> P[];
                   true -> P.isNest;*)
                   (*P.print*)
                   ATd.origin.father[] -> OGsequence -> OGSx[];
                   OGS[] -> OGSx.pred[];
                   true -> OGSx.isNest;
                   OGSx[] -> OGS[];
                   (for pn repeat OGS.PRE -> OGS[] for);
               if)
            exit(encOG[],OGS[])
            #);
          gettingReturnQual: @boolean;
          getVqualX::
            (# mark:
                 (# n: @integer
                 enter n
                 do (if trx then
                        '**** OI:getVqualX:'->puttext; dopt->puttext;
                        ' cont:after:'->puttext; 
                        inner;
                        n -> putint; newline
                    if)
                 #);
               markENC: mark(#do 'ENC:on='->puttext #);
               markPRE: mark(#do 'PRE:pn='->puttext #);
               OGSx,OGSy: ^OGsequence; OGx: ^ObjectGenerator; DI: ^Decl;
               U: ^Text
            do (*'current' -> (ptnID.dopt).equalNCS -> trx;*)
               (if trx then
                   '\n**** ObjectInvocation:getVqualX: '->puttext; dopt -> puttext;
                   ' on=' -> puttext; on -> putint; 
                   ' pn='->puttext; pn -> putint; 
                   ' isNest='->puttext; isNest -> putboolean;  
                   ' getRtnnQual='->puttext; gettingReturnQual -> putboolean;
                   newline;
                   (if OGS[] <> none then 
                       '**   continue:OGS:'->putline;OGS.print 
                   if)
               if);
               (if ptnID.viaIncl[] <> none then
                   (* Given X, via &include C, path(X) to C is (on,pn), *)
                   (if trx then
                       '**** OI:getVqualX:before:viaIncludeX:encOG:'->putline;
                       encOG.dopt;
                       (if OGS[] <> none then OGS.print if)
                   if);
                   (encOG[],this(ObjectInvocation)[],on,pn,OGS[]) 
                     -> viaIncludeX 
                     -> (encOG[],OGS[]);
                   (encOG[],true,OGS[]) -> ATd.getVqualX -> (OGSx[],qual[]);
               else
                   (if (OGS[] -> OGSx[]) = none then
                       encOG[] -> OGx[];
                       (for on repeat 
                            OGx.origin.father[] -> OGx[]
                       for);
                       OGx[] -> OGsequence -> OGSx[];
                       (for pn repeat OGSx.PRE -> OGSx[] for);
                       (if trx then
                           '\n**** OI:getVqualX:initial:' -> puttext; dopt->puthead;
                           OGSx.print;
                       if);
                       (encOG[],false,OGSx[]) -> ATd.getVqualX -> (OGSx[],qual[]);
                       (if trx then
                           '\n**** getVqualX:initial:afterATd:' -> puttext; 
                           dopt->puthead;
                           OGSx.print
                       if)
                    else
                       (if isNest then
                           encOG[] -> OGsequence -> OGSy[];
                           true -> OGSy.isNest;
                           OGSx[] -> OGSy.pred[];
                           OGSy[] -> OGSx[];
                           (if trx then
                               '\n**** getVqualX:added:isNest:' -> putline; 
                               encOG.dopt->puthead;
                               OGSx.print;
                       if)if);
                       (* isNest ==> on = 0, 
                        * otherwise on >= 0, we may come from DataOtem:getVqualX 
                        *)
                       (for i: on repeat OGSx.ENC -> OGSx[]; i -> markENC for);
                       (for i: pn repeat OGSx.PRE -> OGSx[]; i -> markPRE for);
                       (if trx then
                           '\n**** getVqualX:B2:' -> putline;
                           OGSx.print;
                           '---'->putline; ATd.dopt ->puthead
                       if);
                       (encOG[],false,OGSx[]) -> ATd.getVqualX -> (OGSx[],qual[]);
                       (if trx then
                           '\n**** getVqualX:cont:afterATd:qual:' -> putline;
                           qual.dopt->puthead;
                           OGSx.print;
                       if)
               if)if);              
               (# IT: ^node
               do father.father.father[] -> IT[];
                  (if (savedOGS[] <> none) and not IT.isDecl then
                      (if false then
                          '**** OI:getVqualX:savecOGS:isSaved:\n'->puttext;
                          dopt->puthead;
                          IT.label -> putline;
                          IT.dopt -> puthead;
                      if)
                  else
                      (if true or not it.isDecl then
                          OGSx[] -> OGS[] -> savedOGS[]; 
                          this(ObjectInvocation)[] -> savedOI[];
                          (if false then
                              '**** save:\n'->puttext; dopt -> puthead;
               if)if)if)#);
               (if (qual.getReturnDecl -> DI[]) <> none then
                   (if gettingReturnQual then
                       (if trx then
                           '***** gettingReturnQual: ' -> puttext; dopt -> puthead;
                       if);
                       (* Find out if the correct qual/OGS is returned *)
                       leave getVqualX
                   if);
                   true -> gettingReturnQual;
                   (if trx then
                       '**** OI:return: ' -> puttext; DI.dopt -> puthead
                   if);
                   qual[] -> OGsequence -> OGSy[];
                   OGSx[] -> OGSy.pred[]; true -> OGSy.isNest;
                   (if trx then OGSy.print; if);
                   (encOG[],false,OGSy[]) -> DI.getVqualX -> (OGSx[],qual[]);
                   (if trx then
                       '**** OI:return: ' -> puttext; DI.dopt -> putline;
                       '**   qual:'->putline; qual.dopt -> putline;
                       OGSx.print
                   if);
                   false -> gettingReturnQual;
               if); 
               qual[] -> theQual[];
               (if (theQual.getExpUnit (*UnitX*) -> U[]) <> none then
                   U[] -> ExpUnit[];
                   (if false then
                       '**** OI:getQualX: "' -> puttext; dopt -> puttext;
                       '" unit: "' -> puttext; U[] -> puttext; '"\n'->puttext
                   if)
               if);
               OGSx[] -> OGS[]
            #);
          getVqual::
            (# Px: ^OGpath; DI: ^DataItem; hasRtn: @Boolean; OGSx: ^OGsequence
            do (*('Sxx' -> ptnID.T.equal) or trx -> trx;
               ('Rxx' -> ptnID.T.equal) or trx -> trx;*)
               (if trx->trxA then
                   '\n**** ObjectInvocation:getVqual: ' -> puttext; 
                   dopt -> puthead;
               if);
               (if (thequal[] <> none) then
                   (if trx then
                       '**** ObjectInvocation:getVqual:use:theQual:'->putline;
                       theQual.dopt -> puthead
                   if);
                   theQual[] -> qual[];
                   leave getVqual
               if);
               (if (OGS[] <> none) then 
                   encOG[] -> OGsequence -> OGSx[];
                   OGS[] -> OGSx.pred[];
                   OGSx[] -> OGS[];
                   true -> OGS.isNest;
                   (if trx then
                       '**   OGS:isNest:'->putline; OGS.print
                   if);
               if);  
              (if true or (ptnId.viaIncl[] = none) then
                   (encOG[],ATd[],this(ObjectInvocation)[],on,pn,none) 
                     -> OGpath 
                     (*-> ATd.p2d *)
                     -> Px[];
                else
                   (this(ObjectInvocation)[],on,P[])
                     -> viaInclude
                     -> Px[];
               if);
               (if trx then
                   '**   OI:getVqual:got:'->putline; Px.print;
                   '**   OI:getVqual:qual:isVirtual:'->puttext;
                   PX.dcl.isVirtual -> putboolean; newline;
                   Px.dcl.OG.dopt -> puthead
               if);
               L:
                 (#
                 do (if Px.dcl.isVirtual then 
                        (if Px.dcl.isPattern then
                            Px.dcl[] -> Px.vDcl[];
                         else
                            Px.dcl.OG[] -> qual[];
                            leave L
                        if);
                        (if Px.dcl.primNo // vassign_prim then
                            Px.dcl.OG[] -> qual[];
                            leave L
                        if);
                        (if (OGS[] = none) then
                            (if trx then
                                '**** first:'->puttext; dopt -> putline;
                            if);
                            Px.computeOGSeq -> OGS[];
                            OGS[] -> Px.getB -> qual[]
                         else
                            (if trx then 
                                '**** next:'->puttext; dopt -> putline;
                                Px.print;
                                OGS.print
                            if);
                            (if true then
                                (*OGS[] -> Px.getSeq?AndQual -> (OGS[],qual[]);*)
                             else
                                Px.findQual -> qual[];
                            if)
                        if);
                        (if trx then
                            '**** OI:getVqual:binding:'->putline;
                            qual.dopt -> puthead
                        if)
                     else
                        Px.dcl.OG[] -> qual[];
                        (if true then
                            (*encOG[] -> OGsequence -> OGS[]*)
                            (if Px.dcl.isPattern then
                                Px.dcl[] -> Px.vDcl[];
                             else
                                Px.dcl.OG[] -> qual[];
                                leave L
                            if);
                            (if Px.dcl.primNo // vassign_prim then
                                Px.dcl.OG[] -> qual[];
                                leave L
                            if);
                            Px.computeOGseq -> OGS[];
                            OGS[] -> Px.getB -> qual[]
                        if)
                    if);
                    (if not hasRtn and ((qual.getReturnDecl->DI[]) <> none) then
                        (if true then
                            (* hasRtn handles the cases:
                             * A: { out ref B }; B: { X: ...; out ref A}
                             * A.X
                             * Dont recursively follow out arg
                             * where qual of A is B
                             * and A: { out ref A } where qual of A is A
                             *)
                            (if trx then
                                '**** return: ' -> puttext; DI.dopt -> putline;
                                (*Px.print*)
                            if);
                           (* Px[] -> DI.p2d -> Px[];    *)
                            true -> Px.isNest;
                            true -> hasRtn;
                            restart L
                         else                       
                            DI.getQual -> qual[];
                        if)
                 if)#);
               qual[] -> theQual[];
               (if trx then
                   '**** OI:getVqual:save:theQual:' -> puttext; dopt->puthead;
                   theQual.doPT -> puthead
               if)
            #);
          viaInclude:
            (* X via %include C via %include B via %include A
             * means: A.B.C.X, path = [A,nest(B),nest(C),nest(X)]
             *)
            (# OI,OIx: ^ObjectInvocation; on,onx: @integer; P: ^OGpath;
               MI: ^ModuleItem; OGx: ^ObjectGenerator
            enter(OI[],on,P[])
            do 
               (if ptnId.viaIncl[] = none then
                   (if trx then
                       '**** viaInclude:top:on='->puttext; on -> putint;
                       newline
                   if);
                   (origin.father[],ATd[],this(OBjectInvocation)[],on,pn,P[])
                     -> OGpath (*-> ATd.pathToDcl*) -> P[];
                   (*P.print;*)
                else
                   ptnId.viaIncl.scanSons
                   (# i: @integer
                   do (if (i + 1 -> i) > 1 then
                          (if toFix then
                              '!!!! ObjectInvocation:viaInclude: ' -> puttext;
                              'remote not handled! ' -> putline;
                              ptnID.viaIncl.dopt -> putline
                      if)if);
                      current[] -> OIx[];
                   #);
                   OIx.ptnId.on + 1 -> onx;
                   (if trx then
                       '**** viaInclude: '->puttext; OIx.dopt->puttext;
                       ' current.ptnId.on=' ->puttext; onx -> putint; 
                       newline;
                   if);
                   (OI[],on + onx,P[]) -> OIx.viaInclude -> P[];
                   (if trx then
                       '*** add OIx:'->puttext; OIx.dopt -> putline;
                   if);
                   (*P[] -> OIx.ATd.pathToDcl -> P[];*)
                   (if OIx.ATd.isModuleItem then
                       (OIx.ATd[] -> MI[]).MD.OG[] -> OGx[];
                    else
                       OIx.ATd.OG[] -> OGx[]
                   if);
                   (OGx[],ATd[],this(ObjectInvocation)[],0,0,P[])
                     -> OGpath (*-> ATd.pathToDcl*) -> P[];
                   true -> P.isNest;
                   (*P.print*)
               if)
            exit P[]
            #);
          getQual::
            (#
            do (if (trx) or traceGetQual then
                   '**** ObjectInvocation:getQual: ' -> puttext;
                   dopt->puthead
               if);
               (*(if (ATd[] <> none) then ATd.primNo -> putint if);
               ' ' -> put; doPT -> putline;*)
               (if (ATd[] <> none) and (ATd.primNo = this_Prim) then
                   (* move to Apl:getQual*)
                   args.scanArgs
                   (# IV: ^ObjectSpecification
                   do current[] -> IV[]; IV.getQual -> qual[];
                      (* IV.doPT -> putline; qual.doPT -> putline*)
                   #);
                   ('Keyword:getQual:this_prim', qual[])->display;
               if);
               (if ATd[] <> none then
                   (if ATd.isVirtual then
                       ATd.getQual -> qual[]
                    else
                       ATd.getQual -> qual[]
                   if)
                else
                   '*** ATd is none ' -> putline
               if);
               (if trx or traceGetQual then
                   (if qual[] <> none then
                       '**   OI:getQual:QUAL:IS: ' -> putline;
                       qual.doPT -> puthead
                    else
                       '*** qual is none' -> putline
                   if)
                   
               if)
            #);      
          getActualReceiver::
            (#
            do (if ATD.primNo = this_prim then
                   args.scanSons
                   (# i: @integer; OG: ^ObjectCall
                   do (if (i + 1 -> i) = 2 then
                          (*'** primArg:'->puttext; current.doPT -> putline;*)
                          ((current[] -> OG[]).super).last -> rec[]
                      if)
                   #)
               if)
            #)
       #);
     BracketedExp::<
       (# getVqual::
            (#
            do '!!!! BE:getVqual:'->puttext; dopt -> putline
            #);
          getQual::
            (# 
            do IV.getQual -> qual[] 
            #);
          getActualReceiver::
            (#
            do IV.getActualReceiver -> rec[];
            #);
       #);
     Const::<
       (# semcheck::
            (#
            do (if trx then
                   '**** IntegerObj:semcheck:' -> puttext; dopt -> putline
               if);
               (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**** Const:semcheck: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> expUnit[] -> unitTable.findUOGall -> encOG[] -> eOG[];
                   (if eOG[] = none then
                       '!!!! Const:findUOG is none: '->puttext;
                       dopt -> putline;
                   if)
                else
                   integerDecl.OG[] -> encOG[] -> eOG[];
               if)
            #);
          getVqualX::
            (#
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**** Const:getVqualX: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> expUnit[] -> unitTable.findUOGall -> qual[];
                   (if qual[] = none then
                       '!!!! Const:findUOG is none: '->puttext;
                       dopt -> putline;
                   if)
                else
                   integerDecl.OG[] -> qual[]
               if)
            #);
          getQual:: 
            (#
            do (if trx then
                   '**** Const:getQual: ' -> puttext; dopt -> putline
               if);
               integerDecl.getQual -> qual[]
            #);
       #);
     FloatConst::<
       (# semCheck:: 
            (# 
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**** FloatConst:semcheck: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> unitTable.findUOGall -> encOG[] -> eOG[];
                   (if eOG[] = none then
                       '!!!!floatConst:findUOG is none: '->puttext;
                       dopt -> putline;
                   if)
                else
                   floatDecl.OG[] -> encOG[] -> eOG[] 
               if)
            #);
          getVqualX::
            (#
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**   flotConst:getqual: ' -> puttext; dopt -> putline;
                   if);
                   unit.T[] -> expUnit[] -> unitTable.findUOG -> qual[]
                else
                   floatDecl.OG[] -> qual[] 
               if)
            #);
          getQual:: 
            (# 
            do (if (unit[] <> none) and (unit.T[] <> none) then
                   (if false then
                       '**   flotConst:getqual: ' -> puttext; dopt -> putline;
                   if);
                   unit.T[] -> unitTable.findUOG -> qual[]
                else
                   floatDecl.getQual -> qual[] 
               if)
            #);
       #);
     CharObj::<
       (# semcheck::
            (#
            do (if false then
                   '**** CharObj:semcheck:' -> puttext; dopt -> putline
               if);
               charDecl.OG[] -> encOG[] -> eOG[]
            #);
          getVqualX:: (#do charDecl.OG[] -> qual[] #);           
          getQual:: (#do charDecl.getQual -> qual[] #); 
       #);
     StringObj::< 
       (# semcheck::
            (#
            do (if false then
                   '**** StringObj:semcheck:' -> puttext; dopt -> putline
               if);
               stringDecl.OG[] -> encOG[] -> eOG[]
            #);
          getVqualX:: (#do stringDecl.OG[] -> qual[] #);           
          getQual:: (#do stringDecl.getQual -> qual[] #); 
       #);
     decodeUnits:
       (# UT: ^UnitTree; BV: ^Basevector
       do (if false then
              '**** decodeUnits:'->putline;
          if);
          unitTable.scan
          (#
          do (if false then current.print; if);
             (for i: current.UStop repeat 
                  (if false then
                      '**   parse: ' -> puttext;
                      current.US[i][] -> putline;
                  if);
                  current.US[i][] -> parseUnit -> UT[];
                  UT[] -> mkBasevector  -> BV[];
                  (if false then
                      '**   parsed: ' -> puttext; true -> UT.print -> putline;
                      BV.print
                  if)
             for)
          #);
       #)
  do '**** SEMCHECK ****' -> putline;
     decodeUnits;
     (*main.defUnit;*)
     main (*rootModule*).semCheck;
     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline
      else
         inner
     if)
  #)
