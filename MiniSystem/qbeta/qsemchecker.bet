ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
---lib:attributes---
checkRecursive: (# exit true #);
semchecker: checker
  (# ModuleItem::<
       (# getQual:: 
            (# do (*'ModuleItem:getQual: ' -> puttext; dopt -> putline;*)
               md.DI.getQual -> qual[]
            #);
       #);
     DataItem::<
       (# getQual:: (# do OG.getQual -> qual[] #);
          semCheck::
            (* Check that in S : ? T, V: = T, T is a pattern
             * it seems to work for singular patterns, but check if this is so!
             *)
            (#
            do (if OG.isPtnOrSingular then
                   not isConst -> noArgsCheck
                else
                   OG.doPT -> putline;
                   OG.super.ATd.doPT -> putline;
                   this(DataItem)[] -> SemanticError
                   (#
                   do 'The qualification "' -> msg;
                      OG.doPT -> msg;
                      '" must be a pattern '-> msg;
                   #)
               if)
            #);
          checkQual::                               
            (* Note: left / right is from Beta: Left -> Right
             * we should swith for qbeta: Right := Left
             * This applies to rQual, lQual, and messages
             * Perhaps use dest/source or ...
             *)
            (# error:
                 (#
                 do (if reportSemErr then
                        lOG[] -> semanticError
                        (#
                        do '"'->put; lOG.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                 #)if)#);
               lQual,rQual: ^ObjectGenerator
            do (if traceCheckQual then
                   '\n>>> DataItem:checkQual:' -> puttext; 
                   (if isConst then ':C:' -> puttext if);
                   (if isAssign then ' := ' -> puttext if);
                   ('Left',lOG[]) -> display;
                   ('Right',this(DataItem)[]) -> display; 
               if);
               (if lOG[] <> none then 
                   lOG.getQual -> lQual[] (* none if string " ..." *)
                else
                   '>>> lOG none' -> putline
               if);
               getQual -> rQual[];
               ('lQual',lQual[]) -> displayB; (* there is also a Display *)
               ('rQual',rQual[]) -> displayB;
               (if isConst and isAssign then 
                   error
                else
                   (if OG.isSimpleValue then
                       (* OG[] -> rQual[];*)
                       (if lQual[] <> none then
                           (if lQual.primNo
                            // integer_prim then
                               (if rQual.primNo 
                                // integer_prim // char_prim // boolean_prim then
                                else
                                   error
                               if)
                            // char_prim then
                               (if rQual.primNo // integer_prim // char_prim then
                                else
                                   error
                               if)
                            // boolean_prim then
                               (if rQual.primNo // boolean_prim // integer_prim then 
                                else
                                   error 
                               if)
                            else
                               error
                           if)
                        else
                           error
                       if)       
                    else
                       (* getQual -> rQual[];*)
                       (if true
                        // lQual[] -> rQual.inSuper then (* OK *)
                        // (lQual[] <> none) and (rQual[] -> lQual.inSuper) then
                           lOG[] -> QuaCheck
                           (# 
                           do 'It must be checked at run-time that "'
                                -> puttext;
                              lOG.doPT -> puttext;
                              '"\n     is a subpattern of "' -> puttext;
                              doPT -> puttext; '"' -> put; newline
                           #)
                        // (lQual[] <> none) and (lQual.primNo = none_prim) then
                        else
                           (if reportSemErr then
                               lOG[] -> semanticError
                               (#
                               do 'The reference expression:\t"' -> puttext;
                                  lOG.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #);
               if)if)if)if)
            #);
       #);
     isPatternDen:< BooleanValue
       (# E: ^Exp
       enter E[]  
       do E.ATd.doPT -> putline;
          (if E.ATd[] <> none then E.ATd.isPatternDecl -> value if)
       #); 
     pattern::<
       (# checkActualArgs::
            (# A: [6] ^Decl; inx,top: @ integer;
            do (if traceCheckQual then
                   '\nCheck: ' -> puttext; actualArgs.doPT -> putline;
                   '  against: ' -> puttext; sig.doPT -> putline;
               if);  
               sig.scanParameters
               (# 
               do (if (top + 1 -> top) > A.range then A.range -> A.extend if);
                  currentArg[] -> A[top][] 
               #);
               (* should be recursive - and visit all super patterns *)
               (if OD.super[] <> none then
                   (if ((OD.super.last).args[] <> none) and
                       ((OD.super.last).args.length = 0)
                       and (OD.super.ATd[] <> none) then
                       OD.super.ATd.sig.scanParameters
                       (#
                       do (if (top + 1 -> top) > A.range then A.range -> A.extend if);
                          currentArg[] -> a[top][];
               #)if)if);
               L:
                 actualArgs.scanArgs
                 (# 
                 do inx + 1 -> inx; 
                    (if inx > top then
                        actualArgs[] -> SemanticError
                        (# 
                        do 'More actual parameters:\n\t"' -> msg;
                           actualArgs.doPT -> msg; 
                           '"\n    than formal parameters:\n\t"' -> msg;
                           sig.doPT -> msg; '"' -> msg
                        #)
                     else
                        (current[],false) -> A[inx].checkQual;
                    if);
                 #); 
               (if (inx < top)  then
                   actualArgs[] -> SemanticError
                   (# 
                   do '*** More formal than actual parameters' -> msg;
                      actualArgs.doPT -> msg;
                      '\n'-> msg;
                      sig.doPT -> msg;
                   #)
               if);
            #);
          getQual::
            (# 
            do (if traceCheck then
                   '*** Pattern:getQual: '->puttext; sig.doPT -> putline
               if);
               (if (*not isChecked and*) checkRecursive then 
                   (if traceCheck then
                       '\n>>> Pattern not checked: ' -> puttext; 
                       sig.doPT -> putline
                   if);
                   (none,origin[],origin[],true) -> check
               if);
               (if isRecursive then
                   (* For a pattern
                    *    foo(...) -> res: ? foo ...
                    * getQual is called on the foo return value
                    * giving a recursive call of getQual
                    *)
                   OD[] -> qual[];
                   (*false -> isRecursive;*)
                   leave getQual
               if);
               inner;
               (if traceCheckQual then
                   'Pattern getQual: "' -> putline; sig.doPT -> puttext; 
                   '"' ->put; newline;
               if);
               true -> isRecursive;
               (* this is probably just a hack 
                * - we need to handle virtuals as in the Beta compiler
                *)
               sig.getExplicitQual -> qual[];
               (if qual[] = none then
                   (if isVirtual then
                       OD.getQual -> qual[];
                       (* 'Virtual: ' -> puttext; qual.doPT -> putline*)
                    else
                       OD[] -> qual[];
               if)if);
               false -> isRecursive;
               (if traceCheckQual then
                   'Pattern: "\n' -> puttext; 
                   (if qual[] <> none then 
                       qual.doPT -> puttext
                    else 'none'->puttext
                   if);
                   '"' -> put; newline
               if)
            #);
          semCheck::
            (# lastSuper: ^Exp
            do (if (OD.super[] <> none)
                   and ((OD.super.last -> lastSuper[]).args[] <> none) and
                       (lastSuper.args.length = 0) then
                   true -> lastSuper.noArgsCheck
               if)
            #)
       #);
     Signature::<
       (# checkActualArgs:
            (# actualArgs: ^Arguments
            enter actualArgs[]
            do (if args[] <> none then
                   actualArgs[] -> args.checkActualArgs
                else
                   (if traceCheckQual then
                       'Signature:checkActualArgs: args is none: ' -> puttext;
                       this(Signature).doPT -> putline;
                       ' actuals: ' -> puttext;
                       actualArgs.doPT -> putline
                   if)
               if)
            #);
          getExplicitQual:
            (* Returns qual of possible explicit return value
             * GetQual below returns ths as default if no explict return is defined
             * Also try superchain 
             *)
            (# qual: ^ObjectGenerator;  ptn: ^Pattern
            do (if val[] <> none then 
                   val.getQual -> qual[] 
                else
                   father[] -> ptn[];
                   (if (ptn.OD.super.ATd[] -> ptn[]) <> none then
                       ptn.sig.getExplicitQual -> qual[]
                if)if)                           
            exit qual[]
            #);
          getQual:: 
            (# ptn: ^Pattern
            do (if traceCheckQual then
                   'Signature:getQual: "\n' -> puttext; dopt->puttext;
                   '"' -> put; newline
               if);
               getExplicitQual -> qual[];
               (if qual[] = none then
                   (* no return value - use %this P *)
                   (father[] -> ptn[]).OD[] -> qual[]
               if);
            #);
       #);
     Arguments::<
       (# checkActualArgs:
            (# args: ^Arguments; A: [6] ^Decl; inx,top: @ integer
            enter args[]
            do (if traceCheckQual then
                   '\nCheck: ' -> puttext; args.doPT -> putline;
                   '  against: ' -> puttext; this(Arguments).doPT -> putline;
               if);               
               scanArgs
               (# 
               do (if (top + 1 -> top) > A.range then A.range -> A.extend if);
                  current[] -> A[top][] 
               #);
               L:
                 args.scanArgs
                 (# 
                 do inx + 1 -> inx; 
                    (if inx > top then
                        (* try possible super *)
                        '\n*** More actual parameters:\n\t' ->puttext;
                        args.doPT -> puttext;
                        '\n    than formal parameters: \n\t' -> puttext;
                        this(Arguments).doPT -> putline;
                        leave L;
                     else
                        (current[],false) -> A[inx].checkQual;
                    if);
                 #);
               (if (inx < top)  then
                   (* problem for integer versus integer(18)
                    * and probably String ...
                    *)
                   '\n*** More formal than actual parameters' -> putline;
                   args.doPT -> putline;
                   this(Arguments).doPT -> putline;
               if);
            #);
       #);
     Value::<
       (# getQual:
            (# D: ^Decl; qual: ^ObjectGenerator 
            do scanSons(# do current[] -> D[] #);
               (* only works for one return value/decl *)
               D.getQual -> qual[];
               (if traceCheckQual then
                   'Value: ' -> puttext;
                   D.doPT -> putline;
                   (if qual[] <> none then 
                       qual.doPT -> putline;
                    else 'none '->putline
               if)if);
            exit qual[]
            #)
       #);
     Include::
       (# getQual::
            (# 
            do 'Include:getQual: '->puttext; dopt -> putline;
               (if son[] <> none then
                   scanSons
                   (# IV: ^Invocation
                   do (if isLAst then
                          'include:getqual:'-> puttext; doPT -> putline;
                          current[] -> IV[];
                          IV.getQual -> qual[]
               if)#)if)
            #);
       #);
     ObjectGenerator::<
       (# getQual:
            (# qual: ^ObjectGenerator 
            do (if traceCheck then
                   '*** ObjectGenerator:getQual: '->puttext; doPT -> putline
               if);
               (if true (*not isChecked*) then 
                   (if traceCheck then
                       'ObjectGenerator is not checked: ' -> putline;
                   if);
                   (* Should only be called for singular OGs'
                    * If part of pattern decl, argScope may be wrong
                    *)
                   (none,origin[],origin[],true) -> check
               if);
               (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   this(ObjectGenerator)[] -> qual[]
               if)
            exit qual[]
            #); 
          inSuper: BooleanValue
            (# lQ: ^ObjectGenerator
            enter lQ[]
            do ('inSuper:lQ',lQ[]) -> display;
               ('rQ',lQ[]) -> display;
               L:
                 (if lQ[] = this(ObjectGenerator)[] then
                     true -> value 
                  else
                     (if (lQ[] <> none) then
                         (if (lQ.primNo <> object_prim) then
                             lQ.super.getQual -> lQ[];
                             (if lQ[] =  none then
                                 objectDecl.getQual -> lQ[]
                             if);
                             restart L;
                 if)if)if)
            #);
          isPtnOrSingular: BooleanValue
            (#
            do (if super.ATd[] <> none then
                   super.ATd.isPatternDecl -> value
                else
                   (* no super - must be singular *)
                   not IS.isEmpty -> value
               if)
            #);
       #);
     Invocation::<
       (# checkInv:
            (# E: ^Exp; 
            do (* should check path *)
               scanSons(# do current[] -> E[] #);
            exit E[]
            #);
               
          getQual::
            (# (*qual: ^ObjectGenerator;*) E: ^Exp; 
            do (* 'Invocation:' -> puttext; doPT -> putline;*)
               scanSons(# do current[] -> E[] #);
               ('Invocation:getQual',E[]) -> display;
               E.getQual -> qual[]
            (*exit qual[]*)
            #);
       #);
     ObjectInvocation::<
       (# semCheck::
            (# receiver: ^Exp; ptn: ^Pattern
            do (*'>>> ObjectInvication:semCheck: rec: ' -> puttext;
               rec.doPT -> puttext;
               ' <- ' -> puttext; args.doPT -> puttext;*)
               (if (ATd[] <> none) and( ATd.primNo <> assign_prim) then
                   (*' Atd: ' -> puttext; ATd.doPT -> putline;*)
                   (if ATd.primno
                    // inner_prim //this_prim
                    // restart_prim // leave_prim 
                    // indexedPut_prim  then
                       true -> noArgsCheck
                    // ifThen_prim then
                    else
                       (if not noArgsCheck then
                           args[] -> ATd.checkActualArgs
                       if)
                   if)
                else
                   (if ':=' -> ptnId.T.equal then
                       (*' Q:= rec.ATd: ' -> puttext;*)
                       rec[] -> receiver[];
                       (*receiver.Atd.doPt -> putline;*)
                       args.scanArgs
                       (# i: @integer
                       do (if (i + 1 -> i) > 1 then
                              args[] -> semanticError
                              (#
                              do 'List too long to be assigned to: "' -> puttext;
                                 receiver.doPT -> puttext; '"' -> put; newline
                              #)
                          if);
                          (current[],true) -> receiver.ATd.checkQual 
                       #);
                   if)
               if)
            #);
          getQual::
            (#
            do (*'ObjectInvocation:getQual: ' -> puttext;
               dopt->putline;*)
               (*(if (ATd[] <> none) then ATd.primNo -> putint if);
               ' ' -> put; doPT -> putline;*)
               (if (ATd[] <> none) and (ATd.primNo = this_Prim) then
                   (* move to Apl:getQual*)
                   args.scanArgs
                   (# IV: ^ObjectGenerator
                   do current[] -> IV[]; IV.getQual -> qual[];
                      (* IV.doPT -> putline; qual.doPT -> putline*)
                   #);
                   ('Keyword:getQual:this_prim', qual[])->display;
               if);
               (if ATd[] <> none then
                   (if ATd.isVirtual then
                       ATd.getQual -> qual[]
               if)if);
               (if qual[] <> none then
                  (* qual.doPT -> putline*)
               if)
            #);          
       #);
     BracketedExp::<
       (# getQual::
            (# 
            do IV.getQual -> qual[] 
            #);
       #);
     StringObj::< (# getQual:: (#do stringDecl.getQual -> qual[] #) #);
     
  do '**** CHECKER   ****' -> putline;
     main (*rootModule*).semCheck;
     inner
  #)
