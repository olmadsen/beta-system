ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
---lib:attributes---
semchecker: checker
  (# StaticObject::<
       (# getQual:: (# do OG[] -> qual[] #);
          getQual2:: (# do OG.getQual -> qual[] #);
          checkQual2::
            (#
            do (if false and  traceCheckQual then
                   '\n>>> StaticObject: checkQual2:\nleft: ' -> puttext; 
                   lOG.doPT -> puttext;
                   '\nright: ' -> puttext; OG.doPT -> putline
               if);
            #);
          checkQual::
            (# lQual,rQual: ^ObjectGenerator; (* PatternId *)
               error:
                 (#
                 do (if reportSemErr then
                        lOG[] -> semanticError
                        (#
                        do '"'->put; lOG.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                 #)if)#)
            do (if traceCheckQual then
                   '\n>>> StaticObject: checkQual:\nleft: ' -> puttext; 
                   lOG.doPT -> puttext;
                   '\nright: ' -> puttext; OG.doPT -> putline
               if);
               (if lOG[] <> none then
                   lOG.getQual -> lQual[]
               if);
               ('lQual',lQual[]) -> display;
               OG[] -> rQual[];
               ('rQual',rQual[]) -> display;
               ('lQual',lQual[]) -> displayB;
               ('rQual',rQual[]) -> displayB;
               (if lQual[] <> none then
                   (if lQual.primNo
                    // integer_prim then
                       (if rQual.primNo // integer_prim // char_prim // boolean_prim then
                        else
                           error
                       if)
                    // char_prim then
                       (if rQual.primNo // integer_prim // char_prim then
                        else
                           error
                       if)
                    // boolean_prim then
                       (if rQual.primNo // boolean_prim // integer_prim then 
                        else
                           error 
                       if)
                    else
                       error
                   if)
                else
                   error
               if)               
            #);
       #);
     DynamicObject::<
       (# getQual:: 
            (# 
            do (PI.IV[],Items) -> ObjectGenerator -> qual[] 
               (* PI[] -> qual[] *)
            #);
          getQual2:: 
            (# 
            do (if traceCheckQual then
                   'DynamicObject:getQual2: '->puttext; doPT -> putline;
               if);
               PI.IV.getQual2 -> qual[];
               (if traceCheckQual then
                   'DynamicObject:getQual2 = '->puttext; qual.doPT -> putline;
               if);
            #);
          CheckQual2::
            (# lQual,rQual: ^ObjectGenerator
            do (if traceCheckQual then
                   '\n>>> DynamicObject:checkQual2:' -> putline;
                   ('Left',lOG[]) -> display;
                   ('Right',this(DynamicObject)[]) -> display
               if);
               (if lOG[] <> none then 
                   lOG.getQual2 -> lQual[] (* none if string " ..." *)
                else
                   '>>> lOG none' -> putline
               if);
               getQual2 -> rQual[];
               ('lQual',lQual[]) -> display;
               ('rQual',rQual[]) -> display;
               (if (lQual[] <> none) and (lQual.primNo = none_prim) then
                else
                   (* fork(C1), where C1: ^Core fork(S: ^Object)
                    * lQual = S, rQual = C1 *)
                   (*(if lQual[] <> none then 
                       'lqual: ' -> puttext; lQual.doPT -> putline else 'none'->putline 
                   if);
                   'rQual: '->puttext;
                   rQual.doPT -> putline;*)
                   (if lQual[] -> rQual.inSuper then
                    else
                       (if (lQual[] <> none) and (rQual[] -> lQual.inSuper) then
                           lOG[] -> QuaCheck
                           (# 
                           do 'It must be checked at run-time that "'
                                -> puttext;
                              lOG.doPT -> puttext;
                              '"\n     is a subpattern of "' -> puttext;
                              doPT -> puttext; '"' -> put; newline
                           #)
                        else
                           (if reportSemErr then
                               lOG[] -> semanticError
                               (#
                               do 'The reference expression:\t"' -> puttext;
                                  lOG.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #);
                               (*'\n**** reference assignment NOT OK'->putline*)
               if)if)if)if)
            #);
          
          Checkqual::
            (* thisDynamicObject)= R: ^PI
             * Test R := lOG
             *    lOG: none
             *         S where S: ^PIx
             *         P where P is pattern returning either P or S: ^Piy
             * where 
             *    qual(R) = rQual
             *    qual(E) = lQual
             * lQual = foo{ ... }
             * rQual = PI.IV = fisk{} - note that Itempart is empty, see getQual 
             * Test lQual <= rQual
             *  => E = none
             *  => foo <= fisk
             * lQ = Fn where foo = F1.F2.,,,.Fn, where Fn is a pattern
             * rQ = Gm where fisk = G1.G2.,,,.Gm, where Gm s a pattern
             * lQ.ATd = Decl(lQ) -> must be pattern decl
             * rQ.ATd = Decl(rQ) -> must be pattern decl
             * Test
             *    lQ.ATd <= rQ.ATd : lQ.ATd[] -> rQ.ATd.inSuper -> value
             *)
            (# Insuper: booleanValue
                 (# lQ,rQ: ^Exp
                 enter(lQ[],rQ[])
                 do ('lQ',lQ[]) -> display;
                    ('rQ',rQ[]) -> display;
                    (if (lQ[] <> none) and (rQ[] <> none) then
                        (if rQ.ATd[] <> none then
                            lQ.ATd[] -> rQ.ATd.inSuper -> value
                         else
                            (if reportNone then
                                'rQ.ATd is none ' -> putline
                    if)if)if)               
                 #);               
               lQual: ^ObjectGenerator;  (* PatternId *) 
               lQ,rQ: ^Exp
            do (if traceCheckQual then
                   '\n>>> DynamicObject:checkQual:' -> putline;
                   ('Left',lOG[]) -> display;
                   ('Right',this(DynamicObject)[]) -> display
               if);
               (if lOG[] <> none then 
                   lOG.getQual -> lQual[]
               if);
               ('lQual',lQual[]) -> display;
               (if lQual[] <> none then
                   (if lQual.primno = none_prim then
                       (* assignment OK *)
                    else
                       lQual.super.getExpQual -> lQ[];
                       PI.IV.getExpQual -> rQ[];
                       (*'lQ: ' -> puttext; lQ.doPP -> putline;
                       'lQ.ATd.primNo: ' -> puttext; *)
                       (if ((lQ[],rQ[]) -> inSuper) then
                           (*'\n**** reference assignment OK'->putline*)
                        else
                           (* check if rQ is sub of lQ => implies qua-check *)
                           (if traceCheckQual then
                               'Check if qua-check is needed: ' -> puttext;
                               ('rQ',rQ[]) -> display;
                               ('lQ',lQ[]) -> display
                           if);
                           (if (rQ[],lQ[]) -> inSuper then
                               lOG[] -> QuaCheck
                               (# 
                               do 'It must be checked at run-time that "'
                                    -> puttext;
                                  lOG.doPT -> puttext;
                                  '"\n     is a subpattern of "' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #)
                            else
                               (if reportSemErr then
                                   lOG[] -> semanticError
                                   (#
                                   do 'The reference expression:\t"' -> puttext;
                                      lOG.doPT -> puttext;
                                      '"\n     cannot be assigned to:\t"' -> puttext;
                                      doPT -> puttext; '"' -> put; newline
                                   #);
                                   (*'\n**** reference assignment NOT OK'->putline*)
                       if)if)if)
                   if)
                else
                   (if reportNone then
                       'lQual is none!!!' -> putline;
                   if)
               if)
            #);
       #);
     Signature::<
       (# checkActualArgs:
            (# actualArgs: ^Arguments
            enter actualArgs[]
            do (if args[] <> none then
                   actualArgs[] -> args.checkActualArgs
                else
                   (if traceCheckQual then
                       'Signature:checkActualArgs: args is none: ' -> puttext;
                       this(Signature).doPT -> putline;
                       ' actuals: ' -> puttext;
                       actualArgs.doPT -> putline
                   if)
               if)
            #);
          getQual::
            (# 
            do (if traceCheckQual then
                   'Signature:getQual: "\n' -> puttext; dopt->puttext;
                   '"' -> put; newline
               if);
               (if val[] <> none then val.getQual -> qual[] if)
            #);
          getQual2:: 
            (# 
            do (if traceCheckQual then
                   'Signature:getQual: "\n' -> puttext; dopt->puttext;
                   '"' -> put; newline
               if);
               (if val[] <> none then val.getQual2 -> qual[] if)
            #);
       #);
     Arguments::<
       (# checkActualArgs:
            (# args: ^Arguments; A: [6] ^Decl; inx,top: @ integer
            enter args[]
            do (if traceCheckQual then
                   '\nCheck: ' -> puttext; args.doPT -> putline;
                   '  against: ' -> puttext; this(Arguments).doPT -> putline;
               if);
               scanSons
               (# 
               do (if (top + 1 -> top) > A.range then A.range -> A.extend if);
                  current[] -> A[top][] 
               #);
               args.scanSons
               (# 
               do inx + 1 -> inx; 
                  current[] -> A[inx].checkQual2 
               #);
            #);
       #);
     Value::<
       (# getQual:
            (# D: ^Decl; qual: ^ObjectGenerator (* PatternId *)
            do scanSons(# do current[] -> D[] #);
               (* only works for one return value/decl *)
               D.getQual -> qual[];
               (if traceCheckQual then
                   'Value: ' -> puttext;
                   D.doPT -> putline;
                   (if qual[] <> none then 
                       qual.doPT -> putline;
                    else 'none '->putline
               if)if);
            exit qual[]
            #);
          getQual2:
            (# D: ^Decl; qual: ^ObjectGenerator 
            do scanSons(# do current[] -> D[] #);
               (* only works for one return value/decl *)
               D.getQual2 -> qual[];
               (if traceCheckQual then
                   'Value: ' -> puttext;
                   D.doPT -> putline;
                   (if qual[] <> none then 
                       qual.doPT -> putline;
                    else 'none '->putline
               if)if);
            exit qual[]
            #)
       #);
     ObjectGenerator::<
       (# getQual2:
            (# qual: ^ObjectGenerator 
            do (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual2 -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   this(ObjectGenerator)[] -> qual[]
               if)
            exit qual[]
            #); 
          getQual:
            (* this(OG) = (OG (invocation (E1 E2 E3)) (Items ...)) 
             * Cases:
             *    1. StaticObject:  E1.E2.E3 where E3: @T
             *    2. DynamicObject: E1.E2.E3 where E3: ^T
             *    3. Pattern:       E1.E2.E3 where E3: S{ ... }
             *    4. Singular:      E1.E2.E3{ ...} where E3: S{ ... }
             *)
            (# qual: ^ObjectGenerator (* PatternId *)
            do (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   this(ObjectGenerator)[] -> qual[]
               if)
            exit qual[]
            #);
          inSuper: BooleanValue
            (# lQ: ^ObjectGenerator
            enter lQ[]
            do (*'inSuper: lQ: ' -> putline;
               (if lQ[] <> none then
                   lQ.doPT -> putline;
               if);
               'rQ: '->putline;
               doPT -> putline;*)
               L:
                 (if lQ[] = this(ObjectGenerator)[] then
                     true -> value 
                  else
                     (if (lQ[] <> none) then
                         (if (lQ.primNo = object_prim) then
                             (*'Got object_prim'->putline*)
                          else
                             (*(if lQ[] <> none then lQ.doPT -> putline if);*)
                             
                             lQ.super.getQual2 -> lQ[];
                             (*lQ.doPP -> putline;*)
                             (if lQ[] <> none then
                                 (*'Super: ' -> puttext; lQ.primNo -> putint; newline;*)
                                 restart L
                              else
                                 objectDecl.getQual2 -> lQ[];
                                 restart L;
                                 (*'super:getQual2 none'->putline*)
                             if);

                     if)if)
                 if)
            #)
       #);
     Invocation::<
       (# getQual2:
            (# qual: ^ObjectGenerator; E: ^Exp; 
            do scanSons(# do current[] -> E[] #);
               ('Invocation:getQual',E[]) -> display;
               E.getQual2 -> qual[]
            exit qual[]
            #);               
          getQual:
            (# qual: ^ObjectGenerator  (* PatternId *); E: ^Exp;
            do 
               scanSons(# do current[] -> E[] #);
               ('Invocation:getQual',E[]) -> display;
               (if true then
                   E.getQual -> qual[]
                else                   
                   (if E.ATd[] <> none then
                       E.ATd.getQual -> qual[]
                       (*else
                        ObjectGenerator -> qual[]*)
               if)if)
            exit qual[]
            #);
          getExpQual::
            (#
            do scanSons(# do current[] -> eQual[] #)         
            #);
       #);
     Binary::<
       (# semCheck::
            (# receiver: ^Exp
            do (*'Binary:semCheck'-> putline;*)
               (if ATd[] <> none then
                   args[] -> ATd.sig.checkActualArgs
                else
                   (if ':=' -> operator.T.equal then 
                       rec[] -> receiver[];
                       args.scanArgs
                       (# i: @integer
                       do (if (i + 1 -> i) > 1 then
                              args[] -> semanticError
                              (#
                              do 'List too long to be assigned to: "' -> puttext;
                                 receiver.doPT -> puttext; '"' -> put; newline
                              #)
                          if);
                          current[] -> receiver.ATd.checkQual2 
                       #);
                   if)
               if)
            #);
       #);
     Function::<
       (# semCheck::
            (#
            do args[] -> ATd.sig.checkActualArgs
            #);
       #);
     KeyWord::<
       (# getQual2::
            (#
            do getQual -> qual[]
            #);
          getQual::
            (#
            do (if ATd.primNo = this_Prim then
                   (* move to Apl:getQual*)
                   args.scanArgs
                   (#
                   do current[] -> qual[]
                   #);
                   ('Keyword:getQual:this_prim', qual[]);
               if)
            #)
       #);
  do '**** SEMANTIC CHECKER' -> putline;
     rootModule.semCheck;
     inner
  #)
