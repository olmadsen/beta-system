ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
---lib:attributes---
semchecker: checker
  (# DataItem::<
       (# getQual:: (# do OG.getQual -> qual[] #);
          semCheck::
            (* Check that in S : ? T, V: @= T, T is a pattern
             * it seems to work for singular patterns, but check if this is so!
             *)
            (#
            do (if OG.isPtnOrSingular (*(OG.super.checkInv -> isPatternDen)*) then
                   (* pattern or singular *)
                else
                   this(DataItem)[] -> SemanticError
                   (#
                   do 'The qualification "' -> msg;
                      OG.doPT -> msg;
                      '" must be a pattern '-> msg;
                   #)
               if)
            #);
          checkQual::
            (# error:
                 (#
                 do (if reportSemErr then
                        lOG[] -> semanticError
                        (#
                        do '"'->put; lOG.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                 #)if)#);
               lQual,rQual: ^ObjectGenerator
            do (* This is the code from Static/DynamicObject
                * should be reconsidered for const/var
                *)
               (if traceCheckQual then
                   '\n>>> DataItem:checkQual:' -> puttext; 
                   ('Left',lOG[]) -> display;
                   ('Right',this(DataItem)[]) -> display
               if);
               (if lOG[] <> none then 
                   lOG.getQual -> lQual[] (* none if string " ..." *)
                else
                   '>>> lOG none' -> putline
               if);
               (if isConst then error
                else
               (if isSimpleValue then
                   (* this does not capture cases like
                    *   v: ? integer, V := Q
                    * The criteria must be basic or not
                    * Or perhaps isSimpleValue
                    * In fact: isConst => assignment is illegal
                    *)
                   ('lQual',lQual[]) -> display;
                   OG[] -> rQual[];
                   ('rQual',rQual[]) -> display;
                   ('lQual',lQual[]) -> displayB;
                   ('rQual',rQual[]) -> displayB;
                   (if lQual[] <> none then
                       (if lQual.primNo
                        // integer_prim then
                           (if rQual.primNo 
                            // integer_prim // char_prim // boolean_prim then
                            else
                               error
                           if)
                        // char_prim then
                           (if rQual.primNo // integer_prim // char_prim then
                            else
                               error
                           if)
                        // boolean_prim then
                           (if rQual.primNo // boolean_prim // integer_prim then 
                            else
                               error 
                           if)
                        else
                           error
                       if)
                    else
                       error
                   if)       
                else
                   getQual -> rQual[];
                   ('lQual',lQual[]) -> display;
                   ('rQual',rQual[]) -> display;
                   (if (lQual[] <> none) and (lQual.primNo = none_prim) then
                    else
                       (if lQual[] -> rQual.inSuper then
                        else
                           (if (lQual[] <> none) and (rQual[] -> lQual.inSuper) then
                               lOG[] -> QuaCheck
                               (# 
                               do 'It must be checked at run-time that "'
                                    -> puttext;
                                  lOG.doPT -> puttext;
                                  '"\n     is a subpattern of "' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #)
                            else
                               (if reportSemErr then
                                   lOG[] -> semanticError
                                   (#
                                   do 'The reference expression:\t"' -> puttext;
                                      lOG.doPT -> puttext;
                                      '"\n     cannot be assigned to:\t"' -> puttext;
                                      doPT -> puttext; '"' -> put; newline
                                   #);
               if)if)if)if)if)if)
            #);
       #);
     StaticObject::<
       (# getQual:: (# do OG.getQual -> qual[] #);
          checkQual::
            (# error:
                 (#
                 do (if reportSemErr then
                        lOG[] -> semanticError
                        (#
                        do '"'->put; lOG.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                 #)if)#);
               lQual,rQual: ^ObjectGenerator
            do (if traceCheckQual then
                   '\n>>> StaticObject: checkQual:\nleft: ' -> puttext; 
                   lOG.doPT -> puttext;
                   '\nright: ' -> puttext; OG.doPT -> putline
               if);
               (if lOG[] <> none then
                    lOG.getQual -> lQual[]
               if);
               ('lQual',lQual[]) -> display;
               OG[] -> rQual[];
               ('rQual',rQual[]) -> display;
               ('lQual',lQual[]) -> displayB;
               ('rQual',rQual[]) -> displayB;
               (if lQual[] <> none then
                   (if lQual.primNo
                    // integer_prim then
                       (if rQual.primNo // integer_prim // char_prim // boolean_prim then
                        else
                           error
                       if)
                    // char_prim then
                       (if rQual.primNo // integer_prim // char_prim then
                        else
                           error
                       if)
                    // boolean_prim then
                       (if rQual.primNo // boolean_prim // integer_prim then 
                        else
                           error 
                       if)
                    else
                       error
                   if)
                else
                   error
               if)       
            #);
       #);
     isPatternDen:< BooleanValue
       (# E: ^Exp
       enter E[]
       do (*E.ATd.doPT -> putline;*)
          (if E.ATd[] <> none then E.ATd.isPatternDecl -> value if)
       #);     
     DynamicObject::<
       (# semCheck::
            (#
            do (*'\nDynObj: semCheck: ' -> puttext;  PI.doPT -> putline;*)
               (if (PI.IV.checkInv -> isPatternDen) then
                else
                   this(DynamicObject)[] -> SemanticError
                   (#
                   do 'The qualification "' -> msg;
                      PI.IV.doPT -> msg;
                      '" must be a pattern '-> msg;
                   #)
               if)
            #);
          getQual:: 
            (# 
            do (if traceCheckQual then
                   'DynamicObject:getQual: '->puttext; doPT -> putline;
               if);
               PI.IV.getQual -> qual[];
            #);
          CheckQual::
            (# lQual,rQual: ^ObjectGenerator
            do (if traceCheckQual then
                   '\n>>> DynamicObject:checkQual:' -> putline;
                   ('Left',lOG[]) -> display;
                   ('Right',this(DynamicObject)[]) -> display
               if);
               (if lOG[] <> none then 
                   lOG.getQual -> lQual[] (* none if string " ..." *)
                else
                   '>>> lOG none' -> putline
               if);
               getQual -> rQual[];
               ('lQual',lQual[]) -> display;
               ('rQual',rQual[]) -> display;
               (if (lQual[] <> none) and (lQual.primNo = none_prim) then
                else
                   (if lQual[] -> rQual.inSuper then
                    else
                       (if (lQual[] <> none) and (rQual[] -> lQual.inSuper) then
                           lOG[] -> QuaCheck
                           (# 
                           do 'It must be checked at run-time that "'
                                -> puttext;
                              lOG.doPT -> puttext;
                              '"\n     is a subpattern of "' -> puttext;
                              doPT -> puttext; '"' -> put; newline
                           #)
                        else
                           (if reportSemErr then
                               lOG[] -> semanticError
                               (#
                               do 'The reference expression:\t"' -> puttext;
                                  lOG.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #);
               if)if)if)if)
            #);
          
            (* thisDynamicObject)= R: ^PI
             * Test R := lOG
             *    lOG: none
             *         S where S: ^PIx
             *         P where P is pattern returning either P or S: ^Piy
             * where 
             *    qual(R) = rQual
             *    qual(E) = lQual
             * lQual = foo{ ... }
             * rQual = PI.IV = fisk{} - note that Itempart is empty, see getQual 
             * Test lQual <= rQual
             *  => E = none
             *  => foo <= fisk
             * lQ = Fn where foo = F1.F2.,,,.Fn, where Fn is a pattern
             * rQ = Gm where fisk = G1.G2.,,,.Gm, where Gm s a pattern
             * lQ.ATd = Decl(lQ) -> must be pattern decl
             * rQ.ATd = Decl(rQ) -> must be pattern decl
             * Test
             *    lQ.ATd <= rQ.ATd : lQ.ATd[] -> rQ.ATd.inSuper -> value
             *)
            
       #);
     Signature::<
       (# checkActualArgs:
            (# actualArgs: ^Arguments
            enter actualArgs[]
            do (if args[] <> none then
                   actualArgs[] -> args.checkActualArgs
                else
                   (if traceCheckQual then
                       'Signature:checkActualArgs: args is none: ' -> puttext;
                       this(Signature).doPT -> putline;
                       ' actuals: ' -> puttext;
                       actualArgs.doPT -> putline
                   if)
               if)
            #);
          getQual:: 
            (# 
            do (if traceCheckQual then
                   'Signature:getQual: "\n' -> puttext; dopt->puttext;
                   '"' -> put; newline
               if);
               (if val[] <> none then val.getQual -> qual[] if)
            #);
       #);
     Arguments::<
       (# checkActualArgs:
            (# args: ^Arguments; A: [6] ^Decl; inx,top: @ integer
            enter args[]
            do (if traceCheckQual then
                   '\nCheck: ' -> puttext; args.doPT -> putline;
                   '  against: ' -> puttext; this(Arguments).doPT -> putline;
               if);
               scanSons
               (# 
               do (if (top + 1 -> top) > A.range then A.range -> A.extend if);
                  current[] -> A[top][] 
               #);
               args.scanSons
               (# 
               do inx + 1 -> inx; 
                  current[] -> A[inx].checkQual 
               #);
            #);
       #);
     Value::<
       (# getQual:
            (# D: ^Decl; qual: ^ObjectGenerator 
            do scanSons(# do current[] -> D[] #);
               (* only works for one return value/decl *)
               D.getQual -> qual[];
               (if traceCheckQual then
                   'Value: ' -> puttext;
                   D.doPT -> putline;
                   (if qual[] <> none then 
                       qual.doPT -> putline;
                    else 'none '->putline
               if)if);
            exit qual[]
            #)
       #);
     ObjectGenerator::<
       (# getQual:
            (# qual: ^ObjectGenerator 
            do (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   this(ObjectGenerator)[] -> qual[]
               if)
            exit qual[]
            #); 
          inSuper: BooleanValue
            (# lQ: ^ObjectGenerator
            enter lQ[]
            do ('inSuper:lQ',lQ[]) -> display;
               ('rQ',lQ[]) -> display;
               L:
                 (if lQ[] = this(ObjectGenerator)[] then
                     true -> value 
                  else
                     (if (lQ[] <> none) then
                         (if (lQ.primNo <> object_prim) then
                             lQ.super.getQual -> lQ[];
                             (if lQ[] =  none then
                                 objectDecl.getQual -> lQ[]
                             if);
                             restart L;
                 if)if)if)
            #);
          isPtnOrSingular: BooleanValue
            (#
            do (if super.ATd[] <> none then
                   super.ATd.isPatternDecl -> value
                else
                   (* no super - muts be singular *)
                   not IS.isEmpty -> value
               if)
            #)
       #);
     Invocation::<
       (# checkInv:
            (# E: ^Exp; 
            do (* should check path *)
               scanSons(# do current[] -> E[] #);
            exit E[]
            #);
               
          getQual:
            (# qual: ^ObjectGenerator; E: ^Exp; 
            do scanSons(# do current[] -> E[] #);
               ('Invocation:getQual',E[]) -> display;
               E.getQual -> qual[]
            exit qual[]
            #);
       #);
     Binary::<
       (# semCheck::
            (# receiver: ^Exp
            do (*'Binary:semCheck'-> putline;*)
               (if ATd[] <> none then
                   args[] -> ATd.sig.checkActualArgs
                else
                   (if ':=' -> operator.T.equal then 
                       rec[] -> receiver[];
                       args.scanArgs
                       (# i: @integer
                       do (if (i + 1 -> i) > 1 then
                              args[] -> semanticError
                              (#
                              do 'List too long to be assigned to: "' -> puttext;
                                 receiver.doPT -> puttext; '"' -> put; newline
                              #)
                          if);
                          current[] -> receiver.ATd.checkQual 
                       #);
                   if)
               if)
            #);
       #);
     Function::<
       (# semCheck::
            (#
            do (if ATd[] = none then 
                   'Function:semCheck: ATd = NONE: ' -> puttext;
                   doPT -> putline;
                else
                   args[] -> ATd.sig.checkActualArgs
               if)
            #);
       #);
     KeyWord::<
       (# getQual::
            (#
            do (if ATd.primNo = this_Prim then
                   (* move to Apl:getQual*)
                   args.scanArgs
                   (#
                   do current[] -> qual[]
                   #);
                   ('Keyword:getQual:this_prim', qual[])->display;
               if)
            #);
       #);
     StringObj::< (# getQual:: (#do stringDecl.getQual -> qual[] #) #);
     
  do '**** SEMANTIC CHECKER' -> putline;
     rootModule.semCheck;
     inner
  #)
