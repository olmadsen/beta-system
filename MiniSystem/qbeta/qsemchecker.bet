ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual';
INCLUDE 'qunithandler';
BODY 'semchecker_trace'
---lib:attributes---
semchecker: UnitHandler
  (# Module::<
       (# semcheck:: 
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[]
                    if)
                 exit M[]
                 #);
               M: ^Module;
            do (if false then
                   'Module:semCheck:'->puttext; sig.id[] -> putline;
               if);
               (if (encModule -> M[]) <> none then
                   M.semCheck
               if)
            #);
          getVqual::
            (#
            do (if true then
                   '**** Module:getVqual: ' -> putline; dopt -> puthead
               if);
               OG[] -> qual[]
            #);          
          getQual::
            (#
            do (if traceGetQual then
                   '**** Module:getQual: ' -> putline; dopt -> putline
               if);
               OG[] -> qual[]
            #);
       #);
     ModuleItem::<
       (# semCheck::
            (#
            do (if false then
                   '**** ModuleItem:semcheck: ' -> puttext; sig.dopt->putline;
                   ' isIncluded: ' -> puttext; MD.isIncluded -> putboolean;
                   newline
               if);
               (* MD.isIncluded does not seem to work here - a trace shows
                * that no modules are included. It seems that isIncluded is
                * defined via ModulePath in generator. If we delete
                *  false -> doCheck, asemcheck will loop
                * We thus semcheck all modules that have been checked
                * We should fix the compiler to only check, semcheck and
                * generate code for modules actually being used
                *)
               (if not MD.isIncluded then
                   (if false then
                       'Module not included: ' -> puttext; sig.doPT -> putline;
                   if);
                   false -> doCheck
               if);
               (if isChecked then
                   (none,encOG[]) -> MD.OG.semcheck -> encOG[] -> eOG[];
               if)
            #);          
          getVqual:: 
            (# 
            do (if traceGetQual then
                   'ModuleItem:getVqual: ' -> puttext; dopt -> puthead
               if);
               md.OG[] -> qual[]
            #);          
          getQual:: 
            (# 
            do (if traceGetQual then
                   'ModuleItem:getQual: ' -> puttext; dopt -> puthead
               if);
               md.getQual -> qual[]
            #);
       #);
     NewProperty::<
       (# semcheck::
            (#
            do (if true
                // '%id' -> propId.T.equalNCS then
                   (* no semcheck of*)  true -> done 
                // ('%modules' -> propId.T.equalNCS) 
                   and locateWorld.aMiniBetaModule then
                   (*'**** aMiniBetaModule'->putline;*)
                   true -> done;
                // '%exclude' -> propId.T.equalNCS then
                   true -> done;
                   '%exclude:'->dumpT;
                   args.scanSons
                   (# INV: ^Invocation
                   do current.dopt -> dumpT;
                      current.label -> dumpTN;
                      (current[]->INV[]).Atd.dopt -> dumpTN
                   #);
               if)
            #)
       #);
     NameDecl::<
       (# semCheck::
            (#
            do (*'**** NameDecl:semCheck:'->puttext; doPT -> putline;*)
            #);
          getVqual::
            (#
            do (if traceGetVqual then
                   '**** NameDecl:getVqual:'->dumpT; dopt -> dumpTN
               if);
               (encOG[],isNest,OGS[]) -> ATd.getVqual -> (OGS[],qual[]);
            #);
          getQual::
            (#
            do ATd.getQual -> qual[]
            #)
       #);
     DataItem::<
       (# getVqual::
            (#
            do (if traceGetVqual then
                   '**** DataItem:getVqual: ' ->puttext; dopt->putheadN;
                   '**   OGS:'->puttext;
                   (if OGS[] = none then 
                       'none' -> putline 
                    else
                       OGS.print
                   if);
               if);
               (if not OG.isChecked then
                   (*'!!!! no:checked:'->dumpT; dopt -> dumpTN;*)
                   (none,origin[],none,true) -> OG.check
               if);
               (encOG[],false,OGS[]) -> OG.getVqual -> (OGS[],qual[]);
            #);
          getQual:: 
            (# U: ^Text
            do (if traceGetqual then
                   '**** DataItem:getQual: ' -> puttext; sig.dopt ->putline
               if);
               OG.getQual -> qual[];
               (if traceGetqual then
                   '***** DI:getQual:for: ' -> puttext; sig.doPT ->puttext;
                   ' qual:\n' -> puttext; qual.dopt -> puthead
               if);
            #);
          semCheck::
            (* Check that in S: var  T, V: vaL T, T is a pattern
             * It seems to work for singular patterns, but check if this is so!
             * And for X: var/val/obj foo(e1,e2,e3) - type(X) = type(foo.retu rn)
             *)
            (# checkForRecursiveEmbedding:
               (* check if there is a circular/recursive embedding of a const object using obj
                * or an embedding of a value object using var and/or val
                *)
               (# traverse: BooleanValue
                     (# DIa: ^DataItem
                     enter DIa[]
                     do DIa.OG.IS.scanAllItemDecls
                           (# DIx: ^DataItem
                           do (if currentDcl.isDataItem then
                                 currentDcl[] -> DIx[];
                                 (if (DIx.isConst or DIx.isValue) and not DIx.OG.isBasicValue then
                                    (if false then
                                        '**   DI:isConst:hasConst:X:'->dumpT; DIx.dopt->putheadN;
                                    if);
                                    (if DIx.OG.theDesc = this(DataItem).theDesc then
                                         '     The data-item: '->errMsg[]; DIx.dopt -> errMsg.append;
                                         true -> value
                                    else
                                        (if DIx[] -> traverse -> value then
                                           '\n     is an attribute of: '->errMsg.append; DIx.dopt -> errMsg.append;
                    if)if)if)if)#)#);
                  errMsg: ^Text
               do (if (isConst or isValue) and not OG.isBasicValue then
                      (if false then
                          '**   DI:isConst:'->dumpT; dopt -> putHeadN
                      if);
                      (if this(DataItem)[]->traverse then
                           this(DataItem) -> semanticError
                           (# 
                           do 'There is a circular recursive definition of data-items\n' -> msg;
                              errMsg[] -> msg;
                              '\n     is an attribute of: '->msg; dopt -> msg;
                              (if isConst and not isValue then 
                                  '\n     The keyword "obj" implies that the data-item is  '->msg;
                                  '\n     allocated as part of the enclosing object.'-> msg;
                                  '\n     The above declarations will thus lead to an infinite recursive allocation.'->msg;
                              else
                                  '\n     The keyword "var" or "val" implies that the data-item is '->msg;
                                  '\n     embedded in the enclosing object.'-> msg;
                                  '\n     The above declarations will thus lead to an infinite recursive allocation.'->msg
                  if)#)if)if)#);
               OGqual: ^ObjectDescriptor
            do (if traceCheck then
                   '**** DataItem:semCheck:\n' -> puttext; dopt -> putheadN;
                   '**   OG.super:'->dumpT; OG.super.doPT -> dumpTN;
                   '**   OG.isPtnOrSingular:' -> puttext; OG.isPtnOrSingular -> putBoolean; 
                   ' isValue:' -> puttext; isValue -> putboolean;
                   ' isPrimitive:' -> puttext; isPrimitive -> putBoolean;
                   ' OG.isValueObj: ' -> puttext; OG.isValueObj -> putBoolean;
                   '\n**  OG:'->putline; OG.dopt -> puthead; OG.label -> putline;
                   '\n**   OG.getQual: ' -> puttext; (OG.getQual).dopt -> puthead;
                   newline;
               if);
               (if isConst or isValue then
                   (rec[],encOG[]) -> OG.semCheck -> OGqual[]
                else
                   OG.getQual -> OGqual[];
               if);
               checkForRecursiveEmbedding;
               (if OG.isPtnOrSingular then
                   not isConst or isArg -> noArgsCheck;
                   (* see qabstractSyntaxTree::semCheck
                    * if noArgsCheck, the sons are not checked
                    * Is this correct?
                    *)
                   (if isValue then (* val or var *) 
                       (if not (OGqual.isValueObj 
                           or OGqual.isPrimitive
                           and (OGqual.primNo <> string_prim)) then 
                           (if (OGqual.primNo <> string_prim) and not freeDIkind then '*** bum'->putline;
                               this(DataItem)[] -> SemanticError
                               (#
                               do 'The type "' -> msg; OG.doPT -> msg;
                                  '" of "'-> msg; sig.doPT -> msg;
                                  '" must be a value pattern' -> msg;
                               #);
                               OGqual.isValueObj ->putboolean; ' ' ->put;
                               OGqual.isPrimitive ->putboolean; ' ' ->put;
                               (OGqual.primNo <> string_prim) -> putboolean;
                               OG.dopt -> putheadN;
                               OGqual.dopt->putheadN
                       if)if)
                    else (* obj or ref *)
                       (* we currently allow A: ref String
                        * but not R: obj String - gives run-time error
                       *)
                       (if OGqual.isValueObj
                           and not (OGqual.primNo = String_prim)
                           or isConst and (OGqual.primNo = String_prim) then
                           (if OGqual.isBasicValue then
                               (* while implementing sub of integer, etc
                                * we allow decl of the form I: ?integer
                                *)
                            else
                               this(DataItem)[] -> SemanticError
                               (#
                               do 'The qualification "' -> msg; OG.doPT -> msg;
                                  '" must be an object pattern' -> msg;
                   #)if)if)if)
                else
                   (if true then
                       (if OGqual.super.ATd[] <> none then
                           OGqual.super.ATd.doPT -> putline;
                        else
                           OGqual.father.doPT -> puthead
                   if)if);
                   this(DataItem)[] -> SemanticError
                   (#
                   do 'The qualification "' -> msg;
                      OG.doPT -> msg;
                      '" must be a pattern '-> msg;
            #)if)#);
          checkQual::
            (* Check that enter arg srcOS can be assigned to dstOG
             * which is this(DataItem) 
             *)
            (# error:
                 (#
                 do (if reportSemErr then
                        srcOS[] -> semanticError
                        (#
                        do '"'->put; srcOS.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                           '**   in object:\n' -> putline;
                           (enclosingObjectDescriptor).father.dopt->putHeadN;
                           inner error;
                           (if true then
                               '**** srcQual:' -> puttext; 
                               (if srcQual[] <> none then
                                   srcQual.dopt -> putHeadN
                                else
                                   'none'->putline
                               if);
                               '**** srcOS.getQual:' -> puttext; 
                               (srcOS.getQual).dopt -> putline;  
                               '**** dstQual:' -> puttext; 
                               (if dstQual[] <> none then
                                   dstQual.dopt -> putHeadN
                                else
                                   'none' -> putline
                               if);
                               '**** dstOG.getQual:' -> puttext; 
                               (getQual).dopt -> putheadN
                 if)#)if)#);
               emitTrace:
                 (#                    
                 do '\n**** DataItem:checkQual:' -> puttext; 
                    (if isConst then ':C:' -> puttext if);
                    (if isAssign then 'assign:' -> puttext if); newline;
                    ('**   dst',this(DataItem)[]) -> display; 
                    ('**   src',srcOS[]) -> display;
                    (if false then
                        '**   dst.lab:dataItem' -> putline;
                        '**   src.lab: ' -> puttext; srcOS.label -> putline;
                    if);
                    '**   dstQual:'->putline; dstQual.label -> puttext;
                    ' ' -> put; dstQual.dopt -> puthead;
                    '**   srcQual:'->putline; srcQual.label -> puttext;
                    ' ' -> put; srcQual.dopt -> puthead;
                    '**   dstQual:isValueObj:'->puttext;
                    dstQual.isValueObj->putboolean; newline;
                    '**   srcQual:isValueObj:'->puttext; 
                    srcqual.isValueObj -> putboolean;newline;
                    '**   src: ' -> puttext; 
                    srcOS.doPT -> putline;
                    '**   srcOS.arg1Qual: ' -> puttext;                    
                    (if srcOS.arg1Qual[] <> none then
                        srcOS.arg1Qual.dopt -> putline
                     else
                        ' none ' -> putline
                    if);
                    (if false and (dstQual.primNo = indexed_prim) then
                        '**** DI:checkQual:dst is Indexed: ' -> puttext; 
                        this(DataItem).dopt -> putline;
                        '**   src: ' -> puttext; srcOs.doPP -> puttext;
                        ' ' -> put; srcOS.dopt -> putline;
                    if);
                 #);  
               checkSameEncloser:
                 (# src,dst: ^Decl; srcDI,dstDI: ^DataItem;
                    is,ix: @integer; 
                    predSrc,lastSrc,predDst,lastDst: ^Exp;
                    trace: (# exit false #);
                 enter(src[],dst[])
                 do (if trace then 'checkSameEncloser:'->puttext; if);
                    (if src.isDataItem and dst.isDataItem then
                        (if trace then 'di:'->puttext; if);
                        src[] -> srcDI[];
                        dst[] -> dstDI[];
                        (* for objects must be isConst - 
                         * here isValueObj *)
                        (if src.OG.IS.isEmpty and
                            dst.OG.IS.isEmpty then
                            (* src = s1.s2,...,sn
                             * dst = d1.d2,...,dn
                             * where sn = dn
                             * Warning if si <> di 
                             * where 1 <= i and i < n
                             *)
                            (if trace then 'IS:empty:'->puttext; if);
                            src.OG.super.scanSons
                            (#
                            do is + 1 -> is;
                               lastSrc[] -> predSrc[];
                               current[] -> lastSrc[]
                            #);
                            
                            dst.OG.super.scanSons
                            (#
                            do ix + 1 -> ix;
                               lastDst[] -> predDst[];
                               current[] -> lastDst[]
                            #);
                            (if (is > 1) and (ix > 1) then
                                (if trace then 
                                    'remote:'->dumpT;
                                    predSrc.dopt -> dumpt;
                                    lastSrc.dopt -> dumpt;
                                    predDst.dopt -> dumpt;
                                    lastDst.dopt -> dumptN;
                                if);
                                (if predDst.ATd.asDecl <> predSrc.ATd.asDecl then
                                    srcOs[] -> warning
                                    (#
                                    do 'The type of: '->msg;
                                       dst.sig.dopt -> qmsg;
                                       ' and ' -> msg;
                                       src.sig.dopt -> qmsg;
                                       ' is ' -> msg;
                                       lastSrc.dopt -> qmsg;
                                       '\n**   in different objects: '
                                         -> msg;
                                       predDst.dopt -> qmsg;
                                       ' and '->msg;
                                       predSrc.dopt -> qmsg;
                                       '\n**   and thus not the same '-> msg;
                                       lastSrc.dopt -> qmsg;
                 #)if)if)if)if)#)
                    
            do (if traceGetVqual then emitTrace if);
               (* We may come here with 
                * dstU = in base: var Unit
                * I.e. OG = Unit and no items
                * This may be a problem and perhaps we should get Unit.qual!?
                *)
               (if  traceGetVQual then
                   '**** before:checkUnits:'->dumpT; dopt -> putheadN;;
                   srcOs.dopt -> putHeadN;;
                   srcQual.dopt -> putheadN;; dstQual.dopt -> putheadN;;
               if);
               (srcOS[],srcQual[],dstQual[]) 
                 -> checkUnits  -> (srcQual[],dstQual[]);

               (* We need to call getV_qual at the point of the 
                * ObjectInvocation: X := exp or R. foo
                * to get the actual binding of possible virtuals
                * at the point of call
                *)
               ('srcQual',srcQual[]) -> displayB; (* there is also a Display *)
               ('dstQual',dstQual[]) -> displayB;
               (if isConst and isAssign then
                   (* OG is left-part of assign as in aPoint1 := aPoint2 *)
                   (if OG.isValueObj then
                       error
                       (#
                       do '\n**   The destination is a constant value object '
                          'as declared by "val"'->putline
                       #)
                    else
                       error(#do 'BIM'->putline #)
                   if)
                else
                   (if false then
                       (# isEq,isSub,isSuper,isObjectD: @boolean
                       do '\n**** getSubSuperRelation:dstOS:' -> dumpT;
                          sig.dopt -> dumpT;
                          ' src:'->dumpT; srcOS.dopt -> dumpTN;
                          srcQual[] 
                            -> dstQual.getSubSuperRelation
                            -> (isEq,isSub,isSuper,isObjectD);
                          'isEQ:' -> dumpT;
                          isEQ -> putBoolean;
                          ' isSub:' -> dumpT; isSub -> putBoolean;
                          ' isSuper:' -> dumpT; isSuper -> putBoolean;
                          ' isSObjectD:' -> dumpT; isObjectD -> putBoolean;
                          newline;
                   #)if);
                   (if false then
                       (* first shot at a simpler version of the checking
                        * we also need to check dstQual < srcQual and issue 
                        * a warning.
                        * And check for anObj := aValue
                        *)
                       L:
                         (if srcQual[] -> dstQual.inSuper then 
                             (* ok *)
                          else
                             (if srcQual.primNo
                              // integer_prim then
                                 (if dstQual.primNo
                                  // char_prim // boolean_prim // float_prim then
                                     leave L
                                 if)
                              // char_prim // boolean_prim // float_prim then
                                 (if dstQual.primNo = integer_prim then
                                     leave L
                                 if)
                             if);
                             srcOS[] -> warning
                             (#
                             do 'No match'-> msg
                             #)
                   if)if);
                   (if true (* OG = dst *)
                    // OG.primNo = indexed_prim then
                       (* OBS! Added srcOs.super.isVindexed; to simplify
                        * generation of cd.mkVindexed; did not work as intended!
                        * We may check isVindexed at the end of INV:gen, 
                        * but we dont know descNo of destination;
                        * same problem in handleNonVirtualArg
                        *)
                       (# emit:
                            (#
                            do OG.dopt->putHead;
                               ' src:'->dumpt; srcOs.dopt-> dumpTN;
                            #)
                       do (if srcOs.IS.isEmpty then
                              (if srcOS.super.ATd.OG.primNo <> indexed_prim
                                  then
                                  (if false then
                                      'checkQual:asgToIndexed:'->dumpT;
                                      emit;
                                  if);
                                  true -> srcOs.super.isVindexed;
                              if)
                           else
                              srcOs[] -> warning
                              (#
                              do 'Potential error in assignment to Index/Array'
                                   -> msg;
                                 '\nsource: ' -> msg; srcOs.dopt -> msg;
                                 '\ndestination: '->msg; OG.dopt->msg
                              #);
                       if)#)
                       (* we still need to check that srcOs whether single
                        * or list has same type as the destination Indexed
                        *)
                    // OG.primNo = rIndexed_prim then
                       (* similar to indexed_prim above *)

                    // OG.isBasicValue and not dstQual.isNonBasicValueObj 
                      or
                       (dstQual.isBasicValue) and (srcQual.isBasicValue)
                    then
                       (* OBS! For Indexed, not dstQual.isNonBasicValueObj overrides the integer type of the
                        * element type hvis is integer; we should include and Any-type.
                        * We also need to handle this for Array.
                        * The value_prim cases below is to handle
                        *    _V: ?Value 
                        * in patterns integer, char and boolean
                        *)
                       (if srcQual[] <> none then
                           (if srcQual.primNo
                            // integer_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim 
                                // boolean_prim // float_prim then
                                else
                                   error
                               if)
                            // char_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim // value_prim then
                                else
                                   error
                               if)
                            // boolean_prim then
                               (if dstQual.primNo 
                                // boolean_prim // integer_prim then 
                                else
                                   error 
                               if)
                            // float_prim then
                               (if dstQual.primNo 
                                // float_prim // integer_prim then 
                                else
                                   error 
                               if)
                            // value_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim // value_prim then
                                else
                                   error
                               if)                               
                            else 
                               error(#do 'BUM'->dumptn #)
                           if)
                        else
                           error
                       if)  
                    // OG.isValueObj // dstQual.isValueObj then
                       (if true
                        // srcQual[] = dstQual[] then (* OK *)
                           (* if isValueObj, then srcQual = dstQual = float
                            * so bad check
                            *)
                           (if false then
                               'Equal:src:'->dumptN; srcQual.dopt->putheadN;
                               'dst:'->dumpT; dstQual.dopt->putheadN;
                               'src:'->dumpT; srcOS.dopt ->dumpTN;
                               'dst:'->dumpT; dopt -> putheadN;
                           if);
                           (# srcDcl: ^Decl; 
                           do srcOs.getDecl -> srcDcl[]; 
                              (if (srcDcl[] <> none) and 
                                  (srcDcl[] = this(DataItem)[]) then
                                  (if false then
                                      'srcDecl:'->dumpt;
                                      srcDcl.dopt -> putheadN;
                                      'dstDcl:'->dumpT;
                                      dopt -> dumptN
                                  if);
                                  (srcDcl[],this(DataItem)[]) 
                                    -> checkSameEncloser
                               else
                                 (if false then  newline if)
                              if)
                           #)
                        // srcQual[] -> dstQual.inSuper then 
                           (if dstQual.primNo <> value_prim then
                               srcOS[] -> Warning
                               (# 
                               do 'The right-side value: "' -> msg;
                                  srcOS.doPT -> msg;
                                  '" is truncated \n\t' -> msg;
                                  'when assigned to the left-side variable: "'
                                    -> msg;
                                  doPT -> msg; '"' -> msg
                           #)if)
                        // dstQual[] -> srcQual.inSuper then 
                           srcOS[] -> Warning
                           (#
                           do 'Source is super of dest: ' -> msg;
                              '\n     source: ' -> msg; srcOS.dopt -> msg;
                              '\n     dest  : ' -> msg; dopt -> msg;
                              '\n     ' -> msg;
                              srcOS.father.father.father.dopt -> msg;
                           #);
                           (if false then
                               '**   dstQual: ' -> dumpTN;
                               dstQual.dopt -> putHeadN;
                               '**   srcQual: ' -> dumpTN;
                               srcQual.dopt -> putHeadN;
                           if)
                        // srcQual.isInteger // srcQual.isFloat then
                           srcOS[] -> semanticError
                           (#
                           do 'The integer or float expression: "' -> msg;
                              srcOS.doPT -> msg;
                              '"\n    cannot be assigned to: "' -> msg;
                              doPT -> msg; '"\n' -> msg;
                               (if true then
                                   '**** dstQual: ' -> putline;
                                   dstQual.dopt -> puthead;
                                   '**** srcQual: ' -> putline;
                                   srcQual.doPT -> puthead;
                                   '**   srcQual.father:' -> putline;
                                   srcQual.father.doPT -> puthead;
                                   '**   srcQual.father.father:' -> putline;
                                   srcQual.father.father.doPT -> puthead
                           if)#);
                        else
                           (if srcOS.primNo 
                            // indexedGet_prim then
                               ('!!! Not handled:indexGet_prim',srcOS[]) 
                                 -> putPT;
                               (* fix that the type of the indexed DI is 
                                * consistent with the left-side
                                *)
                            else
                               (* we should spell out whether or not srcOS, etc
                                * are objectRefs or valueObjs *)
                               srcOS[] -> semanticError
                               (#
                               do 'The expression:\t"' -> puttext;
                                  srcOS.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' 
                                    -> puttext;
                                  doPT -> puttext; '"' -> put; newline;
                                  (if true then
                                      '**** OG.isBasicValue:'->dumpT; OG.isBasicValue-> putboolean;
                                      ' dstQual.isNonBasicValueObj:'->dumpT; dstQual.isNonBasicValueObj ->putboolean;
                                      ' dstQual.isValueObj:'->dumpt; dstQual.isValueObj->putboolean;
                                      newline;
                                      '**** dstQual: ' -> putline;
                                      dstQual.dopt -> puthead;
                                      '**** srcQual: ' -> putline;
                                      srcQual.doPT -> puthead;
                                      '**   srcQual.father:' -> putline;
                                      srcQual.father.doPT -> puthead;
                                      '**   srcQual.father.father:' -> putline;
                                      srcQual.father.father.doPT -> puthead
                                  if)
                       #)if)if)
                    else (* OG = dst is a reference *)
                       (if true
                        // srcOS.isValueObj 
                           and (OG.origin.encOG.primNo <> indexedPut_prim) and  not freeDIkind then
                          (* OG.origin.encOG.primNo <> indexedPut_prim is true for V: ref elm in:
                           * Array(range: var integer, elm:< Object): 
                           *     ...; put(V: ref elm):at[inx: var integer]: { %basic 115 ... }; ...
                           * in order to allow anArray.put(V):at[ix]
                           * for V being a primitive value or a value object
                           *)
                           srcOS[] -> semanticError
                               (#
                               do 'The value expression: "' -> msg;
                                  srcOS.doPT -> msg;
                                  '"\n     cannot be assigned to '-> msg;
                                  'the object reference: "' -> msg;
                                  doPT -> msg; '"' -> msg;
                               #);
                           (if false then
                               '**   dstQual:'->putline;
                               dstQual.dopt -> putheadN;
                               '**   srcQual:'->putline;
                               srcQual.dopt -> putheadN;
                           if)
                        // srcQual[] = dstQual[] then 
                           (* OK: and may be merged with the case below.
                            * Is splitted for test purposes, see below
                            *)
                           (if false then
                               'Equal:'->dumptN;
                               srcQual.dopt->putheadN;
                               dstQual.dopt->putheadN;
                               'src:'->dumpT; srcOS.dopt ->dumpTN;
                               'dst:'->dumpT; dopt -> puthead;
                           if)
                        // srcQual[] -> dstQual.inSuper then (* OK *)
                           (* This is just for test purposes: 
                            * for references this is ok, but for values, 
                            * the right-side may be truncated, see above
                            *)
                           (if false then
                               srcOS[] -> Warning
                               (# 
                               do 'The right-side: "' -> msg;
                                  srcOS.doPT -> msg;
                                  '" refers to a subpattern/obj ' -> msg;
                                  'of the left-side: "' -> msg;
                                  doPT -> msg;
                                  '"' -> msg
                               #);
                           if)
                        // (srcQual[] <> none) 
                           and (dstQual[] -> srcQual.inSuper) then
                           srcOS[] -> QuaCheck
                           (# 
                           do 'It must be checked at run-time that "'
                                -> puttext;
                              srcOS.doPT -> puttext;
                              '"\n     is a subpattern of "' -> puttext;
                              doPT -> puttext; '"' -> put; newline
                           #)
                        // (srcQual[] <> none) and (srcQual.primNo = none_prim) then
                        else
                           (if reportSemErr then
                               srcOS[] -> semanticError
                               (#
                               do 'The reference expression:\t"' -> puttext;
                                  srcOS.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' ->puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #);
                               (if false then
                                   srcQual[] = dstQual[] -> putboolean; newline;
                                   '**** srcQual:' -> putline;
                                   srcQUal.dopt -> putheadN;
                                   '**** dstQual: ' -> putline;
                                   dstQual.doPT -> putheadN;
               if)if)if)if)if)
            #);
       #);
     LabelDecl::<
       (# getVqual::
            (#
            do (if traceGetVqual then
                   '**** LabelDecl:getVqual: ' -> puttext;
                   sig.dopt->putline;
                   (if OGS[] = none then '!!!! OGS is none' -> putline if);
                   OGS.print
               if);
               (encOG[],false,OGS[]) -> OG.getVqual -> (OGS[],qual[]);
               (if false then
                   '**   qual: ' -> putline;
                   qual.doPT -> putline
               if)
            #)
       #);
     isPatternDen:< BooleanValue
       (# E: ^Exp
       enter E[]  
       do E.ATd.doPT -> puthead;
          (if E.ATd[] <> none then (E.ATd.asDecl).isPatternDecl -> value if)
       #); 
     
     pattern::<
       (# checkQual::
            (* We come here for assignments of the form
             *    (this Speed) := exp
             * where 
             *    Speed: integer{... }
             *    Point: Value{ ... }
             *    Record: { ... }
             * This pattern must be a value of sub of basic 
             * - the latter may later be desclared as sub of Value
             *)
            (# trace: (# exit traceGetQual #)
            do (if trace then
                   '**** Pattern:checkQual:\n' -> puttext; dopt ->puttext;
                   '\n**   :isAssign:' -> puttext; isAssign -> putBoolean;
                   ' :srcOS: "' -> puttext; srcOS.dopt -> putheadN; 
                   '**   srcQual: ' -> puttext; srcQual.dopt -> putHeadN;
                   '**   dstQual: ' -> puttext; dstQual.dopt -> putheadN;
                   '"\n' -> puttext;
                   '**   isValueObj:'->puttext; OG.isValueObj->putBoolean;
                   ' :isPrimitive:' -> puttext; isPrimitive -> putBoolean;
                   newline;
               if);
               (if isAssign then
                   (if true 
                    // OG.isValueObj then 
                       '**** pattern:checkQual:isValueObj:' -> putline;
                       '**   check assignTo: \n' -> puttext;
                       doPT -> putline;
                       '**  from: "' -> puttext; srcOS.doPT -> puttext;
                       '"\n\n' -> puttext
                    // isPrimitive then 
                       '**** pattern:checkQual:isPrimitive:shouldNotHappen'
                         -> putline;
                    // OG.isBasicValue then 
                       (* this happens - must check if ok! *)
                       (if false then
                           '**** pattern:checkQual:isBasicValue:'->putline;
                           '**   check assignTo: \n' -> puttext;
                           doPT -> putline;
                           '**  from: "' -> puttext; srcOS.doPT -> puttext;
                           '"\n\n' -> puttext
                       if);
                    // isVirtual then
                       (* May happen for
                        *    foo: {in V:< T} where this(PTN) = in V:< T
                        * and an invocation; foo(TT)
                        * where TT is a binding of V
                        *)
                    else 
                       (* Bad message - should be fixed *)
                       srcOS[] -> SemanticError
                       (#
                       do srcOS.doPT -> msg;
                          ' cannot be assigned to :\n' -> msg;
                          dopt -> msg;
                       #)
                   if)           
               if)
            #);
          checkActualArgs::
            (* theOI is the the ObjectInvocation calling this(Pattern) *)
            (# fArgs: [6] ^Decl; inx,top: @ integer; 
               checkIfSuperIsSig:
                 (# E: ^ObjectSpecification; i: @integer; 
                    OGy: ^ObjectDescriptor; ptn: ^Pattern
                 enter(E[],i)
                 do <<SLOT semC7:descriptor>>;
                    (if 'ObjectDescriptor' -> (E.label).equal then
                        E[] -> OGy[];
                        (if not OGy.IS.isEmpty then
                            (if fArgs[i].isVirtual then
                                <<SLOT semC8:descriptor>>;
                                fArgs[i][] -> ptn[];
                                (if ptn.theSig.isSig 
                                    and (OGy[]->mkSig->ptn.thesig.equal) 
                                    then
                                    <<SLOT semC9:descriptor>>;
                                    none -> OGy.super.ATd[]; 
                                    none -> OGy.IS.superDesc[];
                    if)if)if)if)
                 #);
               getOGsequenceOfArg:
                 (* this(Pattern) = PTN
                  * fArgs[inx]    = in R: ref T, declared in PTN
                  * theOI         = invocation PTN(...,e,...)
                  * OGS           = OGS of the OI with path to PTN
                  * Must compute new OGS as if 
                  *    PTN(...,e,...).R := e
                  * Perhaps move this method to qvirtual?
                  *)
                 (# OGS: ^OGsequence; pn: @integer;
                    theOIdclOG,theFargOG: ^ObjectDescriptor;
                 enter OGS[] (* the savedOGS for theOI *)
                 do <<SLOT sem_getOGSofArg:descriptor>>;
                    ((theOI.ATd.asDecl).OG[],true,OGS[]) 
                      -> OGsequence
                      -> OGS[];
                    (if traceGetVqual then ('**   After:',0,0) -> OGS.print if);
                    
                    (theOI.ATd.asDecl).OG[] -> theOIdclOG[];
                    fArgs[inx].origin.encOG[] -> theFargOG[];
                    0 -> pn;
                    <<SLOT sem_getOGSofArg_encOG:descriptor>>;
                    findDclOG:
                      (if theOIdclOG[] <> theFargOG[] then
                          theOIdclOG.IS.superDesc.encOG[] -> theOIdclOG[];
                          pn + 1 -> pn;
                          restart findDclOG
                      if);
                    (for pn repeat OGS.PRE -> OGS[] for);
                    <<SLOT sem_getOGSofArg_end:descriptor>>;
                 exit OGS[]
                 #);
               checkForGenericUnit:
                 (* Given M := sqrt(A), 
                  * srcQual = A.qual and dstQual = sqrt.outQual
                  * see decl of arg1Qual in abstractSyntaxTree.bet
                  *)
                 (# current,srcQual,dstQual: ^ObjectDescriptor;
                 enter(current[],srcQual[],dstQual[])
                 do (if hasGenericUnit then
                        srcQual[] -> dstQual[];                          
                        srcQual[] 
                          -> (theOI.enclosingObjectDescriptor).arg1Qual[];
                        current.getExpUnit 
                            -> (theOI.enclosingObjectDescriptor).arg1Unit[]
                    if)
                 exit(srcQual[],dstQual[])
                 #);
               checkForArrayPut:
                 (# trace: (#exit false #);
                    theArg,srcQual,dstQual,OGx: ^ObjectDescriptor; org: ^Items; Ix: ^Invocation
                enter(theArg[],dstQual[])
                 do (if (inx = 1) and ((fArgs[inx].origin.encOG->OGx[]).primno = indexedput_prim) then 
                        (if trace then
                            '**** CheckActualArgs:A:'->dumpT; fArgs[inx].dopt->dumpTN; '---\n'->dumptn;
                            (fArgs[inx].origin.encOG).label -> dumpTN;
                            (fArgs[inx].origin.encOG).father.dopt->dumpTN; '===\n'->dumptn;
                            theArg.dopt-> dumpTN; theArg.label -> dumptn;
                            theArg.father.label -> dumpTN;
                            theArg.father.father.label -> dumpTN;
                            theArg.father.father.father.label -> dumpTN;
                        if);
                        theArg.father.father.father[]->Ix[];
                        L:
                          Ix.scanSons
                          (# n: @integer; pre,OIx: ^ObjectInvocation
                          do (*current.dopt -> dumpTN;*)
                             current[] -> OIx[];
                             (*OIx.ATd.dopt->dumpTN;*)
                             (if OIx.ATd[] = (fArgs[inx].origin.encOG).father[] then
                                 (if false then
                                        '!!!! bingo!  pre:'->dumptN; ('pre:',pre[])->putPT;
                                        ('pre.ATd:',pre.ATd[]) -> putPT;
                                 if);
                                 (if (pre[] <> none) and (pre.ATd[] <> none) then
                                     pre.ATd.OG.scanActualArgs
                                     (# i: @integer; OG: ^ObjectSpecification
                                     do (if (i + 1 -> i) = 2 then
                                            (if false then current.label->dumptN; if);
                                            current[] -> OG[]; 
                                            (if false then (OG.super.last->OIx[]).label -> dumpTN; if);
                                            (OG.super.last->OIx[]).ATd.OG[] -> dstQual[];
                                            (if trace then '**** new dstQual:'->dumpTN; dstQual.dopt->putHeadN if);
                                            leave L;
                                 if)#)if);
                                 leave L
                             if);
                             current[] -> pre[];
                    #)if)
                    exit dstQual[]
                    #);
               org: ^Items; DI: ^DataItem
            do <<SLOT sem_ptn_checkActualArgs:descriptor>>;
               OG.IS.scanNonBoundItemArgs
               (#
               do (if (top + 1 -> top) > fArgs.range then 
                      fArgs.range -> fArgs.extend
                  if);
                  currentArg[] -> fArgs[top][];
               #);            
               0 -> inx;
               actualArgs.scanArgs
               (# E: ^ObjectCall; OGS: ^OGsequence; 
                  srcQual,dstQual,OGx: ^ObjectDescriptor; org: ^Items; Ix: ^Invocation
               do inx + 1 -> inx;
                  (if inx > top then 
                      actualArgs[] -> SemanticError
                      (# 
                      do 'More actual parameters:\n\t"' -> msg;
                         actualArgs.doPT -> msg; 
                         '"\n    than formal parameters:\n\t"' -> msg;
                         sig.doPT -> msg; '"' -> msg
                      #)
                   else
                      (current[],inx) -> checkIfSuperIsSig;
                      (* theOI.savedOGS is the OGsequence for theOI calling this pattern *)
                      <<SLOT sem_ptn_argAtInx:descriptor>>;
                      (* After making getOGsequenceOfArg, the prints in
                       * the trace slots may not be meaningful
                       *)
                      theOI.savedOGS[] -> getOGsequenceOfArg -> OGS[];
                      (encOG[],false,OGS[]) 
                        -> fArgs[inx].getVqual 
                        -> (OGS[],dstqual[]); 
                      (current[],dstQual[]) -> checkForArrayPut -> dstQual[];
                      (none,theOI.enclosingObjectDescriptor)
                        -> current.semcheck -> srcQual[];
                      (current[],srcQual[],dstQual[])
                        -> checkForGenericUnit 
                        -> (srcQual[],dstQual[]);
                      <<SLOT semC5:descriptor>>;
                      (if false then
                          '**** before:checkQual:theOI: ' -> puttext;
                          theOI.label -> puttext; ' ' -> put;
                          theOI.dopt -> putline;
                          '**   ptn: ' -> puttext; dopt -> puthead;
                          '**   vEq:' -> puttext; 
                          OG.primNo = vEq_prim -> putboolean;
                          ' rEq:' -> puttext; 
                          OG.primNo = rEq_prim -> putboolean; newline;
                          '**   fArg:'->puttext; fARgs[inx].dopt->putline;
                          '**   aArg:isNone: ' -> puttext; 
                          current.primNo = none_prim ->putBoolean; newline;
                          current.dopt -> putline;
                      if);
                      (theOI[],fArgs[inx][],current[],srcQual[],dstQual[]) 
                        -> (origin[]->org[]).checkForLocalsConflict;
                      (if fArgs[inx].isDesignator then
                          (if traceCheck then
                              '**** fArg:designator:'->dumpTN;
                              fArgs[inx].dopt->dumptn
                          if)
                       else
                          (current[],srcQual[],dstQual[],false) 
                            -> fArgs[inx].checkQual;
                  if)if);
               #);
               L:
                 (if (inx < top)  then
                     (theOI.enclosingObjectDescriptor).IS.scanDecls
                     (# srcQual,dstQual: ^ObjectDescriptor; OGS: ^OGsequence; 
                     do (if currentDcl.isFinalDI then
                            inx + 1 -> inx;
                            (if inx > top then
                                '!!!! Perhaps too many virtual bindings'
                                  ->putline;
                                  sig.doPT
                            if);
                            (* check: as used above 
                             *  theOI.savedOGS[] -> getOGsequenceOfArg -> OGS[];
                             *)
                            (encOG[],false,OGS[]) 
                              -> fArgs[inx].getVqual 
                              -> (OGS[],dstqual[]);          
                            (none,theOI.enclosingObjectDescriptor)
                              -> currentDcl.OG.semcheck -> srcQual[];
                            (* check: checkForGenericUnit as above *)
                            (if traceInvAsDerived then
                                '**** virtualDI:' -> dumpT; 
                                currentDcl.dopt->dumpTN;
                                '**   srcQual:'->dumpTN; 
                                srcQual.dopt -> putHeadN;
                                '**   dstQual:'->dumpTN;                  
                                (if dstQual[] <> none then 
                                    dstQual.dopt -> putHeadN;
                                if);
                                '**   fArgs[inx]:'->dumpTN; 
                                fArgs[inx].dopt -> putHeadN;
                            if);
                          (currentDcl.OG[],srcQual[],dstQual[],false) 
                            -> fArgs[inx].checkQual;
                            (if inx = top then
                                leave L
                     if)if)#);
                     actualArgs[] -> SemanticError
                     (# 
                     do (if actualArgs.noOfSons = 0 then
                            'Arguments must be supplied for pattern: \n     "' 
                              -> msg;
                            sig.doPT -> msg; '"' -> msg
                         else
                            'The pattern: "' -> msg;
                            sig.doPT -> msg;
                            '"has more formal parameters' -> msg;
                            '\n     than listed as ' -> msg;
                            'actual parameters in the argument list "' ->msg;
                            actualArgs.doPT -> msg; '" of\n\n"' -> msg;
                            theOI.dopt -> msg; '"' -> msg;
                 if)#)if)
            #);
          getVqual::
            (#
            do (if traceGetVqual then
                   '**** Pattern:getVqual: ' -> puttext; sig.doPT->puttext;
                   ' :isVirtual:'-> puttext; isVirtual->putBoolean; 
                   ' primNo:'->dumpT; primNo -> putint; newline;
                   OGS.print;
                   (if primNo
                    // indexedGet_prim then
                       '!!!! PTN:getVqual:indexedGet:'->dumpt; dopt -> putheadN;
                    // indexedPut_prim then
                       '!!!! PTN:getVqual:indexedPut:'->dumpt; dopt -> putheadN;
               if)if);
               (if isVirtual then
                   (if traceGetVqual then
                       '**   PTN:getVqual:isVirtual:OGS: ' ->putline; 
                       OGS.print
                   if);
                   this(pattern)[] -> OGS.newFindBinding -> qual[];
                   (if qual.IS.isEmpty then 
                       (qual.super.ATd.asDecl).OG[] -> qual[]
                   if);
                   (if traceGetVqual then
                       '**** PTN:getVqual:gotBinding: ' -> puttext;
                       qual.dopt ->putheadN
                   if)
                else
                   OG[] -> qual[]
               if);
               (if traceGetVqual then
                   '**** PTN:getVqual:end:qual: ' -> puttext;
                   qual.dopt ->putheadN
               if)

            #);
          getQual::
            (# 
            do (if traceGetQual then
                   '*** Pattern:getQual: '-> puttext; sig.doPT -> putline
               if);
               (none,origin[],origin[],true) -> check;
               (if isRecursive then
                   (* For a pattern
                    *    foo(...) -> res: ? foo ...
                    * getQual is called on the foo return value
                    * giving a recursive call of getQual
                    *)
                   (if traceGetQual then
                       '*** isRecursive' -> putline
                   if);
                   OG[] -> qual[];
                   (*false -> isRecursive;*)
                   leave getQual
               if);
               inner;
               (if traceGetQual then
                   'Pattern:getQual:B: "' -> puttext; 
                   sig.doPT -> puttext; '"' ->put; newline
               if);
               true -> isRecursive;
               (* this is probably just a hack 
                * - we need to handle virtuals as in the Beta compiler
                *)
               L:
                 (if qual[] = none then
                     (if isVirtual then
                         (*'*** Virtual: ' -> puttext; dopt -> puttext; 
                          ' on: ' -> puttext; OG.super.on -> putint;
                          ' pn: ' -> puttext; OG.super.pn -> putint; newline;*)
                         OG.getQual -> qual[];
                         (if traceGetQual then
                             'getQual:Virtual: ' -> puttext; 
                             qual.doPT -> puthead;
                             OG.doPT -> puthead
                         if)
                      else
                         (if traceGetQual then
                             'Pattern:getQual:C: ' -> puttext; 
                             sig.dopt -> putline;
                         if);
                         OG.IS.scanAllItemDecls
                         (# DI: ^DataItem
                         do (if currentDcl.isOutArg then
                                (if currentDcl.isDataItem then
                                    (currentDcl[]->DI[]).getQual -> qual[];
                                    leave L;
                                if)
                            if)
                         #);                       
                         OG[] -> qual[];
                 if)if);
               false -> isRecursive;
               (if traceGetQual then
                   'Pattern:getQual:D: "\n' -> puttext; 
                   (if qual[] <> none then 
                       qual.doPT -> puttext
                    else 'none'->puttext
                   if);
                   '"' -> put; newline
               if)
            #);
          semCheck::
            (# lastSuper: ^Exp; DI: ^Decl
            do (if false then 
                   '**** Pattern:semCheck: '->puttext; sig.dopt -> putline;
                   OG.scanSuperSons(# do current.label -> dumpT #);
                   '---'->dumpTN;
               if);
               (if ((OG.super.last -> lastSuper[]).args[] <> none) and
                       (lastSuper.args.length = 0) then
                   true -> lastSuper.noArgsCheck
               if);
               (if ptnKind // FinalPtn // FurtherPtn then
                   (if vDiDcl[] <> none then
                       (if traceInvAsDerived then
                           '**** Pattern:semChek:virtual data-item:' -> dumpT;
                           dopt -> dumpTN;
                       if);
                       leave semCheck
                   if);
                   (if false then
                       '**** PTN:semCheck:binding: ' -> puttext;
                       dopt -> putline;
                       vDcl.dopt -> putline;
                   if);
                   (if vDcl.theSig.isSig and (theSig[]->vDcl.thesig.equal) then
                       (if true then
                           '**** Sub has same sig as super' -> putline;
                           doPT -> putline;
                       if);
                       none -> OG.super.ATd[]; none -> OG.IS.superDesc[]
                    else
                       (if OG.getQual -> (vDcl.OG.getQual).inSuper then
                           (* '**   qual ok'->putline*)
                        else
                           this(Pattern)[] -> SemanticError
                           (#
                           do 'The binding: \n"' -> msg; OG.doPT -> msg;
                              '"\n****of the virtual pattern:\n\n "' -> msg; 
                              vDcl.doPT -> msg; '"\n\nmust be '->msg;
                              'a subpattern of the virtual pattern' -> msg
                           #);
               if)if)if);
               (* this dont seem to survive super.semcheck - true -> done 
                * will probably not work
               (if (getReturnDecl -> DI[]) <> none then
                   '**** ptn:semCheck:rtn:'->dumpt; DI.dopt -> dumpTN;
                   DI.getQual -> eOG[]
               if);*)
            #)
       #);
     Designator::<
       (# semCheck:: (# do #);
          getVqual:: 
            (# do (encOG[],false,OGS[]) -> OG.getVqual -> (OGS[],qual[]) #);
       #);
     AssignmentStatement::<
       (# semCheck::
            (# trace: (#exit false #);
               getReceiverOrigin:
                 (# inv: ^Invocation; receiver,E: ^exp; 
                    org: ^Items; notInThis: @Boolean
                 enter inv[]
                 do inv.scanSons(#do E[] -> receiver[]; current[] -> E[] #);
                    (if receiver[] = none then
                        E.origin[] -> org[];
                        (for i: E.on repeat org.origin[] -> org[] for);
                        E.on > 0 -> notInThis
                     else
                        receiver.theDesc -> org[]; true -> notInThis
                    if);
                    (if trace and org.isImmutable then
                        '**   E: ' -> dumpT; E.dopt->dumpTN;
                        '**   org: ' -> dumpTN; org.dopt->dumpTN
                    if)
                 exit(org[],notInThis)
                 #);               
               checkIfReceiverInImmutable:
                 (# org: ^Items; notInThis: @Boolean
                 do (if trace then
                        '**** checkIfReceiverInImmutable:'->dumpT;
                        dopt -> putline;
                    if);
                    left[] -> getReceiverOrigin -> (org[],notInThis);
                    (if org.isImmutable and notInThis then
                        (* receiver = X, org = X.origin, declared as in: 
                         *  MyPtn: ...
                         *    %immutable
                         *    X: var integer
                         *    foo:
                         *       X := 117 -- illegal, X.on > 0, not in MyPtn
                         *    X := 118 -- legal X.on = 0 => in MyPtn
                         *   R: obj MyPtn
                         *   R.X := 119 -- illegal, not in MyPtn 
                         *)
                        this(AssignmentStatement)[] -> Warning
                        (#
                        do 'The data-item "' -> msg; left.dopt -> msg;
                           '" is in an immutable object and cannot be assigned'
                             -> msg
                    #)if)
                 exit org[]
                 #);
               checkAssignable:
                 (* check that left can be assigned to right *)
                 (# receiver,receiverX: ^Exp; OGSx: ^OGsequence;
                    srcQual, dstQual: ^ObjectDescriptor
                 do left.last -> receiver[];
                    receiver.getActualReceiver -> receiverX[];
                    (* getActualReceiver is left over from similar
                     * code in OI:semcheck - may be eliminated
                     *)
                    (if receiver[] <> receiverX[] then
                        '!!!!  receiver[] <> receiverX[]:'-> dumpT; 
                        dopt->dumpTN
                    if);
                    (receiver[](*none*),EnclosingOGwithIS)
                      -> right.semCheck 
                      -> srcQual[];

                    (encOG[],true,none)
                    (******* perhaps not always isFirst = true here ? *)
                      -> receiver.getVqual 
                      -> (OGSx[],dstQual[]);
                    
                    (right[],srcQual[],dstQual[],true) -> (receiver.ATd.asDecl).checkQual;
                 exit(srcQual[],dstQual[])
                 #);
               checkLeftNotConstVal:
                  (* Check that we do not have an assigment C.X := exp 
                   * where C is a constant value object declared like C: val SomeValueType 
                   *)
                  (# D: ^DataItem;
                  do left.scanSons
                     (# rec,OI: ^ ObjectInvocation
                     do (if current.isObjectInvocation then
                            current[] -> OI[];
                            (if (rec[] <> none) and rec.ATd.IsDataItem then
                                rec.ATd[] -> D[];
                                (if D.isConst and D.isValue then 
                                    (if trx then
                                        '**** Assign:checkLeftIsNotConst:'->dumptn; 
                                        D.dopt -> putheadN;
                                        OI.dopt -> dumptn;
                                    if);
                                    this(AssignmentStatement)[] -> semanticError
                                    (#
                                    do 'The receiver: "'->msg; rec.doPT->msg; 
                                       '" is a constant value object declared as:\n     "'->msg;
                                       rec.ATd.dopt->msg; 
                                       '"\n     It is not possible '->msg;
                                       'to assign to a variable in a constant value object.\n'->msg;
                                       '     In this case: "'->msg; OI.doPT->msg; '"'->msg
                                    #)
                              if)if)if);
                        OI[] -> rec[];
                     #)#);
               org: ^Items; srcQual,dstQual: ^ObjectDescriptor
            do (if traceGetVqual then
                   '**** AssignStatement:semCheck: '-> puttext; dopt->putline
               if);
               checkIfReceiverInImmutable -> org[];
               checkAssignable -> (srcQual[],dstQual[]);
               (this(AssignmentStatement)[],left.last,right.super.ATd.asDecl
               ,srcQual[],dstQual[]) 
                 -> org.checkForLocalsConflict;
               checkLeftNotConstVal;
               enclosingOGwithIS -> encOG[] -> eOG[];
               srcQual[] -> theSrcQual[];
               true -> done
            #);
          checkWriter:< BooleanValue 
             (* returns true if this(node) modifies the state of ? *)
             (# OD: ^ObjectDescriptor
             enter OD[]
             do (if trx then
                    '**** Assign:checkWriter: ' -> dumpT; left.dopt->dumpTN;
                    '**   origin:'->dumptn;
                    (left.last).ATd.origin.dopt -> putheadN;
                    '**   OD:'->dumpTN; OD.dopt->putHeadN;
                if);
                (left.last).ATd.origin.encOG[] = OD[] -> value
             #);
          getVqual::
            (#
            do (if false then
                   '**** assignmentStatement:getVqual: '->puttext; 
                   dopt->putheadN
               if);
               
            #);
          getQual::
            (#
            do (if false then
                   '**** assignmentStatement:getQual: '->puttext; dopt->putheadN
               if);
            #);
          theSrcQual: ^ObjectDescriptor
       #);
     ObjectCall::<
       (# semCheck::
            (#
            do (if traceUnit then
                   '**** ObjectCall:semCheck: ' -> puttext; dopt -> puthead;
               if);
               (rec[],encOG[]) -> super.semCheck -> eOG[];
               true -> done
            #);
          getVqual::
            (#
            do (if traceGetVqual then
                   '**** ObjectCall:getVqual: ' -> puttext; dopt -> puthead;
               if);
               (if false and (savedqual[] <> none) then
                   (if traceGetVqual then
                       '**** ObjectCall:getVqual:use:theQual:'->putline;
                       savedQual.dopt -> puthead
                   if);
                   savedQual[] -> qual[];
                else
                   (encOG[],false,OGS[]) -> super.getVqual -> (OGS[],qual[]);
               if)
            #);
          getQual::
            (#
            do (if traceGetQual then 
                   'ObjCall:getQual: ' -> puttext; doPT -> putline if);
               super.getQual -> qual[];
            #);
       #);
     ObjectDescriptor::<
       (# semcheck::
            (# superHasInner:
                 (#
                 do (if super.theDesc <> none then
                        (if false then
                            '**** superDesc:'->dumpT;
                            (super.theDesc).noOfInner -> putint; ' ' -> put;
                            IS.doHasCode -> putboolean; ' ' -> put;
                            (super.theDesc).doPT->putHeadN;
                        if);
                        (if IS.doHasCode 
                            and ((super.theDesc).noOfInner = 0) 
                            and ((super.theDesc).encOG.primNo <> value_prim)
                            and ((super.theDesc).encOG.primNo <> object_prim) then
                            this(ObjectDescriptor)[] -> semanticError
                            (#
                            do 'The superpattern "' -> msg;
                               super.dopt -> msg;
                               '" of this descriptor ' -> msg;
                               'has no inner' -> msg;
                               (super.theDesc).dopt -> putheadN
                        #)if)
                    if);
                 #);
               D: ^Decl
            do (if traceGetVqual then
                   '**** OG:semCheck:'->puttext; doPT -> putheadn;
                   (if true then
                       '**   encOG: ' -> puttext;
                       (if encOG[] <> none then
                           encOG.doPT -> putHeadn
                        else
                           'none' -> putline
               if)if)if);
               (if false then
                   (rec[],encOG[]) -> super.semCheck -> eOG[];
                   ('**** OG:semCheck:super:eOG',eOG[]) -> display;
                   (if not IS.isEmpty then 
                       (rec[],this(ObjectDescriptor)[]) -> IS.semCheck -> eOG[];
                   if);
                else
                   (rec[],encOG[]) -> super.semCheck -> eOG[];
                   (if traceGetQual then
                       ('**** OG:semCheck:super:eOG',eOG[]) -> display;
                       '**   OG:semCheck:items:'->puttext; dopt -> putheadn;
                       (if encOG[] <> none then
                           '**   encOG:'->puttext; encOG.dopt -> putheadn;
                       if);
                       (if eOG[] <> none then
                           '**   eOG:'->puttext; eOG.dopt -> puthead;
                   if)if);
                   (if not IS.isEmpty then 
                       (rec[],encOG[]) -> IS.semCheck -> eOG[];
                   if); 
                   (if traceGetVqual then
                       '**** OG:semcheck:IS not empty:eOG: ' -> putline;
                       eOG.dopt -> putheadn;
                   if);
                   superHasInner;
                   (if (primNo <> indexedGet_prim) and ((getReturnDecl -> D[]) <> none) then
                       (if traceGetVqual then
                           '**** OG:returnDecl: ' -> puttext; D.dopt -> putline
                       if);
                       D.getQual -> eOG[]
                   else
                       (if (primNo = indexedGet_prim) then
                           (if false then
                               '!!!! indexed_get'->dumpT; dopt -> dumptn;
                               ('rec:',rec[])->putPT;
                              ('rtnDcl:',D[])->putPT
               if)if)if)if);
               true -> done;
            #);
          checkNoSingleObj::
            (#
            do (if IS.isEmpty then
                   (*'**** OG:checkNoSingleObj: ' -> puttext; dopt->puthead;*)
                   super.CheckNoSingleObj
               if)
            #);
          getVqual::
            (#
            do (if traceGetVqual then
                   '**** ObjectDescriptor:getVqual: ' -> puttext; 
                   dopt -> putheadN;
                   '**   hasVirtualArgs:'->dumpT; hasVirtualArgs->putboolean;
                   newline
               if);
               (if IS.isEmpty (*and not hasVirtualArgs*) then
                   (encOG[],false,OGS[]) -> super.getVqual -> (OGS[],qual[]);
                else
                   this(ObjectDescriptor)[] -> qual[]
               if)
            #);
          getQual::
            (# 
            do (if traceGetQual then
                   '*** ObjectDescriptor:getQual:primNo: '->puttext; 
                   primNo -> putint; ' '-> put; 
                   IS.primNo -> putint; ' '-> put; 
                   (if super.ATd[] <> none then
                       super.Atd.primNo -> putint; ' '-> put; 
                   if);
                   ':isPrimitive: ' -> puttext; isPrimitive -> putboolean;
                   ':' -> put; doPT -> putline
               if);
               (* Should only be called for singular OGs
                * If part of pattern decl, argScope may be wrong
                *)
               (none,origin[],origin[],true) -> check;
               (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   L:  IS.scanAllItemDecls
                     (# DI: ^DataItem
                     do (if currentDcl.isOutArg then
                            (if currentDcl.isDAtaItem then
                                (currentDcl[] -> DI[]).getQual -> qual[];
                                leave L
                            if)
                        if)
                     #);
                   (if qual[] = none then
                       this(ObjectDescriptor)[] -> qual[]
                   if)
               if);
               (*'qual:' -> putline; qual.dopT -> putline;*)
            #);
          getDecl::
            (#
            do (if IS.isEmpty then
                   super.ATd[] -> dcl[]
                else
                   (if father## <= Decl## then
                       father[] -> dcl[]
                    else
                       '**** getDecl:singular:not handled:'->puttext;
                       dopt ->putheadN
               if)if)
            #);      
                beingComputed: @boolean;
          getMethodKind::
             (# handleAssign: BooleanValue
                  (# asg: ^AssignmentStatement 
                  enter asg[]
                  do  (if origin.encOG[] -> asg.checkWriter then 
                          (if trx then '**** handleAssign:isWriter!'->dumptn; if);
                          methodWriter -> methodKind;
                          true -> value
                      if)
                  #);
                handleOI: BooleanValue
                  (# OI: ^ObjectInvocation
                  enter OI[]
                  do (if (OI.ATd[] <> none) and (OI.ATd.OG.primno = 0) and OI.ATd.isPattern then
                         (if trx then '**** handleOI:'->dumpt; OI.dopt->dumpT if);
                         (if OI.ATd.OG.getMethodKind = methodWriter then (* Avoid recursion here *)
                             methodWriter -> methodKind;
                             true -> value;
                             (if trx then 'isWriter'->dumptn; if)
                         if)
                     if)
                  #);
             do (if (methodKind = 0) and not beingComputed then
                    (if trx then 
                        '**** compute methodKind' -> dumptn; dopt->putheadN;
                        '**   traverse:'->dumpTN;
                    if);
                    true -> beingComputed;
                    scan:
                       scanSons
                       (#
                       do current.traverse
                          (# pred::
                             (# 
                             do theNode.isObjectInvocation or theNode.isAssign -> value;
                                (if true 
                                 // theNode.isAssign then
                                    (if theNode[]->handleAssign then true-> done; leave scan if)
                                 // theNode.isObjectInvocation then
                                    (if theNode[]->handleOI then true -> done; leave scan if)
                                if)
                       #)#)#);
                    false -> beingComputed
                if);
                methodKind -> value ;
             #)
       #);
     Items::<
       (# checkInterfaceRestrictions::
            (* This decl: must be a pattern (or virtual)
             *    foo: entry(# do ... #)
             * where entry in interface.rQual
             * We also need to handle several levels
             *    M0: (# foo: Q(# ... #); ... #)
             *    M1: M0(# [interface[E]] E: (# ... #); ... #)
             *    M2: M1(# [interface[F]] F: (# ... #); ... #)
             *    M3: M2(# ... #)
             * Do M1/M2-restrictions apply to M0?
             * M2 further restricts subpatterns ...
             * Methods in M2 are restricted by M1 but not M2
             * For x: ^M3
             *   x.bar -- if bar in M3 then all restrictions
             *                   in M2, M1 restrictions
             *            else no restrictions
             *            if virtual, then restrictions at point of
             *            original declaration apply
             *            Probably different if argument restrictions 
             *            are added
             * THE ABOVE IS NOT IMPLEMENTED
             *)
            (# 
            do (if false then
                   '**** checkInterface: ' -> puttext; 
                   (if sig[] <> none then sig.dopt -> putline else newline if);
               if);
               (if superDesc[] <> none then
                   (if true -> hasInterfaceRestrictions then
                       (if false then
                           '**** Interface restrictions:\n' -> puttext;
                       if);
                       scanDecls
                       (#
                       do (if currentDcl.isPattern then
                              L:
                                (#
                                do scanInterface
                                   (# 
                                   do (if false then
                                          '**** check:\n' -> puttext;
                                          currentDcl.dopt -> puttext;
                                          '\n**   mustBeSubOf:\n' 
                                            -> puttext;
                                          current.dopt -> putline;
                                          current.ATd.OG.dopt -> puthead
                                      if);
                                      (if currentDcl.OG[] 
                                            -> (current.ATd.asDecl).OG.inSuper then
                                          leave L
                                   if)#);
                                   (if true then
                                       acc_private->currentDcl.accessLevel;
                                    else
                                       currentDcl[] -> warning
                                       (#
                                       do 'The pattern: "' -> msg;
                                          currentDcl.sig.dopt -> msg;
                                          '" must be a subppattern of: '
                                            -> msg;
                                          scanInterface
                                          (# i: @integer
                                          do (if (i +1 -> i) > 1 then 
                                                 ' or ' -> msg 
                                             if);
                                             '"' -> msg;
                                             current.dopt ->msg; '"' -> msg
               #)#)if)#)if)#)if)if)
            #);  
          semCheck::
            (# checkArgumentRestrictions:
                 (# nl: @boolean
                 do scanAllDecls
                    (# constraintsOK: @boolean
                    do (if currentDcl.isInArg then
                           true -> constraintsOK;  
                           (if newBasicProp.hasArguments then
                               (*'**** new prop:arguments: ' -> puttext;*)
                               (*newBasicProp.arguments.doPT -> putline;*)
                               L: newBasicProp.scanArguments
                                 (# 
                                 do current.scanSons
                                    (# OI: ^ObjectInvocation
                                    do current[] -> OI[];
                                       (if false then
                                           '\n**** checkArg: ' -> puttext; 
                                           currentDcl.dopt -> puttext;
                                           ' is: ' -> puttext; 
                                           current.dopt -> putline; 
                                       if);
                                       false -> constraintsOK;
                                       (if true
                                        // 'immutable' -> OI.ptnId.T.equalNCS then
                                           (if false then
                                               '** isImmutable?' -> puttext;
                                           if);
                                           (if currentDcl.isImmutable then
                                               (if false then
                                                   'Yes:immutable: ' -> puttext; 
                                                   currentDcl.doPT -> putline;
                                               if);
                                               true -> constraintsOK;
                                               leave L
                                            else
                                               (* need arguments[value] *)
                                               (if currentDcl.OG.isValueObj then
                                                   (if false then
                                                       'Yes:immutable value: '
                                                         -> puttext;
                                                       currentDcl.doPT -> putline;
                                                   if);
                                                   true -> constraintsOK;
                                                   leave L
                                               if)
                                           if);
                                        // 'unique' -> OI.ptnId.T.equalNCS then
                                           (if currentDcl.OG.IS.isUnique then
                                               true -> constraintsOK;
                                               leave L
                                           if)
                                        else
                                           (if false then
                                               '**  match: %argument:\n'
                                                 -> puttext;
                                               OI.ATd.OG.dopt ->putline;
                                               '**  with:dcl:\n' ->puttext;
                                               (currentDcl.theDesc).dopt->putline;
                                           if);
                                           (if (currentDcl.theDesc).father[]
                                                 -> (OI.ATd.asDecl).OG.inSuper
                                                 -> constraintsOk then
                                               leave L
                                           if)
                                           (* not yet complete! *)
                                    if)#);
                                 #);
                               (if not constraintsOK then
                                   currentDcl[] -> Warning
                                   (#
                                   do 'Constraints not satisfied in: "' -> msg;
                                      currentDcl.dopt -> msg;
                                      '"\n     must be one of: ' -> msg; 
                                      newBasicProp.scanArguments
                                      (# i: @integer
                                      do (if (i + 1 -> i) > 1 then ' or ' -> msg if);
                                         current.doPT -> qmsg; 
                                      #);
                                      '\n'->msg
                                   #)
                               if);
                       if)if)
                    #);
                 #);               
               checkImmutability:
                 (#
                 do (if newBasicProp.immutable and
                        (super.ATd[] <> none) and
                        not superDesc.isImmutable then 
                        this(items)[] -> semanticError
                        (#
                        do 'An ObjectDescriptor cannot be marked "immutable"'
                             -> msg;
                           '\n     unless its superpattern is immutable'
                             -> msg
                        #)
                    if)
                 #)
            do (if traceCheck then '**** Items:semCheck: ' -> putline if);
               this(Items).encOG[] -> encOG[] -> eOG[]; 
               (* perhaps a bad idea to use the same name here, encOG!? *)
               none -> rec[];
               checkArgumentRestrictions;
               (*checkInterfaceRestrictions; moved to checker:Items:check *)
               checkImmutability;
               scanSons
                   (# 
                   do (none,eOG[]) -> current.semCheck;
                      current[] -> rec[]
                   #);
               scanSons(#do current.checkNoSingleObj #);
               true -> done
            #);
          hasInterfaceRestrictions: BooleanValue
            (# isFirst: @boolean
            enter isFirst
            do (if superDesc[] <> none then
                   false -> superDesc.hasInterfaceRestrictions -> value
               if);
               (if not value and not isFirst then
                   (if not (newBasicProp.hasIFR -> value) then
               if)if)
            #);
          scanInterface:
            (# current: ^Lexem(*Property*)
            do (if superDesc[] <> none then
                   &superDesc.scanInterface
                   (#
                   do current[] -> this(scanInterface).current[];
                      inner scanInterface
                   #);
                   (if newBasicProp.hasIFR then
                       newBasicProp.interface.args.scanSons
                       (# INV: ^Invocation; N: ^Name; OI: ^ObjectInvocation
                       do (if false then
                              '** arg: ' -> puttext; current.dopt -> putline;
                          if);
                          current.scanSons
                          (#do (if false then current.label -> putline; if);
                          (if current## = ObjectInvocation## then
                              current[] -> OI[]; 
                              OI.ATd.asDecl -> OI.ptnId.ATd[];
                              OI.ptnId[] -> this(scanInterface).current[];
                              inner scanInterface
                          if)#)
                       #);
                    if)
            if)#);
          scanLocals:
            (# current: ^ObjectDescriptor; org: ^Items
            do (*'\n*** scanLocals:'->putline; dopt -> puthead;*)
               (if (superDesc[] <> none ) 
                   and (superDesc[] <> objectDecl.theDesc) then 
                   &superDesc.scanLocals
                   (#
                   do
                      current[] -> this(scanLocals).current[]; 
                      inner scanLocals
               #);if);
               (if newBasicProp.locals[] <> none then
                   newBasicProp.locals.args.scanSons
                   (# inv: ^Invocation
                   do (if false then
                          '** local: ' -> puttext; 
                          current.label -> puttext;
                          ' ' -> put; current.dopt -> putline;
                      if);
                      ((current[]->INV[]).ATd.asDecl).OG[] 
                        -> this(scanLocals).current[];
                      inner scanLocals
                   #)                   
               if);
               (if (origin[]->org[]) <> none then
                   &org.scanLocals
                   (#
                   do current[] -> this(scanLocals).current[]; 
                      inner scanLocals
                   #)
               if)
            #);

          checkForLocalsConflict:
            (* Check possible violation of %locals P1, P2, ...
             * References to Pi-objects can only be hold in data-items in
             * this(Items); Is not complete; see the paper 
             *    Subpattern Restriction and the Aliasing Problem
             * As an example: demo/LocalsEx.xbeta
             * Assignments marked by ??? are probaly not handled correct
             *)
            (# thisS,dst,src: ^Node;
               (* if thisS: asgStmt, then dst = thisS.left, src = thisS.right
                * if thisS: ObjectInvocation, dst = fArgs[inx], 
                *    src = current = actualArgs[inx]
                *)
               srcQual,dstQual: ^ObjectDescriptor;
            enter(thisS[],dst[],src[],srcQual[],dstQual[])
            do (*'**** checkForLocalsConflict: '-> dumpT; dopt->putheadN;*)
               scanLocals
               (# OBS:
                    (#
                    do thisS(*actualArgs*)[] -> warning
                       (#
                       do 'Locals conflict:\n\t' -> msg;
                          src.dopt -> msg;
                          '\n  cannot be assigned to:\n\t' -> msg;
                          dst.dopt -> msg
                       #)
                    #)
               do (if true
                   // srcQual[] -> current.inSuper then
                      (if not (dstQual[] -> current.inSuper) then OBS if)
                   // dstQual[] -> current.inSuper then
                      (if not (srcQual[] -> current.inSuper) then OBS if)
               if)#)
            #);          
       #);
     Invocation::<
       (# semcheck::
            (# markPossibleIsObj:
                 (* Check if an OGs in invocations should be marked as isObj
                  * For:
                  *   R.foo -- qualification of R isObj
                  *   R := foo -- foo is object if a ref is returned
                  * In both cases, R.qual and any sub should be marked isObj
                  * We may have to make isObj a pattern that check if any 
                  * super isObj
                  *)
                 (# rec: ^vNode; OI: ^ObjectInvocation
                 enter rec[]
                 do (if (rec[] <> none) and (rec## = ObjectInvocation##) then
                        rec[] -> OI[];
                        (if false then
                            '**** isObjOrNot:'-> dumpTN;
                            '**   rec:'->dumpT; rec.dopt -> dumpTN;
                            (*'**   current:'->dumpT; 
                             * current.dopt -> dumptn;*)
                            '**   ATd:'->dumpT; OI.ATd.dopt -> puthead;
                            ' isObj:'->dumpT; OI.ATd.OG.isObj -> dumpB;
                            '\n**   qual.isObj: '->dumpT; 
                            (OI.getqual).isObj -> dumpB; dumpNL;
                            (OI.getQual).dopt -> dumpT;
                                dumpNL
                        if);
                      true -> (OI.getqual).isObj 
                  if)
                 #);
            checkOIwriterOnVal:
                 (# rec,OI: ^ObjectInvocation; D: ^DataItem
                 enter(rec[],OI[])
                 do (if rec.ATd.isDataItem then
                       rec.ATd[] -> D[];
                       (if D.isConst and D.isValue then
                           (if false then
                              '**** checkOIwriterOnVal:rec:'->dumpT; rec.dopt->dumpT;
                              'OI:'->dumpT; OI.dopt->dumpTN;
                               D.isConst -> putBoolean; ' ' ->put; D.isValue->putBoolean; ' ' ->put;
                               OI.ATd.isPattern -> putBoolean; newline;
                              'rec:'->dumpT; rec.ATd.dopt -> dumptn;
                              'OI.ATd:'->dumpTN; OI.ATd.dopt ->dumptn
                           if);
                           (if OI.ATd.isPattern then
                               (if OI.ATd.OG.getMethodKind = methodWriter then
                                   this(Invocation)[] -> semanticError
                                   (#
                                   do 'The receiver: "'->msg; rec.doPT->msg; '"'->msg;
                                      ' is a constant value object declared as:\n     "'->msg; 
                                      rec.ATd.dopt->msg;
                                      '"\n     The pattern: "'->msg;  OI.dopt->msg; '"'->msg; 
                                      ' may change the state of the receiver'->msg
                #)if)if)if)if)#);
               noneMet: @Boolean
            do (if trx or traceGetVqual then
                   '**** Invocation:semCheck: '-> puttext; dopt -> putline;
                   '**   encOG:' -> puttext; encOG[] -> putDoPT; newline
               if);
               scanSons
                  (# recx,OI: ^ObjectInvocation
                  do (if current.isObjectInvocation then
                         current[] -> OI[];
                        (if recx[] <> none then (recx[],OI[]) -> checkOIwriterOnVal if);
                        OI[] -> recx[]
                    if)
                  #);
               scanSons
               (# OI: ^ObjectInvocation
               do (if not isLast and current.isObjectInvocation then
                      current[] -> OI[];
                      (if OI.ATd[] = none then 
                          OI.dopt -> dumpTN;
                          'OI.ATd is none'->dumptn
                      if);
                      (if OI.ATd.asDecl = none then 
                          'OI.ATd.asDecl is none'->dumptn
                      if);
                      (if (OI.ATd.asDecl).OG.primNo = none_prim then
                          true -> noneMet;
                      if)
                   else
                      (if noneMet then
                          current[] -> OI[]; (* is this always an OI? *)
                          (if (OI.ATd.asDecl).OG.primNo <> rEq_prim then
                              this(Invocation)[] -> semanticError
                              (#
                              do '"none" in "' -> msg; dopt -> msg; '"'  -> msg;
                                 ' cannot access an attribute' ->  msg
                  #)if)if)if);
                  rec[] -> markPossibleIsObj;
                  (rec[],encOG[]) -> current.semCheck -> eOG[];
                  current[] -> rec[];
               #);
               true -> done
               (*(if showUnits then printUnits if);*)
            #);
          checkNoSingleObj::
            (#
            do (if noOfSons = 1 then
                   (* '**** INV:checkNoSingleObj: '->puttext; 
                    * noOfSons -> putint; ' ' -> put;
                    * dopt -> putline;
                    *)
                   scanSons(#do current.CheckNoSingleObj #)
               if)
            #);
          getVqual::
            (# OI: ^ObjectInvocation; OGx: ^ObjectDescriptor; org: ^Items
            do (if not isChecked then
                   (if traceCheck then
                       '**** INV:getVqual:force:check:beingChecked:'->dumpT;
                       beingChecked -> putBoolean; newline;
                   if);
                   (none,origin[],none,true) -> check
               if);
               (if traceGetVqual then
                   '**** INV:getVqual:'->puttext; dopt -> dumpT;
                   'in:'->dumpT; father.father.dopt->dumpT;
                   'isChecked:'->dumpT; isChecked->putBoolean; newline;
                   '**   OGs: ' -> puttext;
                   (if OGs[] <> none then OGs.print else 'none'->putline if);
                   last <> none -> putboolean; ','->put;
                   ('last.ATd.OG:',((last).atd.asDecl).OG[])->putPT
               if);
               (if ((last).ATd.asDecl).OG.primNo = this_prim then
                   (if false then
                       '**** INV:got this(T): '->puttext;  dopt -> putheadN;
                       '**   origin: '-> putline; origin.dopt -> putline;
                       OGs.print;
                       last -> OI[];
                       OI.args.scanSons
                       (# i: @ integer
                       do '**   arg:'->puttext; current.dopt -> putline;
                          (if (i + 1 -> i) = 3 then
                              (if true then
                                  current[] -> OGx[];
                                  '**   arg3:label: '->puttext;
                                  current.label -> puttext;
                                  ' arg3: '->puttext; current.dopt -> puttext;
                                  ' arg3.super.on: '->puttext;
                                  OGx.super.on -> putint; newline;
                                  origin[] -> org[];
                                  (for i: OGx.super.on - 1 repeat
                                       org.origin[] -> org[]
                                  for);
                                  '**   arg3.origin:super.on:'->putline;
                                  org.dopt -> putheadN
                              if);
                       if)#);
                       '**** OGs:start:'->putline;
                       (OGS.getOGstart).dopt -> puthead;
                   if);
                   OGs.getOGstart -> OGx[];
                   OGx.origin[] -> org[];
                   (if false then
                       '**    org:A:'->putline; org.dopt -> putheadN;
                   if);
                   (for i: OGx.super.on - 1 repeat
                        org.origin[] -> org[];
                        (if false then
                            '**    org:B:'->putline; org.dopt -> putheadN;
                            
                   if)                   for);
                   (if false then  
                       '**    org:C:'->putline;
                       org.dopt -> putheadN; org.primNo -> putint; newline;
                   if);
                   org.encOG[] -> qual[];
                   (if false then 
                       '**    qual:'->putline; qual.dopt -> putheadN;
                   if);
                   leave getVqual
               if);
               encOG[] -> qual[];
               scanSons
               (#
               do (qual[],not isFirst,OGS[]) 
                    -> current.getVqual -> (OGS[],qual[]);
               #);
               (if traceGetVqual then
                   'INV:getVqual:end:'->dumpT;dopt -> dumpTN;
                   ('qual',qual[])->putPT;
                   OGS.print
               if)
            #);
          getQual::
            (# E: ^Exp; 
            do (if false then 'IV:getQual:' -> puttext; doPT -> putline if);
               scanSons(# do current[] -> E[] #);
               ('Invocation:getQual:E:',E[]) -> display;
               (if E[] <> none then
                   E.getQual -> qual[]
                else
                   '**   IV:getQual:E:none:'->dumpT;
               if);
            #);
          getActualReceiver::
            (#
            do (last).getActualReceiver -> rec[]
            #)
       #);

     ObjectInvocation::<
       (# semCheck::<
            (# receiver: ^Exp; ptn: ^Pattern; org: ^Items; 
               srcQual, dstQual,qual: ^ObjectDescriptor; 
               U: ^text;N: ^Node; OGS: ^OGsequence; (*P: ^OG path; *)
               MI: ^ModuleItem; singleUnitArgQual: ^ObjectDescriptor;
               OI: ^ObjectInvocation
            do (* rec = none if first OI in Invocation *) 
               <<SLOT sem_OI_semCheck_T1:descriptor>>;   
               (if ATd[] = none then
                   '**** ATd is none: '->puttext;  dopt -> putheadN;
               if);
               (if (ATd.asDecl).primno
                // inner_prim // restart_prim // leave_prim 
               (* // indexedPut_prim *) then
                   true -> noArgsCheck
                   (* This should be reconsidered. In MapLib we have
                    *   forAll: ... return := innerBool
                    * innerBool is sub of inner which has an argument
                    * that is not supplied here! Is this an error?
                    *)
                // this_prim then
                   args.scanArgs
                   (#
                   do current.getQual -> srcQual[] -> encOG[] ->eOG[];
                      true -> done
                   #)
                // indexedGet_prim then
                   (if trx then
                       '**   OI:semCheck:indexGet:'->dumpT; dopt->dumpTN;
                       ('ATd',Atd[])->putPT;
                       ('rec',rec[])->putPT;
                       (if (rec[] <> none) and rec.isObjectInvocation then 
                           rec[]->OI[];
                           ('rec.ATd',OI.ATd[])->putPT
                           (#
                           do (if (OI.ATd.OG.super.last).args.noOfArgs = 2 then
                                  ('args',(OI.ATd.OG.super.last).args[])->putPT;
                                  ((OI.ATd.OG.super.last).args.getSecondArg).dopt
                                    ->dumpTN;
                              if)
                   #)if)if);
                   (if (rec[] <> none) and rec.isObjectInvocation then 
                       rec[]->OI[];
                       (if (OI.ATd.OG.super.last).args.noOfArgs = 2 then
                          ((OI.ATd.OG.super.last).args.getSecondArg).getQual
                             -> srcQual[] -> encOG[] -> eOG[];
                        else
                           integerDecl.OG[] -> srcQual[] -> encOG[] -> eOG[];
                       if)
                    else
                       integerDecl.OG[] -> srcQual[] -> encOG[] -> eOG[];
                   if);
                   (if false then
                       ('indexedGet.srcQual',srcQual[]) -> putPT;
                   if);
                   true -> done
                else
                   (if (1 -> ptnId.T.inxGet) = '#' then
                       (* clean-up '#PTN: '->puttext; 
                        * ptnId.T[] -> putline*)
                    else
                       (if not noArgsCheck then
                           (args[],encOG[],this(ObjectInvocation)[]) 
                             -> (ATd.asDecl).checkActualArgs
                             -> singleUnitArgQual[];
                           (if (singleUnitArgQual[] <> none) then
                               '**** OI: '->puttext; dopt -> puthead;
                               '**   hasSingleUnitArg:Qual:'->puttext;
                               singleUnitArgQual.doPT -> putline
                           if);
                           true -> done
                   if)if);
                   (if (origin[] <> none) and not ATd.isDesignator then
                       (if savedQual[] <> none then
                           (* is theQual always correct for declarations?*)
                           savedQual[] -> qual[]
                        else
                           '\n!!!!! no saved qual:'->puttext;
                           dopt -> putheadN
                       if);
                       (if (singleUnitArgQual[] <> none) and 
                           (qual[] <> singleUnitArgQual[]) then
                           '****OI:changedQualToSingleUnitArgQual:'
                             -> putline;
                           singleUnitArgQual.doPT -> putline;
                           singleUnitArgQual[] -> qual[]
                       if);
                       qual[] -> encOG[] -> eOG[];
               if)if);
               inner semcheck
            #);
          checkNoSingleObj::
            (# checkATdIsPtn:
                 (#
                 do (if not (ATd.asDecl).isPattern and (ATd## <> StdBetaPtn##) then
                        this(ObjectInvocation)[] -> semanticError
                        (#
                        do '"' -> msg; ptnID.doPT -> msg;
                           '" must be a pattern' -> msg
                        #)
                    if)
                 #);
            do (*'**** OI:checkNoSingleObj: ' -> puttext; dopt -> puthead;*)
               checkATdisPtn
            #);
          viaInclude:
            (* X via %include C via %include B via %include A
             * means: A.B.C.X, path = [A,nest(B),nest(C),nest(X)]
             *)
            (# OI,OIx: ^ObjectInvocation; on,pn,onx: @integer; 
               OGS: ^OGsequence;
               MI: ^ModuleItem; encOG,OGx,qual: ^ObjectDescriptor
            enter(encOG[],OI[],on,pn,OGS[])
            do <<SLOT sem_OI_viaInclude:descriptor>>;
               (if ptnId.viaIncl[] = none then
                   (* In X via %include C; via %include B; via %include A
                    * we have reached A - the top of the include path
                    * Fall back to B and C
                    *)
                   (if OGS[] = none then
                       (encOG[],false(*?*),OGS[]) -> OGsequence -> OGS[];
                       (if traceGetVqual then ('OGS:initial:',0,0)->OGS.print if)
                   if);
                   on -> onx;
                   (if OI.origin.isSignature then
                       onx - 1 -> onx;
                       <<SLOT sem_OI_viaInclude_isSig_onx:descriptor>>;
                   if);
                   (for onx repeat ('OI.viaInclude:',0) -> OGS.ENC ->OGS[] for);
                   (if traceGetVqual then
                       '**** viaInclude:OGS.ENC:'->putline; OGS.print
                   if);
                   (for pn repeat OGS.PRE -> OGS[] for);
                   (encOG[],(*NEST::*)true,OGS[]) -> OGSequence -> OGS[];
                   (if traceGetVqual then
                       '**** viaInclude:GOT:'->putline; OGS.print
                   if);
                   OGS.DOG[] -> encOG[] (* ???*)
                else
                   ptnId.viaIncl.son -> OIx[]; (* first son of INV *)
                   <<SLOT sem_OI_viaInclude_notTop:descriptor>>;
                   OIx.ptnId.on + 1 -> onx; 
                   (if traceGetVqual then 'OIx.ptnID.on:'->dumpt; OIx.ptnId.on->dumpI; newline;  if);
                   (encOG[],OI[],onx,0,OGS[]) 
                     -> OIx.viaInclude 
                     -> (encOG[],OGS[]);
                   (if traceGetVqual then ('**   viaInclude:after',0,0) -> OGs.print if);
                   (encOG[],false,OGS[]) -> ptnId.viaIncl.ATd.getVqual -> (OGS[],qual[]);
                   (if traceGetVqual then
                       ('**   viaInclude:after:ptnId.viaIncl.ATd.getVqual:',0,0) -> OGs.print;
                if)if)
            exit(encOG[],OGS[])
            #);
          gettingReturnQual: @boolean;
          getVqual:: (* encOG[], isNest, OGS[]) *)
            (* this(OI).getVqual is invoked in the context of encOG 
             * It is called from checker::ObjectInvocation::checkOI, 
             * which is called from Invocation::check:
             *    INV = R.X.Y -- '.X' may be a binary op like '+ e'
             * where INV is located in encOG
             * isNest is false for first call of checkOI and true afterwards
             * OGS: is initially none and updated in each call of checkOI
             *    (none,BS,AS,true,none -> checkOI -> (BS,OGS[])
             *      ==> (encOG[],isNest=false,none) -> getVqual -> (OGS[],qual[]
             *    (R,BS,AS,false,OGS) -> checkOI -> (BS,OGS[])
             *       ==> (encOG[],isNest=true,OGS) -> getVqual -> (OGS[],qual[]
             *    (X,BS,AS,false,OGS) -> checkOI -> (BS,OGS[])
             *       ==> (encOG[],isNest=true,OGS) -> getVqual -> (OGS[],qual[]
             *)
            (# mark: (# n: @integer enter n <<SLOT sem_OI_getVq_mark:doPart>>#);
               markENC: mark(#do 'ENC:on='->puttext #);
               markPRE: mark(#do 'PRE:pn='->puttext #);
               OGSx,OGSy: ^OGsequence; OGx: ^ObjectDescriptor; DI: ^Decl;
               U,T: ^Text; inSig: @boolean; onx: @integer
            do <<SLOT sem_OI_getVq:descriptor>>;
               (if ptnID.viaIncl[] <> none then
                   (* Given X, via %include C, path(X) to C is (on,pn), *)
                   (encOG[],this(ObjectInvocation)[],on,pn,OGS[]) 
                     -> viaInclude 
                     -> (encOG[],OGS[]);
                   (*'**** after:viaInclude:'->dumpT;
                   (ATd.asDecl).dopt -> putHeadN;*)
                   (encOG[],true,OGS[]) 
                     -> (ATd.asDecl).getVqual -> (OGSx[],qual[]);
                else
                   (if (OGS[] -> OGSx[]) = none then
                       (* Given INV = R.X.Y, first call of R.getVQual *)
                       encOG[] -> OGx[];
                       (for on repeat 
                            (if false and (OGx.origin.father[] <> OGx.origin.encOG[]) then
                                '**** Differs:'->dumpTN; dopt->dumptn;
                                '**   father:'->dumptn;
                                 OGx.origin.father.dopt->dumptn;
                                 '**   origin:'->dumptn;
                                OGx.origin.encOG.dopt -> dumptn;
                                '---'->dumptn;
                            if);
                            OGx.origin.encOG[] -> OGx[]
                       for);
                       (OGx[],false,none) -> OGsequence -> OGSx[];
                       (for pn repeat OGSx.PRE -> OGSx[] for);
                       <<SLOT sem_OI_getVq_initial:descriptor>>;
                       (encOG[],false,OGSx[]) 
                         -> (ATd.asDecl).getVqual -> (OGSx[],qual[]);
                       <<SLOT sem_OI_getVq_afterATd:descriptor>>;
                    else
                       (if isNest then
                           (* Given INV = R.X.Y, 2nd or 3rd call of R.getVQual*)
                           (# OGSz: ^OGsequence; i: @integer
                           do OGSx[] -> OGSz[];
                              loop:
                                (* encOG is a binding in one of the DOGs 
                                 * in OGSx. We search backward for the 
                                 * DOG having the binding.
                                 * NB! It seems that encOG is not always a 
                                 * binding, so what is going on here?
                                 *)
                                (# 
                                do i + 1 -> i; 
                                   (if OGSz[] <> none then
                                       (if encOG[] = none then leave loop if);
                                       <<SLOT sem_OI_getVq_findEnc:descriptor>>;
                                       (if (encOG.origin[] <> none) and
                                           (encOG.origin.father[] = OGSz.DOG[])
                                           or OGSz.hasBinding then
                                            <<SLOT sem_OI_getVq_findEnc_match:descriptor>>;
                                           OGSz[] -> OGSx[];
                                           leave loop
                                       if);
                                       OGSz.pred[] -> OGSz[];
                                       restart loop
                           if)#)#);
                           (encOG[],true,OGSx[]) -> OGsequence -> OGSx[];
                           <<SLOT sem_OI_getVq_isNest:descriptor>>;
                       (*else: from DataItem.getVqual and others!? *)
                       if);
                       (* isNest ==> on = 0, 
                        * otherwise on >= 0, we may come from DataItem:getVqual 
                        *)
                       (if traceGetVqual then
                           '**** OI:getVqual:XX:'->dumpt; dopt -> dumpT;
                           'on:'->dumpT; on -> dumpI; 
                           origin.label -> dumpT;
                           newline;
                           '**   father:'->dumpt; father.dopt->dumpTN;
                           '**   father.f.f.f.f:'->dumpTN; 
                           father.father.father.father.father.dopt->putHeadN;
                       if);
                       (for i: on repeat
                            ('OI.getVqual:',i) -> OGSx.ENC -> OGSx[]; 
                            i -> markENC;
                       for);
                       (for i: pn repeat OGSx.PRE -> OGSx[]; i -> markPRE for);
                       <<SLOT sem_OI_getVq_B2:descriptor>>;
                       (encOG[],false,OGSx[]) 
                         -> (ATd.asDecl).getVqual -> (OGSx[],qual[]);
                       <<SLOT sem_OI_getVq_cont_afterATd:descriptor>>;
               if)if);
               (# IT: ^node; wasSaved,B: @boolean
               do father.father.father[] -> IT[];
                  (*'**** father:'->dumpT; father.label->dumpT;
                  father.father.label->dumpT;
                  father.father.father.label->dumpTN;*)
                  (if (savedOGS[] <> none) and not IT.isDecl then
                      (if traceGetVqual then
                          '**** savedOGS:save:was:'->puttext; 
                          savedOgs.print; 
                          '**   OI: '->puttext; 
                          this(ObjectInvocation).dopt->putline;
                      if);
                      true -> wasSaved; (* ??? - local here? *)
                   else 
                      (* savedOGS is used atcheckActualArgs as 
                       * argument to getOGsequenceOfArg
                       * savedOI is not used
                       *)
                      OGSx[] -> OGS[] -> savedOGS[];
                      this(ObjectInvocation)[] -> savedOI[];
                      (if traceGetVqual then
                          '**** savedOGS:save:'->puttext; B -> putboolean;
                          savedOgs.print;
                          '**   OI: '->puttext; 
                          this(ObjectInvocation).dopt->putline;
                      if)
                  if);
                  <<SLOT sem_OI_getVq_savedOGS:descriptor>>;
               #);
               (if (qual.getReturnDecl -> DI[]) <> none then
                   (if gettingReturnQual then
                       (*'**   OI:getVqual:leave'->putline;*)
                       (* Find out if the correct qual/OGS is returned *)
                       leave getVqual
                   if);
                   true -> gettingReturnQual;
                   (qual[],true,OGSx[]) -> OGsequence -> OGSy[];
                   (encOG[],false,OGSy[]) -> DI.getVqual -> (OGSx[],qual[]);
                   <<SLOT sem_OI_getVq_return:descriptor>>;
                   false -> gettingReturnQual;
               if); 
               qual[] -> savedQual[];
               (if (savedQual.getExpUnit (*UnitX*) -> U[]) <> none then
                   U[] -> ExpUnit[];
               if);
               OGSx[] -> OGS[];
               <<SLOT sem_OI_Vq_end:descriptor>>
            #);
          getQual::
            (#
            do (if traceGetQual then
                   '**** ObjectInvocation:getQual: ' -> puttext;
                   dopt->putheadN
               if);
               (if (ATd[] <> none) and ((ATd.asDecl).primNo = this_Prim) then
                   args.scanArgs
                   (# IV: ^ObjectSpecification
                   do current[] -> IV[]; 
                      (* we need the original calling context to get the actual
                       * type of this(P) as with getVqual!
                       * We should eliminate getQual and only use getVqual
                       *)
                      IV.getQual -> qual[];
                      (*IV.doPT -> putheadN; qual.doPT -> putheadN*)
                   #);
                   ('Keyword:getQual:this_prim', qual[])->display;
                   leave getQual
               if);
               (if ATd[] <> none then
                   (if (ATd.asDecl).isVirtual then
                       (ATd.asDecl).getQual -> qual[]
                    else
                       (ATd.asDecl).getQual -> qual[]
                   if)
                else
                   '!!!! OI:getQual:ATd is none:' -> putline;
                   dopt -> putheadN
               if);
               (if traceGetQual then
                   (if qual[] <> none then
                       '**   OI:getQual:QUAL:IS: ' -> putline;
                       qual.doPT -> putheadn
                    else
                       '*** qual is none' -> putline
                   if)
               if)
            #);      
          getActualReceiver::
            (#
            do (if (ATd.asDecl).primNo = this_prim then
                   '**** OI:getACtualReceiver:'->dumpT; dopt->putheadN;
                   args.scanSons
                   (# i: @integer; OG: ^ObjectCall
                   do (if (i + 1 -> i) = 2 then
                          (*'** primArg:'->puttext; current.doPT -> putline;*)
                          ((current[] -> OG[]).super).last -> rec[]
                      if)
                   #)
               if)
            #);
          getDecl::
            (#
            do ATd.asDecl -> dcl[]
            #)
       #);
     IfThen::<
       (* Must check that cond is a boolean exp; 
        * and also check thenPart/elsePart *)
       (# semCheck::
            (#
            do (if false then
                   '**** IfThen:semCheck: ' -> puttext; doPT -> putheadN
               if);
            #)
       #);
     IfThenElse::<
       (# semCheck::
            (#
            do (if false then
                   '**** IfThenElse:semCheck: ' -> puttext; doPT -> putheadN
               if);
            #)
       #);
     BinaryExp::<
       (# semCheck::
            (* for en expression e1 + e2, semantic check is apparently
             * done when checking e1 + e2; it is checked that
             * the operator '+' is declared in the type of e1
             *)
            (#
            do (if traceGetVqual then
                   '**** BinaryExp:semCheck:'->puttext; dopt -> putHeadN
               if)
            #);
          getVqual::
            (#
            do (if traceGetVqual then
                   '**** BinaryExp:getVqual:'->puttext; dopt -> putHeadN
               if);
               (encOG[],true,OGS[])
                 -> leftRec.getVqual
                 -> (OGS[],qual[]);
               (qual[],false,OGS[]) -> M.getVqual -> (OGS[],qual[]);
            #);          
       #);
     UnaryExp::<
       (# semCheck::
            (#
            do (if false then
                   '**** Unary:semCheck:'->puttext; dopt -> putHeadN
               if);
               
            #);
          getVqual::
            (#
            do (if traceGetVqual then
                   '**** UnaryExp:getVqual:'->puttext; dopt -> putHeadN
               if);
               (encOG[],true,OGS[]) -> trm.getVqual -> (OGS[],qual[]);
            #);
       #);
     BracketedExp::<
       (# semCheck::
            (# E: ^Exp
            do (if false then
                   '**** BracketedExp:semCheck: ' -> puttext;
                   dopt -> putline;
               if);
               (if false and (noOfSons > 1) then
                   '**   got Indexed literal! ' -> puttext; doPt ->putline;
                   ('receiver',rec[]) -> putPT; 
                   (if rec[] <> none then rec.label -> putline; if)
               if);
               (if false and (rec[] <> none) 
                   and ((rec[]->E[]).ATd[] <> none)
                   and ((E.ATd.asDecl).OG.primno = indexed_prim) then
                   '**** receiver is Indexed: '->puttext; doPT -> putline;
                   ('receiver',rec[]) -> putPT; 
               if)
            #);
          getQual::
            (# 
            do IV.getQual -> qual[] 
            #);
          getVqual::
            (#
            do (if traceGetVqual then
                   'BrackedetExp:getVqual:'->puttext; dopt -> putline;
               if);
               (encOG[],isNest,OGs[]) -> IV.getVqual -> (OGS[],qual[])
            #);
          getActualReceiver::
            (#
            do IV.getActualReceiver -> rec[];
            #);
       #);
     Name::<
       (# semCheck::
            (#
            do (if false then
                   '**** Name:semCheck: '-> puttext; dopt -> putline;
                   (if ATd[] <> none then
                       '**   ATd:'->dumpT; ATd.dopt->dumptn
                   if)
               if);
            #);
          getVqual::
            (#
            do (if true then 
                   '**** Name:getVqual: '-> puttext; dopt -> putline
               if)
            #)
       #);
     Const::<
       (# semcheck::
            (#
            do (if traceCheck then
                   '**** IntegerObj:semcheck:' -> puttext; dopt -> putline
               if);
               (if not unit.isEmpty  then
                   (if false then
                       '**** Const:semcheck: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> expUnit[] 
                     -> unitTable.findUOGall -> encOG[] -> eOG[];
                   (if eOG[] = none then
                       '!!!! Const:findUOG is none: '->puttext;
                       dopt -> putline;
                   if)
                else
                   integerDecl.OG[] -> encOG[] -> eOG[];
               if)
            #);
          getVqual::
            (#
            do (if not unit.isEmpty then
                   (if false then
                       '**** Const:getVqual: ' -> puttext; dopt->putline
                   if);
                   unit.T[] -> expUnit[] -> unitTable.findUOGall -> qual[];
                   (if qual[] = none then
                       '!!!! Const:findUOG is none: '->puttext;
                       dopt -> putline;
                   if)
                else
                   integerDecl.OG[] -> qual[]
               if)
            #);
          getQual:: 
            (#
            do (if traceCheck then
                   '**** Const:getQual: ' -> puttext; dopt -> putline
               if);
               integerDecl.getQual -> qual[]
            #);
       #);
     FloatConst::<
       (# semCheck:: 
            (# 
            do (if not unit.isEmpty then
                   (if false then
                       '**** FloatConst:semcheck: '->puttext; dopt->putline
                   if);
                   unit.T[] -> unitTable.findUOGall -> encOG[] -> eOG[];
                   (if eOG[] = none then
                       '!!!!floatConst:findUOG is none: '->puttext;
                       unit.T[] -> dumpT;
                       dopt -> putline;
                   if)
                else
                   floatDecl.OG[] -> encOG[] -> eOG[] 
               if)
            #);
          getVqual::
            (#
            do (if not unit.isEmpty then
                   (if false then
                       '**   flotConst:getqual: ' ->puttext; dopt->putline
                   if);
                   unit.T[] -> expUnit[] -> unitTable.findUOG -> qual[]
                else
                   floatDecl.OG[] -> qual[] 
               if)
            #);
          getQual:: 
            (# 
            do (if not unit.isEmpty then
                   (if false then
                       '**   flotConst:getqual: '->puttext; dopt->putline;
                   if);
                   unit.T[] -> unitTable.findUOG -> qual[]
                else
                   floatDecl.getQual -> qual[] 
               if)
            #);
       #);
     CharObj::<
       (# semcheck::
            (#
            do (if false then
                   '**** CharObj:semcheck:' -> puttext; dopt -> putline
               if);
               charDecl.OG[] -> encOG[] -> eOG[]
            #);
          getVqual:: (#do charDecl.OG[] -> qual[] #);           
          getQual:: (#do charDecl.getQual -> qual[] #); 
       #);
     StringObj::< 
       (# semcheck::
            (#
            do (if false then
                   '**** StringObj:semcheck:' -> puttext; dopt -> putline
               if);
               stringDecl.OG[] -> encOG[] -> eOG[]
            #);
          getVqual:: (#do stringDecl.OG[] -> qual[] #);           
          getQual:: (#do stringDecl.getQual -> qual[] #); 
       #);
     Slot::<
       (# semCheck::
            (#
            do (if traceSlots then
                   '**** Slot:semCheck: '->puttext; dopt -> putline
               if);
               (rec[],encOG[]) -> slotItems.semCheck -> eOG[];
            #)
       #);
  do (if verbose then '**** SEMCHECK ****' -> putline if);
     
     main.semCheck;

     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline
      else
         (if printHTMLfile then rootModule.emitHTML if);
         inner;
         (if showUnits then rootmodule.selectForPrintUnits if);
     if)
  #)
