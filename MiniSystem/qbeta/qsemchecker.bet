ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'
---lib:attributes---
useNewQual: (#exit true #);
trace_pathToDcl: (# exit false #);
semchecker: checker
  (# doCheckQual:
       (# srcQual,dstQual: ^ObjectGenerator
       enter(srcQual[],dstQual[])
       do  (* repeat code from DataItem - but perhaps in checkQual in Decl? *)
       #);
     Module::<
       (# semcheck:: 
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[]
                    if)
                 exit M[]
                 #);
               M: ^Module;
            do (*'Module:semCheck:'->puttext; DI.sig.id[] -> putline;*)
               (if (encModule -> M[]) <> none then
                   M.semCheck
               if)
            #)
       #);
     ModuleItem::<
       (# semCheck::
            (#
            do (if not MD.isIncluded then
                   (*'Module not included: ' -> putline; doPT -> putline;*)
                   false -> doCheck
               if)
            #);          
          getQual:: 
            (# do (*'ModuleItem:getQual: ' -> puttext; dopt -> putline;*)
               md.getQual -> qual[]
            #);
          getV_qual::
            (#
            do (if traceGetV_qual then
                   '*** ModuleItem:getV_qual:' -> puttext;
                   sig.doPT -> putline;
               if);
               MD.OG[] -> qual[]
            #);
          pathToDcl::
            (#
            do (if trace_PathToDcl then
                   '*** ModuleItem:pathToDcl:' -> putline;
                   sig.doPT -> putline;
               if);
               P[] -> MD.pathToDcl -> P[]
            #)
       #);
     DataItem::<
       (# getV_qual::
            (#
            do (if trx or traceGetV_qual then
                   '*** DataItem:getV_qual: ' -> puttext;
                   doPT -> putline
               if);
               (if OG.IS.isEmpty then
                   (* X: var TTT -- TT not virtual
                    * R: ref Person -- ditto
                    * S: obj Record -- virtual 
                    *)
                   (if not OG.super.ATd.isVirtual then
                       OG.getQual -> qual[]
                   if)
                else
                   OG[] -> qual[]
               if)
            #);
          nestPath: @boolean;;  (* true: mark path for inArg as isNest *)
          pathToDcl::
            (* X: ?T, R: ?V where V:< Q
             * Y: = T{...}
             *)
            (# Px: ^OGPath
            do (if trx or trace_PathToDcl then
                   '*** DataItems:pathToDcl:' -> puttext; sig.doPT -> putline;
                   (*P.print;*)
               if);               
               P[]-> OG.pathToDcl -> P[] -> Px[];
               (if trx or traceGetV_qual then
                   '--- DataItems:pathToDcl:' -> puttext; sig.doPT -> puttext;
                   ' isInArg:' -> puttext; isInArg -> putBoolean; 
                   ' nestPath:' -> puttext; nestPath -> putBoolean; 
                   newline;
                   P.print
               if);
               (if isInarg and nestPath then 
                   true -> Px.isNest; false -> nestPath 
               if);               
            #);
          getQual:: 
            (# 
            do OG.getQual -> qual[];
               (*'***** DI:getQual: ' -> puttext; doPT -> putline;
               'Qual: ' -> puttext; qual.dopt -> putline*)
            #);
          semCheck::
            (* Check that in S : ? T, V: = T, T is a pattern
             * it seems to work for singular patterns, but check if this is so!
             * And for X: var/val/obj foo(e1,e2,e3) - type(X) = type(foo.return)
             *)
            (# OGqual: ^ObjectGenerator
            do (if trx then
                   '**** DataItem: ' -> puttext; dopt -> putline;
                   '**   OG.isPtnOrSingular:' -> puttext;
                   OG.isPtnOrSingular -> putBoolean; 
                   ' isValue:' -> puttext; isValue -> putboolean;
                   ' isPrimitive:' -> puttext; isPrimitive -> putBoolean;
                   ' OG.isValueObj: ' -> puttext; OG.isValueObj -> putBoolean;
                   '\n**  OG:'->putline; OG.dopt -> putline;
                   OG.label -> putline;
                   '\n**   OG.getQual: ' -> puttext; 
                   (OG.getQual).dopt -> putline;
                   newline;
               if);
               OG.getQual -> OGqual[];
               (if OGqual.isPtnOrSingular then
                   not isConst or isArg -> noArgsCheck;
                   (* see qabstractSyntaxTree::semCheck
                    * if noArgsCheck, the sons are not checked
                    * Is this correct?
                    *)
                   (if isValue then
                       (if not (OGqual.isValueObj or OGqual.isPrimitive) then 
                           this(DataItem)[] -> SemanticError
                           (#
                           do 'The qualification "' -> msg;
                              OG.doPT -> msg;
                              '" must be a value pattern' -> msg;
                           #)
                       if)
                    else
                       (if OGqual.isValueObj then
                           (if OGqual.isBasicValue then
                               (* while implementing sub of integer, etc
                                * we allow decl of the form I: ?integer
                                *)
                            else
                               this(DataItem)[] -> SemanticError
                               (#
                               do 'The qualification "' -> msg;
                                  OG.doPT -> msg;
                                  '" must be an object pattern' -> msg;
                               #)                           
                   if)if)if)
                else
                   (if OGqual.super.ATd[] <> none then
                       OGqual.super.ATd.doPT -> putline;
                    else
                       OGqual.father.doPT -> putline
                   if);
                   this(DataItem)[] -> SemanticError
                   (#
                   do 'The qualification "' -> msg;
                      OG.doPT -> msg;
                      '" must be a pattern '-> msg;
                   #)
               if)
            #);
          checkQual::
            (* Check that enter arg srcOG can be assigned to dstOG
             * which is this(DataItem) 
             *)
            (# error:
                 (#
                 do (if reportSemErr then
                        srcOG[] -> semanticError
                        (#
                        do '"'->put; srcOG.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                           '**** srcQual:' -> puttext; 
                           (if srcQual[] <> none then
                               srcQual.dopt -> putline
                            else
                               'none'->putline
                           if);
                           '**** srcOG.getQual:' -> puttext; 
                           (srcOg.getQual).dopt -> putline;  
                           '**** dstQual:' -> puttext; 
                           (if dstQual[] <> none then
                               dstQual.dopt -> putline
                            else
                               'none' -> putline
                           if);
                          '**** dstOG.getQual:' -> puttext; 
                          (getQual).dopt -> putline;                           
                 #)if)#);
               (*srcQual,dstQual: ^ObjectGenerator*)
            do (if false and ('xxxL2'-> sig.ID.equal) then
                   '**** Got: ' -> puttext; dopt -> putline;
                   true -> trx;
               if);
               (if false then
                   '**  in:DI::'->putline; srcOG.label -> putline;
                   srcOG.dopt -> putline;
                   (srcOG.getQual).dopt -> putline;
               if);
               (if trx or traceGetQual then
                   '\n**** DataItem:checkQual:' -> puttext; 
                   (if isConst then ':C:' -> puttext if);
                   (if isAssign then ' := ' -> puttext if); newline;
                   ('**   dst',this(DataItem)[]) -> display; 
                   ('**   src',srcOG[]) -> display;
               if);
               (* We need to call getV_qual at the point of the 
                * ObjectInvocation: X := exp or R. foo
                * to get the actual binding of possible virtuls
                * at the point of call
                *)
               (if false then
                   (if srcOG[] <> none then 
                       srcOG.getQual -> srcQual[] (* none if string " ..." *)
                    else
                       '>>> srcOG none' -> putline
                   if);
                   getQual -> dstQual[]; (* getQual may return possible return value
                                          * which is not correct since we do not
                                          * assign to the return value of OG! 
                                          * So it should be OG[] -> dstQual[]!?
                                          *)
               if);
               (if srcQual[] = none then
                   '**** srcQual:NONE: ' -> puttext; srcOG.dopt -> putline;
                else(*
                   '**** srcQual: ' -> puttext; srcQual.dopt -> putline*)
               if);
               ('srcQual',srcQual[]) -> displayB; (* there is also a Display *)
               ('dstQual',dstQual[]) -> displayB;
               (if isConst and isAssign then 
                   (* OG is left-part of assign as in aPoint1 := aPoint2 *)
                   (if OG.isValueObj then
                    else
                       error
                   if)
                else
                   (if true
                    // OG.isBasicValue then 
                       (* OG[] -> dstQual[];*) 
                       (* '\n***Got isBasicValue:'-> puttext; 
                        OG.doPT -> putline;
                        '** srcQual:' -> putline; srcQual.dopt -> puttext;
                        ':primNo:' -> puttext; srcQual.primNo -> putint;
                        newline;
                        '** dstQual:' -> putline; dstQual.doPT -> putline;*)
                       (* The value_prim cases below is to handle
                        *    _V: ?Value 
                        * in patterns integer, char and boolean
                        *)
                       (if srcQual[] <> none then
                           (if srcQual.primNo
                            // integer_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim 
                                // boolean_prim // float_prim then
                                else
                                   error
                               if)
                            // char_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim // value_prim then
                                else
                                   error
                               if)
                            // boolean_prim then
                               (if dstQual.primNo 
                                // boolean_prim // integer_prim then 
                                else
                                   error 
                               if)
                            // float_prim then
                               (if dstQual.primNo 
                                // float_prim // integer_prim then 
                                else
                                   error 
                               if)
                                                              
                            // value_prim then
                               (if dstQual.primNo 
                                // integer_prim // char_prim // value_prim then
                                else
                                   error
                               if)                               
                            else
                               error
                           if)
                        else
                           error
                       if)  
                    // OG.isValueObj then
                       (*'\n***Got valueObj:'-> puttext; 
                        OG.dopt -> putline;
                        srcQual.dopt -> putline;
                        dstQual.dopt -> putline;
                       '---'->putline;*)
                       (if true
                        // srcQual[] = dstQual[] then (* OK *)
                        // srcQual[] -> dstQual.inSuper then 
                           srcOG[] -> Warning
                           (# 
                           do 'The right-side value: "' -> msg;
                              srcOG.doPT -> msg;
                              '" is truncated ' -> msg;
                              '\n\twhen assigned to the left-side variable: "' -> msg;
                              doPT -> msg;
                              '"' -> msg
                           #);
                           (if trx then
                               '**** Source:'->putline;
                               srcQual.dopt -> putline;
                               '**** Destination:'->putline;
                               dstQual.dopt -> putline;
                           if)
                        // dstQual[] -> srcQual.inSuper then 
                           '\n**** OBS! source is super of dest: ' -> putline;
                           '**   source: ' -> puttext; srcOG.dopt -> putline;
                           '**   dest  : ' -> puttext; dopt -> putline;
                           srcOG.father.father.father.dopt -> putline
                        // srcQual.isInteger // srcQual.isFloat then
                           (# U: ^text
                           do (*
                              '**** Assiging integer or float to value object:'
                                -> putline;
                              '**   src: ' -> puttext; srcOG.dopt -> puttext;
                              ' with unit: ' -> puttext; 
                              srcOG.getUnit -> U[] -> putline;
                               '**   dst: ' -> puttext; OG.dopt -> putline;*)
                              srcOG.getUnit -> OG.matchUnit 
                              (#
                              do srcOG[] -> Warning
                                 (#
                                 do 'The units of the left-side and right-side are not matching ' 
                                      -> msg;
                                 '\n     The right-side unit must be "'-> msg; Ud[] -> msg;
                                    '" but is: "' -> msg; Ua[] -> msg; '"' -> msg
                              #)#)
                           #)
                        else
                           (if srcOG.primNo = indexedGet_prim then
                               (*'indexGet_prim'->putline*)
                               (* fix that the type of the indexed DI is consistent
                                * with the left-side
                                * *)
                            else
                               (* we should spell out wheter or not srcOG, etc
                                * are objectRefs or valueObjs *)
                               (*srcQual.dopt -> putline;
                               dstQual.dopt -> putline;*)
                               srcOG[] -> semanticError
                               (#
                               do 'The expression:\t"' -> puttext;
                                  srcOG.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' 
                                    -> puttext;
                                  doPT -> puttext; '"' -> put; newline;
                       #)if)if)
                    else
                       (*'**** Got object ref:' -> putline;*)
                       (if true
                        // srcOG.isValueObj then
                           srcOG[] -> semanticError
                               (#
                               do 'The value expression: "' -> msg;
                                  srcOG.doPT -> msg;
                                  '"\n     cannot be assigned to '-> msg;
                                  'the object reference: "' -> msg;
                                  doPT -> msg; '"' -> msg
                               #);
                        // srcQual[] = dstQual[] then 
                           (* OK: and may be merged with the case below.
                            * Is splitted for test purposes, see below
                            *)
                        // srcQual[] -> dstQual.inSuper then (* OK *)
                           (if useNewQual then
                               (* This is just for test purposes: 
                                * for references this is ok, but for values, 
                                * the right-side may be truncated, see above
                                *)
                               (if false then
                                   srcOG[] -> Warning
                                   (# 
                                   do 'The right-side: "' -> msg;
                                      srcOG.doPT -> msg;
                                      '" refers to a subpattern/obj ' -> msg;
                                      'of the left-side: "' -> msg;
                                      doPT -> msg;
                                      '"' -> msg
                                   #);
                                   (if trx then
                                       '**** Source:'->putline;
                                       srcQual.dopt -> putline;
                                       '**** Destination:'->putline;
                                       dstQual.dopt -> putline;
                           if)if)if)
                        // (srcQual[] <> none) 
                           and (dstQual[] -> srcQual.inSuper) then
                           srcOG[] -> QuaCheck
                           (# 
                           do 'It must be checked at run-time that "'
                                -> puttext;
                              srcOG.doPT -> puttext;
                              '"\n     is a subpattern of "' -> puttext;
                              doPT -> puttext; '"' -> put; newline
                           #)
                        // (srcQual[] <> none) and (srcQual.primNo = none_prim) then
                        else
                           (if reportSemErr then
                               srcOG[] -> semanticError
                               (#
                               do 'The reference expression:\t"' -> puttext;
                                  srcOG.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #);
                               (if false then
                                   '**** srcQual:' -> putline;
                                   srcQUal.dopt -> putline;
                                   '**** dstQual: ' -> putline;
                                   dstQual.dopp -> putline;
                               if)
               if)if)if)if);
            #);
       #);
     isPatternDen:< BooleanValue
       (# E: ^Exp
       enter E[]  
       do E.ATd.doPT -> putline;
          (if E.ATd[] <> none then E.ATd.isPatternDecl -> value if)
       #); 
     pattern::<
       (# checkQual::
            (* We come here for assignments of the form
             *    (this Speed) := exp
             * where 
             *    Speed: integer{... }
             *    Point: Value{ ... }
             *    Record: { ... }
             * This pattern must be a value of sub of basic 
             * - the latter may later be desclared as sub of Value
             *)
            (# trace: (# exit false #)
            do (if trace then
                   '**** Pattern:checkQual:\n' -> puttext; dopt -> puttext;
                   '\n**   :isAssign:' -> puttext; isAssign -> putBoolean;
                   ':srcOG: "' -> puttext; srcOg.dopt -> puttext; 
                   '"\n' -> puttext;
                   '**   isValueObj:' -> puttext; OG.isValueObj -> putBoolean;
                   ':isPrimitive:' -> puttext; isPrimitive -> putBoolean;
                   newline;
               if);
               (if isAssign then
                   (if true 
                    // OG.isValueObj then 
                       '**** pattern:checkQual:isValueObj:' -> putline;
                       '**   check assignTo: \n' -> puttext;
                       doPT -> putline;
                       '**  from: "' -> puttext; srcOG.doPT -> puttext;
                       '"\n\n' -> puttext
                    // isPrimitive then 
                       '**** pattern:checkQual:isPrimitive:shouldNotHappen' 
                         -> putline;
                    // OG.isBasicValue then 
                       '**** pattern:checkQual:isBasicValue:' -> putline;
                       '**   check assignTo: \n' -> puttext;
                       doPT -> putline;
                       '**  from: "' -> puttext; srcOG.doPT -> puttext;
                       '"\n\n' -> puttext
                    else 
                       (* Bad message - should be fixed *)
                       srcOG[] -> SemanticError
                       (#
                       do srcOG.doPT -> msg;
                          ' cannot be assigned to :\n' -> msg;
                          dopt -> msg;
                       #)
                   if)           
               if)
            #);
          checkActualArgs::
            (* theOI is the the ObjectInvocation calling this(Pattern) *)
            (# trace1:
                 (#
                 do (if trx then
                        ')\n--  theOI: "'->puttext; theOI.doPT->puttext;
                        '" theOI.on:'->puttext; theOI.on -> putint;
                        ' theOI.pn:' -> puttext; theOI.pn -> putint; newline;
                        '--  encOG: "' -> puttext; encOG.dopt -> putline; 
                        '"'->putline;
                        '--  OI_OG: ' -> puttext; OI_OG.doPT -> putline;
                    if);
                 #);
               T: ^text;
               trace2:
                 (# pn: @integer; ATd: ^Decl
                 do (if trx then
                        '--  got:itm: ' -> puttext;  
                        itm[inx - 1].dopt -> putline;
                        ' on: ' -> puttext; itm[inx - 1].super.on -> putint; 
                        ' pn: ' -> puttext; 
                        (itm[inx - 1].super.last).pn -> putint; 
                        ' ATd: ' -> puttext; 
                        itm[inx - 1].super.ATd.doPT -> putline;
                        T[] -> OI_OG.IS.localSearch 
                          -> (ATd[],pn);
                        atD[] <> none -> putboolean; ' ' -> put; 
                        pn -> putint; 
                        '--  qual:' -> putline;
                        (itm[inx - 1].getQual).doPT -> putline
                    if)
                 #);
               fArgs: [6] ^Decl; inx,top: @ integer; 
               OI_OG: ^ObjectGenerator;
               OI_isKeyWord: @boolean;
               mkOG:
                 (# OI: ^ObjectInvocation;
                    OGx: ^ObjectGenerator; IV: ^Invocation; IT: ^Items;
                    ITx: ^text; err: ^Text
                 enter OI[]
                 do (if trx  then
                        '\n\n**** mkOG:OI.label:' -> puttext; OI.label -> putline;
                        '**   OI: ' -> puttext; OI.doPT -> putline;
                        '**   OG:\n' -> puttext; OG.doPT -> putline;
                        '**   encOG: ' -> puttext; encOG.doPT -> putline;
                    if);
                    (if ('ObjectInvocation_KeyWord' -> (OI.label).equal) then
                        true -> OI_isKeyword;
                        leave mkOG
                     else
                        '(' -> ITx[];
                        (OI.doPTnoComments).scanAll
                        (#
                        do (if ch >= ' ' then ch -> ITx.put if)
                        #);                            
                        ') {' -> ITx.puttext;
                        (for i: top repeat
                             ' ' -> ITx.puttext;
                             fArgs[i].sig.dopt -> ITx.puttext; ';' -> ITx.puttext
                        for);
                        '}' -> ITx.puttext;  
                        (*ITx[] -> putline;*)
                        ITx[] -> parseObjectGeneratorText -> (err[],OGx[]);
                        (if trx then
                            '\n****  OGx:label:' -> puttext;
                            OGx.label -> putline;
                            OGx.doPT -> putline;
                        if);
                        OG[] -> OGx.father[];
                        OG.IS[] -> OGx.setUpOrigin;
                        (if trx then '**   check:OGx: ' -> putline if);
                        (none,OGx.IS[],none,true) -> OGx.check;
                    if);
                 exit OGx[]
                 #);
               itm: [6] ^ObjectSpecification (*ObjectGenerator*);
            do (if (trx) or traceGetQual then
                   '**** Pattern:checkActualArgs:"' -> puttext; 
                   '\n**   encOG:' -> putline; encOG.doPT -> putline;
                   actualArgs.doPT -> puttext;
                   '"\n**   against: "' -> puttext; sig.doPT -> puttext; 
                   '"fArgs('->puttext;
               if);                              
               OG.IS.scanItemArgs
               (#
               do (if (top + 1 -> top) > fArgs.range then 
                      fArgs.range -> fArgs.extend;
                      itm.range -> itm.extend
                  if);
                  currentArg[] -> fArgs[top][];
               #);
               (if top > 0 then
                   (if useNewQual then theOI[] -> mkOG -> OI_OG[]; if);
                   (if useNewQual and not OI_isKeyword then 
                       trace1;
                       OI_OG.IS.scanSons
                       (# ATd: ^Decl; pn: @integer
                       do (if (inx + 1 -> inx) > 1 then
                              (* first item is INCLUDE *)
                              current[] -> itm[inx - 1][];
                              trace2;
                           else
                              (if trx then newline if)
                   if)#)if)
                else
                   (if trx then 'no formal args)' -> putline;   if) 
               if);
               0 -> inx;
               actualArgs.scanArgs
               (# srcQual,dstQual: ^ObjectGenerator; DI: ^DataItem
               do inx + 1 -> inx; 
                   (if trx then
                      '**  actualArg:inx:' -> puttext; inx -> putint; 
                      ':arg: ' -> puttext; current.dopt -> puttext;
                      ' :formal: ' -> puttext; fArgs[inx].dopt -> putline;
                  if);                  
                  (if inx > top then
                      actualArgs[] -> SemanticError
                      (# 
                      do 'More actual parameters:\n\t"' -> msg;
                         actualArgs.doPT -> msg; 
                         '"\n    than formal parameters:\n\t"' -> msg;
                         sig.doPT -> msg; '"' -> msg
                      #)
                   else
                      (if not useNewQual or OI_isKeyword then
                          (if trx then 
                              '**  thisArg:label: '->puttext; 
                              current.label -> puttext; ' '->put;
                              current.dopt -> putline;
                          if);
                          current.getQual -> srcQual[];
                          (if trx then
                              '**  srcQual:' -> putline;
                              srcQual.dopt -> putline;
                          if);
                          fArgs[inx].getQual -> dstQual[];
                       else
                          (if trx then
                              '**** current.semCheck:label: ' -> puttext; 
                              current.label -> putline;
                              current.dopt -> putline;
                              '**   theOI.theOG: ' -> putline;
                              (theOI.enclosingObjectGenerator).dopt 
                                -> putline;
                          if);
                          (none,theOI.enclosingObjectGenerator) 
                            -> current.semCheck -> srcQual[];
                          (if trx then
                              '**   srcQual:' -> putline;
                              srcQual.dopt -> putline;
                              '**   srcQual.father: ' -> putline;
                              srcQual.father.dopt -> putline
                          if);
                          (if fArgs[inx].isVirtual then
                              '**** virtual arg:' -> puttext; 
                              fArgs[inx].dopt -> putline;
                              current.getQual -> srcQual[];
                              fArgs[inx].getQual -> dstQual[]
                           else
                              (if fArgs[inx].isDataItem then
                                  fArgs[inx][] -> DI[];
                                  true -> DI.nestPath
                              if);
                              encOG[] 
                                -> (itm[inx].super.last).getV_qual
                                -> dstQual[];
                              (* OBS fArgs may be pattern or data-item
                               * check actual qual *)
                          if);
                          (if trx then
                              '*** arg:src:' -> puttext; current.dopt -> putline;
                              '*** srcQual:'->putline; srcQual.doPT -> putline;
                              '*** arg:dst:' -> puttext; fArgs[inx].dopt -> putline;
                              '*** dstQual:'->putline; dstQual.doPT 
                                -> putline;
                      if)if);
                      (current[],srcQual[],dstQual[],false) 
                        -> fArgs[inx].checkQual;
                  if);
               #); 
               (if trx then '**   after scanArgs' -> putline  if);
               (if (inx < top)  then
                   actualArgs[] -> SemanticError
                   (# 
                   do 'More formal than actual parameters' -> msg;
                      actualArgs.doPT -> msg;
                      '\n'-> msg;
                      sig.doPT -> msg;
                   #)
               if);
            #);
          getV_Qual::
            (* P: S ... 
             * F(...): G ...
             * A(...) -> V: ? T: S ...
             * + virtual
             *    V:< A
             *    V::< A
             *    V:: A
             * + recursive
             *   foo(...) -> V: ? bar: ...
             *   bar(...) -> R: ? foo: ...
             *)
            (# DI: ^DataItem; ptn: ^Pattern
            do (if traceGetV_qual then
                   '*** Pattern:getV_qual:' -> puttext; sig.doPT -> puttext;
                   ':isVirtual:'-> puttext; isVirtual-> putBoolean; newline
               if);      
               L:
                 (if isVirtual then
                     (* V:< Q;
                      * W:< Q{ ... }
                      *)
                     (*P.print;*)
                     (*OG.getV_qual -> qual[]*)
                  else
                     (* P(...) -> V: ? S: { .... } *)
                     (if true then
                         OG[] -> qual[]; 
                         (if (getReturnDecl -> DI[]) <> none then
                             (if DI.OG.IS.isEmpty then
                                 (if ((DI.OG.super.ATd[] -> ptn[]) <> none)
                                     and ptn.isVirtual then
                                     (if trx then
                                         '--  returnDecl:' -> puttext; 
                                         DI.doPT -> putline;
                                         dopt -> putline;
                                     if);
                                     none -> qual[];
                                     leave L
                                 if);
                                 DI.getQual -> qual[]
                             if);
                        else
                           OG[] -> qual[]
                       if)
                    else
                       getQual -> qual[];
                   if)
               if)
            #);
          pathToDcl::
            (* P: S{...}
             * V:< A{ ... }
             * V:< A;
             * V::< ...
             * V:: ...
             *)
            (# Px: ^OGpath; qual: ^ObjectGenerator; DI: ^DataItem
            do (if P[] = none then
                   '!!!! pathToDcl:P is none!' -> putline; doPT -> putline 
               if); 
               (if trx or trace_PathToDcl then
                   '**** Pattern:pathToDcl: '->puttext;
                   sig.dopt -> putline;               
                   (* P.print;*)
               if);               
               OG[] -> (P[]->Px[]).qual[]; (* just ad hoc *)
               this(Pattern)[] -> (P[]->Px[]).vDcl[]; (* just ad hoc *)
               
               (if isRec then 
                   '**** isRecursive'->putline;
                   OG[] -> (P[]-> Px[]).qual[];
                   false -> isRec;
                   leave pathToDcl
               if);
               true -> isRec;
               (* this is probably just a hack 
                * - we need to handle virtuals as in the Beta compiler
                *)
               (if (getReturnDecl -> DI[]) <> none then
                   (if trx then
                       '**  Pattern:return:DI:' -> puttext;
                       DI.doPT -> putline;
                   if);
                   Px[] -> DI.OG.pathToDcl -> Px[] -> P[]; 
                   (* Px = P is path to pattern dcl of the our arg
                    * is  marked isNest in order to call ENC(on-1)
                    * instead of ENC(on)
                    *)
                   true -> Px.isNest;
                   (if trx then
                       '**  Pattern:return:DI:path\n' -> puttext;
                       P.print;
                   if);
                   (*Px.getQual*)
                   false -> isRec;
                   leave pathToDcl
                else
                   (if isVirtual then
                       (* V:< Q -- dont follow path to Q! *)
                       (if trx then
                           '--- Pattern:isVirtual' -> putline;
                           dopt -> putline;
                       if);
                       (*(P[]-> Px[]).OG.pathToDcl -> Px[] -> P[]*)
                       (*(P[]-> Px[]).getQual ;*)
                    else              
                       OG[] -> (P[]-> Px[]).qual[];
               if)if);
               false -> isRec;
            #);
          getQual::
            (# 
            do (if traceGetQual then
                   '*** Pattern:getQual: '-> puttext; sig.doPT -> putline
               if);
               (none,origin[],origin[],true) -> check;
               (if isRecursive then
                   (* For a pattern
                    *    foo(...) -> res: ? foo ...
                    * getQual is called on the foo return value
                    * giving a recursive call of getQual
                    *)
                   (if traceGetQual then
                       '*** isRecursive' -> putline
                   if);
                   OG[] -> qual[];
                   (*false -> isRecursive;*)
                   leave getQual
               if);
               inner;
               (if traceGetQual then
                   'Pattern:getQual:B: "' -> puttext; 
                   sig.doPT -> puttext; '"' ->put; newline
               if);
               true -> isRecursive;
               (* this is probably just a hack 
                * - we need to handle virtuals as in the Beta compiler
                *)
               L:
                 (if qual[] = none then
                     (if isVirtual then
                         (*'*** Virtual: ' -> puttext; dopt -> puttext; 
                          ' on: ' -> puttext; OG.super.on -> putint;
                          ' pn: ' -> puttext; OG.super.pn -> putint; newline;*)
                         OG.getQual -> qual[];
                         (if traceGetQual then
                             'getQual:Virtual: ' -> puttext; 
                             qual.doPT -> putline;
                             OG.doPT -> putline
                         if)
                      else
                         (if traceGetQual then
                             'Pattern:getQual:C:' -> putline;
                         if);
                         OG.IS.scanAllItemDecls
                         (# DI: ^DataItem
                         do (if currentDcl.isOutArg then
                                (if currentDcl.isDAtaItem then
                                    (currentDcl[] -> DI[]).getQual -> qual[];
                                    leave L;
                                if)
                            if)
                         #);                       
                         OG[] -> qual[];
                 if)if);
               false -> isRecursive;
               (if traceGetQual then
                   'Pattern:getQual:D: "\n' -> puttext; 
                   (if qual[] <> none then 
                       qual.doPT -> puttext
                    else 'none'->puttext
                   if);
                   '"' -> put; newline
               if)
            #);
          semCheck::
            (# lastSuper: ^Exp
            do (if ((OG.super.last -> lastSuper[]).args[] <> none) and
                       (lastSuper.args.length = 0) then
                   true -> lastSuper.noArgsCheck
               if)
            #)
       #);
     Signature::< (# #);
     Arguments::< (# #);
     Value::<
       (# getQual:
            (# D: ^Decl; qual: ^ObjectGenerator 
            do scanSons(# do current[] -> D[] #);
               (* only works for one return value/decl *)
               D.getQual -> qual[];
               (if traceGetQual then
                   (if qual[] <> none then 
                       qual.doPT -> putline;
                    else 'none '->putline
               if)if);
            exit qual[]
            #)
       #);
     Include::<
       (# semcheck::
            (#
            do (if trx then
                   '**** include: ' -> puttext; dopt -> putline
               if)
            #);
          getQual::
            (# 
            do 'Include:getQual: '->puttext; dopt -> putline;
               (if son[] <> none then
                   scanSons
                   (# IV: ^Invocation
                   do (if isLAst then
                          'include:getqual:'-> puttext; doPT -> putline;
                          current[] -> IV[];
                          IV.getQual -> qual[]
               if)#)if)
            #);
       #);
     ObjectCall::<
       (# semCheck::
            (#
            do (if false then
                   '**** ObjectCall:semCheck: ' -> puttext; dopt -> putline
               if);
               (rec[],encOG[]) -> super.semCheck -> eOG[];
               true -> done
            #);
          getQual::
            (#
            do (if trx then 'ObjCall:getQual: ' -> puttext; doPT -> putline if);
               super.getQual -> qual[];
            #);
          getV_qual::
            (#
            do '*** ObjectCall:getV_qual: ' -> puttext; dopt -> putline
            #);
          pathToDcl::
            (#
            do (if false then
                   '*** ObjectCall:pathToDcl: ' -> puttext; dopt -> putline;
               if);
               P[] -> super.pathToDcl -> P[]
            #)
       #);
         
     ObjectGenerator::<
       (# semcheck::
            (#
            do (if trx then
                   '**** ObjectGenerator:semCheck:'->putline; dopt -> putline;
                   (if true then
                       '**   encOG: ' -> putline; 
                       (if encOG[] <> none then
                           encOG.doPT -> putline
                        else
                       'none' -> putline
               if)if)if);
               (if false then
                   (rec[],encOG[]) -> super.semCheck -> eOG[];
                   ('**** ObjGen:semCheck:super:eOG',eOG[]) -> display;
                   (if not IS.isEmpty then 
                       (rec[],this(ObjectGenerator)[]) -> IS.semCheck -> eOG[];
                   if);
                else
                   (rec[],encOG[]) -> super.semCheck -> eOG[];
                   ('**** ObjGen:semCheck:super:eOG',eOG[]) -> display;
                   (if not IS.isEmpty then 
                       (rec[],encOG[]) -> IS.semCheck -> eOG[];
                   if);                   
               if);
               true -> done;
            #);
          getV_Qual::
            (# Px: ^OGpath
            do (* Should only be called for singular OGs
                * If part of pattern decl, argScope may be wrong
                *)
               (if trx or traceGetV_qual or trace_pathToDcl then
                   '*** ObjectGenerator:getV_qual:shouldNotHappen' -> putline;
                   doPT -> putline
               if);
               (none,origin[],origin[],true) -> check;
               (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   (if traceGetV_qual then                   
                       '**** ObjectGenerator:getV_qual:' -> putline;
                       dopt -> putline;           
                   if);
                   (origin.father[],none,none,0,0,none) 
                     -> OGpath 
                     -> pathToDcl 
                     -> Px[];
                   (if traceGetV_qual then                   
                       '*** ObjectGenerator:after:pathToDcl:'-> putline;
                       Px.print;
                   if);
                   Px.qual[] -> qual[];
                else
                   (* is Singular *)
                   this(ObjectGenerator)[] -> qual[]
               if)                   
            #);
          pathToDcl::
            (# Px: ^OGPath
            do (if trace_PathToDcl then
                   '*** ObjectGenerator:pathToDcl:' -> putline; dopt -> putline;
                   (*P.print;*)
               if);
               (if IS.isEmpty Then
                   P[] -> super.pathToDcl -> P[]
                else 
                   (if origin.father[] = none then
                       'OG:pathToDcl:origin.father is none'->putline;
                   if);
                   (*(origin.father[],0,0,P[]) -> OGpath -> P[];*)
                   this(ObjectGenerator)[] -> (P[]-> Px[]).qual[]
               if)
            #);
          getQual::
            (# 
            do (if traceGetQual then
                   '*** ObjectGenerator:getQual:primNo: '->puttext; 
                   primNo -> putint; ' '-> put; 
                   IS.primNo -> putint; ' '-> put; 
                   (if super.ATd[] <> none then
                       super.Atd.primNo -> putint; ' '-> put; 
                   if);
                   ':isPrimitive: ' -> puttext; isPrimitive -> putboolean;
                   ':' -> put; doPT -> putline
               if);
               (* Should only be called for singular OGs
                * If part of pattern decl, argScope may be wrong
                *)
               (none,origin[],origin[],true) -> check;
               (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   L:  IS.scanAllItemDecls
                     (# DI: ^DataItem
                     do (if currentDcl.isOutArg then
                            (if currentDcl.isDAtaItem then
                                (currentDcl[] -> DI[]).getQual -> qual[];
                                leave L
                            if)
                        if)
                     #);
                   (if qual[] = none then
                       this(ObjectGenerator)[] -> qual[]
                   if)
               if);
               (*'qual:' -> putline; qual.dopT -> putline;*)
            #); 
          XinSuper: BooleanValue
            (# lQ: ^ObjectGenerator
            enter lQ[]
            do ('inSuper:lQ',lQ[]) -> display;
               ('rQ',lQ[]) -> display;
               L:
                 (if lQ[] = this(ObjectGenerator)[] then
                     true -> value 
                  else
                     (if (lQ[] <> none) then
                         (if (lQ.primNo <> object_prim) then
                             lQ.super.getQual -> lQ[];
                             (if lQ[] =  none then
                                 objectDecl.getQual -> lQ[]
                             if);
                             restart L;
                 if)if)if)
            #);
          isPtnOrSingular: BooleanValue
            (#
            do (if super.ATd[] <> none then
                   super.ATd.isPatternDecl -> value
                else
                   (* no super - must be singular *)
                   not IS.isEmpty -> value
               if)
            #);
       #);
     Items::<
       (# semCheck::
            (# checkInterfaceRestrictions:
                 (* This decl: must be a pattern (or virtual)
                  *    foo: entry(# do ... #)
                  * where entry in interface.rQual
                  * We also need to handle several levels
                  *    M0: (# foo: Q(# ... #); ... #)
                  *    M1: M0(# [interface[E]] E: (# ... #); ... #)
                  *    M2: M1(# [interface[F]] F: (# ... #); ... #)
                  *    M3: M2(# ... #)
                  * Do M1/M2-restrictions apply to M0?
                  * M2 further restricts subpatterns ...
                  * Methods in M2 are restricted by M1 but not M2
                  * For x: ^M3
                  *   x.bar -- if bar in M3 then all restrictions
                  *                   in M2, M1 restrictions
                  *            else no restrictions
                  *            if virtual, then restrictions at point of
                  *            original declaration apply
                  *            Probably different if argument restrictions 
                  *            are added
                  * THE ABOVE IS NOT IMPLEMENTED
                  *)
                 (# 
                 do (if false then
                        '**** checkInterface: ' -> puttext; 
                        (if sig[] <> none then sig.dopt -> putline if);
                        (if props.interface.length > 0 then
                            '**** has interface' -> putline
                    if)if);
                    (if superDesc[] <> none then
                        (if true -> hasInterfaceRestrictions then
                            (if false then
                                '**** Interface restrictions:\n' -> puttext;
                            if);
                            scanDecls
                            (#
                            do L:
                                 (#
                                 do scanInterface
                                    (# 
                                    do (if false then
                                           '**** check:\n' -> puttext;
                                           currentDcl.dopt -> puttext;
                                           '\n**   isSubOf:\n' -> puttext;
                                           current.dopt -> putline;
                                           current.ATd.OG.dopt -> putline;
                                       if);
                                       (if currentDcl.OG[] -> current.ATd.OG.inSuper then
                                           leave L
                                    if)#);
                                    currentDcl[] -> SemanticError
                                    (#
                                    do 'The pattern: "' -> msg;
                                       currentDcl.sig.dopt -> msg;
                                       '" must be a subppattern of: '
                                         -> msg;
                                       scanInterface
                                       (# i: @integer
                                       do (if (i +1 -> i) > 1 then ' or ' -> msg if);
                                          '"' -> msg;
                                          current.dopt ->msg; '"' -> msg
                    #)#)#)#)if)if)
                 #);               
               checkArgumentRestrictions:
                 (# nl: @boolean
                 do scanAllDecls
                    (# constraintsOK: @boolean
                    do (if currentDcl.isInArg then
                           true -> constraintsOK;  
                           (if newBasicProp.hasArguments then
                               (*'**** new prop:arguments: ' -> puttext;*)
                               (*newBasicProp.arguments.doPT -> putline;*)
                               L: newBasicProp.scanArguments
                                 (# 
                                 do 
                                    current.scanSons
                                    (# OI: ^ObjectInvocation
                                    do current[] -> OI[];
                                    (if false then
                                        '\n** checkARg: ' -> puttext; 
                                        currentDcl.dopt -> puttext;
                                        ' is: ' -> puttext; 
                                        current.dopt -> putline; 
                                    if);
                                    false -> constraintsOK;
                                (if true
                                 // 'immutable' -> OI.ptnId.T.equalNCS then
                                    (if false then
                                        '** isImmutable?' -> puttext;
                                    if);
                                    (if currentDcl.isImmutable then
                                        (if false then
                                            'Yes:immutable: ' -> puttext; 
                                            currentDcl.doPT -> putline;
                                        if);
                                        true -> constraintsOK;
                                        leave L
                                     else
                                        (* need arguments[value] *)
                                        (if currentDcl.OG.isValueObj then
                                            (if false then
                                                'Yes:immutable value: '
                                                  -> puttext;
                                                currentDcl.doPT -> putline;
                                            if);
                                            true -> constraintsOK;
                                            leave L
                                        if)
                                    if);
                                 // 'unique' -> OI.ptnId.T.equalNCS then
                                    (if currentDcl.OG.IS.isUnique then
                                        true -> constraintsOK;
                                        leave L
                                    if)
                                 else
                                    (* not yet complete! *)
                                if)#);
                                 #);
                               (if not constraintsOK then
                                   currentDcl[] -> Warning
                                   (#
                                   do 'Constraints not satisfied in: "' -> msg;
                                      currentDcl.dopt -> msg;
                                  '"\n     must be one of: ' -> msg; 
                                  newBasicProp.scanArguments
                                  (# i: @integer
                                  do (if (i + 1 -> i) > 1 then ' or ' -> msg if);
                                     current.doPT -> qmsg; 
                                  #);
                                  '\n'->msg
                               #)
                           if);
                            else
                           L: props.scanArguments
                             (#
                             do (if false then
                                    '\n** check: ' -> puttext; 
                                    currentDcl.dopt -> puttext;
                                    ' is: ' -> puttext; 
                                    current.dopt -> putline; 
                                if);
                                false -> constraintsOK;
                                (if true
                                 // 'immutable' -> current.T.equalNCS then
                                    (if false then
                                        '** isImmutable?' -> puttext;
                                    if);
                                    (if currentDcl.isImmutable then
                                        (if false then
                                            'Yes:immutable: ' -> puttext; 
                                            currentDcl.doPT -> putline;
                                        if);
                                        true -> constraintsOK;
                                        leave L
                                     else
                                        (* need arguments[value] *)
                                        (if currentDcl.OG.isValueObj then
                                            (if false then
                                                'Yes:immutable value: '
                                                  -> puttext;
                                                currentDcl.doPT -> putline;
                                            if);
                                            true -> constraintsOK;
                                            leave L
                                        if)
                                    if);
                                 // 'unique' -> current.T.equalNCS then
                                    (if currentDcl.OG.IS.isUnique then
                                        true -> constraintsOK;
                                        leave L
                                    if)
                                 else
                                    (* not yet complete! *)
                                if);
                             #);
                               (if not constraintsOK then
                                   currentDcl[] -> Warning
                                   (#
                                   do 'Constraints not satisfied in: "' -> msg;
                                      currentDcl.dopt -> msg;
                                  '"\n     must be one of: ' -> msg; 
                                  props.arguments.scanArguments
                                  (# i: @integer
                                  do (if (i + 1 -> i) > 1 then ' or ' -> msg if);
                                     current.doPT -> qmsg; 
                                  #);
                                  '\n'->msg
                               #)
                           if);
                           if);
                       if)
                    #);
                 #);               
               checkImmutability:
                 (#
                 do (if super.ATd[] <> none then
                        (if props.immutable and not superDesc.isImmutable then
                            props[] -> semanticError
                            (#
                            do 'An objectGenerator cannot be marked "immutable"'
                                 -> msg;
                               '\n     unless its superpattern is immutable'
                                 -> msg
                    #)if)if)
                 #)
            do (if trx then '**** Items:semCheck: ' -> putline if);
               this(Items).encOG[] -> encOG[] -> eOG[]; 
               (* perhaps a bad idea to use the same name here, encOG!? *)
               none -> rec[];
               checkArgumentRestrictions;
               checkInterfaceRestrictions;
               checkImmutability;
            #);
          hasInterfaceRestrictions: BooleanValue
            (# isFirst: @boolean
            enter isFirst
            do (if superDesc[] <> none then
                   false -> superDesc.hasInterfaceRestrictions -> value
               if);
               (if not value and not isFirst then
                   (if not (newBasicProp.hasIFR -> value) then
                       props.hasIFR -> value
                   (* else
                       '**** hasNewIFR: '->puttext; dopt -> putline*)
               if)if)
            #);
          scanInterface:
            (# current: ^Lexem(*Property*)
            do (if superDesc[] <> none then
                   &superDesc.scanInterface
                   (#
                   do current[] -> this(scanInterface).current[];
                      inner scanInterface
                   #);
                   (if newBasicProp.hasIFR then
                       newBasicProp.interface.args.scanSons
                       (# INV: ^Invocation; N: ^Name; OI: ^ObjectInvocation
                       do (if false then
                              '** arg: ' -> puttext; current.dopt -> putline;
                          if);
                          current.scanSons
                          (#do (if false then current.label -> putline; if);
                          (if current## = ObjectInvocation## then
                              current[] -> OI[]; OI.ATd[] -> OI.ptnId.ATd[];
                              OI.ptnId[] -> this(scanInterface).current[];
                              inner scanInterface
                          if)#)
                       #);
                    else
                   superDesc.props.interface.scanProps
                   (#
                   do currentProp[] -> this(scanInterface).current[];
                      inner scanInterface
                   #)if);
            if)#);
       #);
     Invocation::<
       (# semcheck::
            (#
            do (if trx then
                   '**** Invocation:semCheck: '-> puttext; dopt -> putline;
                   '**   encOG:' -> putline; 
                   (if encOG[] <> none then
                       encOG.doPT -> putline
                    else
                       'none' -> putline
                   if)
               if);
               none -> rec[]
            #);
          getV_Qual::
            (* R, R.x, R.S.x, ...
             * R.x
             * May be a super - which we dont know here
             *)
            (# E: ^Exp; 
            do (if traceGetV_qual then
                   '*** Invocation:getV_qual: ' -> puttext; dopt -> putline;
               if);
               scanSons
               (# 
               do (* we should call ... -> current.getV_Qual -> qual[]
                   * however, then getV_qual should return a new path
                   * perhaps in general return a path and 
                   * extract the qual from the path?
                   * Or just 2 functions: getPath -> P[] 
                   * and then P[] -> getV_qual
                   *)
                  current[] -> E[] 
               #);
              encOG[] -> E.getV_Qual -> qual[]
            #);
          pathToDcl::
            (# E: ^Exp
            do (if trx or trace_PathToDcl then
                   '*** Invocation:pathTo_dcl: ' -> puttext; dopt -> putline;
               if);
               scanSons(#do P[] -> current.pathToDcl -> P[] #)
            #);
          getQual::
            (# E: ^Exp; 
            do (if trx then 'Invocation:getQual:' -> puttext; doPT -> putline if);
               scanSons(# do current[] -> E[] #);
               ('Invocation:getQual',E[]) -> display;
               (if E[] <> none then
                   E.getQual -> qual[]
               if);
            #);
          getActualReceiver::
            (#
            do (last).getActualReceiver -> rec[]
            #)
       #);

     ObjectInvocation::<
       (# semCheck::
            (# checkIfReceiverInImmutable:
                 (# org: ^Items;
                 do receiver.ATd.OG.IS.origin[] -> org[];
                    (if org.isImmutable and 
                        ((receiver.on > 0) or (receiver.father.noOfSons > 2)) then
                        (* receiver, X, declared as in: 
                         *  MyPtn: ...
                         *    [immutable]
                         *    X: var integer
                         *    foo:
                         *       X:= 117 -- illegal, X.on > 0
                         *    X: = 118 -- legal X.on = 0
                         *   R: obj MyPtn
                         *   R.X := 119 -- illegal receiver.father.noOfSons > 2
                         *              -- ftaher is invocation with more than 2 sons
                         *              -- this is a fragile test, should be improved
                         *)
                        (if false then
                            '**** dst is in immutable OG ,rec: ' -> puttext;
                            rec.dopt -> putline;
                            (rec.enclosingObjectGenerator).dopt -> putline;
                        if);
                        this(ObjectInvocation)[] -> Warning
                        (#
                        do 'The data-item "' -> msg; rec.dopt -> msg;
                           '" is in an immutable object and cannot be assigned' -> msg
                        #)
                    if)
                 #);               
               receiver: ^Exp; ptn: ^Pattern; org: ^Items; 
               srcQual, dstQual,qual: ^ObjectGenerator; N: ^Node
            do (* rec = none if first OI in Invocation *)              
               (if trx then
                   '**** ObjectInvocation:semCheck: "' -> puttext;
                   doPT -> puttext; '" rec: "' -> puttext;
                   rec[] -> putDoPT; '"\n' -> puttext;
                   '**   encOG:\n' -> puttext; 
                   encOG[] -> putDoPT; newline
               if);
               (if ATd.primNo // rAssign_prim // vAssign_prim then
                   (* rec = receiver is defined *)
                   (if trx then 
                       '**** assign: ' -> puttext; rec.dopt -> putline;
                       '**   OI: ' -> putline; dopt -> putline;
                       (*'**   encOG: ' -> putline;
                        encOG.doPT -> putline*)
                       (*rec.origin.dopt -> putline*)
                   if);
                   rec[] -> receiver[];                   
                   checkIfReceiverInImmutable;
                   
                   (if receiver.ATd.primNo = this_prim then
                       '**   this:true'->putline
                   if);
                   args.scanArgs
                   (# i: @integer;
                      srcQual,dstQual,srcQual1,dstQual1: ^ObjectGenerator
                   do (if (i + 1 -> i) > 1 then
                          args[] -> semanticError
                          (#
                          do 'List too long to be assigned to: "' -> puttext;
                             receiver.doPT -> puttext; '"' -> put; newline
                          #)
                      if);
                      (* check that current can be assigned to receiver  *)
                      (none,specialEnclosingObjectGenerator)
                        -> current.semCheck 
                        -> srcQual[];
                      receiver.getQual -> dstQual[];
                      (if trx  then
                          '**   src: ' -> puttext; current.dopt -> putline;
                          '**   srcQual: ' -> putline; srcQual.dopt -> putline;
                          '**   dst: ' -> puttext; receiver.dopt -> putline;
                          '**   dstQual: ' -> putline; dstQual.dopt -> putline;
                      if);                      
                      receiver.getActualReceiver -> receiver[];
                      (current[],srcQual[],dstQual[],true) 
                        -> receiver.ATd.checkQual; 
                      (if trx then
                          '**** after receiver.ATd.checkQual: ' -> puttext;
                          receiver.dopt -> putline;
                      if);
                      (*enclosingObjectGenerator -> encOG[]*)
                      specialEnclosingObjectGenerator -> encOG[] -> eOG[];
                      true -> done
                   #)
                else 
                   (if ATd.primno
                    // inner_prim 
                    // restart_prim // leave_prim 
                    // indexedPut_prim then
                       true -> noArgsCheck
                    // ifThen_prim then
                    // this_prim then
                       (if trx then 
                           '**** got this: ' ->puttext; dopt -> putline;
                       if);
                       args.scanArgs
                       (#
                       do (if trx then 
                              '**  args: ' -> puttext; current.dopt -> putline
                          if);
                          current.getQual -> srcQual[] -> encOG[] -> eOG[];
                          (if trx then
                              '**  args:srcQual: ' -> putline;
                              srcQual.dopt -> putline; 
                          if);
                          true -> done
                       #);
                    else
                       (if (1 -> ptnId.T.inxGet) = '#' then
                           (* clean-up *)
                           (*'#PTN: '->puttext; ptnId.T[] -> putline*)
                        else
                           (if not noArgsCheck then
                               (if false then
                                   (args[],specialenclosingObjectGenerator,this(ObjectInvocation)[]) 
                                     -> ATd.checkActualArgs;
                                else
                                   (args[],encOG[],this(ObjectInvocation)[]) 
                                     -> ATd.checkActualArgs;    
                               if);
                               true -> done
                       if)if);
                       (if (origin[] <> none) then
                           (if trx then 
                               '**   ObjectInvocation:compute:eOG:for: '
                                 -> puttext;
                               dopt -> putline;
                               '**   label: ' -> puttext; label -> puttext;
                               ' from:encOG: ' -> puttext;
                               encOG.dopt -> putline
                           if);
                           (if false then
                              specialenclosingObjectGenerator 
                                 -> getV_qual 
                                 -> qual[] -> encOG[] -> eOG[];
                            else
                               encOG[] -> getV_qual -> qual[] -> encOG[] -> eOG[];
                           if);
                           (if trx then
                               '**  ObjInv:semCheck:qualOf: ' -> puttext;
                               dopt -> putline;
                               (if qual[] <> none then
                                   qual.dopt -> putline
                                else
                                   'none' -> putline
                               if)
               if)if)if)if);
               (*false -> trx *)
            #);
          getV_Qual::
            (* The primary entry to computing virtual bindings as part
             * of a qualification
             * Called from checker::ObjectInvocation:check
             * enter arg: encOG = enclosing ObjectInvocation
             * Cases:   R.foo where R: ref V and V:< T
             *                or R: ref W and W: { ... out R: ref V ... } 
             *          Q(e).bar where Q: { ... out R: ref V ...}
             *)
            (# Px: ^OGpath; DI: ^DataItem; MI: ^ModuleItem; ptn: ^Pattern
            do (if trx or traceGetV_qual then
                   '**** ObjectInvocation:getV_qual:' -> putline; 
                   (if true then
                       dopt -> putline;
                       '**   EncOG: ' -> putline;
                       (if encOG[] <> none then encOG.doPT -> putline if)
                   if)
               if);  
               (if (ATd.getV_qual -> qual[]) = none then
                   (* qual[] <> none: no virtuals involved and qua is correct
                    * qual[] = none: a virtual is involed: compute most
                    * specific bind as shown below
                    *)
                   (if trx or trace_pathToDcl then
                       '\n**   ObjectInvocation:getV_qual:handle:virtual:' -> putline;
                   if);
                   (encOG[],ATd[],this(ObjectInvocation)[],on,pn,none) 
                     -> OGpath 
                     -> ATd.pathToDcl 
                     -> Px[];
                   (if trx or traceGetV_qual then
                           '*** ObjectInvocation: found path:'->putline;
                       Px.print;
                   if);
                   Px.getQual -> qual[];
               if);
               (if traceGetV_qual then
                   '*** ObjectInvocation:QUAL:OF: "'->puttext;
                   dopt -> puttext; '" IS: '->putline; qual.label -> putline;
                   (if qual[] <> none then
                       qual.doPT -> putline; 
                       'father.father.father: ' -> putline;
                       qual.father.father.father.dopt -> putline;
                    else
                       'none'->putline
               if)if)
            #);
          pathToDcl::
            (#
            do (* we should append the path to ATd *)
               (if trx or trace_PathToDcl then
                   '*** ObjectInvocation:pathToDcl:' -> putline; dopt-> putline;
               if);
               (if ATd[] = none then  
                   'ATD[] = none for:' -> putline;
                   dopt -> putline;
                   origin.father.dopt -> putline
               if);
               (if false then
                   P[] -> ATd.pathToDcl -> P[]
                else                   
                   (origin.father[],ATd[],this(ObjectInvocation)[],on,pn,P[])
                     -> OGpath -> ATd.pathToDcl -> P[];
               if)
            #); 
          getQual::
            (#
            do (if trx or traceGetQual then
                   '*** ObjectInvocation:getQual: ' -> puttext;
                   dopt->putline
               if);
               (*(if (ATd[] <> none) then ATd.primNo -> putint if);
               ' ' -> put; doPT -> putline;*)
               (if (ATd[] <> none) and (ATd.primNo = this_Prim) then
                   (* move to Apl:getQual*)
                   args.scanArgs
                   (# IV: ^ObjectSpecification
                   do current[] -> IV[]; IV.getQual -> qual[];
                      (* IV.doPT -> putline; qual.doPT -> putline*)
                   #);
                   ('Keyword:getQual:this_prim', qual[])->display;
               if);
               (if ATd[] <> none then
                   (if ATd.isVirtual then
                       ATd.getQual -> qual[]
               if)if);
               (if trx or traceGetQual then
                   (if qual[] <> none then
                       qual.doPT -> putline
               if)if)
            #);      
          getActualReceiver::
            (#
            do (if ATD.primNo = this_prim then
                   args.scanSons
                   (# i: @integer; OG: ^ObjectGenerator
                   do (if (i + 1 -> i) = 2 then
                          (*'** primArg:'->puttext; current.doPT -> putline;*)
                          ((current[] -> OG[]).super).last -> rec[]
                      if)
                   #)
               if)
            #)
       #);
     BracketedExp::<
       (# getQual::
            (# 
            do IV.getQual -> qual[] 
            #);
          pathToDcl:: 
            (# Px: ^OGpath 
            do P[] -> IV.pathToDcl -> P[];
               
            #);
          getActualReceiver::
            (#
            do IV.getActualReceiver -> rec[];
            #);
       #);
     Const::<
       (# semcheck::
            (#
            do (if false then
                   '**** IntegerObj:semcheck:' -> puttext; dopt -> putline
               if);
               integerDecl.OG[] -> encOG[] -> eOG[];
            #);
          getV_qual::
            (#
            do  integerDecl.getQual -> qual[]; '**** IntegerQual:' -> putline;
                         qual.dopt -> putline
            #);
          getQual:: (#do integerDecl.getQual -> qual[] #);           
          pathToDcl::
            (# Px: ^OGpath
            do IntegerDecl.OG[] -> (P[]->PX[]).qual[]
            #)
       #);
     FloatConst::<
       (# semCheck:: (# do floatDecl.OG[] -> encOG[] -> eOG[] #);
          getV_qual:: (# do #);
          getQual:: (# do floatDecl.getQual -> qual[] #);
          pathToDcl::
             (# Px: ^OGpath
            do FloatDecl.OG[] -> (P[]->PX[]).qual[]
             #)
       #);
     CharObj::<
       (# semcheck::
            (#
            do (if false then
                   '**** CharObj:semcheck:' -> puttext; dopt -> putline
               if);
               charDecl.OG[] -> encOG[] -> eOG[]
            #);
          getV_qual::
            (#
            do charDecl.getQual -> qual[]; '**** CharQual:' -> putline;
               qual.dopt -> putline
            #);
          getQual:: (#do charDecl.getQual -> qual[] #); 
       #);
     StringObj::< 
       (# semcheck::
            (#
            do (if false then
                   '**** StringObj:semcheck:' -> puttext; dopt -> putline
               if);
               stringDecl.OG[] -> encOG[] -> eOG[]
            #);
          getV_qual:: 
            (# do stringDecl.getQual -> qual[]; '**** StringQual:' -> putline;
                         qual.dopt -> putline
            #); 
          getQual:: (#do stringDecl.getQual -> qual[] #); 
          pathToDcl::
            (# Px: ^OGpath
            do StringDecl.OG[] -> (P[]->PX[]).qual[]
            #)
       #);
     
  do '**** SEMCHECK ****' -> putline;
     (*true -> trx;*)
     main (*rootModule*).semCheck;
     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline
      else
         inner
     if)
  #)
