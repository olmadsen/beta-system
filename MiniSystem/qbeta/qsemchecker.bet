ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qchecker';
INCLUDE 'qvirtual'
---lib:attributes---
checkRecursive: (# exit true #);
semchecker: checker
  (# Module::<
       (# semcheck:: 
            (# encModule:
                 (# org: ^Items; 
                 do (if origin[] <> none then
                        (origin[] -> org[]).theModule -> M[]
                    if)
                 exit M[]
                 #);
               M: ^Module;
            do (*'Module:semCheck:'->puttext; DI.sig.id[] -> putline;*)
               (if (encModule -> M[]) <> none then
                   M.semCheck
               if)
            #)
       #);
     ModuleItem::<
       (# semCheck::
            (#
            do (if not MD.isIncluded then
                   (*'Module not included: ' -> putline; doPT -> putline;*)
                   false -> doCheck
               if)
            #);          
          getQual:: 
            (# do (*'ModuleItem:getQual: ' -> puttext; dopt -> putline;*)
               md.DI.getQual -> qual[]
            #);
          pathToDcl::
            (#
            do (if traceGetV_qual then
                   '*** ModuleItem:pathToDcl:' -> putline;
                   sig.doPT -> putline;
               if);
               P[] -> md.DI.pathToDcl -> P[]
            #)
       #);
     DataItem::<
       (# getV_qual::
            (#
            do OG.getV_Qual -> qual[];
               (if ('R_test'-> sig.id.equal) then
                   'Decl:GetV_qual: ' -> puttext; dopt -> putline
               if);
            #);
          pathToDcl::
            (* X: ?T, R: ?V where V:< Q
             * Y: = T{...}
             *)
            (#
            do (if traceGetV_qual then
                   '*** DataItems:pathToDcl:' -> putline;
                   doPT -> putline;
               if);               
               P[]-> OG.pathToDcl -> P[]
            #);
          getQual:: 
            (# 
            do OG.getQual -> qual[];
               (*'***** DI:getQual: ' -> puttext; doPT -> putline;
               'Qual: ' -> puttext; qual.dopt -> putline*)
            #);
          semCheck::
            (* Check that in S : ? T, V: = T, T is a pattern
             * it seems to work for singular patterns, but check if this is so!
             *)
            (#
            do (if OG.isPtnOrSingular then
                   not isConst or isArg -> noArgsCheck;
                   (* see qabstractSyntaxTree::semCheck
                    * if noArgsCheck, the sons are not checked
                    * Is this correct?
                    *)
                   (if isValue then
                       (if not (OG.isValueObj or isBasic) then 
                           this(DataItem)[] -> SemanticError
                           (#
                           do 'The qualification "' -> msg;
                              OG.doPT -> msg;
                              '" must be a value pattern' -> msg;
                           #)
                       if)
                    else
                       (if OG.isValueObj then 
                           this(DataItem)[] -> SemanticError
                           (#
                           do 'The qualification "' -> msg;
                              OG.doPT -> msg;
                              '" must be an object pattern' -> msg;
                           #)                           
                       if)
                   if)
                else
                   (if OG.super.ATd[] <> none then
                       OG.super.ATd.doPT -> putline;
                    else
                       OG.father.doPT -> putline
                   if);
                   this(DataItem)[] -> SemanticError
                   (#
                   do 'The qualification "' -> msg;
                      OG.doPT -> msg;
                      '" must be a pattern '-> msg;
                   #)
               if)
            #);
          checkQual::                               
            (* Note: left / right is from Beta: Left -> Right
             * we should swith for qbeta: Right := Left
             * This applies to rQual, lQual, and messages
             * Perhaps use dest/source or ...
             *)
            (# error:
                 (#
                 do (if reportSemErr then
                        lOG[] -> semanticError
                        (#
                        do '"'->put; lOG.doPT -> puttext;
                           '" cannot be assigned to "' -> puttext;
                           doPT -> puttext; '"' -> put; newline;
                 #)if)#);
               lQual,rQual: ^ObjectGenerator
            do (if traceGetQual then
                   '\n>>> DataItem:checkQual:' -> puttext; 
                   (if isConst then ':C:' -> puttext if);
                   (if isAssign then ' := ' -> puttext if);
                   ('Left',lOG[]) -> display;
                   ('Right',this(DataItem)[]) -> display; 
               if);
               (if lOG[] <> none then 
                   lOG.getQual -> lQual[] (* none if string " ..." *)
                else
                   '>>> lOG none' -> putline
               if);
               getQual -> rQual[];
               ('lQual',lQual[]) -> displayB; (* there is also a Display *)
               ('rQual',rQual[]) -> displayB;
               (if isConst and isAssign then 
                   (* OG is lef-part of assign as in aPoint1 := aPoint2 *)
                   (if OG.isValueObj then
                    else
                       error
                   if)
                else
                   (if true
                    // OG.isSimpleValue then
                       (* OG[] -> rQual[];*)
                       (if lQual[] <> none then
                           (if lQual.primNo
                            // integer_prim then
                               (if rQual.primNo 
                                // integer_prim // char_prim // boolean_prim then
                                else
                                   error
                               if)
                            // char_prim then
                               (if rQual.primNo // integer_prim // char_prim then
                                else
                                   error
                               if)
                            // boolean_prim then
                               (if rQual.primNo // boolean_prim // integer_prim then 
                                else
                                   error 
                               if)
                            else
                               error
                           if)
                        else
                           error
                       if)  
                    // OG.isValueObj then
                       (* '\n***Got valueObj:'-> puttext; 
                        OG.dopt -> putline;
                        lQual.dopt -> putline;
                        rQual.dopt -> putline;
                       '---'->putline;*)
                       (if true
                        // lQual[] = rQual[] then (* OK *)
                        // lQual[] -> rQual.inSuper then 
                           lOG[] -> Warning
                           (# 
                           do 'The right-side value: "' -> msg;
                              lOG.doPT -> msg;
                              '" is truncated ' -> msg;
                              '\n\twhen assigned to the left-side variable: "' -> msg;
                              doPT -> msg;
                              '"' -> msg
                           #);
                           lQual.dopt -> putline;
                           rQual.dopt -> putline;
                        else
                           (if lOG.primNo = indexedGet_prim then
                               (*'indexGet_prim'->putline*)
                               (* fix that the type of the indexed DI is consistent
                                * with the left-side
                                * *)
                            else
                               (* we should spell out wheter or not lOG, etc
                                * are objectRefs or valueObjs *)
                               lQual.dopt -> putline;
                               rQual.dopt -> putline;
                               lOG[] -> semanticError
                               (#
                               do 'The expression:\t"' -> puttext;
                                  lOG.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' 
                                    -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                       #)if)if)
                    else
                       (* getQual -> rQual[];*)
                       (if true
                        // lOG.isValueObj then
                           lOG[] -> semanticError
                               (#
                               do 'The value expression: "' -> msg;
                                  lOG.doPT -> msg;
                                  '"\n     cannot be assigned to '-> msg;
                                  'the object reference: "' -> msg;
                                  doPT -> msg; '"' -> msg
                               #);
                        // lQual[] -> rQual.inSuper then (* OK *)
                        // (lQual[] <> none) and (rQual[] -> lQual.inSuper) then
                           lOG[] -> QuaCheck
                           (# 
                           do 'It must be checked at run-time that "'
                                -> puttext;
                              lOG.doPT -> puttext;
                              '"\n     is a subpattern of "' -> puttext;
                              doPT -> puttext; '"' -> put; newline
                           #)
                        // (lQual[] <> none) and (lQual.primNo = none_prim) then
                        else
                           (if reportSemErr then
                               lOG[] -> semanticError
                               (#
                               do 'The reference expression:\t"' -> puttext;
                                  lOG.doPT -> puttext;
                                  '"\n     cannot be assigned to:\t"' -> puttext;
                                  doPT -> puttext; '"' -> put; newline
                               #);
               if)if)if)if)
            #);
       #);
     isPatternDen:< BooleanValue
       (# E: ^Exp
       enter E[]  
       do E.ATd.doPT -> putline;
          (if E.ATd[] <> none then E.ATd.isPatternDecl -> value if)
       #); 
     pattern::<
       (# checkActualArgs::
            (# A: [6] ^Decl; inx,top: @ integer;
            do (if traceGetQual then
                   '\nCheck: ' -> puttext; actualArgs.doPT -> putline;
                   '  against: ' -> puttext; sig.doPT -> putline;
               if);
               scanArgs
               (#
               do (if (top + 1 -> top) > A.range then A.range -> A.extend if);
                  currentArg[] -> A[top][];
               #);
               actualArgs.scanArgs
               (# 
               do inx + 1 -> inx; 
                  (if inx > top then
                      actualArgs[] -> SemanticError
                      (# 
                      do 'More actual parameters:\n\t"' -> msg;
                         actualArgs.doPT -> msg; 
                         '"\n    than formal parameters:\n\t"' -> msg;
                         sig.doPT -> msg; '"' -> msg
                      #)
                   else
                      (current[],false) -> A[inx].checkQual;
                  if);
               #); 
               (if (inx < top)  then
                   actualArgs[] -> SemanticError
                   (# 
                   do 'More formal than actual parameters' -> msg;
                      actualArgs.doPT -> msg;
                      '\n'-> msg;
                      sig.doPT -> msg;
                   #)
               if);
            #);
          getV_Qual ::
            (* P: S ... 
             * F(...): G ...
             * A(...) -> V: ? T: S ...
             * + virtual
             *    V:< A
             *    V::< A
             *    V:: A
             * + recursive
             *   foo(...) -> V: ? bar: ...
             *   bar(...) -> R: ? foo: ...
             *)
            (#
            do getQual -> qual[];
               (if isVirtual then
                   (* V:< Q;
                    * W:< Q{ ... }
                    *)
                   'Virtual: ' -> puttext; dopt -> putline;
                   (*P.print;*)
                   OG.getV_qual -> qual[]
                else
                   (* P(...) -> V: ? S: { .... } *)
               if)
            #);
          pathToDcl::
                 (* P: S{...}
                  * V:< A{ ... }
                  * V:< A;
                  * V::< ...
                  * V:: ...
                  *)
            (# Px: ^OGpath; qual: ^ObjectGenerator
            do OG[] -> (P[]->Px[]).qual[]; (* just ad hoc *)
               this(Pattern)[] -> (P[]->Px[]).vDcl[]; (* just ad hoc *)
               (if traceGetV_qual then
                   '*** Pattern:pathToDcl: '->puttext;
                   sig.dopt -> putline;               
                   P.print;
               if);
               (*(P[]-> Px[]).getQual ;*)
               (if isRec then 
                   '**** isRecursive'->putline;
                   OG[] -> (P[]-> Px[]).qual[];
                   leave pathToDcl
               if);
               true -> isRec;
               (* this is probably just a hack 
                * - we need to handle virtuals as in the Beta compiler
                *)
               (if P[] <> none then
                   sig.getExplicitQual -> qual[];
                else
                   'P is none: ' -> putline; dopt -> putline
               if);
               (if qual[] = none then
                   (if isVirtual then
                       (*(OG[],0,0,P[]) -> OGpath -> P[];*)
                       (P[]-> Px[]).getQual ;
                       (*P[] -> OG.pathToDcl -> P[]*)
                    else              
                       OG[] -> (P[]-> Px[]).qual[];
                       (*(origin.father[],0,0,P[]) -> OGpath -> P[]*)
                   if)
                else
                   qual[] -> (P[]-> Px[]).qual[]
               if);
               false -> isRec;
            #);
          getQual::
            (# 
            do (if traceGetQual then
                   '*** Pattern:getQual: '-> puttext; sig.doPT -> putline
               if);
               (if (*not isChecked and*) checkRecursive then 
                   (* this code makes no sense: 
                    * checkRecursive just exits true
                    *
                   (if traceCheck then
                       '\n>>> Pattern not checked: ' -> puttext; 
                       sig.doPT -> putline
                   if);*)
                   (none,origin[],origin[],true) -> check
               if);
               (if isRecursive then
                   (* For a pattern
                    *    foo(...) -> res: ? foo ...
                    * getQual is called on the foo return value
                    * giving a recursive call of getQual
                    *)
                   (if traceGetQual then
                       '*** isRecursive' -> putline
                   if);
                   OG[] -> qual[];
                   (*false -> isRecursive;*)
                   leave getQual
               if);
               inner;
               (if traceGetQual then
                   'Pattern getQual:B: "' -> puttext; 
                   sig.doPT -> puttext; '"' ->put; newline
               if);
               true -> isRecursive;
               (* this is probably just a hack 
                * - we need to handle virtuals as in the Beta compiler
                *)
               sig.getExplicitQual -> qual[];
               L:
                 (if qual[] = none then
                     (if isVirtual then
                         (*'*** Virtual: ' -> puttext; dopt -> puttext; 
                          ' on: ' -> puttext; OG.super.on -> putint;
                          ' pn: ' -> puttext; OG.super.pn -> putint; newline;*)
                         OG.getQual -> qual[];
                         (if traceGetQual then
                             'getQual:Virtual: ' -> puttext; 
                             qual.doPT -> putline;
                             OG.doPT -> putline
                         if)
                      else
                         (if traceGetQual then
                             'Pattern:getQual:C:' -> putline;
                         if);
                         OG.IS.scanAllItemDecls
                         (# DI: ^DataItem
                         do (if currentDcl.isOutArg then
                                (if currentDcl.isDAtaItem then
                                    (currentDcl[] -> DI[]).getQual -> qual[];
                                    leave L;
                                if)
                            if)
                         #);                       
                         OG[] -> qual[];
                 if)if);
               false -> isRecursive;
               (if traceGetQual then
                   'GetQual:Pattern:D: "\n' -> puttext; 
                   (if qual[] <> none then 
                       qual.doPT -> puttext
                    else 'none'->puttext
                   if);
                   '"' -> put; newline
               if)
            #);
          semCheck::
            (# lastSuper: ^Exp
            do (if (OG.super[] <> none)
                   and ((OG.super.last -> lastSuper[]).args[] <> none) and
                       (lastSuper.args.length = 0) then
                   true -> lastSuper.noArgsCheck
               if)
            #)
       #);
     Signature::<
       (# checkActualArgs:
            (# actualArgs: ^Arguments
            enter actualArgs[]
            do (if args[] <> none then
                   actualArgs[] -> args.checkActualArgs
                else
                   (if traceGetQual then
                       'Signature:checkActualArgs: args is none: ' -> puttext;
                       this(Signature).doPT -> putline;
                       ' actuals: ' -> puttext;
                       actualArgs.doPT -> putline
                   if)
               if)
            #);
          getExplicitQual:
            (* Returns qual of possible explicit return value
             * GetQual returns this as default if no explict return is defined
             * Also try superchain 
             *)
            (# qual: ^ObjectGenerator;  ptn: ^Pattern
            do (if val[] <> none then 
                   val.getQual -> qual[] 
                else
                   father[] -> ptn[];
                   (if (ptn.OG.super.ATd[] -> ptn[]) <> none then
                       ptn.sig.getExplicitQual -> qual[]
                if)if)                           
            exit qual[]
            #);
          getQual:: 
            (# ptn: ^Pattern
            do (if traceGetQual then
                   'Signature:getQual: "\n' -> puttext; dopt->puttext;
                   '"' -> put; newline
               if);
               getExplicitQual -> qual[];
               L:
                 (if qual[] = none then
                     (* no return value - use %this P *)
                     father[] -> ptn[];
                     ptn.OG.IS.scanAllItemDecls
                     (# DI: ^DataItem
                     do (if currentDcl.isOutArg then
                            (if currentDcl.isDAtaItem then
                                (currentDcl[] -> DI[]).getQual -> qual[];
                                leave L
                            if)
                        if)
                     #);
                     (father[] -> ptn[]).OG[] -> qual[]
                 if);
            #);
       #);
     Arguments::<
       (# checkActualArgs:
            (# args: ^Arguments; A: [6] ^Decl; inx,top: @ integer
            enter args[]
            do (if traceGetQual then
                   '\nCheck: ' -> puttext; args.doPT -> putline;
                   '  against: ' -> puttext; this(Arguments).doPT -> putline;
               if);               
               scanArgs
               (# 
               do (if (top + 1 -> top) > A.range then A.range -> A.extend if);
                  current[] -> A[top][] 
               #);
               L:
                 args.scanArgs
                 (# 
                 do inx + 1 -> inx; 
                    (if inx > top then
                        (* try possible super *)
                        '\n*** More actual parameters:\n\t' ->puttext;
                        args.doPT -> puttext;
                        '\n    than formal parameters: \n\t' -> puttext;
                        this(Arguments).doPT -> putline;
                        leave L;
                     else
                        (current[],false) -> A[inx].checkQual;
                    if);
                 #);
               (if (inx < top)  then
                   (* problem for integer versus integer(18)
                    * and probably String ...
                    *)
                   '\n*** More formal than actual parameters' -> putline;
                   args.doPT -> putline;
                   this(Arguments).doPT -> putline;
               if);
            #);
       #);
     Value::<
       (# getQual:
            (# D: ^Decl; qual: ^ObjectGenerator 
            do scanSons(# do current[] -> D[] #);
               (* only works for one return value/decl *)
               D.getQual -> qual[];
               (if traceGetQual then
                   'Value: ' -> puttext;
                   D.doPT -> putline;
                   (if qual[] <> none then 
                       qual.doPT -> putline;
                    else 'none '->putline
               if)if);
            exit qual[]
            #)
       #);
     Include::
       (# getQual::
            (# 
            do 'Include:getQual: '->puttext; dopt -> putline;
               (if son[] <> none then
                   scanSons
                   (# IV: ^Invocation
                   do (if isLAst then
                          'include:getqual:'-> puttext; doPT -> putline;
                          current[] -> IV[];
                          IV.getQual -> qual[]
               if)#)if)
            #);
       #);
     ObjectGenerator::<
       (# getV_Qual::
            (# Px: ^OGpath; ITx: ^Items
            do (if true (*not isChecked*) then 
                   (if traceGetQual then
                       'ObjectGenerator is not checked: ' -> putline;
                   if);
                   (* Should only be called for singular OGs
                    * If part of pattern decl, argScope may be wrong
                    *)
                   (none,origin[],origin[],true) -> check
               if);
               (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   '**** ObjectGenerator:getV_qual:' -> putline;
                   dopt -> putline;                       
                   (origin.father[],0,0,none) 
                     -> OGpath 
                     -> pathToDcl 
                     -> Px[];
                   '*** ObjectGenerator:after:pathToDcl:'-> putline;
                   Px.print;
                   Px.qual[] -> qual[];
                else
                   (* is Singular *)
                   this(ObjectGenerator)[] -> qual[]
               if)                   
            #);
          pathToDcl::
            (# Px: ^OGPath
            do (if traceGetV_qual then
                   '*** ObjectGenerator:pathToDcl:' -> putline; dopt -> putline
               if);
               (if IS.isEmpty Then
                   P[] -> super.pathToDcl -> P[]
                else
                   (if origin.father[] = none then
                       'OG:pathToDcl:origin.father is none'->putline;
                   if);
                   (origin.father[],0,0,P[]) -> OGpath -> P[];
                   this(ObjectGenerator)[] -> (P[]-> Px[]).qual[];
               if)
            #);
          getQual:
            (# qual: ^ObjectGenerator 
            do (if traceGetQual then
                   '*** ObjectGenerator:getQual: '->puttext; doPT -> putline
               if);
               (if true (*not isChecked*) then 
                   (if traceGetQual then
                       'ObjectGenerator is not checked: ' -> putline;
                   if);
                   (* Should only be called for singular OGs
                    * If part of pattern decl, argScope may be wrong
                    *)
                   (none,origin[],origin[],true) -> check
               if);
               (if IS.isEmpty then
                   (* super (Invocation) may be object or pattern *)
                   super.getQual -> qual[]
                   (* qual = E3.ATd.getQual *)
                else
                   (* is Singular *)
                   this(ObjectGenerator)[] -> qual[]
               if)
            exit qual[]
            #); 
          XinSuper: BooleanValue
            (# lQ: ^ObjectGenerator
            enter lQ[]
            do ('inSuper:lQ',lQ[]) -> display;
               ('rQ',lQ[]) -> display;
               L:
                 (if lQ[] = this(ObjectGenerator)[] then
                     true -> value 
                  else
                     (if (lQ[] <> none) then
                         (if (lQ.primNo <> object_prim) then
                             lQ.super.getQual -> lQ[];
                             (if lQ[] =  none then
                                 objectDecl.getQual -> lQ[]
                             if);
                             restart L;
                 if)if)if)
            #);
          isPtnOrSingular: BooleanValue
            (#
            do (if super.ATd[] <> none then
                   super.ATd.isPatternDecl -> value
                else
                   (* no super - must be singular *)
                   not IS.isEmpty -> value
               if)
            #);
       #);
     Invocation::<
       (# checkInv:
            (# E: ^Exp; 
            do (* should check path *)
               scanSons(# do current[] -> E[] #);
            exit E[]
            #);
          getV_Qual::
            (* R, R.x, R.S.x, ...
             * R.x
             * May be a super - which we dont know here
             *)
            (# E: ^Exp; 
            do '*** Invocation:getV_qual: ' -> puttext; dopt -> putline;
               scanSons
               (# 
               do (* we should call ... -> current.getV_Qual -> qual[]
                   * however, then getV_qual should return a new path
                   * perhaps in general return a path and 
                   * extract the qual from the path?
                   * Or just 2 functions: getPath -> P[] 
                   * and then P[] -> getV_qual
                   *)
                  current[] -> E[] 
               #);
              E.getV_Qual -> qual[]
            #);
          pathToDcl::
            (# E: ^Exp
            do (if traceGetV_qual then
                   '*** Invocation:pathTo_dcl: ' -> puttext; dopt -> putline;
               if);
               scansons
               (#
               do current[] -> E[] (* see getV_qual comment *);
               #);
               P[] -> E.pathToDcl -> P[];
            #);
          getQual::
            (# E: ^Exp; 
            do (* 'Invocation:' -> puttext; doPT -> putline;*)
               scanSons(# do current[] -> E[] #);
               ('Invocation:getQual',E[]) -> display;
               E.getQual -> qual[]
            #);
       #);
     ObjectInvocation::<
       (# semCheck::
            (# receiver: ^Exp; ptn: ^Pattern
            do (*'>>> ObjectInvication:semCheck: rec: ' -> puttext;
               rec.doPT -> puttext;
                ' <- ' -> puttext; args.doPT -> puttext;*)
               (if (ATd.primNo <> rAssign_prim) and (ATd.primNo <> vAssign_prim) then
                   (*' Atd: ' -> puttext; ATd.doPT -> putline;*)
                   (if ATd.primno
                    // inner_prim //this_prim
                    // restart_prim // leave_prim 
                    // indexedPut_prim  then
                       true -> noArgsCheck
                    // ifThen_prim then
                    else
                       (if (1 -> ptnId.T.inxGet) = '#' then
                           (* clean-up *)
                           (*'#PTN: '->puttext; ptnId.T[] -> putline*)
                        else
                           (if not noArgsCheck then
                               args[] -> ATd.checkActualArgs
                       if)if)
                   if)
                else
                   (* pattern is assignment := *)
                   (*' Q:= rec.ATd: ' -> puttext;*)
                   rec[] -> receiver[];
                   (*receiver.Atd.doPt -> putline;*)
                   args.scanArgs
                   (# i: @integer
                   do (if (i + 1 -> i) > 1 then
                          args[] -> semanticError
                          (#
                          do 'List too long to be assigned to: "' -> puttext;
                             receiver.doPT -> puttext; '"' -> put; newline
                          #)
                      if);
                      (*current.dopt -> putline;*)
                      (current[],true) -> receiver.ATd.checkQual 
                   #);
               if)
            #);
          getV_Qual::
            (# Px: ^OGpath
            do (if traceGetV_qual then
                   '*** ObjectInvocation:getV_qual:' -> putline; 
                   dopt -> putline;
                   'EncOG: ' -> putline;
                   encOG.doPT -> putline
               if);
               (encOG[],on,pn,none) -> OGpath -> Px[];
               Px[] -> ATd.pathToDcl -> Px[];
               (*pathToDcl -> Px[];*)
               (if traceGetV_qual then
                   '*** ObjectInvocation: found path:'->putline;
                   Px.print;
               if);
               Px.qual[] -> qual[];
               (if traceGetV_qual then
                   '*** ObjectInvocation:QUAL:OF: "'->puttext;
                   dopt -> puttext; '" IS: '->putline; qual.label -> putline;
                   (if qual[] <> none then
                       qual.doPT -> putline; 
                       'father.father.father: ' -> putline;
                       qual.father.father.father.dopt -> putline;
                    else
                       'none'->putline
               if)if)
            #);
          pathToDcl::
            (#
            do (* we should append the path to ATd *)
               (if traceGetV_qual then
                   '*** ObjectInvocation:pathToDcl:' -> putline; dopt-> putline;
               if);
               (if ATd[] = none then  
                   'ATD[] = none for:' -> putline;
                   dopt -> putline;
               if);
               (origin.father[],on,pn,P[]) -> OGpath -> ATd.pathToDcl -> P[];
            #); 
          getQual::
            (#
            do (if traceGetQual then
                   '*** ObjectInvocation:getQual: ' -> puttext;
                   dopt->putline
               if);
               (*(if (ATd[] <> none) then ATd.primNo -> putint if);
               ' ' -> put; doPT -> putline;*)
               (if (ATd[] <> none) and (ATd.primNo = this_Prim) then
                   (* move to Apl:getQual*)
                   args.scanArgs
                   (# IV: ^ObjectGenerator
                   do current[] -> IV[]; IV.getQual -> qual[];
                      (* IV.doPT -> putline; qual.doPT -> putline*)
                   #);
                   ('Keyword:getQual:this_prim', qual[])->display;
               if);
               (if ATd[] <> none then
                   (if ATd.isVirtual then
                       ATd.getQual -> qual[]
               if)if);
               (if traceGetQual then
                   (if qual[] <> none then
                       qual.doPT -> putline
                    else
                       'qual is none' -> putline
               if)if)
            #);          
       #);
     BracketedExp::<
       (# getQual::
            (# 
            do IV.getQual -> qual[] 
            #);
          pathToDcl:: 
            (# Px: ^OGpath 
            do P[] -> IV.pathToDcl -> P[];
               
            #);
       #);
     Const::<
       (# pathToDcl::
            (# Px: ^OGpath
            do IntegerDecl.OG[] -> (P[]->PX[]).qual[]
            #)
       #);
     StringObj::< 
       (# getQual:: (#do stringDecl.getQual -> qual[] #); 
          pathToDcl::
            (# Px: ^OGpath
            do StringDecl.OG[] -> (P[]->PX[]).qual[]
            #)
       #);
     
  do '**** CHECKER   ****' -> putline;
     main (*rootModule*).semCheck;
     (if semanticErrors then
         '\n***** Semantic errors: compilation stops' -> putline
      else
         inner
     if)
  #)
