ORIGIN 'qparser'
---pStatement:doPart---
   (*
    <Item>		::= <Decl> | <Statement> | <Property>
    <Decl> 		::= <DataItem> | <Pattern> 
    <DataItem>		::= <ConstantDataItem> | <VariableDataItem>
    <ConstantDataItem> 	::= obj <ObjectDescriptor> | val <ObjectDescriptor
    <Pattern> 		::= ...
    <ObjectSpec>	::= <ObjectCall> | <ObjectDescriptor>
    <ObjectCall> 	::= <Invocation>
    <ObjectDescriptor> 	::= <Invocation> <MainPart>
    <MainPart> 		::= <Item> *
    <Statement>		::= <Assignment> | <ObjectSpec>
    <Assignment>	::= <Invocation> := <Exp> 
                         |  <Invocation> :- <Exp>
    ObjectSpecification: Item ...
    pObjectSpec: exit ObjectSpecification == ObjectDescriptor
    
    *)
do (# lINV,rINV: ^Invocation; E: ^Exp;  IS: ^Items; 
      OG: ^ObjectDescriptor; OS: ^ObjectSpecification;
      fixIt:
        (# IV: ^Invocation; E: ^Exp; ISx: ^Items; 
        enter(IV[],ISx[])
        do 'pStmt:fixIt'->trace;
           (if ISx.isEmpty then 
               IV.last -> E[]; 
               'pStmt:fixIt:ISx.isEmpty'->trace
               (#
               do (if E.args[] <> none then
                      E.args.noOfSons -> putint;  ' ' -> put; 
                      E.args.inBraces -> putboolean; newline;
               if)#);
               (if (E.args[] <> none) 
                   and (E.args.noOfSons = 4) (* OBS! hack! *)
                   and (E.args.inBraces) 
                   and E.isObjectInvocation then
                   'pStmt:fixIt:FIX'->trace
                   (#
                   do 'pOG:got:arg:as:mainPart: ' -> puttext;
                      E.args.noOfSons -> putint; newline; IV.dopt -> puthead;
                   #);                  
                   IV.mkOG -> (IV[],ISx[]);
                   (if false then
                       '**   IV:' -> puttext; IV.dopt -> putline;
                       '**   ISx:' -> putline; ISx.dopt -> putHead
           if)if)if); 
        exit(IV[],ISx[])
        #)
   do 'pStmt:'->trace;
      pInvocation -> lINV[]; (* includes :=, +. -, ... 
                             * Only R.P.S,
                             * R %& T returning datum? 
                             * NO, must be DataItem
                             *)
      (if false then lINV.dopt -> putline; if);
      (* lex.symb -> lex.symbols.asText -> putline;*)
      (if lex.symb
       // lex.symbols.vAssign // lex.symbols.rAssign then
          'pStmt:assign'->trace;
          lex;
          pInvocation -> rINV[];
          pMainPart -> IS[];
          (rINV[],IS[]) -> fixIt -> (rINV[],IS[]);
          (rINV[],IS[]) -> ObjectDescriptor -> OG[];
          (lInv[],OG[]) -> AssignmentStatement -> S[];
          (if false then S.doPT -> putline if)
       else
          'pStmt:not:assign'->trace;
          (if invAsDerived then
              (*lex;*)
              'pStmt:beforeBindings'->trace;
              pBindings -> IS[];
              'pStmt:afterBindings'->trace(#do IS.dopt->dumpTN #);
              IS[] -> pMainPartII -> IS[];
              (if IS.noOfSons = 0 then
                  'pStmt:pMainPartII:B:noOfSons=0'->trace;
                  true -> IS.isEmpty
              if);
              'pStmt:after:MainPartII'->trace(#do IS.dopt->dumptn #)
           else
              pMainPart -> IS[];
          if);
          (lINV[],IS[]) -> fixIt -> (lINV[],IS[]);
          (lINV[],IS[]) -> ObjectDescriptor -> OG[] -> S[]
      if);
      (*INV[] -> S[]    *)
     'pStmt:end'->trace
   #)
      
   
