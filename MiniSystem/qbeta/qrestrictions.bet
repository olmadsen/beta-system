ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qsemchecker';
---lib:attributes---
traceAE: (# exit false #);
restrictions: semchecker
  (# AccessError: notification
       (# printHeading:: (# do '\n***** Possible access error' -> puttext #);
          report:: (# do true -> value #)
       do inner
       #);
     items::<
       (# superHasInSub: @boolean;
          scanGlobals:
            (# current: ^Lexem;
               hasGlobals:< Object;    
               hasInSub:< Object
            do (if traceAE then
                   '**** scanGlobals: '->puttext; encOG.OGid -> puttext;
                   dopt->putHeadN
               if);
               (if superDesc[] <> none then 
                   (if traceAE then ':hasSuper:'->putline; if);
                   &superDesc.scanGlobals
                   (# hasGlobals:: (# do this(scanGlobals).hasGlobals #);
                      hasInSub:: (# do  this(scanGlobals).hasInSub #);
                   do current[] -> this(scanGlobals).current[]; 
                      (if (current.ATd.asDecl).primNo = inSub_prim then
                          (if traceAE then
                              ':Found inSub-1' -> putline;
                          if);
                          hasInSub
                       else
                          inner scanGlobals;
                      if);
               #)if);
               (if newBasicProp.globals[] <> none then
                   (* globals defined: 
                    * 1: globals[]
                    * 2: globals[..., inSub,...]
                    * 3: globals[Q1,Q2,Q3] - may include inSub as in (2)
                    *)
                   hasGlobals;
                   newBasicProp.scanGlobals
                   (#
                   do current.scanSons
                      (# OI: ^ObjectInvocation
                      do current[] -> OI[];
                         OI.ptnId[] -> this(scanGlobals).current[]; 
                         OI.ATd.asDecl -> OI.ptnId.ATd[];
                         (if OI.ATd[] = none then
                             '*** OI.ATd is none'->putline;
                         if);
                         (if (OI.ATd.asDecl).primNo = inSub_prim then
                             hasInSub
                          else
                             inner scanGlobals
                         if)
                      #)
                   #)
               if)
            #);
          checkGlobalsIncluded:
            (* adIS: the AD.IS of application
             * check ad.IS.globals IN this(Items).globals
             * Assume that this(items).globals exist
            *)
            (# ad: ^Apl;
               adIS: ^Items; 
               superQual,subQual: ^ObjectGenerator; (* subQual <= superQual *)
               dx: ^Lexem;
               noSubGlobals: @boolean
            enter ad[]
            do ad.ATd.desc -> adIS[];
               (if traceAE then
                   '\n>>> checkGlobalsIncluded:' -> puttext;
                   adIS.dopt -> putheadN
               if);
               true -> noSubGlobals;
               adIS.scanGlobals
               (# hasGlobals:: (# do false -> noSubGlobals #);
               do (if traceAE then
                      ':sub: ' -> puttext; 
                      current.doPT -> putLine;
                  if);
                  current[] -> dx[];
                  (current.ATd.asDecl).getQual -> subQual[];
                  (if traceAe THEN '?in adIS:globals: ' -> puttext; if); 
                  L:
                    (if true then
                        scanGlobals
                        (# hasGlobals:: 
                             (# 
                             do (* always the case *)
                                (if traceAE then ' hasGlobals'-> putline if)
                             #)
                        do (if traceAE then 
                               current.doPT -> puttext; ' ' -> put if);
                           (current.ATd.asDecl).getQual -> superQual[];
                           (if (subQual[] -> superQual.inSuper) then 
                               (if traceAE then ' -> OK' -> putline if);
                               leave L
                           if);
                        #);
                        (* not found *)
                        inner checkGlobalsIncluded;
                        (if traceAE then newline if);
                    if)
               #);
               (if noSubGlobals then
                   (if objectDecl[] = ad.ATd.asDecl then
                       '**   suppress error for basic pattern object:' 
                         -> putline
                   if);
                   ad[] -> accessError
                   (#
                   do ' "' -> msg; ad.doPT -> msg; 
                      '" has no restrictions ' -> msg
                   #)
               if);
               (if traceAE then newline if)
            #);
          checkGlobals:
            (* check if AD in this(items).globals
             * if not check if AD.globals in this(items).globals 
             *    using checkGlobalsIncluded
             *)
            (# ok,first: @boolean;
               AD: ^Apl; (* The Apl being accessed *)
               OG: ^ObjectGenerator;
               adQual,rQual: ^ObjectGenerator (* adQual <= rQual *)
            enter AD[]
            do (if AD[] = none then
                   (*'AD none'->putline;*)
                   true -> ok;
                   leave checkGlobals
               if);
               scanGlobals; (* just test if Super has globals[inSub] *)
               true -> ok;
               true -> first;
               loop:
                 scanGlobals
                 (# hasGlobals:: 
                      (# 
                      do false -> ok;
                         (if first then 
                             (if traceAE then
                                 '\n%%% checkGlobals: ' ->puttext;
                                 AD.doPT -> puttext; 
                             if);
                             false -> first;
                         if);
                      #);
                    hasInSub:: (# do true -> superHAsInSub #);
                    DI: ^DataItem
                 do (if traceAE then
                        ' < ' -> puttext; current.doPT -> puttext;
                    if);
                    (*false -> ok; (*global restrictions exists *)
                    (* Current: Property has no desc att - 
                     * Property should probably be an Apl 
                     * and checked as an Apl
                     * We then need to handle primitives 
                     * Property.P is a lexem which is an Apl, 
                     * so perhaps we are ok!?
                     *)
                    (if traceAE then
                        '>>> adQual=AD.qual=' -> puttext; 
                        AD.doPT -> puttext; ':\n' -> puttext;
                    if);
                    AD.getQual -> adQual[];
                    (* '\n>>> adQual:'->putline; *)
                    (if current[] = none then ' P is none'->putline if);
                    (if current.ATd[] = none then 
                        'ATd is none'->putline if);
                    (current.ATd.asDecl).getQual -> rQual[]; (*Must check current*)
                    (if traceAE then
                        '>>> adQual:'->putline; adQual.doPT -> putHeadN;
                        rQual.dopt -> putheadN;
                    if);
                    (if (adQual[] -> rQual.inSuper) then 
                        (if traceAE then ' -> OK'->putline if);
                        true -> ok;
                        leave loop
                    if);
                 #);
               (if not ok then 
                   (if not superHasInSub then
                       (if (AD.ATd.asDecl).isPatternDecl then
                           (if traceAE then ' -> Pattern:'->putline if);
                           (* foo: [Q1,Q2,Q3]
                            * [Q1,Q2,Q3] must be contained in globals[this(PTN)]
                            *)
                           '**** KUK:X:'->puttext; AD.label -> putline;
                           Ad.dopt -> putline;
                           AD[] -> checkGlobalsIncluded
                           (#
                           do AD[] -> accessError
                              (#
                              do AD.doPT -> msg;
                                 ' may access: "' -> msg;
                                 dx.doPT -> msg;
                                 '" which is not allowed in this scope' -> msg
                              #)
                           #)
                        else
                           AD[] -> AccessError
                           (#
                           do 'Cannot access global data-item: "' -> msg;;
                              AD.doPT -> msg;
                              '"' -> msg
                           #)
            if)if)if)#)
       #)
  do '**** RESTRICTIONS ****' -> putline;
     inner
  #)
