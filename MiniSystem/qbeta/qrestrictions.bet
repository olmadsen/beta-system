ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qsemchecker';
---lib:attributes---
traceAE: (# exit false #);
restrictions: semchecker
  (# AccessError: notification
       (# printHeading:: (# do '\n***** Possible access error' -> puttext #);
          report:: (# do not allowUnsafe -> value #)
       do inner
       #);
     items::<
       (# superHasInSub: @boolean;
          scanGlobals:
            (# current: ^Lexem;
               hasGlobals:< Object;    
               hasInSub:< Object
            do (if traceAE then
                   '**** scanGlobals: '->puttext; encOG.OGid -> puttext;
                   dopt->putHeadN
               if);
               (if superDesc[] <> none then 
                   (if traceAE then ':hasSuper:'->putline; if);
                   &superDesc.scanGlobals
                   (# hasGlobals:: (# do this(scanGlobals).hasGlobals #);
                      hasInSub:: (# do  this(scanGlobals).hasInSub #);
                   do current[] -> this(scanGlobals).current[]; 
                      (if (current.ATd.asDecl).primNo = inSub_prim then
                          (if traceAE then
                              ':Found inSub-1' -> putline;
                          if);
                          hasInSub
                       else
                          inner scanGlobals;
                      if);
               #)if);
               (if newBasicProp.globals[] <> none then
                   (* globals defined: 
                    * 1: globals[]
                    * 2: globals[..., inSub,...]
                    * 3: globals[Q1,Q2,Q3] - may include inSub as in (2)
                    *)
                   hasGlobals;
                   newBasicProp.scanGlobals
                   (#
                   do current.scanSons
                      (# OI: ^ObjectInvocation
                      do current[] -> OI[];
                         OI.ptnId[] -> this(scanGlobals).current[]; 
                         OI.ATd.asDecl -> OI.ptnId.ATd[];
                         (if OI.ATd[] = none then
                             '*** OI.ATd is none'->putline;
                         if);
                         (if (OI.ATd.asDecl).primNo = inSub_prim then
                             hasInSub
                          else
                             inner scanGlobals
               if)#)#)if)
            #);
          checkGlobalsConform:
            (* adIS: the AD.IS of application
             * check ad.IS.globals IN this(Items).globals
             * Assume that this(items).globals exist
            *)
            (# isObjectQualOrPtnName: BooleanValue
                 (* Object is allowed even if no %globals
                  * Currenlty we also allow Set.Set(#Record) for
                  * arbitrary Record patterns evne without %globals
                  * The problem with '#' below is that for
                  *    S: obj Set.Set(#Record)
                  * if Record must have %globals then we cannot have containers
                  * with objects accessing globals values - this does not work;
                  * We may perhaps require that if ptn like Set has %globals, 
                  * then possble virtual parameters cannot be instantiated
                  *)
                 (# D: ^ Decl; nm:^Name; T: ^text
                 do ad.ATd.asDecl -> D[];
                    (if false then
                        '**** isObjectQual:'->puttext; ad.doPT -> dumpT;
                        D.OG.primNo->putint;
                        newline;
                    if);
                    D.OG.primNo = object_prim -> value;
                    ad.dopt->T[];
                    ((1 -> T.inxGet) = '#') or value 
                      -> value
                 #);
               ad: ^Exp;
               adIS: ^Items; 
               superQual,subQual: ^ObjectDescriptor; (* subQual <= superQual *)
               dx: ^Lexem;
               noSubGlobals: @boolean
            enter ad[]
            do (if isObjectQualOrPtnName then
                   '**** checkGlobalsConform:'->puttext;
                   ad.dopt -> putheadN;
                   leave checkGlobalsConform
               if);
               ad.ATd.desc -> adIS[];
               (if traceAE then
                   '**** checkGlobalsConform:' -> puttext;
                   adIS.dopt -> putheadN
               if);
               true -> noSubGlobals;
               adIS.scanGlobals
               (# hasGlobals:: (# do false -> noSubGlobals #);
               do (if traceAE then
                      '**   sub: ' -> puttext; 
                      current.doPT -> putLine;
                  if);
                  current[] -> dx[];
                  (current.ATd.asDecl).getQual -> subQual[];
                  (if traceAe THEN '**   in adIS:globals: ' -> puttext if); 
                  L:
                    (if true then
                        scanGlobals
                        (# hasGlobals:: 
                             (# 
                             do (* always the case *)
                                (if traceAE then '**   hasGlobals'-> putline if)
                             #)
                        do (if traceAE then 
                               current.doPT -> puttext; ' ' -> put if);
                           (current.ATd.asDecl).getQual -> superQual[];
                           (if (subQual[] -> superQual.inSuper) then 
                               (if traceAE then ' -> OK' -> putline if);
                               leave L
                           if);
                        #);
                        (* not found *)
                        inner checkGlobalsConform;
                        (if traceAE then newline if);
                    if)
               #);
               (if noSubGlobals then
                   ad[] -> accessError
                   (#
                   do ' "' -> msg; ad.doPT -> msg; 
                      '" has no restrictions ' -> msg
                   #)
               if);
               (if traceAE then newline if)
            #);
          checkGlobalsViolations:
            (* check if ATapl in this(items).globals
             * if not check if ATapl.globals in this(items).globals 
             *    using checkGlobalsConform
             *)
            (# noViolations,emitTrace: @boolean;
               ATapl: ^Exp; (* The Exp being accessed *)
               OG: ^ObjectDescriptor;
               adQual,rQual: ^ObjectDescriptor (* adQual <= rQual *)
            enter ATapl[]
            do (if ATapl[] = none then
                   true -> noViolations;
                   leave checkGlobalsViolations
               if);
               scanGlobals; (* just test if Super has globals[inSub] *)
               true -> noViolations; (* we assume no violations *)
               true -> emitTrace;    (* emitTrace only for first %globals *)
               loop:
                 scanGlobals
                 (# hasGlobals:: 
                      (# 
                      do false -> noViolations; (* now assume violations *)
                         (if emitTrace then 
                             (if traceAE then
                                 '\n**** checkGlobalsViolations: ' ->puttext;
                                 ATapl.doPT -> puttext; 
                             if);
                             false -> emitTrace;
                         if)
                      #);
                    hasInSub:: (# do true -> superHAsInSub #);
                    DI: ^DataItem
                 do (if traceAE then
                        ' < ' -> puttext; current.doPT -> puttext;
                    if);
                    (* Current: Property has no desc att - 
                     * Property should probably be an Exp
                     * and checked as an Exp
                     * We then need to handle primitives 
                     * Property.P is a lexem which is an Exp,
                     * so perhaps we are ok!?
                     *)
                    (if traceAE then
                        '>>> adQual=ATapl.qual=' -> puttext; 
                        ATapl.doPT -> puttext; ':\n' -> puttext;
                    if);
                    ATapl.getQual -> adQual[];
                    (current.ATd.asDecl).getQual->rQual[];(*Must check current*)
                    (if traceAE then
                        '>>> adQual:'->putline; adQual.doPT -> putHeadN;
                        rQual.dopt -> putheadN;
                    if);
                    (if (adQual[] -> rQual.inSuper) then 
                        (if traceAE then ' -> OK'->putline if);
                        true -> noViolations;
                        leave loop
                 if)#);
               (if not noViolations then 
                   (if not superHasInSub then
                       (if (ATapl.ATd.asDecl).isPatternDecl then
                           (if traceAE then ' -> Pattern:'->putline if);
                           (* this(Items): %globals P1, P2, ...
                            * foo: %globals Q1,Q2, ...
                            * Check that Q1,Q2, ... is conformed by P1,P2,...
                            * contained, .. What to call it?
                            *)
                           ATapl[] -> checkGlobalsConform
                           (#
                           do ATapl[] -> accessError
                              (#
                              do ATapl.doPT -> msg; ' may access: ' -> msg;
                                 dx.doPT -> qmsg;
                                 ' which is not allowed in this scope' -> msg
                              #)
                           #)
                        else
                           ATapl[] -> AccessError
                           (#
                           do 'Cannot access global data-item: ' -> msg;
                              ATapl.doPT -> qmsg;
                           #)
            if)if)if)#)
       #);
     objectInvocation::<
       (# semCheck::
            (# ATdx: ^Decl; ISx,org: ^Items
            do (if false then
                   '**** Restrictions:OI:semcheck:'->puttext; dopt -> putline;
                   (ATd.asDecl->ATdx[]).isVirtual -> putboolean; newline
               if);
               (if (ATd.asDecl->ATdx[]).isVirtual then
                   (* Not enough just to scan origin
                    * We must scan all enclosing Items in the path from
                    * from origin to this(OI).on
                    * And the path is the same as getVqual/OGsequence
                    * is computing
                    *)
                   (if ATdx.OG.isObject (*and (on > 0)*) then
                       (origin.OGofScope).IS -> org[];
                       (*'**** ' -> puttext;  on -> putint; ' '-> put;
                       this(ObjectInvocation).dopt -> puttext; newline;*)
                       (for i: on + 1 repeat
                            (*org.dopt -> putheadN;*)
                            (if org.hasGlobals then
                                '**** virtual Object: ' -> puttext;
                                this(ObjectInvocation).dopt -> puttext;
                                '\n**   the declaration is in enclosing scope: '
                                  -> puttext;
                                ATdx.dopt->puttext; ' on:'->puttext; on->putint;
                                newline
                            if);
                            (org.origin.OGofScope).IS[] -> org[];
                       for)
                   if);
                   ((origin.OGofScope).IS[] -> ISx[]).scanGlobals
                   (# hasGlobals::
                        (#
                        do (if ATdx.OG.isObject then
                               this(ObjectInvocation)[] -> AccessError
                               (#
                               do 'The virtual pattern: '-> msg;
                                  ATdx.dopt -> qmsg;
                                  '\n     cannot be instantiated' -> msg;
                                  ' since the declaration is in'-> msg;
                                  '\n     an object with %globals restrictions'
                                  -> msg;
                                  '\n     and is just of type Object' -> msg
            #)if)#)#)if)#)
       #)
  do (if verbose then '**** RESTRICTIONS ****' -> putline if);
     inner
  #)
