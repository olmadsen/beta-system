ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'qStdBetaAllocator';
INCLUDE '../../VM/objectcode'
---LIB:attributes---
qStdBetaGenerator: qStdBetaAllocator
  (# StdBetaModule::<
       (# gen:: 
            (# 
            do '**** StdBetaModule:gen:'-> dumpT; moduleName.doPT->dumpTN;
               cd.fcom
               (#
               do 'StdBetaModule:gen:'->TT; moduleName.dopt->TQ; #);
               frags.gen
            #)
       #);   
     BetaFragments:: (# gen:: (#do scanSons(#do current.gen #); #)#);
     AttFrag::
       (# gen:: (# do cd.fcom(#do thename.dopt->TT #); att.gen #)
       #);   
     ObjDescFrag::
       (# gen:: 
            (# 
            do OD[] -> objTmpStack.add;  
               cd.com(#do thename.dopt->TT #) 
            #)
       #);   
     DoPartFrag::
       (# gen:: 
            (# 
            do cd.fcom(#do 'DoPartFrag:'->TT; thename.dopt->TT #);
               DP.gen
            #)
       #);
     AttSlot::<
       (# gen:: (#do scanBindings(#do current.gen #)#);
       #);
     ObjDescSlot::<
       (# gen::
            (#
            do scanBindings
               (# ODF: ^ObjDescFrag
               do (current[] -> ODF[]).OD[] -> objTmpStack.add;
               #)
            #);
       #);
     DoPartSlot::<
       (# gen::
            (#
            do cd.com(#do 'DoPartSlot:gen:'->TT; theName.dopt -> TT #);
               scanBindings
               (# DP: ^DoPartFrag
               do cd.com(#do 'call:gen:'->TT; theName.dopt->TT ;
                            (*current.dopt->TT*) #);
                  (current[] -> DP[]).gen
               #)
            #);
       #);
     Attributes::
       (# gen:: (#do scanSons(#do current.gen #);#)
       #);
          
     ObjectDesc::
       (# gen:: 
            (#
            do this(ObjectDesc)[] -> objTmpStack.add;
               cd.fcom
               (#do 'ObjectDesc:gen:'->TT; slt[] <> none -> BB(*dopt->TT *)#);
            #);
          activate::
            (#
            do cd.fcom(#do 'ObjectDesc:activate'->TT; descNo->II; #);
               (if isSingular then
                   this(ObjectDesc)[] -> objTmpStack.add;
               if);
               cd.pushThis;
               ('Singular',descNo,false) -> cd.alloc;
               ('singular','S') -> doCall
            #);
          isExternal: BooleanValue
            (# primNo: @integer
            do (if sup.isExternal then
                   cd.com(#do 'External:'->TT; dopt -> TT; #);
                   L:
                     acp.imps.scanSons
                     (#
                     do cd.com(#do current.doPP -> TT#);
                        current.scanSons
                        (# i: @integer
                        do current.getPrimNo -> primNo;
                           cd.com(#do primNo -> II #);
                           true -> value;
                           leave L
                     #)#);
                   (if primNo 
                    // 2 then 
                       ('put',2) -> cd.callPrim
                    else
            if)if)#);
          isExtern: BooleanValue
            (# primNo: @integer
            do (if sup.isExternal then
                   cd.com(#do 'isExtern:'->TT; dopt -> TT; #);
                   L:
                     acp.imps.scanSons
                     (#
                     do cd.com(#do current.doPP -> TT#);
                        current.scanSons
                        (# i: @integer
                        do current.getPrimNo -> primNo;
                           cd.com(#do primNo -> II #);
                           true -> value;
                           leave L
               #)#)if);
            #);
          addEncNS:
            (# T:  ^Text; encOD: ^ObjectDesc
            enter T[]
            do (if ((theEncOD -> encOD[]) <> none) then
                   cd.fcom (#do 'encOD:'->TT; encOD.dopt->TL #);
                   (if (encOD.NS[] <> none) 
                       then 
                       cd.fcom(#do 'NS:'->TT; encOD.ns.dopt->TT#);;
                       encOD.NS.scanSons
                       (#do current.dopt -> T.append #);
                       '$' -> T.put
                    else
                       T[] -> encOD.addEncNS -> T[];
                       '$S$' -> T.append;
                   if)
                else
                   'betaenv'-> T.append; '$' -> T.put
               if);
            exit T[]
            #);
          genClass:
            (# handleSuper:
                 (#
                 do (if superDesc[] <> none then
                        (if not sup.isThisBlockLevel then
                            cd.rdouble;
                            ('origin',originOff) -> cd.rstore; 
                            (*sup.loadOrigin -> N[]; *)
                            (*cd.pushThis;*) (* ??? *)
                            'super' -> superName[]; (* fix *)
                            cd.fcom
                            (#do 'loadorigin:exealloc:'->TT; sup.dopt->TT#);
                            sup.loadOrigin (*-> N[];*)
                        if);
                        (superName[],superDesc.descNo) -> cd.exeAlloc;
                        cd.rpop;
                        (superName[],superDesc.descNo)  -> cd.super; 
                        (if false then
                            '**** vdtTableCopy:'->dumpt; 
                            descNo -> putint; ' ' -> put;
                            superDesc.descNo -> putint; ' ' -> put;
                            dopt -> putHeadN;
                            '**    super:'->dumpTN;
                            superDesc.dopt -> putheadN;
                        if);
                        superDesc.descNo  -> cd.vdtTableCopy;
                        (if superDesc.innerInx > 0 then
                            cd.fcom(#do 'super has inner:'->TT; doPT->TT #);
                            (superDesc.innerInx,descno,true,'LLVMsig')
                              -> cd.vdtTable
                        if)
                     else
                        ('origin',originOff) -> cd.rstore; (* save origin *)
                    if);
                 #);
               mkClassName:
                 (# T: ^Text
                 do 'B$'-> T[];
                    (if NS[] <> none then
                        NS.scanSons(#do current.dopt -> T.append #)
                     else 
                        (if origin[] = none then
                            'betaenv' -> T.append;
                         else
                            T[] -> addEncNS -> T[];
                            (*'$' -> T.put*)
                        if);
                        'S$' -> T.append; descNo -> T.putint
                    if)
                 exit T[]
                 #);
                    
               className,orgId,superName: ^Text; 
               orgDescNo: @integer; org,encOD: ^ObjectDesc
            do mkClassName -> className[]; 
               cd.fcom
               (#
               do 'ObjectDesc:genClass:'-> TT; className[]->TQ; 
                  'isSlot:'->TT; slt[]<>none->BB #);
               (if (superDesc[] <> none) and not superDesc.done then
                   (* pretty ad hoc - since we copy the VDtable from super, 
                    * code must have been generated for super; 
                    * done is introduced to handle this. 
                    * But fix it
                    *)
                   (*sup.name -> *) superDesc.genClass;
               if);
               (if (theEncOD->org[]) <> none then
                   org.descNo -> orgDescNo;
                   'origin' -> orgId[]
                else
                   'origin' -> orgId[]
               if);
               (if not done then
                   true -> done;
                   (if slt[] = none then
                       (className[],descNo,false,(topSuper).descNo
                       ,originOff,orgId[],orgDescNo,false,false)
                         -> cd.class;
                       cd.bcPos -> beginBCP;
                       (* gen super, save origin, vdtTableCopy, etc  *)
                       handleSuper;
                       (if false then ('super',501) -> cd.exeAlloc; if);
                       att.gen;
                       (* check generator: more may be need here including 
                        * for-fields
                        *)
                       'a' -> cd.rtn; 
                       cd.markEnterE;
                       superDesc[] ->  acp.gen;
                    else
                       slt.scanBindings
                       (# ODF: ^ObjDescFrag
                       do cd.fcom
                          (#do 'ObjDesc:gen:slot:'->TT; current.dopt -> TT #);
                          (current[]->ODF[]).OD.genClass
                       #)
                   if);
                   (objSize,false,0) -> cd.endclass;
            if)#);   
          doCall::
             (# TP: ^type; xType: @integer
             do cd.fcom(#do 'ObjDesc:doCall'->TT; LMR ->CC #);
                (if (exitType->TP[]) <> none then
                    (if TP.isRef then
                        2 -> xType
                     else
                        1 -> xType
                if)if);
                (if false then
                    doPt->putline;
                    'exitType: ' -> puttext; xType -> putint; newline;
                if);
                (if LMR
                 // 'S' then 
                    (if hasDoPart then 
                        (N[],'D') -> cd.call;
                        cd.rpop 
                    if);
                    (*cd.rtnEvent;*)
                 // 'L' then
                    (if hasDoPart then (N[],'D') -> cd.call if);
                    (N[],'X') -> cd.call;
                    (*xType -> cd.rtnEvent*)
                 // 'M' then
                    (N[],'N') -> cd.call;
                    (if hasDoPart then (N[],'D') -> cd.call if);
                    (N[],'X') -> cd.call;
                    (*xType -> cd.rtnEvent*)
                 // 'R' then
                    (N[],'N') -> cd.call;
                    (if hasDoPart then
                        (N[],'D') -> cd.call;
                        cd.rpop
                    if);
                    (*cd.rtnEvent;*)
             if)#);
          goOrigin::
            (#
            do cd.fcom(#do 'ObjectDesc:goOrigin:'->TT; on->II; isSimple->BB #);
               (if on > 0 then
                   ('origin',originOff) -> cd.rpushg;
                   on - 1 -> origin.goOrigin
            if)#);
          done: @boolean
       #);
     DoPart::<
       (# gen::
            (#
            do cd.com(#do 'DoPart:gen:'->TT; #);
               (if imps[] <> none then imps.gen if)
            #);
       #);
     BetaDecl::
       (# gen:: 
            (# 
            do (*cd.fcom(#do 'BetaDecl:gen:'->TT; NS.dopt->TQ #);*)
               NS.gen; IT.gen 
            #);
          doAlloc::
            (#
            do cd.fcom
               (#do 'BetaDecl:doAlloc:'->TT; NS.doPT->TQ; IT.label->TT #);
               IT.doAlloc
       #)#);
     BetaNameDecl::
       (# gen::
            (#
            do cd.fcom(#do 'NameDecl:gen:'->TT; N.T[]->TQ #);
               theDcl.IT.gen
            #);
          pushThis:: (#do theDcl.IT.pushThis #);
          activate::
            (#
            do cd.fcom
               (#do 'NameDecl:activate:'->TT; N.T[]->TQ; 
                  theDcl.label->TT; LMR->CC; isRef->BB; 
                  (*'primNo:'->TT; primNo->II*)
               #);
               (if 'range'->N.T.equalNCS then
                   ('pushRange',5) -> cd.callPrim
                else
                   (this(BetaNameDecl)[],LMR,isRef,isIndexed)
                     -> theDcl.IT.activate;
            if)#);
          doAlloc::
            (#
            do cd.fcom
               (#do 'NameDecl:doAlloc:'->TT; N.T[]->TQ; theDcl.label->TT #);
               theDcl.doAlloc
            #);
          doCall::
            (#
            do cd.fcom(#do 'NameDecl:doCall:'->TT; dopt->TT; LMR->CC #);
               (doPT,LMR) -> (theDcl.IT.theDesc).doCall
       #)#);
     StaticItem::
       (# loadItem::
            (#
            do cd.fcom
               (#
               do 'StaticItem:loadItem:'->TT; id[]->TQ; 
                  (if NS.theDesc <> none then
                      (NS.theDesc).doPT -> TT;
                      (NS.theDesc).isPrimitive->BB;
               if)#);
               (if (NS.theDesc <> none) and (NS.theDesc).isPrimitive then
                   (id[],off) -> cd.pushg
                else
                   (id[],off) -> cd.rpushg
            if)#);
          storeItem::
            (#
            do cd.fcom
               (#
               do 'StaticItem:storeItem:'->TT; id[]->TQ; 
                  (if NS.theDesc <> none then
                      (NS.theDesc).doPT -> TT;
                      (NS.theDesc).isPrimitive->BB;
                  if); 
               #);
               (id[],off) -> cd.rstoreg
            #);
          pushThis:: (#do cd.pushThis #);
          activate::
            (#
            do cd.fcom
               (#do 'StaticItem:activate:'->TT; ND.dopt->TQ;LMR->CC;isRef->BB#);
               (if isRef then
                   (if LMR
                    // 'L' then 
                       (ND.dopt,ND.off) -> cd.rpushg
                    // 'M' then
                       cd.rdouble;
                       (ND.dopt,ND.off) -> cd.rstoreg
                    // 'R' then
                       (ND.dopt,ND.off) -> cd.rstoreg
                    else
                       cd.fcom(#do 'StaticItem:activate:'->TT; ND.dopt->TQ#);
                   if)
                else
                   (if (NS.theDesc <> none) and (NS.theDesc).isPrimitive then
                       (if LMR
                        // 'L' then
                           (ND.dopt,ND.off) -> cd.pushg
                        // 'M' then
                           cd.double;
                           (ND.doPT,ND.off) -> cd.storeg;
                        // 'R' then
                           (ND.doPT,ND.off) -> cd.storeg;
                        // 'S' then
                           (* standalone primitive like V where V: @integer
                            * pop thisObj
                            *)
                           cd.rpop
                       if)
                    else
                       cd.fcom(#do  'StaticItem:activate:doCall'->TT #);
                       (ND.doPT,LMR) -> doCall
            if)if)#);
          gen::
            (#
            do (if OS.isSingular then 
                   cd.fcom(#do 'StaticItem:gen:'->TT; NS.doPT-> TT; #);
                   OS[] -> objTmpStack.add ;
                   
                   NS.scanSons
                   (# ND:  ^BetaNameDecl
                   do cd.pushThis; (* origin *)
                      (NS.dopt,(OS.theDesc).descNo,false) -> cd.alloc;
                      cd.pushThis;
                      ((current[]->ND[]).doPT,ND.off) -> cd.rstoreg
                   #)
                else
                   (* also store X: @T if T not primitive *)
       if)#)#);
     DynamicItem::
       (# loadItem::
            (#
            do (id[],off) -> cd.rpushg
            #);
          storeItem::
            (#
            do cd.fcom
               (#do 'DynamicItem:storeItem:'->TT; OS.dopt->TQ; (*isRef->BB*)#);
               (if true (*isRef*) then
                   (id[],off) -> cd.rstoreg
                else
                   (*'R' -> (OS.theDesc).doCall*)
            if)#);
          pushThis:: (#do cd.pushThis #);
          activate::
            (#
            do cd.fcom
               (#
               do 'DynamicItem:activate:'->TT; ND.dopt->TQ;LMR->CC;isRef->BB;
                  OS.label->TT 
               #);
               (if isRef then
                   (if LMR
                    // 'L' then 
                       (ND.dopt,ND.off) -> cd.rpushg
                    // 'M' then
                       (ND.dopt,ND.off) -> cd.rpushg;
                       cd.rdouble
                    // 'R' then
                       (ND.dopt,ND.off) -> cd.rstoreg
                   if)
                else
                   (ND.dopt,ND.off) -> cd.rpushg;
                   (ND.doPT,LMR) -> OS.doCall
       if)#)#);
     Repetition::
       (# gen::
            (#
            do NS.scanSons
               (# ND:  ^BetaNameDecl
               do cd.pushThis; (* origin *)
                  (none,'L',false,false) -> inx.EV.activate;
                  1 -> cd.pushConst; (* dinx *)
                  (NS.dopt,repetitionDesc.descNo,(IT.theDesc).objsize,0,0)
                    -> cd.allocIndexed;
                  cd.pushThis;
                  ((current[]->ND[]).doPT,ND.off) -> cd.rstoreg
               #);
               (* also X: @ [3] T where T is not primitive *)
            #);
          pushThis:: (#do cd.pushThis #);
          activate::
            (#
            do cd.fcom
               (#do 'Repetition:activate:'->TT; NS.dopt->TQ;LMR->CC;isRef->BB#);
               L:
                 NS.scanSons
                 (#
                 do (if isIndexed then
                        (if isRef then
                            (if LMR
                             // 'L' then 
                                (ND.dopt) -> cd.xrpushg;
                             // 'M' then
                                cd.rswap;
                                cd.rdouble;
                                1 -> cd.rswap;
                                (ND.dopt) -> cd.xrstoreg;
                             // 'R' then 
                                (ND.dopt) -> cd.xrstoreg
                             else
                                cd.fcom(#do 'no match'-> TT #)
                            if)
                         else
                            (if LMR
                             // 'L' then 
                                (ND.dopt,0,1) -> cd.xpushg;
                             // 'M' then
                                cd.swap;
                                cd.double;
                                1 -> cd.swap;
                                (ND.dopt,0,1) -> cd.xstoreg;
                             // 'R' then 
                                (ND.dopt,0,1) -> cd.xstoreg
                             else
                                cd.fcom(#do 'no match'-> TT #)
                        if)if)
                     else
                        cd.fcom(#do 'Repetition:activate:R.range?'->TT #);
                        (ND.dopt, ND.off) -> cd.rpushg;
                    if);
                    leave L
            #)#);
       #);
     VarPtn::
       (# activate::
            (#
            do cd.fcom(#do 'VarPtn:activate:'->TT; NS.dopt -> TQ #);
            #)
       #);
     BetaPattern::
       (# gen:: 
            (#
            do (if OD.slt[] = none then
                   OD[] -> objTmpStack.add;
                else
                   OD.slt.scanBindings
                   (# ODF: ^ObjDescFrag
                   do (current[] -> ODF[]).OD[] -> objTmpStack.add
                   #)
            if)#);
          notSimple: BooleanValue
            (#
            do (if true
                // OD[] = trueDesc[] then
                // OD[] = falseDesc[] then
                // OD.isExtern then
                else
                   true -> value
               if)
            #);
          pushThis::
            (#
            do (if notSimple then cd.pushThis if)
            #);
          activate::
            (#
            do cd.fcom
               (#do 'PTN:activate:'->TT; ND.dopt->TQ; LMR->CC;isRef->BB#);
               (if true
                // OD[] = trueDesc[] then
                   1 -> cd.pushConst
                // OD[] = falseDesc[] then
                   0 -> cd.pushConst
                // OD.isExternal then
                else
                   doAlloc;
                   (if not isRef then
                       (NS.doPT,LMR) -> OD.doCall
                   if)
               if)
            #);
          loadItem::
            (#
            do cd.fcom(#do 'PTN:loadItem:'->TT; NS.dopt -> TQ #);
               (if true then
                   doAlloc
                else
                   (NS.doPT,OD.descNo,false) -> cd.alloc;
               if);
               (NS.dopt,'S') -> OD.doCall
            #);
          storeItem::
            (#
            do cd.fcom(#do 'PTN:storeItem:'->TT; NS.dopt -> TQ #);
               (if OD.isExternal then
                else
                   (if true then
                       loadItem
                    else
                       (NS.doPT,OD.descNo,OD.objSize,0,false) -> cd.invoke
               if)if)
            #);
          doAlloc::
            (#
            do cd.fcom
               (#do 'PTN:doAlloc:'->TT; NS.dopt->TQ; 'isSlot:'->TT;
                  OD.slt[] <> none -> BB 
               #);
               (if OD.slt[] = none then
                   (NS.doPT,OD.descNo,false) -> cd.alloc
                else
                   cd.fcom(#do 'findBinding'->TT #);
                   OD.slt.scanBindings
                   (# ODF: ^ObjDescFrag
                   do cd.fcom(#do 'got:'->TT; current.dopt->TT #);
                      (NS.doPT,(current[] -> ODF[]).OD.descNo,false) -> cd.alloc
            #)if)#);
       #);
     BetaVirtualPattern:: 
       (# pushThis:: (# do cd.pushThis  #);
          gen::
            (#
            do cd.fcom(#do 'VirtualPtn:gen:'->TT; NS.dopt -> TQ; #);
               (if OS.isSingular then OS[] -> objTmpSTack.add if);
               NS.scanSons
               (# ND: ^BetaNameDecl
               do ((current[]->ND[]).off,OS.getDescNo,false,'LLVMsig') 
                    -> cd.vdtTable;
            #)#);
          activate::
            (#
            do cd.fcom
               (#do 'VirtualPTN:activate:'->TT;ND.dopt->TQ; LMR->CC;isRef->BB#);
               NS.scanSons
               (# ND: ^BetaNameDecl
               do current[]->ND[];
                  (ND.doPT,ND.off,0,false) -> cd.invokeV;
                  (* 0 is noOfRefArgs - must be defined *)
               #);
               (* isRef : no doCall, only alloc *)
               (if not isRef then
                   (NS.doPT,LMR) -> OS.doCall
            if)#);
          doAlloc::
            (# 
            do cd.fcom(#do 'VirtualPtn:doAlloc:'->TT; NS.dopt -> TQ;
                         'dispatch needed'->TQ #);
               (if true then
                   NS.scanSons
                   (# ND: ^BetaNameDecl
                   do current[]->ND[];
                      (ND.doPT,ND.off,0,false) -> cd.invokeV;
                      (* 0 is noOfRefArgs - must be defined *)
                   #)
                else
                   (NS.doPT,OS.getDescNo,false) -> cd.alloc
            if)#);
       #);
     furtherBinding:: 
       (# gen::
            (#
            do cd.fcom(#do 'FurtherPtn:gen:'->TT; NS.dopt -> TQ; #);
               (if OS.isSingular then OS[] -> objTmpSTack.add if);
               NS.scanSons
               (# ND: ^BetaNameDecl
               do ((current[]->ND[]).off,OS.getDescNo,false,'LLVMsig') 
                    -> cd.vdtTable;
            #)#);
          pushThis:: (# do cd.pushThis #);
          doAlloc::
            (#
            do cd.fcom(#do 'FurtherPtn:doAlloc:'->TT; NS.dopt -> TQ;
                      'dispatch needed'->TQ #);
               (NS.doPT,OS.getDescNo,false) -> cd.alloc;
            #)
       #);
     FinalBinding:: 
       (# gen::
            (#
            do cd.fcom(#do 'FinalPtn:gen:'->TT; NS.dopt -> TQ; #);
               (if OS.isSingular then OS[] -> objTmpSTack.add if);
               NS.scanSons
               (# ND: ^BetaNameDecl
               do ((current[]->ND[]).off,OS.getDescNo,false,'LLVMsig') 
                    -> cd.vdtTable;
            #)#);
          pushThis:: (# do cd.pushThis #);          
          doAlloc::
            (#
            do cd.fcom(#do 'FinalPTN:doAlloc:'->TT; NS.dopt -> TQ #);
               (NS.doPT,OS.getDescNo,false) -> cd.alloc;
            #);
       #);
          
     ActionPart::
       (# gen::
            (# superDesc: ^ObjectDesc
            enter superDesc[]
            do cd.bcPos -> beginBCP;
               enterP.gen;
               (if imps[] <> none then 
                   (false (*(superDesc[] <> none)*)) -> cd.actions;
                   cd.mvStack;
                   labelHandler.init;
                   startLab.new; endLab.new;
                   startLab -> cd.defLab;
                   imps.gen;
                   endLab -> cd.defLab;
                   (if superDesc[] <> none then
                       cd.rtnInner
                    else
                       'd' -> cd.rtn;
               if)if);
               exitP.gen;
               cd.bcPos -> endBCP
            #);
       #);
     EnterPart::
       (# gen::
            (# 
            do cd.bcPos -> beginBCP;
               (if eval[] <> none then
                   cd.enterP; (* generate no code *)
                   (none,'R',false,false) -> eval.activate;
                   'n' -> cd.rtn 
               if);
               cd.bcPos -> endBCP;
            #)
       #);
     Imperatives::
       (# gen:: (#do scanSons(#do current.gen #)  #)
       #);
     ExitPart::
       (# gen::
            (#
            do cd.bcPos -> beginBCP;
               cd.markExitE;
               (none,'L',false,false) -> eval.activate;
               'x' -> cd.rtn;
               cd.bcPos -> endBCP;
            #)
       #);

     IfImp::
       (# gen::
            (# elseLab, Xlab,exitLab: @labelHandler.label
            do cd.fcom(#do 'IfImp:gen:'->TT; dopt -> TL #);
               cd.bcPos -> beginBCP;
               exitlab.new;
               (if not elsePart.isNull then
                   elseLab.new; 
                   elseLab -> Xlab
                else
                   exitLab -> xLab
               if);               
               (none,'L',false,false) -> eval.activate;
                              
               (if not thenPart.isNull then
                   (* simpleif: (if e then I1 else I2 if *)
                   (Xlab,Xlab) -> cd.jmpFalse; (* cd expects a Tlab and an Flab
                                                * due to LLVM - must check *)
                   thenPart.gen
                else
                   (Xlab[],exitLab[]) -> alt.select
               if);
               
               (if not elsePart.isNull then
                   (* Sometimes extra jmp here perhaps if thenPart.isNull *)
                   exitLab -> cd.jmp;
                   elseLab -> cd.defLab;                   
                   elsePart.gen
               if);
               exitLab -> cd.defLab;
               cd.bcPos -> endBCP               
       #)#);
     Alternatives::
       (# select:
            (# xLab,exitLAb: ^LabelHandler.label; 
               A: ^Alternative;
               nLab: @LabelHandler.label
            enter(xLab[],exitLab[])
            do cd.bcPos -> beginBCP;
               scansons
               (#
               do current[] -> A[]; 
                  (if isLast then
                      (false,xLab[],exitLab[]) -> A.select
                   else
                      nLab.new;
                      (true,nLab[],exitLab[]) -> A.select;
                      nLab -> cd.defLab
               if)#);
               cd.bcPos -> endBCP;
       #)#);
     Alternative::
       (# select:
            (# double: @Boolean; xLab,elseLAb: ^LabelHandler.label;
               tLab: @LabelHandler.label
            enter(double,xLab[],elseLab[])
            do cd.fcom(#do 'Alternative:'->TT; dopt -> TT #);
               cd.bcPos -> beginBCP;
               tLab.new;
               (double,tLab[],xLab[]) -> sel.select;
               tLab -> cd.defLab;
               imps.gen;
               elseLab -> cd.jmp;
               cd.bcPos -> endBCP;
       #)#);
     Selections::
       (# select:
            (# double: @Boolean; tLab,xLab: ^LabelHandler.label;
            enter(double,tLab[],xLab[])
            do cd.bcPos -> beginBCP;
               scansons
               (# S: ^Selection
               do current[] -> S[];
                  (if isLast then
                      (double,true,xLab[]) -> S.select 
                   else
                      (true,false,tLab[]) -> S.select
               if)#);
               cd.bcPos -> endBCP;
       #)#);
     Selection::
       (# select:
            (# double,isLast: @boolean; lab: ^LabelHandler.Label
            enter(double,isLast,lab[])
            do (if double then cd.double if);
               (*'L' -> *) EV.gen;
               lex.symbols.eq -> cd.op;
               (if isLast then
                   (lab,lab) -> cd.jmpFalse; (* check objectcode *)
                   (if double then cd.vpop if);
                else
                   lab -> cd.jmpTrue
            if)#);
       #);
     ForImp::
       (# gen:: 
            (# ND:  ^BetaNameDecl; startlab,endLab: @labelHandler.label
            do cd.fcom(#do 'ForImp:gen:missing'->TT #); 
               cd.fcom
               (# 
               do 'range:'->TT; off -> II; 'inx:'->TT;
                  inxDecl.NS.scanSons(#do (current[]->ND[]).off -> II #)
               #);
               (ND[],'L',false,false) -> rangee.activate;
               cd.pushthis;
               ('ForImp',off) -> cd.storeg;
               startLab.new;
               endLab.new;
               startLab -> cd.defLab;
               cd.pushthis;
               ('ForImp',off) -> cd.pushg; (* range *)
               cd.pushThis;
               (ND.dopt,ND.off) -> cd.pushg; (* index *)
               1 -> cd.pushConst;
               61 (* + *) -> cd.op;
               cd.double;
               cd.pushThis;
               (ND.dopt,ND.off) -> cd.storeg;
               54 (* range >= index *) -> cd.op;
               (endLab,endLab) -> cd.jmpFalse;
               imps.gen;
               startLab -> cd.jmp;
               endLab -> cd.defLab               
            #);
          goOrigin::
            (#
            do cd.fcom(#do 'ForImp:goOrigin:'->TT; on -> II; dopt->TL #);
               on -> origin.goOrigin
            #);
       #);
     ForImpItem::<
       (# pushThis:: (# do cd.pushThis #);
          activate::
            (#
            do cd.fcom
               (#do 'ForImpItem:activate:'->TT; ND.dopt->TQ;LMR->CC;isRef->BB#);
               (ND.dopt,ND.off) -> cd.pushg
            #)
       #);
     traceLabImp: (#exit false #);
     LabelledImp::
       (# gen:: 
            (# 
            do cd.fcom(#do 'LabelledImp:gen:'->TT #); 
               startLab.new; endLab.new;
               startLab -> cd.defLab;
               imp.gen;
               endLab -> cd.defLab;
            #);
          goOrigin::
            (#
            do cd.fcom(#do 'LabelledImp:goOrigin:'->TT; on -> II; dopt->TL #);
               on -> origin.goOrigin
            #);
       #);
     LeaveImp::
       (# gen:: 
            (# N: ^StdBetaNode; labImp: ^StdBetaNode
            do cd.fcom(#do 'LeaveImp:gen:'->TT; lab.on->II  #); 
               lab.on -> origin.goEncLabImp -> labImp[];
               (if traceLabImp then
                   '**** restart:encloser:lab:'->dumpT; 
                   labImp.endLab->putint; 
                   ' '->put; labImp.label -> dumpT;
                   newline;
                   labImp.dopt -> putheadn;
               if);
               (if labImp.isLabelledImp then
                   (if lab.on = 0 then
                       labImp.endLab -> cd.jmp
                    else
                       (lab.on,labImp.endLab,0,0) -> cd.break; 
                   if)
                else (* ActionPart *)
                   (if lab.on = 1 then
                       labImp.endLab -> cd.jmp
                    else
                       (lab.on - 1,labImp.endLab,0,0) -> cd.break;
       if)if)#)#);
     RestartImp::
       (# gen:: 
            (# N: ^StdBetaNode; labImp: ^StdBetaNode
            do cd.fcom(#do 'RestartImp:gen:'->TT; lab.on -> II #);
               lab.on -> origin.goEncLabImp -> labImp[];
               (if traceLabImp then
                   '**** restart:encloser:lab:'->dumpT; 
                   labImp.startLab->putint; 
                   ' '->put; labImp.label -> dumpT;
                   newline;
                   labImp.dopt -> putheadn;
               if);
               (if labImp.isLabelledImp then
                   (if lab.on = 0 then
                       labImp.startLab -> cd.jmp
                    else
                       (lab.on,labImp.startLab,0,0) -> cd.break; 
                   if)
                else (* ActionPart *)
                   (if lab.on = 1 then
                       labImp.startLab -> cd.jmp
                    else
                       (lab.on - 1,labImp.startLab,0,0) -> cd.break;
       if)if)#)#);
     InnerImp::
       (# gen:: 
            (#
            do cd.fcom
               (#do 'InnerImp:gen:'->TT; doPT->TT; 
                  (if orgOD[] = none then
                      'OBS! orgOD is NONE'->TT
                   else
                      orgOD.dopt->TL
               if)#);
               cd.pushThis;
               (* on -> goorigin *)
               (if orgOD[] <> none then 
                   orgOD.innerInx -> cd.innerP;
                   cd.rpopThisObj
            if)#);
       #);
     
     Evaluation::
       (# gen::
            (#
            do cd.fcom(#do 'Eval:gen:'->TT; dopt -> TL #);
               (none,'S',false,false) -> activate
            #);
          activate::
            (# LMRx: @char
            do cd.fcom(#do 'Eval:activate:'->TT; dopt->TQ; LMR->CC;isRef->BB#);
               scanSons
               (#
               do (if true
                   // isFirst and isLast then
                      (if LMR 
                       // 'S' then
                          'S' -> LMRx
                       // 'L' then
                          'L' -> LMRx
                       // 'R' then
                          'R' -> LMRx
                      if)
                   // isFirst then
                      (if LMR
                       // 'S' then
                          'L' -> LMRx
                       // 'L' then
                          'L' -> LMRx
                       // 'R' then
                          'M' -> LMRx
                      if)
                   // isLast then
                      (if LMR
                       // 'S' then
                          'R' -> LMRx
                       // 'L' then
                          'M' -> LMRx
                       // 'R' then
                          'M' -> LMRx
                      if)
                   else
                      'M' -> LMRx
                  if);
                  cd.fcom
                  (#do 'Eval:activate:trans:'->TT; current.dopt->TT; LMRx->CC#);
                  (ND[],LMRx,isRef,isIndexed) -> current.activate
            #)#);
       #);
     PatternDen::
       (# gen::
            (#
            do cd.fcom(#do 'PatternDen:gen:'->TT; AD.dopt->TQ #);
               AD.gen
            #);
          activate::
            (#
            do cd.fcom
               (#do 'PatternDen:activate:'->TT; dopt->TT; LMR->CC; isRef->BB#);
               AD.pushThis;
               AD.loadOrigin;
               (ND[],LMR,isRef,isIndexed) -> AD.activate
            #);
          doAlloc::
            (#
            do cd.fcom(#do 'PatternDen:doAlloc:'->TT; AD.label->TT;dopt->TT #);
               AD.loadOrigin;
               AD.doAlloc
            #);
          doCall::
            (#
            do cd.fcom
               (#do 'PatternDen:doCall:'->TT; AD.label->TT; dopt->TT;LMR->CC#);
               (N[],LMR) -> AD.docall
            #)
       #);
     ObjectEvaluation::
       (# activate::
            (#
            do cd.fcom
               (#do 'ObjectEval:activate:'->TT; dopt->TT; LMR->CC; isRef->BB#);
               (ND[],LMR,isRef,isIndexed) -> OS.activate
            #);
       #);
     BetaBinaryExp::
       (# activate:: 
            (#
            do cd.fcom(#do 'BinExp:activate:'->TT; dopt->TT #);
               (none,'L',false,false) -> lE.activate;
               (none,'L',false,false) -> rE.activate;
               (if op
                // lex.symbols.eq then
                   (if true
                    // (lE.exitType).isRef then
                       cd.req
                    // (lE.exitType).isStrucRef then
                       cd.seq
                    else
                       op ->  cd.op;
                   if)
                // lex.symbols.ne then
                   (if true 
                    // (lE.exitType).isRef  then
                       cd.rne                       
                    // (lE.exitType).isStrucRef then
                       cd.sne
                    else
                       op -> cd.op;
                   if)                   
                else
                   op -> cd.op;
            if)#)
       #);
     BetaTerm::
       (# activate::
            (#
            do cd.fcom
               (#do 'Term:activate:'->TT; dopt->TT; LMR->CC; isRef->BB#);
               (ND[],LMR,isRef,isIndexed) -> T.activate;
            #);
       #);
     ObjectReference::
       (# activate::
            (#
            do cd.fcom
               (#do 'ObjRef:activate:'->TT; dopt->TT; LMR->CC; isRef->BB#);
               (ND[],LMR,true,isIndexed) -> OV.activate
            #);
          doAlloc::
            (#
            do cd.fcom(#do 'ObjRef:doAlloc'->TT; OV.dopt->TT #); OV.doAlloc
            #)
       #);
     StructureRef::
       (# activate::
            (#
            do cd.fcom
               (#do 'StrucRef:activate:'->TT; dopt->TT; LMR->CC; isRef->BB#);
               (ND[],LMR,true,isIndexed) -> OV.activate;
            #);
       #);
     DynamicObjectGeneration::
       (# activate::
            (#
            do cd.fcom
               (#do 'DynamicObjectGeneration:activate'->TT; OS.dopt->TT #);
               (if false then
                   OS.doAlloc 
                else
                   (ND[],LMR,true,isIndexed) -> OS.activate 
            if)#);
          doAlloc:: 
            (# 
            do cd.fcom(#do 'DynamicObjectGeneration:doAlloc'->TT;OS.dopt->TT#);
               OS.doAlloc
            #)
       #);
     ThisObject::<
       (# activate::
            (#
            do cd.fcom(#do 'ThisObject:activate:missing:'->TT; AD.doPT->TT #);
               (* probably not AD.activate
                * push adr of enclosing AD
                *)
            #);
       #);
     EvaluationList::<
       (# gen::(#do  #);
          activate::
            (#
            do cd.fcom(#do 'EvalList:activate'->TT; dopt ->TT; LMR->CC  #);
               (*(if LMR = 'L' then 'M' -> LMR if);*)
               scanSons(#do (ND[],LMR,isRef,false) -> current.activate #)
            #);
       #);
     NoneValue::
       (# gen:: (#do cd.pushNone #);
          activate::(# do cd.pushNone #);
       #);
     NameApl::
       (# gen::
            (#
            do (if false then
                   cd.fcom(#do 'nameApl:gen:'->TT; N.dopt-> TQ #);
                   ATd.gen
            if)#);
          activate::
            (#
            do cd.fcom
               (#do 'NameApl:activate:'->TT; dopt->TT; LMR->CC; isRef->BB#);
               (if false and (on > 0) then
                   cd.pushThis;
                   on -> origin.goOrigin;
               if);
               (ND[],LMR ,isRef,isIndexed) -> ATd.activate;
            #);
          pushThis:: (#do ATd.pushThis #);
          loadOrigin::
            (#
            do cd.fcom
               (#do 'NameApl:loadOrigin:'->TT; dopt->TT; 
                  ATd.theDcl.IT.label->TT;
                  (if false then
                      ATd.theDcl.IT.dopt->TT;
                  if);
                  ATd.theDcl.IT.isSimple->BB;
               #);
               (if not ATd.theDcl.IT.getSimple then
                   on -> origin.goOrigin;
               if);
            #);
          doAlloc::
            (#
            do cd.fcom(#do 'NameApl:doAlloc:' -> TT; dopt->TT #);
               (if not isRemote then
                   (*cd.pushThis;*)
                   on -> origin.goOrigin;
               if);
               ATd.doAlloc
            #);
          doCall::
            (#
            do cd.fcom(#do 'NameApl:doCall:'->TT; dopt -> TT; LMR->CC #);
               (doPT,LMR) -> ATd.doCall
            #)
       #);   
     Indexed::
       (# pushThis:: (#do NA.pushThis #);
          loadOrigin:: (#do on -> NA.goOrigin #);
          activate::
            (#
            do cd.fcom
               (#
               do 'Indexed:activate:'->TT; doPT->TT; NA.doPT->TT;
                  LMR-> CC; isRef -> BB
               #);
               (none,'L',false,false) -> EV.activate;
               NA.loadOrigin; (* not ok; R.V[i] - no V.loadOrigin *)
               cd.fcom(#do 'on:'->TT; NA.on->II; 'off:'->TT;NA.ATd.off->II#);

               (if NA.on > 0 then NA.on -> origin.goorigin if);
               (NA.dopt,NA.Atd.off) -> cd.rpushg;
               (ND[],LMR,isRef,true) -> NA.activate;
            #)
       #);
     Remote::
       (# doAlloc::
            (#
            do '!!!! Remote:doAlloc:missing:'->dumpT; dopt -> dumpTN;
               (*scanSons
                   (#
                    do (if not isLast then
                          isFirst -> current.load
                        else
                           not isFirst -> current.doAlloc
                   if)#);*)
            #);
          pushThis:: (#do L: scanSons(#do current.pushThis; leave L #)#);
          loadOrigin:: 
            (# 
            do cd.fcom(#do 'Remote:loadOrigin:'->TT; doPT -> TT #);
               L: scanSons(#do current.loadOrigin; leave L #)
            #);
          activate::
            (#
            do cd.fcom(#do 'Remote:activate:'->TT; doPT -> TT #);
               scanSons
               (#
               do (if not isLast then
                      (ND[],'L',true,isIndexed) -> current.activate
                   else
                      (ND[],LMR,isRef,isIndexed) -> current.activate
            if)#)#);
          doCall::
            (#
            do cd.fcom(#do 'remote:doCall'->TT; dopt->TT #);
               scanSons(# do (if isLast then (doPT,LMR) -> current.docall if)#)
            #)
       #);
          
     ConstExp::
       (# activate:: (# do cst.T.setpos; cst.T.getInt  -> cd.pushConst #);
       #);
     CharExp:: 
       (# activate:: (#do theCh.T.setpos; 1 -> theCh.T.inxGet ->cd.pushConst #);
       #);
     objTmpStack: @
       (# ODs: [30] ^ObjectDesc; next,top: @integer;
          add:
            (# OD: ^ObjectDesc; 
            enter OD[]
            do (if (top + 1 -> top) > ODs.range then
                   ODs.range -> ODs.extend
               if);
               (if OD.slt[] = none then
                   OD[] -> ODs[top][]
                else
                   (# found: @boolean
                   do cd.fcom(#do 'objTmpStack.add:SLOT'->TT;OD.slt.dopt->TT#);
                      OD.slt.scanBindings
                      (# ODF: ^ObjDescFrag
                      do (*cd.fcom(#do 'adding:'->TT; current.dopt-> TT #);*)
                         true -> found;
                         (current[] -> ODF[]).OD[] -> ODs[top][]
                      #);
                      (if not found then top - 1 -> top if)
            #)if)#); 
          genNext: BooleanValue
            (#
            do (if (next + 1 -> next) <= top then
                   ODs[next].genClass;
                   true -> value
            if)#)
       #);   
     genStdBeta:
       (#
       do '**** Generator: StdBeta:'->dumptn;
          (if true then
              allocStdBeta;
           else
              topModule.alloc;
          if);
          topModule.gen;
          cd.com(#do 'objTmpStack.gen'->TT #);
          L:
            (if objTmpStack.genNext then
                restart L
       if)#);
     cd:  ^ObjectCode;
  enter cd[]
  #);

