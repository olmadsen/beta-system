ChemicalPlantSystem: obj
   %include Containers
   Qualification:
      in Q: var integer
      print: {"Qualification:".print; putint(Q)}
   Qualifications: Set.Set(#Qualification)
      print: {scan{current.print}} 
   
   Expert:
      in name: ref String.String   
      in quali: ref Qualifications
      print:
         "Expert:".print
         name.print
         put(':')
         quali.print
         newline 
   Experts: Set.Set(#Expert)
      print: {scan{current.print}}
   
   Alarm:
      in descr: ref String.String
      in reqQuali: ref Qualification
   Alarms: Set.Set(#Alarm)
      dumx: var integer -- currently the mainpart cannot be empty

   Period:
      in start: var integer
      in end: var integer
      print:
         "Period:".print
         putint(start)
         put(',')
         putint(end)
         newline 
   Periods: Set.Set(#Period)
      print: {scan{current.print}}
   
   Schedule: MapLib.Map(#Period,#Experts)
      dum: var integer
   
   Plant:
      in theAlarms: ref Alarms
      in theSchedule: ref Schedule
      PlantInvX:
          %id "PlantInvX"
          out B: var Boolean
          B := theSchedule.forAll({B:= E.elm.isEmpty.not})
          B := B && theAlarms.forAllB({in A: ref Alarm; out BB: var Boolean; BB := theSchedule.forAll({XX: ref Experts; XX := E.elm; V := XX.exists({V := X.quali.has(A.reqQuali)})})})
	  
      PlantInvB:
          %id "PlantInvB"
          out B: var Boolean
          B := theSchedule.forAll({B := E.elm.isEmpty.not})

      PlantInv:
          out B: var Boolean
          B := true
          theSchedule.scan
              B := B && current.elm.isEmpty.not
          theAlarms.forAll -- for all A in alarm
              A: ref Alarm
              A := current
              theSchedule.scan -- for all current in schedule
                 -- an Expert E with qualifications needed 
                 -- for the Alarm A must exist
                 bbb: var Boolean
                 bbb := current.elm.exists({in E: ref Expert; out R: var Boolean; R := E.quali.has(A.reqQuali)})
                 B := B && bbb
      ExpertToPage:
         in a: ref Alarm
         in p: ref Period
         out exp: ref Expert
         theSchedule.lookup(p).scan -- exp not defined, should be current?
            @if exp.quali.has(A.reqQuali) :then
                @leave ExpertToPage
      numberOfExperts:
         in p: ref Period
         out n: var integer
         n := theSchedule.lookup(p).card
      expertIsOnDuty:
         in ep: ref Expert
         out fp: obj Periods
         theSchedule.scan
            @if current.elm.has(ep) :then
                fp.insert(current.inx)
         fp.print
      expertIsOnDutyR:
         in ep: ref Expert
         out fp: ref Periods
         fp:= theSchedule.select({in p: ref Period; in ES: ref Experts; out B: var boolean; B := ES.has(ep)})
         fp.print
   Q: obj Qualification(17)
   QS: obj Qualifications
   
   E1: ref Expert
   E2: ref Expert
   ES1: obj set.set(#Expert)
   ES2: obj set.set(#Expert)
   A: ref Alarm
   AS: obj Alarms
   
   S: obj Schedule
   
   P: obj Plant(AS,S)
   QS.insert(Q)
   A := Alarm("OverHeat",Q)
   E1 := Expert("John",QS)
   ES1.insert(E1)
   E1:= Expert("Laura",QS)
   ES1.insert(E1)   
   S.add(Period(0,8),ES1)
   E2:= Expert("Surayya",QS)
   ES2.insert(E2)
   S.add(Period(8,16),ES2)
   S.add(Period(16,24),ES1)
   AS.insert(A)
   @if P.PlantInv :then
      "P.plantInv = true\n".print
   :else
      "P.plantInv = not true\n".print

   @if P.PlantInvB :then
      "P.plantInvB = true\n".print
   :else
      "P.plantInvB = not true\n".print
   @if P.PlantInv :then
      "P.plantInvX = true\n".print
   :else
      "P.plantInvX = not true\n".print
   newline
   
   "On duty:".print
   E1.print
   P.expertIsOnDuty(E1)
   "On duty:".print
   E2.print   
   P.expertIsOnDuty(E2)   
   newline
   
   "On duty:".print
   E1.print
   P.expertIsOnDutyR(E1)
   "On duty:".print
   E2.print   
   P.expertIsOnDutyR(E2)    
   
   
   