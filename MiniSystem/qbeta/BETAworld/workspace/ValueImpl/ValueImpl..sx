
 CLASS BETAworld 21 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "inner(Object)" 
 -- OG:before:super.gen: "inner(Object)" 
 -- INV:gen: "inner(Object)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- rec:  "inner(Object)" E:  "inner(Object)" 
 -- INV:gen:E.loadArgs "inner(Object)" 
 -- INV:gen:after:E.loadArgs "inner(Object)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Object)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(O ..." 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner" E: "inner(Object)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS BETAworld 1 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 pushThis 
 saveBETAworld
 mvStack 
 -- OG:gen: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;         %ba ...}" 
 pushThis 
 -- before objTmpStack:add:  2   "BETA" 
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Compi ...}" 
 pushThis 
 -- before objTmpStack:add:  33   "LIB" 
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasi ...}" 
 pushThis 
 -- before objTmpStack:add:  65   "workspace" 
 invoke workspace 65 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS BETA 2 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   null: ...}" 
 pushThis 
 -- before objTmpStack:add:  3   "ascii" 
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0

 CLASS ascii 3 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- INV:gen: "10" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 pushThis 
 storeg nl 2
 -- OG:gen: "13" 
 -- OG:before:super.gen: "13" 
 -- INV:gen: "13" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "13" E:  "13" 
 -- INV:gen:E.loadArgs "13" 
 -- INV:gen:after:E.loadArgs "13" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "13" 
 pushc 13
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 pushThis 
 storeg cr 3
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- INV:gen: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 pushThis 
 storeg null 4
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 pushThis 
 -- OG:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- OG:before:super.gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- INV:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 pushc 10
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg ascii$3 5
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS Value 4 0 BETA 2 isValueObj
DO:
 L1:
 L2:
 rtnV
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS integer 5 0 BETA 2 isValueObj
DO:
 L1:
 L2:
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS universal 6 0 BETA 2 isValueObj
DO:
 L1:
 L2:
 rtnV
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0

 CLASS char 7 0 BETA 2 isValueObj
DO:
 L1:
 L2:
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ConsoleIF 8 1 BETA 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 9 1 ConsoleIF 8
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS String 10 0 StringLib 39
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1

 CLASS = 11 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 L4:
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 store 2 origin.valueOff
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "inner(= )" 
 -- OG:before:super.gen: "inner(= )" 
 -- INV:gen: "inner(= )" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- rec:  "inner(= )" E:  "inner(= )" 
 -- INV:gen:E.loadArgs "inner(= )" 
 -- INV:gen:after:E.loadArgs "inner(= )" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(= )" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )": ... 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner" E: "inner(= )" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      c1 ...}" 
 pushThis 
 -- before objTmpStack:add:  14   "loop" 
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS loop 14 1 = 13
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "L := length" 
 pushThis 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- INV:gen: "length" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg loop$14 1
 -- items:goOrigin: 1 
 rpushg =$13 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- assign:adr.store:A: 
 storeg loop$14 4
 -- assign:adr.store:B: 
 -- OG:gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:before:super.gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- INV:gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L <> Veq.length) :then {   leave(loop)}" E:  "if (L <> Veq.length) :then {   leave(loop)}" 
 -- INV:gen:E.loadArgs "if (L <> Veq.length) :then {   leave(loop)}" 
 -- INV:gen:after:E.loadArgs "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:gen: "(L <> Veq.length)" 
 -- OG:before:super.gen: "(L <> Veq.length)" 
 -- INV:gen: "(L <> Veq.length)" 
 -- BinaryExp:loadOrigin:empty: "L <> Veq.length" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L <> Veq.length" E:  "L <> Veq.length" 
 -- INV:gen:E.loadArgs "L <> Veq.length" 
 -- BinaryExp:loadArgs: "L <> Veq.length" superAdj: 0 
 -- INV:gen: "L" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 pushg 4 loop$14
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OG:gen: "Veq.length" 
 -- OG:before:super.gen: "Veq.length" 
 -- INV:gen: "Veq.length" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$14 1
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "length" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$14 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec:  "Veq" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L <> Veq.length" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L <> Veq.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L" rec: "L <> Veq.length" 
 -- M: "<> Veq.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>  " E: "<> Veq.length" ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "leave(loop)" 
 pushThis 
 -- before objTmpStack:add:  18   "$18" 
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign: "beq := true" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$14 1
 -- OG:gen: "true" 
 -- OG:before:super.gen: "true" 
 -- INV:gen: "true" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "true" E:  "true" 
 -- INV:gen:E.loadArgs "true" 
 -- INV:gen:after:E.loadArgs "true" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true" 
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- ptn:invoke: "True" E: "true" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- OG:gen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30" 
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS length 15 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "V := get[0] -- actually an index error, accessing length" 
 pushThis 
 -- OG:gen: "get[0] -- actually an index error, accessing length" 
 -- OG:before:super.gen: "get[0] -- actually an index error, accessing length" 
 -- INV:gen: "get[0] -- actually an index error, accessing length" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg length$15 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing len ..." 
 -- rec:  "get[0] -- actually an index error, accessing length" E:  "get[0] -- actually an index error, accessing length" 
 -- INV:gen:E.loadArgs "get[0] -- actually an index error, accessing length" 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- INV:gen: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- INV:gen:after:E.loadArgs "get[0] -- actually an index error, accessing length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[0] -- actually an index error, accessing length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[0] -- actually an index error, accessing length" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0 ... 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0 ... 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- a ... 
 -- assign:adr.store:A: 
 storeg length$15 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS this 31 1 BETA 2
 pushThis 
 rstoreg  this 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS X_asString 32 1 Object 21
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "inner(X_asString)" 
 -- OG:before:super.gen: "inner(X_asString)" 
 -- INV:gen: "inner(X_asString)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- rec:  "inner(X_asString)" E:  "inner(X_asString)" 
 -- INV:gen:E.loadArgs "inner(X_asString)" 
 -- INV:gen:after:E.loadArgs "inner(X_asString)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(X_asString)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inn ..." 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner" E: "inner(X_asString)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS LIB 33 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: var  ...}" 
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO" 
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %publi ...}" 
 pushThis 
 -- before objTmpStack:add:  38   "Dimensions" 
 invoke Dimensions 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      length ...}" 
 pushThis 
 -- before objTmpStack:add:  39   "StringLib" 
 invoke StringLib 39 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS BasicIO 34 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;      ...}" 
 pushThis 
 -- before objTmpStack:add:  35   "keyboard" 
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 pushThis 
 -- before objTmpStack:add:  36   "screen" 
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS keyboard 35 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS screen 36 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "Lock" 
 -- OG:before:super.gen: "Lock" 
 -- INV:gen: "Lock" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg screen$36 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- rec:  "Lock" E:  "Lock" 
 -- INV:gen:E.loadArgs "Lock" 
 -- INV:gen:after:E.loadArgs "Lock" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Lock" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- ptn:invoke: "Lock" E: "Lock" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS Lock 37 1 BasicIO 34
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS Dimensions 38 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS StringLib 39 1 LIB 33
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 saveStringOrigin
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $18 18 1 loop 14
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "leave(loop)" 
 -- OG:before:super.gen: "leave(loop)" 
 -- INV:gen: "leave(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- rec:  "leave(loop)" E:  "leave(loop)" 
 -- INV:gen:E.loadArgs "leave(loop)" 
 -- INV:gen:after:E.loadArgs "leave(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loo ..." 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(loop)" ptnKind: 0 useRtnV: false 
 break  1 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS if:then 20 0 BETA 2
 pushThis 
 storeg Boolean$40 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS Boolean 40 0 BETA 2 isValueObj
DO:
 L1:
 L2:
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS True 23 0 BETA 2
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "B := 1" 
 pushThis 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- INV:gen: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg True$23 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat 28 0 BETA 2
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "inx := first" 
 pushThis 
 -- OG:gen: "first" 
 -- OG:before:super.gen: "first" 
 -- INV:gen: "first" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- rec:  "first" E:  "first" 
 -- INV:gen:E.loadArgs "first" 
 -- INV:gen:after:E.loadArgs "first" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "first" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- OI:invoke:before:ATdx.invoke: var first 
 -- DI:invoke: "first: var integer" 
 pushg 1 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- OG:gen: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 pushThis 
 -- before objTmpStack:add:  41   "_doIt" 
 invoke _doIt 41 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0

 CLASS _doIt 41 1 for:to:repeat 28
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:before:super.gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- INV:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" E:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_do ...}" 
 -- INV:gen:E.loadArgs "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- INV:gen:after:E.loadArgs "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:gen: "(inx <= last)" 
 -- OG:before:super.gen: "(inx <= last)" 
 -- INV:gen: "(inx <= last)" 
 -- BinaryExp:loadOrigin:empty: "inx <= last" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx <= last" E:  "inx <= last" 
 -- INV:gen:E.loadArgs "inx <= last" 
 -- BinaryExp:loadArgs: "inx <= last" superAdj: 0 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg _doIt$41 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OG:gen: "last" 
 -- OG:before:super.gen: "last" 
 -- INV:gen: "last" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg _doIt$41 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- rec:  "last" E:  "last" 
 -- INV:gen:E.loadArgs "last" 
 -- INV:gen:after:E.loadArgs "last" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- OI:invoke:before:ATdx.invoke: var last 
 -- DI:invoke: "last: var integer" 
 pushg 2 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx <= last" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx <= last" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx" rec: "inx <= last" 
 -- M: "<= last" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=  " E: "<= last" ptnKind: 1 useRtnV: true 
 -- rec: "inx" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "inx: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 pushThis 
 -- before objTmpStack:add:  43   "$43" 
 invoke $43 43 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- OG:gen: "inx := inx" 
 pushThis 
 -- before objTmpStack:add:  46   "$46" 
 invoke $46 46 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $43 43 1 _doIt 41
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "repeat" 
 -- OG:before:super.gen: "repeat" 
 -- INV:gen: "repeat" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $43$43 1
 -- items:goOrigin: 1 
 rpushg _doIt$41 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- rec:  "repeat" E:  "repeat" 
 -- INV:gen:E.loadArgs "repeat" 
 -- INV:gen:after:E.loadArgs "repeat" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "repeat" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern repeat 
 -- ptn:invoke: "repeat" E: "repeat" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- assign: "inx := inx + 1" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $43$43 1
 -- items:goOrigin: 1 
 rpushg _doIt$41 1
 -- OG:gen: "inx + 1" 
 -- OG:before:super.gen: "inx + 1" 
 -- INV:gen: "inx + 1" 
 -- BinaryExp:loadOrigin:empty: "inx + 1" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx + 1" E:  "inx + 1" 
 -- INV:gen:E.loadArgs "inx + 1" 
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $43$43 1
 -- items:goOrigin: 1 
 rpushg _doIt$41 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- INV:gen: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx" rec: "inx + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- OG:gen: "restart(_doIt)" 
 -- OG:before:super.gen: "restart(_doIt)" 
 -- INV:gen: "restart(_doIt)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- rec:  "restart(_doIt)" E:  "restart(_doIt)" 
 -- INV:gen:E.loadArgs "restart(_doIt)" 
 -- INV:gen:after:E.loadArgs "restart(_doIt)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(_doIt)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restar ..." 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(_doIt)" ptnKind: 0 useRtnV: false 
 break  1 1 41 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $46 46 1 _doIt 41
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "inx := inx" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $46$46 1
 -- items:goOrigin: 1 
 rpushg _doIt$41 1
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $46$46 1
 -- items:goOrigin: 1 
 rpushg _doIt$41 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$28
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- assign:adr.store:A: 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$24 24 1 for:to:repeat$30 30
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "c1 := get[inx]" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$24$24 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$30$30 4
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- INV:gen: "get[inx]" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg repeat$24$24 1
 -- items:goOrigin: 3 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin: 2 
 rpushg loop$14 1
 -- items:goOrigin: 1 
 rpushg =$13 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg repeat$24$24 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg loop$14 2
 -- assign:adr.store:B: 
 -- assign: "c2 := Veq.get[inx]" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$24$24 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$30$30 4
 -- OG:gen: "Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx]" 
 -- INV:gen: "Veq.get[inx]" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg repeat$24$24 1
 -- items:goOrigin: 2 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin: 1 
 rpushg loop$14 1
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "get[inx]" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg repeat$24$24 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec:  "Veq" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg repeat$24$24 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$30$30
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- assign:adr.store:A: 
 storeg loop$14 3
 -- assign:adr.store:B: 
 -- OG:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:before:super.gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- INV:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" E:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- INV:gen:E.loadArgs "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- INV:gen:after:E.loadArgs "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:gen: "(c1 <> c2)" 
 -- OG:before:super.gen: "(c1 <> c2)" 
 -- INV:gen: "(c1 <> c2)" 
 -- BinaryExp:loadOrigin:empty: "c1 <> c2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 <> c2" E:  "c1 <> c2" 
 -- INV:gen:E.loadArgs "c1 <> c2" 
 -- BinaryExp:loadArgs: "c1 <> c2" superAdj: 0 
 -- INV:gen: "c1" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$24$24 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$30$30 4
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 pushg 2 loop$14
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- INV:gen: "c2" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$24$24 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$30$30 4
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 pushg 3 loop$14
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 <> c2" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 <> c2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1" rec: "c1 <> c2" 
 -- M: "<> c2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- ptn:invoke: "<>  " E: "<> c2" ptnKind: 0 useRtnV: true 
 ne
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "Beq := false{   leave(loop)}" 
 pushThis 
 -- before objTmpStack:add:  26   "$26" 
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $26 26 1 repeat$24 24
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "Beq := false" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg $26$26 1
 -- items:goOrigin: 3 
 rpushg repeat$24$24 1
 -- items:goOrigin: 2 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin: 1 
 rpushg loop$14 1
 -- OG:gen: "false" 
 -- OG:before:super.gen: "false" 
 -- INV:gen: "false" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "false" E:  "false" 
 -- INV:gen:E.loadArgs "false" 
 -- INV:gen:after:E.loadArgs "false" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false" 
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False" E: "false" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- OG:gen: "leave(loop)" 
 -- OG:before:super.gen: "leave(loop)" 
 -- INV:gen: "leave(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- rec:  "leave(loop)" E:  "leave(loop)" 
 -- INV:gen:E.loadArgs "leave(loop)" 
 -- INV:gen:after:E.loadArgs "leave(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loo ..." 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(loop)" ptnKind: 0 useRtnV: false 
 break  3 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS False 27 0 BETA 2
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "B := 0" 
 pushThis 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- INV:gen: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg False$27 1
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- INV:gen: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- INV:gen: "length" 
 pushThis 
 rpushg loop$14 4
 -- items:goOrigin: 2 
 rpushg loop$14 1
 -- items:goOrigin: 1 
 rpushg =$13 1
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS <= 42 1 Value 4
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 L4:
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 store 2 origin.valueOff
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0

 CLASS <= 47 1 String 10
 -- vdtTableCopy: I:1:42
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 pushThis 
 rpushg iOrigin 1
 rShiftDown  1
 pushThis 
 rstoreg  Veq 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - false ...}" 
 pushThis 
 -- before objTmpStack:add:  48   "loop" 
 invoke loop 48 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS loop 48 1 <= 47
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "L1 := length{-- min length of this and V}" 
 pushThis 
 -- OG:gen: "length{-- min length of this and V}" 
 -- OG:before:super.gen: "length{-- min length of this and V}" 
 -- INV:gen: "length{-- min length of this and V}" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg loop$48 1
 -- items:goOrigin: 1 
 rpushg <=$47 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:-} 
 -- rec:  "length{-- min length of this and V}" E:  "length{-- min length of this and V}" 
 -- INV:gen:E.loadArgs "length{-- min length of this and V}" 
 -- INV:gen:after:E.loadArgs "length{-- min length of this and V}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length{-- min length of this and V}" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length{-- min length of this and V}" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":re ...} 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min l ...} 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length o ...} 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V ...} 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length o ...} 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V ...} 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this ...} 
 -- assign:adr.store:A: 
 storeg loop$48 3
 -- assign:adr.store:B: 
 -- assign: "L2 := Veq.length" 
 pushThis 
 -- OG:gen: "Veq.length" 
 -- OG:before:super.gen: "Veq.length" 
 -- INV:gen: "Veq.length" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$48 1
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "length" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$48 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec:  "Veq" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- assign:adr.store:A: 
 storeg loop$48 4
 -- assign:adr.store:B: 
 -- OG:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:before:super.gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- INV:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" E:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- INV:gen:E.loadArgs "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- INV:gen:after:E.loadArgs "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:gen: "(L1 < L2)" 
 -- OG:before:super.gen: "(L1 < L2)" 
 -- INV:gen: "(L1 < L2)" 
 -- BinaryExp:loadOrigin:empty: "L1 < L2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L1 < L2" E:  "L1 < L2" 
 -- INV:gen:E.loadArgs "L1 < L2" 
 -- BinaryExp:loadArgs: "L1 < L2" superAdj: 0 
 -- INV:gen: "L1" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 pushg 3 loop$48
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- INV:gen: "L2" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 pushg 4 loop$48
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 < L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 < L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1" rec: "L1 < L2" 
 -- M: "< L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<  " E: "< L2" ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "L := L1" 
 pushThis 
 -- before objTmpStack:add:  50   "$50" 
 invoke $50 50 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- OG:gen: "L := L2" 
 pushThis 
 -- before objTmpStack:add:  51   "$51" 
 invoke $51 51 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "matchEq" 
 -- OG:before:super.gen: "matchEq" 
 -- INV:gen: "matchEq" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- rec:  "matchEq" E:  "matchEq" 
 -- INV:gen:E.loadArgs "matchEq" 
 -- INV:gen:after:E.loadArgs "matchEq" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "matchEq" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern matchEq 
 -- ptn:invoke: "matchEq" E: "matchEq" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 invoke matchEq 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS $50 50 1 loop 48
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "L := L1" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg $50$50 1
 -- OG:gen: "L1" 
 -- OG:before:super.gen: "L1" 
 -- INV:gen: "L1" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg $50$50 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 pushg 3 loop$48
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- assign:adr.store:A: 
 storeg loop$48 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $51 51 1 loop 48
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "L := L2" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg $51$51 1
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- INV:gen: "L2" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg $51$51 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 pushg 4 loop$48
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- assign:adr.store:A: 
 storeg loop$48 2
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS matchEq 52 1 loop 48
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  53   "isEmpty" 
 invoke isEmpty 53 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  56   "loop" 
 invoke loop 56 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  59   "doit" 
 invoke doit 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS isEmpty 53 1 matchEq 52
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- INV:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" E:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- INV:gen:E.loadArgs "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- INV:gen:after:E.loadArgs "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:gen: "(L1 = 0)" 
 -- OG:before:super.gen: "(L1 = 0)" 
 -- INV:gen: "(L1 = 0)" 
 -- BinaryExp:loadOrigin:empty: "L1 = 0" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 = 0" E:  "L1 = 0" 
 -- INV:gen:E.loadArgs "L1 = 0" 
 -- BinaryExp:loadArgs: "L1 = 0" superAdj: 0 
 -- INV:gen: "L1" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg isEmpty$53 1
 -- items:goOrigin: 1 
 rpushg matchEq$52 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 pushg 3 loop$48
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- INV:gen: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 = 0" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 = 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1" rec: "L1 = 0" 
 -- M: "= 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=  " E: "= 0" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "Beq := L1 <= L2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  54   "$54" 
 invoke $54 54 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- INV:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" E:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- INV:gen:E.loadArgs "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- INV:gen:after:E.loadArgs "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:gen: "(L2 = 0)" 
 -- OG:before:super.gen: "(L2 = 0)" 
 -- INV:gen: "(L2 = 0)" 
 -- BinaryExp:loadOrigin:empty: "L2 = 0" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L2 = 0" E:  "L2 = 0" 
 -- INV:gen:E.loadArgs "L2 = 0" 
 -- BinaryExp:loadArgs: "L2 = 0" superAdj: 0 
 -- INV:gen: "L2" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg isEmpty$53 1
 -- items:goOrigin: 1 
 rpushg matchEq$52 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 pushg 4 loop$48
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- INV:gen: "0" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:after:E.loadArgs "L2 = 0" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L2 = 0" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- BinaryExp:invoke: "L2" rec: "L2 = 0" 
 -- M: "= 0" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=  " E: "= 0" ptnKind: 1 useRtnV: true 
 -- rec: "L2" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L2: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L7
 L6:
 -- OG:gen: "Beq := false{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  55   "$55" 
 invoke $55 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $54 54 1 isEmpty 53
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "Beq := L1 <= L2" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg $54$54 1
 -- items:goOrigin: 3 
 rpushg isEmpty$53 1
 -- items:goOrigin: 2 
 rpushg matchEq$52 1
 -- items:goOrigin: 1 
 rpushg loop$48 1
 -- OG:gen: "L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2" 
 -- INV:gen: "L1 <= L2" 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 <= L2" E:  "L1 <= L2" 
 -- INV:gen:E.loadArgs "L1 <= L2" 
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- INV:gen: "L1" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg $54$54 1
 -- items:goOrigin: 2 
 rpushg isEmpty$53 1
 -- items:goOrigin: 1 
 rpushg matchEq$52 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 pushg 3 loop$48
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- INV:gen: "L2" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg $54$54 1
 -- items:goOrigin: 2 
 rpushg isEmpty$53 1
 -- items:goOrigin: 1 
 rpushg matchEq$52 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 pushg 4 loop$48
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1" rec: "L1 <= L2" 
 -- M: "<= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=  " E: "<= L2" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg <=$47 3
 -- assign:adr.store:B: 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- INV:gen: "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 52 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $55 55 1 isEmpty 53
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "Beq := false" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg $55$55 1
 -- items:goOrigin: 3 
 rpushg isEmpty$53 1
 -- items:goOrigin: 2 
 rpushg matchEq$52 1
 -- items:goOrigin: 1 
 rpushg loop$48 1
 -- OG:gen: "false" 
 -- OG:before:super.gen: "false" 
 -- INV:gen: "false" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "false" E:  "false" 
 -- INV:gen:E.loadArgs "false" 
 -- INV:gen:after:E.loadArgs "false" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false" 
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- ptn:invoke: "False" E: "false" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg <=$47 3
 -- assign:adr.store:B: 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- INV:gen: "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 52 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS loop 56 1 matchEq 52
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "inx := inx + 1" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- OG:gen: "inx + 1" 
 -- OG:before:super.gen: "inx + 1" 
 -- INV:gen: "inx + 1" 
 -- BinaryExp:loadOrigin:empty: "inx + 1" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx + 1" E:  "inx + 1" 
 -- INV:gen:E.loadArgs "inx + 1" 
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 2 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- INV:gen: "1" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx" rec: "inx + 1" 
 -- M: "+ 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg matchEq$52 2
 -- assign:adr.store:B: 
 -- assign: "c1 := get[inx]" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- INV:gen: "get[inx]" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg loop$56 1
 -- items:goOrigin: 3 
 rpushg matchEq$52 1
 -- items:goOrigin: 2 
 rpushg loop$48 1
 -- items:goOrigin: 1 
 rpushg <=$47 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 2 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg matchEq$52 3
 -- assign:adr.store:B: 
 -- assign: "c2 := Veq.get[inx]" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- OG:gen: "Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx]" 
 -- INV:gen: "Veq.get[inx]" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg loop$56 1
 -- items:goOrigin: 2 
 rpushg matchEq$52 1
 -- items:goOrigin: 1 
 rpushg loop$48 1
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "get[inx]" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg loop$56 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec:  "Veq" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 2 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- assign:adr.store:A: 
 storeg matchEq$52 4
 -- assign:adr.store:B: 
 -- OG:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:before:super.gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- INV:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" E:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- INV:gen:E.loadArgs "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:gen: "(c1 = c2)" 
 -- OG:before:super.gen: "(c1 = c2)" 
 -- INV:gen: "(c1 = c2)" 
 -- BinaryExp:loadOrigin:empty: "c1 = c2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 = c2" E:  "c1 = c2" 
 -- INV:gen:E.loadArgs "c1 = c2" 
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- INV:gen: "c1" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 pushg 3 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- INV:gen: "c2" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 pushg 4 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1" rec: "c1 = c2" 
 -- M: "= c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=  " E: "= c2" ptnKind: 1 useRtnV: true 
 -- rec: "c1" "Invocation" OGx.label: "ObjectGenerator" OGx: char 
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: char 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "if (inx < L) :then {      restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  57   "$57" 
 invoke $57 57 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $57 57 1 loop 56
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "if (inx < L) :then {   restart(loop)}" 
 -- OG:before:super.gen: "if (inx < L) :then {   restart(loop)}" 
 -- INV:gen: "if (inx < L) :then {   restart(loop)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (inx < L) :then {   restart(loop)}" E:  "if (inx < L) :then {   restart(loop)}" 
 -- INV:gen:E.loadArgs "if (inx < L) :then {   restart(loop)}" 
 -- INV:gen:after:E.loadArgs "if (inx < L) :then {   restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (inx < L) :then {   restart(loop)}" 
 -- OG:gen: "(inx < L)" 
 -- OG:before:super.gen: "(inx < L)" 
 -- INV:gen: "(inx < L)" 
 -- BinaryExp:loadOrigin:empty: "inx < L" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx < L" E:  "inx < L" 
 -- INV:gen:E.loadArgs "inx < L" 
 -- BinaryExp:loadArgs: "inx < L" superAdj: 0 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $57$57 1
 -- items:goOrigin: 1 
 rpushg loop$56 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 2 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- INV:gen: "L" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg $57$57 1
 -- items:goOrigin: 2 
 rpushg loop$56 1
 -- items:goOrigin: 1 
 rpushg matchEq$52 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 pushg 2 loop$48
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx < L" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx < L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:invoke: "inx" rec: "inx < L" 
 -- M: "< L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<  " E: "< L" ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "restart(loop)" 
 pushThis 
 -- before objTmpStack:add:  58   "$58" 
 invoke $58 58 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $58 58 1 $57 57
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "restart(loop)" 
 -- OG:before:super.gen: "restart(loop)" 
 -- INV:gen: "restart(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- rec:  "restart(loop)" E:  "restart(loop)" 
 -- INV:gen:E.loadArgs "restart(loop)" 
 -- INV:gen:after:E.loadArgs "restart(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loop)" ptnKind: 0 useRtnV: false 
 break  2 1 56 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS doit 59 1 matchEq 52
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- INV:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" E:  "if (c1 = c2) :then {   -- we have inx = ...}" 
 -- INV:gen:E.loadArgs "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:gen: "(c1 = c2)" 
 -- OG:before:super.gen: "(c1 = c2)" 
 -- INV:gen: "(c1 = c2)" 
 -- BinaryExp:loadOrigin:empty: "c1 = c2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 = c2" E:  "c1 = c2" 
 -- INV:gen:E.loadArgs "c1 = c2" 
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- INV:gen: "c1" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg doit$59 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 pushg 3 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- INV:gen: "c2" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg doit$59 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 pushg 4 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1" rec: "c1 = c2" 
 -- M: "= c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- ptn:invoke: "=  " E: "= c2" ptnKind: 1 useRtnV: true 
 -- rec: "c1" "Invocation" OGx.label: "ObjectGenerator" OGx: char 
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: char 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- OG:gen: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  60   "$60" 
 invoke $60 60 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- OG:gen: "Beq := c1 < c2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  61   "$61" 
 invoke $61 61 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $60 60 1 doit 59
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "Beq := L1 <= L2" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg $60$60 1
 -- items:goOrigin: 3 
 rpushg doit$59 1
 -- items:goOrigin: 2 
 rpushg matchEq$52 1
 -- items:goOrigin: 1 
 rpushg loop$48 1
 -- OG:gen: "L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2" 
 -- INV:gen: "L1 <= L2" 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 <= L2" E:  "L1 <= L2" 
 -- INV:gen:E.loadArgs "L1 <= L2" 
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- INV:gen: "L1" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg $60$60 1
 -- items:goOrigin: 2 
 rpushg doit$59 1
 -- items:goOrigin: 1 
 rpushg matchEq$52 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var integer" 
 pushg 3 loop$48
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- INV:gen: "L2" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg $60$60 1
 -- items:goOrigin: 2 
 rpushg doit$59 1
 -- items:goOrigin: 1 
 rpushg matchEq$52 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- DI:invoke: "L2: var integer" 
 pushg 4 loop$48
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- BinaryExp:invoke: "L1" rec: "L1 <= L2" 
 -- M: "<= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- ptn:invoke: "<=  " E: "<= L2" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg <=$47 3
 -- assign:adr.store:B: 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- INV:gen: "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 52 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS $61 61 1 doit 59
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "Beq := c1 < c2" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg $61$61 1
 -- items:goOrigin: 3 
 rpushg doit$59 1
 -- items:goOrigin: 2 
 rpushg matchEq$52 1
 -- items:goOrigin: 1 
 rpushg loop$48 1
 -- OG:gen: "c1 < c2" 
 -- OG:before:super.gen: "c1 < c2" 
 -- INV:gen: "c1 < c2" 
 -- BinaryExp:loadOrigin:empty: "c1 < c2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 < c2" E:  "c1 < c2" 
 -- INV:gen:E.loadArgs "c1 < c2" 
 -- BinaryExp:loadArgs: "c1 < c2" superAdj: 0 
 -- INV:gen: "c1" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $61$61 1
 -- items:goOrigin: 1 
 rpushg doit$59 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- DI:invoke: "c1: var char" 
 pushg 3 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- INV:gen: "c2" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg $61$61 1
 -- items:goOrigin: 1 
 rpushg doit$59 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- DI:invoke: "c2: var char" 
 pushg 4 matchEq$52
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 < c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 < c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- BinaryExp:invoke: "c1" rec: "c1 < c2" 
 -- M: "< c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- ptn:invoke: "<  " E: "< c2" ptnKind: 0 useRtnV: true 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg <=$47 3
 -- assign:adr.store:B: 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- INV:gen: "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 52 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS puttext 63 1 ConsoleIF 8
 pushThis 
 rstoreg  T 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "inner(puttext)" 
 -- OG:before:super.gen: "inner(puttext)" 
 -- INV:gen: "inner(puttext)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- rec:  "inner(puttext)" E:  "inner(puttext)" 
 -- INV:gen:E.loadArgs "inner(puttext)" 
 -- INV:gen:after:E.loadArgs "inner(puttext)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(puttext)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner( ..." 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner" E: "inner(puttext)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS putint 64 1 ConsoleIF 8
 pushThis 
 storeg integer$5 2
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "inner(putint)" 
 -- OG:before:super.gen: "inner(putint)" 
 -- INV:gen: "inner(putint)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- rec:  "inner(putint)" E:  "inner(putint)" 
 -- INV:gen:E.loadArgs "inner(putint)" 
 -- INV:gen:after:E.loadArgs "inner(putint)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(putint)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(p ..." 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- ptn:invoke: "inner" E: "inner(putint)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS workspace 65 1 BETAworld 1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "Point(x: var integer,y: var integer): Value{      print: ;         put(x + 2);         put(y + 2);      put(x);      put(y);   Complex(I: var float,R: var Float): ...}" 
 pushThis 
 -- before objTmpStack:add:  66   "ValueImpl" 
 invoke ValueImpl 66 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS ValueImpl 66 1 workspace 65
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "TryImplIV{--tryImplV}" 
 -- OG:before:super.gen: "TryImplIV{--tryImplV}" 
 -- INV:gen: "TryImplIV{--tryImplV}" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"TryImplIV":rec:- 
 -- rec:  "TryImplIV" E:  "TryImplIV" 
 -- INV:gen:E.loadArgs "TryImplIV" 
 -- INV:gen:after:E.loadArgs "TryImplIV" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "TryImplIV" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"TryImplIV":re ... 
 -- OI:invoke:before:ATdx.invoke: pattern tryImplIV 
 -- ptn:invoke: "tryImplIV" E: "TryImplIV" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"TryImplIV":rec:TryImplIV 
 invoke tryImplIV 67 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"TryImplIV":rec:TryImplIV 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"TryImplIV":rec:TryImplIV 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"TryImplIV":rec:TryImplIV 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS tryImplIV 67 1 ValueImpl 66
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "Line('o','p')" 
 -- OG:before:super.gen: "Line('o','p')" 
 -- INV:gen: "Line('o','p')" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Line('o','p')" E:  "Line('o','p')" 
 -- INV:gen:E.loadArgs "Line('o','p')" 
 -- OG:gen: "'o'" 
 -- OG:before:super.gen: "'o'" 
 -- INV:gen: "'o'" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'o'" E:  "'o'" 
 -- INV:gen:E.loadArgs "'o'" 
 -- INV:gen:after:E.loadArgs "'o'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'o'" 
 pushc 111
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "'p'" 
 -- OG:before:super.gen: "'p'" 
 -- INV:gen: "'p'" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'p'" E:  "'p'" 
 -- INV:gen:E.loadArgs "'p'" 
 -- INV:gen:after:E.loadArgs "'p'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'p'" 
 pushc 112
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- INV:gen:after:E.loadArgs "Line('o','p')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Line('o','p')" 
 -- OI:invoke:before:ATdx.invoke: pattern Line 
 -- ptn:invoke: "Line" E: "Line('o','p')" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  Line 68 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "L1.print" 
 -- OG:before:super.gen: "L1.print" 
 -- INV:gen: "L1.print" 
 pushThis 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- DI:invoke: "L1: var Line('o','p')" 
 -- isValueObj:isAdr: true objSize: 6  rec "L1" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:push:valOff:descNo:B: 
 pushc 2
 pushc 68
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- rec:  "L1" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke print 70 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0

 CLASS Line 68 0 ValueImpl 66 isValueObj
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 -- OG:gen: "xPoint(X1,X2) -- 3-4" 
 -- OG:before:super.gen: "xPoint(X1,X2) -- 3-4" 
 -- INV:gen: "xPoint(X1,X2) -- 3-4" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "xPoint(X1,X2) -- 3-4" E:  "xPoint(X1,X2) -- 3-4" 
 -- INV:gen:E.loadArgs "xPoint(X1,X2) -- 3-4" 
 -- OG:gen: "X1" 
 -- OG:before:super.gen: "X1" 
 -- INV:gen: "X1" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:- 
 -- rec:  "X1" E:  "X1" 
 -- INV:gen:E.loadArgs "X1" 
 -- INV:gen:after:E.loadArgs "X1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X1" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X1 
 -- DI:invoke: "in X1: var integer -- 1" 
 pushg 1 Line$68
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- OG:gen: "X2" 
 -- OG:before:super.gen: "X2" 
 -- INV:gen: "X2" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:- 
 -- rec:  "X2" E:  "X2" 
 -- INV:gen:E.loadArgs "X2" 
 -- INV:gen:after:E.loadArgs "X2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X2 
 -- DI:invoke: "in X2: var integer -- 2" 
 pushg 2 Line$68
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- INV:gen:after:E.loadArgs "xPoint(X1,X2) -- 3-4" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "xPoint(X1,X2) -- 3-4" 
 -- OI:invoke:before:ATdx.invoke: pattern xPoint(x: var integer,y: var integer) 
 -- ptn:invoke: "xPoint(x: var integer,y: var integer)" E: "xPoint(X1,X2) -- 3-4" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 3 adr:none 
 invokeVal  xPoint 69 2 true
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- OG:before:super.gen: "xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- INV:gen: "xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "xPoint(X1 + 2,X2 + 2) -- 5-6" E:  "xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- INV:gen:E.loadArgs "xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- OG:gen: "X1 + 2" 
 -- OG:before:super.gen: "X1 + 2" 
 -- INV:gen: "X1 + 2" 
 pushValId 
 -- BinaryExp:loadOrigin:empty: "X1 + 2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "X1 + 2" E:  "X1 + 2" 
 -- INV:gen:E.loadArgs "X1 + 2" 
 -- BinaryExp:loadArgs: "X1 + 2" superAdj: 0 
 -- INV:gen: "X1" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:- 
 -- rec:  "X1" E:  "X1" 
 -- INV:gen:E.loadArgs "X1" 
 -- INV:gen:after:E.loadArgs "X1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X1" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X1 
 -- DI:invoke: "in X1: var integer -- 1" 
 pushg 1 Line$68
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- 
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- OG:gen: "2" 
 -- OG:before:super.gen: "2" 
 -- INV:gen: "2" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "2" E:  "2" 
 -- INV:gen:E.loadArgs "2" 
 -- INV:gen:after:E.loadArgs "2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "2" 
 pushc 2
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- INV:gen:after:E.loadArgs "X1 + 2" 
 -- OIadr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "X1 + 2" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- BinaryExp:invoke: "X1" rec: "X1 + 2" 
 -- M: "+ 2" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X1":rec:X1 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+  " E: "+ 2" ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 2":rec:X1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 2":rec:X1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "X2 + 2" 
 -- OG:before:super.gen: "X2 + 2" 
 -- INV:gen: "X2 + 2" 
 pushValId 
 -- BinaryExp:loadOrigin:empty: "X2 + 2" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "X2 + 2" E:  "X2 + 2" 
 -- INV:gen:E.loadArgs "X2 + 2" 
 -- BinaryExp:loadArgs: "X2 + 2" superAdj: 0 
 -- INV:gen: "X2" 
 pushThis 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:- 
 -- rec:  "X2" E:  "X2" 
 -- INV:gen:E.loadArgs "X2" 
 -- INV:gen:after:E.loadArgs "X2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "X2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:- 
 -- OI:invoke:before:ATdx.invoke: var X2 
 -- DI:invoke: "in X2: var integer -- 2" 
 pushg 2 Line$68
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- 
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- OG:gen: "2" 
 -- OG:before:super.gen: "2" 
 -- INV:gen: "2" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "2" E:  "2" 
 -- INV:gen:E.loadArgs "2" 
 -- INV:gen:after:E.loadArgs "2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "2" 
 pushc 2
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- INV:gen:after:E.loadArgs "X2 + 2" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "X2 + 2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- BinaryExp:invoke: "X2" rec: "X2 + 2" 
 -- M: "+ 2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"X2":rec:X2 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+  " E: "+ 2" ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 2":rec:X2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 2":rec:X2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- INV:gen:after:E.loadArgs "xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- OI:invoke:before:ATdx.invoke: pattern xPoint(x: var integer,y: var integer) 
 -- ptn:invoke: "xPoint(x: var integer,y: var integer)" E: "xPoint(X1 + 2,X2 + 2) -- 5-6" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 5 adr:none 
 invokeVal  xPoint 69 4 true
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
DO:
 L1:
 L2:
 rtnV
 rtn(D)
 END OSDV:0 objSize:6 isIndexed:0

 CLASS xPoint 69 0 ValueImpl 66 isValueObj
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
DO:
 L1:
 L2:
 rtnV
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS print 70 1 Line 68
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 store 2 origin.valueOff
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: ""Line[".print" 
 -- OG:before:super.gen: ""Line[".print" 
 -- INV:gen: ""Line[".print" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Line["" E:  ""Line["" 
 -- INV:gen:E.loadArgs ""Line["" 
 -- INV:gen:after:E.loadArgs ""Line["" 
 -- OIadr: 
 pushText "Line["
 -- IV:gen:checkTail: ""Line[".print" E: ""Line["" tail: "print"  not isLast: false 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 71 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "PL1.print" 
 -- OG:before:super.gen: "PL1.print" 
 -- INV:gen: "PL1.print" 
 pushThis 
 -- items:goOrigin: 1 
 -- origin.valueOff:load  2 
 rdouble 0
 rpushg print$70 1
 rswap 0
 rdouble 0
 pushg 2 print$70
 pushg 3 print$70
 -- OI:invoke:before:ATdx.invoke: var PL1 
 -- DI:invoke: "PL1: var xPoint(X1,X2) -- 3-4" 
 -- isValueObj:isAdr: true objSize: 2  rec "PL1" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- loadAdr:push:valOff:descNo:C: 
 swap
 pushc 2
 plus
 swap
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- rec:  "PL1" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 invoke print 75 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL1 
 -- OG:gen: "put(',')" 
 -- OG:before:super.gen: "put(',')" 
 -- INV:gen: "put(',')" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(',')" E:  "put(',')" 
 -- INV:gen:E.loadArgs "put(',')" 
 -- OG:gen: "','" 
 -- OG:before:super.gen: "','" 
 -- INV:gen: "','" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "','" E:  "','" 
 -- INV:gen:E.loadArgs "','" 
 -- INV:gen:after:E.loadArgs "','" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "','" 
 pushc 44
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- INV:gen:after:E.loadArgs "put(',')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(',')" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put" E: "put(',')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "PL2.print" 
 -- OG:before:super.gen: "PL2.print" 
 -- INV:gen: "PL2.print" 
 pushThis 
 -- items:goOrigin: 1 
 -- origin.valueOff:load  2 
 rdouble 0
 rpushg print$70 1
 rswap 0
 rdouble 0
 pushg 2 print$70
 pushg 3 print$70
 -- OI:invoke:before:ATdx.invoke: var PL2 
 -- DI:invoke: "PL2: var xPoint(X1 + 2,X2 + 2) -- 5-6" 
 -- isValueObj:isAdr: true objSize: 2  rec "PL2" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- loadAdr:push:valOff:descNo:C: 
 swap
 pushc 4
 plus
 swap
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- rec:  "PL2" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 invoke print 75 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- OI:invoke:V: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 5 
 -- OG:gen:end: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"print":rec:PL2 
 -- OG:gen: "put(']')" 
 -- OG:before:super.gen: "put(']')" 
 -- INV:gen: "put(']')" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(']')" E:  "put(']')" 
 -- INV:gen:E.loadArgs "put(']')" 
 -- OG:gen: "']'" 
 -- OG:before:super.gen: "']'" 
 -- INV:gen: "']'" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "']'" E:  "']'" 
 -- INV:gen:E.loadArgs "']'" 
 -- INV:gen:after:E.loadArgs "']'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "']'" 
 pushc 93
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- INV:gen:after:E.loadArgs "put(']')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(']')" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put" E: "put(']')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS print 71 1 String 10
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "for(1):to(length):repeat{   put(get[inx]);}" 
 pushThis 
 -- before objTmpStack:add:  74   "for:to:repeat$74" 
 invoke for:to:repeat$74 74 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS repeat$72 72 1 for:to:repeat$74 74
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "put(get[inx])" 
 -- OG:before:super.gen: "put(get[inx])" 
 -- INV:gen: "put(get[inx])" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(get[inx])" E:  "put(get[inx])" 
 -- INV:gen:E.loadArgs "put(get[inx])" 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- INV:gen: "get[inx]" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg repeat$72$72 1
 -- items:goOrigin: 2 
 rpushg for:to:repeat$74$74 4
 -- items:goOrigin: 1 
 rpushg print$71 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg repeat$72$72 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$74$74
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- INV:gen:after:E.loadArgs "put(get[inx])" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(get[inx])" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put" E: "put(get[inx])" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS put 73 0 BETA 2
 pushThis 
 storeg char$7 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$74 74 4 print 71
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- INV:gen: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- INV:gen: "length" 
 pushThis 
 rpushg print$71 4
 -- items:goOrigin: 1 
 rpushg print$71 1
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS print 75 1 xPoint 69
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 store 2 origin.valueOff
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "put(x)" 
 -- OG:before:super.gen: "put(x)" 
 -- INV:gen: "put(x)" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(x)" E:  "put(x)" 
 -- INV:gen:E.loadArgs "put(x)" 
 -- OG:gen: "x" 
 -- OG:before:super.gen: "x" 
 -- INV:gen: "x" 
 pushThis 
 -- items:goOrigin: 1 
 -- origin.valueOff:load  2 
 rdouble 0
 rpushg print$75 1
 rswap 0
 rdouble 0
 pushg 2 print$75
 pushg 3 print$75
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:- 
 -- rec:  "x" E:  "x" 
 -- INV:gen:E.loadArgs "x" 
 -- INV:gen:after:E.loadArgs "x" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "x" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:- 
 -- OI:invoke:before:ATdx.invoke: var x 
 -- DI:invoke: "x: var integer" 
 ovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- 
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"x":rec:x 
 -- INV:gen:after:E.loadArgs "put(x)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(x)" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put" E: "put(x)" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "put(y)" 
 -- OG:before:super.gen: "put(y)" 
 -- INV:gen: "put(y)" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(y)" E:  "put(y)" 
 -- INV:gen:E.loadArgs "put(y)" 
 -- OG:gen: "y" 
 -- OG:before:super.gen: "y" 
 -- INV:gen: "y" 
 pushThis 
 -- items:goOrigin: 1 
 -- origin.valueOff:load  2 
 rdouble 0
 rpushg print$75 1
 rswap 0
 rdouble 0
 pushg 2 print$75
 pushg 3 print$75
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:- 
 -- rec:  "y" E:  "y" 
 -- INV:gen:E.loadArgs "y" 
 -- INV:gen:after:E.loadArgs "y" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "y" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:- 
 -- OI:invoke:before:ATdx.invoke: var y 
 -- DI:invoke: "y: var integer" 
 ovpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"y":rec:y 
 -- INV:gen:after:E.loadArgs "put(y)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(y)" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- ptn:invoke: "put" E: "put(y)" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0

 CLASS + 76 1 String 10
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushText ""
 pushThis 
 rstoreg  V 3
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "L := Length" 
 pushThis 
 -- OG:gen: "Length" 
 -- OG:before:super.gen: "Length" 
 -- INV:gen: "Length" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg +$76 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- rec:  "Length" E:  "Length" 
 -- INV:gen:E.loadArgs "Length" 
 -- INV:gen:after:E.loadArgs "Length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "Length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- assign:adr.store:A: 
 storeg +$76 4
 -- assign:adr.store:B: 
 -- OG:gen: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.leng ...}" 
 pushThis 
 -- before objTmpStack:add:  77   "doplus" 
 invoke doplus 77 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS doplus 77 1 + 76
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- OG:gen: "Indexed(L + S.length,Integer)" 
 -- OG:before:super.gen: "Indexed(L + S.length,Integer)" 
 -- INV:gen: "Indexed(L + S.length,Integer)" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Indexed(L + S.length,Integer)" E:  "Indexed(L + S.length,Integer)" 
 -- INV:gen:E.loadArgs "Indexed(L + S.length,Integer)" 
 -- OG:gen: "L + S.length" 
 -- OG:before:super.gen: "L + S.length" 
 -- INV:gen: "L + S.length" 
 -- BinaryExp:loadOrigin:empty: "L + S.length" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L + S.length" E:  "L + S.length" 
 -- INV:gen:E.loadArgs "L + S.length" 
 -- BinaryExp:loadArgs: "L + S.length" superAdj: 0 
 -- INV:gen: "L" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg doplus$77 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 pushg 4 +$76
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OG:gen: "S.length" 
 -- OG:before:super.gen: "S.length" 
 -- INV:gen: "S.length" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg doplus$77 1
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 rpushg doplus$77 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- rec:  "S" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + S.length" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + S.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L" rec: "L + S.length" 
 -- M: "+ S.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+  " E: "+ S.length" ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- INV:gen:after:E.loadArgs "Indexed(L + S.length,Integer)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Indexed(L + S.length,Integer)" 
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- ptn:invoke: "Indexed" E: "Indexed(L + S.length,Integer)" ptnKind: 0 useRtnV: false 
 pushThis 
 pushc 1
 allocIndexed doplus$77 78 1 0
 pushThis 
 rstoreg  doplus$77 4
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- OG:gen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 pushThis 
 -- before objTmpStack:add:  82   "for:to:repeat$82" 
 invoke for:to:repeat$82 82 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OG:gen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 pushThis 
 -- before objTmpStack:add:  84   "for:to:repeat$84" 
 invoke for:to:repeat$84 84 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- assign: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg doplus$77 1
 -- OG:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OG:before:super.gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- INV:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 pushThis 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 rpushg doplus$77 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- ..."} 
 -- rec:  "T" E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- INV:gen:E.loadArgs "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- INV:gen:after:E.loadArgs "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" :Adr:off:4 size:0 isFloat:F is ... 
 -- OI:invoke:before:ATdx.invoke: pattern asString 
 -- ptn:invoke: "asString" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" ptnKind: 0 useRtnV: true 
 %asString 118
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] +  ..."} 
 -- assign:adr.store:A: 
 rswap 0
 rstoreg  EisNone 3
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0

 CLASS Indexed 78 0 BETA 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1

 CLASS repeat$80 80 1 for:to:repeat$82 82
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "e := get[inx]" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$80$80 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$82$82 4
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- INV:gen: "get[inx]" 
 pushThis 
 -- items:goOrigin: 4 
 rpushg repeat$80$80 1
 -- items:goOrigin: 3 
 rpushg for:to:repeat$82$82 4
 -- items:goOrigin: 2 
 rpushg doplus$77 1
 -- items:goOrigin: 1 
 rpushg +$76 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg repeat$80$80 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$82$82
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- assign:adr.store:A: 
 storeg doplus$77 2
 -- assign:adr.store:B: 
 -- OG:gen: "T.put(e):at[inx]" 
 -- OG:before:super.gen: "T.put(e):at[inx]" 
 -- INV:gen: "T.put(e):at[inx]" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$80$80 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$82$82 4
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 rpushg repeat$80$80 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- rec:  "T" E:  "put(e):at[inx]" 
 -- INV:gen:E.loadArgs "put(e):at[inx]" 
 -- OG:gen: "e" 
 -- OG:before:super.gen: "e" 
 -- INV:gen: "e" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$80$80 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$82$82 4
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- rec:  "e" E:  "e" 
 -- INV:gen:E.loadArgs "e" 
 -- INV:gen:after:E.loadArgs "e" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer" 
 pushg 2 doplus$77
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg repeat$80$80 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$82$82
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "put(e):at[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[inx]" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e) ..." 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(e):at[inx]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$82 82 4 doplus 77
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- INV:gen: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- INV:gen: "L" 
 pushThis 
 rpushg doplus$77 4
 -- items:goOrigin: 1 
 rpushg doplus$77 1
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 pushg 4 +$76
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS repeat$83 83 1 for:to:repeat$84 84
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- assign: "e := S.get[inx]" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$83$83 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$84$84 4
 -- OG:gen: "S.get[inx]" 
 -- OG:before:super.gen: "S.get[inx]" 
 -- INV:gen: "S.get[inx]" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg repeat$83$83 1
 -- items:goOrigin: 2 
 rpushg for:to:repeat$84$84 4
 -- items:goOrigin: 1 
 rpushg doplus$77 1
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 rpushg repeat$83$83 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- rec:  "S" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg repeat$83$83 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$84$84
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- assign:adr.store:A: 
 storeg doplus$77 2
 -- assign:adr.store:B: 
 -- assign: "i := L + inx" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$83$83 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$84$84 4
 -- OG:gen: "L + inx" 
 -- OG:before:super.gen: "L + inx" 
 -- INV:gen: "L + inx" 
 -- BinaryExp:loadOrigin:empty: "L + inx" superAdj: 0 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L + inx" E:  "L + inx" 
 -- INV:gen:E.loadArgs "L + inx" 
 -- BinaryExp:loadArgs: "L + inx" superAdj: 0 
 -- INV:gen: "L" 
 pushThis 
 -- items:goOrigin: 3 
 rpushg repeat$83$83 1
 -- items:goOrigin: 2 
 rpushg for:to:repeat$84$84 4
 -- items:goOrigin: 1 
 rpushg doplus$77 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- DI:invoke: "L: var integer" 
 pushg 4 +$76
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- INV:gen: "inx" 
 pushThis 
 -- items:goOrigin: 1 
 rpushg repeat$83$83 1
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- DI:invoke: "inx: var integer" 
 pushg 3 for:to:repeat$84$84
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + inx" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + inx" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- BinaryExp:invoke: "L" rec: "L + inx" 
 -- M: "+ inx" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- ptn:invoke: "+  " E: "+ inx" ptnKind: 0 useRtnV: true 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- assign:adr.store:A: 
 storeg doplus$77 3
 -- assign:adr.store:B: 
 -- OG:gen: "T.put(e):at[i]" 
 -- OG:before:super.gen: "T.put(e):at[i]" 
 -- INV:gen: "T.put(e):at[i]" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$83$83 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$84$84 4
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 rpushg repeat$83$83 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- rec:  "T" E:  "put(e):at[i]" 
 -- INV:gen:E.loadArgs "put(e):at[i]" 
 -- OG:gen: "e" 
 -- OG:before:super.gen: "e" 
 -- INV:gen: "e" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$83$83 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$84$84 4
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- rec:  "e" E:  "e" 
 -- INV:gen:E.loadArgs "e" 
 -- INV:gen:after:E.loadArgs "e" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- DI:invoke: "e: var integer" 
 pushg 2 doplus$77
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OG:gen: "i" 
 -- OG:before:super.gen: "i" 
 -- INV:gen: "i" 
 pushThis 
 -- items:goOrigin: 2 
 rpushg repeat$83$83 1
 -- items:goOrigin: 1 
 rpushg for:to:repeat$84$84 4
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- rec:  "i" E:  "i" 
 -- INV:gen:E.loadArgs "i" 
 -- INV:gen:after:E.loadArgs "i" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- DI:invoke: "i: var integer" 
 pushg 3 doplus$77
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- INV:gen:after:E.loadArgs "put(e):at[i]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[i]" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):a ..." 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(e):at[i]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0

 CLASS for:to:repeat$84 84 4 doplus 77
 -- vdtTableCopy: I:1:28 V:2:29
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- INV:gen: "1" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- OG:gen: "S.length" 
 -- OG:before:super.gen: "S.length" 
 -- INV:gen: "S.length" 
 pushThis 
 rpushg doplus$77 4
 -- items:goOrigin: 1 
 rpushg doplus$77 1
 -- OI:invoke:before:ATdx.invoke: var S 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 rpushg doplus$77 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- rec:  "S" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 pushThis 
 storeg integer$5 2
 pushThis 
 storeg integer$5 1
 allocEventQ
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0

 CLASS asString 85 1 Indexed 78
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 pushText ""
 pushThis 
 rstoreg  S 2
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS valProx 86 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 87 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 88 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 89 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 65 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 31 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	rtnAlloc 1
doE: 
31:	doEventQ 
32:	mvStack
33:	pushthis 
34:	innerP 2
36:	rpopThisObj
37:	setThisStack
38:	pushthis 
39:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 41 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 39 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Dimensions descInx:38 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class StringLib descInx:39 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:40 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class _doIt descInx:41 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 43 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 46 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:42 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 31 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	rtnAlloc 1
doE: 
31:	doEventQ 
32:	mvStack
33:	setThisStack
34:	pushthis 
35:	rtn D


Class $43 descInx:43 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 41 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $46 descInx:46 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class <= descInx:47 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 48 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:48 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 50 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 51 0 0
71:	rpop 
72:	pushthis 
73:	invoke 52 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $50 descInx:50 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $51 descInx:51 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:52 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 53 0 0
18:	rpop 
19:	pushthis 
20:	invoke 56 0 0
26:	rpop 
27:	pushthis 
28:	invoke 59 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:53 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 54 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 55 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $54 descInx:54 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 52 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $55 descInx:55 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 52 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:56 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 57 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $57 descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 58 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $58 descInx:58 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 56 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 60 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 61 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $60 descInx:60 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 52 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $61 descInx:61 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 52 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:63 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:64 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class workspace descInx:65 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 66 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ValueImpl descInx:66 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 67 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class tryImplIV descInx:67 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 111
9:	pushc 112
11:	invokeVal 68 1 0
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	pushthis 
22:	pushc 2
24:	pushc 68
26:	invoke 70 0 0
32:	rpop 
33:	setThisStack
34:	pushthis 
35:	rtn D


Class Line descInx:68 objSize:6 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
allocE: 
7:	pushthis 
8:	pushg 1
10:	pushthis 
11:	pushg 2
13:	invokeVal 69 2 1
19:	pushValId 
20:	pushthis 
21:	pushg 1
23:	pushc 2
25:	+
26:	pushValId 
27:	pushthis 
28:	pushg 2
30:	pushc 2
32:	+
33:	invokeVal 69 4 1
doE: 
39:	rtnV
40:	rtn D


Class xPoint descInx:69 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
allocE: 
doE: 
7:	rtnV
8:	rtn D


Class print descInx:70 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	allocEventQ 0
10:	mvStack
allocE: 
11:	rtnAlloc 1
doE: 
13:	doEventQ 
14:	mvStack
15:	pushText 1
17:	invoke 71 0 0
23:	rpop 
24:	pushthis 
25:	rdouble 
26:	rpushg 1
28:	rswap 0
30:	rdouble 
31:	pushg 2
33:	pushg 3
35:	swap 
36:	pushc 2
38:	+
39:	swap 
40:	invoke 75 0 0
46:	rpop 
47:	pushc 44
49:	%prim put 2
51:	pushthis 
52:	rdouble 
53:	rpushg 1
55:	rswap 0
57:	rdouble 
58:	pushg 2
60:	pushg 3
62:	swap 
63:	pushc 4
65:	+
66:	swap 
67:	invoke 75 0 0
73:	rpop 
74:	pushc 93
76:	%prim put 2
78:	setThisStack
79:	pushthis 
80:	rtn D


Class print descInx:71 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 74 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$72 descInx:72 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:73 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$74 descInx:74 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class print descInx:75 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	allocEventQ 0
10:	mvStack
allocE: 
11:	rtnAlloc 1
doE: 
13:	doEventQ 
14:	mvStack
15:	pushthis 
16:	rdouble 
17:	rpushg 1
19:	rswap 0
21:	rdouble 
22:	pushg 2
24:	pushg 3
26:	ovpushg 1
28:	%prim put 2
30:	pushthis 
31:	rdouble 
32:	rpushg 1
34:	rswap 0
36:	rdouble 
37:	pushg 2
39:	pushg 3
41:	ovpushg 2
43:	%prim put 2
45:	setThisStack
46:	pushthis 
47:	rtn D


Class + descInx:76 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 77 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:77 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 78 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 82 0 0
48:	rpop 
49:	pushthis 
50:	invoke 84 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class Indexed descInx:78 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class repeat$80 descInx:80 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$82 descInx:82 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$83 descInx:83 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$84 descInx:84 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:85 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class valProx descInx:86 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:87 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:88 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:89 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

