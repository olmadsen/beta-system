RoadMap: obj 
   %module SegmentLib, RoadLib, Point3Dlib, CityLib
   noOfRoads: val 100
   noOfCities: val 10
   roads: obj RoadLib.RoadNetwork(100)
   cities: obj CityLib.CityLayer(noOfCities)
   O2: obj RoadLib.Road("O2","Ringgaden",noOfRoads)
   createO2:
      O2.addPoints(2.0,10.0,1.0)
      roads.add(O2)
      O2.print(false)
   M15: obj RoadLib.Road("15","Herning motorvejen",100)
   createP15:
      M15.addPoints(10,12,1.5)
      roads.add(M15)
      M15.print(false)
   createRoads:
      createO2
      newline
      createP15
      newline
      for(1):to(noOfRoads):repeat
         roadName: var String
         roadName := "HW_" + I2S(inx)
         --roadName.print
         --newline
         R: ref RoadLib.Road("","",0)
         R := RoadLib.Road(roadName,roadName,100)
         R.addPoints(-(3.0+(0.0+inx)/10),(-4.0+(0.0+inx)),1.3)
         roads.add(R)
   Aarhus: ref CityLib.City("",none)
   createAarhus:
      Aarhus := CityLib.City("Aarhus",M15.firstCoord)
      cities.add(Aarhus)
   Herning: ref CityLib.City("",none)
   createHerning:
      Herning := CityLib.City("Herning",M15.lastCoord)
      cities.add(Herning)
   createCities:
      newline
      createAarhus
      newline
      createHerning
      for(1):to(noOfCities):repeat
          cityName: var String
          loc: var Point3dLib.GCSpoint(0,0,0)
          R: ref RoadLib.Road("","",0)
          cityName := "City_" + I2s(inx)
          --cityName.print
          --newline
          R:= roads.roads.get[inx ]
          --R.print(false)
          --newline
          loc := roads.roads.get[(inx - 1)/% 2 + 1 ].coordinates.get[inx]
   findRoads:
      in cityA: ref CityLib.City
      in cityB: ref CityLib.City
      in withPrint: var Boolean
      if (withPrint) :then
         "\n**** Find a road between:\n".print
         cityA.print
         "and\n".print
         cityB.print
      if (useObj) :then
         roads.scan   
            if (cityA.intersectEQ(currentRoad)) :then
               if (cityB.intersectEQ(currentRoad)) :then
                  if (withPrint) :then
                     "*** They are connected via:\n".print
                     currentRoad.print(false)
      :else
         roads.scan   
            if (cityA.intersect(currentRoad)) :then
               if (cityB.intersect(currentRoad)) :then
                  if (withPrint) :then
                     "*** They are connected via:\n".print
                     currentRoad.print(false)
   useObj: val false
   createRoads    
   createCities
   if (useObj) :then
      "\n!!!! Using obj: Point:no:VALUE, RoadLib:using:INDEXEDREF".print
   findRoads(Aarhus,Herning,true) 
   for (1):to(0):repeat
      findRoads(Aarhus,Herning,false) 
length
