 -- QBETA 
 -- OG:markForCodeGen: 
 --  %id "BETAworld"
 --     %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --     error: 
 --        %basic 999isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %id "BETAworld"
 --     %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --     error: 
 --        %basic 999
 -- OG:Qalloc: 
 --  %id "BETAworld"
 --     %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --     error: 
 --        %basic 999qDescno:  0 
 -- OG:Qalloc:A:  "BETAworld " super:  " "  marked:  true 
 --  BETAworld: obj 
 --     %id "BETAworld"
 --     %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --     error: super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %id "BETAworld"
 --     %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --     error: 
 --        %basic 999
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "BETAworld "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 1 IS.newDescNo: 1 objSize: 0 1: 1 
 --  %id "BETAworld"
 --  %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --  error: 
 --     %basic 999
 -- Items:Qalloc:objSize: 0  newDescNo: 1 
 --  %id "BETAworld"
 --  %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --  error: 
 --     %basic 999
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: error 
 -- ModuleItem:Qalloc: 
 --  --BETA
 --  
 -- Qalloc:module: BETA 
 -- Module:alloc:off: 2 
 --  
 --  BETA: obj 
 --     %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --DK
 --  
 -- ModuleItem:Qalloc: 
 --  --LIB
 --  
 -- Qalloc:module: LIB 
 -- Module:alloc:off: 3 
 --  
 --  LIB: obj 
 --     %id "LIB"
 --     %module BETA
 --     %Include BETA
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --OOPM
 --  
 -- ModuleItem:Qalloc: 
 --  --Sequential
 --  
 -- ModuleItem:Qalloc: 
 --  --no
 --  
 -- ModuleItem:Qalloc: 
 --  --workspace
 --  
 -- Qalloc:module: workspace 
 -- Module:alloc:off: 4 
 --  
 --  workspace: obj 
 --     %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 1 
 --  %id "BETAworld"
 --  %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --  error: 
 --     %basic 999
 -- IS.newDescNo: 1 IS.objSize: 4 
 --  %id "BETAworld"
 --  %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --  error: 
 --     %basic 999
 -- OG:Qalloc:end: IS.newDescNo:  1 
 --  %id "BETAworld"
 --     %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --     error: 
 --        %basic 999
 -- ObjTmpStack:add: "BETAworld ": 
 --  %id "BETAworld"
 --     %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --     error: 
 --        %basic 999
 -- items:markForCodeGen: 
 --  %id "BETAworld"
 --  %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --  error: 
 --     %basic 999
 -- markItem: "%id "BETAworld" " Property 
 -- markItem: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo " 
 --  Property 
 -- OG:markForCodeGen: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %publicisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
 -- OG:Qalloc: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %publicqDescno:  0 
 -- OG:Qalloc:A:  "BETA " super:  " "  marked:  true 
 --  BETA: obj 
 --     %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLibsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "BETA "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 2 IS.newDescNo: 2 objSize: 0 1: 1 
 --  %ID BETA
 --  %OSDvisibility disguised
 --  %module LIB, LIB.StringLib
 --  %public
 -- Items:Qalloc:objSize: 0  newDescNo: 2 
 --  %ID BETA
 --  %OSDvisibility disguised
 --  %module LIB, LIB.StringLib
 --  %public
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Object 
 -- Pattern:Qalloc: Value 
 -- Pattern:Qalloc: universal 
 -- Pattern:Qalloc: integer 
 -- Pattern:Qalloc: Boolean 
 -- Pattern:Qalloc: False 
 -- Pattern:Qalloc:B: False 
 -- Pattern:Qalloc: True 
 -- Pattern:Qalloc:B: True 
 -- Pattern:Qalloc: char 
 -- Pattern:Qalloc: universalFloat 
 -- Pattern:Qalloc: float 
 -- Pattern:Qalloc: put 
 -- Pattern:Qalloc: _put 
 -- Pattern:Qalloc: _get 
 -- Pattern:Qalloc: _iget 
 -- Pattern:Qalloc:B: _iget 
 -- Pattern:Qalloc: _kbhit 
 -- Pattern:Qalloc:B: _kbhit 
 -- Pattern:Qalloc: none 
 -- Pattern:Qalloc: immutable 
 -- Pattern:Qalloc: unique 
 -- Pattern:Qalloc:B: unique 
 -- Pattern:Qalloc: inner 
 -- Pattern:Qalloc: this 
 -- Pattern:Qalloc: disable 
 -- Pattern:Qalloc: enable 
 -- Pattern:Qalloc: fork 
 -- Pattern:Qalloc: sleep 
 -- Pattern:Qalloc: SuperCore 
 -- Pattern:Qalloc:B: SuperCore 
 -- Pattern:Qalloc: SuperScheduler 
 -- Pattern:Qalloc:B: SuperScheduler 
 -- Pattern:Qalloc: GeneralProcess 
 -- Pattern:Qalloc:B: GeneralProcess 
 -- Pattern:Qalloc: thisCoreIdx 
 -- Pattern:Qalloc: thisCore 
 -- Pattern:Qalloc: inSub 
 -- Pattern:Qalloc: method 
 -- Pattern:Qalloc:B: method 
 -- Pattern:Qalloc: disguised 
 -- Pattern:Qalloc:B: disguised 
 -- Pattern:Qalloc: SkipInternal 
 -- Pattern:Qalloc:B: SkipInternal 
 -- Pattern:Qalloc: Show 
 -- Pattern:Qalloc:B: Show 
 -- Pattern:Qalloc: Array 
 -- Pattern:Qalloc: Indexed 
 -- Pattern:Qalloc: IndexedRef 
 -- Pattern:Qalloc: restart 
 -- Pattern:Qalloc: leave 
 -- Pattern:Qalloc: if:then 
 -- Pattern:Qalloc: if:then:else 
 -- Pattern:Qalloc:B: if:then:else 
 -- Pattern:Qalloc: cycle 
 -- Pattern:Qalloc:B: cycle 
 -- Pattern:Qalloc: for:to:repeat 
 -- Pattern:Qalloc:B: for:to:repeat 
 -- Pattern:Qalloc: Condition 
 -- Pattern:Qalloc:B: Condition 
 -- Pattern:Qalloc: while:repeat 
 -- Pattern:Qalloc:B: while:repeat 
 -- Pattern:Qalloc: switch 
 -- Pattern:Qalloc:B: switch 
 -- Pattern:Qalloc: rswitch 
 -- Pattern:Qalloc:B: rswitch 
 -- dataitem:qalloc: "ascii "isValue: false  isPrimitive: false 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 -- OG:Qalloc: 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2qDescno:  0 
 -- OG:Qalloc:A:  "ascii " super:  " "  marked:  false 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "ascii "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 3 IS.newDescNo: 3 objSize: 0 1: 1 
 --  asciiFoo: 
 --     msg1:  -- obj
 --        _put('F')
 --        asciiBar.msg2
 -- Items:Qalloc:objSize: 0  newDescNo: 3 
 --  asciiFoo: 
 --     msg1:  -- obj
 --        _put('F')
 --        asciiBar.msg2
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: asciiFoo 
 -- Pattern:Qalloc:B: asciiFoo 
 -- Pattern:Qalloc: asciiBar 
 -- Pattern:Qalloc:B: asciiBar 
 -- dataitem:qalloc: "nl "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "cr "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "null "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- dataitem:qalloc: "newline "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 " " 
 -- Pattern:Qalloc: isLetter 
 -- Pattern:Qalloc:B: isLetter 
 -- Pattern:Qalloc: isDigit 
 -- Pattern:Qalloc:B: isDigit 
 -- Invocation:Qalloc: "newline " 
 -- ObjectInvocation:Qalloc: "newline "
 -- name: "newline "
 -- Arguments " "
 -- OG:Qalloc: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --   marked:  false 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  super:  
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- Invocation:Qalloc: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- ObjectInvocation:Qalloc: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- name: "nl "
 -- Arguments "
 --  -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:Qalloc:SuperAlloc: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsqDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "value "  marked:  false 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalssuper:  "value " 
 -- Invocation:Qalloc: "value " 
 -- ObjectInvocation:Qalloc: "value "
 -- name: "value "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:Qalloc:SuperAlloc: 
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %publicqDescno:  0 
 -- OG:Qalloc:A:  "Value " super:  " "  marked:  false 
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "Value "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 4 IS.newDescNo: 4 objSize: 0 1: 1 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- Items:Qalloc:objSize: 0  newDescNo: 4 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc: <= 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 4 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- IS.newDescNo: 4 IS.objSize: 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:Qalloc:end: IS.newDescNo:  4 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
 -- OG:super:  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 --  super:  "value " 
 --  E:  "value "
 -- OG:Qalloc:B: "integer "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 5 IS.newDescNo: 5 objSize: 0 1: 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Items:Qalloc:objSize: 0  newDescNo: 5 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Items:Qalloc:super: "value " size: 0 "integer "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "_thisBasicValue "isValue: true  isPrimitive: 
 --  true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: * 
 -- Pattern:Qalloc: / 
 -- Pattern:Qalloc: // 
 -- Pattern:Qalloc: /% 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <=? 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc: cmpAndSwap 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 5 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- IS.newDescNo: 5 IS.objSize: 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:Qalloc:end: IS.newDescNo:  5 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:super:  "nl: val 10 " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 --  super:  
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 --  E:  "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- Items:Qalloc:END:objSize: 5  newDescNo: 3 
 --  asciiFoo: 
 --     msg1:  -- obj
 --        _put('F')
 --        asciiBar.msg2
 -- IS.newDescNo: 3 IS.objSize: 5 
 --  asciiFoo: 
 --     msg1:  -- obj
 --        _put('F')
 --        asciiBar.msg2
 -- OG:Qalloc:end: IS.newDescNo:  3 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Pattern:Qalloc: newline 
 -- Pattern:Qalloc:B: newline 
 -- Pattern:Qalloc: int2chars 
 -- Pattern:Qalloc:B: int2chars 
 -- Pattern:Qalloc: putint 
 -- Pattern:Qalloc:B: putint 
 -- Pattern:Qalloc: exp 
 -- Pattern:Qalloc:B: exp 
 -- Pattern:Qalloc: sqrt 
 -- Pattern:Qalloc: cbrt 
 -- Pattern:Qalloc: log 
 -- Pattern:Qalloc: putFloat 
 -- Pattern:Qalloc: putFloatX 
 -- Pattern:Qalloc:B: putFloatX 
 -- Pattern:Qalloc: ConsoleIF 
 -- Pattern:Qalloc:B: ConsoleIF 
 -- dataitem:qalloc: "console "isValue: false  isPrimitive: false 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "console: ref ConsoleIF " 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 2 
 --  %ID BETA
 --  %OSDvisibility disguised
 --  %module LIB, LIB.StringLib
 --  %public
 -- IS.newDescNo: 2 IS.objSize: 3 
 --  %ID BETA
 --  %OSDvisibility disguised
 --  %module LIB, LIB.StringLib
 --  %public
 -- OG:Qalloc:end: IS.newDescNo:  2 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
 -- ObjTmpStack:add: "BETA ": 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
 -- items:markForCodeGen: 
 --  %ID BETA
 --  %OSDvisibility disguised
 --  %module LIB, LIB.StringLib
 --  %public
 -- markItem: "%ID BETA " Property 
 -- markItem: "%OSDvisibility disguised " Property 
 -- markItem: "%module LIB, LIB.StringLib " Property 
 -- markItem: "%public " Property 
 -- DataItem:markForCodeGen: "ascii ":descNo: 3 :OG.primNo: 0 
 -- OG:markForCodeGen: 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2
 -- OG:Qalloc: 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2qDescno:  3 
 -- ObjTmpStack:add: "ascii ": 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2
 -- items:markForCodeGen: 
 --  asciiFoo: 
 --     msg1:  -- obj
 --        _put('F')
 --        asciiBar.msg2
 -- DataItem:markForCodeGen: "nl ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "10 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "10 " "10 "true 
 -- OG:markSuper: "10 " 
 -- Invocation:markForCodeGen: "10 " 
 -- OG:markForCodeGen: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "value " "value "true 
 -- OG:markSuper: "value " 
 -- Invocation:markForCodeGen: "value " 
 -- ObjectInvocation:markForCodeGen: "value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- Pattern:markForCodeGen: 
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %publicisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
 -- OG:Qalloc: 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %publicqDescno:  4 
 -- ObjTmpStack:add: "Value ": 
 --  %ID Value
 --     %globals
 --     %basic 21
 --     %public
 -- items:markForCodeGen: 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- markItem: "%ID Value " Property 
 -- markItem: "%globals " Property 
 -- markItem: "%basic 21 " Property 
 -- markItem: "%public " Property 
 -- Pattern:markForCodeGen: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- items:markForCodeGen: " " 
 -- Pattern:markForCodeGen: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc: 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsqDescno:  5 
 -- ObjTmpStack:add: "integer ": 
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- items:markForCodeGen: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- markItem: "%ID integer " Property 
 -- markItem: "%basic 1, 32 " Property 
 -- markItem: "%globals " Property 
 -- markItem: "%public " Property 
 -- DataItem:markForCodeGen: "_thisBasicValue ":descNo: 0 
 --  :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Universal " "Universal "true 
 -- OG:markSuper: "Universal " 
 -- Invocation:markForCodeGen: "Universal " 
 -- ObjectInvocation:markForCodeGen: "Universal " ATd: 
 --  
 --  universal: Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 -- Pattern:markForCodeGen: 
 --  universal: Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  Value
 --     %ID universal
 --     %basic 1, 32
 --     %globalsisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Value " "Value "true 
 -- OG:markSuper: "Value " 
 -- Invocation:markForCodeGen: "Value " 
 -- ObjectInvocation:markForCodeGen: "Value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc: 
 --  Value
 --     %ID universal
 --     %basic 1, 32
 --     %globalsqDescno:  0 
 -- OG:Qalloc:A:  "universal " super:  "Value "  marked:  true 
 --  universal: Value
 --     %ID universal
 --     %basic 1, 32
 --     %globalssuper:  "Value " 
 -- Invocation:Qalloc: "Value " 
 -- ObjectInvocation:Qalloc: "Value "
 -- name: "Value "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:super:  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 --  super:  "Value " 
 --  E:  "Value "
 -- OG:Qalloc:B: "universal "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 6 IS.newDescNo: 6 objSize: 0 1: 1 
 --  %ID universal
 --  %basic 1, 32
 --  %globals
 --  +  : 
 -- Items:Qalloc:objSize: 0  newDescNo: 6 
 --  %ID universal
 --  %basic 1, 32
 --  %globals
 --  +  : 
 -- Items:Qalloc:super: "Value " size: 0 "universal "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 6 
 --  %ID universal
 --  %basic 1, 32
 --  %globals
 --  +  : 
 -- IS.newDescNo: 6 IS.objSize: 0 
 --  %ID universal
 --  %basic 1, 32
 --  %globals
 --  +  : 
 -- OG:Qalloc:end: IS.newDescNo:  6 
 --  Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 -- ObjTmpStack:add: "universal ": 
 --  Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 -- items:markForCodeGen: 
 --  %ID universal
 --  %basic 1, 32
 --  %globals
 --  +  : 
 -- markItem: "%ID universal " Property 
 -- markItem: "%basic 1, 32 " Property 
 -- markItem: "%globals " Property 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Universal "  IS.isEmpty:  true 
 -- not ObjDesc:  "10 "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "cr ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "13 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "13 " "13 "true 
 -- OG:markSuper: "13 " 
 -- Invocation:markForCodeGen: "13 " 
 -- not ObjDesc:  "13 "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "null ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "0 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "0 " "0 "true 
 -- OG:markSuper: "0 " 
 -- Invocation:markForCodeGen: "0 " 
 -- not ObjDesc:  "0 "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "newline ":descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "char " "char "true 
 -- OG:markSuper: "char " 
 -- Invocation:markForCodeGen: "char " 
 -- ObjectInvocation:markForCodeGen: "char " ATd: 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- Pattern:markForCodeGen: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "value " "value "true 
 -- OG:markSuper: "value " 
 -- Invocation:markForCodeGen: "value " 
 -- ObjectInvocation:markForCodeGen: "value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OG:Qalloc: 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16qDescno:  0 
 -- OG:Qalloc:A:  "char " super:  "value "  marked:  true 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16super:  "value " 
 -- Invocation:Qalloc: "value " 
 -- ObjectInvocation:Qalloc: "value "
 -- name: "value "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:super:  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 --  super:  "value " 
 --  E:  "value "
 -- OG:Qalloc:B: "char "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 7 IS.newDescNo: 7 objSize: 0 1: 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Items:Qalloc:objSize: 0  newDescNo: 7 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Items:Qalloc:super: "value " size: 0 "char "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "_thisBasicValue "isValue: true  isPrimitive: 
 --  true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <=? 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 7 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- IS.newDescNo: 7 IS.objSize: 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- OG:Qalloc:end: IS.newDescNo:  7 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- ObjTmpStack:add: "char ": 
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- items:markForCodeGen: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- markItem: "%id "char" " Property 
 -- markItem: "%globals " Property 
 -- markItem: "%basic 3, 16 " Property 
 -- markItem: "%public " Property 
 -- DataItem:markForCodeGen: "_thisBasicValue ":descNo: 0 
 --  :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Universal " "Universal "true 
 -- OG:markSuper: "Universal " 
 -- Invocation:markForCodeGen: "Universal " 
 -- ObjectInvocation:markForCodeGen: "Universal " ATd: 
 --  
 --  universal: Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Universal "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "char "  IS.isEmpty:  true 
 -- markItem: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  Assign 
 -- Invocation:markForCodeGen: "newline " 
 -- ObjectInvocation:markForCodeGen: "newline " ATd: 
 --  "newline: var char " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "true 
 -- DataItem:markForCodeGen: "console ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "ConsoleIF " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "ConsoleIF " "ConsoleIF "false 
 -- OG:markForCodeGen: 
 --  put:< 
 --        ...
 --     puttext(T: var LIB.StringLib.String):< 
 --        inner(puttext)isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  put:< 
 --        ...
 --     puttext(T: var LIB.StringLib.String):< 
 --        inner(puttext)
 -- OG:Qalloc: 
 --  put:< 
 --        ...
 --     puttext(T: var LIB.StringLib.String):< 
 --        inner(puttext)qDescno:  0 
 -- OG:Qalloc:A:  "ConsoleIF " super:  " "  marked:  true 
 --  ConsoleIF: 
 --     put:< 
 --        ...
 --     puttext(T: var LIB.StringLib.String):< super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  put:< 
 --        ...
 --     puttext(T: var LIB.StringLib.String):< 
 --        inner(puttext)
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "ConsoleIF "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 8 IS.newDescNo: 8 objSize: 0 1: 1 
 --  put:< 
 --     ...
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 -- Items:Qalloc:objSize: 0  newDescNo: 8 
 --  put:< 
 --     ...
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: put 
 -- Pattern:Qalloc:B: put 
 -- Pattern:Qalloc: puttext 
 -- Pattern:Qalloc:B: puttext 
 -- Pattern:Qalloc: putint 
 -- Pattern:Qalloc:B: putint 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 8 
 --  put:< 
 --     ...
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 -- IS.newDescNo: 8 IS.objSize: 1 
 --  put:< 
 --     ...
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 -- OG:Qalloc:end: IS.newDescNo:  8 
 --  put:< 
 --        ...
 --     puttext(T: var LIB.StringLib.String):< 
 --        inner(puttext)
 -- ObjTmpStack:add: "ConsoleIF ": 
 --  put:< 
 --        ...
 --     puttext(T: var LIB.StringLib.String):< 
 --        inner(puttext)
 -- items:markForCodeGen: 
 --  put:< 
 --     ...
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 -- Pattern:markForCodeGen: 
 --  put:< 
 --     ...
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "... " isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "... " 
 -- OG:Qalloc: "... " qDescno:  0 
 -- OG:Qalloc:A:  "put " super:  " "  marked:  true 
 --  put:< 
 --     ...
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "... " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "put "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 9 IS.newDescNo: 9 objSize: 0 1: 1 "
 --  ... " 
 -- Items:Qalloc:objSize: 0  newDescNo: 9 "... " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 9 "... " 
 -- IS.newDescNo: 9 IS.objSize: 1 "... " 
 -- OG:Qalloc:end: IS.newDescNo:  9 "... " 
 -- ObjTmpStack:add: "put ": "... " 
 -- items:markForCodeGen: "... " 
 -- markItem: "... " Dots 
 -- Pattern:markForCodeGen: 
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 --  
 -- items:markForCodeGen: 
 --  %$B "("
 --  T: var LIB.StringLib.String
 --  %$E ")"
 --  
 -- markItem: "%$B "(" " Property 
 -- DataItem:markForCodeGen: "T ":descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "LIB.StringLib.String " "LIB "false "StringLib "false "String "
 --  true 
 -- OG:markForCodeGen: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Value " "Value "true 
 -- OG:markSuper: "Value " 
 -- Invocation:markForCodeGen: "Value " 
 -- ObjectInvocation:markForCodeGen: "Value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- OG:Qalloc: 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5qDescno:  0 
 -- OG:Qalloc:A:  "String " super:  "Value "  marked:  true 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5super:  "Value " 
 -- Invocation:Qalloc: "Value " 
 -- ObjectInvocation:Qalloc: "Value "
 -- name: "Value "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:super:  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 --  super:  "Value " 
 --  E:  "Value "
 -- OG:Qalloc:B: "String "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 10 IS.newDescNo: 10 objSize: 0 1: 1 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Items:Qalloc:objSize: 0  newDescNo: 10 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Items:Qalloc:super: "Value " size: 0 "String "
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- Pattern:Qalloc: length 
 -- Pattern:Qalloc:B: length 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc:B: + 
 -- Pattern:Qalloc: asLowerCase 
 -- Pattern:Qalloc:B: asLowerCase 
 -- Pattern:Qalloc: scan 
 -- Pattern:Qalloc:B: scan 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc:B: = 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc:B: <> 
 -- Pattern:Qalloc: <= 
 -- Pattern:Qalloc:B: <= 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 10 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- IS.newDescNo: 10 IS.objSize: 0 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- OG:Qalloc:end: IS.newDescNo:  10 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- ObjTmpStack:add: "String ": 
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- items:markForCodeGen: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- markItem: "%id "String pattern" " Property 
 -- markItem: "%OSDvisibility disguised " Property 
 -- markItem: "%basic 5 " Property 
 -- markItem: "%public " Property 
 -- Pattern:markForCodeGen: 
 --  =  :: 
 --     loop: do 
 --        c1: var char
 --        c2: var char
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  loop: do 
 --        c1: var char
 --        c2: var char
 --        L: var integerisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  loop: do 
 --        c1: var char
 --        c2: var char
 --        L: var integer
 -- OG:Qalloc: 
 --  loop: do 
 --        c1: var char
 --        c2: var char
 --        L: var integerqDescno:  0 
 -- OG:Qalloc:A:  "= " super:  " "  marked:  true 
 --  =  :: 
 --     loop: do 
 --        c1: var char
 --        c2: var charsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OG:Qalloc: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  qDescno:  0 
 -- OG:Qalloc:A:  "= " super:  " "  marked:  false 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleansuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "= "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 11 IS.newDescNo: 11 objSize: 0 1: 1 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 11 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "Veq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "Beq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- OG:Qalloc: "inner(= ) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(= ) "  marked:  false 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  super:  "inner(= ) " 
 -- Invocation:Qalloc: "inner(= ) " 
 -- ObjectInvocation:Qalloc: "inner(= ) "
 -- name: "inner "
 -- Arguments "inner(= ) "
 -- OG:Qalloc: "=  " qDescno:  0 
 -- OG:Qalloc:A:  "= " super:  "=  "  marked:  false "inner(= ) " 
 --  super:  "=  " 
 -- Invocation:Qalloc: "=  " 
 -- ObjectInvocation:Qalloc: "=  "
 -- name: "= "
 -- Arguments " "
 -- OG:Qalloc: " " qDescno:  0 
 -- OG:Qalloc:A:  "emptyOG " super:  " "  marked:  false " " super:  "
 --   " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- " " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:end: IS.newDescNo:  0 " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 3 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- OG:super:  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "=  " 
 --  super:  "=  " 
 --  E:  "=  "
 -- OG:Qalloc:end: IS.newDescNo:  0 "=  " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc: 
 --  %basic 101
 --     in inner: ref Object
 --  qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  " "  marked:  false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 101
 --     in inner: ref Object
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "inner "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 12 IS.newDescNo: 12 objSize: 0 1: 1 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 12 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "inner "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in inner: ref Object " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 12 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- IS.newDescNo: 12 IS.objSize: 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:Qalloc:end: IS.newDescNo:  12 
 --  %basic 101
 --     in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(= ) " 
 --  super:  "inner(= ) " 
 --  E:  "inner(= ) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(= ) " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 11 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- IS.newDescNo: 11 IS.objSize: 3 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- OG:Qalloc:end: IS.newDescNo:  11 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  loop: do 
 --        c1: var char
 --        c2: var char
 --        L: var integer
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "= "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 13 IS.newDescNo: 13 objSize: 0 1: 1 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- Items:Qalloc:objSize: 0  newDescNo: 13 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- Items:Qalloc:super: " " size: 3 "= "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 13 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- IS.newDescNo: 13 IS.objSize: 3 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- OG:Qalloc:end: IS.newDescNo:  13 
 --  loop: do 
 --        c1: var char
 --        c2: var char
 --        L: var integer
 -- ObjTmpStack:add: "=   ": 
 --  loop: do 
 --        c1: var char
 --        c2: var char
 --        L: var integer
 -- items:markForCodeGen: 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- OG:markForCodeGen: 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := lengthisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := length
 -- OG:Qalloc: 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := lengthqDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  " "  marked:  true 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integersuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := length
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "loop "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 14 IS.newDescNo: 14 objSize: 0 1: 1 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- Items:Qalloc:objSize: 0  newDescNo: 14 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "c1 "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "c2 "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "L "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- OG:Qalloc: "length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "length "  marked:  false "
 --  L := length " super:  "length " 
 -- Invocation:Qalloc: "length " 
 -- ObjectInvocation:Qalloc: "length "
 -- name: "length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc: 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  " "  marked:  false 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "length "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 15 IS.newDescNo: 15 objSize: 0 1: 1 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 15 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- OG:Qalloc: "
 --  get[0] -- actually an index error, accessing length " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "
 --  get[0] -- actually an index error, accessing length "  marked:  false "
 --  V := get[0] -- actually an index error, accessing length " super:  "get[0] -- actually an index error, accessing length " 
 -- Invocation:Qalloc: "
 --  get[0] -- actually an index error, accessing length " 
 -- ObjectInvocation:Qalloc: "
 --  get[0] -- actually an index error, accessing length "
 -- name: "get "
 -- Arguments "get[0] "
 -- OG:Qalloc: "0 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "0 "  marked:  false "get[0] " 
 --  super:  "0 " 
 -- Invocation:Qalloc: "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 " 
 --  super:  "0 " 
 --  E:  "0 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc: 
 --  %basic 117
 --     out ch: var char
 --  qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  " "  marked:  false 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 117
 --     out ch: var char
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "get "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 16 IS.newDescNo: 16 objSize: 0 1: 1 
 --  %basic 117
 --  out ch: var char
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 16 
 --  %basic 117
 --  out ch: var char
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 
 --  %$B "["
 --  inx: var integer
 --  %$E "]"
 --  
 -- dataitem:qalloc: "inx "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 
 --  %$B "["
 --  inx: var integer
 --  %$E "]"
 --  
 -- dataitem:qalloc: "ch "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 16 
 --  %basic 117
 --  out ch: var char
 --  
 -- IS.newDescNo: 16 IS.objSize: 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:Qalloc:end: IS.newDescNo:  16 
 --  %basic 117
 --     out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[0] -- actually an index error, accessing length " 
 --  super:  "get[0] -- actually an index error, accessing length " 
 --  E:  "get[0] -- actually an index error, accessing length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "
 --  get[0] -- actually an index error, accessing length " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 15 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- IS.newDescNo: 15 IS.objSize: 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:end: IS.newDescNo:  15 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length " 
 --  super:  "length " 
 --  E:  "length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "length " 
 -- OG:Qalloc: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --   marked:  false 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := lengthsuper:  
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- Invocation:Qalloc: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- OG:Qalloc: "(L <> Veq.length) " qDescno:  0 
 -- OG:Qalloc:A:  "<> " super:  "(L <> Veq.length) "  marked:  false 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  super:  "(L <> Veq.length) " 
 -- Invocation:Qalloc: "(L <> Veq.length) " 
 -- Invocation:Qalloc: "L <> Veq.length " 
 -- BinaryExp:Qalloc: "L <> Veq.length "
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "<> Veq.length "
 -- name: "<> "
 -- Arguments "Veq.length "
 -- OG:Qalloc: "Veq.length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "Veq.length "  marked:  false "
 --  Veq.length " super:  "Veq.length " 
 -- Invocation:Qalloc: "Veq.length " 
 -- ObjectInvocation:Qalloc: "Veq "
 -- name: "Veq "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "length "
 -- name: "length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.length " 
 --  super:  "Veq.length " 
 --  E:  "length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.length " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc: 
 --  %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  qDescno:  0 
 -- OG:Qalloc:A:  "<> " super:  " "  marked:  false 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "<> "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 17 IS.newDescNo: 17 objSize: 0 1: 1 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 17 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 17 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  
 -- IS.newDescNo: 17 IS.objSize: 3 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:Qalloc:end: IS.newDescNo:  17 
 --  %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:super:  
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L <> Veq.length) " 
 --  super:  "(L <> Veq.length) " 
 --  E:  "(L <> Veq.length) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L <> Veq.length) " 
 -- OG:Qalloc: "leave(loop) " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop) " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 18 IS.newDescNo: 18 objSize: 0 1: 1 "
 --  leave(loop) " 
 -- Items:Qalloc:objSize: 0  newDescNo: 18 "leave(loop) " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "leave(loop) " qDescno:  0 
 -- OG:Qalloc:A:  "leave " super:  "leave(loop) "  marked:  false "
 --  leave(loop) " super:  "leave(loop) " 
 -- Invocation:Qalloc: "leave(loop) " 
 -- ObjectInvocation:Qalloc: "leave(loop) "
 -- name: "leave "
 -- Arguments "leave(loop) "
 -- OG:Qalloc: "loop " qDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  "loop "  marked:  false "
 --  leave(loop) " super:  "loop " 
 -- Invocation:Qalloc: "loop " 
 -- ObjectInvocation:Qalloc: "loop "
 -- name: "loop "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  14 4 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- OG:super:  
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop " 
 --  super:  "loop " 
 --  E:  "loop "
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "
 --  %basic 103 " 
 -- OG:Qalloc:SuperAlloc: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OG:Qalloc: "%basic 103 " qDescno:  0 
 -- OG:Qalloc:A:  "leave " super:  " "  marked:  false 
 --  leave(V: var integer): 
 --     %basic 103
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 103 " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "leave "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 19 IS.newDescNo: 19 objSize: 0 1: 1 "
 --  %basic 103 " 
 -- Items:Qalloc:objSize: 0  newDescNo: 19 "%basic 103 " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 
 --  %$B "("
 --  V: var integer
 --  %$E ")"
 --  
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 
 --  %$B "("
 --  V: var integer
 --  %$E ")"
 --  
 -- Items:Qalloc:END:objSize: 2  newDescNo: 19 "%basic 103 " 
 -- IS.newDescNo: 19 IS.objSize: 2 "%basic 103 " 
 -- OG:Qalloc:end: IS.newDescNo:  19 "%basic 103 " 
 -- OG:super:  
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop) " 
 --  super:  "leave(loop) " 
 --  E:  "leave(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(loop) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 18 "leave(loop) " 
 -- IS.newDescNo: 18 IS.objSize: 1 "leave(loop) " 
 -- OG:Qalloc:end: IS.newDescNo:  18 "leave(loop) " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc: 
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then " super:  " "  marked:  false 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:SuperAlloc: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "if:then "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 20 IS.newDescNo: 20 objSize: 0 1: 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 20 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 
 --  %$B "("
 --  cond: var boolean
 --  %$S "):then{"
 --  thenPart:< object
 -- dataitem:qalloc: "cond "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: thenPart 
 -- Pattern:Qalloc:B: thenPart 
 -- (OG.super.desc).newDescNo = 0 
 -- OG:Qalloc: 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : qDescno:  0 
 -- OG:Qalloc:A:  "Object " super:  " "  marked:  false 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %publicsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  false  IS.superDesc.newDescNo:  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "Object "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 21 IS.newDescNo: 21 objSize: 0 1: 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- Items:Qalloc:objSize: 0  newDescNo: 21 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- OG:Qalloc: "inner(Object) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(Object) "  marked:  false 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : super:  "inner(Object) " 
 -- Invocation:Qalloc: "inner(Object) " 
 -- ObjectInvocation:Qalloc: "inner(Object) "
 -- name: "inner "
 -- Arguments "inner(Object) "
 -- OG:Qalloc: "Object " qDescno:  0 
 -- OG:Qalloc:A:  "Object " super:  "Object "  marked:  false "
 --  inner(Object) " super:  "Object " 
 -- Invocation:Qalloc: "Object " 
 -- ObjectInvocation:Qalloc: "Object "
 -- name: "Object "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:super:  
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Object " 
 --  super:  "Object " 
 --  E:  "Object "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Object " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Object) " 
 --  super:  "inner(Object) " 
 --  E:  "inner(Object) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Object) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 21 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- IS.newDescNo: 21 IS.objSize: 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:end: IS.newDescNo:  21 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 -- Pattern:qalloc:super:descNo: 21 thenPart:< object 
 -- Pattern:Qalloc: thenPart$22 
 -- Pattern:Qalloc:B: thenPart$22 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 
 --  %$B "("
 --  cond: var boolean
 --  %$S "):then{"
 --  thenPart:< object
 -- Items:Qalloc:END:objSize: 1  newDescNo: 20 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- IS.newDescNo: 20 IS.objSize: 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:Qalloc:end: IS.newDescNo:  20 
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 --  super:  
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 --  E:  "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- Invocation:Qalloc: "beq " 
 -- ObjectInvocation:Qalloc: "beq "
 -- name: "beq "
 -- Arguments " "
 -- OG:Qalloc: "true " qDescno:  0 
 -- OG:Qalloc:A:  "True " super:  "true "  marked:  false "
 --  beq := true " super:  "true " 
 -- Invocation:Qalloc: "true " 
 -- ObjectInvocation:Qalloc: "true "
 -- name: "true "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- OG:Qalloc: 
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  qDescno:  0 
 -- OG:Qalloc:A:  "True " super:  " "  marked:  false 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "True "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 23 IS.newDescNo: 23 objSize: 0 1: 1 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 23 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Invocation:Qalloc: "B " 
 -- ObjectInvocation:Qalloc: "B "
 -- name: "B "
 -- Arguments " "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false "B := 1 " 
 --  super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 23 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  
 -- IS.newDescNo: 23 IS.objSize: 1 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  
 -- OG:Qalloc:end: IS.newDescNo:  23 
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- OG:super:  
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "true " 
 --  super:  "true " 
 --  E:  "true "
 -- OG:Qalloc:end: IS.newDescNo:  0 "true " 
 -- OG:Qalloc: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0 " super:  
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then  marked:  false 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := lengthsuper:  
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- Invocation:Qalloc: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- ObjectInvocation:Qalloc: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- name: "for:to:repeat "
 -- Arguments "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- OG:Qalloc: "length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "length "  marked:  false 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then super:  "length " 
 -- Invocation:Qalloc: "length " 
 -- ObjectInvocation:Qalloc: "length "
 -- name: "length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length " 
 --  super:  "length " 
 --  E:  "length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "length " 
 -- OG:Qalloc: 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := falseqDescno:  0 
 -- OG:Qalloc:A:  "repeat$0 " super:  " "  marked:  false 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "repeat$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 24 IS.newDescNo: 24 objSize: 0 1: 1 
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 <> c2) :then 
 --     Beq := false
 -- Items:Qalloc:objSize: 0  newDescNo: 24 
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 <> c2) :then 
 --     Beq := false
 -- Items:Qalloc:super: " " size: 1 "repeat$24 "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "c1 " 
 -- ObjectInvocation:Qalloc: "c1 "
 -- name: "c1 "
 -- Arguments " "
 -- OG:Qalloc: "get[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "get[inx] "  marked:  false "
 --  c1 := get[inx] " super:  "get[inx] " 
 -- Invocation:Qalloc: "get[inx] " 
 -- ObjectInvocation:Qalloc: "get[inx] "
 -- name: "get "
 -- Arguments "get[inx] "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  get[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx] " 
 --  super:  "get[inx] " 
 --  E:  "get[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx] " 
 -- Invocation:Qalloc: "c2 " 
 -- ObjectInvocation:Qalloc: "c2 "
 -- name: "c2 "
 -- Arguments " "
 -- OG:Qalloc: "Veq.get[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "Veq.get[inx] "  marked:  false "
 --  c2 := Veq.get[inx] " super:  "Veq.get[inx] " 
 -- Invocation:Qalloc: "Veq.get[inx] " 
 -- ObjectInvocation:Qalloc: "Veq "
 -- name: "Veq "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "get[inx] "
 -- name: "get "
 -- Arguments "get[inx] "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  get[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.get[inx] " 
 --  super:  "Veq.get[inx] " 
 --  E:  "get[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.get[inx] " 
 -- OG:Qalloc: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --   marked:  false 
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 <> c2) :then 
 --     Beq := falsesuper:  
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- Invocation:Qalloc: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- OG:Qalloc: "(c1 <> c2) " qDescno:  0 
 -- OG:Qalloc:A:  "<> " super:  "(c1 <> c2) "  marked:  false 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  super:  "(c1 <> c2) " 
 -- Invocation:Qalloc: "(c1 <> c2) " 
 -- Invocation:Qalloc: "c1 <> c2 " 
 -- BinaryExp:Qalloc: "c1 <> c2 "
 -- Invocation:Qalloc: "c1 " 
 -- ObjectInvocation:Qalloc: "c1 "
 -- name: "c1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "<> c2 "
 -- name: "<> "
 -- Arguments "c2 "
 -- OG:Qalloc: "c2 " qDescno:  0 
 -- OG:Qalloc:A:  "char " super:  "c2 "  marked:  false "c2 " 
 --  super:  "c2 " 
 -- Invocation:Qalloc: "c2 " 
 -- ObjectInvocation:Qalloc: "c2 "
 -- name: "c2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- OG:super:  "c2: var char " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2 " 
 --  super:  "c2 " 
 --  E:  "c2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- OG:Qalloc: 
 --  %basic 55
 --     in V: var char
 --     out B: var boolean
 --  qDescno:  0 
 -- OG:Qalloc:A:  "<> " super:  " "  marked:  false 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "<> "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 25 IS.newDescNo: 25 objSize: 0 1: 1 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 25 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 25 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  
 -- IS.newDescNo: 25 IS.objSize: 3 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  
 -- OG:Qalloc:end: IS.newDescNo:  25 
 --  %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- OG:super:  
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 <> c2) " 
 --  super:  "(c1 <> c2) " 
 --  E:  "(c1 <> c2) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 <> c2) " 
 -- OG:Qalloc: 
 --  Beq := false
 --     leave(loop)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Beq := false
 --     leave(loop)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 26 IS.newDescNo: 26 objSize: 0 1: 1 
 --  Beq := false
 --  leave(loop)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 26 
 --  Beq := false
 --  leave(loop)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq " 
 -- ObjectInvocation:Qalloc: "Beq "
 -- name: "Beq "
 -- Arguments " "
 -- OG:Qalloc: "false " qDescno:  0 
 -- OG:Qalloc:A:  "False " super:  "false "  marked:  false "
 --  Beq := false " super:  "false " 
 -- Invocation:Qalloc: "false " 
 -- ObjectInvocation:Qalloc: "false "
 -- name: "false "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OG:Qalloc: 
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  qDescno:  0 
 -- OG:Qalloc:A:  "False " super:  " "  marked:  false 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "False "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 27 IS.newDescNo: 27 objSize: 0 1: 1 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 27 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Invocation:Qalloc: "B " 
 -- ObjectInvocation:Qalloc: "B "
 -- name: "B "
 -- Arguments " "
 -- OG:Qalloc: "0 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "0 "  marked:  false "B := 0 " 
 --  super:  "0 " 
 -- Invocation:Qalloc: "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 " 
 --  super:  "0 " 
 --  E:  "0 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 27 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 -- IS.newDescNo: 27 IS.objSize: 1 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 -- OG:Qalloc:end: IS.newDescNo:  27 
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OG:super:  
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "false " 
 --  super:  "false " 
 --  E:  "false "
 -- OG:Qalloc:end: IS.newDescNo:  0 "false " 
 -- OG:Qalloc: "leave(loop) " qDescno:  0 
 -- OG:Qalloc:A:  "leave " super:  "leave(loop) "  marked:  false 
 --  Beq := false
 --  leave(loop)
 --  super:  "leave(loop) " 
 -- Invocation:Qalloc: "leave(loop) " 
 -- ObjectInvocation:Qalloc: "leave(loop) "
 -- name: "leave "
 -- Arguments "leave(loop) "
 -- OG:Qalloc: "loop " qDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  "loop "  marked:  false "
 --  leave(loop) " super:  "loop " 
 -- Invocation:Qalloc: "loop " 
 -- ObjectInvocation:Qalloc: "loop "
 -- name: "loop "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  14 4 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- OG:super:  
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop " 
 --  super:  "loop " 
 --  E:  "loop "
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 "
 --  %basic 103 " 
 -- OG:super:  
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop) " 
 --  super:  "leave(loop) " 
 --  E:  "leave(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(loop) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 26 
 --  Beq := false
 --  leave(loop)
 --  
 -- IS.newDescNo: 26 IS.objSize: 1 
 --  Beq := false
 --  leave(loop)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  26 
 --  Beq := false
 --     leave(loop)
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 --  super:  
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 --  E:  "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- Items:Qalloc:END:objSize: 1  newDescNo: 24 
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 <> c2) :then 
 --     Beq := false
 -- IS.newDescNo: 24 IS.objSize: 1 
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 <> c2) :then 
 --     Beq := false
 -- OG:Qalloc:end: IS.newDescNo:  24 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- OG:Qalloc:SuperAlloc: 
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OG:Qalloc: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := firstqDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat " super:  " "  marked:  false 
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integersuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "for:to:repeat "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 28 IS.newDescNo: 28 objSize: 0 1: 1 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- Items:Qalloc:objSize: 0  newDescNo: 28 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 
 --  %$B "("
 --  first: var integer
 --  %$S "):to("
 --  last: var integer
 -- dataitem:qalloc: "first "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "last "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Pattern:Qalloc: repeat 
 -- Pattern:Qalloc:B: repeat 
 -- Pattern:Qalloc: repeat$29 
 -- Pattern:Qalloc:B: repeat$29 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 
 --  %$B "("
 --  first: var integer
 --  %$S "):to("
 --  last: var integer
 -- dataitem:qalloc: "inx "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- OG:Qalloc: "first " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "first "  marked:  false "
 --  inx := first " super:  "first " 
 -- Invocation:Qalloc: "first " 
 -- ObjectInvocation:Qalloc: "first "
 -- name: "first "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "first: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "first " 
 --  super:  "first " 
 --  E:  "first "
 -- OG:Qalloc:end: IS.newDescNo:  0 "first " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 28 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- IS.newDescNo: 28 IS.objSize: 3 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- OG:Qalloc:end: IS.newDescNo:  28 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
 -- OG:super:  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --  super:  
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --  E:  "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- OG:Qalloc:B: "for:to:repeat$0 "newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 30 IS.newDescNo: 30 objSize: 3 1: 1 "
 --   " 
 -- Items:Qalloc:objSize: 0  newDescNo: 30 " " 
 -- Items:Qalloc:super: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then size: 3 "for:to:repeat$30 "
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 30 " " 
 -- IS.newDescNo: 30 IS.objSize: 3 " " 
 -- OG:Qalloc:end: IS.newDescNo:  30 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 14 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- IS.newDescNo: 14 IS.objSize: 4 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- OG:Qalloc:end: IS.newDescNo:  14 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := length
 -- ObjTmpStack:add: "loop ": 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := length
 -- items:markForCodeGen: 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- DataItem:markForCodeGen: "c1 ":descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "char " "char "true 
 -- OG:markSuper: "char " 
 -- Invocation:markForCodeGen: "char " 
 -- ObjectInvocation:markForCodeGen: "char " ATd: 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "char "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c2 ":descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "char " "char "true 
 -- OG:markSuper: "char " 
 -- Invocation:markForCodeGen: "char " 
 -- ObjectInvocation:markForCodeGen: "char " ATd: 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "char "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- Pattern:markForCodeGen: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "L := length " Assign 
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "length " "length "false 
 -- OG:markSuper: "length " 
 -- Invocation:markForCodeGen: "length " 
 -- ObjectInvocation:markForCodeGen: "length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- Pattern:markForCodeGen: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc: 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  qDescno:  15 
 -- ObjTmpStack:add: "length ": 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- items:markForCodeGen: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- DataItem:markForCodeGen: "V ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "
 --  V := get[0] -- actually an index error, accessing length " Assign 
 -- Invocation:markForCodeGen: "V " 
 -- ObjectInvocation:markForCodeGen: "V " ATd: 
 --  "out V: var integer " 
 -- OI:args:markForCodgen: " "
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "length "  IS.isEmpty:  true 
 -- markItem: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  "if (L <> Veq.length) :then 
 --     leave(loop) "true 
 -- OG:markSuper: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- Invocation:markForCodeGen: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- OG:markForCodeGen: "(L <> Veq.length) " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(L <> Veq.length) " "(L <> Veq.length) "true 
 -- OG:markSuper: "(L <> Veq.length) " 
 -- Invocation:markForCodeGen: "(L <> Veq.length) " 
 -- Invocation:markForCodeGen: "L <> Veq.length " 
 -- BinaryExp:markForCodeGen: "L <> Veq.length "
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "<> Veq.length " ATd: 
 --  
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- Pattern:markForCodeGen: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "Veq.length "
 -- OG:markForCodeGen: "Veq.length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Veq.length " "Veq "true "length "false 
 -- OG:markSuper: "Veq.length " 
 -- Invocation:markForCodeGen: "Veq.length " 
 -- ObjectInvocation:markForCodeGen: "Veq " ATd: 
 --  "in Veq: var this(Value) " 
 -- DataItem:markForCodeGen: "Veq ":descNo: 0 :OG.primNo: 18 
 -- OG:markForCodeGen: "this(Value) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "this(Value) " "this(Value) "true 
 -- OG:markSuper: "this(Value) " 
 -- Invocation:markForCodeGen: "this(Value) " 
 -- ObjectInvocation:markForCodeGen: "this(Value) " ATd: 
 --  
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- Pattern:markForCodeGen: 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %basic 18
 --     in this: ref Object
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %basic 18
 --     in this: ref Object
 --  
 -- OG:Qalloc: 
 --  %basic 18
 --     in this: ref Object
 --  qDescno:  0 
 -- OG:Qalloc:A:  "this " super:  " "  marked:  true 
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 18
 --     in this: ref Object
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "this "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 31 IS.newDescNo: 31 objSize: 0 1: 1 
 --  %basic 18
 --  in this: ref Object
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 31 
 --  %basic 18
 --  in this: ref Object
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "this "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in this: ref Object " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 31 
 --  %basic 18
 --  in this: ref Object
 --  
 -- IS.newDescNo: 31 IS.objSize: 2 
 --  %basic 18
 --  in this: ref Object
 --  
 -- OG:Qalloc:end: IS.newDescNo:  31 
 --  %basic 18
 --     in this: ref Object
 --  
 -- ObjTmpStack:add: "this ": 
 --  %basic 18
 --     in this: ref Object
 --  
 -- items:markForCodeGen: 
 --  %basic 18
 --  in this: ref Object
 --  
 -- markItem: "%basic 18 " Property 
 -- DataItem:markForCodeGen: "this ":descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Object " "Object "true 
 -- OG:markForCodeGen: 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 -- OG:Qalloc: 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : qDescno:  21 
 -- ObjTmpStack:add: "Object ": 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 -- items:markForCodeGen: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- markItem: "%ID Object " Property 
 -- markItem: "%basic 64 " Property 
 -- markItem: "%public " Property 
 -- Pattern:markForCodeGen: 
 --  X_asString:<  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "-- does not wokr, problem with virtual in Object " " "false 
 -- OG:markIS: 
 --  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  
 -- OG:Qalloc: 
 --  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "X_asString " super:  "
 --  -- does not wokr, problem with virtual in Object "  marked:  true 
 --  X_asString:<  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  super:  "-- does not wokr, problem with virtual in Object " 
 -- Invocation:Qalloc: "
 --  -- does not wokr, problem with virtual in Object " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  
 --  super:  "-- does not wokr, problem with virtual in Object " 
 --  E:  " "
 -- OG:Qalloc:B: "X_asString "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 32 IS.newDescNo: 32 objSize: 0 1: 1 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 32 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "S "isValue: true  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out S: var LIB.StringLib.String " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- OG:Qalloc: "inner(X_asString) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(X_asString) "  marked:  
 --  false 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  super:  "inner(X_asString) " 
 -- Invocation:Qalloc: "inner(X_asString) " 
 -- ObjectInvocation:Qalloc: "inner(X_asString) "
 -- name: "inner "
 -- Arguments "inner(X_asString) "
 -- OG:Qalloc: "X_asString " qDescno:  0 
 -- OG:Qalloc:A:  "X_asString " super:  "X_asString "  marked:  
 --  false "inner(X_asString) " super:  "X_asString " 
 -- Invocation:Qalloc: "X_asString " 
 -- ObjectInvocation:Qalloc: "X_asString "
 -- name: "X_asString "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  32 2 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  
 -- OG:super:  
 --  X_asString:<  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "X_asString " 
 --  super:  "X_asString " 
 --  E:  "X_asString "
 -- OG:Qalloc:end: IS.newDescNo:  0 "X_asString " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(X_asString) " 
 --  super:  "inner(X_asString) " 
 --  E:  "inner(X_asString) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(X_asString) " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 32 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  
 -- IS.newDescNo: 32 IS.objSize: 2 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  32 
 --  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  
 -- ObjTmpStack:add: "X_asString ": 
 --  -- does not wokr, problem with virtual in Object
 --     out S: var LIB.StringLib.String
 --     inner(X_asString)
 --  
 -- items:markForCodeGen: 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  
 -- DataItem:markForCodeGen: "S ":descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "LIB.StringLib.String " "LIB "false "StringLib "false "String "
 --  true 
 -- OG:markSuper: "LIB.StringLib.String " 
 -- Invocation:markForCodeGen: "LIB.StringLib.String " 
 -- ObjectInvocation:markForCodeGen: "LIB " ATd: 
 --  
 --  --LIB
 --  
 -- OG:markForCodeGen: 
 --  %id "LIB"
 --     %module BETA
 --     %Include BETA
 --     x_dummy_LIB: var integerisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %id "LIB"
 --     %module BETA
 --     %Include BETA
 --     x_dummy_LIB: var integer
 -- OG:Qalloc: 
 --  %id "LIB"
 --     %module BETA
 --     %Include BETA
 --     x_dummy_LIB: var integerqDescno:  0 
 -- OG:Qalloc:A:  "LIB " super:  " "  marked:  true 
 --  LIB: obj 
 --     %id "LIB"
 --     %module BETA
 --     %Include BETAsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %id "LIB"
 --     %module BETA
 --     %Include BETA
 --     x_dummy_LIB: var integer
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "LIB "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 33 IS.newDescNo: 33 objSize: 0 1: 1 
 --  %id "LIB"
 --  %module BETA
 --  %Include BETA
 --  x_dummy_LIB: var integer
 -- Items:Qalloc:objSize: 0  newDescNo: 33 
 --  %id "LIB"
 --  %module BETA
 --  %Include BETA
 --  x_dummy_LIB: var integer
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "x_dummy_LIB "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --AgentSystem
 --  
 -- ModuleItem:Qalloc: 
 --  --Associations
 --  
 -- ModuleItem:Qalloc: 
 --  --BasicIO
 --  
 -- Qalloc:module: BasicIO 
 -- Module:alloc:off: 3 
 --  
 --  BasicIO: obj 
 --     %module LIB.StringLib
 --     %Public
 --     Lock: 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --BasicSystemLib
 --  
 -- ModuleItem:Qalloc: 
 --  --COsystem
 --  
 -- ModuleItem:Qalloc: 
 --  --Collections
 --  
 -- ModuleItem:Qalloc: 
 --  --Compiler
 --  
 -- ModuleItem:Qalloc: 
 --  --Complex
 --  
 -- ModuleItem:Qalloc: 
 --  --DateTimeLib
 --  
 -- ModuleItem:Qalloc: 
 --  --Dimensions
 --  
 -- Qalloc:module: Dimensions 
 -- Module:alloc:off: 4 
 --  
 --  Dimensions: obj 
 --     %domain_boundary
 --     %public
 --     Dimension: 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --EMC2array
 --  
 -- ModuleItem:Qalloc: 
 --  --Embedded
 --  
 -- ModuleItem:Qalloc: 
 --  --FileSys
 --  
 -- ModuleItem:Qalloc: 
 --  --ForkJoinSystem
 --  
 -- ModuleItem:Qalloc: 
 --  --MetaSystem
 --  
 -- ModuleItem:Qalloc: 
 --  --MonitorSystemLib
 --  
 -- ModuleItem:Qalloc: 
 --  --NonBlockingIO
 --  
 -- ModuleItem:Qalloc: 
 --  --RandomNumberGeneratorLib
 --  
 -- ModuleItem:Qalloc: 
 --  --SimpleConcurrentProcesses
 --  
 -- ModuleItem:Qalloc: 
 --  --Socket
 --  
 -- ModuleItem:Qalloc: 
 --  --SocketSystem
 --  
 -- ModuleItem:Qalloc: 
 --  --StringLib
 --  
 -- Qalloc:module: StringLib 
 -- Module:alloc:off: 5 
 --  
 --  StringLib: obj 
 --     %id "String module"
 --     %module LIB
 --     %public
 -- Items:Qalloc:objSize: 5  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --Xarray
 --  
 -- Items:Qalloc:END:objSize: 5  newDescNo: 33 
 --  %id "LIB"
 --  %module BETA
 --  %Include BETA
 --  x_dummy_LIB: var integer
 -- IS.newDescNo: 33 IS.objSize: 5 
 --  %id "LIB"
 --  %module BETA
 --  %Include BETA
 --  x_dummy_LIB: var integer
 -- OG:Qalloc:end: IS.newDescNo:  33 
 --  %id "LIB"
 --     %module BETA
 --     %Include BETA
 --     x_dummy_LIB: var integer
 -- ObjTmpStack:add: "LIB ": 
 --  %id "LIB"
 --     %module BETA
 --     %Include BETA
 --     x_dummy_LIB: var integer
 -- items:markForCodeGen: 
 --  %id "LIB"
 --  %module BETA
 --  %Include BETA
 --  x_dummy_LIB: var integer
 -- markItem: "%id "LIB" " Property 
 -- markItem: "%module BETA " Property 
 -- markItem: "%Include BETA " Property 
 -- DataItem:markForCodeGen: "x_dummy_LIB ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integerisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integer
 -- OG:Qalloc: 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integerqDescno:  0 
 -- OG:Qalloc:A:  "BasicIO " super:  " "  marked:  true 
 --  BasicIO: obj 
 --     %module LIB.StringLib
 --     %Public
 --     Lock: super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integer
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "BasicIO "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 34 IS.newDescNo: 34 objSize: 0 1: 1 
 --  %module LIB.StringLib
 --  %Public
 --  Lock: 
 --     dummy: var integer
 -- Items:Qalloc:objSize: 0  newDescNo: 34 
 --  %module LIB.StringLib
 --  %Public
 --  Lock: 
 --     dummy: var integer
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Lock 
 -- Pattern:Qalloc:B: Lock 
 -- dataitem:qalloc: "keyboard "isValue: false  isPrimitive: false 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 -- OG:Qalloc: 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integerqDescno:  0 
 -- OG:Qalloc:A:  "keyboard " super:  " "  marked:  false 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.Stringsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integer
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "keyboard "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 35 IS.newDescNo: 35 objSize: 0 1: 1 
 --  %Public
 --  readLine: 
 --     out M: var LIB.StringLib.String
 --     inx: var integer
 -- Items:Qalloc:objSize: 0  newDescNo: 35 
 --  %Public
 --  readLine: 
 --     out M: var LIB.StringLib.String
 --     inx: var integer
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: readLine 
 -- Pattern:Qalloc:B: readLine 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 35 
 --  %Public
 --  readLine: 
 --     out M: var LIB.StringLib.String
 --     inx: var integer
 -- IS.newDescNo: 35 IS.objSize: 1 
 --  %Public
 --  readLine: 
 --     out M: var LIB.StringLib.String
 --     inx: var integer
 -- OG:Qalloc:end: IS.newDescNo:  35 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integer
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "screen "isValue: false  isPrimitive: false 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: 
 -- OG:Qalloc: 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.getqDescno:  0 
 -- OG:Qalloc:A:  "screen " super:  " "  marked:  false 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.get
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "screen "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 36 IS.newDescNo: 36 objSize: 0 1: 1 
 --  L: obj Lock
 --  %Public
 --  init: 
 --     L.get
 -- Items:Qalloc:objSize: 0  newDescNo: 36 
 --  L: obj Lock
 --  %Public
 --  init: 
 --     L.get
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "L "isValue: false  isPrimitive: false 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "L: obj Lock " 
 -- OG:Qalloc: "Lock " qDescno:  0 
 -- OG:Qalloc:A:  "Lock " super:  "Lock "  marked:  false "
 --  L: obj Lock " super:  "Lock " 
 -- Invocation:Qalloc: "Lock " 
 -- ObjectInvocation:Qalloc: "Lock "
 -- name: "Lock "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- OG:Qalloc:SuperAlloc: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- OG:Qalloc: 
 --  dummy: var integer
 --     %Public
 --     M: var integer
 --     init: qDescno:  0 
 -- OG:Qalloc:A:  "Lock " super:  " "  marked:  false 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integersuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  dummy: var integer
 --     %Public
 --     M: var integer
 --     init: 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "Lock "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 37 IS.newDescNo: 37 objSize: 0 1: 1 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- Items:Qalloc:objSize: 0  newDescNo: 37 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "dummy "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "M "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc:B: get 
 -- Pattern:Qalloc: free 
 -- Pattern:Qalloc:B: free 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 37 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- IS.newDescNo: 37 IS.objSize: 3 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- OG:Qalloc:end: IS.newDescNo:  37 
 --  dummy: var integer
 --     %Public
 --     M: var integer
 --     init: 
 -- OG:super:  
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock " 
 --  super:  "Lock " 
 --  E:  "Lock "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 36 
 --  L: obj Lock
 --  %Public
 --  init: 
 --     L.get
 -- IS.newDescNo: 36 IS.objSize: 2 
 --  L: obj Lock
 --  %Public
 --  init: 
 --     L.get
 -- OG:Qalloc:end: IS.newDescNo:  36 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.get
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 34 
 --  %module LIB.StringLib
 --  %Public
 --  Lock: 
 --     dummy: var integer
 -- IS.newDescNo: 34 IS.objSize: 3 
 --  %module LIB.StringLib
 --  %Public
 --  Lock: 
 --     dummy: var integer
 -- OG:Qalloc:end: IS.newDescNo:  34 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integer
 -- ObjTmpStack:add: "BasicIO ": 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integer
 -- items:markForCodeGen: 
 --  %module LIB.StringLib
 --  %Public
 --  Lock: 
 --     dummy: var integer
 -- markItem: "%module LIB.StringLib " Property 
 -- markItem: "%Public " Property 
 -- DataItem:markForCodeGen: "keyboard ":descNo: 35 :OG.primNo: 0 
 -- OG:markForCodeGen: 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integerisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integer
 -- OG:Qalloc: 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integerqDescno:  35 
 -- ObjTmpStack:add: "keyboard ": 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integer
 -- items:markForCodeGen: 
 --  %Public
 --  readLine: 
 --     out M: var LIB.StringLib.String
 --     inx: var integer
 -- markItem: "%Public " Property 
 -- DataItem:markForCodeGen: "screen ":descNo: 36 :OG.primNo: 0 
 -- OG:markForCodeGen: 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.getisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.get
 -- OG:Qalloc: 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.getqDescno:  36 
 -- ObjTmpStack:add: "screen ": 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.get
 -- items:markForCodeGen: 
 --  L: obj Lock
 --  %Public
 --  init: 
 --     L.get
 -- DataItem:markForCodeGen: "L ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Lock " "Lock "false 
 -- OG:markSuper: "Lock " 
 -- Invocation:markForCodeGen: "Lock " 
 -- ObjectInvocation:markForCodeGen: "Lock " ATd: 
 --  
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- Pattern:markForCodeGen: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  dummy: var integer
 --     %Public
 --     M: var integer
 --     init: isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  dummy: var integer
 --     %Public
 --     M: var integer
 --     init: 
 -- OG:Qalloc: 
 --  dummy: var integer
 --     %Public
 --     M: var integer
 --     init: qDescno:  37 
 -- ObjTmpStack:add: "Lock ": 
 --  dummy: var integer
 --     %Public
 --     M: var integer
 --     init: 
 -- items:markForCodeGen: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- DataItem:markForCodeGen: "dummy ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "%Public " Property 
 -- DataItem:markForCodeGen: "M ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Lock "  IS.isEmpty:  true 
 -- markItem: "%Public " Property 
 -- OG:markForCodeGen: 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"
 -- OG:Qalloc: 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"qDescno:  0 
 -- OG:Qalloc:A:  "Dimensions " super:  " "  marked:  true 
 --  Dimensions: obj 
 --     %domain_boundary
 --     %public
 --     Dimension: super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "Dimensions "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 38 IS.newDescNo: 38 objSize: 0 1: 1 
 --  %domain_boundary
 --  %public
 --  Dimension: 
 --     %dimension "-top-"
 -- Items:Qalloc:objSize: 0  newDescNo: 38 
 --  %domain_boundary
 --  %public
 --  Dimension: 
 --     %dimension "-top-"
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Dimension 
 -- Pattern:Qalloc:B: Dimension 
 -- ModuleItem:Qalloc: 
 --  --Acceleration
 --  
 -- ModuleItem:Qalloc: 
 --  --AmountOfSubstance
 --  
 -- ModuleItem:Qalloc: 
 --  --AngularAcceleration
 --  
 -- ModuleItem:Qalloc: 
 --  --Area
 --  
 -- Qalloc:module: Area 
 -- Module:alloc:off: 2 
 --  
 --  Area: obj Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %Public
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --Currency
 --  
 -- ModuleItem:Qalloc: 
 --  --Density
 --  
 -- ModuleItem:Qalloc: 
 --  --ElectricCurrent
 --  
 -- ModuleItem:Qalloc: 
 --  --ElectricFrequency
 --  
 -- ModuleItem:Qalloc: 
 --  --ElectricPower
 --  
 -- ModuleItem:Qalloc: 
 --  --ElectricVoltage
 --  
 -- ModuleItem:Qalloc: 
 --  --Energy
 --  
 -- ModuleItem:Qalloc: 
 --  --Force
 --  
 -- ModuleItem:Qalloc: 
 --  --Length
 --  
 -- Qalloc:module: Length 
 -- Module:alloc:off: 3 
 --  
 --  Length: obj Dimension
 --     %dimension "L"
 --     %requires Area
 --     %Public
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --LuminousIntensity
 --  
 -- ModuleItem:Qalloc: 
 --  --MagneticFluxDensity
 --  
 -- ModuleItem:Qalloc: 
 --  --Mass
 --  
 -- ModuleItem:Qalloc: 
 --  --MassFlowRate
 --  
 -- ModuleItem:Qalloc: 
 --  --MeterPowerN
 --  
 -- ModuleItem:Qalloc: 
 --  --RadioNuclide
 --  
 -- ModuleItem:Qalloc: 
 --  --Temperature
 --  
 -- ModuleItem:Qalloc: 
 --  --ThermodynamicTemperature
 --  
 -- ModuleItem:Qalloc: 
 --  --Time
 --  
 -- ModuleItem:Qalloc: 
 --  --Velocity
 --  
 -- ModuleItem:Qalloc: 
 --  --Volume
 --  
 -- Items:Qalloc:END:objSize: 3  newDescNo: 38 
 --  %domain_boundary
 --  %public
 --  Dimension: 
 --     %dimension "-top-"
 -- IS.newDescNo: 38 IS.objSize: 3 
 --  %domain_boundary
 --  %public
 --  Dimension: 
 --     %dimension "-top-"
 -- OG:Qalloc:end: IS.newDescNo:  38 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"
 -- ObjTmpStack:add: "Dimensions ": 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"
 -- items:markForCodeGen: 
 --  %domain_boundary
 --  %public
 --  Dimension: 
 --     %dimension "-top-"
 -- markItem: "%domain_boundary " Property 
 -- markItem: "%public " Property 
 -- OG:markForCodeGen: 
 --  Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %PublicisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Dimension " "Dimension "false 
 -- OG:markSuper: "Dimension " 
 -- Invocation:markForCodeGen: "Dimension " 
 -- ObjectInvocation:markForCodeGen: "Dimension " ATd: 
 --  
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- Pattern:markForCodeGen: 
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 --     Unit: ValueisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 --     Unit: Value
 -- OG:Qalloc: 
 --  %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 --     Unit: ValueqDescno:  0 
 -- OG:Qalloc:A:  "Dimension " super:  " "  marked:  true 
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unitsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 --     Unit: Value
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "Dimension "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 39 IS.newDescNo: 39 objSize: 0 1: 1 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- Items:Qalloc:objSize: 0  newDescNo: 39 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- (OG.super.desc).newDescNo = 0 
 -- OG:Qalloc: 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var FloatqDescno:  0 
 -- OG:Qalloc:A:  "Unit " super:  "Value "  marked:  false 
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Floatsuper:  "Value " 
 -- Invocation:Qalloc: "Value " 
 -- ObjectInvocation:Qalloc: "Value "
 -- name: "Value "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:super:  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 --  super:  "Value " 
 --  E:  "Value "
 -- OG:Qalloc:B: "Unit "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 40 IS.newDescNo: 40 objSize: 0 1: 1 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- Items:Qalloc:objSize: 0  newDescNo: 40 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- Items:Qalloc:super: "Value " size: 0 "Unit "
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "magnitude "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$41 
 -- Pattern:Qalloc:B: thisUnit$41 
 -- Pattern:Qalloc: argUnit 
 -- Pattern:Qalloc:B: argUnit 
 -- Pattern:Qalloc: argUnit$42 
 -- Pattern:Qalloc:B: argUnit$42 
 -- Pattern:Qalloc: resUnit 
 -- Pattern:Qalloc:B: resUnit 
 -- Pattern:Qalloc: resUnit$43 
 -- Pattern:Qalloc:B: resUnit$43 
 -- Pattern:Qalloc: +? 
 -- Pattern:Qalloc:B: +? 
 -- Pattern:Qalloc: -? 
 -- Pattern:Qalloc:B: -? 
 -- Pattern:Qalloc: *? 
 -- Pattern:Qalloc:B: *? 
 -- Pattern:Qalloc: /? 
 -- Pattern:Qalloc:B: /? 
 -- Pattern:Qalloc: ^? 
 -- Pattern:Qalloc:B: ^? 
 -- Pattern:Qalloc: *** 
 -- Pattern:Qalloc:B: *** 
 -- Pattern:Qalloc: =+ 
 -- Pattern:Qalloc:B: =+ 
 -- Pattern:Qalloc: min 
 -- Pattern:Qalloc:B: min 
 -- Pattern:Qalloc: max 
 -- Pattern:Qalloc:B: max 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 40 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- IS.newDescNo: 40 IS.objSize: 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:Qalloc:end: IS.newDescNo:  40 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- Pattern:qalloc:super:descNo: 40 PrimaryUnit:< Unit 
 -- Pattern:Qalloc: PrimaryUnit$44 
 -- Pattern:Qalloc:B: PrimaryUnit$44 
 -- Pattern:Qalloc: Unit 
 -- Pattern:Qalloc:B: Unit 
 -- Pattern:Qalloc: symbol 
 -- Pattern:Qalloc:B: symbol 
 -- Pattern:Qalloc: MultArgL 
 -- Pattern:Qalloc:B: MultArgL 
 -- Pattern:Qalloc: MultArgL$45 
 -- Pattern:Qalloc:B: MultArgL$45 
 -- Pattern:Qalloc: MultArgR 
 -- Pattern:Qalloc:B: MultArgR 
 -- Pattern:Qalloc: MultArgR$46 
 -- Pattern:Qalloc:B: MultArgR$46 
 -- Pattern:Qalloc: MultRes 
 -- Pattern:Qalloc:B: MultRes 
 -- Pattern:Qalloc: MultRes$47 
 -- Pattern:Qalloc:B: MultRes$47 
 -- Pattern:Qalloc: gMult 
 -- Pattern:Qalloc:B: gMult 
 -- OG:Qalloc: "inner(Dimension) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(Dimension) "  marked:  
 --  false 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Valuesuper:  "inner(Dimension) " 
 -- Invocation:Qalloc: "inner(Dimension) " 
 -- ObjectInvocation:Qalloc: "inner(Dimension) "
 -- name: "inner "
 -- Arguments "inner(Dimension) "
 -- OG:Qalloc: "Dimension " qDescno:  0 
 -- OG:Qalloc:A:  "Dimension " super:  "Dimension "  marked:  false "
 --  inner(Dimension) " super:  "Dimension " 
 -- Invocation:Qalloc: "Dimension " 
 -- ObjectInvocation:Qalloc: "Dimension "
 -- name: "Dimension "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- OG:super:  
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Dimension " 
 --  super:  "Dimension " 
 --  E:  "Dimension "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Dimension " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Dimension) " 
 --  super:  "inner(Dimension) " 
 --  E:  "inner(Dimension) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Dimension) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 39 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- IS.newDescNo: 39 IS.objSize: 1 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- OG:Qalloc:end: IS.newDescNo:  39 
 --  %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 --     Unit: Value
 -- ObjTmpStack:add: "Dimension ": 
 --  %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 --     Unit: Value
 -- items:markForCodeGen: 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- markItem: "%dimension "-top-" " Property 
 -- markItem: "%public " Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:< Unit " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Unit " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- Pattern:markForCodeGen: 
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var FloatisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Value " "Value "true 
 -- OG:markSuper: "Value " 
 -- Invocation:markForCodeGen: "Value " 
 -- ObjectInvocation:markForCodeGen: "Value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc: 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var FloatqDescno:  40 
 -- ObjTmpStack:add: "Unit ": 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- items:markForCodeGen: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- markItem: "%unit "U", 1 " Property 
 -- markItem: "%public " Property 
 -- DataItem:markForCodeGen: "magnitude ":descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "Float " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Float " "Float "true 
 -- OG:markSuper: "Float " 
 -- Invocation:markForCodeGen: "Float " 
 -- ObjectInvocation:markForCodeGen: "Float " ATd: 
 --  
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- Pattern:markForCodeGen: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Value " "Value "true 
 -- OG:markSuper: "Value " 
 -- Invocation:markForCodeGen: "Value " 
 -- ObjectInvocation:markForCodeGen: "Value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- OG:Qalloc: 
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatqDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "Value "  marked:  true 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Floatsuper:  "Value " 
 -- Invocation:Qalloc: "Value " 
 -- ObjectInvocation:Qalloc: "Value "
 -- name: "Value "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:super:  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 --  super:  "Value " 
 --  E:  "Value "
 -- OG:Qalloc:B: "float "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 48 IS.newDescNo: 48 objSize: 0 1: 1 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Items:Qalloc:objSize: 0  newDescNo: 48 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Items:Qalloc:super: "Value " size: 0 "float "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "_thisBasicValue "isValue: true  isPrimitive: 
 --  true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: * 
 -- Pattern:Qalloc: / 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <= 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc: ^ 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 48 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- IS.newDescNo: 48 IS.objSize: 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:Qalloc:end: IS.newDescNo:  48 
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- ObjTmpStack:add: "float ": 
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- items:markForCodeGen: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- markItem: "%globals " Property 
 -- markItem: "%basic 9 " Property 
 -- DataItem:markForCodeGen: "_thisBasicValue ":descNo: 0 
 --  :OG.primNo: 9 
 -- OG:markForCodeGen: "Float " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Float " "Float "true 
 -- OG:markSuper: "Float " 
 -- Invocation:markForCodeGen: "Float " 
 -- ObjectInvocation:markForCodeGen: "Float " ATd: 
 --  
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- Pattern:markForCodeGen: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Float "  IS.isEmpty:  true 
 -- markItem: "%public " Property 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Float "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "thisUnit:< Unit " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Unit " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- Pattern:markForCodeGen: 
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Unit "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "argUnit:< Unit " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Unit " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Unit "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "resUnit:< Unit " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Unit " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Unit "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  toPrimary:< 
 --     out base: var PrimaryUnit
 --     inner(toPrimary)
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  out base: var PrimaryUnit
 --     inner(toPrimary)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  out base: var PrimaryUnit
 --     inner(toPrimary)
 --  
 -- OG:Qalloc: 
 --  out base: var PrimaryUnit
 --     inner(toPrimary)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary " super:  " "  marked:  true 
 --  toPrimary:< 
 --     out base: var PrimaryUnit
 --     inner(toPrimary)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  out base: var PrimaryUnit
 --     inner(toPrimary)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "toPrimary "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 49 IS.newDescNo: 49 objSize: 0 1: 1 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 49 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "base "isValue: true  isPrimitive: false 
 --   isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit " qDescno:  0 
 -- OG:Qalloc:A:  "Unit " super:  "Unit "  marked:  true "
 --  PrimaryUnit:< Unit " super:  "Unit " 
 -- Invocation:Qalloc: "Unit " 
 -- ObjectInvocation:Qalloc: "Unit "
 -- name: "Unit "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:super:  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit " 
 --  super:  "Unit " 
 --  E:  "Unit "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit " 
 -- new_size:A: true   "PrimaryUnit:< Unit " 
 -- new_size:A: true   
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "PrimaryUnit:< Unit " 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- OG:Qalloc: "inner(toPrimary) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(toPrimary) "  marked:  
 --  false 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  super:  "inner(toPrimary) " 
 -- Invocation:Qalloc: "inner(toPrimary) " 
 -- ObjectInvocation:Qalloc: "inner(toPrimary) "
 -- name: "inner "
 -- Arguments "inner(toPrimary) "
 -- OG:Qalloc: "toPrimary " qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary " super:  "toPrimary "  marked:  false "
 --  inner(toPrimary) " super:  "toPrimary " 
 -- Invocation:Qalloc: "toPrimary " 
 -- ObjectInvocation:Qalloc: "toPrimary "
 -- name: "toPrimary "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 3 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- OG:super:  
 --  toPrimary:< 
 --     out base: var PrimaryUnit
 --     inner(toPrimary)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "toPrimary " 
 --  super:  "toPrimary " 
 --  E:  "toPrimary "
 -- OG:Qalloc:end: IS.newDescNo:  0 "toPrimary " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(toPrimary) " 
 --  super:  "inner(toPrimary) " 
 --  E:  "inner(toPrimary) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(toPrimary) " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 49 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- IS.newDescNo: 49 IS.objSize: 3 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  49 
 --  out base: var PrimaryUnit
 --     inner(toPrimary)
 --  
 -- ObjTmpStack:add: "toPrimary ": 
 --  out base: var PrimaryUnit
 --     inner(toPrimary)
 --  
 -- items:markForCodeGen: 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- DataItem:markForCodeGen: "base ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "PrimaryUnit " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "PrimaryUnit " "PrimaryUnit "false 
 -- OG:markSuper: "PrimaryUnit " 
 -- Invocation:markForCodeGen: "PrimaryUnit " 
 -- ObjectInvocation:markForCodeGen: "PrimaryUnit " ATd: 
 --  "PrimaryUnit:< Unit " 
 -- Pattern:markForCodeGen: "PrimaryUnit:< Unit " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "PrimaryUnit "  IS.isEmpty:  true 
 -- markItem: "inner(toPrimary) " ObjectGenerator 
 -- Pattern:markForCodeGen: 
 --  fromPrimary:< 
 --     in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  
 -- OG:Qalloc: 
 --  in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary " super:  " "  marked:  true 
 --  fromPrimary:< 
 --     in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "fromPrimary "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 50 IS.newDescNo: 50 objSize: 0 1: 1 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 50 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "base "isValue: true  isPrimitive: false 
 --   isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit " qDescno:  0 
 -- OG:Qalloc:A:  "Unit " super:  "Unit "  marked:  true "
 --  PrimaryUnit:< Unit " super:  "Unit " 
 -- Invocation:Qalloc: "Unit " 
 -- ObjectInvocation:Qalloc: "Unit "
 -- name: "Unit "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:super:  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit " 
 --  super:  "Unit " 
 --  E:  "Unit "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit " 
 -- new_size:A: true   "PrimaryUnit:< Unit " 
 -- new_size:A: true   
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "PrimaryUnit:< Unit " 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- OG:Qalloc: "inner(fromPrimary) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(fromPrimary) "  marked:  
 --  false 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  super:  "inner(fromPrimary) " 
 -- Invocation:Qalloc: "inner(fromPrimary) " 
 -- ObjectInvocation:Qalloc: "inner(fromPrimary) "
 -- name: "inner "
 -- Arguments "inner(fromPrimary) "
 -- OG:Qalloc: "fromPrimary " qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary " super:  "fromPrimary "  marked:  
 --  false "inner(fromPrimary) " super:  "fromPrimary " 
 -- Invocation:Qalloc: "fromPrimary " 
 -- ObjectInvocation:Qalloc: "fromPrimary "
 -- name: "fromPrimary "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 3 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- OG:super:  
 --  fromPrimary:< 
 --     in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fromPrimary " 
 --  super:  "fromPrimary " 
 --  E:  "fromPrimary "
 -- OG:Qalloc:end: IS.newDescNo:  0 "fromPrimary " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(fromPrimary) " 
 --  super:  "inner(fromPrimary) " 
 --  E:  "inner(fromPrimary) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(fromPrimary) " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 50 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- IS.newDescNo: 50 IS.objSize: 3 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  50 
 --  in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  
 -- ObjTmpStack:add: "fromPrimary ": 
 --  in base: var PrimaryUnit
 --     inner(fromPrimary)
 --  
 -- items:markForCodeGen: 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- DataItem:markForCodeGen: "base ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "PrimaryUnit " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "PrimaryUnit " "PrimaryUnit "false 
 -- OG:markSuper: "PrimaryUnit " 
 -- Invocation:markForCodeGen: "PrimaryUnit " 
 -- ObjectInvocation:markForCodeGen: "PrimaryUnit " ATd: 
 --  "PrimaryUnit:< Unit " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "PrimaryUnit "  IS.isEmpty:  true 
 -- markItem: "inner(fromPrimary) " ObjectGenerator 
 -- Pattern:markForCodeGen: 
 --  print:< 
 --     "Unit:".print
 --     inner(print)
 --     put(':')
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  "Unit:".print
 --     inner(print)
 --     put(':')
 --     putFloat(magnitude)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  "Unit:".print
 --     inner(print)
 --     put(':')
 --     putFloat(magnitude)
 --  
 -- OG:Qalloc: 
 --  "Unit:".print
 --     inner(print)
 --     put(':')
 --     putFloat(magnitude)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  " "  marked:  true 
 --  print:< 
 --     "Unit:".print
 --     inner(print)
 --     put(':')super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  "Unit:".print
 --     inner(print)
 --     put(':')
 --     putFloat(magnitude)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "print "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 51 IS.newDescNo: 51 objSize: 0 1: 1 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 51 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- OG:Qalloc: ""Unit:".print " qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  ""Unit:".print "  marked:  false 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  super:  ""Unit:".print " 
 -- Invocation:Qalloc: ""Unit:".print " 
 -- ObjectInvocation:Qalloc: "print "
 -- name: "print "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- OG:Qalloc:SuperAlloc: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OG:Qalloc: 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  " "  marked:  false 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "print "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 52 IS.newDescNo: 52 objSize: 0 1: 1 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Items:Qalloc:objSize: 0  newDescNo: 52 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: gogo 
 -- Pattern:Qalloc:B: gogo 
 -- OG:Qalloc: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0 " super:  
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   marked:  false 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])super:  
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- Invocation:Qalloc: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- ObjectInvocation:Qalloc: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- name: "for:to:repeat "
 -- Arguments "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- OG:Qalloc: "length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "length "  marked:  false 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  super:  "length " 
 -- Invocation:Qalloc: "length " 
 -- ObjectInvocation:Qalloc: "length "
 -- name: "length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length " 
 --  super:  "length " 
 --  E:  "length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "length " 
 -- OG:Qalloc: "put(get[inx]) " qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0 " super:  " "  marked:  false 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(get[inx]) " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "repeat$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 53 IS.newDescNo: 53 objSize: 0 1: 1 "
 --  put(get[inx]) " 
 -- Items:Qalloc:objSize: 0  newDescNo: 53 "put(get[inx]) " 
 -- Items:Qalloc:super: " " size: 1 "repeat$53 "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- OG:Qalloc: "put(get[inx]) " qDescno:  0 
 -- OG:Qalloc:A:  "put " super:  "put(get[inx]) "  marked:  false "
 --  put(get[inx]) " super:  "put(get[inx]) " 
 -- Invocation:Qalloc: "put(get[inx]) " 
 -- ObjectInvocation:Qalloc: "put(get[inx]) "
 -- name: "put "
 -- Arguments "put(get[inx]) "
 -- OG:Qalloc: "get[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "get[inx] "  marked:  false "
 --  put(get[inx]) " super:  "get[inx] " 
 -- Invocation:Qalloc: "get[inx] " 
 -- ObjectInvocation:Qalloc: "get[inx] "
 -- name: "get "
 -- Arguments "get[inx] "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  get[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx] " 
 --  super:  "get[inx] " 
 --  E:  "get[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx] " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:Qalloc: 
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  qDescno:  0 
 -- OG:Qalloc:A:  "put " super:  "-- to be eliminated "  marked:  
 --  false 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  super:  "-- to be eliminated " 
 -- Invocation:Qalloc: "-- to be eliminated " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 --  super:  "-- to be eliminated " 
 --  E:  " "
 -- OG:Qalloc:B: "put "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 54 IS.newDescNo: 54 objSize: 0 1: 1 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 54 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "ch "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 54 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- IS.newDescNo: 54 IS.objSize: 1 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- OG:Qalloc:end: IS.newDescNo:  54 
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:super:  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(get[inx]) " 
 --  super:  "put(get[inx]) " 
 --  E:  "put(get[inx]) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(get[inx]) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 53 "put(get[inx]) " 
 -- IS.newDescNo: 53 IS.objSize: 1 "put(get[inx]) " 
 -- OG:Qalloc:end: IS.newDescNo:  53 "put(get[inx]) " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- OG:super:  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 --  super:  
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 --  E:  "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- OG:Qalloc:B: "for:to:repeat$0 "newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 55 IS.newDescNo: 55 objSize: 3 1: 1 "
 --   " 
 -- Items:Qalloc:objSize: 0  newDescNo: 55 " " 
 -- Items:Qalloc:super: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  size: 3 "for:to:repeat$55 "
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 55 " " 
 -- IS.newDescNo: 55 IS.objSize: 3 " " 
 -- OG:Qalloc:end: IS.newDescNo:  55 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- Items:Qalloc:END:objSize: 1  newDescNo: 52 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- IS.newDescNo: 52 IS.objSize: 1 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- OG:Qalloc:end: IS.newDescNo:  52 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])
 -- OG:super:  
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Unit:".print " 
 --  super:  ""Unit:".print " 
 --  E:  "print "
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Unit:".print " 
 -- OG:Qalloc: "inner(print) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(print) "  marked:  false 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  super:  "inner(print) " 
 -- Invocation:Qalloc: "inner(print) " 
 -- ObjectInvocation:Qalloc: "inner(print) "
 -- name: "inner "
 -- Arguments "inner(print) "
 -- OG:Qalloc: "print " qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  "print "  marked:  false "
 --  inner(print) " super:  "print " 
 -- Invocation:Qalloc: "print " 
 -- ObjectInvocation:Qalloc: "print "
 -- name: "print "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 1 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- OG:super:  
 --  print:< 
 --     "Unit:".print
 --     inner(print)
 --     put(':')
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "print " 
 --  super:  "print " 
 --  E:  "print "
 -- OG:Qalloc:end: IS.newDescNo:  0 "print " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(print) " 
 --  super:  "inner(print) " 
 --  E:  "inner(print) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(print) " 
 -- OG:Qalloc: "put(':') " qDescno:  0 
 -- OG:Qalloc:A:  "put " super:  "put(':') "  marked:  false 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  super:  "put(':') " 
 -- Invocation:Qalloc: "put(':') " 
 -- ObjectInvocation:Qalloc: "put(':') "
 -- name: "put "
 -- Arguments "put(':') "
 -- OG:Qalloc: "':' " qDescno:  0 
 -- OG:Qalloc:A:  "char " super:  "':' "  marked:  false "put(':') " 
 --  super:  "':' " 
 -- Invocation:Qalloc: "':' " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- OG:super:  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "':' " 
 --  super:  "':' " 
 --  E:  "':' "
 -- OG:Qalloc:end: IS.newDescNo:  0 "':' " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- OG:super:  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(':') " 
 --  super:  "put(':') " 
 --  E:  "put(':') "
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(':') " 
 -- OG:Qalloc: "putFloat(magnitude) " qDescno:  0 
 -- OG:Qalloc:A:  "putFloat " super:  "putFloat(magnitude) " 
 --   marked:  false 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  super:  "putFloat(magnitude) " 
 -- Invocation:Qalloc: "putFloat(magnitude) " 
 -- ObjectInvocation:Qalloc: "putFloat(magnitude) "
 -- name: "putFloat "
 -- Arguments "putFloat(magnitude) "
 -- OG:Qalloc: "magnitude " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "magnitude "  marked:  false "
 --  putFloat(magnitude) " super:  "magnitude " 
 -- Invocation:Qalloc: "magnitude " 
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "magnitude: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude " 
 --  super:  "magnitude " 
 --  E:  "magnitude "
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 142
 --     in X: var Float
 --     out V: var integer
 --  qDescno:  0 
 -- OG:Qalloc:A:  "putFloat " super:  " "  marked:  false 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "putFloat "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 56 IS.newDescNo: 56 objSize: 0 1: 1 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 56 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "X "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 56 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- IS.newDescNo: 56 IS.objSize: 4 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- OG:Qalloc:end: IS.newDescNo:  56 
 --  %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OG:super:  
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putFloat(magnitude) " 
 --  super:  "putFloat(magnitude) " 
 --  E:  "putFloat(magnitude) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "putFloat(magnitude) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 51 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- IS.newDescNo: 51 IS.objSize: 1 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  51 
 --  "Unit:".print
 --     inner(print)
 --     put(':')
 --     putFloat(magnitude)
 --  
 -- ObjTmpStack:add: "print ": 
 --  "Unit:".print
 --     inner(print)
 --     put(':')
 --     putFloat(magnitude)
 --  
 -- items:markForCodeGen: 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- markItem: ""Unit:".print " ObjectGenerator 
 -- OG:markForCodeGen: ""Unit:".print " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  ""Unit:".print " ""Unit:" "true "print "false 
 -- OG:markSuper: ""Unit:".print " 
 -- Invocation:markForCodeGen: ""Unit:".print " 
 -- ObjectInvocation:markForCodeGen: "print " ATd: 
 --  
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- Pattern:markForCodeGen: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])
 -- OG:Qalloc: 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])qDescno:  52 
 -- ObjTmpStack:add: "print ": 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])
 -- items:markForCodeGen: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- markItem: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  isObjectDesc: true  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "for(1):to(length):repeat
 --     put(get[inx])
 --   "false 
 -- OG:markSuper: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- Invocation:markForCodeGen: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- ObjectInvocation:markForCodeGen: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " ATd: 
 --  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- Pattern:markForCodeGen: 
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- items:markForCodeGen: 
 --  %$B "("
 --  first: var integer
 --  %$S "):to("
 --  last: var integer
 -- markItem: "%$B "(" " Property 
 -- DataItem:markForCodeGen: "first ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "%$S "):to(" " Property 
 -- DataItem:markForCodeGen: "last ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "%$S "):repeat{" " Property 
 -- Pattern:markForCodeGen: "repeat:< object " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "object " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "object " "object "true 
 -- not ObjDesc:  "object "  IS.isEmpty:  true 
 -- markItem: "%$E "}" " Property 
 -- OG:markForCodeGen: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := firstisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
 -- OG:Qalloc: 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := firstqDescno:  28 
 -- ObjTmpStack:add: "
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object} ": 
 --  %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 --     inx := first
 -- items:markForCodeGen: 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- markItem: "%OSDvisibility skipInternal " Property 
 -- markItem: "%globals inSub " Property 
 -- DataItem:markForCodeGen: "inx ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "inx := first " Assign 
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "first " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "first " "first "true 
 -- OG:markForCodeGen: 
 --  if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 --        restart(_doIt)isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 --        restart(_doIt)
 -- OG:Qalloc: 
 --  if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 --        restart(_doIt)qDescno:  0 
 -- OG:Qalloc:A:  "_doIt " super:  " "  marked:  true 
 --  _doIt: do 
 --     if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 --        restart(_doIt)
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "_doIt "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 57 IS.newDescNo: 57 objSize: 0 1: 1 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- Items:Qalloc:objSize: 0  newDescNo: 57 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt) marked:  false 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)super:  
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- Invocation:Qalloc: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- OG:Qalloc: "(inx <= last) " qDescno:  0 
 -- OG:Qalloc:A:  "<= " super:  "(inx <= last) "  marked:  false 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)super:  "(inx <= last) " 
 -- Invocation:Qalloc: "(inx <= last) " 
 -- Invocation:Qalloc: "inx <= last " 
 -- BinaryExp:Qalloc: "inx <= last "
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "<= last "
 -- name: "<= "
 -- Arguments "last "
 -- OG:Qalloc: "last " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "last "  marked:  false "last " 
 --  super:  "last " 
 -- Invocation:Qalloc: "last " 
 -- ObjectInvocation:Qalloc: "last "
 -- name: "last "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "last: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "last " 
 --  super:  "last " 
 --  E:  "last "
 -- OG:Qalloc:end: IS.newDescNo:  0 "last " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OG:Qalloc: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  qDescno:  0 
 -- OG:Qalloc:A:  "<= " super:  " "  marked:  false 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "<= "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 58 IS.newDescNo: 58 objSize: 0 1: 1 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 58 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "Veq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "Beq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 58 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- IS.newDescNo: 58 IS.objSize: 3 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- OG:Qalloc:end: IS.newDescNo:  58 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OG:super:  
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(inx <= last) " 
 --  super:  "(inx <= last) " 
 --  E:  "(inx <= last) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(inx <= last) " 
 -- OG:Qalloc: 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 59 IS.newDescNo: 59 objSize: 0 1: 1 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 59 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "repeat " qDescno:  0 
 -- OG:Qalloc:A:  "Object " super:  "repeat "  marked:  false 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  super:  "repeat " 
 -- Invocation:Qalloc: "repeat " 
 -- ObjectInvocation:Qalloc: "repeat "
 -- name: "repeat "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:super:  "repeat:< object " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "repeat " 
 --  super:  "repeat " 
 --  E:  "repeat "
 -- OG:Qalloc:end: IS.newDescNo:  0 "repeat " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- OG:Qalloc: "inx + 1 " qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  "inx + 1 "  marked:  false "
 --  inx := inx + 1 " super:  "inx + 1 " 
 -- Invocation:Qalloc: "inx + 1 " 
 -- BinaryExp:Qalloc: "inx + 1 "
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "+ 1 "
 -- name: "+ "
 -- Arguments "1 "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false "1 " 
 --  super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 61
 --     in V: var integer
 --     out R: var integer
 --  qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  " "  marked:  false 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "+ "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 60 IS.newDescNo: 60 objSize: 0 1: 1 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 60 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "R "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 60 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- IS.newDescNo: 60 IS.objSize: 3 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:end: IS.newDescNo:  60 
 --  %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:super:  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx + 1 " 
 --  super:  "inx + 1 " 
 --  E:  "inx + 1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx + 1 " 
 -- OG:Qalloc: "restart(_doIt) " qDescno:  0 
 -- OG:Qalloc:A:  "restart " super:  "restart(_doIt) "  marked:  
 --  false 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  super:  "restart(_doIt) " 
 -- Invocation:Qalloc: "restart(_doIt) " 
 -- ObjectInvocation:Qalloc: "restart(_doIt) "
 -- name: "restart "
 -- Arguments "restart(_doIt) "
 -- OG:Qalloc: "_doIt " qDescno:  0 
 -- OG:Qalloc:A:  "_doIt " super:  "_doIt "  marked:  false "
 --  restart(_doIt) " super:  "_doIt " 
 -- Invocation:Qalloc: "_doIt " 
 -- ObjectInvocation:Qalloc: "_doIt "
 -- name: "_doIt "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  57 1 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- OG:super:  
 --  _doIt: do 
 --     if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "_doIt " 
 --  super:  "_doIt " 
 --  E:  "_doIt "
 -- OG:Qalloc:end: IS.newDescNo:  0 "_doIt " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "
 --  %basic 102 " 
 -- OG:Qalloc:SuperAlloc: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- OG:Qalloc: 
 --  -- odd parameter type!
 --     %basic 102
 --  qDescno:  0 
 -- OG:Qalloc:A:  "restart " super:  "-- odd parameter type! " 
 --   marked:  false 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  super:  "-- odd parameter type! " 
 -- Invocation:Qalloc: "-- odd parameter type! " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  -- odd parameter type!
 --     %basic 102
 --  
 --  super:  "-- odd parameter type! " 
 --  E:  " "
 -- OG:Qalloc:B: "restart "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 61 IS.newDescNo: 61 objSize: 0 1: 1 "
 --  %basic 102 " 
 -- Items:Qalloc:objSize: 0  newDescNo: 61 "%basic 102 " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 
 --  %$B "("
 --  V: var integer
 --  %$E ")"
 --  
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 
 --  %$B "("
 --  V: var integer
 --  %$E ")"
 --  
 -- Items:Qalloc:END:objSize: 2  newDescNo: 61 "%basic 102 " 
 -- IS.newDescNo: 61 IS.objSize: 2 "%basic 102 " 
 -- OG:Qalloc:end: IS.newDescNo:  61 
 --  -- odd parameter type!
 --     %basic 102
 --  
 -- OG:super:  
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(_doIt) " 
 --  super:  "restart(_doIt) " 
 --  E:  "restart(_doIt) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(_doIt) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 59 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  
 -- IS.newDescNo: 59 IS.objSize: 1 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  59 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 -- OG:Qalloc: "inx := inx " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx := inx " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 62 IS.newDescNo: 62 objSize: 0 1: 1 "
 --  inx := inx " 
 -- Items:Qalloc:objSize: 0  newDescNo: 62 "inx := inx " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  inx := inx " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 62 "inx := inx " 
 -- IS.newDescNo: 62 IS.objSize: 1 "inx := inx " 
 -- OG:Qalloc:end: IS.newDescNo:  62 "inx := inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  super:  
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  E:  "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- Items:Qalloc:END:objSize: 1  newDescNo: 57 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- IS.newDescNo: 57 IS.objSize: 1 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- OG:Qalloc:end: IS.newDescNo:  57 
 --  if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 --        restart(_doIt)
 -- ObjTmpStack:add: "_doIt ": 
 --  if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 --        restart(_doIt)
 -- items:markForCodeGen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- markItem: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)"
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 -- \
 --      inx := inx "true 
 -- OG:markSuper: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- Invocation:markForCodeGen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- OG:markForCodeGen: "(inx <= last) " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(inx <= last) " "(inx <= last) "true 
 -- OG:markSuper: "(inx <= last) " 
 -- Invocation:markForCodeGen: "(inx <= last) " 
 -- Invocation:markForCodeGen: "inx <= last " 
 -- BinaryExp:markForCodeGen: "inx <= last "
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "<= last " ATd: 
 --  
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OI:args:markForCodgen: "last "
 -- OG:markForCodeGen: "last " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "last " "last "true 
 -- not ObjDesc:  "(inx <= last) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 -- OG:Qalloc: 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  qDescno:  59 
 -- ObjTmpStack:add: 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 -- items:markForCodeGen: 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  
 -- markItem: "repeat " ObjectGenerator 
 -- OG:markForCodeGen: "repeat " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "repeat " "repeat "false 
 -- OG:markSuper: "repeat " 
 -- Invocation:markForCodeGen: "repeat " 
 -- ObjectInvocation:markForCodeGen: "repeat " ATd: 
 --  "repeat:< object " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "repeat "  IS.isEmpty:  true 
 -- markItem: "inx := inx + 1 " Assign 
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "inx + 1 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "inx + 1 " "inx + 1 "true 
 -- OG:markSuper: "inx + 1 " 
 -- Invocation:markForCodeGen: "inx + 1 " 
 -- BinaryExp:markForCodeGen: "inx + 1 "
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "+ 1 " ATd: 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- Pattern:markForCodeGen: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "1 "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- not ObjDesc:  "inx + 1 "  IS.isEmpty:  true 
 -- markItem: "restart(_doIt) " ObjectGenerator 
 -- OG:markForCodeGen: "inx := inx " isObjectDesc: true  hasItems: 
 --  true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "inx := inx " 
 -- OG:Qalloc: "inx := inx " qDescno:  62 
 -- ObjTmpStack:add: "inx := inx " 
 -- items:markForCodeGen: "inx := inx " 
 -- markItem: "inx := inx " Assign 
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "inx " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "inx " "inx "true 
 -- OG:markForCodeGen: 
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc: 
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  qDescno:  20 
 -- ObjTmpStack:add: "if(cond: var boolean):then{thenPart:< object} "
 --  : 
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- items:markForCodeGen: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- markItem: "%OSDvisibility skipInternal " Property 
 -- markItem: "%basic 100 " Property 
 -- markItem: "%globals inSub " Property 
 -- not ObjDesc:  
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt) IS.isEmpty:  true 
 -- OI:args:markForCodgen: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "length " "length "false 
 -- OG:markSuper: "length " 
 -- Invocation:markForCodeGen: "length " 
 -- ObjectInvocation:markForCodeGen: "length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "length "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "put(get[inx]) " isObjectDesc: true 
 --   hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "put(get[inx]) " 
 -- OG:Qalloc: "put(get[inx]) " qDescno:  53 
 -- ObjTmpStack:add: "put(get[inx]) " 
 -- items:markForCodeGen: "put(get[inx]) " 
 -- markItem: "put(get[inx]) " ObjectGenerator 
 -- OG:markForCodeGen: "put(get[inx]) " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "put(get[inx]) " "put(get[inx]) "true 
 -- OG:markSuper: "put(get[inx]) " 
 -- Invocation:markForCodeGen: "put(get[inx]) " 
 -- ObjectInvocation:markForCodeGen: "put(get[inx]) " ATd: 
 --  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- Pattern:markForCodeGen: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "-- to be eliminated " " "false 
 -- OG:markIS: 
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:Qalloc: 
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  qDescno:  54 
 -- ObjTmpStack:add: "put ": 
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- items:markForCodeGen: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- markItem: "%globals " Property 
 -- markItem: "%basic 2 " Property 
 -- DataItem:markForCodeGen: "ch ":descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "char " "char "true 
 -- OG:markSuper: "char " 
 -- Invocation:markForCodeGen: "char " 
 -- ObjectInvocation:markForCodeGen: "char " ATd: 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "char "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "put(get[inx]) "
 -- arg:   "get[inx] "
 -- not ObjDesc:  "put(get[inx]) "  IS.isEmpty:  true 
 -- arg:   "1 "
 -- arg:   "length "
 -- arg:   "put(get[inx]) "
 -- OG:markIS: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- OG:Qalloc: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  qDescno:  55 
 -- ObjTmpStack:add: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  ""Unit:".print "  IS.isEmpty:  true 
 -- markItem: "inner(print) " ObjectGenerator 
 -- markItem: "put(':') " ObjectGenerator 
 -- OG:markForCodeGen: "put(':') " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "put(':') " "put(':') "true 
 -- OG:markSuper: "put(':') " 
 -- Invocation:markForCodeGen: "put(':') " 
 -- ObjectInvocation:markForCodeGen: "put(':') " ATd: 
 --  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:args:markForCodgen: "put(':') "
 -- OG:markForCodeGen: "':' " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "':' " "':' "true 
 -- OG:markSuper: "':' " 
 -- Invocation:markForCodeGen: "':' " 
 -- not ObjDesc:  "':' "  IS.isEmpty:  true 
 -- arg:   "':' "
 -- not ObjDesc:  "put(':') "  IS.isEmpty:  true 
 -- markItem: "putFloat(magnitude) " ObjectGenerator 
 -- OG:markForCodeGen: "putFloat(magnitude) " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "putFloat(magnitude) " "putFloat(magnitude) "true 
 -- OG:markSuper: "putFloat(magnitude) " 
 -- Invocation:markForCodeGen: "putFloat(magnitude) " 
 -- ObjectInvocation:markForCodeGen: "putFloat(magnitude) " ATd: 
 --  
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- Pattern:markForCodeGen: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %basic 142
 --     in X: var Float
 --     out V: var integer
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 142
 --     in X: var Float
 --     out V: var integer
 --  qDescno:  56 
 -- ObjTmpStack:add: "putFloat ": 
 --  %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- items:markForCodeGen: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- markItem: "%basic 142 " Property 
 -- DataItem:markForCodeGen: "X ":descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "Float " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Float " "Float "true 
 -- OG:markSuper: "Float " 
 -- Invocation:markForCodeGen: "Float " 
 -- ObjectInvocation:markForCodeGen: "Float " ATd: 
 --  
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Float "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "V ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "putFloat(magnitude) "
 -- OG:markForCodeGen: "magnitude " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "magnitude " "magnitude "true 
 -- arg:   "magnitude "
 -- not ObjDesc:  "putFloat(magnitude) "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Unit "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  symbol:< 
 --     %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  
 -- OG:Qalloc: 
 --  %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "symbol " super:  " "  marked:  true 
 --  symbol:< 
 --     %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "symbol "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 63 IS.newDescNo: 63 objSize: 0 1: 1 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 63 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "T "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out T: var StringLib.String " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- OG:Qalloc: "inner(Symbol) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(Symbol) "  marked:  false 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  super:  "inner(Symbol) " 
 -- Invocation:Qalloc: "inner(Symbol) " 
 -- ObjectInvocation:Qalloc: "inner(Symbol) "
 -- name: "inner "
 -- Arguments "inner(Symbol) "
 -- OG:Qalloc: "Symbol " qDescno:  0 
 -- OG:Qalloc:A:  "symbol " super:  "Symbol "  marked:  false "
 --  inner(Symbol) " super:  "Symbol " 
 -- Invocation:Qalloc: "Symbol " 
 -- ObjectInvocation:Qalloc: "Symbol "
 -- name: "Symbol "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  63 2 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- OG:super:  
 --  symbol:< 
 --     %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Symbol " 
 --  super:  "Symbol " 
 --  E:  "Symbol "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Symbol " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Symbol) " 
 --  super:  "inner(Symbol) " 
 --  E:  "inner(Symbol) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Symbol) " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 63 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- IS.newDescNo: 63 IS.objSize: 2 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  63 
 --  %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  
 -- ObjTmpStack:add: "symbol ": 
 --  %globals
 --     out T: var StringLib.String
 --     inner(Symbol)
 --  
 -- items:markForCodeGen: 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- markItem: "%globals " Property 
 -- DataItem:markForCodeGen: "T ":descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "StringLib.String " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "StringLib.String " "StringLib "false "String "true 
 -- not ObjDesc:  "StringLib.String "  IS.isEmpty:  true 
 -- markItem: "inner(Symbol) " ObjectGenerator 
 -- Pattern:markForCodeGen: "MultArgL:< Unit " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Unit " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Unit "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "MultArgR:< Unit " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Unit " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Unit "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "MultRes:< Unit " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Unit " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Unit "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  gMult:< 
 --     in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRes
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRes
 --     U.magnitude := L.magnitude * R.magnitude
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRes
 --     U.magnitude := L.magnitude * R.magnitude
 --  
 -- OG:Qalloc: 
 --  in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRes
 --     U.magnitude := L.magnitude * R.magnitude
 --  qDescno:  0 
 -- OG:Qalloc:A:  "gMult " super:  " "  marked:  true 
 --  gMult:< 
 --     in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRessuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRes
 --     U.magnitude := L.magnitude * R.magnitude
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "gMult "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 64 IS.newDescNo: 64 objSize: 0 1: 1 
 --  in L: var MultArgL
 --  in R: var MultArgR
 --  out U: var MultRes
 --  U.magnitude := L.magnitude * R.magnitude
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 64 
 --  in L: var MultArgL
 --  in R: var MultArgR
 --  out U: var MultRes
 --  U.magnitude := L.magnitude * R.magnitude
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "L "isValue: true  isPrimitive: false 
 --   isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit " qDescno:  0 
 -- OG:Qalloc:A:  "Unit " super:  "Unit "  marked:  true "
 --  MultArgL:< Unit " super:  "Unit " 
 -- Invocation:Qalloc: "Unit " 
 -- ObjectInvocation:Qalloc: "Unit "
 -- name: "Unit "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:super:  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit " 
 --  super:  "Unit " 
 --  E:  "Unit "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit " 
 -- new_size:A: true   "MultArgL:< Unit " 
 -- new_size:A: true   
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "MultArgL:< Unit " 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "R "isValue: true  isPrimitive: false 
 --   isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit " qDescno:  0 
 -- OG:Qalloc:A:  "Unit " super:  "Unit "  marked:  true "
 --  MultArgR:< Unit " super:  "Unit " 
 -- Invocation:Qalloc: "Unit " 
 -- ObjectInvocation:Qalloc: "Unit "
 -- name: "Unit "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:super:  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit " 
 --  super:  "Unit " 
 --  E:  "Unit "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit " 
 -- new_size:A: true   "MultArgR:< Unit " 
 -- new_size:A: true   
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "MultArgR:< Unit " 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 " " 
 -- dataitem:qalloc: "U "isValue: true  isPrimitive: false 
 --   isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit " qDescno:  0 
 -- OG:Qalloc:A:  "Unit " super:  "Unit "  marked:  true "
 --  MultRes:< Unit " super:  "Unit " 
 -- Invocation:Qalloc: "Unit " 
 -- ObjectInvocation:Qalloc: "Unit "
 -- name: "Unit "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:super:  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit " 
 --  super:  "Unit " 
 --  E:  "Unit "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit " 
 -- new_size:A: true   "MultRes:< Unit " 
 -- new_size:A: true   
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "MultRes:< Unit " 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 " " 
 -- Invocation:Qalloc: "U.magnitude " 
 -- ObjectInvocation:Qalloc: "U "
 -- name: "U "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- OG:Qalloc: "L.magnitude * R.magnitude " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "L.magnitude * R.magnitude " 
 --   marked:  false "U.magnitude := L.magnitude * R.magnitude " super:  "
 --  L.magnitude * R.magnitude " 
 -- Invocation:Qalloc: "L.magnitude * R.magnitude " 
 -- BinaryExp:Qalloc: "L.magnitude * R.magnitude "
 -- Invocation:Qalloc: "L.magnitude " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* R.magnitude "
 -- name: "* "
 -- Arguments "R.magnitude "
 -- OG:Qalloc: "R.magnitude " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "R.magnitude "  marked:  false "
 --  R.magnitude " super:  "R.magnitude " 
 -- Invocation:Qalloc: "R.magnitude " 
 -- ObjectInvocation:Qalloc: "R "
 -- name: "R "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "magnitude: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.magnitude " 
 --  super:  "R.magnitude " 
 --  E:  "magnitude "
 -- OG:Qalloc:end: IS.newDescNo:  0 "R.magnitude " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:Qalloc: 
 --  %basic 112
 --     in V: var float
 --     out R: var float
 --  qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  " "  marked:  false 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 112
 --     in V: var float
 --     out R: var float
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "* "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 65 IS.newDescNo: 65 objSize: 0 1: 1 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 65 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "R "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 65 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- IS.newDescNo: 65 IS.objSize: 5 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- OG:Qalloc:end: IS.newDescNo:  65 
 --  %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.magnitude * R.magnitude " 
 --  super:  "L.magnitude * R.magnitude " 
 --  E:  "L.magnitude * R.magnitude "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.magnitude * R.magnitude " 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 64 
 --  in L: var MultArgL
 --  in R: var MultArgR
 --  out U: var MultRes
 --  U.magnitude := L.magnitude * R.magnitude
 --  
 -- IS.newDescNo: 64 IS.objSize: 7 
 --  in L: var MultArgL
 --  in R: var MultArgR
 --  out U: var MultRes
 --  U.magnitude := L.magnitude * R.magnitude
 --  
 -- OG:Qalloc:end: IS.newDescNo:  64 
 --  in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRes
 --     U.magnitude := L.magnitude * R.magnitude
 --  
 -- ObjTmpStack:add: "gMult ": 
 --  in L: var MultArgL
 --     in R: var MultArgR
 --     out U: var MultRes
 --     U.magnitude := L.magnitude * R.magnitude
 --  
 -- items:markForCodeGen: 
 --  in L: var MultArgL
 --  in R: var MultArgR
 --  out U: var MultRes
 --  U.magnitude := L.magnitude * R.magnitude
 --  
 -- DataItem:markForCodeGen: "L ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MultArgL " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "MultArgL " "MultArgL "false 
 -- OG:markSuper: "MultArgL " 
 -- Invocation:markForCodeGen: "MultArgL " 
 -- ObjectInvocation:markForCodeGen: "MultArgL " ATd: 
 --  "MultArgL:< Unit " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "MultArgL "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MultArgR " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "MultArgR " "MultArgR "false 
 -- OG:markSuper: "MultArgR " 
 -- Invocation:markForCodeGen: "MultArgR " 
 -- ObjectInvocation:markForCodeGen: "MultArgR " ATd: 
 --  "MultArgR:< Unit " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "MultArgR "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "U ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MultRes " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "MultRes " "MultRes "false 
 -- OG:markSuper: "MultRes " 
 -- Invocation:markForCodeGen: "MultRes " 
 -- ObjectInvocation:markForCodeGen: "MultRes " ATd: 
 --  "MultRes:< Unit " 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "MultRes "  IS.isEmpty:  true 
 -- markItem: "U.magnitude := L.magnitude * R.magnitude " Assign 
 -- Invocation:markForCodeGen: "U.magnitude " 
 -- ObjectInvocation:markForCodeGen: "U " ATd: 
 --  "out U: var MultRes " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "magnitude " ATd: 
 --  "magnitude: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L.magnitude * R.magnitude " isObjectDesc: 
 --  false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L.magnitude * R.magnitude " "L.magnitude * R.magnitude "true 
 -- OG:markSuper: "L.magnitude * R.magnitude " 
 -- Invocation:markForCodeGen: "L.magnitude * R.magnitude " 
 -- BinaryExp:markForCodeGen: "L.magnitude * R.magnitude "
 -- Invocation:markForCodeGen: "L.magnitude " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "in L: var MultArgL " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "magnitude " ATd: 
 --  "magnitude: var Float " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* R.magnitude " ATd: 
 --  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- Pattern:markForCodeGen: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "R.magnitude "
 -- OG:markForCodeGen: "R.magnitude " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "R.magnitude " "R "false "magnitude "true 
 -- not ObjDesc:  "L.magnitude * R.magnitude "  IS.isEmpty:  true 
 -- markItem: "inner(Dimension) " ObjectGenerator 
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %Public
 -- OG:Qalloc: 
 --  Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %PublicqDescno:  0 
 -- OG:Qalloc:A:  "Area " super:  "Dimension "  marked:  true 
 --  Area: obj Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %Publicsuper:  "Dimension " 
 -- Invocation:Qalloc: "Dimension " 
 -- ObjectInvocation:Qalloc: "Dimension "
 -- name: "Dimension "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- OG:super:  
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %Public
 --  super:  "Dimension " 
 --  E:  "Dimension "
 -- OG:Qalloc:B: "Area "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 66 IS.newDescNo: 66 objSize: 0 1: 1 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- Items:Qalloc:objSize: 0  newDescNo: 66 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- Items:Qalloc:super: "Dimension " size: 1 "Area "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- Pattern:Qalloc: PrimaryUnit$67 
 -- Pattern:Qalloc:B: PrimaryUnit$67 
 -- Pattern:Qalloc: SquareMeter 
 -- Pattern:Qalloc:B: SquareMeter 
 -- Pattern:Qalloc: SquareCentimeter 
 -- Pattern:Qalloc:B: SquareCentimeter 
 -- Pattern:Qalloc: mult 
 -- Pattern:Qalloc:B: mult 
 -- Pattern:Qalloc: symbol 
 -- Pattern:Qalloc:B: symbol 
 -- Pattern:Qalloc: test 
 -- Pattern:Qalloc:B: test 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 66 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- IS.newDescNo: 66 IS.objSize: 1 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- OG:Qalloc:end: IS.newDescNo:  66 
 --  Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %Public
 -- ObjTmpStack:add: "Area ": 
 --  Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %Public
 -- items:markForCodeGen: 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- markItem: "%dimension "A", "L*L" " Property 
 -- markItem: "%requires Length " Property 
 -- markItem: "%Public " Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:: SquareMeter " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "SquareMeter " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "SquareMeter " "SquareMeter "false 
 -- OG:markSuper: "SquareMeter " 
 -- Invocation:markForCodeGen: "SquareMeter " 
 -- ObjectInvocation:markForCodeGen: "SquareMeter " ATd: 
 --  
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- Pattern:markForCodeGen: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- OG:Qalloc: 
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterqDescno:  0 
 -- OG:Qalloc:A:  "SquareMeter " super:  "Unit "  marked:  true 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMetersuper:  "Unit " 
 -- Invocation:Qalloc: "Unit " 
 -- ObjectInvocation:Qalloc: "Unit "
 -- name: "Unit "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:super:  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 --  super:  "Unit " 
 --  E:  "Unit "
 -- OG:Qalloc:B: "SquareMeter "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 68 IS.newDescNo: 68 objSize: 0 1: 1 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Items:Qalloc:objSize: 0  newDescNo: 68 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Items:Qalloc:super: "Unit " size: 2 "SquareMeter "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$69 
 -- Pattern:Qalloc:B: thisUnit$69 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 68 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- IS.newDescNo: 68 IS.objSize: 2 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- OG:Qalloc:end: IS.newDescNo:  68 
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- ObjTmpStack:add: "SquareMeter ": 
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- items:markForCodeGen: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- markItem: "%unit "m2", 1 " Property 
 -- markItem: "%Public " Property 
 -- Pattern:markForCodeGen: "thisUnit:: SquareMeter " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "SquareMeter " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "SquareMeter " "SquareMeter "false 
 -- OG:markSuper: "SquareMeter " 
 -- Invocation:markForCodeGen: "SquareMeter " 
 -- ObjectInvocation:markForCodeGen: "SquareMeter " ATd: 
 --  
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- Pattern:markForCodeGen: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "SquareMeter "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: ""SquareMeter".print " isObjectDesc: true 
 --   hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: ""SquareMeter".print " 
 -- OG:Qalloc: ""SquareMeter".print " qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  " "  marked:  true 
 --  print:: 
 --     "SquareMeter".print
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 1 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""SquareMeter".print " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "print "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 70 IS.newDescNo: 70 objSize: 0 1: 1 "
 --  "SquareMeter".print " 
 -- Items:Qalloc:objSize: 0  newDescNo: 70 ""SquareMeter".print " 
 -- Items:Qalloc:super: " " size: 1 "print "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- OG:Qalloc: ""SquareMeter".print " qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  ""SquareMeter".print "  marked:  
 --  false ""SquareMeter".print " super:  ""SquareMeter".print " 
 -- Invocation:Qalloc: ""SquareMeter".print " 
 -- ObjectInvocation:Qalloc: "print "
 -- name: "print "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- OG:super:  
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""SquareMeter".print " 
 --  super:  ""SquareMeter".print " 
 --  E:  "print "
 -- OG:Qalloc:end: IS.newDescNo:  0 ""SquareMeter".print " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 70 "
 --  "SquareMeter".print " 
 -- IS.newDescNo: 70 IS.objSize: 1 ""SquareMeter".print " 
 -- OG:Qalloc:end: IS.newDescNo:  70 ""SquareMeter".print " 
 -- ObjTmpStack:add: "print ": ""SquareMeter".print " 
 -- items:markForCodeGen: ""SquareMeter".print " 
 -- markItem: ""SquareMeter".print " ObjectGenerator 
 -- OG:markForCodeGen: ""SquareMeter".print " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  ""SquareMeter".print " ""SquareMeter" "true "print "false 
 -- OG:markSuper: ""SquareMeter".print " 
 -- Invocation:markForCodeGen: ""SquareMeter".print " 
 -- ObjectInvocation:markForCodeGen: "print " ATd: 
 --  
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  ""SquareMeter".print "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "SquareMeter "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  symbol:: 
 --     T := "A"
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "T := "A" " isObjectDesc: true  hasItems: 
 --  true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "T := "A" " 
 -- OG:Qalloc: "T := "A" " qDescno:  0 
 -- OG:Qalloc:A:  "symbol " super:  " "  marked:  true 
 --  symbol:: 
 --     T := "A"
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  63 2 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T := "A" " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "symbol "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 71 IS.newDescNo: 71 objSize: 0 1: 1 "
 --  T := "A" " 
 -- Items:Qalloc:objSize: 0  newDescNo: 71 "T := "A" " 
 -- Items:Qalloc:super: " " size: 2 "symbol "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 1 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Invocation:Qalloc: "T " 
 -- ObjectInvocation:Qalloc: "T "
 -- name: "T "
 -- Arguments " "
 -- OG:Qalloc: ""A" " qDescno:  0 
 -- OG:Qalloc:A:  "String " super:  ""A" "  marked:  false "
 --  T := "A" " super:  ""A" " 
 -- Invocation:Qalloc: ""A" " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- OG:super:  
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""A" " 
 --  super:  ""A" " 
 --  E:  ""A" "
 -- OG:Qalloc:end: IS.newDescNo:  0 ""A" " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 71 "T := "A" " 
 -- IS.newDescNo: 71 IS.objSize: 2 "T := "A" " 
 -- OG:Qalloc:end: IS.newDescNo:  71 "T := "A" " 
 -- ObjTmpStack:add: "symbol ": "T := "A" " 
 -- items:markForCodeGen: "T := "A" " 
 -- markItem: "T := "A" " Assign 
 -- Invocation:markForCodeGen: "T " 
 -- ObjectInvocation:markForCodeGen: "T " ATd: 
 --  "out T: var StringLib.String " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: ""A" " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  ""A" " ""A" "true 
 -- OG:markSuper: ""A" " 
 -- Invocation:markForCodeGen: ""A" " 
 -- not ObjDesc:  ""A" "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  Dimension
 --     %dimension "L"
 --     %requires Area
 --     %PublicisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Dimension " "Dimension "false 
 -- OG:markSuper: "Dimension " 
 -- Invocation:markForCodeGen: "Dimension " 
 -- ObjectInvocation:markForCodeGen: "Dimension " ATd: 
 --  
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Dimension
 --     %dimension "L"
 --     %requires Area
 --     %Public
 -- OG:Qalloc: 
 --  Dimension
 --     %dimension "L"
 --     %requires Area
 --     %PublicqDescno:  0 
 -- OG:Qalloc:A:  "Length " super:  "Dimension "  marked:  true 
 --  Length: obj Dimension
 --     %dimension "L"
 --     %requires Area
 --     %Publicsuper:  "Dimension " 
 -- Invocation:Qalloc: "Dimension " 
 -- ObjectInvocation:Qalloc: "Dimension "
 -- name: "Dimension "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- OG:super:  
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Dimension
 --     %dimension "L"
 --     %requires Area
 --     %Public
 --  super:  "Dimension " 
 --  E:  "Dimension "
 -- OG:Qalloc:B: "Length "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 72 IS.newDescNo: 72 objSize: 0 1: 1 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- Items:Qalloc:objSize: 0  newDescNo: 72 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- Items:Qalloc:super: "Dimension " size: 1 "Length "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- Pattern:Qalloc: PrimaryUnit$73 
 -- Pattern:Qalloc:B: PrimaryUnit$73 
 -- Pattern:Qalloc: Meter 
 -- Pattern:Qalloc:B: Meter 
 -- Pattern:Qalloc: Centimeter 
 -- Pattern:Qalloc:B: Centimeter 
 -- Pattern:Qalloc: LightYear 
 -- Pattern:Qalloc:B: LightYear 
 -- Pattern:Qalloc: Foot 
 -- Pattern:Qalloc:B: Foot 
 -- Pattern:Qalloc: Mile 
 -- Pattern:Qalloc:B: Mile 
 -- Pattern:Qalloc: symbol 
 -- Pattern:Qalloc:B: symbol 
 -- Pattern:Qalloc: F2M 
 -- Pattern:Qalloc:B: F2M 
 -- Pattern:Qalloc: Meter2Foot 
 -- Pattern:Qalloc:B: Meter2Foot 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 72 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- IS.newDescNo: 72 IS.objSize: 1 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- OG:Qalloc:end: IS.newDescNo:  72 
 --  Dimension
 --     %dimension "L"
 --     %requires Area
 --     %Public
 -- ObjTmpStack:add: "Length ": 
 --  Dimension
 --     %dimension "L"
 --     %requires Area
 --     %Public
 -- items:markForCodeGen: 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- markItem: "%dimension "L" " Property 
 -- markItem: "%requires Area " Property 
 -- markItem: "%Public " Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:: Meter " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Meter " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Meter " "Meter "false 
 -- OG:markSuper: "Meter " 
 -- Invocation:markForCodeGen: "Meter " 
 -- ObjectInvocation:markForCodeGen: "Meter " ATd: 
 --  
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- Pattern:markForCodeGen: 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: MeterisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Unit " "Unit "false 
 -- OG:markSuper: "Unit " 
 -- Invocation:markForCodeGen: "Unit " 
 -- ObjectInvocation:markForCodeGen: "Unit " ATd: 
 --  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- OG:Qalloc: 
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: MeterqDescno:  0 
 -- OG:Qalloc:A:  "Meter " super:  "Unit "  marked:  true 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Metersuper:  "Unit " 
 -- Invocation:Qalloc: "Unit " 
 -- ObjectInvocation:Qalloc: "Unit "
 -- name: "Unit "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- OG:super:  
 --  Unit: Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 --  super:  "Unit " 
 --  E:  "Unit "
 -- OG:Qalloc:B: "Meter "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 74 IS.newDescNo: 74 objSize: 0 1: 1 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- Items:Qalloc:objSize: 0  newDescNo: 74 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- Items:Qalloc:super: "Unit " size: 2 "Meter "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$75 
 -- Pattern:Qalloc:B: thisUnit$75 
 -- Pattern:Qalloc: argUnit 
 -- Pattern:Qalloc:B: argUnit 
 -- Pattern:Qalloc: argUnit$76 
 -- Pattern:Qalloc:B: argUnit$76 
 -- Pattern:Qalloc: resUnit 
 -- Pattern:Qalloc:B: resUnit 
 -- Pattern:Qalloc: resUnit$77 
 -- Pattern:Qalloc:B: resUnit$77 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Pattern:Qalloc: power 
 -- Pattern:Qalloc:B: power 
 -- Pattern:Qalloc: power2 
 -- Pattern:Qalloc:B: power2 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 74 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- IS.newDescNo: 74 IS.objSize: 2 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- OG:Qalloc:end: IS.newDescNo:  74 
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- ObjTmpStack:add: "Meter ": 
 --  Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- items:markForCodeGen: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- markItem: "%unit "m", 1 " Property 
 -- markItem: "%Public " Property 
 -- Pattern:markForCodeGen: "thisUnit:: Meter " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Meter " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Meter " "Meter "false 
 -- OG:markSuper: "Meter " 
 -- Invocation:markForCodeGen: "Meter " 
 -- ObjectInvocation:markForCodeGen: "Meter " ATd: 
 --  
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- Pattern:markForCodeGen: 
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Meter "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "argUnit:: Meter " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Meter " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Meter " "Meter "false 
 -- OG:markSuper: "Meter " 
 -- Invocation:markForCodeGen: "Meter " 
 -- ObjectInvocation:markForCodeGen: "Meter " ATd: 
 --  
 --  Meter: Unit
 --     %unit "m", 1
 --     %Public
 --     thisUnit:: Meter
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Meter "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "resUnit:: Area.SquareMeter " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Area.SquareMeter " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Area.SquareMeter " "Area "false "SquareMeter "false 
 -- OG:markSuper: "Area.SquareMeter " 
 -- Invocation:markForCodeGen: "Area.SquareMeter " 
 -- ObjectInvocation:markForCodeGen: "Area " ATd: 
 --  
 --  --Area
 --  
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "SquareMeter " ATd: 
 --  
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Area.SquareMeter "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  toPrimary:: 
 --     base.magnitude := magnitude
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "base.magnitude := magnitude " isObjectDesc: 
 --  true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "base.magnitude := magnitude " 
 -- OG:Qalloc: "base.magnitude := magnitude " qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary " super:  " "  marked:  true 
 --  toPrimary:: 
 --     base.magnitude := magnitude
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 3 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude := magnitude " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "toPrimary "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 78 IS.newDescNo: 78 objSize: 0 1: 1 "
 --  base.magnitude := magnitude " 
 -- Items:Qalloc:objSize: 0  newDescNo: 78 "
 --  base.magnitude := magnitude " 
 -- Items:Qalloc:super: " " size: 3 "toPrimary "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Invocation:Qalloc: "base.magnitude " 
 -- ObjectInvocation:Qalloc: "base "
 -- name: "base "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- OG:Qalloc: "magnitude " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "magnitude "  marked:  false "
 --  base.magnitude := magnitude " super:  "magnitude " 
 -- Invocation:Qalloc: "magnitude " 
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "magnitude: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude " 
 --  super:  "magnitude " 
 --  E:  "magnitude "
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 78 "
 --  base.magnitude := magnitude " 
 -- IS.newDescNo: 78 IS.objSize: 3 "base.magnitude := magnitude " 
 -- OG:Qalloc:end: IS.newDescNo:  78 "base.magnitude := magnitude " 
 -- ObjTmpStack:add: "toPrimary ": "base.magnitude := magnitude " 
 -- items:markForCodeGen: "base.magnitude := magnitude " 
 -- markItem: "base.magnitude := magnitude " Assign 
 -- Invocation:markForCodeGen: "base.magnitude " 
 -- ObjectInvocation:markForCodeGen: "base " ATd: 
 --  "out base: var PrimaryUnit " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "magnitude " ATd: 
 --  "magnitude: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "magnitude " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "magnitude " "magnitude "true 
 -- Pattern:markForCodeGen: 
 --  fromPrimary:: 
 --     magnitude := base.magnitude
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "magnitude := base.magnitude " isObjectDesc: 
 --  true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "magnitude := base.magnitude " 
 -- OG:Qalloc: "magnitude := base.magnitude " qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary " super:  " "  marked:  true 
 --  fromPrimary:: 
 --     magnitude := base.magnitude
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 3 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude := base.magnitude " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "fromPrimary "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 79 IS.newDescNo: 79 objSize: 0 1: 1 "
 --  magnitude := base.magnitude " 
 -- Items:Qalloc:objSize: 0  newDescNo: 79 "
 --  magnitude := base.magnitude " 
 -- Items:Qalloc:super: " " size: 3 "fromPrimary "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Invocation:Qalloc: "magnitude " 
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- OG:Qalloc: "base.magnitude " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "base.magnitude "  marked:  false "
 --  magnitude := base.magnitude " super:  "base.magnitude " 
 -- Invocation:Qalloc: "base.magnitude " 
 -- ObjectInvocation:Qalloc: "base "
 -- name: "base "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "magnitude "
 -- name: "magnitude "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "magnitude: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude " 
 --  super:  "base.magnitude " 
 --  E:  "magnitude "
 -- OG:Qalloc:end: IS.newDescNo:  0 "base.magnitude " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 79 "
 --  magnitude := base.magnitude " 
 -- IS.newDescNo: 79 IS.objSize: 3 "magnitude := base.magnitude " 
 -- OG:Qalloc:end: IS.newDescNo:  79 "magnitude := base.magnitude " 
 -- ObjTmpStack:add: "fromPrimary ": "magnitude := base.magnitude " 
 -- items:markForCodeGen: "magnitude := base.magnitude " 
 -- markItem: "magnitude := base.magnitude " Assign 
 -- Invocation:markForCodeGen: "magnitude " 
 -- ObjectInvocation:markForCodeGen: "magnitude " ATd: 
 --  "magnitude: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "base.magnitude " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "base.magnitude " "base "false "magnitude "true 
 -- Pattern:markForCodeGen: 
 --  print:: 
 --     "Meter".print
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: ""Meter".print " isObjectDesc: true 
 --   hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: ""Meter".print " 
 -- OG:Qalloc: ""Meter".print " qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  " "  marked:  true 
 --  print:: 
 --     "Meter".print
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 1 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Meter".print " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "print "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 80 IS.newDescNo: 80 objSize: 0 1: 1 "
 --  "Meter".print " 
 -- Items:Qalloc:objSize: 0  newDescNo: 80 ""Meter".print " 
 -- Items:Qalloc:super: " " size: 1 "print "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- OG:Qalloc: ""Meter".print " qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  ""Meter".print "  marked:  false "
 --  "Meter".print " super:  ""Meter".print " 
 -- Invocation:Qalloc: ""Meter".print " 
 -- ObjectInvocation:Qalloc: "print "
 -- name: "print "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- OG:super:  
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Meter".print " 
 --  super:  ""Meter".print " 
 --  E:  "print "
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Meter".print " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 80 ""Meter".print " 
 -- IS.newDescNo: 80 IS.objSize: 1 ""Meter".print " 
 -- OG:Qalloc:end: IS.newDescNo:  80 ""Meter".print " 
 -- ObjTmpStack:add: "print ": ""Meter".print " 
 -- items:markForCodeGen: ""Meter".print " 
 -- markItem: ""Meter".print " ObjectGenerator 
 -- OG:markForCodeGen: ""Meter".print " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  ""Meter".print " ""Meter" "true "print "false 
 -- OG:markSuper: ""Meter".print " 
 -- Invocation:markForCodeGen: ""Meter".print " 
 -- ObjectInvocation:markForCodeGen: "print " ATd: 
 --  
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  ""Meter".print "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Meter "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  symbol:: 
 --     T := "L"
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "T := "L" " isObjectDesc: true  hasItems: 
 --  true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "T := "L" " 
 -- OG:Qalloc: "T := "L" " qDescno:  0 
 -- OG:Qalloc:A:  "symbol " super:  " "  marked:  true 
 --  symbol:: 
 --     T := "L"
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  63 2 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T := "L" " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "symbol "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 81 IS.newDescNo: 81 objSize: 0 1: 1 "
 --  T := "L" " 
 -- Items:Qalloc:objSize: 0  newDescNo: 81 "T := "L" " 
 -- Items:Qalloc:super: " " size: 2 "symbol "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 1 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Invocation:Qalloc: "T " 
 -- ObjectInvocation:Qalloc: "T "
 -- name: "T "
 -- Arguments " "
 -- OG:Qalloc: ""L" " qDescno:  0 
 -- OG:Qalloc:A:  "String " super:  ""L" "  marked:  false "
 --  T := "L" " super:  ""L" " 
 -- Invocation:Qalloc: ""L" " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- OG:super:  
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""L" " 
 --  super:  ""L" " 
 --  E:  ""L" "
 -- OG:Qalloc:end: IS.newDescNo:  0 ""L" " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 81 "T := "L" " 
 -- IS.newDescNo: 81 IS.objSize: 2 "T := "L" " 
 -- OG:Qalloc:end: IS.newDescNo:  81 "T := "L" " 
 -- ObjTmpStack:add: "symbol ": "T := "L" " 
 -- items:markForCodeGen: "T := "L" " 
 -- markItem: "T := "L" " Assign 
 -- Invocation:markForCodeGen: "T " 
 -- ObjectInvocation:markForCodeGen: "T " ATd: 
 --  "out T: var StringLib.String " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: ""L" " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  ""L" " ""L" "true 
 -- OG:markSuper: ""L" " 
 -- Invocation:markForCodeGen: ""L" " 
 -- not ObjDesc:  ""L" "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: ValueisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: Value
 -- OG:Qalloc: 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: ValueqDescno:  0 
 -- OG:Qalloc:A:  "StringLib " super:  " "  marked:  true 
 --  StringLib: obj 
 --     %id "String module"
 --     %module LIB
 --     %publicsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: Value
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "StringLib "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 82 IS.newDescNo: 82 objSize: 0 1: 1 
 --  %id "String module"
 --  %module LIB
 --  %public
 --  String: Value
 -- Items:Qalloc:objSize: 0  newDescNo: 82 
 --  %id "String module"
 --  %module LIB
 --  %public
 --  String: Value
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: String 
 -- Pattern:Qalloc: C 
 -- Pattern:Qalloc:B: C 
 -- Pattern:Qalloc: I2S 
 -- Pattern:Qalloc:B: I2S 
 -- Pattern:Qalloc: F2S 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 82 
 --  %id "String module"
 --  %module LIB
 --  %public
 --  String: Value
 -- IS.newDescNo: 82 IS.objSize: 1 
 --  %id "String module"
 --  %module LIB
 --  %public
 --  String: Value
 -- OG:Qalloc:end: IS.newDescNo:  82 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: Value
 -- ObjTmpStack:add: "StringLib ": 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: Value
 -- items:markForCodeGen: 
 --  %id "String module"
 --  %module LIB
 --  %public
 --  String: Value
 -- markItem: "%id "String module" " Property 
 -- markItem: "%module LIB " Property 
 -- markItem: "%public " Property 
 -- Items:markString 
 --  %id "String module"
 --  %module LIB
 --  %public
 --  String: Value
 -- Pattern:markForCodeGen: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "StringLib " ATd: 
 --  
 --  --StringLib
 --  
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "String " ATd: 
 --  
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "LIB.StringLib.String "  IS.isEmpty:  true 
 -- markItem: "inner(X_asString) " ObjectGenerator 
 -- markItem: "inner(Object) " ObjectGenerator 
 -- not ObjDesc:  "Object "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "this(Value) "
 -- OG:markForCodeGen: "Value " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Value " "Value "true 
 -- OG:markSuper: "Value " 
 -- Invocation:markForCodeGen: "Value " 
 -- ObjectInvocation:markForCodeGen: "Value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Value "  IS.isEmpty:  true 
 -- arg:   "Value "
 -- not ObjDesc:  "this(Value) "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Veq.length "  IS.isEmpty:  true 
 -- not ObjDesc:  "(L <> Veq.length) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "leave(loop) " isObjectDesc: true  hasItems: 
 --  true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "leave(loop) " 
 -- OG:Qalloc: "leave(loop) " qDescno:  18 
 -- ObjTmpStack:add: "leave(loop) " 
 -- items:markForCodeGen: "leave(loop) " 
 -- markItem: "leave(loop) " ObjectGenerator 
 -- not ObjDesc:  
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --   IS.isEmpty:  true 
 -- markItem: "beq := true " Assign 
 -- Invocation:markForCodeGen: "beq " 
 -- ObjectInvocation:markForCodeGen: "beq " ATd: 
 --  "out Beq: var boolean " 
 -- DataItem:markForCodeGen: "Beq ":descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "boolean " "boolean "true 
 -- OG:markSuper: "boolean " 
 -- Invocation:markForCodeGen: "boolean " 
 -- ObjectInvocation:markForCodeGen: "boolean " ATd: 
 --  
 --  Boolean: value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- Pattern:markForCodeGen: 
 --  Boolean: value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "value " "value "true 
 -- OG:markSuper: "value " 
 -- Invocation:markForCodeGen: "value " 
 -- ObjectInvocation:markForCodeGen: "value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- OG:markIS: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- OG:Qalloc: 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8qDescno:  0 
 -- OG:Qalloc:A:  "Boolean " super:  "value "  marked:  true 
 --  Boolean: value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8super:  "value " 
 -- Invocation:Qalloc: "value " 
 -- ObjectInvocation:Qalloc: "value "
 -- name: "value "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- OG:super:  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 --  super:  "value " 
 --  E:  "value "
 -- OG:Qalloc:B: "Boolean "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 83 IS.newDescNo: 83 objSize: 0 1: 1 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- Items:Qalloc:objSize: 0  newDescNo: 83 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- Items:Qalloc:super: "value " size: 0 "Boolean "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "_thisBasicValue "isValue: true  isPrimitive: 
 --  true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: && 
 -- Pattern:Qalloc: || 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: not 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 83 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- IS.newDescNo: 83 IS.objSize: 1 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- OG:Qalloc:end: IS.newDescNo:  83 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- ObjTmpStack:add: "Boolean ": 
 --  value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- items:markForCodeGen: 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- markItem: "%id "Boolean" " Property 
 -- markItem: "%globals inSub " Property 
 -- markItem: "%basic 4, 8 " Property 
 -- markItem: "%public " Property 
 -- DataItem:markForCodeGen: "_thisBasicValue ":descNo: 0 
 --  :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Universal " "Universal "true 
 -- OG:markSuper: "Universal " 
 -- Invocation:markForCodeGen: "Universal " 
 -- ObjectInvocation:markForCodeGen: "Universal " ATd: 
 --  
 --  universal: Value
 --     %ID universal
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Universal "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "boolean "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "true " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "true " "true "false 
 -- OG:markSuper: "true " 
 -- Invocation:markForCodeGen: "true " 
 -- ObjectInvocation:markForCodeGen: "true " ATd: 
 --  
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- Pattern:markForCodeGen: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- OG:Qalloc: 
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  qDescno:  23 
 -- ObjTmpStack:add: "True ": 
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- items:markForCodeGen: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  
 -- markItem: "%globals " Property 
 -- DataItem:markForCodeGen: "B ":descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "boolean " "boolean "true 
 -- OG:markSuper: "boolean " 
 -- Invocation:markForCodeGen: "boolean " 
 -- ObjectInvocation:markForCodeGen: "boolean " ATd: 
 --  
 --  Boolean: value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "boolean "  IS.isEmpty:  true 
 -- markItem: "B := 1 " Assign 
 -- Invocation:markForCodeGen: "B " 
 -- ObjectInvocation:markForCodeGen: "B " ATd: 
 --  "out B: var boolean " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "true "  IS.isEmpty:  true 
 -- markItem: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then ObjectGenerator 
 -- OG:markForCodeGen: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then isObjectDesc: true  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 -- \
 --         leave(loop)
 --   "false 
 -- OG:markSuper: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- Invocation:markForCodeGen: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- ObjectInvocation:markForCodeGen: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " ATd: 
 --  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OI:args:markForCodgen: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "length " "length "false 
 -- OG:markSuper: "length " 
 -- Invocation:markForCodeGen: "length " 
 -- ObjectInvocation:markForCodeGen: "length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "length "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := falseisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 -- OG:Qalloc: 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := falseqDescno:  24 
 -- ObjTmpStack:add: 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 -- items:markForCodeGen: 
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 <> c2) :then 
 --     Beq := false
 -- markItem: "c1 := get[inx] " Assign 
 -- Invocation:markForCodeGen: "c1 " 
 -- ObjectInvocation:markForCodeGen: "c1 " ATd: 
 --  "c1: var char " 
 -- OI:args:markForCodgen: " "
 -- markItem: "c2 := Veq.get[inx] " Assign 
 -- Invocation:markForCodeGen: "c2 " 
 -- ObjectInvocation:markForCodeGen: "c2 " ATd: 
 --  "c2: var char " 
 -- OI:args:markForCodgen: " "
 -- markItem: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "true 
 -- OG:markSuper: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- Invocation:markForCodeGen: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- OG:markForCodeGen: "(c1 <> c2) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(c1 <> c2) " "(c1 <> c2) "true 
 -- OG:markSuper: "(c1 <> c2) " 
 -- Invocation:markForCodeGen: "(c1 <> c2) " 
 -- Invocation:markForCodeGen: "c1 <> c2 " 
 -- BinaryExp:markForCodeGen: "c1 <> c2 "
 -- Invocation:markForCodeGen: "c1 " 
 -- ObjectInvocation:markForCodeGen: "c1 " ATd: 
 --  "c1: var char " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "<> c2 " ATd: 
 --  
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- Pattern:markForCodeGen: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "c2 "
 -- OG:markForCodeGen: "c2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "c2 " "c2 "true 
 -- not ObjDesc:  "(c1 <> c2) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  Beq := false
 --     leave(loop)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  Beq := false
 --     leave(loop)
 --  
 -- OG:Qalloc: 
 --  Beq := false
 --     leave(loop)
 --  qDescno:  26 
 -- ObjTmpStack:add: 
 --  Beq := false
 --     leave(loop)
 --  
 -- items:markForCodeGen: 
 --  Beq := false
 --  leave(loop)
 --  
 -- markItem: "Beq := false " Assign 
 -- Invocation:markForCodeGen: "Beq " 
 -- ObjectInvocation:markForCodeGen: "Beq " ATd: 
 --  "out Beq: var boolean " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "false " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "false " "false "false 
 -- OG:markSuper: "false " 
 -- Invocation:markForCodeGen: "false " 
 -- ObjectInvocation:markForCodeGen: "false " ATd: 
 --  
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- Pattern:markForCodeGen: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OG:Qalloc: 
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  qDescno:  27 
 -- ObjTmpStack:add: "False ": 
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- items:markForCodeGen: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 -- markItem: "%globals " Property 
 -- DataItem:markForCodeGen: "B ":descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "boolean " "boolean "true 
 -- OG:markSuper: "boolean " 
 -- Invocation:markForCodeGen: "boolean " 
 -- ObjectInvocation:markForCodeGen: "boolean " ATd: 
 --  
 --  Boolean: value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "boolean "  IS.isEmpty:  true 
 -- markItem: "B := 0 " Assign 
 -- Invocation:markForCodeGen: "B " 
 -- ObjectInvocation:markForCodeGen: "B " ATd: 
 --  "out B: var boolean " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "0 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "0 " "0 "true 
 -- OG:markSuper: "0 " 
 -- Invocation:markForCodeGen: "0 " 
 -- not ObjDesc:  "0 "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "false "  IS.isEmpty:  true 
 -- markItem: "leave(loop) " ObjectGenerator 
 -- not ObjDesc:  
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --   IS.isEmpty:  true 
 -- arg:   "1 "
 -- arg:   "length "
 -- arg:   "
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop) "
 -- OG:markIS: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- OG:Qalloc: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then qDescno:  30 
 -- ObjTmpStack:add: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- items:markForCodeGen: " " 
 -- Pattern:markForCodeGen: 
 --  <=  :: 
 --     loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 --        -- "Qweayc" <= "Qwexby"isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 --        -- "Qweayc" <= "Qwexby"
 -- OG:Qalloc: 
 --  loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 --        -- "Qweayc" <= "Qwexby"qDescno:  0 
 -- OG:Qalloc:A:  "<= " super:  " "  marked:  true 
 --  <=  :: 
 --     loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= esuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  58 3 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 --        -- "Qweayc" <= "Qwexby"
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "<= "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 84 IS.newDescNo: 84 objSize: 0 1: 1 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- Items:Qalloc:objSize: 0  newDescNo: 84 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- Items:Qalloc:super: " " size: 3 "<= "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "loop "isValue: false  isPrimitive: false 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- OG:Qalloc: 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"qDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  " "  marked:  false 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "loop "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 85 IS.newDescNo: 85 objSize: 0 1: 1 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"
 -- Items:Qalloc:objSize: 0  newDescNo: 85 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: matchEq 
 -- Pattern:Qalloc:B: matchEq 
 -- dataitem:qalloc: "L "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "L1 "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "L2 "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Invocation:Qalloc: "L1 " 
 -- ObjectInvocation:Qalloc: "L1 "
 -- name: "L1 "
 -- Arguments " "
 -- OG:Qalloc: 
 --  length
 --  -- min length of this and V
 --  qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  
 --  length
 --  -- min length of this and V
 --   marked:  false 
 --  L1 := length
 --  -- min length of this and V
 --  super:  
 --  length
 --  -- min length of this and V
 --  
 -- Invocation:Qalloc: 
 --  length
 --  -- min length of this and V
 --  
 -- ObjectInvocation:Qalloc: "length
 --  -- min length of this and V "
 -- name: "length "
 -- Arguments "-- min length of this and V "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  length
 --  -- min length of this and V
 --  
 --  super:  
 --  length
 --  -- min length of this and V
 --  
 --  E:  "length
 --  -- min length of this and V "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  length
 --  -- min length of this and V
 --  
 -- Invocation:Qalloc: "L2 " 
 -- ObjectInvocation:Qalloc: "L2 "
 -- name: "L2 "
 -- Arguments " "
 -- OG:Qalloc: "Veq.length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "Veq.length "  marked:  false "
 --  L2 := Veq.length " super:  "Veq.length " 
 -- Invocation:Qalloc: "Veq.length " 
 -- ObjectInvocation:Qalloc: "Veq "
 -- name: "Veq "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "length "
 -- name: "length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.length " 
 --  super:  "Veq.length " 
 --  E:  "length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.length " 
 -- OG:Qalloc: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --   marked:  false 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"super:  
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- Invocation:Qalloc: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- OG:Qalloc: "(L1 < L2) " qDescno:  0 
 -- OG:Qalloc:A:  "< " super:  "(L1 < L2) "  marked:  false 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  super:  "(L1 < L2) " 
 -- Invocation:Qalloc: "(L1 < L2) " 
 -- Invocation:Qalloc: "L1 < L2 " 
 -- BinaryExp:Qalloc: "L1 < L2 "
 -- Invocation:Qalloc: "L1 " 
 -- ObjectInvocation:Qalloc: "L1 "
 -- name: "L1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "< L2 "
 -- name: "< "
 -- Arguments "L2 "
 -- OG:Qalloc: "L2 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L2 "  marked:  false "L2 " 
 --  super:  "L2 " 
 -- Invocation:Qalloc: "L2 " 
 -- ObjectInvocation:Qalloc: "L2 "
 -- name: "L2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L2: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2 " 
 --  super:  "L2 " 
 --  E:  "L2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc: 
 --  %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  qDescno:  0 
 -- OG:Qalloc:A:  "< " super:  " "  marked:  false 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "< "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 86 IS.newDescNo: 86 objSize: 0 1: 1 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 86 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 86 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  
 -- IS.newDescNo: 86 IS.objSize: 3 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:Qalloc:end: IS.newDescNo:  86 
 --  %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:super:  
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L1 < L2) " 
 --  super:  "(L1 < L2) " 
 --  E:  "(L1 < L2) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L1 < L2) " 
 -- OG:Qalloc: "L := L1 " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L := L1 " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 87 IS.newDescNo: 87 objSize: 0 1: 1 "
 --  L := L1 " 
 -- Items:Qalloc:objSize: 0  newDescNo: 87 "L := L1 " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- OG:Qalloc: "L1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L1 "  marked:  false "
 --  L := L1 " super:  "L1 " 
 -- Invocation:Qalloc: "L1 " 
 -- ObjectInvocation:Qalloc: "L1 "
 -- name: "L1 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L1: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 " 
 --  super:  "L1 " 
 --  E:  "L1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 87 "L := L1 " 
 -- IS.newDescNo: 87 IS.objSize: 1 "L := L1 " 
 -- OG:Qalloc:end: IS.newDescNo:  87 "L := L1 " 
 -- OG:Qalloc: "L := L2 " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L := L2 " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 88 IS.newDescNo: 88 objSize: 0 1: 1 "
 --  L := L2 " 
 -- Items:Qalloc:objSize: 0  newDescNo: 88 "L := L2 " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- OG:Qalloc: "L2 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L2 "  marked:  false "
 --  L := L2 " super:  "L2 " 
 -- Invocation:Qalloc: "L2 " 
 -- ObjectInvocation:Qalloc: "L2 "
 -- name: "L2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L2: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2 " 
 --  super:  "L2 " 
 --  E:  "L2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2 " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 88 "L := L2 " 
 -- IS.newDescNo: 88 IS.objSize: 1 "L := L2 " 
 -- OG:Qalloc:end: IS.newDescNo:  88 "L := L2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 --  super:  
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 --  E:  "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- OG:Qalloc: "matchEq " qDescno:  0 
 -- OG:Qalloc:A:  "matchEq " super:  "matchEq "  marked:  false 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"super:  "matchEq " 
 -- Invocation:Qalloc: "matchEq " 
 -- ObjectInvocation:Qalloc: "matchEq "
 -- name: "matchEq "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- OG:Qalloc:SuperAlloc: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- OG:Qalloc: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do qDescno:  0 
 -- OG:Qalloc:A:  "matchEq " super:  " "  marked:  false 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var charsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "matchEq "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 89 IS.newDescNo: 89 objSize: 0 1: 1 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- Items:Qalloc:objSize: 0  newDescNo: 89 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "inx "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "c1 "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "c2 "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 89 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- IS.newDescNo: 89 IS.objSize: 4 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- OG:Qalloc:end: IS.newDescNo:  89 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
 -- OG:super:  
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq " 
 --  super:  "matchEq " 
 --  E:  "matchEq "
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 85 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"
 -- IS.newDescNo: 85 IS.objSize: 4 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"
 -- OG:Qalloc:end: IS.newDescNo:  85 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 84 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- IS.newDescNo: 84 IS.objSize: 4 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- OG:Qalloc:end: IS.newDescNo:  84 
 --  loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 --        -- "Qweayc" <= "Qwexby"
 -- ObjTmpStack:add: "<=   ": 
 --  loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 --        -- "Qweayc" <= "Qwexby"
 -- items:markForCodeGen: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- DataItem:markForCodeGen: "loop ":descNo: 85 :OG.primNo: 0 
 -- OG:markForCodeGen: 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"
 -- OG:Qalloc: 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"qDescno:  85 
 -- ObjTmpStack:add: "loop ": 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"
 -- items:markForCodeGen: 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"
 -- DataItem:markForCodeGen: "L ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L1 ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L2 ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: 
 --  L1 := length
 --  -- min length of this and V
 --  Assign 
 -- Invocation:markForCodeGen: "L1 " 
 -- ObjectInvocation:markForCodeGen: "L1 " ATd: 
 --  "L1: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: 
 --  length
 --  -- min length of this and V
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  
 --  length
 --  -- min length of this and V
 --  "length
 --  -- min length of this and V "false 
 -- OG:markSuper: 
 --  length
 --  -- min length of this and V
 --  
 -- Invocation:markForCodeGen: 
 --  length
 --  -- min length of this and V
 --  
 -- ObjectInvocation:markForCodeGen: "
 --  length
 --  -- min length of this and V " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: "-- min length of this and V "
 -- not ObjDesc:  
 --  length
 --  -- min length of this and V
 --   IS.isEmpty:  true 
 -- markItem: "L2 := Veq.length " Assign 
 -- Invocation:markForCodeGen: "L2 " 
 -- ObjectInvocation:markForCodeGen: "L2 " ATd: 
 --  "L2: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "Veq.length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Veq.length " "Veq "true "length "false 
 -- OG:markSuper: "Veq.length " 
 -- Invocation:markForCodeGen: "Veq.length " 
 -- ObjectInvocation:markForCodeGen: "Veq " ATd: 
 --  "in Veq: var this(Value) " 
 -- DataItem:markForCodeGen: "Veq ":descNo: 0 :OG.primNo: 18 
 -- OG:markForCodeGen: "this(Value) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "this(Value) " "this(Value) "true 
 -- OG:markSuper: "this(Value) " 
 -- Invocation:markForCodeGen: "this(Value) " 
 -- ObjectInvocation:markForCodeGen: "this(Value) " ATd: 
 --  
 --  this: 
 --     %basic 18
 --     in this: ref Object
 --  
 -- OI:args:markForCodgen: "this(Value) "
 -- OG:markForCodeGen: "Value " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Value " "Value "true 
 -- OG:markSuper: "Value " 
 -- Invocation:markForCodeGen: "Value " 
 -- ObjectInvocation:markForCodeGen: "Value " ATd: 
 --  
 --  Value: 
 --     %ID Value
 --     %globals
 --     %basic 21
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Value "  IS.isEmpty:  true 
 -- arg:   "Value "
 -- not ObjDesc:  "this(Value) "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Veq.length "  IS.isEmpty:  true 
 -- markItem: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "true 
 -- OG:markSuper: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- Invocation:markForCodeGen: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- OG:markForCodeGen: "(L1 < L2) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(L1 < L2) " "(L1 < L2) "true 
 -- OG:markSuper: "(L1 < L2) " 
 -- Invocation:markForCodeGen: "(L1 < L2) " 
 -- Invocation:markForCodeGen: "L1 < L2 " 
 -- BinaryExp:markForCodeGen: "L1 < L2 "
 -- Invocation:markForCodeGen: "L1 " 
 -- ObjectInvocation:markForCodeGen: "L1 " ATd: 
 --  "L1: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "< L2 " ATd: 
 --  
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- Pattern:markForCodeGen: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "L2 "
 -- OG:markForCodeGen: "L2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L2 " "L2 "true 
 -- not ObjDesc:  "(L1 < L2) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L := L1 " isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "L := L1 " 
 -- OG:Qalloc: "L := L1 " qDescno:  87 
 -- ObjTmpStack:add: "L := L1 " 
 -- items:markForCodeGen: "L := L1 " 
 -- markItem: "L := L1 " Assign 
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L1 " "L1 "true 
 -- OG:markForCodeGen: "L := L2 " isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "L := L2 " 
 -- OG:Qalloc: "L := L2 " qDescno:  88 
 -- ObjTmpStack:add: "L := L2 " 
 -- items:markForCodeGen: "L := L2 " 
 -- markItem: "L := L2 " Assign 
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L2 " "L2 "true 
 -- not ObjDesc:  
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --   IS.isEmpty:  true 
 -- markItem: "matchEq " ObjectGenerator 
 -- OG:markForCodeGen: "matchEq " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "matchEq " "matchEq "false 
 -- OG:markSuper: "matchEq " 
 -- Invocation:markForCodeGen: "matchEq " 
 -- ObjectInvocation:markForCodeGen: "matchEq " ATd: 
 --  
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- Pattern:markForCodeGen: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
 -- OG:Qalloc: 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do qDescno:  89 
 -- ObjTmpStack:add: "matchEq ": 
 --  inx: var integer
 --     c1: var char
 --     c2: var char
 --     isEmpty: do 
 -- items:markForCodeGen: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- DataItem:markForCodeGen: "inx ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c1 ":descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "char " "char "true 
 -- OG:markSuper: "char " 
 -- Invocation:markForCodeGen: "char " 
 -- ObjectInvocation:markForCodeGen: "char " ATd: 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "char "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c2 ":descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "char " "char "true 
 -- OG:markSuper: "char " 
 -- Invocation:markForCodeGen: "char " 
 -- ObjectInvocation:markForCodeGen: "char " ATd: 
 --  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "char "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 --     if (L2 = 0) :then isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 --     if (L2 = 0) :then 
 -- OG:Qalloc: 
 --  if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 --     if (L2 = 0) :then qDescno:  0 
 -- OG:Qalloc:A:  "isEmpty " super:  " "  marked:  true 
 --  isEmpty: do 
 --     if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 --     if (L2 = 0) :then 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "isEmpty "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 90 IS.newDescNo: 90 objSize: 0 1: 1 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then 
 -- Items:Qalloc:objSize: 0  newDescNo: 90 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --   marked:  false 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then super:  
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- Invocation:Qalloc: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:Qalloc: "(L1 = 0) " qDescno:  0 
 -- OG:Qalloc:A:  "= " super:  "(L1 = 0) "  marked:  false 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  super:  "(L1 = 0) " 
 -- Invocation:Qalloc: "(L1 = 0) " 
 -- Invocation:Qalloc: "L1 = 0 " 
 -- BinaryExp:Qalloc: "L1 = 0 "
 -- Invocation:Qalloc: "L1 " 
 -- ObjectInvocation:Qalloc: "L1 "
 -- name: "L1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "= 0 "
 -- name: "= "
 -- Arguments "0 "
 -- OG:Qalloc: "0 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "0 "  marked:  false "0 " 
 --  super:  "0 " 
 -- Invocation:Qalloc: "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 " 
 --  super:  "0 " 
 --  E:  "0 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 3 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- OG:super:  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L1 = 0) " 
 --  super:  "(L1 = 0) " 
 --  E:  "(L1 = 0) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L1 = 0) " 
 -- OG:Qalloc: 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 91 IS.newDescNo: 91 objSize: 0 1: 1 
 --  Beq := L1 <= L2
 --  leave(matchEq)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 91 
 --  Beq := L1 <= L2
 --  leave(matchEq)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq " 
 -- ObjectInvocation:Qalloc: "Beq "
 -- name: "Beq "
 -- Arguments " "
 -- OG:Qalloc: "L1 <= L2 " qDescno:  0 
 -- OG:Qalloc:A:  "<= " super:  "L1 <= L2 "  marked:  false "
 --  Beq := L1 <= L2 " super:  "L1 <= L2 " 
 -- Invocation:Qalloc: "L1 <= L2 " 
 -- BinaryExp:Qalloc: "L1 <= L2 "
 -- Invocation:Qalloc: "L1 " 
 -- ObjectInvocation:Qalloc: "L1 "
 -- name: "L1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "<= L2 "
 -- name: "<= "
 -- Arguments "L2 "
 -- OG:Qalloc: "L2 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L2 "  marked:  false "L2 " 
 --  super:  "L2 " 
 -- Invocation:Qalloc: "L2 " 
 -- ObjectInvocation:Qalloc: "L2 "
 -- name: "L2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L2: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2 " 
 --  super:  "L2 " 
 --  E:  "L2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  58 3 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- OG:super:  
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 <= L2 " 
 --  super:  "L1 <= L2 " 
 --  E:  "L1 <= L2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 <= L2 " 
 -- OG:Qalloc: "leave(matchEq) " qDescno:  0 
 -- OG:Qalloc:A:  "leave " super:  "leave(matchEq) "  marked:  false 
 --  Beq := L1 <= L2
 --  leave(matchEq)
 --  super:  "leave(matchEq) " 
 -- Invocation:Qalloc: "leave(matchEq) " 
 -- ObjectInvocation:Qalloc: "leave(matchEq) "
 -- name: "leave "
 -- Arguments "leave(matchEq) "
 -- OG:Qalloc: "matchEq " qDescno:  0 
 -- OG:Qalloc:A:  "matchEq " super:  "matchEq "  marked:  false "
 --  leave(matchEq) " super:  "matchEq " 
 -- Invocation:Qalloc: "matchEq " 
 -- ObjectInvocation:Qalloc: "matchEq "
 -- name: "matchEq "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  89 4 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- OG:super:  
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq " 
 --  super:  "matchEq " 
 --  E:  "matchEq "
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 "
 --  %basic 103 " 
 -- OG:super:  
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq) " 
 --  super:  "leave(matchEq) " 
 --  E:  "leave(matchEq) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 91 
 --  Beq := L1 <= L2
 --  leave(matchEq)
 --  
 -- IS.newDescNo: 91 IS.objSize: 1 
 --  Beq := L1 <= L2
 --  leave(matchEq)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  91 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 --  super:  
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 --  E:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:Qalloc: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --   marked:  false 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then super:  
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- Invocation:Qalloc: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- OG:Qalloc: "(L2 = 0) " qDescno:  0 
 -- OG:Qalloc:A:  "= " super:  "(L2 = 0) "  marked:  false 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  super:  "(L2 = 0) " 
 -- Invocation:Qalloc: "(L2 = 0) " 
 -- Invocation:Qalloc: "L2 = 0 " 
 -- BinaryExp:Qalloc: "L2 = 0 "
 -- Invocation:Qalloc: "L2 " 
 -- ObjectInvocation:Qalloc: "L2 "
 -- name: "L2 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "= 0 "
 -- name: "= "
 -- Arguments "0 "
 -- OG:Qalloc: "0 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "0 "  marked:  false "0 " 
 --  super:  "0 " 
 -- Invocation:Qalloc: "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 " 
 --  super:  "0 " 
 --  E:  "0 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 3 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- OG:super:  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L2 = 0) " 
 --  super:  "(L2 = 0) " 
 --  E:  "(L2 = 0) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L2 = 0) " 
 -- OG:Qalloc: 
 --  Beq := false
 --     leave(matchEq)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Beq := false
 --     leave(matchEq)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 92 IS.newDescNo: 92 objSize: 0 1: 1 
 --  Beq := false
 --  leave(matchEq)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 92 
 --  Beq := false
 --  leave(matchEq)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq " 
 -- ObjectInvocation:Qalloc: "Beq "
 -- name: "Beq "
 -- Arguments " "
 -- OG:Qalloc: "false " qDescno:  0 
 -- OG:Qalloc:A:  "False " super:  "false "  marked:  false "
 --  Beq := false " super:  "false " 
 -- Invocation:Qalloc: "false " 
 -- ObjectInvocation:Qalloc: "false "
 -- name: "false "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  27 1 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 -- OG:super:  
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "false " 
 --  super:  "false " 
 --  E:  "false "
 -- OG:Qalloc:end: IS.newDescNo:  0 "false " 
 -- OG:Qalloc: "leave(matchEq) " qDescno:  0 
 -- OG:Qalloc:A:  "leave " super:  "leave(matchEq) "  marked:  false 
 --  Beq := false
 --  leave(matchEq)
 --  super:  "leave(matchEq) " 
 -- Invocation:Qalloc: "leave(matchEq) " 
 -- ObjectInvocation:Qalloc: "leave(matchEq) "
 -- name: "leave "
 -- Arguments "leave(matchEq) "
 -- OG:Qalloc: "matchEq " qDescno:  0 
 -- OG:Qalloc:A:  "matchEq " super:  "matchEq "  marked:  false "
 --  leave(matchEq) " super:  "matchEq " 
 -- Invocation:Qalloc: "matchEq " 
 -- ObjectInvocation:Qalloc: "matchEq "
 -- name: "matchEq "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  89 4 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- OG:super:  
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq " 
 --  super:  "matchEq " 
 --  E:  "matchEq "
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 "
 --  %basic 103 " 
 -- OG:super:  
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq) " 
 --  super:  "leave(matchEq) " 
 --  E:  "leave(matchEq) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 92 
 --  Beq := false
 --  leave(matchEq)
 --  
 -- IS.newDescNo: 92 IS.objSize: 1 
 --  Beq := false
 --  leave(matchEq)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  92 
 --  Beq := false
 --     leave(matchEq)
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 --  super:  
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 --  E:  "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- Items:Qalloc:END:objSize: 1  newDescNo: 90 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then 
 -- IS.newDescNo: 90 IS.objSize: 1 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then 
 -- OG:Qalloc:end: IS.newDescNo:  90 
 --  if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 --     if (L2 = 0) :then 
 -- ObjTmpStack:add: "isEmpty ": 
 --  if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 --     if (L2 = 0) :then 
 -- items:markForCodeGen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then 
 -- markItem: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "true 
 -- OG:markSuper: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- Invocation:markForCodeGen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:markForCodeGen: "(L1 = 0) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(L1 = 0) " "(L1 = 0) "true 
 -- OG:markSuper: "(L1 = 0) " 
 -- Invocation:markForCodeGen: "(L1 = 0) " 
 -- Invocation:markForCodeGen: "L1 = 0 " 
 -- BinaryExp:markForCodeGen: "L1 = 0 "
 -- Invocation:markForCodeGen: "L1 " 
 -- ObjectInvocation:markForCodeGen: "L1 " ATd: 
 --  "L1: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "= 0 " ATd: 
 --  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:args:markForCodgen: "0 "
 -- OG:markForCodeGen: "0 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "0 " "0 "true 
 -- OG:markSuper: "0 " 
 -- Invocation:markForCodeGen: "0 " 
 -- not ObjDesc:  "0 "  IS.isEmpty:  true 
 -- not ObjDesc:  "(L1 = 0) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:Qalloc: 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  qDescno:  91 
 -- ObjTmpStack:add: 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- items:markForCodeGen: 
 --  Beq := L1 <= L2
 --  leave(matchEq)
 --  
 -- markItem: "Beq := L1 <= L2 " Assign 
 -- Invocation:markForCodeGen: "Beq " 
 -- ObjectInvocation:markForCodeGen: "Beq " ATd: 
 --  "out Beq: var boolean " 
 -- DataItem:markForCodeGen: "Beq ":descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "boolean " "boolean "true 
 -- OG:markSuper: "boolean " 
 -- Invocation:markForCodeGen: "boolean " 
 -- ObjectInvocation:markForCodeGen: "boolean " ATd: 
 --  
 --  Boolean: value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "boolean "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L1 <= L2 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L1 <= L2 " "L1 <= L2 "true 
 -- OG:markSuper: "L1 <= L2 " 
 -- Invocation:markForCodeGen: "L1 <= L2 " 
 -- BinaryExp:markForCodeGen: "L1 <= L2 "
 -- Invocation:markForCodeGen: "L1 " 
 -- ObjectInvocation:markForCodeGen: "L1 " ATd: 
 --  "L1: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "<= L2 " ATd: 
 --  
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OI:args:markForCodgen: "L2 "
 -- OG:markForCodeGen: "L2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L2 " "L2 "true 
 -- not ObjDesc:  "L1 <= L2 "  IS.isEmpty:  true 
 -- markItem: "leave(matchEq) " ObjectGenerator 
 -- not ObjDesc:  
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --   IS.isEmpty:  true 
 -- markItem: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "true 
 -- OG:markSuper: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- Invocation:markForCodeGen: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- OG:markForCodeGen: "(L2 = 0) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(L2 = 0) " "(L2 = 0) "true 
 -- OG:markSuper: "(L2 = 0) " 
 -- Invocation:markForCodeGen: "(L2 = 0) " 
 -- Invocation:markForCodeGen: "L2 = 0 " 
 -- BinaryExp:markForCodeGen: "L2 = 0 "
 -- Invocation:markForCodeGen: "L2 " 
 -- ObjectInvocation:markForCodeGen: "L2 " ATd: 
 --  "L2: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "= 0 " ATd: 
 --  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:args:markForCodgen: "0 "
 -- OG:markForCodeGen: "0 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "0 " "0 "true 
 -- OG:markSuper: "0 " 
 -- Invocation:markForCodeGen: "0 " 
 -- not ObjDesc:  "0 "  IS.isEmpty:  true 
 -- not ObjDesc:  "(L2 = 0) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  Beq := false
 --     leave(matchEq)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  Beq := false
 --     leave(matchEq)
 --  
 -- OG:Qalloc: 
 --  Beq := false
 --     leave(matchEq)
 --  qDescno:  92 
 -- ObjTmpStack:add: 
 --  Beq := false
 --     leave(matchEq)
 --  
 -- items:markForCodeGen: 
 --  Beq := false
 --  leave(matchEq)
 --  
 -- markItem: "Beq := false " Assign 
 -- Invocation:markForCodeGen: "Beq " 
 -- ObjectInvocation:markForCodeGen: "Beq " ATd: 
 --  "out Beq: var boolean " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "false " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "false " "false "false 
 -- OG:markSuper: "false " 
 -- Invocation:markForCodeGen: "false " 
 -- ObjectInvocation:markForCodeGen: "false " ATd: 
 --  
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "false "  IS.isEmpty:  true 
 -- markItem: "leave(matchEq) " ObjectGenerator 
 -- not ObjDesc:  
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --   IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then 
 -- OG:Qalloc: 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then qDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  " "  marked:  true 
 --  loop: do 
 --     inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "loop "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 93 IS.newDescNo: 93 objSize: 0 1: 1 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then 
 -- Items:Qalloc:objSize: 0  newDescNo: 93 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- OG:Qalloc: "inx + 1 " qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  "inx + 1 "  marked:  false "
 --  inx := inx + 1 " super:  "inx + 1 " 
 -- Invocation:Qalloc: "inx + 1 " 
 -- BinaryExp:Qalloc: "inx + 1 "
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "+ 1 "
 -- name: "+ "
 -- Arguments "1 "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false "1 " 
 --  super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  60 3 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx + 1 " 
 --  super:  "inx + 1 " 
 --  E:  "inx + 1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx + 1 " 
 -- Invocation:Qalloc: "c1 " 
 -- ObjectInvocation:Qalloc: "c1 "
 -- name: "c1 "
 -- Arguments " "
 -- OG:Qalloc: "get[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "get[inx] "  marked:  false "
 --  c1 := get[inx] " super:  "get[inx] " 
 -- Invocation:Qalloc: "get[inx] " 
 -- ObjectInvocation:Qalloc: "get[inx] "
 -- name: "get "
 -- Arguments "get[inx] "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  get[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx] " 
 --  super:  "get[inx] " 
 --  E:  "get[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx] " 
 -- Invocation:Qalloc: "c2 " 
 -- ObjectInvocation:Qalloc: "c2 "
 -- name: "c2 "
 -- Arguments " "
 -- OG:Qalloc: "Veq.get[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "Veq.get[inx] "  marked:  false "
 --  c2 := Veq.get[inx] " super:  "Veq.get[inx] " 
 -- Invocation:Qalloc: "Veq.get[inx] " 
 -- ObjectInvocation:Qalloc: "Veq "
 -- name: "Veq "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "get[inx] "
 -- name: "get "
 -- Arguments "get[inx] "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  get[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.get[inx] " 
 --  super:  "Veq.get[inx] " 
 --  E:  "get[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.get[inx] " 
 -- OG:Qalloc: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --   marked:  false 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then super:  
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- Invocation:Qalloc: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- OG:Qalloc: "(c1 = c2) " qDescno:  0 
 -- OG:Qalloc:A:  "= " super:  "(c1 = c2) "  marked:  false 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  super:  "(c1 = c2) " 
 -- Invocation:Qalloc: "(c1 = c2) " 
 -- Invocation:Qalloc: "c1 = c2 " 
 -- BinaryExp:Qalloc: "c1 = c2 "
 -- Invocation:Qalloc: "c1 " 
 -- ObjectInvocation:Qalloc: "c1 "
 -- name: "c1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "= c2 "
 -- name: "= "
 -- Arguments "c2 "
 -- OG:Qalloc: "c2 " qDescno:  0 
 -- OG:Qalloc:A:  "char " super:  "c2 "  marked:  false "c2 " 
 --  super:  "c2 " 
 -- Invocation:Qalloc: "c2 " 
 -- ObjectInvocation:Qalloc: "c2 "
 -- name: "c2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- OG:super:  "c2: var char " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2 " 
 --  super:  "c2 " 
 --  E:  "c2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 3 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- OG:super:  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 = c2) " 
 --  super:  "(c1 = c2) " 
 --  E:  "(c1 = c2) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 = c2) " 
 -- OG:Qalloc: 
 --  if (inx < L) :then 
 --        restart(loop)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  if (inx < L) :then 
 --        restart(loop)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 94 IS.newDescNo: 94 objSize: 0 1: 1 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 94 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (inx < L) :then 
 --     restart(loop)
 --   marked:  false 
 --  if (inx < L) :then 
 --     restart(loop)
 --  super:  
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- Invocation:Qalloc: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- OG:Qalloc: "(inx < L) " qDescno:  0 
 -- OG:Qalloc:A:  "< " super:  "(inx < L) "  marked:  false 
 --  if (inx < L) :then 
 --     restart(loop)
 --  super:  "(inx < L) " 
 -- Invocation:Qalloc: "(inx < L) " 
 -- Invocation:Qalloc: "inx < L " 
 -- BinaryExp:Qalloc: "inx < L "
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "< L "
 -- name: "< "
 -- Arguments "L "
 -- OG:Qalloc: "L " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L "  marked:  false "L " 
 --  super:  "L " 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L " 
 --  super:  "L " 
 --  E:  "L "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  86 3 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:super:  
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(inx < L) " 
 --  super:  "(inx < L) " 
 --  E:  "(inx < L) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(inx < L) " 
 -- OG:Qalloc: "restart(loop) " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (inx < L) :then 
 --     restart(loop)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop) " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 95 IS.newDescNo: 95 objSize: 0 1: 1 "
 --  restart(loop) " 
 -- Items:Qalloc:objSize: 0  newDescNo: 95 "restart(loop) " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "restart(loop) " qDescno:  0 
 -- OG:Qalloc:A:  "restart " super:  "restart(loop) "  marked:  
 --  false "restart(loop) " super:  "restart(loop) " 
 -- Invocation:Qalloc: "restart(loop) " 
 -- ObjectInvocation:Qalloc: "restart(loop) "
 -- name: "restart "
 -- Arguments "restart(loop) "
 -- OG:Qalloc: "loop " qDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  "loop "  marked:  false "
 --  restart(loop) " super:  "loop " 
 -- Invocation:Qalloc: "loop " 
 -- ObjectInvocation:Qalloc: "loop "
 -- name: "loop "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  93 1 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then 
 -- OG:super:  
 --  loop: do 
 --     inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop " 
 --  super:  "loop " 
 --  E:  "loop "
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  61 2 "
 --  %basic 102 " 
 -- OG:super:  
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop) " 
 --  super:  "restart(loop) " 
 --  E:  "restart(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 95 "restart(loop) " 
 -- IS.newDescNo: 95 IS.objSize: 1 "restart(loop) " 
 -- OG:Qalloc:end: IS.newDescNo:  95 "restart(loop) " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 --  super:  
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 --  E:  "if (inx < L) :then 
 --     restart(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- Items:Qalloc:END:objSize: 1  newDescNo: 94 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- IS.newDescNo: 94 IS.objSize: 1 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  94 
 --  if (inx < L) :then 
 --        restart(loop)
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 --  super:  
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 --  E:  "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- Items:Qalloc:END:objSize: 1  newDescNo: 93 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then 
 -- IS.newDescNo: 93 IS.objSize: 1 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then 
 -- OG:Qalloc:end: IS.newDescNo:  93 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then 
 -- ObjTmpStack:add: "loop ": 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then 
 -- items:markForCodeGen: 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then 
 -- markItem: "inx := inx + 1 " Assign 
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "inx + 1 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "inx + 1 " "inx + 1 "true 
 -- OG:markSuper: "inx + 1 " 
 -- Invocation:markForCodeGen: "inx + 1 " 
 -- BinaryExp:markForCodeGen: "inx + 1 "
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "+ 1 " ATd: 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "1 "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- not ObjDesc:  "inx + 1 "  IS.isEmpty:  true 
 -- markItem: "c1 := get[inx] " Assign 
 -- Invocation:markForCodeGen: "c1 " 
 -- ObjectInvocation:markForCodeGen: "c1 " ATd: 
 --  "c1: var char " 
 -- OI:args:markForCodgen: " "
 -- markItem: "c2 := Veq.get[inx] " Assign 
 -- Invocation:markForCodeGen: "c2 " 
 -- ObjectInvocation:markForCodeGen: "c2 " ATd: 
 --  "c2: var char " 
 -- OI:args:markForCodgen: " "
 -- markItem: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  "if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 --  true 
 -- OG:markSuper: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- Invocation:markForCodeGen: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- OG:markForCodeGen: "(c1 = c2) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(c1 = c2) " "(c1 = c2) "true 
 -- OG:markSuper: "(c1 = c2) " 
 -- Invocation:markForCodeGen: "(c1 = c2) " 
 -- Invocation:markForCodeGen: "c1 = c2 " 
 -- BinaryExp:markForCodeGen: "c1 = c2 "
 -- Invocation:markForCodeGen: "c1 " 
 -- ObjectInvocation:markForCodeGen: "c1 " ATd: 
 --  "c1: var char " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "= c2 " ATd: 
 --  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:args:markForCodgen: "c2 "
 -- OG:markForCodeGen: "c2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "c2 " "c2 "true 
 -- not ObjDesc:  "(c1 = c2) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  if (inx < L) :then 
 --        restart(loop)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  if (inx < L) :then 
 --        restart(loop)
 --  
 -- OG:Qalloc: 
 --  if (inx < L) :then 
 --        restart(loop)
 --  qDescno:  94 
 -- ObjTmpStack:add: 
 --  if (inx < L) :then 
 --        restart(loop)
 --  
 -- items:markForCodeGen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- markItem: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (inx < L) :then 
 --     restart(loop)
 --  "if (inx < L) :then 
 --     restart(loop) "true 
 -- OG:markSuper: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- Invocation:markForCodeGen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- OG:markForCodeGen: "(inx < L) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(inx < L) " "(inx < L) "true 
 -- OG:markSuper: "(inx < L) " 
 -- Invocation:markForCodeGen: "(inx < L) " 
 -- Invocation:markForCodeGen: "inx < L " 
 -- BinaryExp:markForCodeGen: "inx < L "
 -- Invocation:markForCodeGen: "inx " 
 -- ObjectInvocation:markForCodeGen: "inx " ATd: 
 --  "inx: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "< L " ATd: 
 --  
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OI:args:markForCodgen: "L "
 -- OG:markForCodeGen: "L " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L " "L "true 
 -- not ObjDesc:  "(inx < L) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "restart(loop) " isObjectDesc: true 
 --   hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "restart(loop) " 
 -- OG:Qalloc: "restart(loop) " qDescno:  95 
 -- ObjTmpStack:add: "restart(loop) " 
 -- items:markForCodeGen: "restart(loop) " 
 -- markItem: "restart(loop) " ObjectGenerator 
 -- not ObjDesc:  
 --  if (inx < L) :then 
 --     restart(loop)
 --   IS.isEmpty:  true 
 -- not ObjDesc:  
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --   IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 --     :else isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 --     :else 
 -- OG:Qalloc: 
 --  if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 --     :else qDescno:  0 
 -- OG:Qalloc:A:  "doit " super:  " "  marked:  true 
 --  doit: do 
 --     if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 --     :else 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "doit "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 96 IS.newDescNo: 96 objSize: 0 1: 1 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- Items:Qalloc:objSize: 0  newDescNo: 96 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else  marked:  false 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else super:  
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- Invocation:Qalloc: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- OG:Qalloc: "(c1 = c2) " qDescno:  0 
 -- OG:Qalloc:A:  "= " super:  "(c1 = c2) "  marked:  false 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else super:  "(c1 = c2) " 
 -- Invocation:Qalloc: "(c1 = c2) " 
 -- Invocation:Qalloc: "c1 = c2 " 
 -- BinaryExp:Qalloc: "c1 = c2 "
 -- Invocation:Qalloc: "c1 " 
 -- ObjectInvocation:Qalloc: "c1 "
 -- name: "c1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "= c2 "
 -- name: "= "
 -- Arguments "c2 "
 -- OG:Qalloc: "c2 " qDescno:  0 
 -- OG:Qalloc:A:  "char " super:  "c2 "  marked:  false "c2 " 
 --  super:  "c2 " 
 -- Invocation:Qalloc: "c2 " 
 -- ObjectInvocation:Qalloc: "c2 "
 -- name: "c2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- OG:super:  "c2: var char " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2 " 
 --  super:  "c2 " 
 --  E:  "c2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 3 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- OG:super:  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 = c2) " 
 --  super:  "(c1 = c2) " 
 --  E:  "(c1 = c2) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 = c2) " 
 -- OG:Qalloc: 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 97 IS.newDescNo: 97 objSize: 0 1: 1 
 --  -- we have inx = LBeq := L1 <= L2
 --  leave(matchEq)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 97 
 --  -- we have inx = LBeq := L1 <= L2
 --  leave(matchEq)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq " 
 -- ObjectInvocation:Qalloc: "Beq "
 -- name: "Beq "
 -- Arguments " "
 -- OG:Qalloc: "L1 <= L2 " qDescno:  0 
 -- OG:Qalloc:A:  "<= " super:  "L1 <= L2 "  marked:  false "
 --  Beq := L1 <= L2 " super:  "L1 <= L2 " 
 -- Invocation:Qalloc: "L1 <= L2 " 
 -- BinaryExp:Qalloc: "L1 <= L2 "
 -- Invocation:Qalloc: "L1 " 
 -- ObjectInvocation:Qalloc: "L1 "
 -- name: "L1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "<= L2 "
 -- name: "<= "
 -- Arguments "L2 "
 -- OG:Qalloc: "L2 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L2 "  marked:  false "L2 " 
 --  super:  "L2 " 
 -- Invocation:Qalloc: "L2 " 
 -- ObjectInvocation:Qalloc: "L2 "
 -- name: "L2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L2: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2 " 
 --  super:  "L2 " 
 --  E:  "L2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  58 3 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- OG:super:  
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 <= L2 " 
 --  super:  "L1 <= L2 " 
 --  E:  "L1 <= L2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 <= L2 " 
 -- OG:Qalloc: "leave(matchEq) " qDescno:  0 
 -- OG:Qalloc:A:  "leave " super:  "leave(matchEq) "  marked:  false 
 --  -- we have inx = LBeq := L1 <= L2
 --  leave(matchEq)
 --  super:  "leave(matchEq) " 
 -- Invocation:Qalloc: "leave(matchEq) " 
 -- ObjectInvocation:Qalloc: "leave(matchEq) "
 -- name: "leave "
 -- Arguments "leave(matchEq) "
 -- OG:Qalloc: "matchEq " qDescno:  0 
 -- OG:Qalloc:A:  "matchEq " super:  "matchEq "  marked:  false "
 --  leave(matchEq) " super:  "matchEq " 
 -- Invocation:Qalloc: "matchEq " 
 -- ObjectInvocation:Qalloc: "matchEq "
 -- name: "matchEq "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  89 4 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- OG:super:  
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq " 
 --  super:  "matchEq " 
 --  E:  "matchEq "
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 "
 --  %basic 103 " 
 -- OG:super:  
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq) " 
 --  super:  "leave(matchEq) " 
 --  E:  "leave(matchEq) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 97 
 --  -- we have inx = LBeq := L1 <= L2
 --  leave(matchEq)
 --  
 -- IS.newDescNo: 97 IS.objSize: 1 
 --  -- we have inx = LBeq := L1 <= L2
 --  leave(matchEq)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  97 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:Qalloc: 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 98 IS.newDescNo: 98 objSize: 0 1: 1 
 --  Beq := c1 < c2
 --  leave(matchEq)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 98 
 --  Beq := c1 < c2
 --  leave(matchEq)
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq " 
 -- ObjectInvocation:Qalloc: "Beq "
 -- name: "Beq "
 -- Arguments " "
 -- OG:Qalloc: "c1 < c2 " qDescno:  0 
 -- OG:Qalloc:A:  "< " super:  "c1 < c2 "  marked:  false "
 --  Beq := c1 < c2 " super:  "c1 < c2 " 
 -- Invocation:Qalloc: "c1 < c2 " 
 -- BinaryExp:Qalloc: "c1 < c2 "
 -- Invocation:Qalloc: "c1 " 
 -- ObjectInvocation:Qalloc: "c1 "
 -- name: "c1 "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "< c2 "
 -- name: "< "
 -- Arguments "c2 "
 -- OG:Qalloc: "c2 " qDescno:  0 
 -- OG:Qalloc:A:  "char " super:  "c2 "  marked:  false "c2 " 
 --  super:  "c2 " 
 -- Invocation:Qalloc: "c2 " 
 -- ObjectInvocation:Qalloc: "c2 "
 -- name: "c2 "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- OG:super:  "c2: var char " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2 " 
 --  super:  "c2 " 
 --  E:  "c2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- OG:Qalloc: 
 --  %basic 51
 --     in V: var char
 --     out B: var boolean
 --  qDescno:  0 
 -- OG:Qalloc:A:  "< " super:  " "  marked:  false 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "< "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 99 IS.newDescNo: 99 objSize: 0 1: 1 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 99 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 99 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  
 -- IS.newDescNo: 99 IS.objSize: 3 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  
 -- OG:Qalloc:end: IS.newDescNo:  99 
 --  %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- OG:super:  
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c1 < c2 " 
 --  super:  "c1 < c2 " 
 --  E:  "c1 < c2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "c1 < c2 " 
 -- OG:Qalloc: "leave(matchEq) " qDescno:  0 
 -- OG:Qalloc:A:  "leave " super:  "leave(matchEq) "  marked:  false 
 --  Beq := c1 < c2
 --  leave(matchEq)
 --  super:  "leave(matchEq) " 
 -- Invocation:Qalloc: "leave(matchEq) " 
 -- ObjectInvocation:Qalloc: "leave(matchEq) "
 -- name: "leave "
 -- Arguments "leave(matchEq) "
 -- OG:Qalloc: "matchEq " qDescno:  0 
 -- OG:Qalloc:A:  "matchEq " super:  "matchEq "  marked:  false "
 --  leave(matchEq) " super:  "matchEq " 
 -- Invocation:Qalloc: "matchEq " 
 -- ObjectInvocation:Qalloc: "matchEq "
 -- name: "matchEq "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  89 4 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- OG:super:  
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq " 
 --  super:  "matchEq " 
 --  E:  "matchEq "
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 "
 --  %basic 103 " 
 -- OG:super:  
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq) " 
 --  super:  "leave(matchEq) " 
 --  E:  "leave(matchEq) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 98 
 --  Beq := c1 < c2
 --  leave(matchEq)
 --  
 -- IS.newDescNo: 98 IS.objSize: 1 
 --  Beq := c1 < c2
 --  leave(matchEq)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  98 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --  super:  
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --  E:  "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 96 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- IS.newDescNo: 96 IS.objSize: 1 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- OG:Qalloc:end: IS.newDescNo:  96 
 --  if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 --     :else 
 -- ObjTmpStack:add: "doit ": 
 --  if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 --     :else 
 -- items:markForCodeGen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- markItem: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 -- \
 --      leave(matchEq) "true 
 -- OG:markSuper: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- Invocation:markForCodeGen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- OG:markForCodeGen: "(c1 = c2) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(c1 = c2) " "(c1 = c2) "true 
 -- OG:markSuper: "(c1 = c2) " 
 -- Invocation:markForCodeGen: "(c1 = c2) " 
 -- Invocation:markForCodeGen: "c1 = c2 " 
 -- BinaryExp:markForCodeGen: "c1 = c2 "
 -- Invocation:markForCodeGen: "c1 " 
 -- ObjectInvocation:markForCodeGen: "c1 " ATd: 
 --  "c1: var char " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "= c2 " ATd: 
 --  
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:args:markForCodgen: "c2 "
 -- OG:markForCodeGen: "c2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "c2 " "c2 "true 
 -- not ObjDesc:  "(c1 = c2) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:Qalloc: 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  qDescno:  97 
 -- ObjTmpStack:add: 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  
 -- items:markForCodeGen: 
 --  -- we have inx = LBeq := L1 <= L2
 --  leave(matchEq)
 --  
 -- markItem: "Beq := L1 <= L2 " Assign 
 -- Invocation:markForCodeGen: "Beq " 
 -- ObjectInvocation:markForCodeGen: "Beq " ATd: 
 --  "out Beq: var boolean " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L1 <= L2 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L1 <= L2 " "L1 <= L2 "true 
 -- OG:markSuper: "L1 <= L2 " 
 -- Invocation:markForCodeGen: "L1 <= L2 " 
 -- BinaryExp:markForCodeGen: "L1 <= L2 "
 -- Invocation:markForCodeGen: "L1 " 
 -- ObjectInvocation:markForCodeGen: "L1 " ATd: 
 --  "L1: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "<= L2 " ATd: 
 --  
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OI:args:markForCodgen: "L2 "
 -- OG:markForCodeGen: "L2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L2 " "L2 "true 
 -- not ObjDesc:  "L1 <= L2 "  IS.isEmpty:  true 
 -- markItem: "leave(matchEq) " ObjectGenerator 
 -- OG:markForCodeGen: 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  
 -- OG:Qalloc: 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  qDescno:  98 
 -- ObjTmpStack:add: 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  
 -- items:markForCodeGen: 
 --  Beq := c1 < c2
 --  leave(matchEq)
 --  
 -- markItem: "Beq := c1 < c2 " Assign 
 -- Invocation:markForCodeGen: "Beq " 
 -- ObjectInvocation:markForCodeGen: "Beq " ATd: 
 --  "out Beq: var boolean " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "c1 < c2 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "c1 < c2 " "c1 < c2 "true 
 -- OG:markSuper: "c1 < c2 " 
 -- Invocation:markForCodeGen: "c1 < c2 " 
 -- BinaryExp:markForCodeGen: "c1 < c2 "
 -- Invocation:markForCodeGen: "c1 " 
 -- ObjectInvocation:markForCodeGen: "c1 " ATd: 
 --  "c1: var char " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "< c2 " ATd: 
 --  
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- Pattern:markForCodeGen: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "c2 "
 -- OG:markForCodeGen: "c2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "c2 " "c2 "true 
 -- not ObjDesc:  "c1 < c2 "  IS.isEmpty:  true 
 -- markItem: "leave(matchEq) " ObjectGenerator 
 -- not ObjDesc:  
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "matchEq "  IS.isEmpty:  true 
 -- not ObjDesc:  "LIB.StringLib.String "  IS.isEmpty:  true 
 -- markItem: "%$E ")" " Property 
 -- OG:markForCodeGen: "inner(puttext) " isObjectDesc: true 
 --   hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "inner(puttext) " 
 -- OG:Qalloc: "inner(puttext) " qDescno:  0 
 -- OG:Qalloc:A:  "puttext " super:  " "  marked:  true 
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(puttext) " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "puttext "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 100 IS.newDescNo: 100 objSize: 0 1: 1 "
 --  inner(puttext) " 
 -- Items:Qalloc:objSize: 0  newDescNo: 100 "inner(puttext) " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 
 --  %$B "("
 --  T: var LIB.StringLib.String
 --  %$E ")"
 --  
 -- dataitem:qalloc: "T "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "T: var LIB.StringLib.String " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 
 --  %$B "("
 --  T: var LIB.StringLib.String
 --  %$E ")"
 --  
 -- OG:Qalloc: "inner(puttext) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(puttext) "  marked:  false "
 --  inner(puttext) " super:  "inner(puttext) " 
 -- Invocation:Qalloc: "inner(puttext) " 
 -- ObjectInvocation:Qalloc: "inner(puttext) "
 -- name: "inner "
 -- Arguments "inner(puttext) "
 -- OG:Qalloc: "puttext " qDescno:  0 
 -- OG:Qalloc:A:  "puttext " super:  "puttext "  marked:  false "
 --  inner(puttext) " super:  "puttext " 
 -- Invocation:Qalloc: "puttext " 
 -- ObjectInvocation:Qalloc: "puttext "
 -- name: "puttext "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  100 2 "
 --  inner(puttext) " 
 -- OG:super:  
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "puttext " 
 --  super:  "puttext " 
 --  E:  "puttext "
 -- OG:Qalloc:end: IS.newDescNo:  0 "puttext " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(puttext) " 
 --  super:  "inner(puttext) " 
 --  E:  "inner(puttext) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(puttext) " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 100 "inner(puttext) " 
 -- IS.newDescNo: 100 IS.objSize: 2 "inner(puttext) " 
 -- OG:Qalloc:end: IS.newDescNo:  100 "inner(puttext) " 
 -- ObjTmpStack:add: "puttext(T: var LIB.StringLib.String) ": "
 --  inner(puttext) " 
 -- items:markForCodeGen: "inner(puttext) " 
 -- markItem: "inner(puttext) " ObjectGenerator 
 -- Pattern:markForCodeGen: 
 --  putint(V: var Integer):< 
 --     inner(putint)
 --  
 -- items:markForCodeGen: 
 --  %$B "("
 --  V: var Integer
 --  %$E ")"
 --  
 -- markItem: "%$B "(" " Property 
 -- DataItem:markForCodeGen: "V ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Integer " "Integer "true 
 -- OG:markSuper: "Integer " 
 -- Invocation:markForCodeGen: "Integer " 
 -- ObjectInvocation:markForCodeGen: "Integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Integer "  IS.isEmpty:  true 
 -- markItem: "%$E ")" " Property 
 -- OG:markForCodeGen: "inner(putint) " isObjectDesc: true 
 --   hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "inner(putint) " 
 -- OG:Qalloc: "inner(putint) " qDescno:  0 
 -- OG:Qalloc:A:  "putint " super:  " "  marked:  true 
 --  putint(V: var Integer):< 
 --     inner(putint)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(putint) " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "putint "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 101 IS.newDescNo: 101 objSize: 0 1: 1 "
 --  inner(putint) " 
 -- Items:Qalloc:objSize: 0  newDescNo: 101 "inner(putint) " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 
 --  %$B "("
 --  V: var Integer
 --  %$E ")"
 --  
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 
 --  %$B "("
 --  V: var Integer
 --  %$E ")"
 --  
 -- OG:Qalloc: "inner(putint) " qDescno:  0 
 -- OG:Qalloc:A:  "inner " super:  "inner(putint) "  marked:  false "
 --  inner(putint) " super:  "inner(putint) " 
 -- Invocation:Qalloc: "inner(putint) " 
 -- ObjectInvocation:Qalloc: "inner(putint) "
 -- name: "inner "
 -- Arguments "inner(putint) "
 -- OG:Qalloc: "putint " qDescno:  0 
 -- OG:Qalloc:A:  "putint " super:  "putint "  marked:  false "
 --  inner(putint) " super:  "putint " 
 -- Invocation:Qalloc: "putint " 
 -- ObjectInvocation:Qalloc: "putint "
 -- name: "putint "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  101 2 "
 --  inner(putint) " 
 -- OG:super:  
 --  putint(V: var Integer):< 
 --     inner(putint)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putint " 
 --  super:  "putint " 
 --  E:  "putint "
 -- OG:Qalloc:end: IS.newDescNo:  0 "putint " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- OG:super:  
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(putint) " 
 --  super:  "inner(putint) " 
 --  E:  "inner(putint) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(putint) " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 101 "inner(putint) " 
 -- IS.newDescNo: 101 IS.objSize: 2 "inner(putint) " 
 -- OG:Qalloc:end: IS.newDescNo:  101 "inner(putint) " 
 -- ObjTmpStack:add: "putint(V: var Integer) ": "inner(putint) " 
 -- items:markForCodeGen: "inner(putint) " 
 -- markItem: "inner(putint) " ObjectGenerator 
 -- not ObjDesc:  "ConsoleIF "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 --     --AbstractExisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 --     --AbstractEx
 -- OG:Qalloc: 
 --  %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 --     --AbstractExqDescno:  0 
 -- OG:Qalloc:A:  "workspace " super:  " "  marked:  true 
 --  workspace: obj 
 --     %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundarysuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 --     --AbstractEx
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "workspace "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 102 IS.newDescNo: 102 objSize: 0 1: 1 
 --  %id "workspace"
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --  %domain_boundary
 --  --AbstractEx
 -- Items:Qalloc:objSize: 0  newDescNo: 102 
 --  %id "workspace"
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --  %domain_boundary
 --  --AbstractEx
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- ModuleItem:Qalloc: 
 --  --AbstractEx
 --  
 -- ModuleItem:Qalloc: 
 --  --AccessEx
 --  
 -- ModuleItem:Qalloc: 
 --  --ApplyPred
 --  
 -- ModuleItem:Qalloc: 
 --  --ArduinoEx
 --  
 -- ModuleItem:Qalloc: 
 --  --ArmBasicSys
 --  
 -- ModuleItem:Qalloc: 
 --  --ArmLed
 --  
 -- ModuleItem:Qalloc: 
 --  --ArmMultiCore
 --  
 -- ModuleItem:Qalloc: 
 --  --CAStest
 --  
 -- ModuleItem:Qalloc: 
 --  --CAStestCore
 --  
 -- ModuleItem:Qalloc: 
 --  --CoroutineEx
 --  
 -- ModuleItem:Qalloc: 
 --  --CppEx
 --  
 -- ModuleItem:Qalloc: 
 --  --DumpObjEx
 --  
 -- ModuleItem:Qalloc: 
 --  --Errors
 --  
 -- ModuleItem:Qalloc: 
 --  --FoolishUnitEx
 --  
 -- ModuleItem:Qalloc: 
 --  --ForkGC
 --  
 -- ModuleItem:Qalloc: 
 --  --FuncVirtExVclass
 --  
 -- ModuleItem:Qalloc: 
 --  --FunctionalVirtEx
 --  
 -- ModuleItem:Qalloc: 
 --  --Jurgen
 --  
 -- ModuleItem:Qalloc: 
 --  --LLVMex
 --  
 -- ModuleItem:Qalloc: 
 --  --ListLiteralEx
 --  
 -- ModuleItem:Qalloc: 
 --  --LockTestCore
 --  
 -- ModuleItem:Qalloc: 
 --  --MVRsystem
 --  
 -- ModuleItem:Qalloc: 
 --  --MapEx
 --  
 -- ModuleItem:Qalloc: 
 --  --MiniVal
 --  
 -- ModuleItem:Qalloc: 
 --  --NewInner
 --  
 -- ModuleItem:Qalloc: 
 --  --NewSyntax
 --  
 -- ModuleItem:Qalloc: 
 --  --NoneEx
 --  
 -- ModuleItem:Qalloc: 
 --  --ObjectAndValues
 --  
 -- ModuleItem:Qalloc: 
 --  --ReadersSingleWriter
 --  
 -- ModuleItem:Qalloc: 
 --  --RemoteSuperVC
 --  
 -- ModuleItem:Qalloc: 
 --  --Restrictions
 --  
 -- ModuleItem:Qalloc: 
 --  --SlideEx
 --  
 -- ModuleItem:Qalloc: 
 --  --Sub1
 --  
 -- ModuleItem:Qalloc: 
 --  --TST
 --  
 -- ModuleItem:Qalloc: 
 --  --TstBreak
 --  
 -- ModuleItem:Qalloc: 
 --  --UnitIssues
 --  
 -- ModuleItem:Qalloc: 
 --  --UnitKindEx
 --  
 -- ModuleItem:Qalloc: 
 --  --UnitTest
 --  
 -- ModuleItem:Qalloc: 
 --  --ValueArray
 --  
 -- ModuleItem:Qalloc: 
 --  --ValueConv
 --  
 -- ModuleItem:Qalloc: 
 --  --ValueEx
 --  
 -- ModuleItem:Qalloc: 
 --  --ValueItemEx
 --  
 -- ModuleItem:Qalloc: 
 --  --VirtError
 --  
 -- ModuleItem:Qalloc: 
 --  --VirtualEx
 --  
 -- ModuleItem:Qalloc: 
 --  --Visibility
 --  
 -- ModuleItem:Qalloc: 
 --  --demo
 --  
 -- ModuleItem:Qalloc: 
 --  --embodyex
 --  
 -- ModuleItem:Qalloc: 
 --  --hello
 --  
 -- ModuleItem:Qalloc: 
 --  --qbetaCmp
 --  
 -- ModuleItem:Qalloc: 
 --  --test
 --  
 -- ModuleItem:Qalloc: 
 --  --tiny
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyA
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyAA
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyAB
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyAC
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyB
 --  
 -- Qalloc:module: tinyB 
 -- Module:alloc:off: 2 
 --  
 --  tinyB: obj 
 --     %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- ModuleItem:Qalloc: 
 --  --tinyC
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyD
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyE
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyF
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyG
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyH
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyI
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyJ
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyP
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyQ
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyR
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyS
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyV
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyW
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyX
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyY
 --  
 -- ModuleItem:Qalloc: 
 --  --tinyZ
 --  
 -- Items:Qalloc:END:objSize: 2  newDescNo: 102 
 --  %id "workspace"
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --  %domain_boundary
 --  --AbstractEx
 -- IS.newDescNo: 102 IS.objSize: 2 
 --  %id "workspace"
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --  %domain_boundary
 --  --AbstractEx
 -- OG:Qalloc:end: IS.newDescNo:  102 
 --  %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 --     --AbstractEx
 -- ObjTmpStack:add: "workspace ": 
 --  %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 --     --AbstractEx
 -- items:markForCodeGen: 
 --  %id "workspace"
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --  %domain_boundary
 --  --AbstractEx
 -- markItem: "%id "workspace" " Property 
 -- markItem: "
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib " Property 
 -- markItem: "%domain_boundary " Property 
 -- OG:markForCodeGen: 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeterisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeter
 -- OG:Qalloc: 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeterqDescno:  0 
 -- OG:Qalloc:A:  "tinyB " super:  " "  marked:  true 
 --  tinyB: obj 
 --     %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integersuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeter
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "tinyB "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 103 IS.newDescNo: 103 objSize: 0 1: 1 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- Items:Qalloc:objSize: 0  newDescNo: 103 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "F "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "I "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- dataitem:qalloc: "A "isValue: true  isPrimitive: false 
 --   isValObj:  true  isBasicValue: false 
 -- new_size:A: true   
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- newDescNo: 68 
 -- diSize: 2 IT.qSize: 6 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 " " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- OG:Qalloc: "3 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "3 "  marked:  false "F := 3 " 
 --  super:  "3 " 
 -- Invocation:Qalloc: "3 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "3 " 
 --  super:  "3 " 
 --  E:  "3 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "3 " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- OG:Qalloc: "4.87 " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "4.87 "  marked:  false "
 --  I := 4.87 " super:  "4.87 " 
 -- Invocation:Qalloc: "4.87 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "4.87 " 
 --  super:  "4.87 " 
 --  E:  "4.87 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "4.87 " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- OG:Qalloc: "F * 12 " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "F * 12 "  marked:  false "
 --  F := F * 12 " super:  "F * 12 " 
 -- Invocation:Qalloc: "F * 12 " 
 -- BinaryExp:Qalloc: "F * 12 "
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* 12 "
 -- name: "* "
 -- Arguments "12 "
 -- OG:Qalloc: "12 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "12 "  marked:  false "12 " 
 --  super:  "12 " 
 -- Invocation:Qalloc: "12 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "12 " 
 --  super:  "12 " 
 --  E:  "12 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "12 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 5 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F * 12 " 
 --  super:  "F * 12 " 
 --  E:  "F * 12 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F * 12 " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- OG:Qalloc: "F * I " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "F * I "  marked:  false "
 --  F := F * I " super:  "F * I " 
 -- Invocation:Qalloc: "F * I " 
 -- BinaryExp:Qalloc: "F * I "
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* I "
 -- name: "* "
 -- Arguments "I "
 -- OG:Qalloc: "I " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "I "  marked:  false "I " 
 --  super:  "I " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "I: var Integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I " 
 --  super:  "I " 
 --  E:  "I "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 5 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F * I " 
 --  super:  "F * I " 
 --  E:  "F * I "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F * I " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- OG:Qalloc: "10 * F " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "10 * F "  marked:  false "
 --  F := 10 * F " super:  "10 * F " 
 -- Invocation:Qalloc: "10 * F " 
 -- BinaryExp:Qalloc: "10 * F "
 -- Invocation:Qalloc: "10 " 
 -- ObjectInvocation:Qalloc: "* F "
 -- name: "* "
 -- Arguments "F "
 -- OG:Qalloc: "F " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "F "  marked:  false "F " super:  "
 --  F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "F: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F " 
 --  super:  "F " 
 --  E:  "F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 66
 --     in V: var integer
 --     out R: var integer
 --  qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  " "  marked:  false 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "* "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 104 IS.newDescNo: 104 objSize: 0 1: 1 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 104 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "R "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 104 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- IS.newDescNo: 104 IS.objSize: 3 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:end: IS.newDescNo:  104 
 --  %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10 * F " 
 --  super:  "10 * F " 
 --  E:  "10 * F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "10 * F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- OG:Qalloc: "I * F " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "I * F "  marked:  false "
 --  F := I * F " super:  "I * F " 
 -- Invocation:Qalloc: "I * F " 
 -- BinaryExp:Qalloc: "I * F "
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* F "
 -- name: "* "
 -- Arguments "F "
 -- OG:Qalloc: "F " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "F "  marked:  false "F " super:  "
 --  F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "F: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F " 
 --  super:  "F " 
 --  E:  "F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  104 3 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I * F " 
 --  super:  "I * F " 
 --  E:  "I * F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I * F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- OG:Qalloc: "I * I " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "I * I "  marked:  false "
 --  F := I * I " super:  "I * I " 
 -- Invocation:Qalloc: "I * I " 
 -- BinaryExp:Qalloc: "I * I "
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* I "
 -- name: "* "
 -- Arguments "I "
 -- OG:Qalloc: "I " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "I "  marked:  false "I " 
 --  super:  "I " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "I: var Integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I " 
 --  super:  "I " 
 --  E:  "I "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  104 3 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I * I " 
 --  super:  "I * I " 
 --  E:  "I * I "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I * I " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- OG:Qalloc: "I * 11.11 " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "I * 11.11 "  marked:  false "
 --  I := I * 11.11 " super:  "I * 11.11 " 
 -- Invocation:Qalloc: "I * 11.11 " 
 -- BinaryExp:Qalloc: "I * 11.11 "
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* 11.11 "
 -- name: "* "
 -- Arguments "11.11 "
 -- OG:Qalloc: "11.11 " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "11.11 "  marked:  false "11.11 " 
 --  super:  "11.11 " 
 -- Invocation:Qalloc: "11.11 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "11.11 " 
 --  super:  "11.11 " 
 --  E:  "11.11 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "11.11 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  104 3 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I * 11.11 " 
 --  super:  "I * 11.11 " 
 --  E:  "I * 11.11 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I * 11.11 " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- OG:Qalloc: "I * F " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "I * F "  marked:  false "
 --  I := I * F " super:  "I * F " 
 -- Invocation:Qalloc: "I * F " 
 -- BinaryExp:Qalloc: "I * F "
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* F "
 -- name: "* "
 -- Arguments "F "
 -- OG:Qalloc: "F " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "F "  marked:  false "F " super:  "
 --  F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "F: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F " 
 --  super:  "F " 
 --  E:  "F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  104 3 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I * F " 
 --  super:  "I * F " 
 --  E:  "I * F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I * F " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- OG:Qalloc: "12.12 * F " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "12.12 * F "  marked:  false "
 --  I := 12.12 * F " super:  "12.12 * F " 
 -- Invocation:Qalloc: "12.12 * F " 
 -- BinaryExp:Qalloc: "12.12 * F "
 -- Invocation:Qalloc: "12.12 " 
 -- ObjectInvocation:Qalloc: "* F "
 -- name: "* "
 -- Arguments "F "
 -- OG:Qalloc: "F " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "F "  marked:  false "F " super:  "
 --  F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "F: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F " 
 --  super:  "F " 
 --  E:  "F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 5 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "12.12 * F " 
 --  super:  "12.12 * F " 
 --  E:  "12.12 * F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "12.12 * F " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- OG:Qalloc: "I * F " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "I * F "  marked:  false "
 --  I := I * F " super:  "I * F " 
 -- Invocation:Qalloc: "I * F " 
 -- BinaryExp:Qalloc: "I * F "
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* F "
 -- name: "* "
 -- Arguments "F "
 -- OG:Qalloc: "F " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "F "  marked:  false "F " super:  "
 --  F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "F: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F " 
 --  super:  "F " 
 --  E:  "F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  104 3 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I * F " 
 --  super:  "I * F " 
 --  E:  "I * F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I * F " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- OG:Qalloc: "F * F " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "F * F "  marked:  false "
 --  I := F * F " super:  "F * F " 
 -- Invocation:Qalloc: "F * F " 
 -- BinaryExp:Qalloc: "F * F "
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* F "
 -- name: "* "
 -- Arguments "F "
 -- OG:Qalloc: "F " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "F "  marked:  false "F " super:  "
 --  F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "F: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F " 
 --  super:  "F " 
 --  E:  "F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 5 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F * F " 
 --  super:  "F * F " 
 --  E:  "F * F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F * F " 
 -- OG:Qalloc: "putint(I) " qDescno:  0 
 -- OG:Qalloc:A:  "putint " super:  "putint(I) "  marked:  false 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMetersuper:  "putint(I) " 
 -- Invocation:Qalloc: "putint(I) " 
 -- ObjectInvocation:Qalloc: "putint(I) "
 -- name: "putint "
 -- Arguments "putint(I) "
 -- OG:Qalloc: "I " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "I "  marked:  false "
 --  putint(I) " super:  "I " 
 -- Invocation:Qalloc: "I " 
 -- ObjectInvocation:Qalloc: "I "
 -- name: "I "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "I: var Integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "I " 
 --  super:  "I " 
 --  E:  "I "
 -- OG:Qalloc:end: IS.newDescNo:  0 "I " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- OG:Qalloc:SuperAlloc: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 -- OG:Qalloc: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integerqDescno:  0 
 -- OG:Qalloc:A:  "putint " super:  " "  marked:  false 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "putint "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 105 IS.newDescNo: 105 objSize: 0 1: 1 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- Items:Qalloc:objSize: 0  newDescNo: 105 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "D "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "D: obj Indexed(20,#integer) " 
 -- OG:Qalloc: "Indexed(20,#integer) " qDescno:  0 
 -- OG:Qalloc:A:  "D " super:  "Indexed(20,#integer) "  marked:  
 --  false "D: obj Indexed(20,#integer) " super:  "Indexed(20,#integer) " 
 -- Invocation:Qalloc: "Indexed(20,#integer) " 
 -- ObjectInvocation:Qalloc: "Indexed(20,#integer) "
 -- name: "Indexed "
 -- Arguments "(20,#integer) "
 -- OG:Qalloc: "20 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "20 "  marked:  false "
 --  (20,#integer) " super:  "20 " 
 -- Invocation:Qalloc: "20 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "20 " 
 --  super:  "20 " 
 --  E:  "20 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "20 " 
 -- OG:Qalloc: "#integer " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "#integer "  marked:  false "
 --  (20,#integer) " super:  "#integer " 
 -- Invocation:Qalloc: "#integer " 
 -- ObjectInvocation:Qalloc: "#integer "
 -- name: "#integer "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "#integer " 
 --  super:  "#integer " 
 --  E:  "#integer "
 -- OG:Qalloc:end: IS.newDescNo:  0 "#integer " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- OG:Qalloc:SuperAlloc: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- OG:Qalloc: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var IntegerqDescno:  0 
 -- OG:Qalloc:A:  "Indexed " super:  " "  marked:  false 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicsuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "Indexed "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 106 IS.newDescNo: 106 objSize: 0 1: 1 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- Items:Qalloc:objSize: 0  newDescNo: 106 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- dataitem:qalloc: "range "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- Pattern:Qalloc: elm 
 -- Pattern:Qalloc:B: elm 
 -- Pattern:Qalloc: elm$107 
 -- Pattern:Qalloc:B: elm$107 
 -- Pattern:Qalloc: length 
 -- Pattern:Qalloc:B: length 
 -- Pattern:Qalloc: put:at 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc: has 
 -- Pattern:Qalloc:B: has 
 -- Pattern:Qalloc: scan 
 -- Pattern:Qalloc:B: scan 
 -- Pattern:Qalloc: asString 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 106 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- IS.newDescNo: 106 IS.objSize: 1 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- OG:Qalloc:end: IS.newDescNo:  106 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 -- OG:super:  
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "Indexed(20,#integer) " 
 --  super:  "Indexed(20,#integer) " 
 --  E:  "Indexed(20,#integer) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Indexed(20,#integer) " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "L "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "isNeg "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Invocation:Qalloc: "isNeg " 
 -- ObjectInvocation:Qalloc: "isNeg "
 -- name: "isNeg "
 -- Arguments " "
 -- OG:Qalloc: "V < 0 " qDescno:  0 
 -- OG:Qalloc:A:  "< " super:  "V < 0 "  marked:  false "
 --  isNeg := V < 0 " super:  "V < 0 " 
 -- Invocation:Qalloc: "V < 0 " 
 -- BinaryExp:Qalloc: "V < 0 "
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "< 0 "
 -- name: "< "
 -- Arguments "0 "
 -- OG:Qalloc: "0 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "0 "  marked:  false "0 " 
 --  super:  "0 " 
 -- Invocation:Qalloc: "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 " 
 --  super:  "0 " 
 --  E:  "0 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  86 3 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:super:  
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V < 0 " 
 --  super:  "V < 0 " 
 --  E:  "V < 0 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "V < 0 " 
 -- OG:Qalloc: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (isNeg) :then 
 --     V := 0 - V
 --   marked:  false 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integersuper:  
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- Invocation:Qalloc: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- OG:Qalloc: "(isNeg) " qDescno:  0 
 -- OG:Qalloc:A:  "Boolean " super:  "(isNeg) "  marked:  false 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  super:  "(isNeg) " 
 -- Invocation:Qalloc: "(isNeg) " 
 -- Invocation:Qalloc: "isNeg " 
 -- ObjectInvocation:Qalloc: "isNeg "
 -- name: "isNeg "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 1 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- OG:super:  "isNeg: var Boolean " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(isNeg) " 
 --  super:  "(isNeg) " 
 --  E:  "(isNeg) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(isNeg) " 
 -- OG:Qalloc: "V := 0 - V " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V := 0 - V " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 108 IS.newDescNo: 108 objSize: 0 1: 1 "
 --  V := 0 - V " 
 -- Items:Qalloc:objSize: 0  newDescNo: 108 "V := 0 - V " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- OG:Qalloc: "0 - V " qDescno:  0 
 -- OG:Qalloc:A:  "- " super:  "0 - V "  marked:  false "
 --  V := 0 - V " super:  "0 - V " 
 -- Invocation:Qalloc: "0 - V " 
 -- BinaryExp:Qalloc: "0 - V "
 -- Invocation:Qalloc: "0 " 
 -- ObjectInvocation:Qalloc: "- V "
 -- name: "- "
 -- Arguments "V "
 -- OG:Qalloc: "V " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "V "  marked:  false "V " 
 --  super:  "V " 
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "in V: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V " 
 --  super:  "V " 
 --  E:  "V "
 -- OG:Qalloc:end: IS.newDescNo:  0 "V " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 62
 --     in V: var integer
 --     out R: var integer
 --  qDescno:  0 
 -- OG:Qalloc:A:  "- " super:  " "  marked:  false 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "- "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 109 IS.newDescNo: 109 objSize: 0 1: 1 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 109 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "R "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 109 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  
 -- IS.newDescNo: 109 IS.objSize: 3 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:end: IS.newDescNo:  109 
 --  %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:super:  
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 - V " 
 --  super:  "0 - V " 
 --  E:  "0 - V "
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 - V " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 108 "V := 0 - V " 
 -- IS.newDescNo: 108 IS.objSize: 1 "V := 0 - V " 
 -- OG:Qalloc:end: IS.newDescNo:  108 "V := 0 - V " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 --  super:  
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 --  E:  "if (isNeg) :then 
 --     V := 0 - V "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- OG:Qalloc: 
 --  if (isNeg) :then 
 --     put('-')
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (isNeg) :then 
 --     put('-')
 --   marked:  false 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integersuper:  
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- Invocation:Qalloc: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- OG:Qalloc: "(isNeg) " qDescno:  0 
 -- OG:Qalloc:A:  "Boolean " super:  "(isNeg) "  marked:  false 
 --  if (isNeg) :then 
 --     put('-')
 --  super:  "(isNeg) " 
 -- Invocation:Qalloc: "(isNeg) " 
 -- Invocation:Qalloc: "isNeg " 
 -- ObjectInvocation:Qalloc: "isNeg "
 -- name: "isNeg "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  83 1 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- OG:super:  "isNeg: var Boolean " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(isNeg) " 
 --  super:  "(isNeg) " 
 --  E:  "(isNeg) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(isNeg) " 
 -- OG:Qalloc: "put('-') " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (isNeg) :then 
 --     put('-')
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('-') " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 110 IS.newDescNo: 110 objSize: 0 1: 1 "
 --  put('-') " 
 -- Items:Qalloc:objSize: 0  newDescNo: 110 "put('-') " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "put('-') " qDescno:  0 
 -- OG:Qalloc:A:  "put " super:  "put('-') "  marked:  false "
 --  put('-') " super:  "put('-') " 
 -- Invocation:Qalloc: "put('-') " 
 -- ObjectInvocation:Qalloc: "put('-') "
 -- name: "put "
 -- Arguments "put('-') "
 -- OG:Qalloc: "'-' " qDescno:  0 
 -- OG:Qalloc:A:  "char " super:  "'-' "  marked:  false "put('-') " 
 --  super:  "'-' " 
 -- Invocation:Qalloc: "'-' " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- OG:super:  
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'-' " 
 --  super:  "'-' " 
 --  E:  "'-' "
 -- OG:Qalloc:end: IS.newDescNo:  0 "'-' " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- OG:super:  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('-') " 
 --  super:  "put('-') " 
 --  E:  "put('-') "
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('-') " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 110 "put('-') " 
 -- IS.newDescNo: 110 IS.objSize: 1 "put('-') " 
 -- OG:Qalloc:end: IS.newDescNo:  110 "put('-') " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (isNeg) :then 
 --     put('-')
 --  
 --  super:  
 --  if (isNeg) :then 
 --     put('-')
 --  
 --  E:  "if (isNeg) :then 
 --     put('-') "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- OG:Qalloc: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0 " super:  
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i]) marked:  false 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integersuper:  
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- Invocation:Qalloc: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- ObjectInvocation:Qalloc: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- name: "for:to:repeat "
 -- Arguments "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- OG:Qalloc: "L " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L "  marked:  false 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])super:  "L " 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L " 
 --  super:  "L " 
 --  E:  "L "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L " 
 -- OG:Qalloc: 
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0 " super:  " "  marked:  false 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "repeat$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 111 IS.newDescNo: 111 objSize: 0 1: 1 
 --  i: var integer
 --  i := L + 1 - inx
 --  put('0' + D.get[i])
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 111 
 --  i: var integer
 --  i := L + 1 - inx
 --  put('0' + D.get[i])
 --  
 -- Items:Qalloc:super: " " size: 1 "repeat$111 "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "i "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Invocation:Qalloc: "i " 
 -- ObjectInvocation:Qalloc: "i "
 -- name: "i "
 -- Arguments " "
 -- OG:Qalloc: "L + 1 - inx " qDescno:  0 
 -- OG:Qalloc:A:  "- " super:  "L + 1 - inx "  marked:  false "
 --  i := L + 1 - inx " super:  "L + 1 - inx " 
 -- Invocation:Qalloc: "L + 1 - inx " 
 -- BinaryExp:Qalloc: "L + 1 - inx "
 -- BinaryExp:Qalloc: "L + 1 "
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "+ 1 "
 -- name: "+ "
 -- Arguments "1 "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false "1 " 
 --  super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- ObjectInvocation:Qalloc: "- inx "
 -- name: "- "
 -- Arguments "inx "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "inx " 
 --  super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  109 3 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + 1 - inx " 
 --  super:  "L + 1 - inx " 
 --  E:  "L + 1 - inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + 1 - inx " 
 -- OG:Qalloc: "put('0' + D.get[i]) " qDescno:  0 
 -- OG:Qalloc:A:  "put " super:  "put('0' + D.get[i]) "  marked:  
 --  false 
 --  i: var integer
 --  i := L + 1 - inx
 --  put('0' + D.get[i])
 --  super:  "put('0' + D.get[i]) " 
 -- Invocation:Qalloc: "put('0' + D.get[i]) " 
 -- ObjectInvocation:Qalloc: "put('0' + D.get[i]) "
 -- name: "put "
 -- Arguments "put('0' + D.get[i]) "
 -- OG:Qalloc: "'0' + D.get[i] " qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  "'0' + D.get[i] "  marked:  false "
 --  put('0' + D.get[i]) " super:  "'0' + D.get[i] " 
 -- Invocation:Qalloc: "'0' + D.get[i] " 
 -- BinaryExp:Qalloc: "'0' + D.get[i] "
 -- Invocation:Qalloc: "'0' " 
 -- ObjectInvocation:Qalloc: "+ D.get[i] "
 -- name: "+ "
 -- Arguments "D.get[i] "
 -- OG:Qalloc: "D.get[i] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "D.get[i] "  marked:  false "
 --  D.get[i] " super:  "D.get[i] " 
 -- Invocation:Qalloc: "D.get[i] " 
 -- ObjectInvocation:Qalloc: "D "
 -- name: "D "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "get[i] "
 -- name: "get "
 -- Arguments "get[i] "
 -- OG:Qalloc: "i " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "i "  marked:  false "get[i] " 
 --  super:  "i " 
 -- Invocation:Qalloc: "i " 
 -- ObjectInvocation:Qalloc: "i "
 -- name: "i "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "i: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "i " 
 --  super:  "i " 
 --  E:  "i "
 -- OG:Qalloc:end: IS.newDescNo:  0 "i " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 116
 --  out V: var integer
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 116
 --     out V: var integer
 --  qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  " "  marked:  false 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 116
 --     out V: var integer
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "get "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 112 IS.newDescNo: 112 objSize: 0 1: 1 
 --  %basic 116
 --  out V: var integer
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 112 
 --  %basic 116
 --  out V: var integer
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 
 --  %$B "["
 --  inx: var integer
 --  %$E "]"
 --  
 -- dataitem:qalloc: "inx "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 
 --  %$B "["
 --  inx: var integer
 --  %$E "]"
 --  
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 112 
 --  %basic 116
 --  out V: var integer
 --  
 -- IS.newDescNo: 112 IS.objSize: 3 
 --  %basic 116
 --  out V: var integer
 --  
 -- OG:Qalloc:end: IS.newDescNo:  112 
 --  %basic 116
 --     out V: var integer
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "D.get[i] " 
 --  super:  "D.get[i] " 
 --  E:  "get[i] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "D.get[i] " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 61
 --  in V: var char
 --  out R: var char
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  
 -- OG:Qalloc: 
 --  %basic 61
 --     in V: var char
 --     out R: var char
 --  qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  " "  marked:  false 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 61
 --     in V: var char
 --     out R: var char
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "+ "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 113 IS.newDescNo: 113 objSize: 0 1: 1 
 --  %basic 61
 --  in V: var char
 --  out R: var char
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 113 
 --  %basic 61
 --  in V: var char
 --  out R: var char
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "R "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 113 
 --  %basic 61
 --  in V: var char
 --  out R: var char
 --  
 -- IS.newDescNo: 113 IS.objSize: 3 
 --  %basic 61
 --  in V: var char
 --  out R: var char
 --  
 -- OG:Qalloc:end: IS.newDescNo:  113 
 --  %basic 61
 --     in V: var char
 --     out R: var char
 --  
 -- OG:super:  
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'0' + D.get[i] " 
 --  super:  "'0' + D.get[i] " 
 --  E:  "'0' + D.get[i] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "'0' + D.get[i] " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- OG:super:  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('0' + D.get[i]) " 
 --  super:  "put('0' + D.get[i]) " 
 --  E:  "put('0' + D.get[i]) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('0' + D.get[i]) " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 111 
 --  i: var integer
 --  i := L + 1 - inx
 --  put('0' + D.get[i])
 --  
 -- IS.newDescNo: 111 IS.objSize: 2 
 --  i: var integer
 --  i := L + 1 - inx
 --  put('0' + D.get[i])
 --  
 -- OG:Qalloc:end: IS.newDescNo:  111 
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- OG:super:  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  super:  
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  E:  "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- OG:Qalloc:B: "for:to:repeat$0 "newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 114 IS.newDescNo: 114 objSize: 3 1: 1 "
 --   " 
 -- Items:Qalloc:objSize: 0  newDescNo: 114 " " 
 -- Items:Qalloc:super: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])size: 3 "for:to:repeat$114 "
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 114 " " 
 -- IS.newDescNo: 114 IS.objSize: 3 " " 
 -- OG:Qalloc:end: IS.newDescNo:  114 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- Items:Qalloc:END:objSize: 4  newDescNo: 105 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- IS.newDescNo: 105 IS.objSize: 4 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- OG:Qalloc:end: IS.newDescNo:  105 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 -- OG:super:  
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putint(I) " 
 --  super:  "putint(I) " 
 --  E:  "putint(I) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "putint(I) " 
 -- OG:Qalloc: "newline " qDescno:  0 
 -- OG:Qalloc:A:  "newline " super:  "newline "  marked:  false 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMetersuper:  "newline " 
 -- Invocation:Qalloc: "newline " 
 -- ObjectInvocation:Qalloc: "newline "
 -- name: "newline "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %globals
 --  put(10)
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- OG:Qalloc: 
 --  %globals
 --     put(10)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "newline " super:  " "  marked:  false 
 --  newline: 
 --     %globals
 --     put(10)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %globals
 --     put(10)
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "newline "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 115 IS.newDescNo: 115 objSize: 0 1: 1 
 --  %globals
 --  put(10)
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 115 
 --  %globals
 --  put(10)
 --  
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 " " 
 -- OG:Qalloc: "put(10) " qDescno:  0 
 -- OG:Qalloc:A:  "put " super:  "put(10) "  marked:  false 
 --  %globals
 --  put(10)
 --  super:  "put(10) " 
 -- Invocation:Qalloc: "put(10) " 
 -- ObjectInvocation:Qalloc: "put(10) "
 -- name: "put "
 -- Arguments "put(10) "
 -- OG:Qalloc: "10 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "10 "  marked:  false "
 --  put(10) " super:  "10 " 
 -- Invocation:Qalloc: "10 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10 " 
 --  super:  "10 " 
 --  E:  "10 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "10 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- OG:super:  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(10) " 
 --  super:  "put(10) " 
 --  E:  "put(10) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(10) " 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 115 
 --  %globals
 --  put(10)
 --  
 -- IS.newDescNo: 115 IS.objSize: 0 
 --  %globals
 --  put(10)
 --  
 -- OG:Qalloc:end: IS.newDescNo:  115 
 --  %globals
 --     put(10)
 --  
 -- OG:super:  
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline " 
 --  super:  "newline " 
 --  E:  "newline "
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline " 
 -- OG:Qalloc: "putfloat(F) " qDescno:  0 
 -- OG:Qalloc:A:  "putFloat " super:  "putfloat(F) "  marked:  false 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMetersuper:  "putfloat(F) " 
 -- Invocation:Qalloc: "putfloat(F) " 
 -- ObjectInvocation:Qalloc: "putfloat(F) "
 -- name: "putfloat "
 -- Arguments "putfloat(F) "
 -- OG:Qalloc: "F " qDescno:  0 
 -- OG:Qalloc:A:  "float " super:  "F "  marked:  false "
 --  putfloat(F) " super:  "F " 
 -- Invocation:Qalloc: "F " 
 -- ObjectInvocation:Qalloc: "F "
 -- name: "F "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- OG:super:  "F: var Float " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F " 
 --  super:  "F " 
 --  E:  "F "
 -- OG:Qalloc:end: IS.newDescNo:  0 "F " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  56 4 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- OG:super:  
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putfloat(F) " 
 --  super:  "putfloat(F) " 
 --  E:  "putfloat(F) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "putfloat(F) " 
 -- OG:Qalloc: "newline " qDescno:  0 
 -- OG:Qalloc:A:  "newline " super:  "newline "  marked:  false 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMetersuper:  "newline " 
 -- Invocation:Qalloc: "newline " 
 -- ObjectInvocation:Qalloc: "newline "
 -- name: "newline "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  115 0 
 --  %globals
 --  put(10)
 --  
 -- OG:super:  
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline " 
 --  super:  "newline " 
 --  E:  "newline "
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline " 
 -- Invocation:Qalloc: "A " 
 -- ObjectInvocation:Qalloc: "A "
 -- name: "A "
 -- Arguments " "
 -- OG:Qalloc: "24"m2" " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "24"m2" "  marked:  false "
 --  A := 24"m2" " super:  "24"m2" " 
 -- Invocation:Qalloc: "24"m2" " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "24"m2" " 
 --  super:  "24"m2" " 
 --  E:  "24"m2" "
 -- OG:Qalloc:end: IS.newDescNo:  0 "24"m2" " 
 -- Invocation:Qalloc: "A " 
 -- ObjectInvocation:Qalloc: "A "
 -- name: "A "
 -- Arguments " "
 -- OG:Qalloc: "3 * A " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "3 * A "  marked:  false "
 --  A := 3 * A " super:  "3 * A " 
 -- Invocation:Qalloc: "3 * A " 
 -- BinaryExp:Qalloc: "3 * A "
 -- Invocation:Qalloc: "3 " 
 -- ObjectInvocation:Qalloc: "* A "
 -- name: "* "
 -- Arguments "A "
 -- OG:Qalloc: "A " qDescno:  0 
 -- OG:Qalloc:A:  "SquareMeter " super:  "A "  marked:  false "A " 
 --  super:  "A " 
 -- Invocation:Qalloc: "A " 
 -- ObjectInvocation:Qalloc: "A "
 -- name: "A "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  68 2 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- OG:super:  "A: var Area.SquareMeter " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "A " 
 --  super:  "A " 
 --  E:  "A "
 -- OG:Qalloc:end: IS.newDescNo:  0 "A " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  104 3 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "3 * A " 
 --  super:  "3 * A " 
 --  E:  "3 * A "
 -- OG:Qalloc:end: IS.newDescNo:  0 "3 * A " 
 -- Invocation:Qalloc: "A " 
 -- ObjectInvocation:Qalloc: "A "
 -- name: "A "
 -- Arguments " "
 -- OG:Qalloc: "A * 2 " qDescno:  0 
 -- OG:Qalloc:A:  "* " super:  "A * 2 "  marked:  false "
 --  A := A * 2 " super:  "A * 2 " 
 -- Invocation:Qalloc: "A * 2 " 
 -- BinaryExp:Qalloc: "A * 2 "
 -- Invocation:Qalloc: "A " 
 -- ObjectInvocation:Qalloc: "A "
 -- name: "A "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "* 2 "
 -- name: "* "
 -- Arguments "2 "
 -- OG:Qalloc: "2 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "2 "  marked:  false "2 " 
 --  super:  "2 " 
 -- Invocation:Qalloc: "2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "2 " 
 --  super:  "2 " 
 --  E:  "2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "2 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 5 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  
 -- OG:super:  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "A * 2 " 
 --  super:  "A * 2 " 
 --  E:  "A * 2 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "A * 2 " 
 -- OG:Qalloc: "A.print " qDescno:  0 
 -- OG:Qalloc:A:  "print " super:  "A.print "  marked:  false 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMetersuper:  "A.print " 
 -- Invocation:Qalloc: "A.print " 
 -- ObjectInvocation:Qalloc: "A "
 -- name: "A "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "print "
 -- name: "print "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  70 1 "
 --  "SquareMeter".print " 
 -- OG:super:  
 --  print:: 
 --     "SquareMeter".print
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "A.print " 
 --  super:  "A.print " 
 --  E:  "print "
 -- OG:Qalloc:end: IS.newDescNo:  0 "A.print " 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 103 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- IS.newDescNo: 103 IS.objSize: 6 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- OG:Qalloc:end: IS.newDescNo:  103 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeter
 -- ObjTmpStack:add: "tinyB ": 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeter
 -- items:markForCodeGen: 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- markItem: "%visible LIB.Dimensions " Property 
 -- DataItem:markForCodeGen: "F ":descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "Float " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Float " "Float "true 
 -- OG:markSuper: "Float " 
 -- Invocation:markForCodeGen: "Float " 
 -- ObjectInvocation:markForCodeGen: "Float " ATd: 
 --  
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Float "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "I ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Integer " "Integer "true 
 -- OG:markSuper: "Integer " 
 -- Invocation:markForCodeGen: "Integer " 
 -- ObjectInvocation:markForCodeGen: "Integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "A ":descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Area.SquareMeter " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Area.SquareMeter " "Area "false "SquareMeter "false 
 -- OG:markSuper: "Area.SquareMeter " 
 -- Invocation:markForCodeGen: "Area.SquareMeter " 
 -- ObjectInvocation:markForCodeGen: "Area " ATd: 
 --  
 --  --Area
 --  
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "SquareMeter " ATd: 
 --  
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Area.SquareMeter "  IS.isEmpty:  true 
 -- markItem: "F := 3 " Assign 
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "3 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "3 " "3 "true 
 -- OG:markSuper: "3 " 
 -- Invocation:markForCodeGen: "3 " 
 -- not ObjDesc:  "3 "  IS.isEmpty:  true 
 -- markItem: "I := 4.87 " Assign 
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "4.87 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "4.87 " "4.87 "true 
 -- OG:markSuper: "4.87 " 
 -- Invocation:markForCodeGen: "4.87 " 
 -- not ObjDesc:  "4.87 "  IS.isEmpty:  true 
 -- markItem: "F := F * 12 " Assign 
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "F * 12 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F * 12 " "F * 12 "true 
 -- OG:markSuper: "F * 12 " 
 -- Invocation:markForCodeGen: "F * 12 " 
 -- BinaryExp:markForCodeGen: "F * 12 "
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* 12 " ATd: 
 --  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:args:markForCodgen: "12 "
 -- OG:markForCodeGen: "12 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "12 " "12 "true 
 -- OG:markSuper: "12 " 
 -- Invocation:markForCodeGen: "12 " 
 -- not ObjDesc:  "12 "  IS.isEmpty:  true 
 -- not ObjDesc:  "F * 12 "  IS.isEmpty:  true 
 -- markItem: "F := F * I " Assign 
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "F * I " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F * I " "F * I "true 
 -- OG:markSuper: "F * I " 
 -- Invocation:markForCodeGen: "F * I " 
 -- BinaryExp:markForCodeGen: "F * I "
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* I " ATd: 
 --  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:args:markForCodgen: "I "
 -- OG:markForCodeGen: "I " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I " "I "true 
 -- not ObjDesc:  "F * I "  IS.isEmpty:  true 
 -- markItem: "F := 10 * F " Assign 
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "10 * F " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "10 * F " "10 * F "true 
 -- OG:markSuper: "10 * F " 
 -- Invocation:markForCodeGen: "10 * F " 
 -- BinaryExp:markForCodeGen: "10 * F "
 -- Invocation:markForCodeGen: "10 " 
 -- ObjectInvocation:markForCodeGen: "* F " ATd: 
 --  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- Pattern:markForCodeGen: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "F "
 -- OG:markForCodeGen: "F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F " "F "true 
 -- not ObjDesc:  "10 * F "  IS.isEmpty:  true 
 -- markItem: "F := I * F " Assign 
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "I * F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I * F " "I * F "true 
 -- OG:markSuper: "I * F " 
 -- Invocation:markForCodeGen: "I * F " 
 -- BinaryExp:markForCodeGen: "I * F "
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* F " ATd: 
 --  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "F "
 -- OG:markForCodeGen: "F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F " "F "true 
 -- not ObjDesc:  "I * F "  IS.isEmpty:  true 
 -- markItem: "F := I * I " Assign 
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "I * I " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I * I " "I * I "true 
 -- OG:markSuper: "I * I " 
 -- Invocation:markForCodeGen: "I * I " 
 -- BinaryExp:markForCodeGen: "I * I "
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* I " ATd: 
 --  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "I "
 -- OG:markForCodeGen: "I " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I " "I "true 
 -- not ObjDesc:  "I * I "  IS.isEmpty:  true 
 -- markItem: "I := I * 11.11 " Assign 
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "I * 11.11 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I * 11.11 " "I * 11.11 "true 
 -- OG:markSuper: "I * 11.11 " 
 -- Invocation:markForCodeGen: "I * 11.11 " 
 -- BinaryExp:markForCodeGen: "I * 11.11 "
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* 11.11 " ATd: 
 --  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "11.11 "
 -- OG:markForCodeGen: "11.11 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "11.11 " "11.11 "true 
 -- OG:markSuper: "11.11 " 
 -- Invocation:markForCodeGen: "11.11 " 
 -- not ObjDesc:  "11.11 "  IS.isEmpty:  true 
 -- not ObjDesc:  "I * 11.11 "  IS.isEmpty:  true 
 -- markItem: "I := I * F " Assign 
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "I * F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I * F " "I * F "true 
 -- OG:markSuper: "I * F " 
 -- Invocation:markForCodeGen: "I * F " 
 -- BinaryExp:markForCodeGen: "I * F "
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* F " ATd: 
 --  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "F "
 -- OG:markForCodeGen: "F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F " "F "true 
 -- not ObjDesc:  "I * F "  IS.isEmpty:  true 
 -- markItem: "I := 12.12 * F " Assign 
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "12.12 * F " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "12.12 * F " "12.12 * F "true 
 -- OG:markSuper: "12.12 * F " 
 -- Invocation:markForCodeGen: "12.12 * F " 
 -- BinaryExp:markForCodeGen: "12.12 * F "
 -- Invocation:markForCodeGen: "12.12 " 
 -- ObjectInvocation:markForCodeGen: "* F " ATd: 
 --  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:args:markForCodgen: "F "
 -- OG:markForCodeGen: "F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F " "F "true 
 -- not ObjDesc:  "12.12 * F "  IS.isEmpty:  true 
 -- markItem: "I := I * F " Assign 
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "I * F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I * F " "I * F "true 
 -- OG:markSuper: "I * F " 
 -- Invocation:markForCodeGen: "I * F " 
 -- BinaryExp:markForCodeGen: "I * F "
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* F " ATd: 
 --  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "F "
 -- OG:markForCodeGen: "F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F " "F "true 
 -- not ObjDesc:  "I * F "  IS.isEmpty:  true 
 -- markItem: "I := F * F " Assign 
 -- Invocation:markForCodeGen: "I " 
 -- ObjectInvocation:markForCodeGen: "I " ATd: 
 --  "I: var Integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "F * F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F * F " "F * F "true 
 -- OG:markSuper: "F * F " 
 -- Invocation:markForCodeGen: "F * F " 
 -- BinaryExp:markForCodeGen: "F * F "
 -- Invocation:markForCodeGen: "F " 
 -- ObjectInvocation:markForCodeGen: "F " ATd: 
 --  "F: var Float " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* F " ATd: 
 --  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:args:markForCodgen: "F "
 -- OG:markForCodeGen: "F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F " "F "true 
 -- not ObjDesc:  "F * F "  IS.isEmpty:  true 
 -- markItem: "putint(I) " ObjectGenerator 
 -- OG:markForCodeGen: "putint(I) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "putint(I) " "putint(I) "false 
 -- OG:markSuper: "putint(I) " 
 -- Invocation:markForCodeGen: "putint(I) " 
 -- ObjectInvocation:markForCodeGen: "putint(I) " ATd: 
 --  
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 -- Pattern:markForCodeGen: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integerisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 -- OG:Qalloc: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integerqDescno:  105 
 -- ObjTmpStack:add: "putint ": 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 -- items:markForCodeGen: 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- markItem: "%globals " Property 
 -- DataItem:markForCodeGen: "V ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "D ":descNo: 0 :OG.primNo: 114 
 -- OG:markForCodeGen: "Indexed(20,#integer) " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Indexed(20,#integer) " "Indexed(20,#integer) "true 
 -- OG:markSuper: "Indexed(20,#integer) " 
 -- Invocation:markForCodeGen: "Indexed(20,#integer) " 
 -- ObjectInvocation:markForCodeGen: "Indexed(20,#integer) " ATd: 
 --  
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- Pattern:markForCodeGen: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var IntegerisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 -- OG:Qalloc: 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var IntegerqDescno:  106 
 -- ObjTmpStack:add: "Indexed ": 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 -- items:markForCodeGen: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- markItem: "%globals " Property 
 -- markItem: "%basic 114 " Property 
 -- markItem: "%public " Property 
 -- DataItem:markForCodeGen: "range ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Integer " "Integer "true 
 -- OG:markSuper: "Integer " 
 -- Invocation:markForCodeGen: "Integer " 
 -- ObjectInvocation:markForCodeGen: "Integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Integer "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "in elm:< Object " 
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: "Object " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Object " "Object "true 
 -- not ObjDesc:  "Object "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "(20,#integer) "
 -- OG:markForCodeGen: "20 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "20 " "20 "true 
 -- OG:markSuper: "20 " 
 -- Invocation:markForCodeGen: "20 " 
 -- not ObjDesc:  "20 "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "#integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "#integer " "#integer "true 
 -- OG:markSuper: "#integer " 
 -- Invocation:markForCodeGen: "#integer " 
 -- ObjectInvocation:markForCodeGen: "#integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "#integer "  IS.isEmpty:  true 
 -- arg:   "20 "
 -- arg:   "#integer "
 -- not ObjDesc:  "Indexed(20,#integer) "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "isNeg ":descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "Boolean " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Boolean " "Boolean "true 
 -- OG:markSuper: "Boolean " 
 -- Invocation:markForCodeGen: "Boolean " 
 -- ObjectInvocation:markForCodeGen: "Boolean " ATd: 
 --  
 --  Boolean: value
 --     %id "Boolean"
 --     %globals inSub
 --     %basic 4, 8
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Boolean "  IS.isEmpty:  true 
 -- markItem: "isNeg := V < 0 " Assign 
 -- Invocation:markForCodeGen: "isNeg " 
 -- ObjectInvocation:markForCodeGen: "isNeg " ATd: 
 --  "isNeg: var Boolean " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "V < 0 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "V < 0 " "V < 0 "true 
 -- OG:markSuper: "V < 0 " 
 -- Invocation:markForCodeGen: "V < 0 " 
 -- BinaryExp:markForCodeGen: "V < 0 "
 -- Invocation:markForCodeGen: "V " 
 -- ObjectInvocation:markForCodeGen: "V " ATd: 
 --  "in V: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "< 0 " ATd: 
 --  
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OI:args:markForCodgen: "0 "
 -- OG:markForCodeGen: "0 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "0 " "0 "true 
 -- OG:markSuper: "0 " 
 -- Invocation:markForCodeGen: "0 " 
 -- not ObjDesc:  "0 "  IS.isEmpty:  true 
 -- not ObjDesc:  "V < 0 "  IS.isEmpty:  true 
 -- markItem: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (isNeg) :then 
 --     V := 0 - V
 --  "if (isNeg) :then 
 --     V := 0 - V "true 
 -- OG:markSuper: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- Invocation:markForCodeGen: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- OG:markForCodeGen: "(isNeg) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(isNeg) " "(isNeg) "true 
 -- OG:markForCodeGen: "V := 0 - V " isObjectDesc: true  hasItems: 
 --  true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "V := 0 - V " 
 -- OG:Qalloc: "V := 0 - V " qDescno:  108 
 -- ObjTmpStack:add: "V := 0 - V " 
 -- items:markForCodeGen: "V := 0 - V " 
 -- markItem: "V := 0 - V " Assign 
 -- Invocation:markForCodeGen: "V " 
 -- ObjectInvocation:markForCodeGen: "V " ATd: 
 --  "in V: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "0 - V " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "0 - V " "0 - V "true 
 -- OG:markSuper: "0 - V " 
 -- Invocation:markForCodeGen: "0 - V " 
 -- BinaryExp:markForCodeGen: "0 - V "
 -- Invocation:markForCodeGen: "0 " 
 -- ObjectInvocation:markForCodeGen: "- V " ATd: 
 --  
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- Pattern:markForCodeGen: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "V "
 -- OG:markForCodeGen: "V " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "V " "V "true 
 -- not ObjDesc:  "0 - V "  IS.isEmpty:  true 
 -- not ObjDesc:  
 --  if (isNeg) :then 
 --     V := 0 - V
 --   IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 --     if (V > 0) :then isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 --     if (V > 0) :then 
 -- OG:Qalloc: 
 --  L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 --     if (V > 0) :then qDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  " "  marked:  true 
 --  loop: do 
 --     L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 --     if (V > 0) :then 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "loop "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 116 IS.newDescNo: 116 objSize: 0 1: 1 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then 
 -- Items:Qalloc:objSize: 0  newDescNo: 116 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- OG:Qalloc: "L + 1 " qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  "L + 1 "  marked:  false "
 --  L := L + 1 " super:  "L + 1 " 
 -- Invocation:Qalloc: "L + 1 " 
 -- BinaryExp:Qalloc: "L + 1 "
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "+ 1 "
 -- name: "+ "
 -- Arguments "1 "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false "1 " 
 --  super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  60 3 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + 1 " 
 --  super:  "L + 1 " 
 --  E:  "L + 1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + 1 " 
 -- OG:Qalloc: "D.put(V /% 10):at[L] " qDescno:  0 
 -- OG:Qalloc:A:  "put:at " super:  "D.put(V /% 10):at[L] " 
 --   marked:  false 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then super:  "D.put(V /% 10):at[L] " 
 -- Invocation:Qalloc: "D.put(V /% 10):at[L] " 
 -- ObjectInvocation:Qalloc: "D "
 -- name: "D "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "put(V /% 10):at[L] "
 -- name: "put:at "
 -- Arguments "put(V /% 10):at[L] "
 -- OG:Qalloc: "V /% 10 " qDescno:  0 
 -- OG:Qalloc:A:  "/% " super:  "V /% 10 "  marked:  false "
 --  put(V /% 10):at[L] " super:  "V /% 10 " 
 -- Invocation:Qalloc: "V /% 10 " 
 -- BinaryExp:Qalloc: "V /% 10 "
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "/% 10 "
 -- name: "/% "
 -- Arguments "10 "
 -- OG:Qalloc: "10 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "10 "  marked:  false "10 " 
 --  super:  "10 " 
 -- Invocation:Qalloc: "10 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10 " 
 --  super:  "10 " 
 --  E:  "10 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "10 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 69
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 69
 --     in V: var integer
 --     out R: var integer
 --  qDescno:  0 
 -- OG:Qalloc:A:  "/% " super:  " "  marked:  false 
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 69
 --     in V: var integer
 --     out R: var integer
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "/% "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 117 IS.newDescNo: 117 objSize: 0 1: 1 
 --  %basic 69
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 117 
 --  %basic 69
 --  in V: var integer
 --  out R: var integer
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "R "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 117 
 --  %basic 69
 --  in V: var integer
 --  out R: var integer
 --  
 -- IS.newDescNo: 117 IS.objSize: 3 
 --  %basic 69
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:Qalloc:end: IS.newDescNo:  117 
 --  %basic 69
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:super:  
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V /% 10 " 
 --  super:  "V /% 10 " 
 --  E:  "V /% 10 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "V /% 10 " 
 -- OG:Qalloc: "L " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L "  marked:  false "
 --  put(V /% 10):at[L] " super:  "L " 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L " 
 --  super:  "L " 
 --  E:  "L "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "
 --  %basic 115 " 
 -- OG:Qalloc:SuperAlloc: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- OG:Qalloc: "%basic 115 " qDescno:  0 
 -- OG:Qalloc:A:  "put:at " super:  " "  marked:  false 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 115 " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "put:at "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 118 IS.newDescNo: 118 objSize: 0 1: 1 "
 --  %basic 115 " 
 -- Items:Qalloc:objSize: 0  newDescNo: 118 "%basic 115 " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 
 --  %$B "("
 --  V: var integer
 --  %$S "):at["
 --  inx: var integer
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "inx "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 
 --  %$B "("
 --  V: var integer
 --  %$S "):at["
 --  inx: var integer
 -- Items:Qalloc:END:objSize: 3  newDescNo: 118 "%basic 115 " 
 -- IS.newDescNo: 118 IS.objSize: 3 "%basic 115 " 
 -- OG:Qalloc:end: IS.newDescNo:  118 "%basic 115 " 
 -- OG:super:  
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "D.put(V /% 10):at[L] " 
 --  super:  "D.put(V /% 10):at[L] " 
 --  E:  "put(V /% 10):at[L] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "D.put(V /% 10):at[L] " 
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- OG:Qalloc: "V // 10 " qDescno:  0 
 -- OG:Qalloc:A:  "// " super:  "V // 10 "  marked:  false "
 --  V := V // 10 " super:  "V // 10 " 
 -- Invocation:Qalloc: "V // 10 " 
 -- BinaryExp:Qalloc: "V // 10 "
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "// 10 "
 -- name: "// "
 -- Arguments "10 "
 -- OG:Qalloc: "10 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "10 "  marked:  false "10 " 
 --  super:  "10 " 
 -- Invocation:Qalloc: "10 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10 " 
 --  super:  "10 " 
 --  E:  "10 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "10 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 68
 --  in V: var integer
 --  out B: var integer
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- OG:Qalloc: 
 --  %basic 68
 --     in V: var integer
 --     out B: var integer
 --  qDescno:  0 
 -- OG:Qalloc:A:  "// " super:  " "  marked:  false 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "// "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 119 IS.newDescNo: 119 objSize: 0 1: 1 
 --  %basic 68
 --  in V: var integer
 --  out B: var integer
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 119 
 --  %basic 68
 --  in V: var integer
 --  out B: var integer
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 119 
 --  %basic 68
 --  in V: var integer
 --  out B: var integer
 --  
 -- IS.newDescNo: 119 IS.objSize: 3 
 --  %basic 68
 --  in V: var integer
 --  out B: var integer
 --  
 -- OG:Qalloc:end: IS.newDescNo:  119 
 --  %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- OG:super:  
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V // 10 " 
 --  super:  "V // 10 " 
 --  E:  "V // 10 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "V // 10 " 
 -- OG:Qalloc: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0 " super:  
 --  if (V > 0) :then 
 --     restart(loop)
 --   marked:  false 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then super:  
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- Invocation:Qalloc: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- OG:Qalloc: "(V > 0) " qDescno:  0 
 -- OG:Qalloc:A:  "> " super:  "(V > 0) "  marked:  false 
 --  if (V > 0) :then 
 --     restart(loop)
 --  super:  "(V > 0) " 
 -- Invocation:Qalloc: "(V > 0) " 
 -- Invocation:Qalloc: "V > 0 " 
 -- BinaryExp:Qalloc: "V > 0 "
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "> 0 "
 -- name: "> "
 -- Arguments "0 "
 -- OG:Qalloc: "0 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "0 "  marked:  false "0 " 
 --  super:  "0 " 
 -- Invocation:Qalloc: "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0 " 
 --  super:  "0 " 
 --  E:  "0 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "0 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 53
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc: 
 --  %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  qDescno:  0 
 -- OG:Qalloc:A:  "> " super:  " "  marked:  false 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "> "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 120 IS.newDescNo: 120 objSize: 0 1: 1 
 --  %basic 53
 --  in V: var integer
 --  out B: var boolean
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 120 
 --  %basic 53
 --  in V: var integer
 --  out B: var boolean
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "B "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 120 
 --  %basic 53
 --  in V: var integer
 --  out B: var boolean
 --  
 -- IS.newDescNo: 120 IS.objSize: 3 
 --  %basic 53
 --  in V: var integer
 --  out B: var boolean
 --  
 -- OG:Qalloc:end: IS.newDescNo:  120 
 --  %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:super:  
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(V > 0) " 
 --  super:  "(V > 0) " 
 --  E:  "(V > 0) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "(V > 0) " 
 -- OG:Qalloc: "restart(loop) " qDescno:  0 
 -- OG:Qalloc:A:  "$0 " super:  " "  marked:  false 
 --  if (V > 0) :then 
 --     restart(loop)
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop) " 
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 121 IS.newDescNo: 121 objSize: 0 1: 1 "
 --  restart(loop) " 
 -- Items:Qalloc:objSize: 0  newDescNo: 121 "restart(loop) " 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "restart(loop) " qDescno:  0 
 -- OG:Qalloc:A:  "restart " super:  "restart(loop) "  marked:  
 --  false "restart(loop) " super:  "restart(loop) " 
 -- Invocation:Qalloc: "restart(loop) " 
 -- ObjectInvocation:Qalloc: "restart(loop) "
 -- name: "restart "
 -- Arguments "restart(loop) "
 -- OG:Qalloc: "loop " qDescno:  0 
 -- OG:Qalloc:A:  "loop " super:  "loop "  marked:  false "
 --  restart(loop) " super:  "loop " 
 -- Invocation:Qalloc: "loop " 
 -- ObjectInvocation:Qalloc: "loop "
 -- name: "loop "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  116 1 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then 
 -- OG:super:  
 --  loop: do 
 --     L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop " 
 --  super:  "loop " 
 --  E:  "loop "
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  61 2 "
 --  %basic 102 " 
 -- OG:super:  
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop) " 
 --  super:  "restart(loop) " 
 --  E:  "restart(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop) " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 121 "restart(loop) " 
 -- IS.newDescNo: 121 IS.objSize: 1 "restart(loop) " 
 -- OG:Qalloc:end: IS.newDescNo:  121 "restart(loop) " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- OG:super:  
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 --  super:  
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 --  E:  "if (V > 0) :then 
 --     restart(loop) "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- Items:Qalloc:END:objSize: 1  newDescNo: 116 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then 
 -- IS.newDescNo: 116 IS.objSize: 1 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then 
 -- OG:Qalloc:end: IS.newDescNo:  116 
 --  L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 --     if (V > 0) :then 
 -- ObjTmpStack:add: "loop ": 
 --  L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 --     if (V > 0) :then 
 -- items:markForCodeGen: 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then 
 -- markItem: "L := L + 1 " Assign 
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L + 1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L + 1 " "L + 1 "true 
 -- OG:markSuper: "L + 1 " 
 -- Invocation:markForCodeGen: "L + 1 " 
 -- BinaryExp:markForCodeGen: "L + 1 "
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "+ 1 " ATd: 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "1 "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- not ObjDesc:  "L + 1 "  IS.isEmpty:  true 
 -- markItem: "D.put(V /% 10):at[L] " ObjectGenerator 
 -- markItem: "V := V // 10 " Assign 
 -- Invocation:markForCodeGen: "V " 
 -- ObjectInvocation:markForCodeGen: "V " ATd: 
 --  "in V: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "V // 10 " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "V // 10 " "V // 10 "true 
 -- OG:markSuper: "V // 10 " 
 -- Invocation:markForCodeGen: "V // 10 " 
 -- BinaryExp:markForCodeGen: "V // 10 "
 -- Invocation:markForCodeGen: "V " 
 -- ObjectInvocation:markForCodeGen: "V " ATd: 
 --  "in V: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "// 10 " ATd: 
 --  
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- Pattern:markForCodeGen: 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "10 "
 -- OG:markForCodeGen: "10 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "10 " "10 "true 
 -- OG:markSuper: "10 " 
 -- Invocation:markForCodeGen: "10 " 
 -- not ObjDesc:  "10 "  IS.isEmpty:  true 
 -- not ObjDesc:  "V // 10 "  IS.isEmpty:  true 
 -- markItem: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (V > 0) :then 
 --     restart(loop)
 --  "if (V > 0) :then 
 --     restart(loop) "true 
 -- OG:markSuper: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- Invocation:markForCodeGen: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- OG:markForCodeGen: "(V > 0) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(V > 0) " "(V > 0) "true 
 -- OG:markSuper: "(V > 0) " 
 -- Invocation:markForCodeGen: "(V > 0) " 
 -- Invocation:markForCodeGen: "V > 0 " 
 -- BinaryExp:markForCodeGen: "V > 0 "
 -- Invocation:markForCodeGen: "V " 
 -- ObjectInvocation:markForCodeGen: "V " ATd: 
 --  "in V: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "> 0 " ATd: 
 --  
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- Pattern:markForCodeGen: 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "0 "
 -- OG:markForCodeGen: "0 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "0 " "0 "true 
 -- OG:markSuper: "0 " 
 -- Invocation:markForCodeGen: "0 " 
 -- not ObjDesc:  "0 "  IS.isEmpty:  true 
 -- not ObjDesc:  "(V > 0) "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "restart(loop) " isObjectDesc: true 
 --   hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "restart(loop) " 
 -- OG:Qalloc: "restart(loop) " qDescno:  121 
 -- ObjTmpStack:add: "restart(loop) " 
 -- items:markForCodeGen: "restart(loop) " 
 -- markItem: "restart(loop) " ObjectGenerator 
 -- not ObjDesc:  
 --  if (V > 0) :then 
 --     restart(loop)
 --   IS.isEmpty:  true 
 -- markItem: 
 --  if (isNeg) :then 
 --     put('-')
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  if (isNeg) :then 
 --     put('-')
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  if (isNeg) :then 
 --     put('-')
 --  "if (isNeg) :then 
 --     put('-') "true 
 -- OG:markSuper: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- Invocation:markForCodeGen: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- OG:markForCodeGen: "(isNeg) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "(isNeg) " "(isNeg) "true 
 -- OG:markForCodeGen: "put('-') " isObjectDesc: true  hasItems: 
 --  true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: "put('-') " 
 -- OG:Qalloc: "put('-') " qDescno:  110 
 -- ObjTmpStack:add: "put('-') " 
 -- items:markForCodeGen: "put('-') " 
 -- markItem: "put('-') " ObjectGenerator 
 -- OG:markForCodeGen: "put('-') " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "put('-') " "put('-') "true 
 -- OG:markSuper: "put('-') " 
 -- Invocation:markForCodeGen: "put('-') " 
 -- ObjectInvocation:markForCodeGen: "put('-') " ATd: 
 --  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:args:markForCodgen: "put('-') "
 -- OG:markForCodeGen: "'-' " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "'-' " "'-' "true 
 -- OG:markSuper: "'-' " 
 -- Invocation:markForCodeGen: "'-' " 
 -- not ObjDesc:  "'-' "  IS.isEmpty:  true 
 -- arg:   "'-' "
 -- not ObjDesc:  "put('-') "  IS.isEmpty:  true 
 -- not ObjDesc:  
 --  if (isNeg) :then 
 --     put('-')
 --   IS.isEmpty:  true 
 -- markItem: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])ObjectGenerator 
 -- OG:markForCodeGen: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])isObjectDesc: true  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])"
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "false 
 -- OG:markSuper: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- Invocation:markForCodeGen: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- ObjectInvocation:markForCodeGen: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   " ATd: 
 --  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OI:args:markForCodgen: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L " "L "true 
 -- OG:markForCodeGen: 
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  
 -- OG:Qalloc: 
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  qDescno:  111 
 -- ObjTmpStack:add: 
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --  
 -- items:markForCodeGen: 
 --  i: var integer
 --  i := L + 1 - inx
 --  put('0' + D.get[i])
 --  
 -- DataItem:markForCodeGen: "i ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "i := L + 1 - inx " Assign 
 -- Invocation:markForCodeGen: "i " 
 -- ObjectInvocation:markForCodeGen: "i " ATd: 
 --  "i: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L + 1 - inx " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L + 1 - inx " "L + 1 - inx "true 
 -- OG:markSuper: "L + 1 - inx " 
 -- Invocation:markForCodeGen: "L + 1 - inx " 
 -- BinaryExp:markForCodeGen: "L + 1 - inx "
 -- BinaryExp:markForCodeGen: "L + 1 "
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "+ 1 " ATd: 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "1 "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- ObjectInvocation:markForCodeGen: "- inx " ATd: 
 --  
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "inx "
 -- OG:markForCodeGen: "inx " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "inx " "inx "true 
 -- not ObjDesc:  "L + 1 - inx "  IS.isEmpty:  true 
 -- markItem: "put('0' + D.get[i]) " ObjectGenerator 
 -- OG:markForCodeGen: "put('0' + D.get[i]) " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "put('0' + D.get[i]) " "put('0' + D.get[i]) "true 
 -- OG:markSuper: "put('0' + D.get[i]) " 
 -- Invocation:markForCodeGen: "put('0' + D.get[i]) " 
 -- ObjectInvocation:markForCodeGen: "put('0' + D.get[i]) " ATd: 
 --  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:args:markForCodgen: "put('0' + D.get[i]) "
 -- OG:markForCodeGen: "'0' + D.get[i] " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "'0' + D.get[i] " "'0' + D.get[i] "true 
 -- OG:markSuper: "'0' + D.get[i] " 
 -- Invocation:markForCodeGen: "'0' + D.get[i] " 
 -- BinaryExp:markForCodeGen: "'0' + D.get[i] "
 -- Invocation:markForCodeGen: "'0' " 
 -- ObjectInvocation:markForCodeGen: "+ D.get[i] " ATd: 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  
 -- Pattern:markForCodeGen: 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "D.get[i] "
 -- not ObjDesc:  "'0' + D.get[i] "  IS.isEmpty:  true 
 -- arg:   "'0' + D.get[i] "
 -- not ObjDesc:  "put('0' + D.get[i]) "  IS.isEmpty:  true 
 -- arg:   "1 "
 -- arg:   "L "
 -- arg:   "i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i]) "
 -- OG:markIS: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- OG:Qalloc: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])qDescno:  114 
 -- ObjTmpStack:add: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- items:markForCodeGen: " " 
 -- OI:args:markForCodgen: "putint(I) "
 -- OG:markForCodeGen: "I " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "I " "I "true 
 -- arg:   "I "
 -- not ObjDesc:  "putint(I) "  IS.isEmpty:  true 
 -- markItem: "newline " ObjectGenerator 
 -- OG:markForCodeGen: "newline " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "newline " "newline "false 
 -- OG:markSuper: "newline " 
 -- Invocation:markForCodeGen: "newline " 
 -- ObjectInvocation:markForCodeGen: "newline " ATd: 
 --  
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- Pattern:markForCodeGen: 
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %globals
 --     put(10)
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %globals
 --     put(10)
 --  
 -- OG:Qalloc: 
 --  %globals
 --     put(10)
 --  qDescno:  115 
 -- ObjTmpStack:add: "newline ": 
 --  %globals
 --     put(10)
 --  
 -- items:markForCodeGen: 
 --  %globals
 --  put(10)
 --  
 -- markItem: "%globals " Property 
 -- markItem: "put(10) " ObjectGenerator 
 -- OG:markForCodeGen: "put(10) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "put(10) " "put(10) "true 
 -- OG:markSuper: "put(10) " 
 -- Invocation:markForCodeGen: "put(10) " 
 -- ObjectInvocation:markForCodeGen: "put(10) " ATd: 
 --  
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:args:markForCodgen: "put(10) "
 -- OG:markForCodeGen: "10 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "10 " "10 "true 
 -- OG:markSuper: "10 " 
 -- Invocation:markForCodeGen: "10 " 
 -- not ObjDesc:  "10 "  IS.isEmpty:  true 
 -- arg:   "10 "
 -- not ObjDesc:  "put(10) "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "newline "  IS.isEmpty:  true 
 -- markItem: "putfloat(F) " ObjectGenerator 
 -- OG:markForCodeGen: "putfloat(F) " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "putfloat(F) " "putfloat(F) "true 
 -- OG:markSuper: "putfloat(F) " 
 -- Invocation:markForCodeGen: "putfloat(F) " 
 -- ObjectInvocation:markForCodeGen: "putfloat(F) " ATd: 
 --  
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OI:args:markForCodgen: "putfloat(F) "
 -- OG:markForCodeGen: "F " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "F " "F "true 
 -- arg:   "F "
 -- not ObjDesc:  "putfloat(F) "  IS.isEmpty:  true 
 -- markItem: "newline " ObjectGenerator 
 -- OG:markForCodeGen: "newline " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "newline " "newline "false 
 -- OG:markSuper: "newline " 
 -- Invocation:markForCodeGen: "newline " 
 -- ObjectInvocation:markForCodeGen: "newline " ATd: 
 --  
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "newline "  IS.isEmpty:  true 
 -- markItem: "A := 24"m2" " Assign 
 -- Invocation:markForCodeGen: "A " 
 -- ObjectInvocation:markForCodeGen: "A " ATd: 
 --  "A: var Area.SquareMeter " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "24"m2" " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "24"m2" " "24"m2" "true 
 -- OG:markSuper: "24"m2" " 
 -- Invocation:markForCodeGen: "24"m2" " 
 -- not ObjDesc:  "24"m2" "  IS.isEmpty:  true 
 -- markItem: "A := 3 * A " Assign 
 -- Invocation:markForCodeGen: "A " 
 -- ObjectInvocation:markForCodeGen: "A " ATd: 
 --  "A: var Area.SquareMeter " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "3 * A " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "3 * A " "3 * A "true 
 -- OG:markSuper: "3 * A " 
 -- Invocation:markForCodeGen: "3 * A " 
 -- BinaryExp:markForCodeGen: "3 * A "
 -- Invocation:markForCodeGen: "3 " 
 -- ObjectInvocation:markForCodeGen: "* A " ATd: 
 --  
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "A "
 -- OG:markForCodeGen: "A " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "A " "A "false 
 -- not ObjDesc:  "3 * A "  IS.isEmpty:  true 
 -- markItem: "A := A * 2 " Assign 
 -- Invocation:markForCodeGen: "A " 
 -- ObjectInvocation:markForCodeGen: "A " ATd: 
 --  "A: var Area.SquareMeter " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "A * 2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "A * 2 " "A * 2 "true 
 -- OG:markSuper: "A * 2 " 
 -- Invocation:markForCodeGen: "A * 2 " 
 -- BinaryExp:markForCodeGen: "A * 2 "
 -- Invocation:markForCodeGen: "A " 
 -- ObjectInvocation:markForCodeGen: "A " ATd: 
 --  "A: var Area.SquareMeter " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "* 2 " ATd: 
 --  
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:args:markForCodgen: "2 "
 -- OG:markForCodeGen: "2 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "2 " "2 "true 
 -- OG:markSuper: "2 " 
 -- Invocation:markForCodeGen: "2 " 
 -- not ObjDesc:  "2 "  IS.isEmpty:  true 
 -- not ObjDesc:  "A * 2 "  IS.isEmpty:  true 
 -- markItem: "A.print " ObjectGenerator 
 -- OG:markForCodeGen: "A.print " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "A.print " "A "false "print "false 
 -- OG:markSuper: "A.print " 
 -- Invocation:markForCodeGen: "A.print " 
 -- ObjectInvocation:markForCodeGen: "A " ATd: 
 --  "A: var Area.SquareMeter " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "print " ATd: 
 --  
 --  print:: 
 --     "SquareMeter".print
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "A.print "  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: 
 --  Object: 
 --     %ID Object
 --     %basic 64
 --     %public
 -- items:markForCodeGen: " " 
 -- Pattern:markForCodeGen: 
 --  +  : 
 --     in S: var String
 --     out V: var String
 --     L: var integer
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := LengthisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 -- OG:Qalloc: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := LengthqDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  " "  marked:  true 
 --  +  : 
 --     in S: var String
 --     out V: var String
 --     L: var integersuper:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "+ "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 122 IS.newDescNo: 122 objSize: 0 1: 1 
 --  in S: var String
 --  out V: var String
 --  L: var integer
 --  L := Length
 -- Items:Qalloc:objSize: 0  newDescNo: 122 
 --  in S: var String
 --  out V: var String
 --  L: var integer
 --  L := Length
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "S "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in S: var String " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "V "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "out V: var String " 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "L "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- OG:Qalloc: "Length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "Length "  marked:  false "
 --  L := Length " super:  "Length " 
 -- Invocation:Qalloc: "Length " 
 -- ObjectInvocation:Qalloc: "Length "
 -- name: "Length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Length " 
 --  super:  "Length " 
 --  E:  "Length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Length " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 122 
 --  in S: var String
 --  out V: var String
 --  L: var integer
 --  L := Length
 -- IS.newDescNo: 122 IS.objSize: 4 
 --  in S: var String
 --  out V: var String
 --  L: var integer
 --  L := Length
 -- OG:Qalloc:end: IS.newDescNo:  122 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 -- ObjTmpStack:add: "+   ": 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 -- items:markForCodeGen: 
 --  in S: var String
 --  out V: var String
 --  L: var integer
 --  L := Length
 -- DataItem:markForCodeGen: "S ":descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "String " "String "true 
 -- not ObjDesc:  "String "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "V ":descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "String " "String "true 
 -- not ObjDesc:  "String "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- markItem: "L := Length " Assign 
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "Length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "Length " "Length "false 
 -- OG:markSuper: "Length " 
 -- Invocation:markForCodeGen: "Length " 
 -- ObjectInvocation:markForCodeGen: "Length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Length "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeatisObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 -- OG:Qalloc: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeatqDescno:  0 
 -- OG:Qalloc:A:  "doplus " super:  " "  marked:  true 
 --  doplus: do 
 --     e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "doplus "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 123 IS.newDescNo: 123 objSize: 0 1: 1 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeat
 -- Items:Qalloc:objSize: 0  newDescNo: 123 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeat
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "e "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- dataitem:qalloc: "i "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 " " 
 -- dataitem:qalloc: "T "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "T: obj Indexed(L + S.length,Integer) " 
 -- OG:Qalloc: "Indexed(L + S.length,Integer) " qDescno:  0 
 -- OG:Qalloc:A:  "T " super:  "Indexed(L + S.length,Integer) " 
 --   marked:  false "T: obj Indexed(L + S.length,Integer) " super:  "
 --  Indexed(L + S.length,Integer) " 
 -- Invocation:Qalloc: "Indexed(L + S.length,Integer) " 
 -- ObjectInvocation:Qalloc: "Indexed(L + S.length,Integer) "
 -- name: "Indexed "
 -- Arguments "(L + S.length,Integer) "
 -- OG:Qalloc: "L + S.length " qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  "L + S.length "  marked:  false "
 --  (L + S.length,Integer) " super:  "L + S.length " 
 -- Invocation:Qalloc: "L + S.length " 
 -- BinaryExp:Qalloc: "L + S.length "
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "+ S.length "
 -- name: "+ "
 -- Arguments "S.length "
 -- OG:Qalloc: "S.length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "S.length "  marked:  false "
 --  S.length " super:  "S.length " 
 -- Invocation:Qalloc: "S.length " 
 -- ObjectInvocation:Qalloc: "S "
 -- name: "S "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "length "
 -- name: "length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.length " 
 --  super:  "S.length " 
 --  E:  "length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.length " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  60 3 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + S.length " 
 --  super:  "L + S.length " 
 --  E:  "L + S.length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + S.length " 
 -- OG:Qalloc: "Integer " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "Integer "  marked:  false "
 --  (L + S.length,Integer) " super:  "Integer " 
 -- Invocation:Qalloc: "Integer " 
 -- ObjectInvocation:Qalloc: "Integer "
 -- name: "Integer "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Integer " 
 --  super:  "Integer " 
 --  E:  "Integer "
 -- OG:Qalloc:end: IS.newDescNo:  0 "Integer " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  106 1 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- OG:super:  
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "Indexed(L + S.length,Integer) " 
 --  super:  "Indexed(L + S.length,Integer) " 
 --  E:  "Indexed(L + S.length,Integer) "
 -- OG:Qalloc:end: IS.newDescNo:  0 "
 --  Indexed(L + S.length,Integer) " 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- OG:Qalloc: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0 " super:  
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   marked:  false 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeatsuper:  
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- Invocation:Qalloc: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- ObjectInvocation:Qalloc: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- name: "for:to:repeat "
 -- Arguments "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- OG:Qalloc: "L " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "L "  marked:  false 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  super:  "L " 
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "L: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L " 
 --  super:  "L " 
 --  E:  "L "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L " 
 -- OG:Qalloc: 
 --  e := get[inx]
 --     T.put(e):at[inx]
 --  qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0 " super:  " "  marked:  false 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  e := get[inx]
 --     T.put(e):at[inx]
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "repeat$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 124 IS.newDescNo: 124 objSize: 0 1: 1 
 --  e := get[inx]
 --  T.put(e):at[inx]
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 124 
 --  e := get[inx]
 --  T.put(e):at[inx]
 --  
 -- Items:Qalloc:super: " " size: 1 "repeat$124 "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "e " 
 -- ObjectInvocation:Qalloc: "e "
 -- name: "e "
 -- Arguments " "
 -- OG:Qalloc: "get[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "get[inx] "  marked:  false "
 --  e := get[inx] " super:  "get[inx] " 
 -- Invocation:Qalloc: "get[inx] " 
 -- ObjectInvocation:Qalloc: "get[inx] "
 -- name: "get "
 -- Arguments "get[inx] "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  get[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx] " 
 --  super:  "get[inx] " 
 --  E:  "get[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx] " 
 -- OG:Qalloc: "T.put(e):at[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "put:at " super:  "T.put(e):at[inx] "  marked:  
 --  false 
 --  e := get[inx]
 --  T.put(e):at[inx]
 --  super:  "T.put(e):at[inx] " 
 -- Invocation:Qalloc: "T.put(e):at[inx] " 
 -- ObjectInvocation:Qalloc: "T "
 -- name: "T "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "put(e):at[inx] "
 -- name: "put:at "
 -- Arguments "put(e):at[inx] "
 -- OG:Qalloc: "e " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "e "  marked:  false "
 --  put(e):at[inx] " super:  "e " 
 -- Invocation:Qalloc: "e " 
 -- ObjectInvocation:Qalloc: "e "
 -- name: "e "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "e: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e " 
 --  super:  "e " 
 --  E:  "e "
 -- OG:Qalloc:end: IS.newDescNo:  0 "e " 
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  put(e):at[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  118 3 "
 --  %basic 115 " 
 -- OG:super:  
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.put(e):at[inx] " 
 --  super:  "T.put(e):at[inx] " 
 --  E:  "put(e):at[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.put(e):at[inx] " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 124 
 --  e := get[inx]
 --  T.put(e):at[inx]
 --  
 -- IS.newDescNo: 124 IS.objSize: 1 
 --  e := get[inx]
 --  T.put(e):at[inx]
 --  
 -- OG:Qalloc:end: IS.newDescNo:  124 
 --  e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- OG:super:  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 --  super:  
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 --  E:  "for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- OG:Qalloc:B: "for:to:repeat$0 "newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 125 IS.newDescNo: 125 objSize: 3 1: 1 "
 --   " 
 -- Items:Qalloc:objSize: 0  newDescNo: 125 " " 
 -- Items:Qalloc:super: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  size: 3 "for:to:repeat$125 "
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 125 " " 
 -- IS.newDescNo: 125 IS.objSize: 3 " " 
 -- OG:Qalloc:end: IS.newDescNo:  125 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- OG:Qalloc: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0 " super:  
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i] marked:  false 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeatsuper:  
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- Invocation:Qalloc: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- ObjectInvocation:Qalloc: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- name: "for:to:repeat "
 -- Arguments "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- OG:Qalloc: "1 " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "1 "  marked:  false 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]super:  "1 " 
 -- Invocation:Qalloc: "1 " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1 " 
 --  super:  "1 " 
 --  E:  "1 "
 -- OG:Qalloc:end: IS.newDescNo:  0 "1 " 
 -- OG:Qalloc: "S.length " qDescno:  0 
 -- OG:Qalloc:A:  "length " super:  "S.length "  marked:  false 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]super:  "S.length " 
 -- Invocation:Qalloc: "S.length " 
 -- ObjectInvocation:Qalloc: "S "
 -- name: "S "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "length "
 -- name: "length "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- OG:super:  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.length " 
 --  super:  "S.length " 
 --  E:  "length "
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.length " 
 -- OG:Qalloc: 
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0 " super:  " "  marked:  false 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "repeat$0 "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 126 IS.newDescNo: 126 objSize: 0 1: 1 
 --  e := S.get[inx]
 --  i := L + inx
 --  T.put(e):at[i]
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 126 
 --  e := S.get[inx]
 --  i := L + inx
 --  T.put(e):at[i]
 --  
 -- Items:Qalloc:super: " " size: 1 "repeat$126 "
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "e " 
 -- ObjectInvocation:Qalloc: "e "
 -- name: "e "
 -- Arguments " "
 -- OG:Qalloc: "S.get[inx] " qDescno:  0 
 -- OG:Qalloc:A:  "get " super:  "S.get[inx] "  marked:  false "
 --  e := S.get[inx] " super:  "S.get[inx] " 
 -- Invocation:Qalloc: "S.get[inx] " 
 -- ObjectInvocation:Qalloc: "S "
 -- name: "S "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "get[inx] "
 -- name: "get "
 -- Arguments "get[inx] "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "
 --  get[inx] " super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 
 --  %basic 117
 --  out ch: var char
 --  
 -- OG:super:  
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.get[inx] " 
 --  super:  "S.get[inx] " 
 --  E:  "get[inx] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.get[inx] " 
 -- Invocation:Qalloc: "i " 
 -- ObjectInvocation:Qalloc: "i "
 -- name: "i "
 -- Arguments " "
 -- OG:Qalloc: "L + inx " qDescno:  0 
 -- OG:Qalloc:A:  "+ " super:  "L + inx "  marked:  false "
 --  i := L + inx " super:  "L + inx " 
 -- Invocation:Qalloc: "L + inx " 
 -- BinaryExp:Qalloc: "L + inx "
 -- Invocation:Qalloc: "L " 
 -- ObjectInvocation:Qalloc: "L "
 -- name: "L "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "+ inx "
 -- name: "+ "
 -- Arguments "inx "
 -- OG:Qalloc: "inx " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "inx "  marked:  false "inx " 
 --  super:  "inx " 
 -- Invocation:Qalloc: "inx " 
 -- ObjectInvocation:Qalloc: "inx "
 -- name: "inx "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "inx: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx " 
 --  super:  "inx " 
 --  E:  "inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  60 3 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  
 -- OG:super:  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + inx " 
 --  super:  "L + inx " 
 --  E:  "L + inx "
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + inx " 
 -- OG:Qalloc: "T.put(e):at[i] " qDescno:  0 
 -- OG:Qalloc:A:  "put:at " super:  "T.put(e):at[i] "  marked:  
 --  false 
 --  e := S.get[inx]
 --  i := L + inx
 --  T.put(e):at[i]
 --  super:  "T.put(e):at[i] " 
 -- Invocation:Qalloc: "T.put(e):at[i] " 
 -- ObjectInvocation:Qalloc: "T "
 -- name: "T "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "put(e):at[i] "
 -- name: "put:at "
 -- Arguments "put(e):at[i] "
 -- OG:Qalloc: "e " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "e "  marked:  false "
 --  put(e):at[i] " super:  "e " 
 -- Invocation:Qalloc: "e " 
 -- ObjectInvocation:Qalloc: "e "
 -- name: "e "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "e: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e " 
 --  super:  "e " 
 --  E:  "e "
 -- OG:Qalloc:end: IS.newDescNo:  0 "e " 
 -- OG:Qalloc: "i " qDescno:  0 
 -- OG:Qalloc:A:  "integer " super:  "i "  marked:  false "
 --  put(e):at[i] " super:  "i " 
 -- Invocation:Qalloc: "i " 
 -- ObjectInvocation:Qalloc: "i "
 -- name: "i "
 -- Arguments " "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- OG:super:  "i: var integer " 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "i " 
 --  super:  "i " 
 --  E:  "i "
 -- OG:Qalloc:end: IS.newDescNo:  0 "i " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  118 3 "
 --  %basic 115 " 
 -- OG:super:  
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.put(e):at[i] " 
 --  super:  "T.put(e):at[i] " 
 --  E:  "put(e):at[i] "
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.put(e):at[i] " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 126 
 --  e := S.get[inx]
 --  i := L + inx
 --  T.put(e):at[i]
 --  
 -- IS.newDescNo: 126 IS.objSize: 1 
 --  e := S.get[inx]
 --  i := L + inx
 --  T.put(e):at[i]
 --  
 -- OG:Qalloc:end: IS.newDescNo:  126 
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- OG:super:  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  super:  
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  E:  "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- OG:Qalloc:B: "for:to:repeat$0 "newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 127 IS.newDescNo: 127 objSize: 3 1: 1 "
 --   " 
 -- Items:Qalloc:objSize: 0  newDescNo: 127 " " 
 -- Items:Qalloc:super: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]size: 3 "for:to:repeat$127 "
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 127 " " 
 -- IS.newDescNo: 127 IS.objSize: 3 " " 
 -- OG:Qalloc:end: IS.newDescNo:  127 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- Invocation:Qalloc: "V " 
 -- ObjectInvocation:Qalloc: "V "
 -- name: "V "
 -- Arguments " "
 -- OG:Qalloc: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  qDescno:  0 
 -- OG:Qalloc:A:  "asString " super:  
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --   marked:  false 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  super:  
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- Invocation:Qalloc: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- ObjectInvocation:Qalloc: "T "
 -- name: "T "
 -- Arguments " "
 -- ObjectInvocation:Qalloc: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- name: "asString "
 -- Arguments "
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- OG:Qalloc:SuperAlloc: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- OG:Qalloc: 
 --  %basic 118
 --     out S: var LIB.StringLib.String
 --  qDescno:  0 
 -- OG:Qalloc:A:  "asString " super:  " "  marked:  false 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  super:  " " 
 -- Invocation:Qalloc: " " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  
 --  true 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  %basic 118
 --     out S: var LIB.StringLib.String
 --  
 --  super:  " " 
 --  E:  " "
 -- OG:Qalloc:B: "asString "newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 128 IS.newDescNo: 128 objSize: 0 1: 1 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- Items:Qalloc:objSize: 0  newDescNo: 128 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 " " 
 -- dataitem:qalloc: "S "isValue: false  isPrimitive: true 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out S: var LIB.StringLib.String " 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 128 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- IS.newDescNo: 128 IS.objSize: 2 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- OG:Qalloc:end: IS.newDescNo:  128 
 --  %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- OG:super:  
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  
 --  false 
 -- super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  super:  
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  E:  "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- OG:Qalloc:end: IS.newDescNo:  0 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- Items:Qalloc:END:objSize: 4  newDescNo: 123 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeat
 -- IS.newDescNo: 123 IS.objSize: 4 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeat
 -- OG:Qalloc:end: IS.newDescNo:  123 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 -- ObjTmpStack:add: "doplus ": 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 -- items:markForCodeGen: 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeat
 -- DataItem:markForCodeGen: "e ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "i ":descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "integer " "integer "true 
 -- OG:markSuper: "integer " 
 -- Invocation:markForCodeGen: "integer " 
 -- ObjectInvocation:markForCodeGen: "integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "integer "  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "T ":descNo: 0 :OG.primNo: 114 
 -- OG:markForCodeGen: "Indexed(L + S.length,Integer) " 
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Indexed(L + S.length,Integer) " "Indexed(L + S.length,Integer) "
 --  true 
 -- OG:markSuper: "Indexed(L + S.length,Integer) " 
 -- Invocation:markForCodeGen: "Indexed(L + S.length,Integer) " 
 -- ObjectInvocation:markForCodeGen: "Indexed(L + S.length,Integer) "
 --   ATd: 
 --  
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- OI:args:markForCodgen: "(L + S.length,Integer) "
 -- OG:markForCodeGen: "L + S.length " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L + S.length " "L + S.length "true 
 -- OG:markSuper: "L + S.length " 
 -- Invocation:markForCodeGen: "L + S.length " 
 -- BinaryExp:markForCodeGen: "L + S.length "
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "+ S.length " ATd: 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "S.length "
 -- OG:markForCodeGen: "S.length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "S.length " "S "true "length "false 
 -- OG:markSuper: "S.length " 
 -- Invocation:markForCodeGen: "S.length " 
 -- ObjectInvocation:markForCodeGen: "S " ATd: 
 --  "in S: var String " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "S.length "  IS.isEmpty:  true 
 -- not ObjDesc:  "L + S.length "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Integer " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "Integer " "Integer "true 
 -- OG:markSuper: "Integer " 
 -- Invocation:markForCodeGen: "Integer " 
 -- ObjectInvocation:markForCodeGen: "Integer " ATd: 
 --  
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "Integer "  IS.isEmpty:  true 
 -- arg:   "L + S.length "
 -- arg:   "Integer "
 -- not ObjDesc:  "Indexed(L + S.length,Integer) "  IS.isEmpty:  
 --  true 
 -- markItem: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  ObjectGenerator 
 -- OG:markForCodeGen: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  isObjectDesc: true  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 --  false 
 -- OG:markSuper: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- Invocation:markForCodeGen: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- ObjectInvocation:markForCodeGen: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " ATd: 
 --  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OI:args:markForCodgen: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L " "L "true 
 -- OG:markForCodeGen: 
 --  e := get[inx]
 --     T.put(e):at[inx]
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- OG:Qalloc: 
 --  e := get[inx]
 --     T.put(e):at[inx]
 --  qDescno:  124 
 -- ObjTmpStack:add: 
 --  e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- items:markForCodeGen: 
 --  e := get[inx]
 --  T.put(e):at[inx]
 --  
 -- markItem: "e := get[inx] " Assign 
 -- Invocation:markForCodeGen: "e " 
 -- ObjectInvocation:markForCodeGen: "e " ATd: 
 --  "e: var integer " 
 -- OI:args:markForCodgen: " "
 -- markItem: "T.put(e):at[inx] " ObjectGenerator 
 -- arg:   "1 "
 -- arg:   "L "
 -- arg:   "e := get[inx]
 --     T.put(e):at[inx] "
 -- OG:markIS: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- OG:Qalloc: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  qDescno:  125 
 -- ObjTmpStack:add: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- items:markForCodeGen: " " 
 -- markItem: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]ObjectGenerator 
 -- OG:markForCodeGen: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]isObjectDesc: true  hasItems: false 
 --   super.hasVirtualArgs: true 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "false 
 -- OG:markSuper: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- Invocation:markForCodeGen: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- ObjectInvocation:markForCodeGen: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " ATd: 
 --  
 --  for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
 --     %OSDvisibility skipInternal
 --     %globals inSub
 --     inx: var integer
 -- OI:args:markForCodgen: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- OG:markForCodeGen: "1 " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "1 " "1 "true 
 -- OG:markSuper: "1 " 
 -- Invocation:markForCodeGen: "1 " 
 -- not ObjDesc:  "1 "  IS.isEmpty:  true 
 -- OG:markForCodeGen: "S.length " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  "S.length " "S "true "length "false 
 -- OG:markSuper: "S.length " 
 -- Invocation:markForCodeGen: "S.length " 
 -- ObjectInvocation:markForCodeGen: "S " ATd: 
 --  "in S: var String " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "length " ATd: 
 --  
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:args:markForCodgen: " "
 -- not ObjDesc:  "S.length "  IS.isEmpty:  true 
 -- OG:markForCodeGen: 
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  
 -- OG:Qalloc: 
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  qDescno:  126 
 -- ObjTmpStack:add: 
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --  
 -- items:markForCodeGen: 
 --  e := S.get[inx]
 --  i := L + inx
 --  T.put(e):at[i]
 --  
 -- markItem: "e := S.get[inx] " Assign 
 -- Invocation:markForCodeGen: "e " 
 -- ObjectInvocation:markForCodeGen: "e " ATd: 
 --  "e: var integer " 
 -- OI:args:markForCodgen: " "
 -- markItem: "i := L + inx " Assign 
 -- Invocation:markForCodeGen: "i " 
 -- ObjectInvocation:markForCodeGen: "i " ATd: 
 --  "i: var integer " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: "L + inx " isObjectDesc: false  hasItems: 
 --  false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "L + inx " "L + inx "true 
 -- OG:markSuper: "L + inx " 
 -- Invocation:markForCodeGen: "L + inx " 
 -- BinaryExp:markForCodeGen: "L + inx "
 -- Invocation:markForCodeGen: "L " 
 -- ObjectInvocation:markForCodeGen: "L " ATd: 
 --  "L: var integer " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "+ inx " ATd: 
 --  
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:args:markForCodgen: "inx "
 -- OG:markForCodeGen: "inx " isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "inx " "inx "true 
 -- not ObjDesc:  "L + inx "  IS.isEmpty:  true 
 -- markItem: "T.put(e):at[i] " ObjectGenerator 
 -- arg:   "1 "
 -- arg:   "S.length "
 -- arg:   "e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i] "
 -- OG:markIS: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- OG:Qalloc: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]qDescno:  127 
 -- ObjTmpStack:add: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- items:markForCodeGen: " " 
 -- markItem: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  Assign 
 -- Invocation:markForCodeGen: "V " 
 -- ObjectInvocation:markForCodeGen: "V " ATd: 
 --  "out V: var String " 
 -- OI:args:markForCodgen: " "
 -- OG:markForCodeGen: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  isObjectDesc: false  hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  "T "true "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "true 
 -- OG:markSuper: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- Invocation:markForCodeGen: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- ObjectInvocation:markForCodeGen: "T " ATd: 
 --  "T: obj Indexed(L + S.length,Integer) " 
 -- OI:args:markForCodgen: " "
 -- ObjectInvocation:markForCodeGen: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] " ATd: 
 --  
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- Pattern:markForCodeGen: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- items:markForCodeGen: " " 
 -- OG:markForCodeGen: 
 --  %basic 118
 --     out S: var LIB.StringLib.String
 --  isObjectDesc: true  hasItems: true 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: false 
 --   (super.last).isPrimitive: false 
 --  " " " "false 
 -- OG:markIS: 
 --  %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- OG:Qalloc: 
 --  %basic 118
 --     out S: var LIB.StringLib.String
 --  qDescno:  128 
 -- ObjTmpStack:add: "asString ": 
 --  %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- items:markForCodeGen: 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- markItem: "%basic 118 " Property 
 -- DataItem:markForCodeGen: "S ":descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String " isObjectDesc: false 
 --   hasItems: false 
 --   super.hasVirtualArgs: false 
 --   super.isPrimitive: true 
 --   (super.last).isPrimitive: true 
 --  "LIB.StringLib.String " "LIB "false "StringLib "false "String "
 --  true 
 -- not ObjDesc:  "LIB.StringLib.String "  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- not ObjDesc:  
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --   IS.isEmpty:  true 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 1 
 -- Items:GenClass: BETAworld descNo: 1 isValue: false 
 -- Items:GenClass: BETAworld descNo: 21 isValue: false 

 CLASS BETAworld 21 1 BETA 2
 -- Store itemArgs: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- $Property:gen: %ID Object 
 -- $Property:gen: %basic 64 
 -- $Property:gen: %public 
 -- 
 -- $pattern:gen:  \
 -- X_asString:<  -- does not wokr, problem with virtual in Object \
 --    out S: var LIB.StringLib.String \
 --    inner(X_asString) 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%ID Object " 
 -- $Property:gen: %ID Object 
 -- genclass:stmt: "%basic 64 " 
 -- $Property:gen: %basic 64 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 -- genclass:stmt: "inner(Object) " 
 -- $ObjectGenerator:gen: inner(Object) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(Object) " 
 -- OG:before:super.gen: "inner(Object) "
 -- $Invocation:gen: inner(Object) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(Object) " 
 -- isConstant: "Invocation ""inner(Object) "
 -- needorigin: "inner(Object) " 
 -- needOrigin:E: "inner(Object) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Object) " rec: "inner(Object) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Object) "originIsValueObj: false 
 --  origin.isPrimitive: true 
 -- KUK 
 -- after:needOrigin: "inner(Object) " 
 -- doNeedOrigin:E: "inner(Object) " 
 -- computeAdrX:superAdj: 0 "inner(Object) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Object) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(Object) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(Object) >on:1 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(Object) >ATd.off:0 (isPtn):on:1:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inner(Object) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- computeAdrX:isLast:E:  "inner(Object) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 --  rec:  "inner(Object) "E:  "inner(Object) "
 -- INV:gen:E.loadArgs "inner(Object) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(Object) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:Object
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(Object)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(Object) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Object) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(Object) >rec:"inner(Object)" ATd:"pattern" E:"inner(Object)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(Object) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:B: "inner(Object) "E: "inner(Object) " rec: "
 --  inner(Object) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(Object)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(Object) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:C: inner(Object) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 L2:
 -- pushReturn:  "BETAworld "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=21 vDescInx=0 vdtTop: 2 
 -- vdtAdd: inx=1 descInx=21 vDescInx=32 vdtTop: 2 

 CLASS BETAworld 1 1 Object 21
 -- Store itemArgs: 
 --  %id "BETAworld"
 --  %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
 --  error: 
 --     %basic 999
 -- Store:Origin: 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=1 vDescInx=1 vdtTop: 1 
 pushThis 
 saveBETAworld
 mvStack 
 -- $Property:gen: %id "BETAworld" 
 -- $Property:gen: %modules BETA, LIB, LIB.StringLib, LIB.BasicIo 
 -- 
 -- $obj:gen:  \
 -- BETA: obj  \
 --    %ID BETA \
 --    %OSDvisibility disguised
 -- 
 -- $ObjectGenerator:gen:  \
 -- %ID BETA \
 --    %OSDvisibility disguised \
 --    %module LIB, LIB.StringLib
 -- OG:gen: 
 --  %ID BETA
 --     %OSDvisibility disguised
 --     %module LIB, LIB.StringLib
 --     %public
 pushThis 
 -- before objTmpStack:add:  2   "BETA "
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $obj:gen:  \
 -- LIB: obj  \
 --    %id "LIB" \
 --    %module BETA
 -- 
 -- $ObjectGenerator:gen:  \
 -- %id "LIB" \
 --    %module BETA \
 --    %Include BETA
 -- OG:gen: 
 --  %id "LIB"
 --     %module BETA
 --     %Include BETA
 --     x_dummy_LIB: var integer
 pushThis 
 -- before objTmpStack:add:  33   "LIB "
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "workspace "
 -- 
 -- $ModuleItem:gen:  \
 -- --BETA \
 --  
 -- ModuleItem:gen BETA 
 -- 
 -- $obj:gen:  \
 -- BETA: obj  \
 --    %ID BETA \
 --    %OSDvisibility disguised
 -- 
 -- $ModuleItem:gen:  \
 -- --DK \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --LIB \
 --  
 -- ModuleItem:gen LIB 
 -- 
 -- $obj:gen:  \
 -- LIB: obj  \
 --    %id "LIB" \
 --    %module BETA
 -- 
 -- $ModuleItem:gen:  \
 -- --OOPM \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Sequential \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --no \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --workspace \
 --  
 -- ModuleItem:gen workspace 
 -- 
 -- $obj:gen:  \
 -- workspace: obj  \
 --    %id "workspace" \
 --    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 -- 
 -- $ObjectGenerator:gen:  \
 -- %id "workspace" \
 --    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib \
 --    %domain_boundary
 -- OG:gen: 
 --  %id "workspace"
 --     %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --     %domain_boundary
 --     --AbstractEx
 pushThis 
 -- before objTmpStack:add:  102   "workspace "
 invoke workspace 102 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "BETAworld" " 
 -- $Property:gen: %id "BETAworld" 
 -- genclass:stmt: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo " 
 -- $Property:gen: %modules BETA, LIB, LIB.StringLib, LIB.BasicIo 
 L2:
 -- pushReturn:  "BETAworld "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 2 
 -- Items:GenClass: BETA descNo: 2 isValue: false 
 -- Items:GenClass: BETA descNo: 21 isValue: false 

 CLASS BETA 2 1 BETAworld 1
 -- Store itemArgs: 
 --  %ID BETA
 --  %OSDvisibility disguised
 --  %module LIB, LIB.StringLib
 --  %public
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=2 vDescInx=2 vdtTop: 1 
 mvStack 
 -- $Property:gen: %ID BETA 
 -- $Property:gen: %OSDvisibility disguised 
 -- $Property:gen: %module LIB, LIB.StringLib 
 -- $Property:gen: %public 
 -- 
 -- $obj:gen:  \
 -- ascii: obj  \
 --    asciiFoo:  \
 --       msg1:  -- obj
 -- DI:gen: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: ascii 
 -- DI:off: 2 this: 
 --  ascii: obj 
 --     asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- asciiFoo:  \
 --       msg1:  -- obj \
 --          _put('F')
 -- OG:gen: 
 --  asciiFoo: 
 --        msg1:  -- obj
 --           _put('F')
 --           asciiBar.msg2
 pushThis 
 -- before objTmpStack:add:  3   "ascii "
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ref:gen: console: ref ConsoleIF 
 -- DI:gen: "console: ref ConsoleIF " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%ID BETA " 
 -- $Property:gen: %ID BETA 
 -- genclass:stmt: "%OSDvisibility disguised " 
 -- $Property:gen: %OSDvisibility disguised 
 -- genclass:stmt: "%module LIB, LIB.StringLib " 
 -- $Property:gen: %module LIB, LIB.StringLib 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "BETA "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 3 
 -- Items:GenClass: ascii descNo: 3 isValue: false 
 -- Items:GenClass: ascii descNo: 21 isValue: false 

 CLASS ascii 3 1 BETA 2
 -- Store itemArgs: 
 --  asciiFoo: 
 --     msg1:  -- obj
 --        _put('F')
 --        asciiBar.msg2
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=3 vDescInx=3 vdtTop: 1 
 mvStack 
 -- $val:gen: nl: val 10 
 -- DI:gen: "nl: val 10 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: nl 
 -- $ObjectGenerator:gen: 10 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "10 " 
 -- OG:before:super.gen: "10 "
 -- $Invocation:gen: 10 >useRtnV:"True"superAdj: 0
 -- INV:gen: "10 " 
 -- isConstant: "Invocation ""10 "
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- $ConstLiteral:loadArgs: 10 
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 -- $ConstLiteral:invoke: 10 
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 1 NewOff: 2 
 pushThis 
 storeg nl 2
 -- $val:gen: cr: val 13 
 -- DI:gen: "cr: val 13 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: cr 
 -- $ObjectGenerator:gen: 13 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "13 " 
 -- OG:before:super.gen: "13 "
 -- $Invocation:gen: 13 >useRtnV:"True"superAdj: 0
 -- INV:gen: "13 " 
 -- isConstant: "Invocation ""13 "
 -- needorigin: "13 " 
 -- needOrigin:E: "13 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "13 " rec: "13 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "13 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "13 "E:  "13 "
 -- INV:gen:E.loadArgs "13 "
 -- $ConstLiteral:loadArgs: 13 
 -- INV:gen:after:E.loadArgs "13 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "13 "
 -- $ConstLiteral:invoke: 13 
 pushc 13
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 2 NewOff: 3 
 pushThis 
 storeg cr 3
 -- $val:gen: null: val 0 
 -- DI:gen: "null: val 0 " DI:isConst: true isBasicValue: true 
 --  primNo: 1 
 -- DI:valueObj: null 
 -- $ObjectGenerator:gen: 0 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 " 
 -- OG:before:super.gen: "0 "
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- DI:store:basicValue: off: 3 NewOff: 4 
 pushThis 
 storeg null 4
 -- $var:gen: newline: var char 
 -- DI:gen: "newline: var char " DI:isConst: false isBasicValue: 
 --  true primNo: 3 
 -- DI:gen:primitiveType: newline 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- 
 -- $Assign:gen:  \
 -- newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf> \
 -- --asciiFoo.msg1 
 -- AssignmentStatement:gen: 
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- computeAdrG:superAdj: 0 "newline "
 -- computeAdrG: 1 :rec: "none " E: "newline "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: newline 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: newline >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: newline >ATd.off:5:on:0:superAdj:0newline: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: newline: var char >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"newline":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "newline: var char "ObjectGenerator 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- After:U*U: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- computeAdrG:isLast:E:  "newline "
 -- AssignmentStatement:gen: 
 --  
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  right.label: "ObjectGenerator "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf> \
 -- --asciiFoo.msg1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- OG:before:super.gen: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- 
 -- $Invocation:gen:  \
 -- nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf> \
 -- --asciiFoo.msg1 >useRtnV:"True"superAdj: 0
 -- INV:gen: 
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1
 --  
 -- isConstant: "Invocation ""
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 pushc 10
 -- constLiteral: 10 
 -- OG:gen:end: OIadr: none 
 -- rec: "newline "dstE: "newline "dstE.ATd: "newline: var char " 
 --  useRtn: false 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "
 -- isArgOfAssignI2IwithUniValArg "
 --  newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "arg: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "ObjectGenerator 
 -- arg.super.arg: "
 --  nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
 --  --asciiFoo.msg1 "ObjectInvocation_Unary 
 -- dstDI: "newline: var char " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg ascii$3 5
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "ascii "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 4 
 -- Items:GenClass: Value descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Value 4 0 BETA 2 isValueObj
 -- Store itemArgs: 
 --  %ID Value
 --  %globals
 --  %basic 21
 --  %public
 -- vdtAdd: inx=1 descInx=4 vDescInx=4 vdtTop: 1 
 mvStack 
 -- $Property:gen: %ID Value 
 -- $Property:gen: %globals 
 -- $Property:gen: %basic 21 
 -- $Property:gen: %public 
 -- 
 -- $pattern:gen:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- 
 -- $pattern:gen:  \
 -- <=  :<  \
 --    %basic 52 \
 --    in Veq: var this(Value)
 rtnAlloc 1
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%ID Value " 
 -- $Property:gen: %ID Value 
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "%basic 21 " 
 -- $Property:gen: %basic 21 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "Value "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- vdtAdd: inx=2 descInx=4 vDescInx=11 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=4 vDescInx=58 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 5 
 -- Items:GenClass: integer descNo: 5 isValue: true 
 -- Items:GenClass: integer descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS integer 5 0 BETA 2 isValueObj
 -- Store itemArgs: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- vdtAdd: inx=1 descInx=5 vDescInx=5 vdtTop: 1 
 mvStack 
 -- $Property:gen: %ID integer 
 -- $Property:gen: %basic 1, 32 
 -- $Property:gen: %globals 
 -- $Property:gen: %public 
 -- $var:gen: _thisBasicValue: var Universal 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%ID integer " 
 -- $Property:gen: %ID integer 
 -- genclass:stmt: "%basic 1, 32 " 
 -- $Property:gen: %basic 1, 32 
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "integer "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 6 
 -- Items:GenClass: universal descNo: 6 isValue: true 
 -- Items:GenClass: universal descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS universal 6 0 BETA 2 isValueObj
 -- Store itemArgs: 
 --  %ID universal
 --  %basic 1, 32
 --  %globals
 --  +  : 
 -- vdtAdd: inx=1 descInx=6 vDescInx=6 vdtTop: 1 
 mvStack 
 -- $Property:gen: %ID universal 
 -- $Property:gen: %basic 1, 32 
 -- $Property:gen: %globals 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%ID universal " 
 -- $Property:gen: %ID universal 
 -- genclass:stmt: "%basic 1, 32 " 
 -- $Property:gen: %basic 1, 32 
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 L2:
 -- pushReturn:  "universal "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 7 
 -- Items:GenClass: char descNo: 7 isValue: true 
 -- Items:GenClass: char descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS char 7 0 BETA 2 isValueObj
 -- Store itemArgs: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- vdtAdd: inx=1 descInx=7 vDescInx=7 vdtTop: 1 
 mvStack 
 -- $Property:gen: %id "char" 
 -- $Property:gen: %globals 
 -- $Property:gen: %basic 3, 16 
 -- $Property:gen: %public 
 -- $var:gen: _thisBasicValue: var Universal 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%id "char" " 
 -- $Property:gen: %id "char" 
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "%basic 3, 16 " 
 -- $Property:gen: %basic 3, 16 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "char "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 8 
 -- Items:GenClass: ConsoleIF descNo: 8 isValue: false 
 -- Items:GenClass: ConsoleIF descNo: 21 isValue: false 

 CLASS ConsoleIF 8 1 BETA 2
 -- Store itemArgs: 
 --  put:< 
 --     ...
 --  puttext(T: var LIB.StringLib.String):< 
 --     inner(puttext)
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=8 vDescInx=8 vdtTop: 1 
 mvStack 
 -- 
 -- $pattern:gen:  \
 -- put:<  \
 --    ... 
 -- 
 -- $pattern:gen:  \
 -- puttext(T: var LIB.StringLib.String):<  \
 --    inner(puttext) 
 -- 
 -- $pattern:gen:  \
 -- putint(V: var Integer):<  \
 --    inner(putint) 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "ConsoleIF "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=8 vDescInx=9 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=8 vDescInx=100 vdtTop: 3 
 -- vdtAdd: inx=4 descInx=8 vDescInx=101 vdtTop: 4 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 9 
 -- Items:GenClass: put descNo: 9 isValue: false 
 -- Items:GenClass: put descNo: 21 isValue: false 

 CLASS put 9 1 ConsoleIF 8
 -- Store itemArgs: "... " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=9 vDescInx=9 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "... " 
 -- $Dots:gen: ... 
 L2:
 -- pushReturn:  "put "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 10 
 -- Items:GenClass: String descNo: 10 isValue: false 
 -- Items:GenClass: String descNo: 4 isValue: false 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS String 10 0 StringLib 82
 -- Store itemArgs: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 allocEventQ
 -- vdtAdd: inx=1 descInx=10 vDescInx=10 vdtTop: 1 
 mvStack 
 -- $Property:gen: %id "String pattern" 
 -- $Property:gen: %OSDvisibility disguised 
 -- $Property:gen: %basic 5 
 -- $Property:gen: %public 
 -- 
 -- $pattern:gen:  \
 -- =  ::  \
 --    loop: do  \
 --       c1: var char
 -- 
 -- $pattern:gen:  \
 -- <=  ::  \
 --    loop: obj  \
 --       -- "Hello"  <= "World" since H <= W
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "String pattern" " 
 -- $Property:gen: %id "String pattern" 
 -- genclass:stmt: "%OSDvisibility disguised " 
 -- $Property:gen: %OSDvisibility disguised 
 -- genclass:stmt: "%basic 5 " 
 -- $Property:gen: %basic 5 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "String "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1
 -- vdtAdd: inx=2 descInx=10 vDescInx=13 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=10 vDescInx=84 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 13 
 -- Items:GenClass: = descNo: 13 isValue: false 
 -- Items:GenClass: = descNo: 11 isValue: false 
 -- Items:GenClass: = descNo: 21 isValue: false 
 -- got:sub:vEq:  50  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 21 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 -- OG:reAlloc: descNo: 0 0 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- dataitem:qalloc: "Veq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- dataitem:qalloc: "Beq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 " " 

 CLASS = 11 1 Value 4
 -- Store itemArgs: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  
 -- in Veq: var this(Value) 18 
 -- DI:store: "Veq "
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 L4:
 -- Store:Origin: 21 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=11 vDescInx=11 vdtTop: 1 
 mvStack 
 -- $Property:gen: %basic 50 
 -- $var:gen: in Veq: var this(Value) 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: out Beq: var boolean 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 50 " 
 -- $Property:gen: %basic 50 
 -- genclass:stmt: "inner(= ) " 
 -- $ObjectGenerator:gen: inner(= ) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(= ) " 
 -- OG:before:super.gen: "inner(= ) "
 -- $Invocation:gen: inner(= ) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(= ) " 
 -- isConstant: "Invocation ""inner(= ) "
 -- needorigin: "inner(= ) " 
 -- needOrigin:E: "inner(= ) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(= ) " rec: "inner(= ) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(= ) "originIsValueObj: false 
 --  origin.isPrimitive: true 
 -- KUK 
 -- after:needOrigin: "inner(= ) " 
 -- doNeedOrigin:E: "inner(= ) " 
 -- computeAdrX:superAdj: 0 "inner(= ) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(= ) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(= ) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(= ) >on:2 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(= ) >ATd.off:0 (isPtn):on:2:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(= ) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- computeAdrX:isLast:E:  "inner(= ) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 --  rec:  "inner(= ) "E:  "inner(= ) "
 -- INV:gen:E.loadArgs "inner(= ) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(= ) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:= 
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(= )":descNo:12
 -- INV:gen:after:E.loadArgs "inner(= ) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(= ) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(= ) >rec:"inner(= )" ATd:"pattern" E:"inner(= )" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(= ) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:B: "inner(= ) "E: "inner(= ) " rec: "inner(= ) "
 --   useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(= )" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(= ) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:C: inner(= ) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 L2:
 -- pushReturn:  "= "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- vdtAdd: inx=2 descInx=11 vDescInx=0 vdtTop: 2 
 -- got:sub:vEq:  50  isValueObj:  false 3 
 -- OG:reAlloc: descNo: 0 5 
 --  loop: do 
 --        c1: var char
 --        c2: var char
 --        L: var integer
 -- OG:reAlloc:String: 
 -- currentDcl:this: 
 -- reAllocatedOff: "Veq "2 
 -- dataitem:qalloc: "Beq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- reAllocatedOff: "Beq "3 
 -- reAllocatedOff: "loop "0 

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 -- vdtAdd: inx=2 descInx=13 vDescInx=13 vdtTop: 2 
 -- Store itemArgs: 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- Store:Origin: 5 
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: " "theIS: 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs:  
 rShiftDown  1
 -- hArgOrg:super: = 
 -- Store itemArgs: 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- in Veq: var this(Value) 18 
 pushThis 
 rstoreg  Veq 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=13 vDescInx=11 vdtTop: 2 
 mvStack 
 -- $Property:gen: %basic 50 
 -- $var:gen: in Veq: var this(Value) 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: out Beq: var boolean 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  loop: do 
 --     c1: var char
 --     c2: var char
 --     L: var integer
 -- 
 -- $do:gen:  \
 -- loop: do  \
 --    c1: var char \
 --    c2: var char
 -- 
 -- $ObjectGenerator:gen:  \
 -- c1: var char \
 --    c2: var char \
 --    L: var integer
 -- OG:gen: 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := length
 pushThis 
 -- before objTmpStack:add:  14   "loop "
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "= "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 14 
 -- Items:GenClass: loop descNo: 14 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 14 1 = 13
 -- Store itemArgs: 
 --  c1: var char
 --  c2: var char
 --  L: var integer
 --  L := length
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=14 vDescInx=14 vdtTop: 1 
 mvStack 
 -- $var:gen: c1: var char 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- $var:gen: c2: var char 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 -- $var:gen: L: var integer 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := length " 
 -- $Assign:gen: L := length 
 -- AssignmentStatement:gen: "L := length " 
 -- computeAdrG:superAdj: 0 "L "
 -- computeAdrG: 1 :rec: "none " E: "L "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:4:on:0:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrG:isLast:E:  "L "
 -- AssignmentStatement:gen: 
 --  "L := length " right.label: "ObjectGenerator ""length " 
 -- $ObjectGenerator:gen: length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "length " 
 -- OG:before:super.gen: "length "
 -- $Invocation:gen: length >useRtnV:"True"superAdj: 0 descNo: 15
 -- INV:gen: "length " 
 -- isConstant: "Invocation ""length "
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: length 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: length >on:2 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- 
 -- $ObjectInvocation_Unary:getAdr: length >ATd.off:0 (isPtn):on:2:superAdj:0 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length " ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length":descNo:15
 -- ptn:loadArgs:E: "length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: length >rec:"length" ATd:"pattern" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "length "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length "E: "length " rec: "length " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length" useRTNv: "True"
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- rec: "L "dstE: "L "dstE.ATd: "L: var integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "length "
 -- isArgOfAssignI2IwithUniValArg "L := length "arg: "length "
 --  ObjectGenerator 
 -- arg.super.arg: "length "ObjectInvocation_Unary 
 -- dstDI: "L: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 4
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (L <> Veq.length) :then  \
 --    leave(loop) >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- OG:before:super.gen: "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- 
 -- $Invocation:gen:  \
 -- if (L <> Veq.length) :then  \
 --    leave(loop) >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- isConstant: "Invocation ""
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 -- needorigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  rec: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L <> Veq.length) :then 
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L <> Veq.length) :then 
 --     leave(loop) "E:  "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 -- INV:gen:E.loadArgs "if (L <> Veq.length) :then 
 --     leave(loop) "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (L <> Veq.length) :then  \
 --    leave(loop) 
 -- INV:gen:after:E.loadArgs "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L <> Veq.length) :then 
 --     leave(loop) "
 -- 
 -- $IfThen:invoke:  \
 -- if (L <> Veq.length) :then  \
 --    leave(loop) 
 -- 
 -- $IfThen:gen:  \
 -- if (L <> Veq.length) :then  \
 --    leave(loop) 
 -- $ObjectGenerator:gen: (L <> Veq.length) >OGid:"<>" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(L <> Veq.length) " 
 -- OG:before:super.gen: "(L <> Veq.length) "
 -- $Invocation:gen: (L <> Veq.length) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(L <> Veq.length) " 
 -- isConstant: "Invocation ""(L <> Veq.length) "
 -- needorigin: "(L <> Veq.length) " 
 -- needOrigin:E: "(L <> Veq.length) "  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L <> Veq.length) " rec: "(L <> Veq.length) " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 55
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(L <> Veq.length) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L <> Veq.length) " 
 -- doNeedOrigin:E: "(L <> Veq.length) " 
 -- computeAdrX:superAdj: 0 "(L <> Veq.length) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L <> Veq.length) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (L <> Veq.length) 
 -- $BracketedExp:loadOrigin: (L <> Veq.length) 
 -- computeAdrG:superAdj: 0 "L <> Veq.length "
 -- computeAdrG: 1 :rec: "none " E: "L <> Veq.length "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L <> Veq.length 
 -- $BinOp:loadOrigin: L <> Veq.length 
 -- BinaryExp:loadOrigin:empty: "L <> Veq.length "superAdj: 0 
 -- $BinOp:getAdr: L <> Veq.length 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "L <> Veq.length "
 -- BE:loadOrigin:E: L <> Veq.length 
 -- $BinOp:getAdr: L <> Veq.length 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L <> Veq.length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L <> Veq.length "E:  "L <> Veq.length "
 -- INV:gen:E.loadArgs "L <> Veq.length "
 -- $BinOp:loadArgs: L <> Veq.length 
 -- BinaryExp:loadArgs: "L <> Veq.length " superAdj: 0 
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 0
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:4:on:0:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:0
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:4 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 4 loop$14
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L <> Veq.length "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- $pattern:loadArgs:  \
 -- <>  :  \
 --    %basic 55 \
 --    in V: var integer
 -- ptn:loadArgs:E: "<> Veq.length " 
 -- args: "Veq.length " 
 -- E: "ObjectGenerator "Veq.length 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "<> Veq.length " "ObjectInvocation_Binary " ActArg: "
 --  Veq.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> Veq.length "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: Veq.length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "Veq.length " 
 -- OG:before:super.gen: "Veq.length "
 -- $Invocation:gen: Veq.length >useRtnV:"True"superAdj: 0 descNo: 15
 -- INV:gen: "Veq.length " 
 -- isConstant: "Invocation ""Veq.length "
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "Veq " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "Veq.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Veq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Veq >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: Veq >ATd.off:2:on:1:superAdj:0in Veq: var this(Value):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  c1: var char
 --     c2: var char
 --     L: var integer
 --     L := length
 --     if (L <> Veq.length) :then 
 --        leave(loop)
 --     beq := true
 --     for(1):to(length):repeat
 --        c1 := get[inx]
 --        c2 := Veq.get[inx]
 --        if (c1 <> c2) :then 
 --           Beq := false
 --           leave(loop)
 --      
 -- BOBS:ATd: "in Veq: var this(Value) "
 -- String:vEq:  "Veq "off:  2 ATd: "in Veq: var this(Value) " 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Veq " ATd: "in Veq: var this(Value) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_Unary:getAdr: length >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "length " 
 --  false true 
 -- $ObjectInvocation_Unary:loadArgs: Veq >staticOff:0 in Veq: var this(Value) superAdj:0
 -- $var:loadArgs: in Veq: var this(Value) >E:"Veq"
 -- 
 -- $pattern:loadArgs:  \
 -- this:  \
 --    %basic 18 \
 --    in this: ref Object >E:"Veq":descNo:31
 -- computeAdrX:before:rec:: "Veq " 
 -- $ObjectInvocation_Unary:invoke: Veq >rec:"Veq" ATd:"var" isValueObj E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "Veq "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "Veq "E: "length " rec: "Veq " useRtnV: true "
 --  in Veq: var this(Value) " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: in Veq: var this(Value) E: "length">newOff:2 useRTNv: "True"
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$14 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: Veq :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- checkInt2IntWithUnitArg:rec: "Veq "E: "length "
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length":descNo:15
 -- ptn:loadArgs:E: "length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- $ObjectInvocation_Unary:invoke: length >rec:"Veq" ATd:"pattern" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "length "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "length "E: "length " rec: "Veq " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length" useRTNv: "True"
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "Veq.length ":isBasicVal: true 
 -- case:B: Veq.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "<> Veq.length "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L <> Veq.length "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L <> Veq.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: L <> Veq.length 
 -- BinaryExp:invoke: "L "rec: "L <> Veq.length "
 -- M: "<> Veq.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: <> Veq.length >rec:"L" ATd:"pattern" E:"<> Veq.length" E.ATd:<>   unique:"False"
 -- OI:invoke: "<> Veq.length "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "<> Veq.length "E: "<> Veq.length " rec: "L "
 --   useRtnV: true 
 --  <>  : 
 --     %basic 55
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- 
 -- $pattern:invoke:  \
 -- <>  :  \
 --    %basic 55 \
 --    in V: var integer
 -- ptn:invoke: "<>   "E: "<> Veq.length "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L "E: "<> Veq.length "
 -- arg:other 
 ne
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- OI:invoke:C: <> Veq.length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: leave(loop) >OGid:"$18" singular! staticOff=0 descNo=18 superAdj=0
 -- OG:gen: "leave(loop) " 
 pushThis 
 -- before objTmpStack:add:  18   "$18 "
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: "beq := true " 
 -- $Assign:gen: beq := true 
 -- AssignmentStatement:gen: "beq := true " 
 -- computeAdrG:superAdj: 0 "beq "
 -- computeAdrG: 1 :rec: "none " E: "beq "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: beq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: beq >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: beq >ATd.off:3:on:1:superAdj:0out Beq: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out Beq: var boolean >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"beq":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "beq " ATd: "out Beq: var boolean " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- computeAdrG:isLast:E:  "beq "
 -- AssignmentStatement:gen: 
 --  "beq := true " right.label: "ObjectGenerator ""true " 
 -- $ObjectGenerator:gen: true >OGid:"True" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "true " 
 -- OG:before:super.gen: "true "
 -- $Invocation:gen: true >useRtnV:"True"superAdj: 0 descNo: 23
 -- INV:gen: "true " 
 -- isConstant: "Invocation ""true "
 -- needorigin: "true " 
 -- needOrigin:E: "true "  E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  Ex: "true " rec: "true " E.ATd: 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- after:needOrigin: "true " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "true "E:  "true "
 -- INV:gen:E.loadArgs "true "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: true >staticOff:0  \
 -- True:  \
 --    %globals \
 --    out B: var boolean
 -- 
 -- $pattern:loadArgs:  \
 -- True:  \
 --    %globals \
 --    out B: var boolean
 -- ptn:loadArgs:E: "true " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "true "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true "
 -- $ObjectInvocation_Unary:invoke: true >rec:"true" ATd:"pattern" E:"true" E.ATd:True unique:"False"
 -- OI:invoke: "true "
 -- 
 -- OI:invoke:B: "true "E: "true " rec: "true " useRtnV: true 
 --  True: 
 --     %globals
 --     out B: var boolean
 --     B := 1
 --  
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- 
 -- $pattern:invoke:  \
 -- True:  \
 --    %globals \
 --    out B: var boolean
 -- ptn:invoke: "True "E: "true "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "true " 
 --  adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: true :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "beq "dstE: "beq "dstE.ATd: "out Beq: var boolean " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "true "
 -- isArgOfAssignI2IwithUniValArg "beq := true "arg: "true "
 --  ObjectGenerator 
 -- arg.super.arg: "true "ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- 
 -- $ObjectGenerator:gen:  \
 -- for(1):to(length):repeat \
 --    c1 := get[inx] \
 --    c2 := Veq.get[inx]
 -- OG:gen: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30 "
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "loop "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 15 
 -- Items:GenClass: length descNo: 15 isValue: false 
 -- Items:GenClass: length descNo: 21 isValue: false 

 CLASS length 15 1 String 10
 -- Store itemArgs: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=15 vDescInx=15 vdtTop: 1 
 mvStack 
 -- $var:gen: out V: var integer 
 -- DI:gen: "out V: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "
 --  V := get[0] -- actually an index error, accessing length " 
 -- $Assign:gen: V := get[0] -- actually an index error, accessing length 
 -- AssignmentStatement:gen: "
 --  V := get[0] -- actually an index error, accessing length " 
 -- computeAdrG:superAdj: 0 "V "
 -- computeAdrG: 1 :rec: "none " E: "V "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:2:on:0:superAdj:0out V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length 
 -- $var:getAdr: out V: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "out V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrG:isLast:E:  "V "
 -- AssignmentStatement:gen: 
 --  "V := get[0] -- actually an index error, accessing length " 
 --  right.label: "ObjectGenerator ""
 --  get[0] -- actually an index error, accessing length " 
 -- $ObjectGenerator:gen: get[0] -- actually an index error, accessing length >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "get[0] -- actually an index error, accessing length " 
 -- OG:before:super.gen: "
 --  get[0] -- actually an index error, accessing length "
 -- $Invocation:gen: get[0] -- actually an index error, accessing length >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "get[0] -- actually an index error, accessing length " 
 -- isConstant: "Invocation ""
 --  get[0] -- actually an index error, accessing length "
 -- needorigin: "
 --  get[0] -- actually an index error, accessing length " 
 -- needOrigin:E: "
 --  get[0] -- actually an index error, accessing length "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[0] -- actually an index error, accessing length " rec: "
 --  get[0] -- actually an index error, accessing length " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "
 --  get[0] -- actually an index error, accessing length "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "
 --  get[0] -- actually an index error, accessing length " 
 -- doNeedOrigin:E: "
 --  get[0] -- actually an index error, accessing length " 
 -- computeAdrX:superAdj: 0 "
 --  get[0] -- actually an index error, accessing length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  get[0] -- actually an index error, accessing length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: get[0] -- actually an index error, accessing length 
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: get[0] -- actually an index error, accessing length >on:1 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "length "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg length$15 1
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[0] -- actually an index error, accessing length >ATd.off:0 (isPtn):on:1:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  out V: var integer
 --     V := get[0] -- actually an index error, accessing length 
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "
 --  get[0] -- actually an index error, accessing length " ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- computeAdrX:isLast:E:  "
 --  get[0] -- actually an index error, accessing length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 --  rec:  "get[0] -- actually an index error, accessing length "E:  "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen:E.loadArgs "
 --  get[0] -- actually an index error, accessing length "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[0] -- actually an index error, accessing length >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:0
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[0] -- actually an index error, accessing length":descNo:16
 -- ptn:loadArgs:E: "
 --  get[0] -- actually an index error, accessing length " 
 -- args: "get[0] " 
 -- E: "ObjectGenerator "0 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[0] -- actually an index error, accessing length " "
 --  ObjectInvocation_KeyWord " ActArg: "0 "isValue: true formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  get[0] -- actually an index error, accessing length " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 0 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 " 
 -- OG:before:super.gen: "0 "
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "
 --  get[0] -- actually an index error, accessing length "
 -- INV:gen:after:E.loadArgs "
 --  get[0] -- actually an index error, accessing length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "
 --  get[0] -- actually an index error, accessing length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: get[0] -- actually an index error, accessing length >rec:"get[0] -- actually an index error, accessing length" ATd:"pattern" E:"get[0] -- actually an index error, accessing length" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[0] -- actually an index error, accessing length "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- OI:invoke:B: "get[0] -- actually an index error, accessing length "
 --  E: "get[0] -- actually an index error, accessing length " rec: "
 --  get[0] -- actually an index error, accessing length " useRtnV: true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[0] -- actually an index error, accessing length" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "
 --  get[0] -- actually an index error, accessing length "ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- OI:invoke:C: get[0] -- actually an index error, accessing length 
 --  :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an index error, accessing length 
 -- rec: "V "dstE: "V "dstE.ATd: "out V: var integer " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "get[0] -- actually an index error, accessing length "
 -- isArgOfAssignI2IwithUniValArg "
 --  V := get[0] -- actually an index error, accessing length "arg: "get[0] -- actually an index error, accessing length "
 --  ObjectGenerator 
 -- arg.super.arg: "
 --  get[0] -- actually an index error, accessing length "ObjectInvocation_KeyWord 
 -- dstDI: "out V: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg length$15 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "length "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 31 
 -- Items:GenClass: this descNo: 31 isValue: false 
 -- Items:GenClass: this descNo: 21 isValue: false 

 CLASS this 31 1 BETA 2
 -- Store itemArgs: 
 --  %basic 18
 --  in this: ref Object
 --  
 -- in this: ref Object 64 
 -- DI:store: "this "
 pushThis 
 rstoreg  this 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=31 vDescInx=31 vdtTop: 1 
 mvStack 
 -- $Property:gen: %basic 18 
 -- $ref:gen: in this: ref Object 
 -- DI:gen: "in this: ref Object " DI:isConst: false isBasicValue: 
 --  false primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 18 " 
 -- $Property:gen: %basic 18 
 L2:
 -- pushReturn:  "this "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 32 
 -- Items:GenClass: X_asString descNo: 32 isValue: false 
 -- Items:GenClass: X_asString descNo: 21 isValue: false 

 CLASS X_asString 32 1 Object 21
 -- Store itemArgs: 
 --  out S: var LIB.StringLib.String
 --  inner(X_asString)
 --  
 -- Store:Origin: 64 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=32 vDescInx=32 vdtTop: 1 
 mvStack 
 -- $var:gen: out S: var LIB.StringLib.String 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(X_asString) " 
 -- $ObjectGenerator:gen: inner(X_asString) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(X_asString) " 
 -- OG:before:super.gen: "inner(X_asString) "
 -- $Invocation:gen: inner(X_asString) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(X_asString) " 
 -- isConstant: "Invocation ""inner(X_asString) "
 -- needorigin: "inner(X_asString) " 
 -- needOrigin:E: "inner(X_asString) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(X_asString) " rec: "inner(X_asString) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(X_asString) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(X_asString) " 
 -- doNeedOrigin:E: "inner(X_asString) " 
 -- computeAdrX:superAdj: 0 "inner(X_asString) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(X_asString) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(X_asString) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(X_asString) >on:2 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(X_asString) >ATd.off:0 (isPtn):on:2:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(X_asString) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- computeAdrX:isLast:E:  "inner(X_asString) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 --  rec:  "inner(X_asString) "E:  "inner(X_asString) "
 -- INV:gen:E.loadArgs "inner(X_asString) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(X_asString) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:X_asString
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(X_asString)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(X_asString) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(X_asString) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(X_asString) >rec:"inner(X_asString)" ATd:"pattern" E:"inner(X_asString)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(X_asString) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- OI:invoke:B: "inner(X_asString) "E: "inner(X_asString) " rec: "
 --  inner(X_asString) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(X_asString)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(X_asString) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- OI:invoke:C: inner(X_asString) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 L2:
 -- pushReturn:  "X_asString "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=32 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 33 
 -- Items:GenClass: LIB descNo: 33 isValue: false 
 -- Items:GenClass: LIB descNo: 21 isValue: false 

 CLASS LIB 33 1 BETAworld 1
 -- Store itemArgs: 
 --  %id "LIB"
 --  %module BETA
 --  %Include BETA
 --  x_dummy_LIB: var integer
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=33 vDescInx=33 vdtTop: 1 
 mvStack 
 -- $Property:gen: %id "LIB" 
 -- $Property:gen: %module BETA 
 -- Module:genMI:  "BasicIO "
 -- 
 -- $obj:gen:  \
 -- BasicIO: obj  \
 --    %module LIB.StringLib \
 --    %Public
 -- 
 -- $ObjectGenerator:gen:  \
 -- %module LIB.StringLib \
 --    %Public \
 --    Lock: 
 -- OG:gen: 
 --  %module LIB.StringLib
 --     %Public
 --     Lock: 
 --        dummy: var integer
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO "
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "Dimensions "
 -- 
 -- $obj:gen:  \
 -- Dimensions: obj  \
 --    %domain_boundary \
 --    %public
 -- 
 -- $ObjectGenerator:gen:  \
 -- %domain_boundary \
 --    %public \
 --    Dimension: 
 -- OG:gen: 
 --  %domain_boundary
 --     %public
 --     Dimension: 
 --        %dimension "-top-"
 pushThis 
 -- before objTmpStack:add:  38   "Dimensions "
 invoke Dimensions 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "StringLib "
 -- 
 -- $obj:gen:  \
 -- StringLib: obj  \
 --    %id "String module" \
 --    %module LIB
 -- 
 -- $ObjectGenerator:gen:  \
 -- %id "String module" \
 --    %module LIB \
 --    %public
 -- OG:gen: 
 --  %id "String module"
 --     %module LIB
 --     %public
 --     String: Value
 pushThis 
 -- before objTmpStack:add:  82   "StringLib "
 invoke StringLib 82 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $Property:gen: %Include BETA 
 -- $var:gen: x_dummy_LIB: var integer 
 -- DI:gen: "x_dummy_LIB: var integer " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: x_dummy_LIB 
 -- 
 -- $ModuleItem:gen:  \
 -- --AgentSystem \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Associations \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --BasicIO \
 --  
 -- ModuleItem:gen BasicIO 
 -- 
 -- $obj:gen:  \
 -- BasicIO: obj  \
 --    %module LIB.StringLib \
 --    %Public
 -- 
 -- $ModuleItem:gen:  \
 -- --BasicSystemLib \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --COsystem \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Collections \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Compiler \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Complex \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --DateTimeLib \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Dimensions \
 --  
 -- ModuleItem:gen Dimensions 
 -- 
 -- $obj:gen:  \
 -- Dimensions: obj  \
 --    %domain_boundary \
 --    %public
 -- 
 -- $ModuleItem:gen:  \
 -- --EMC2array \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Embedded \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --FileSys \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ForkJoinSystem \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MetaSystem \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MonitorSystemLib \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --NonBlockingIO \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --RandomNumberGeneratorLib \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --SimpleConcurrentProcesses \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Socket \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --SocketSystem \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --StringLib \
 --  
 -- ModuleItem:gen StringLib 
 -- 
 -- $obj:gen:  \
 -- StringLib: obj  \
 --    %id "String module" \
 --    %module LIB
 -- 
 -- $ModuleItem:gen:  \
 -- --Xarray \
 --  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "LIB" " 
 -- $Property:gen: %id "LIB" 
 -- genclass:stmt: "%module BETA " 
 -- $Property:gen: %module BETA 
 -- genclass:stmt: "%Include BETA " 
 -- $Property:gen: %Include BETA 
 L2:
 -- pushReturn:  "LIB "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 34 
 -- Items:GenClass: BasicIO descNo: 34 isValue: false 
 -- Items:GenClass: BasicIO descNo: 21 isValue: false 

 CLASS BasicIO 34 1 LIB 33
 -- Store itemArgs: 
 --  %module LIB.StringLib
 --  %Public
 --  Lock: 
 --     dummy: var integer
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=34 vDescInx=34 vdtTop: 1 
 mvStack 
 -- $Property:gen: %module LIB.StringLib 
 -- $Property:gen: %Public 
 -- 
 -- $obj:gen:  \
 -- keyboard: obj  \
 --    %Public \
 --    readLine: 
 -- DI:gen: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.StringDI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: keyboard 
 -- DI:off: 2 this: 
 --  keyboard: obj 
 --     %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- %Public \
 --    readLine:  \
 --       out M: var LIB.StringLib.String
 -- OG:gen: 
 --  %Public
 --     readLine: 
 --        out M: var LIB.StringLib.String
 --        inx: var integer
 pushThis 
 -- before objTmpStack:add:  35   "keyboard "
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $obj:gen:  \
 -- screen: obj  \
 --    L: obj Lock \
 --    %Public
 -- DI:gen: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: screen 
 -- DI:off: 3 this: 
 --  screen: obj 
 --     L: obj Lock
 --     %Public
 --     init: 
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- L: obj Lock \
 --    %Public \
 --    init: 
 -- OG:gen: 
 --  L: obj Lock
 --     %Public
 --     init: 
 --        L.get
 pushThis 
 -- before objTmpStack:add:  36   "screen "
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%module LIB.StringLib " 
 -- $Property:gen: %module LIB.StringLib 
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 -- pushReturn:  "BasicIO "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 35 
 -- Items:GenClass: keyboard descNo: 35 isValue: false 
 -- Items:GenClass: keyboard descNo: 21 isValue: false 

 CLASS keyboard 35 1 BasicIO 34
 -- Store itemArgs: 
 --  %Public
 --  readLine: 
 --     out M: var LIB.StringLib.String
 --     inx: var integer
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=35 vDescInx=35 vdtTop: 1 
 mvStack 
 -- $Property:gen: %Public 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 -- pushReturn:  "keyboard "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 36 
 -- Items:GenClass: screen descNo: 36 isValue: false 
 -- Items:GenClass: screen descNo: 21 isValue: false 

 CLASS screen 36 1 BasicIO 34
 -- Store itemArgs: 
 --  L: obj Lock
 --  %Public
 --  init: 
 --     L.get
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=36 vDescInx=36 vdtTop: 1 
 mvStack 
 -- $obj:gen: L: obj Lock 
 -- DI:gen: "L: obj Lock " DI:isConst: true isBasicValue: false 
 --  primNo: 0 
 -- DI:isConst: L 
 -- DI:off: 2 this: "L: obj Lock " 
 --  
 -- $ObjectGenerator:gen: Lock >OGid:"Lock" IS.isempty! staticOff=2 descNo=0 superAdj=0
 -- OG:gen: "Lock " 
 -- OG:before:super.gen: "Lock "
 -- $Invocation:gen: Lock >useRtnV:"False"superAdj: 0 descNo: 37
 -- INV:gen: "Lock " 
 -- isConstant: "Invocation ""Lock "
 -- needorigin: "Lock " 
 -- needOrigin:E: "Lock "  E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integerEx: "Lock " rec: "Lock " E.ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integerE.ATd.desc: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: E.ATd.IT: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- doNeedOrigin:Ex: "Lock "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Lock " 
 -- doNeedOrigin:E: "Lock " 
 -- computeAdrX:superAdj: 0 "Lock " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Lock " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Lock 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Lock >on:1 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "screen "on: 1 isValueObj: false 
 --  origin: BasicIO origin:isValueObj: false 
 rpushg screen$36 1
 -- 
 -- $ObjectInvocation_Unary:getAdr: Lock >ATd.off:0 (isPtn):on:1:superAdj:0 \
 -- Lock:  \
 --    dummy: var integer \
 --    %Public
 -- 
 -- $pattern:getAdr:  \
 -- Lock:  \
 --    dummy: var integer \
 --    %Public
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Lock " ATd: 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- computeAdrX:isLast:E:  "Lock "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 --  rec:  "Lock "E:  "Lock "
 -- INV:gen:E.loadArgs "Lock "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: Lock >staticOff:0  \
 -- Lock:  \
 --    dummy: var integer \
 --    %Public
 -- 
 -- $pattern:loadArgs:  \
 -- Lock:  \
 --    dummy: var integer \
 --    %Public
 -- ptn:loadArgs:E: "Lock " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "Lock "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Lock "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- $ObjectInvocation_Unary:invoke: Lock >rec:"Lock" ATd:"pattern" E:"Lock" E.ATd:Lock unique:"False"
 -- OI:invoke: "Lock "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- OI:invoke:B: "Lock "E: "Lock " rec: "Lock " useRtnV: false 
 --  Lock: 
 --     dummy: var integer
 --     %Public
 --     M: var integer
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- 
 -- $pattern:invoke:  \
 -- Lock:  \
 --    dummy: var integer \
 --    %Public
 -- ptn:invoke: "Lock "E: "Lock "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 rec: "Lock " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- OI:invoke:C: Lock :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- $Property:gen: %Public 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 -- pushReturn:  "screen "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 37 
 -- Items:GenClass: Lock descNo: 37 isValue: false 
 -- Items:GenClass: Lock descNo: 21 isValue: false 

 CLASS Lock 37 1 BasicIO 34
 -- Store itemArgs: 
 --  dummy: var integer
 --  %Public
 --  M: var integer
 --  init: 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=37 vDescInx=37 vdtTop: 1 
 mvStack 
 -- $var:gen: dummy: var integer 
 -- DI:gen: "dummy: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: dummy 
 -- $Property:gen: %Public 
 -- $var:gen: M: var integer 
 -- DI:gen: "M: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: M 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 -- pushReturn:  "Lock "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 38 
 -- Items:GenClass: Dimensions descNo: 38 isValue: false 
 -- Items:GenClass: Dimensions descNo: 21 isValue: false 

 CLASS Dimensions 38 1 LIB 33
 -- Store itemArgs: 
 --  %domain_boundary
 --  %public
 --  Dimension: 
 --     %dimension "-top-"
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=38 vDescInx=38 vdtTop: 1 
 mvStack 
 -- $Property:gen: %domain_boundary 
 -- $Property:gen: %public 
 -- 
 -- $ModuleItem:gen:  \
 -- --Acceleration \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --AmountOfSubstance \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --AngularAcceleration \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Area \
 --  
 -- ModuleItem:gen Area 
 -- 
 -- $obj:gen:  \
 -- Area: obj Dimension \
 --    %dimension "A", "L*L" \
 --    %requires Length
 -- 
 -- $ObjectGenerator:gen:  \
 -- Dimension \
 --    %dimension "A", "L*L" \
 --    %requires Length
 -- OG:gen: 
 --  Dimension
 --     %dimension "A", "L*L"
 --     %requires Length
 --     %Public
 pushThis 
 -- before objTmpStack:add:  66   "Area "
 invoke Area 66 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ModuleItem:gen:  \
 -- --Currency \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Density \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ElectricCurrent \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ElectricFrequency \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ElectricPower \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ElectricVoltage \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Energy \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Force \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Length \
 --  
 -- ModuleItem:gen Length 
 -- 
 -- $obj:gen:  \
 -- Length: obj Dimension \
 --    %dimension "L" \
 --    %requires Area
 -- 
 -- $ObjectGenerator:gen:  \
 -- Dimension \
 --    %dimension "L" \
 --    %requires Area
 -- OG:gen: 
 --  Dimension
 --     %dimension "L"
 --     %requires Area
 --     %Public
 pushThis 
 -- before objTmpStack:add:  72   "Length "
 invoke Length 72 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ModuleItem:gen:  \
 -- --LuminousIntensity \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MagneticFluxDensity \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Mass \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MassFlowRate \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MeterPowerN \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --RadioNuclide \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Temperature \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ThermodynamicTemperature \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Time \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Velocity \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Volume \
 --  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%domain_boundary " 
 -- $Property:gen: %domain_boundary 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "Dimensions "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 39 
 -- Items:GenClass: Dimension descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Dimension 39 1 Dimensions 38
 -- Store itemArgs: 
 --  %dimension "-top-"
 --  %public
 --  PrimaryUnit:< Unit
 --  Unit: Value
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=39 vDescInx=39 vdtTop: 1 
 mvStack 
 -- $Property:gen: %dimension "-top-" 
 -- $Property:gen: %public 
 -- $pattern:gen: PrimaryUnit:< Unit 
 -- 
 -- $pattern:gen:  \
 -- symbol:<  \
 --    %globals \
 --    out T: var StringLib.String
 -- $pattern:gen: MultArgL:< Unit 
 -- $pattern:gen: MultArgR:< Unit 
 -- $pattern:gen: MultRes:< Unit 
 -- 
 -- $pattern:gen:  \
 -- gMult:<  \
 --    in L: var MultArgL \
 --    in R: var MultArgR
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "-top-" " 
 -- $Property:gen: %dimension "-top-" 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 -- genclass:stmt: "inner(Dimension) " 
 -- $ObjectGenerator:gen: inner(Dimension) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(Dimension) " 
 -- OG:before:super.gen: "inner(Dimension) "
 -- $Invocation:gen: inner(Dimension) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(Dimension) " 
 -- isConstant: "Invocation ""inner(Dimension) "
 -- needorigin: "inner(Dimension) " 
 -- needOrigin:E: "inner(Dimension) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Dimension) " rec: "inner(Dimension) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Dimension) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Dimension) " 
 -- doNeedOrigin:E: "inner(Dimension) " 
 -- computeAdrX:superAdj: 0 "inner(Dimension) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Dimension) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(Dimension) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(Dimension) >on:2 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(Dimension) >ATd.off:0 (isPtn):on:2:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(Dimension) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 -- computeAdrX:isLast:E:  "inner(Dimension) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 --  rec:  "inner(Dimension) "E:  "inner(Dimension) "
 -- INV:gen:E.loadArgs "inner(Dimension) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(Dimension) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:Dimension
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(Dimension)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(Dimension) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Dimension) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(Dimension) >rec:"inner(Dimension)" ATd:"pattern" E:"inner(Dimension)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(Dimension) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- OI:invoke:B: "inner(Dimension) "E: "inner(Dimension) " rec: "
 --  inner(Dimension) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(Dimension)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(Dimension) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  8
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- OI:invoke:C: inner(Dimension) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 L2:
 -- pushReturn:  "Dimension "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=8 descInx=39 vDescInx=0 vdtTop: 8 
 -- vdtAdd: inx=2 descInx=39 vDescInx=44 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=39 vDescInx=63 vdtTop: 8 
 -- vdtAdd: inx=4 descInx=39 vDescInx=45 vdtTop: 8 
 -- vdtAdd: inx=5 descInx=39 vDescInx=46 vdtTop: 8 
 -- vdtAdd: inx=6 descInx=39 vDescInx=47 vdtTop: 8 
 -- vdtAdd: inx=7 descInx=39 vDescInx=64 vdtTop: 8 

 CLASS PrimaryUnit#44 44 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 44  newDescNo:  39 

 CLASS MultArgL#45 45 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 45  newDescNo:  39 

 CLASS MultArgR#46 46 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 46  newDescNo:  39 

 CLASS MultRes#47 47 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 47  newDescNo:  39 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 40 
 -- Items:GenClass: Unit descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Unit 40 0 Dimension 39 isValueObj
 -- Store itemArgs: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 -- vdtAdd: inx=1 descInx=40 vDescInx=40 vdtTop: 1 
 mvStack 
 -- $Property:gen: %unit "U", 1 
 -- $Property:gen: %public 
 -- $var:gen: magnitude: var Float 
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 -- $pattern:gen: thisUnit:< Unit 
 -- $pattern:gen: argUnit:< Unit 
 -- $pattern:gen: resUnit:< Unit 
 -- 
 -- $pattern:gen:  \
 -- toPrimary:<  \
 --    out base: var PrimaryUnit \
 --    inner(toPrimary) 
 -- 
 -- $pattern:gen:  \
 -- fromPrimary:<  \
 --    in base: var PrimaryUnit \
 --    inner(fromPrimary) 
 -- 
 -- $pattern:gen:  \
 -- print:<  \
 --    "Unit:".print \
 --    inner(print)
 rtnAlloc 1
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%unit "U", 1 " 
 -- $Property:gen: %unit "U", 1 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "Unit "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=40 vDescInx=49 vdtTop: 7 
 -- vdtAdd: inx=8 descInx=40 vDescInx=50 vdtTop: 8 
 -- vdtAdd: inx=9 descInx=40 vDescInx=51 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 48 
 -- Items:GenClass: float descNo: 48 isValue: true 
 -- Items:GenClass: float descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS float 48 0 BETA 2 isValueObj
 -- Store itemArgs: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- vdtAdd: inx=1 descInx=48 vDescInx=48 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 -- $Property:gen: %basic 9 
 -- $var:gen: _thisBasicValue: var Float 
 -- DI:gen: "_thisBasicValue: var Float " DI:isConst: false 
 --  isBasicValue: true primNo: 9 
 -- DI:gen:primitiveType: _thisBasicValue 
 -- $Property:gen: %public 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "%basic 9 " 
 -- $Property:gen: %basic 9 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "float "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 49 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 49 1 Unit 40
 -- Store itemArgs: 
 --  out base: var PrimaryUnit
 --  inner(toPrimary)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=49 vDescInx=49 vdtTop: 1 
 mvStack 
 -- $var:gen: out base: var PrimaryUnit 
 -- DI:gen: "out base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- DI:off: 2 this: "out base: var PrimaryUnit " 
 --  
 -- $ObjectGenerator:gen: PrimaryUnit >OGid:"Unit" IS.isempty! staticOff=2 descNo=0 superAdj=0
 -- OG:gen: "PrimaryUnit " 
 -- OG:before:super.gen: "PrimaryUnit "
 -- $Invocation:gen: PrimaryUnit >useRtnV:"False"superAdj: 0 descNo: 0
 -- INV:gen: "PrimaryUnit " 
 -- isConstant: "Invocation ""PrimaryUnit "
 -- needorigin: "PrimaryUnit " 
 -- needOrigin:E: "PrimaryUnit "  E.ATd: "PrimaryUnit:< Unit " Ex: "
 --  PrimaryUnit " rec: "PrimaryUnit " E.ATd: "PrimaryUnit:< Unit " E.ATd.desc: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< UnitE.ATd.IT: " " 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- after:needOrigin: "PrimaryUnit " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PrimaryUnit "E:  "PrimaryUnit "
 -- INV:gen:E.loadArgs "PrimaryUnit "
 -- $ObjectInvocation_Unary:loadArgs: PrimaryUnit >staticOff:0 PrimaryUnit:< Unit superAdj:0
 -- $pattern:loadArgs: PrimaryUnit:< Unit >E:"PrimaryUnit":descNo:0
 -- ptn:loadArgs:E: "PrimaryUnit " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "PrimaryUnit "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  PrimaryUnit "
 -- $ObjectInvocation_Unary:invoke: PrimaryUnit >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:PrimaryUnit unique:"False"
 -- OI:invoke: "PrimaryUnit "
 -- 
 -- OI:invoke:B: "PrimaryUnit "E: "PrimaryUnit " rec: "PrimaryUnit "
 --   useRtnV: false "PrimaryUnit:< Unit " 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: PrimaryUnit:< Unit E: "PrimaryUnit" useRTNv: "False"
 -- ptn:invoke: "PrimaryUnit "E: "PrimaryUnit "ptnKind: 1 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 2 rec: "PrimaryUnit " 
 --  adr:none 
 -- isStatic: true rec: "PrimaryUnit "
 invokeVal  PrimaryUnit 40 1
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(toPrimary) " 
 -- $ObjectGenerator:gen: inner(toPrimary) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(toPrimary) " 
 -- OG:before:super.gen: "inner(toPrimary) "
 -- $Invocation:gen: inner(toPrimary) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(toPrimary) " 
 -- isConstant: "Invocation ""inner(toPrimary) "
 -- needorigin: "inner(toPrimary) " 
 -- needOrigin:E: "inner(toPrimary) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(toPrimary) " rec: "inner(toPrimary) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(toPrimary) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(toPrimary) " 
 -- doNeedOrigin:E: "inner(toPrimary) " 
 -- computeAdrX:superAdj: 0 "inner(toPrimary) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(toPrimary) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(toPrimary) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(toPrimary) >on:4 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(toPrimary) >ATd.off:0 (isPtn):on:4:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(toPrimary) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- computeAdrX:isLast:E:  "inner(toPrimary) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 --  rec:  "inner(toPrimary) "E:  "inner(toPrimary) "
 -- INV:gen:E.loadArgs "inner(toPrimary) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(toPrimary) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:toPrimary
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(toPrimary)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(toPrimary) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(toPrimary) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(toPrimary) >rec:"inner(toPrimary)" ATd:"pattern" E:"inner(toPrimary)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(toPrimary) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- OI:invoke:B: "inner(toPrimary) "E: "inner(toPrimary) " rec: "
 --  inner(toPrimary) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(toPrimary)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(toPrimary) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- OI:invoke:C: inner(toPrimary) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 L2:
 -- pushReturn:  "toPrimary "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=49 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 50 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 50 1 Unit 40
 -- Store itemArgs: 
 --  in base: var PrimaryUnit
 --  inner(fromPrimary)
 --  
 -- in base: var PrimaryUnit 0 
 -- DI:store: "base "
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  base 40 1
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=50 vDescInx=50 vdtTop: 1 
 mvStack 
 -- $var:gen: in base: var PrimaryUnit 
 -- DI:gen: "in base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(fromPrimary) " 
 -- $ObjectGenerator:gen: inner(fromPrimary) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(fromPrimary) " 
 -- OG:before:super.gen: "inner(fromPrimary) "
 -- $Invocation:gen: inner(fromPrimary) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(fromPrimary) " 
 -- isConstant: "Invocation ""inner(fromPrimary) "
 -- needorigin: "inner(fromPrimary) " 
 -- needOrigin:E: "inner(fromPrimary) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(fromPrimary) " rec: "inner(fromPrimary) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(fromPrimary) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(fromPrimary) " 
 -- doNeedOrigin:E: "inner(fromPrimary) " 
 -- computeAdrX:superAdj: 0 "inner(fromPrimary) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(fromPrimary) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(fromPrimary) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(fromPrimary) >on:4 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(fromPrimary) >ATd.off:0 (isPtn):on:4:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(fromPrimary) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- computeAdrX:isLast:E:  "inner(fromPrimary) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 --  rec:  "inner(fromPrimary) "E:  "inner(fromPrimary) "
 -- INV:gen:E.loadArgs "inner(fromPrimary) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(fromPrimary) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:fromPrimary
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(fromPrimary)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(fromPrimary) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(fromPrimary) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(fromPrimary) >rec:"inner(fromPrimary)" ATd:"pattern" E:"inner(fromPrimary)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(fromPrimary) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- OI:invoke:B: "inner(fromPrimary) "E: "inner(fromPrimary) " rec: "
 --  inner(fromPrimary) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(fromPrimary)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(fromPrimary) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- OI:invoke:C: inner(fromPrimary) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 L2:
 -- pushReturn:  "fromPrimary "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=50 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 51 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 51 1 Unit 40
 -- Store itemArgs: 
 --  "Unit:".print
 --  inner(print)
 --  put(':')
 --  putFloat(magnitude)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=51 vDescInx=51 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: ""Unit:".print " 
 -- $ObjectGenerator:gen: "Unit:".print >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: ""Unit:".print " 
 -- OG:before:super.gen: ""Unit:".print "
 -- $Invocation:gen: "Unit:".print >useRtnV:"False"superAdj: 0 descNo: 52
 -- INV:gen: ""Unit:".print " 
 -- isConstant: "Invocation """Unit:".print "
 -- needorigin: ""Unit:".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""Unit:" " rec: ""Unit:" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Unit:" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Unit:" "E:  ""Unit:" "
 -- INV:gen:E.loadArgs ""Unit:" "
 -- $String::loadArgs: "Unit:" 
 -- INV:gen:after:E.loadArgs ""Unit:" "
 --  OIadr: 
 -- $String::invoke: "Unit:" 
 pushText "Unit:"
 -- IV:gen:checkTail: ""Unit:".print "E: ""Unit:" "tail: "print "
 --   not isLast: false 
 -- 
 -- $ObjectInvocation_Unary:loadArgs: print >staticOff:0  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- 
 -- $pattern:loadArgs:  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- ptn:loadArgs:E: "print " 
 -- args: " " 
 -- $ObjectInvocation_Unary:invoke: print >rec:""Unit:"" ATd:"pattern" E:"print" E.ATd:print unique:"False"
 -- OI:invoke: "print "
 -- 
 -- OI:invoke:B: "print "E: "print " rec: ""Unit:" " useRtnV: false 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- 
 -- $pattern:invoke:  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Unit:" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: print :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: "inner(print) " 
 -- $ObjectGenerator:gen: inner(print) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(print) " 
 -- OG:before:super.gen: "inner(print) "
 -- $Invocation:gen: inner(print) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(print) " 
 -- isConstant: "Invocation ""inner(print) "
 -- needorigin: "inner(print) " 
 -- needOrigin:E: "inner(print) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(print) " rec: "inner(print) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(print) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(print) " 
 -- doNeedOrigin:E: "inner(print) " 
 -- computeAdrX:superAdj: 0 "inner(print) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(print) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(print) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(print) >on:4 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(print) >ATd.off:0 (isPtn):on:4:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(print) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- computeAdrX:isLast:E:  "inner(print) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 --  rec:  "inner(print) "E:  "inner(print) "
 -- INV:gen:E.loadArgs "inner(print) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(print) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:print
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(print)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(print) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(print) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(print) >rec:"inner(print)" ATd:"pattern" E:"inner(print)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(print) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:B: "inner(print) "E: "inner(print) " rec: "inner(print) "
 --   useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(print)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(print) "ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:C: inner(print) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- genclass:stmt: "put(':') " 
 -- $ObjectGenerator:gen: put(':') >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "put(':') " 
 -- OG:before:super.gen: "put(':') "
 -- $Invocation:gen: put(':') >useRtnV:"False"superAdj: 0 descNo: 54
 -- INV:gen: "put(':') " 
 -- isConstant: "Invocation ""put(':') "
 -- needorigin: "put(':') " 
 -- needOrigin:E: "put(':') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(':') " rec: "put(':') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(':') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(':') "E:  "put(':') "
 -- INV:gen:E.loadArgs "put(':') "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put(':') >staticOff:0  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- 
 -- $pattern:loadArgs:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:loadArgs:E: "put(':') " 
 -- args: "put(':') " 
 -- E: "ObjectGenerator "':' 
 -- E.arg: "val "in ch: val char 
 -- NonVirt: "put(':') " "ObjectInvocation_KeyWord " ActArg: "':' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(':') " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: ':' >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "':' " 
 -- OG:before:super.gen: "':' "
 -- $Invocation:gen: ':' >useRtnV:"True"superAdj: 0
 -- INV:gen: "':' " 
 -- isConstant: "Invocation ""':' "
 -- needorigin: "':' " 
 -- needOrigin:E: "':' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "':' " rec: "':' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "':' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "':' "E:  "':' "
 -- INV:gen:E.loadArgs "':' "
 -- $Char::loadArgs: ':' 
 -- INV:gen:after:E.loadArgs "':' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "':' "
 -- $Char::invoke: ':' 
 pushc 58
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "':' ":isBasicVal: true 
 -- case:B: ':' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(':') "
 -- INV:gen:after:E.loadArgs "put(':') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(':') "
 -- $ObjectInvocation_KeyWord:invoke: put(':') >rec:"put(':')" ATd:"pattern" E:"put(':')" E.ATd:put unique:"False"
 -- OI:invoke: "put(':') "
 -- 
 -- OI:invoke:B: "put(':') "E: "put(':') " rec: "put(':') " useRtnV: 
 --  false 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- 
 -- $pattern:invoke:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:invoke: "put "E: "put(':') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(':') :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: "putFloat(magnitude) " 
 -- $ObjectGenerator:gen: putFloat(magnitude) >OGid:"putFloat" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "putFloat(magnitude) " 
 -- OG:before:super.gen: "putFloat(magnitude) "
 -- $Invocation:gen: putFloat(magnitude) >useRtnV:"False"superAdj: 0 descNo: 56
 -- INV:gen: "putFloat(magnitude) " 
 -- isConstant: "Invocation ""putFloat(magnitude) "
 -- needorigin: "putFloat(magnitude) " 
 -- needOrigin:E: "putFloat(magnitude) "  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putFloat(magnitude) " rec: "putFloat(magnitude) " E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  E.ATd.desc: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  E.ATd.IT: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "putFloat(magnitude) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "putFloat(magnitude) " 
 -- doNeedOrigin:E: "putFloat(magnitude) " 
 -- computeAdrX:superAdj: 0 "putFloat(magnitude) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  putFloat(magnitude) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: putFloat(magnitude) 
 -- $ObjectInvocation_KeyWord:loadOrigin: putFloat(magnitude) >on:4 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: putFloat(magnitude) >ATd.off:0 (isPtn):on:4:superAdj:0 \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- 
 -- $pattern:getAdr:  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "putFloat(magnitude) " ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- computeAdrX:isLast:E:  "putFloat(magnitude) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 --  rec:  "putFloat(magnitude) "E:  "putFloat(magnitude) "
 -- INV:gen:E.loadArgs "putFloat(magnitude) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: putFloat(magnitude) >staticOff:0  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- 
 -- $pattern:loadArgs:  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- ptn:loadArgs:E: "putFloat(magnitude) " 
 -- args: "putFloat(magnitude) " 
 -- E: "ObjectGenerator "magnitude 
 -- E.arg: "var "in X: var Float 
 -- NonVirt: "putFloat(magnitude) " "ObjectInvocation_KeyWord " 
 --  ActArg: "magnitude "isValue: false formalArg: "in X: var Float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putFloat(magnitude) "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: magnitude >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "magnitude " 
 -- OG:before:super.gen: "magnitude "
 -- $Invocation:gen: magnitude >useRtnV:"True"superAdj: 0
 -- INV:gen: "magnitude " 
 -- isConstant: "Invocation ""magnitude "
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: "
 --  magnitude " rec: "magnitude " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: magnitude 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: magnitude >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: Unit origin:isValueObj: true 
 rpushg print$51 1
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:1:superAdj:0magnitude: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"magnitude":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude " ATd: "magnitude: var Float " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 --  rec:  "magnitude "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- $ObjectInvocation_Unary:loadArgs: magnitude >staticOff:0 magnitude: var Float superAdj:0
 -- $var:loadArgs: magnitude: var Float >E:"magnitude"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "magnitude " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- $ObjectInvocation_Unary:invoke: magnitude >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:magnitude unique:"False"
 -- OI:invoke: "magnitude "
 -- 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit "
 -- 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude "E: "magnitude " rec: "magnitude "
 --   useRtnV: true "magnitude: var Float " 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: magnitude: var Float E: "magnitude">newOff:1 useRTNv: "True"
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude isNotRemote: true 
 -- isCompositeValueObj: false E: "magnitude ""
 --  magnitude: var Float " true 
 -- E.ATd.isValueObj: true rec: "magnitude "
 -- load:isValue:E: "magnitude "originIsValue: true 
 --  E.ATd:isValueObj: true 
 -- E.ATd: "magnitude: var Float " 
 --  E.ATd.origin: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 --  (E.ATd.origin.ogOfScope): 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 fvpushg 1 Unit$40
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:C: magnitude :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "magnitude ":isBasicVal: true 
 -- case:B: magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putFloat(magnitude) "
 -- INV:gen:after:E.loadArgs "putFloat(magnitude) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  putFloat(magnitude) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: putFloat(magnitude) >rec:"putFloat(magnitude)" ATd:"pattern" E:"putFloat(magnitude)" E.ATd:putFloat unique:"False"
 -- OI:invoke: "putFloat(magnitude) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- OI:invoke:B: "putFloat(magnitude) "E: "putFloat(magnitude) "
 --   rec: "putFloat(magnitude) " useRtnV: false 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- 
 -- $pattern:invoke:  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- ptn:invoke: "putFloat "E: "putFloat(magnitude) "ptnKind: 0 
 --  useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  putFloat(magnitude) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 %printf_prim 142
 vpop
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- OI:invoke:C: putFloat(magnitude) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 L2:
 -- pushReturn:  "print "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=51 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 52 
 -- Items:GenClass: print descNo: 52 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 52 1 String 10
 -- Store itemArgs: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=52 vDescInx=52 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- for(1):to(length):repeat \
 --    put(get[inx]) \
 --  >OGid:"for:to:repeat$55" IS.isempty! staticOff=0 descNo=55 superAdj=0
 -- OG:gen: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 pushThis 
 -- before objTmpStack:add:  55   "for:to:repeat$55 "
 invoke for:to:repeat$55 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "print "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 28 
 -- Items:GenClass: for:to:repeat descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat 28 0 BETA 2
 -- Store itemArgs: 
 --  %OSDvisibility skipInternal
 --  %globals inSub
 --  inx: var integer
 --  inx := first
 -- last: var integer 1 
 -- DI:store: "last "
 pushThis 
 storeg integer$5 2
 -- first: var integer 1 
 -- DI:store: "first "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=28 vDescInx=28 vdtTop: 1 
 mvStack 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- $Property:gen: %globals inSub 
 -- $var:gen: inx: var integer 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%OSDvisibility skipInternal " 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- genclass:stmt: "%globals inSub " 
 -- $Property:gen: %globals inSub 
 -- genclass:stmt: "inx := first " 
 -- $Assign:gen: inx := first 
 -- AssignmentStatement:gen: "inx := first " 
 -- computeAdrG:superAdj: 0 "inx "
 -- computeAdrG: 1 :rec: "none " E: "inx "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:0:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrG:isLast:E:  "inx "
 -- AssignmentStatement:gen: 
 --  "inx := first " right.label: "ObjectGenerator ""first " 
 -- $ObjectGenerator:gen: first >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "first " 
 -- OG:before:super.gen: "first "
 -- $Invocation:gen: first >useRtnV:"True"superAdj: 0
 -- INV:gen: "first " 
 -- isConstant: "Invocation ""first "
 -- notConst: first first: var integer 
 -- needorigin: "first " 
 -- needOrigin:E: "first "  E.ATd: "first: var integer " Ex: "
 --  first " rec: "first " E.ATd: "first: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "first " 
 -- doNeedOrigin:E: "first " 
 -- computeAdrX:superAdj: 0 "first " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "first " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: first 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: first >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: first >ATd.off:1:on:0:superAdj:0first: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: first: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"first":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "first: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- computeAdrX:isLast:E:  "first "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 --  rec:  "first "E:  "first "
 -- INV:gen:E.loadArgs "first "
 -- $ObjectInvocation_Unary:loadArgs: first >staticOff:0 first: var integer superAdj:0
 -- $var:loadArgs: first: var integer >E:"first"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "first " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "first "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "first "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- $ObjectInvocation_Unary:invoke: first >rec:"first" ATd:"var" isValueObj E:"first" E.ATd:first unique:"False"
 -- OI:invoke: "first "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:B: "first "E: "first " rec: "first " useRtnV: true "
 --  first: var integer " 
 -- OI:invoke:before:ATdx.invoke: var first 
 -- $var:invoke: first: var integer E: "first">newOff:1 useRTNv: "True"
 -- DI:invoke: "first: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first isNotRemote: true 
 -- isCompositeValueObj: false E: "first ""first: var integer " true 
 -- E.ATd.isValueObj: false rec: "first "
 pushg 1 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:C: first :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- rec: "inx "dstE: "inx "dstE.ATd: "inx: var integer " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "first "
 -- isArgOfAssignI2IwithUniValArg "inx := first "arg: "first "
 --  ObjectGenerator 
 -- arg.super.arg: "first "ObjectInvocation_Unary 
 -- dstDI: "inx: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  _doIt: do 
 --     if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 -- 
 -- $do:gen:  \
 -- _doIt: do  \
 --    if (inx <= last) :then  \
 --       repeat
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (inx <= last) :then  \
 --       repeat \
 --       inx := inx + 1
 -- OG:gen: 
 --  if (inx <= last) :then 
 --        repeat
 --        inx := inx + 1
 --        restart(_doIt)
 pushThis 
 -- before objTmpStack:add:  57   "_doIt "
 invoke _doIt 57 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "for:to:repeat "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=28 vDescInx=29 vdtTop: 2 

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 1 21 
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdt:a:dNo: 29  newDescNo:  28 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 57 
 -- Items:GenClass: _doIt descNo: 57 isValue: false 
 -- Items:GenClass: _doIt descNo: 21 isValue: false 

 CLASS _doIt 57 1 for:to:repeat 28
 -- Store itemArgs: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=57 vDescInx=57 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (inx <= last) :then  \
 --    repeat \
 --    inx := inx + 1
 -- OG:gen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- OG:before:super.gen: "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- 
 -- $Invocation:gen:  \
 -- if (inx <= last) :then  \
 --    repeat \
 --    inx := inx + 1
 -- INV:gen: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- isConstant: "Invocation ""
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- needorigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- needOrigin:E: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt) E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)rec: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "E:  "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- INV:gen:E.loadArgs "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- 
 -- $IfThenElse:loadArgs:  \
 -- if (inx <= last) :then  \
 --    repeat \
 --    inx := inx + 1
 -- INV:gen:after:E.loadArgs "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (inx <= last) :then 
 --     repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  :else 
 --     inx := inx "
 -- 
 -- $IfThenElse:invoke:  \
 -- if (inx <= last) :then  \
 --    repeat \
 --    inx := inx + 1
 -- 
 -- $IfThenElse:gen:  \
 -- if (inx <= last) :then  \
 --    repeat \
 --    inx := inx + 1
 -- $ObjectGenerator:gen: (inx <= last) >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(inx <= last) " 
 -- OG:before:super.gen: "(inx <= last) "
 -- $Invocation:gen: (inx <= last) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(inx <= last) " 
 -- isConstant: "Invocation ""(inx <= last) "
 -- needorigin: "(inx <= last) " 
 -- needOrigin:E: "(inx <= last) "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "(inx <= last) " rec: "(inx <= last) " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(inx <= last) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(inx <= last) " 
 -- doNeedOrigin:E: "(inx <= last) " 
 -- computeAdrX:superAdj: 0 "(inx <= last) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx <= last) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (inx <= last) 
 -- $BracketedExp:loadOrigin: (inx <= last) 
 -- computeAdrG:superAdj: 0 "inx <= last "
 -- computeAdrG: 1 :rec: "none " E: "inx <= last "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: inx <= last 
 -- $BinOp:loadOrigin: inx <= last 
 -- BinaryExp:loadOrigin:empty: "inx <= last "superAdj: 0 
 -- $BinOp:getAdr: inx <= last 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx <= last " ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "inx <= last "
 -- BE:loadOrigin:E: inx <= last 
 -- $BinOp:getAdr: inx <= last 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx <= last " ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inx <= last "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx <= last "E:  "inx <= last "
 -- INV:gen:E.loadArgs "inx <= last "
 -- $BinOp:loadArgs: inx <= last 
 -- BinaryExp:loadArgs: "inx <= last " superAdj: 0 
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "inx <= last "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- $pattern:loadArgs:  \
 -- <=  :<  \
 --    %basic 52 \
 --    in Veq: var this(Value)
 -- ptn:loadArgs:E: "<= last " 
 -- args: "last " 
 -- E: "ObjectGenerator "last 
 -- E.arg: "var "in Veq: var this(Value) 
 -- NonVirt: "<= last " "ObjectInvocation_Binary " ActArg: "last "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= last " isCompositeValueObj: 
 --  true 
 -- $ObjectGenerator:gen: last >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "last " 
 -- OG:before:super.gen: "last "
 -- $Invocation:gen: last >useRtnV:"True"superAdj: 0
 -- INV:gen: "last " 
 -- isConstant: "Invocation ""last "
 -- notConst: last last: var integer 
 -- needorigin: "last " 
 -- needOrigin:E: "last "  E.ATd: "last: var integer " Ex: "last " 
 --  rec: "last " E.ATd: "last: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "last " 
 -- doNeedOrigin:E: "last " 
 -- computeAdrX:superAdj: 0 "last " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "last " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: last 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: last >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: last >ATd.off:2:on:1:superAdj:0last: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: last: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"last":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "last: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "last " ATd: "last: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- computeAdrX:isLast:E:  "last "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 --  rec:  "last "E:  "last "
 -- INV:gen:E.loadArgs "last "
 -- $ObjectInvocation_Unary:loadArgs: last >staticOff:0 last: var integer superAdj:0
 -- $var:loadArgs: last: var integer >E:"last"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "last " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "last "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- $ObjectInvocation_Unary:invoke: last >rec:"last" ATd:"var" isValueObj E:"last" E.ATd:last unique:"False"
 -- OI:invoke: "last "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:B: "last "E: "last " rec: "last " useRtnV: true "
 --  last: var integer " 
 -- OI:invoke:before:ATdx.invoke: var last 
 -- $var:invoke: last: var integer E: "last">newOff:2 useRTNv: "True"
 -- DI:invoke: "last: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last isNotRemote: true 
 -- isCompositeValueObj: false E: "last ""last: var integer " true 
 -- E.ATd.isValueObj: false rec: "last "
 pushg 2 for:to:repeat$28
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:C: last :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= last "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx <= last "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx <= last "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: inx <= last 
 -- BinaryExp:invoke: "inx "rec: "inx <= last "
 -- M: "<= last "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: <= last >rec:"inx" ATd:"pattern" E:"<= last" E.ATd:<=   unique:"False"
 -- OI:invoke: "<= last "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "Value "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "<= last "E: "<= last " rec: "inx " useRtnV: true 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- 
 -- $pattern:invoke:  \
 -- <=  :<  \
 --    %basic 52 \
 --    in Veq: var this(Value)
 -- ptn:invoke: "<=   "E: "<= last "ptnKind: 1 useRtnV: true 
 -- E: "<= last " rec: "inx ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "inx: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- OI:invoke:C: <= last :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- 
 -- $ObjectGenerator:gen:  \
 -- repeat \
 --    inx := inx + 1 \
 --    restart(_doIt) >OGid:"$59" singular! staticOff=0 descNo=59 superAdj=0
 -- OG:gen: 
 --  repeat
 --     inx := inx + 1
 --     restart(_doIt)
 --  
 pushThis 
 -- before objTmpStack:add:  59   "$59 "
 invoke $59 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: inx := inx >OGid:"$62" singular! staticOff=0 descNo=62 superAdj=0
 -- OG:gen: "inx := inx " 
 pushThis 
 -- before objTmpStack:add:  62   "$62 "
 invoke $62 62 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  "_doIt "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 59 
 -- Items:GenClass: $59 descNo: 59 isValue: false 
 -- Items:GenClass: $59 descNo: 21 isValue: false 

 CLASS $59 59 1 _doIt 57
 -- Store itemArgs: 
 --  repeat
 --  inx := inx + 1
 --  restart(_doIt)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=59 vDescInx=59 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "repeat " 
 -- $ObjectGenerator:gen: repeat >OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "repeat " 
 -- OG:before:super.gen: "repeat "
 -- $Invocation:gen: repeat >useRtnV:"False"superAdj: 0 descNo: 0
 -- INV:gen: "repeat " 
 -- isConstant: "Invocation ""repeat "
 -- needorigin: "repeat " 
 -- needOrigin:E: "repeat "  E.ATd: "repeat:< object " Ex: "repeat " 
 --  rec: "repeat " E.ATd: "repeat:< object " E.ATd.desc: 
 --  %ID Object
 --  %basic 64
 --  %public
 --  ==  : E.ATd.IT: " " 
 -- doNeedOrigin:Ex: "repeat "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "repeat " 
 -- doNeedOrigin:E: "repeat " 
 -- computeAdrX:superAdj: 0 "repeat " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "repeat " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: repeat 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: repeat >on:2 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: repeat >ATd.off:0 (isPtn):on:2:superAdj:0repeat:< object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $pattern:getAdr: repeat:< object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "repeat " ATd: "repeat:< object " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- computeAdrX:isLast:E:  "repeat "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 --  rec:  "repeat "E:  "repeat "
 -- INV:gen:E.loadArgs "repeat "
 -- $ObjectInvocation_Unary:loadArgs: repeat >staticOff:0 repeat:< object superAdj:0
 -- $pattern:loadArgs: repeat:< object >E:"repeat":descNo:0
 -- ptn:loadArgs:E: "repeat " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "repeat "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "repeat "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- $ObjectInvocation_Unary:invoke: repeat >rec:"repeat" ATd:"pattern" E:"repeat" E.ATd:repeat unique:"False"
 -- OI:invoke: "repeat "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- OI:invoke:B: "repeat "E: "repeat " rec: "repeat " useRtnV: false "
 --  repeat:< object " 
 -- OI:invoke:before:ATdx.invoke: pattern repeat 
 -- $pattern:invoke: repeat:< object E: "repeat" useRTNv: "False"
 -- ptn:invoke: "repeat "E: "repeat "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 rec: "repeat " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- isPtn 
 -- isStatic: false rec: "repeat "
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- OI:invoke:C: repeat :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- genclass:stmt: "inx := inx + 1 " 
 -- $Assign:gen: inx := inx + 1 
 -- AssignmentStatement:gen: "inx := inx + 1 " 
 -- computeAdrG:superAdj: 0 "inx "
 -- computeAdrG: 1 :rec: "none " E: "inx "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:2:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrG:isLast:E:  "inx "
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1 " right.label: "ObjectGenerator ""inx + 1 " 
 -- $ObjectGenerator:gen: inx + 1 >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx + 1 " 
 -- OG:before:super.gen: "inx + 1 "
 -- $Invocation:gen: inx + 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx + 1 " 
 -- isConstant: "Invocation ""inx + 1 "
 -- needorigin: "inx + 1 " 
 -- needOrigin:E: "inx + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1 " rec: "inx + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1 " 
 -- doNeedOrigin:E: "inx + 1 " 
 -- computeAdrX:superAdj: 0 "inx + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: inx + 1 
 -- $BinOp:loadOrigin: inx + 1 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- $BinOp:getAdr: inx + 1 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx + 1 " ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- $BinOp:loadArgs: inx + 1 
 -- BinaryExp:loadArgs: "inx + 1 " superAdj: 0 
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:2:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "inx + 1 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- $pattern:loadArgs:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:loadArgs:E: "+ 1 " 
 -- args: "1 " 
 -- E: "ObjectGenerator "1 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: inx + 1 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: + 1 >rec:"inx" ATd:"pattern" E:"+ 1" E.ATd:+   unique:"False"
 -- OI:invoke: "+ 1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "+ 1 "E: "+ 1 " rec: "inx " useRtnV: true 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- 
 -- $pattern:invoke:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx "E: "+ 1 "
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:C: + 1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "inx "dstE: "inx "dstE.ATd: "inx: var integer " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "inx + 1 "
 -- isArgOfAssignI2IwithUniValArg "inx := inx + 1 "arg: "inx + 1 "
 --  ObjectGenerator 
 -- arg.super.arg: "inx + 1 "BinOp 
 -- recx:BinaryExp:recx: "inx + 1 "
 -- M: "+ 1 "label: "ObjectInvocation_Binary "M.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "inx "E: "+ 1 "
 -- arg:integer 
 -- M:arg: "1 "ObjectGenerator false 
 -- dstDI: "inx: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "restart(_doIt) " 
 -- $ObjectGenerator:gen: restart(_doIt) >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "restart(_doIt) " 
 -- OG:before:super.gen: "restart(_doIt) "
 -- $Invocation:gen: restart(_doIt) >useRtnV:"False"superAdj: 0 descNo: 61
 -- INV:gen: "restart(_doIt) " 
 -- isConstant: "Invocation ""restart(_doIt) "
 -- needorigin: "restart(_doIt) " 
 -- needOrigin:E: "restart(_doIt) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(_doIt) " rec: "restart(_doIt) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(_doIt) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(_doIt) " 
 -- doNeedOrigin:E: "restart(_doIt) " 
 -- computeAdrX:superAdj: 0 "restart(_doIt) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(_doIt) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: restart(_doIt) 
 -- $ObjectInvocation_KeyWord:loadOrigin: restart(_doIt) >on:3 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: restart(_doIt) >ATd.off:0 (isPtn):on:3:superAdj:0 \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "restart(_doIt) " ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- computeAdrX:isLast:E:  "restart(_doIt) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 --  rec:  "restart(_doIt) "E:  "restart(_doIt) "
 -- INV:gen:E.loadArgs "restart(_doIt) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: restart(_doIt) >staticOff:0  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 superAdj:0arg:_doIt
 -- 
 -- $pattern:loadArgs:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 >E:"restart(_doIt)":descNo:61
 -- INV:gen:after:E.loadArgs "restart(_doIt) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(_doIt) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: restart(_doIt) >rec:"restart(_doIt)" ATd:"pattern" E:"restart(_doIt)" E.ATd:restart(V: var integer) unique:"False"
 -- OI:invoke: "restart(_doIt) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:B: "restart(_doIt) "E: "restart(_doIt) " rec: "
 --  restart(_doIt) " useRtnV: false 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 E: "restart(_doIt)" useRTNv: "False"
 -- ptn:invoke: "restart(V: var integer) "E: "restart(_doIt) "
 --  ptnKind: 0 useRtnV: false 
 break  1 1 57 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:C: restart(_doIt) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 62 
 -- Items:GenClass: $62 descNo: 62 isValue: false 
 -- Items:GenClass: $62 descNo: 21 isValue: false 

 CLASS $62 62 1 _doIt 57
 -- Store itemArgs: "inx := inx " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=62 vDescInx=62 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inx := inx " 
 -- $Assign:gen: inx := inx 
 -- AssignmentStatement:gen: "inx := inx " 
 -- computeAdrG:superAdj: 0 "inx "
 -- computeAdrG: 1 :rec: "none " E: "inx "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$62 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:2:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrG:isLast:E:  "inx "
 -- AssignmentStatement:gen: 
 --  "inx := inx " right.label: "ObjectGenerator ""inx " 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$62 "on: 2 isValueObj: false 
 --  origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt "on: 1 isValueObj: false 
 --  origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:2:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- rec: "inx "dstE: "inx "dstE.ATd: "inx: var integer " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "inx "
 -- isArgOfAssignI2IwithUniValArg "inx := inx "arg: "inx "
 --  ObjectGenerator 
 -- arg.super.arg: "inx "ObjectInvocation_Unary 
 -- dstDI: "inx: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 20 
 -- Items:GenClass: if:then descNo: 20 isValue: false 
 -- Items:GenClass: if:then descNo: 21 isValue: false 

 CLASS if:then 20 0 BETA 2
 -- Store itemArgs: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- cond: var boolean 4 
 -- DI:store: "cond "
 pushThis 
 storeg Boolean$83 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=20 vDescInx=20 vdtTop: 1 
 mvStack 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- $Property:gen: %basic 100 
 -- $Property:gen: %globals inSub 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%OSDvisibility skipInternal " 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- genclass:stmt: "%basic 100 " 
 -- $Property:gen: %basic 100 
 -- genclass:stmt: "%globals inSub " 
 -- $Property:gen: %globals inSub 
 L2:
 -- pushReturn:  "if:then "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=20 vDescInx=22 vdtTop: 2 

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 1 21 
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdt:a:dNo: 22  newDescNo:  20 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 53 
 -- Items:GenClass: repeat$53 descNo: 53 isValue: false 
 -- Items:GenClass: repeat$53 descNo: 21 isValue: false 

 CLASS repeat$53 53 1 for:to:repeat$55 55
 -- Store itemArgs: "put(get[inx]) " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=53 vDescInx=53 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "put(get[inx]) " 
 -- $ObjectGenerator:gen: put(get[inx]) >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "put(get[inx]) " 
 -- OG:before:super.gen: "put(get[inx]) "
 -- $Invocation:gen: put(get[inx]) >useRtnV:"False"superAdj: 0 descNo: 54
 -- INV:gen: "put(get[inx]) " 
 -- isConstant: "Invocation ""put(get[inx]) "
 -- needorigin: "put(get[inx]) " 
 -- needOrigin:E: "put(get[inx]) "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(get[inx]) " rec: "put(get[inx]) " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(get[inx]) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(get[inx]) "E:  "put(get[inx]) "
 -- INV:gen:E.loadArgs "put(get[inx]) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put(get[inx]) >staticOff:0  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- 
 -- $pattern:loadArgs:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:loadArgs:E: "put(get[inx]) " 
 -- args: "put(get[inx]) " 
 -- E: "ObjectGenerator "get[inx] 
 -- E.arg: "val "in ch: val char 
 -- NonVirt: "put(get[inx]) " "ObjectInvocation_KeyWord " ActArg: "
 --  get[inx] "isValue: false formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(get[inx]) "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: get[inx] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- $Invocation:gen: get[inx] >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "get[inx] " 
 -- isConstant: "Invocation ""get[inx] "
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: get[inx] 
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: get[inx] >on:3 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$53 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- items:goOrigin:encOG: "for:to:repeat$55 "on: 2 isValueObj: 
 --  false 
 --  origin: print origin:isValueObj: false 
 rpushg for:to:repeat$55$55 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[inx] >ATd.off:0 (isPtn):on:3:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "get[inx] " ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[inx] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[inx]":descNo:16
 -- ptn:loadArgs:E: "get[inx] " 
 -- args: "get[inx] " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$53 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$55$55
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: get[inx] >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[inx] "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx] "E: "get[inx] " rec: "get[inx] " useRtnV: 
 --  true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[inx]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:C: get[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "get[inx] ":isBasicVal: true 
 -- case:B: get[inx] ObjectGenerator 3 117 117 false false 
 -- end:loadArgs:NonVirt: "put(get[inx]) "
 -- INV:gen:after:E.loadArgs "put(get[inx]) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(get[inx]) "
 -- $ObjectInvocation_KeyWord:invoke: put(get[inx]) >rec:"put(get[inx])" ATd:"pattern" E:"put(get[inx])" E.ATd:put unique:"False"
 -- OI:invoke: "put(get[inx]) "
 -- 
 -- OI:invoke:B: "put(get[inx]) "E: "put(get[inx]) " rec: "
 --  put(get[inx]) " useRtnV: false 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- 
 -- $pattern:invoke:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:invoke: "put "E: "put(get[inx]) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(get[inx]) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 54 
 -- Items:GenClass: put descNo: 54 isValue: false 
 -- Items:GenClass: put descNo: 21 isValue: false 

 CLASS put 54 0 BETA 2
 -- Store itemArgs: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  
 -- in ch: val char 3 
 -- DI:store: "ch "
 pushThis 
 storeg char$7 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=54 vDescInx=54 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 -- $Property:gen: %basic 2 
 -- $val:gen: in ch: val char 
 -- DI:gen: "in ch: val char " DI:isConst: true isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: ch 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "%basic 2 " 
 -- $Property:gen: %basic 2 
 L2:
 -- pushReturn:  "put "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 55 
 -- Items:GenClass: for:to:repeat$55 descNo: 55 isValue: false 
 -- Items:GenClass: for:to:repeat$55 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$55 55 4 print 52
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs: " " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 --  theIS: " " 
 -- super.sig:none:superAdj: 4 
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs:  \
 -- for(1):to(length):repeat \
 --    put(get[inx]) \
 --  >staticOff:0 
 -- 
 -- $pattern:loadArgs:  \
 -- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
 --    %OSDvisibility skipInternal \
 --    %globals inSub
 -- ptn:loadArgs:E: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- args: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  
 -- E: "ObjectGenerator "1 
 -- E: "ObjectGenerator "length 
 -- E: "ObjectGenerator "put(get[inx]) 
 -- E.arg: "var "first: var integer 
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 4
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- E.arg: "var "last: var integer 
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     put(get[inx])
 --  "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     put(get[inx])
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "length " 
 -- OG:before:super.gen: "length "
 -- $Invocation:gen: length >useRtnV:"True"superAdj: 4 descNo: 15
 -- INV:gen: "length " 
 -- isConstant: "Invocation ""length "
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: length 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: length >on:1 superAdj:4 isValueObj:"False"
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg print$52 4
 -- items:goOrigin:encOG: "print "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- 
 -- $ObjectInvocation_Unary:getAdr: length >ATd.off:0 (isPtn):on:1:superAdj:4 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 --        put(get[inx])
 --      
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "length " ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:4
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length":descNo:15
 -- ptn:loadArgs:E: "length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: length >rec:"length" ATd:"pattern" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "length "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length "E: "length " rec: "length " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length" useRTNv: "True"
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- args:  "repeat:< object ""put(get[inx]) "for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs: " " 
 -- last: var integer 1 
 -- DI:store: "last "
 pushThis 
 storeg integer$5 2
 -- first: var integer 1 
 -- DI:store: "first "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=55 vDescInx=28 vdtTop: 2 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- $Property:gen: %globals inSub 
 -- $var:gen: inx: var integer 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: " " E: "for(1):to(length):repeat
 --     put(get[inx])
 --   "
 -- vdtAdd: inx=2 descInx=55 vDescInx=53 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 56 
 -- Items:GenClass: putFloat descNo: 56 isValue: false 
 -- Items:GenClass: putFloat descNo: 21 isValue: false 

 CLASS putFloat 56 1 BETA 2
 -- Store itemArgs: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  
 -- in X: var Float 9 
 -- DI:store: "X "
 pushThis 
 fstoreg 2 X
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=56 vDescInx=56 vdtTop: 1 
 mvStack 
 -- $Property:gen: %basic 142 
 -- $var:gen: in X: var Float 
 -- DI:gen: "in X: var Float " DI:isConst: false isBasicValue: true 
 --  primNo: 9 
 -- DI:gen:primitiveType: X 
 -- $var:gen: out V: var integer 
 -- DI:gen: "out V: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 142 " 
 -- $Property:gen: %basic 142 
 L2:
 -- pushReturn:  "putFloat "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 63 
 -- Items:GenClass: symbol descNo: 63 isValue: false 
 -- Items:GenClass: symbol descNo: 21 isValue: false 

 CLASS symbol 63 1 Dimension 39
 -- Store itemArgs: 
 --  %globals
 --  out T: var StringLib.String
 --  inner(Symbol)
 --  
 allocEventQ
 -- vdtAdd: inx=1 descInx=63 vDescInx=63 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 -- $var:gen: out T: var StringLib.String 
 -- DI:gen: "out T: var StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "inner(Symbol) " 
 -- $ObjectGenerator:gen: inner(Symbol) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(Symbol) " 
 -- OG:before:super.gen: "inner(Symbol) "
 -- $Invocation:gen: inner(Symbol) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(Symbol) " 
 -- isConstant: "Invocation ""inner(Symbol) "
 -- needorigin: "inner(Symbol) " 
 -- needOrigin:E: "inner(Symbol) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(Symbol) " rec: "inner(Symbol) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(Symbol) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(Symbol) " 
 -- doNeedOrigin:E: "inner(Symbol) " 
 -- computeAdrX:superAdj: 0 "inner(Symbol) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(Symbol) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(Symbol) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(Symbol) >on:3 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(Symbol) >ATd.off:0 (isPtn):on:3:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "inner(Symbol) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- computeAdrX:isLast:E:  "inner(Symbol) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 --  rec:  "inner(Symbol) "E:  "inner(Symbol) "
 -- INV:gen:E.loadArgs "inner(Symbol) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(Symbol) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:Symbol
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(Symbol)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(Symbol) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(Symbol) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(Symbol) >rec:"inner(Symbol)" ATd:"pattern" E:"inner(Symbol)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(Symbol) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- OI:invoke:B: "inner(Symbol) "E: "inner(Symbol) " rec: "
 --  inner(Symbol) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(Symbol)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(Symbol) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- OI:invoke:C: inner(Symbol) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 L2:
 -- pushReturn:  "symbol "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=63 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 64 
 -- Items:GenClass: gMult descNo: 64 isValue: false 
 -- Items:GenClass: gMult descNo: 21 isValue: false 

 CLASS gMult 64 1 Dimension 39
 -- Store itemArgs: 
 --  in L: var MultArgL
 --  in R: var MultArgR
 --  out U: var MultRes
 --  U.magnitude := L.magnitude * R.magnitude
 --  
 -- in R: var MultArgR 0 
 -- DI:store: "R "
 jmpFalse  L3
 pushThis 
 -- vassign:B: R off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  R 40 3
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 L4:
 -- in L: var MultArgL 0 
 -- DI:store: "L "
 jmpFalse  L5
 pushThis 
 -- vassign:B: L off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  L 40 1
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 L6:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=64 vDescInx=64 vdtTop: 1 
 mvStack 
 -- $var:gen: in L: var MultArgL 
 -- DI:gen: "in L: var MultArgL " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: L 
 -- inArg: in L: var MultArgL 
 -- $var:gen: in R: var MultArgR 
 -- DI:gen: "in R: var MultArgR " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: R 
 -- inArg: in R: var MultArgR 
 -- $var:gen: out U: var MultRes 
 -- DI:gen: "out U: var MultRes " DI:isConst: false isBasicValue: 
 --  false primNo: 0 
 -- DI:isConst: U 
 -- DI:off: 6 this: "out U: var MultRes " 
 --  
 -- $ObjectGenerator:gen: MultRes >OGid:"Unit" IS.isempty! staticOff=6 descNo=0 superAdj=0
 -- OG:gen: "MultRes " 
 -- OG:before:super.gen: "MultRes "
 -- $Invocation:gen: MultRes >useRtnV:"False"superAdj: 0 descNo: 0
 -- INV:gen: "MultRes " 
 -- isConstant: "Invocation ""MultRes "
 -- needorigin: "MultRes " 
 -- needOrigin:E: "MultRes "  E.ATd: "MultRes:< Unit " Ex: "
 --  MultRes " rec: "MultRes " E.ATd: "MultRes:< Unit " E.ATd.desc: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< UnitE.ATd.IT: " " 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- after:needOrigin: "MultRes " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "MultRes "E:  "MultRes "
 -- INV:gen:E.loadArgs "MultRes "
 -- $ObjectInvocation_Unary:loadArgs: MultRes >staticOff:0 MultRes:< Unit superAdj:0
 -- $pattern:loadArgs: MultRes:< Unit >E:"MultRes":descNo:0
 -- ptn:loadArgs:E: "MultRes " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "MultRes "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "MultRes "
 -- $ObjectInvocation_Unary:invoke: MultRes >rec:"MultRes" ATd:"pattern" isValueObj E:"MultRes" E.ATd:MultRes unique:"False"
 -- OI:invoke: "MultRes "
 -- 
 -- OI:invoke:B: "MultRes "E: "MultRes " rec: "MultRes " useRtnV: 
 --  false "MultRes:< Unit " 
 -- OI:invoke:before:ATdx.invoke: pattern MultRes 
 -- $pattern:invoke: MultRes:< Unit E: "MultRes" useRTNv: "False"
 -- ptn:invoke: "MultRes "E: "MultRes "ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 6 rec: "MultRes " 
 --  adr:none 
 -- isStatic: true rec: "MultRes "
 invokeVal  MultRes 40 5
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: MultRes :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "U.magnitude := L.magnitude * R.magnitude " 
 -- $Assign:gen: U.magnitude := L.magnitude * R.magnitude 
 -- AssignmentStatement:gen: "
 --  U.magnitude := L.magnitude * R.magnitude " 
 -- computeAdrG:superAdj: 0 "U.magnitude "
 -- computeAdrG: 1 :rec: "none " E: "U "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: U 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: U >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: U >ATd.off:6:on:0:superAdj:0out U: var MultRes:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out U: var MultRes >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"U":rec:-
 -- DI:OG: MultRes 
 -- before:floatTest:  "out U: var MultRes "ObjectGenerator 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- After:U*U: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- computeAdrG: 2 :rec: "U " E: "magnitude " A.E: "U "
 --  
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:0:superAdj:0magnitude: var Float:Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- After:U*U: 
 --  :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdrG:isLast:E:  "magnitude "
 -- AssignmentStatement:gen: 
 --  "U.magnitude := L.magnitude * R.magnitude " right.label: "
 --  ObjectGenerator ""L.magnitude * R.magnitude " 
 -- $ObjectGenerator:gen: L.magnitude * R.magnitude >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L.magnitude * R.magnitude " 
 -- OG:before:super.gen: "L.magnitude * R.magnitude "
 -- $Invocation:gen: L.magnitude * R.magnitude >useRtnV:"True"superAdj: 0
 -- INV:gen: "L.magnitude * R.magnitude " 
 -- isConstant: "Invocation ""L.magnitude * R.magnitude "
 -- needorigin: "L.magnitude * R.magnitude " 
 -- needOrigin:E: "L.magnitude * R.magnitude "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "L.magnitude * R.magnitude " rec: "
 --  L.magnitude * R.magnitude " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 -- \
 --   out R: var float
 --  
 -- doNeedOrigin:Ex: "L.magnitude * R.magnitude "originIsValueObj: 
 --  true origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L.magnitude * R.magnitude " 
 -- doNeedOrigin:E: "L.magnitude * R.magnitude " 
 -- computeAdrX:superAdj: 0 "L.magnitude * R.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "
 --  L.magnitude * R.magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L.magnitude * R.magnitude 
 -- $BinOp:loadOrigin: L.magnitude * R.magnitude 
 -- BinaryExp:loadOrigin:empty: "L.magnitude * R.magnitude "
 --  superAdj: 0 
 -- $BinOp:getAdr: L.magnitude * R.magnitude 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L.magnitude * R.magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L.magnitude * R.magnitude "E:  "L.magnitude * R.magnitude "
 -- INV:gen:E.loadArgs "L.magnitude * R.magnitude "
 -- $BinOp:loadArgs: L.magnitude * R.magnitude 
 -- BinaryExp:loadArgs: "L.magnitude * R.magnitude " superAdj: 0 
 -- $Invocation:gen: L.magnitude >useRtnV:"True"superAdj: 0
 -- INV:gen: "L.magnitude " 
 -- isConstant: "Invocation ""L.magnitude "
 -- notConst: L in L: var MultArgL 
 -- needorigin: "L.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "L " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "L.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:2:on:0:superAdj:0in L: var MultArgL:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in L: var MultArgL >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: MultArgL 
 -- before:floatTest:  "in L: var MultArgL "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:En: 2 pRec: "L " rec: "L " E: "magnitude " 
 --  A.E: "L "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:0:superAdj:0magnitude: var Float:Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- $ObjectInvocation_Unary:loadArgs: magnitude >staticOff:0 magnitude: var Float superAdj:0
 -- $var:loadArgs: magnitude: var Float >E:"magnitude"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "magnitude " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: magnitude >rec:"L" ATd:"var" isValueObj E:"magnitude" E.ATd:magnitude unique:"False"
 -- OI:invoke: "magnitude "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "Unit "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "magnitude "E: "magnitude " rec: "L " useRtnV: true "
 --  magnitude: var Float " 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: magnitude: var Float E: "magnitude">newOff:1 useRTNv: "True"
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L isNotRemote: false 
 -- isCompositeValueObj: false E: "magnitude ""
 --  magnitude: var Float " true 
 -- E.ATd.isValueObj: true rec: "L "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- OI:invoke:C: magnitude :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:loadArgs:E: "* R.magnitude " 
 -- args: "R.magnitude " 
 -- E: "ObjectGenerator "R.magnitude 
 -- E.arg: "var "in V: var float 
 -- NonVirt: "* R.magnitude " "ObjectInvocation_Binary " ActArg: "
 --  R.magnitude "isValue: false formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* R.magnitude "
 -- $ObjectGenerator:gen: R.magnitude >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "R.magnitude " 
 -- OG:before:super.gen: "R.magnitude "
 -- $Invocation:gen: R.magnitude >useRtnV:"True"superAdj: 0
 -- INV:gen: "R.magnitude " 
 -- isConstant: "Invocation ""R.magnitude "
 -- notConst: R in R: var MultArgR 
 -- needorigin: "R.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "R " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "R.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "R " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: R 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: R >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: R >ATd.off:4:on:0:superAdj:0in R: var MultArgR:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in R: var MultArgR >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"R":rec:-
 -- DI:OG: MultArgR 
 -- before:floatTest:  "in R: var MultArgR "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdrX:En: 2 pRec: "R " rec: "R " E: "magnitude " 
 --  A.E: "R "
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:0:superAdj:0magnitude: var Float:Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 --  rec:  "R "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- $ObjectInvocation_Unary:loadArgs: magnitude >staticOff:0 magnitude: var Float superAdj:0
 -- $var:loadArgs: magnitude: var Float >E:"magnitude"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "magnitude " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:invoke: magnitude >rec:"R" ATd:"var" isValueObj E:"magnitude" E.ATd:magnitude unique:"False"
 -- OI:invoke: "magnitude "
 -- 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- origin:isValueObj "Unit "
 -- 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- OI:invoke:B: "magnitude "E: "magnitude " rec: "R " useRtnV: true "
 --  magnitude: var Float " 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: magnitude: var Float E: "magnitude">newOff:1 useRTNv: "True"
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R isNotRemote: false 
 -- isCompositeValueObj: false E: "magnitude ""
 --  magnitude: var Float " true 
 -- E.ATd.isValueObj: true rec: "R "
 fpushg 4 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- OI:invoke:C: magnitude :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "R.magnitude ":isBasicVal: true 
 -- case:B: R.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* R.magnitude "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- INV:gen:after:E.loadArgs "L.magnitude * R.magnitude "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L.magnitude * R.magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- $BinOp:invoke: L.magnitude * R.magnitude 
 -- BinaryExp:invoke: "L.magnitude "rec: "L.magnitude * R.magnitude "
 -- M: "* R.magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- $ObjectInvocation_Binary:invoke: * R.magnitude >rec:"L.magnitude" ATd:"pattern" E:"* R.magnitude" E.ATd:*   unique:"False"
 -- OI:invoke: "* R.magnitude "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L.magnitude 
 -- origin:isValueObj "float "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L.magnitude 
 -- OI:invoke:B: "* R.magnitude "E: "* R.magnitude " rec: "
 --  L.magnitude " useRtnV: true 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:invoke: "*   "E: "* R.magnitude "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L.magnitude "E: "* R.magnitude "
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude 
 -- OI:invoke:C: * R.magnitude :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "U "dstE: "magnitude "dstE.ATd: "magnitude: var Float " 
 --  useRtn: false 
 --  :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "L.magnitude * R.magnitude "
 -- isArgOfAssignI2IwithUniValArg "
 --  U.magnitude := L.magnitude * R.magnitude "arg: "L.magnitude * R.magnitude "ObjectGenerator 
 -- arg.super.arg: "L.magnitude * R.magnitude "BinOp 
 -- recx:BinaryExp:recx: "L.magnitude * R.magnitude "
 -- M: "* R.magnitude "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- checkInt2IntWithUnitArg:rec: "L.magnitude "E: "* R.magnitude "
 -- arg:other 
 -- M:arg: "R.magnitude "ObjectGenerator false 
 -- dstDI: "magnitude: var Float " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "gMult "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 66 
 -- Items:GenClass: Area descNo: 66 isValue: false 
 -- Items:GenClass: Area descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Area 66 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 -- vdtAdd: inx=8 descInx=66 vDescInx=66 vdtTop: 8 
 -- Store itemArgs: 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- push:super.origin: 
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Dimension 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Dimension >on:0 superAdj:1 isValueObj:"False"
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Dimensions$38 1
 -- 
 -- $ObjectInvocation_Unary:getAdr: Dimension >ATd.off:0 (isPtn):on:0:superAdj:1 \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- 
 -- $pattern:getAdr:  \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Dimension " ATd: 
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- computeAdrX:isLast:E:  "Dimension "
 -- genClass:after:pushAddress: "Dimension "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- handleSuperArgs:E: "Dimension "theIS: 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- super.sig:not:none:superAdj: -1 
 -- 
 -- $ObjectInvocation_Unary:loadArgs: Dimension >staticOff:0  \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- 
 -- $pattern:loadArgs:  \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- ptn:loadArgs:E: "Dimension " 
 -- args: " " 
 -- hArgOrg:super: Dimension 
 -- Store itemArgs: 
 --  %dimension "A", "L*L"
 --  %requires Length
 --  %Public
 --  PrimaryUnit:: SquareMeter
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=66 vDescInx=39 vdtTop: 8 
 -- $Property:gen: %dimension "-top-" 
 -- $Property:gen: %public 
 -- $pattern:gen: PrimaryUnit:< Unit 
 -- 
 -- $pattern:gen:  \
 -- symbol:<  \
 --    %globals \
 --    out T: var StringLib.String
 -- $pattern:gen: MultArgL:< Unit 
 -- $pattern:gen: MultArgR:< Unit 
 -- $pattern:gen: MultRes:< Unit 
 -- 
 -- $pattern:gen:  \
 -- gMult:<  \
 --    in L: var MultArgL \
 --    in R: var MultArgR
 -- $Property:gen: %dimension "A", "L*L" 
 -- $Property:gen: %requires Length 
 -- $Property:gen: %Public 
 -- $pattern:gen: PrimaryUnit:: SquareMeter 
 -- 
 -- $pattern:gen:  \
 -- symbol::  \
 --    T := "A" 
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "A", "L*L" " 
 -- $Property:gen: %dimension "A", "L*L" 
 -- genclass:stmt: "%requires Length " 
 -- $Property:gen: %requires Length 
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=66 vDescInx=67 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=66 vDescInx=71 vdtTop: 8 

 CLASS PrimaryUnit#67 67 1 Area$66 66 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 68 
 invoke SquareMeter 68 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 67  newDescNo:  66 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 68 
 -- Items:GenClass: SquareMeter descNo: 68 isValue: true 
 -- Items:GenClass: SquareMeter descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS SquareMeter 68 0 Area 66 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit "theIS: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- super.sig:not:none:superAdj: 0 
 -- 
 -- $ObjectInvocation_Unary:loadArgs: Unit >staticOff:0  \
 -- Unit: Value \
 --    %unit "U", 1 \
 --    %public
 -- 
 -- $pattern:loadArgs:  \
 -- Unit: Value \
 --    %unit "U", 1 \
 --    %public
 -- ptn:loadArgs:E: "Unit " 
 -- args: " " 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- vdtAdd: inx=1 descInx=68 vDescInx=40 vdtTop: 9 
 -- $Property:gen: %unit "U", 1 
 -- $Property:gen: %public 
 -- $var:gen: magnitude: var Float 
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 -- $pattern:gen: thisUnit:< Unit 
 -- $pattern:gen: argUnit:< Unit 
 -- $pattern:gen: resUnit:< Unit 
 -- 
 -- $pattern:gen:  \
 -- toPrimary:<  \
 --    out base: var PrimaryUnit \
 --    inner(toPrimary) 
 -- 
 -- $pattern:gen:  \
 -- fromPrimary:<  \
 --    in base: var PrimaryUnit \
 --    inner(fromPrimary) 
 -- 
 -- $pattern:gen:  \
 -- print:<  \
 --    "Unit:".print \
 --    inner(print)
 -- $Property:gen: %unit "m2", 1 
 -- $Property:gen: %Public 
 -- $pattern:gen: thisUnit:: SquareMeter 
 -- 
 -- $pattern:gen:  \
 -- print::  \
 --    "SquareMeter".print 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%unit "m2", 1 " 
 -- $Property:gen: %unit "m2", 1 
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=9 descInx=68 vDescInx=70 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 70 
 -- Items:GenClass: print descNo: 70 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 70 1 SquareMeter 68
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=70 vDescInx=70 vdtTop: 2 
 -- Store itemArgs: ""SquareMeter".print " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: " "theIS: ""SquareMeter".print " 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs:  
 -- hArgOrg:super: print 
 -- Store itemArgs: ""SquareMeter".print " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=70 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""SquareMeter".print " 
 -- $ObjectGenerator:gen: "SquareMeter".print >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: ""SquareMeter".print " 
 -- OG:before:super.gen: ""SquareMeter".print "
 -- $Invocation:gen: "SquareMeter".print >useRtnV:"False"superAdj: 0 descNo: 52
 -- INV:gen: ""SquareMeter".print " 
 -- isConstant: "Invocation """SquareMeter".print "
 -- needorigin: ""SquareMeter".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""SquareMeter" " rec: ""SquareMeter" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""SquareMeter" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""SquareMeter" "E:  ""SquareMeter" "
 -- INV:gen:E.loadArgs ""SquareMeter" "
 -- $String::loadArgs: "SquareMeter" 
 -- INV:gen:after:E.loadArgs ""SquareMeter" "
 --  OIadr: 
 -- $String::invoke: "SquareMeter" 
 pushText "SquareMeter"
 -- IV:gen:checkTail: ""SquareMeter".print "E: ""SquareMeter" "tail: "
 --  print " not isLast: false 
 -- 
 -- $ObjectInvocation_Unary:loadArgs: print >staticOff:0  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- 
 -- $pattern:loadArgs:  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- ptn:loadArgs:E: "print " 
 -- args: " " 
 -- $ObjectInvocation_Unary:invoke: print >rec:""SquareMeter"" ATd:"pattern" E:"print" E.ATd:print unique:"False"
 -- OI:invoke: "print "
 -- 
 -- OI:invoke:B: "print "E: "print " rec: ""SquareMeter" " useRtnV: 
 --  false 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- 
 -- $pattern:invoke:  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "
 --  "SquareMeter" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: print :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 71 
 -- Items:GenClass: symbol descNo: 71 isValue: false 
 -- Items:GenClass: symbol descNo: 63 isValue: false 
 -- Items:GenClass: symbol descNo: 21 isValue: false 

 CLASS symbol 71 1 Area 66
 -- vdtTableCopy: I:1:63 I:2:0
 -- vdtAdd: inx=2 descInx=71 vDescInx=71 vdtTop: 2 
 -- Store itemArgs: "T := "A" " 
 -- super symbol
 -- push:super.origin: 
 -- hArgOrg:super: symbol 
 -- Store itemArgs: "T := "A" " 
 allocEventQ
 -- vdtAdd: inx=1 descInx=71 vDescInx=63 vdtTop: 2 
 -- $Property:gen: %globals 
 -- $var:gen: out T: var StringLib.String 
 -- DI:gen: "out T: var StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- genclass:stmt: "T := "A" " 
 -- $Assign:gen: T := "A" 
 -- AssignmentStatement:gen: "T := "A" " 
 -- computeAdrG:superAdj: 0 "T "
 -- computeAdrG: 1 :rec: "none " E: "T "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: T 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: T >on:0 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: T >ATd.off:2:on:0:superAdj:0out T: var StringLib.String:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 T := "A" 
 -- BOBS:ATd: "out T: var StringLib.String "
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: out T: var StringLib.String >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"T":rec:-
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "T "
 -- AssignmentStatement:gen: 
 --  "T := "A" " right.label: "ObjectGenerator """A" " 
 -- $ObjectGenerator:gen: "A" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: ""A" " 
 -- OG:before:super.gen: ""A" "
 -- $Invocation:gen: "A" >useRtnV:"True"superAdj: 0
 -- INV:gen: ""A" " 
 -- isConstant: "Invocation """A" "
 -- needorigin: ""A" " 
 -- needOrigin:E: ""A" "  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5Ex: ""A" " rec: ""A" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5E.ATd.desc: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %publicE.ATd.IT: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""A" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""A" "E:  ""A" "
 -- INV:gen:E.loadArgs ""A" "
 -- $String::loadArgs: "A" 
 -- INV:gen:after:E.loadArgs ""A" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""A" "
 -- $String::invoke: "A" 
 pushText "A"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "T "dstE: "T "dstE.ATd: "out T: var StringLib.String " 
 --  useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 72 
 -- Items:GenClass: Length descNo: 72 isValue: false 
 -- Items:GenClass: Length descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Length 72 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 -- vdtAdd: inx=8 descInx=72 vDescInx=72 vdtTop: 8 
 -- Store itemArgs: 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- push:super.origin: 
 -- computeAdrX:superAdj: 1 "Dimension " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Dimension " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Dimension 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Dimension >on:0 superAdj:1 isValueObj:"False"
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Dimensions$38 1
 -- 
 -- $ObjectInvocation_Unary:getAdr: Dimension >ATd.off:0 (isPtn):on:0:superAdj:1 \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- 
 -- $pattern:getAdr:  \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Dimension " ATd: 
 --  Dimension: 
 --     %dimension "-top-"
 --     %public
 --     PrimaryUnit:< Unit
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- computeAdrX:isLast:E:  "Dimension "
 -- genClass:after:pushAddress: "Dimension "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- handleSuperArgs:E: "Dimension "theIS: 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- super.sig:not:none:superAdj: -1 
 -- 
 -- $ObjectInvocation_Unary:loadArgs: Dimension >staticOff:0  \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- 
 -- $pattern:loadArgs:  \
 -- Dimension:  \
 --    %dimension "-top-" \
 --    %public
 -- ptn:loadArgs:E: "Dimension " 
 -- args: " " 
 -- hArgOrg:super: Dimension 
 -- Store itemArgs: 
 --  %dimension "L"
 --  %requires Area
 --  %Public
 --  PrimaryUnit:: Meter
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=72 vDescInx=39 vdtTop: 8 
 -- $Property:gen: %dimension "-top-" 
 -- $Property:gen: %public 
 -- $pattern:gen: PrimaryUnit:< Unit 
 -- 
 -- $pattern:gen:  \
 -- symbol:<  \
 --    %globals \
 --    out T: var StringLib.String
 -- $pattern:gen: MultArgL:< Unit 
 -- $pattern:gen: MultArgR:< Unit 
 -- $pattern:gen: MultRes:< Unit 
 -- 
 -- $pattern:gen:  \
 -- gMult:<  \
 --    in L: var MultArgL \
 --    in R: var MultArgR
 -- $Property:gen: %dimension "L" 
 -- $Property:gen: %requires Area 
 -- $Property:gen: %Public 
 -- $pattern:gen: PrimaryUnit:: Meter 
 -- 
 -- $pattern:gen:  \
 -- symbol::  \
 --    T := "L" 
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "L" " 
 -- $Property:gen: %dimension "L" 
 -- genclass:stmt: "%requires Area " 
 -- $Property:gen: %requires Area 
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=72 vDescInx=73 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=72 vDescInx=81 vdtTop: 8 

 CLASS PrimaryUnit#73 73 1 Length$72 72 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 74 
 invoke Meter 74 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 73  newDescNo:  72 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 74 
 -- Items:GenClass: Meter descNo: 74 isValue: true 
 -- Items:GenClass: Meter descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Meter 74 0 Length 72 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit "theIS: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- super.sig:not:none:superAdj: 0 
 -- 
 -- $ObjectInvocation_Unary:loadArgs: Unit >staticOff:0  \
 -- Unit: Value \
 --    %unit "U", 1 \
 --    %public
 -- 
 -- $pattern:loadArgs:  \
 -- Unit: Value \
 --    %unit "U", 1 \
 --    %public
 -- ptn:loadArgs:E: "Unit " 
 -- args: " " 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: 
 --  %unit "m", 1
 --  %Public
 --  thisUnit:: Meter
 --  argUnit:: Meter
 -- vdtAdd: inx=1 descInx=74 vDescInx=40 vdtTop: 9 
 -- $Property:gen: %unit "U", 1 
 -- $Property:gen: %public 
 -- $var:gen: magnitude: var Float 
 -- DI:gen: "magnitude: var Float " DI:isConst: false isBasicValue: 
 --  true primNo: 9 
 -- DI:gen:primitiveType: magnitude 
 -- $pattern:gen: thisUnit:< Unit 
 -- $pattern:gen: argUnit:< Unit 
 -- $pattern:gen: resUnit:< Unit 
 -- 
 -- $pattern:gen:  \
 -- toPrimary:<  \
 --    out base: var PrimaryUnit \
 --    inner(toPrimary) 
 -- 
 -- $pattern:gen:  \
 -- fromPrimary:<  \
 --    in base: var PrimaryUnit \
 --    inner(fromPrimary) 
 -- 
 -- $pattern:gen:  \
 -- print:<  \
 --    "Unit:".print \
 --    inner(print)
 -- $Property:gen: %unit "m", 1 
 -- $Property:gen: %Public 
 -- $pattern:gen: thisUnit:: Meter 
 -- $pattern:gen: argUnit:: Meter 
 -- $pattern:gen: resUnit:: Area.SquareMeter 
 -- 
 -- $pattern:gen:  \
 -- toPrimary::  \
 --    base.magnitude := magnitude 
 -- 
 -- $pattern:gen:  \
 -- fromPrimary::  \
 --    magnitude := base.magnitude 
 -- 
 -- $pattern:gen:  \
 -- print::  \
 --    "Meter".print 
 rtnAlloc 1
 toSuper 40
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%unit "m", 1 " 
 -- $Property:gen: %unit "m", 1 
 -- genclass:stmt: "%Public " 
 -- $Property:gen: %Public 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=74 vDescInx=78 vdtTop: 9 
 -- vdtAdd: inx=8 descInx=74 vDescInx=79 vdtTop: 9 
 -- vdtAdd: inx=9 descInx=74 vDescInx=80 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 78 
 -- Items:GenClass: toPrimary descNo: 78 isValue: false 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 78 1 Meter 74
 -- vdtTableCopy: I:1:49 I:2:0
 -- vdtAdd: inx=2 descInx=78 vDescInx=78 vdtTop: 2 
 -- Store itemArgs: "base.magnitude := magnitude " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super toPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: " "theIS: "base.magnitude := magnitude " 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs:  
 -- hArgOrg:super: toPrimary 
 -- Store itemArgs: "base.magnitude := magnitude " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=78 vDescInx=49 vdtTop: 2 
 -- $var:gen: out base: var PrimaryUnit 
 -- DI:gen: "out base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- DI:off: 2 this: "out base: var PrimaryUnit " 
 --  
 -- $ObjectGenerator:gen: PrimaryUnit >OGid:"Unit" IS.isempty! staticOff=2 descNo=0 superAdj=0
 -- OG:gen: "PrimaryUnit " 
 -- OG:before:super.gen: "PrimaryUnit "
 -- $Invocation:gen: PrimaryUnit >useRtnV:"False"superAdj: 0 descNo: 0
 -- INV:gen: "PrimaryUnit " 
 -- isConstant: "Invocation ""PrimaryUnit "
 -- needorigin: "PrimaryUnit " 
 -- needOrigin:E: "PrimaryUnit "  E.ATd: "PrimaryUnit:< Unit " Ex: "
 --  PrimaryUnit " rec: "PrimaryUnit " E.ATd: "PrimaryUnit:< Unit " E.ATd.desc: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< UnitE.ATd.IT: " " 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 -- after:needOrigin: "PrimaryUnit " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "PrimaryUnit "E:  "PrimaryUnit "
 -- INV:gen:E.loadArgs "PrimaryUnit "
 -- $ObjectInvocation_Unary:loadArgs: PrimaryUnit >staticOff:0 PrimaryUnit:< Unit superAdj:0
 -- $pattern:loadArgs: PrimaryUnit:< Unit >E:"PrimaryUnit":descNo:0
 -- ptn:loadArgs:E: "PrimaryUnit " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "PrimaryUnit "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  PrimaryUnit "
 -- $ObjectInvocation_Unary:invoke: PrimaryUnit >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:PrimaryUnit unique:"False"
 -- OI:invoke: "PrimaryUnit "
 -- 
 -- OI:invoke:B: "PrimaryUnit "E: "PrimaryUnit " rec: "PrimaryUnit "
 --   useRtnV: false "PrimaryUnit:< Unit " 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: PrimaryUnit:< Unit E: "PrimaryUnit" useRTNv: "False"
 -- ptn:invoke: "PrimaryUnit "E: "PrimaryUnit "ptnKind: 1 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 2 rec: "PrimaryUnit " 
 --  adr:none 
 -- isStatic: true rec: "PrimaryUnit "
 invokeVal  PrimaryUnit 40 1
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- genclass:stmt: "base.magnitude := magnitude " 
 -- $Assign:gen: base.magnitude := magnitude 
 -- AssignmentStatement:gen: "base.magnitude := magnitude " 
 -- computeAdrG:superAdj: 0 "base.magnitude "
 -- computeAdrG: 1 :rec: "none " E: "base "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: base 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: base >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: base >ATd.off:2:on:0:superAdj:0out base: var PrimaryUnit:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out base: var PrimaryUnit >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"base":rec:-
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "out base: var PrimaryUnit "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdrG: 2 :rec: "base " E: "magnitude " A.E: "base "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:0:superAdj:0magnitude: var Float:Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdrG:isLast:E:  "magnitude "
 -- AssignmentStatement:gen: 
 --  "base.magnitude := magnitude " right.label: "ObjectGenerator ""
 --  magnitude " 
 -- $ObjectGenerator:gen: magnitude >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "magnitude " 
 -- OG:before:super.gen: "magnitude "
 -- $Invocation:gen: magnitude >useRtnV:"True"superAdj: 0
 -- INV:gen: "magnitude " 
 -- isConstant: "Invocation ""magnitude "
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: "
 --  magnitude " rec: "magnitude " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "magnitude " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: magnitude 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: magnitude >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "toPrimary "on: 1 isValueObj: false 
 --  origin: Meter origin:isValueObj: true 
 rpushg toPrimary$78 1
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:1:superAdj:0magnitude: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"magnitude":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude " ATd: "magnitude: var Float " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 --  rec:  "magnitude "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- $ObjectInvocation_Unary:loadArgs: magnitude >staticOff:0 magnitude: var Float superAdj:0
 -- $var:loadArgs: magnitude: var Float >E:"magnitude"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "magnitude " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- $ObjectInvocation_Unary:invoke: magnitude >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:magnitude unique:"False"
 -- OI:invoke: "magnitude "
 -- 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit "
 -- 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude "E: "magnitude " rec: "magnitude "
 --   useRtnV: true "magnitude: var Float " 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: magnitude: var Float E: "magnitude">newOff:1 useRTNv: "True"
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude isNotRemote: true 
 -- isCompositeValueObj: false E: "magnitude ""
 --  magnitude: var Float " true 
 -- E.ATd.isValueObj: true rec: "magnitude "
 -- load:isValue:E: "magnitude "originIsValue: true 
 --  E.ATd:isValueObj: true 
 -- E.ATd: "magnitude: var Float " 
 --  E.ATd.origin: 
 --  %unit "U", 1
 --  %public
 --  magnitude: var Float
 --  thisUnit:< Unit
 --  (E.ATd.origin.ogOfScope): 
 --  Value
 --     %unit "U", 1
 --     %public
 --     magnitude: var Float
 fvpushg 1 Meter$74
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:C: magnitude :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- rec: "base "dstE: "magnitude "dstE.ATd: "magnitude: var Float " 
 --  useRtn: false 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "magnitude "
 -- isArgOfAssignI2IwithUniValArg "base.magnitude := magnitude "arg: "
 --  magnitude "ObjectGenerator 
 -- arg.super.arg: "magnitude "ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 79 
 -- Items:GenClass: fromPrimary descNo: 79 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 79 1 Meter 74
 -- vdtTableCopy: I:1:50 I:2:0
 -- vdtAdd: inx=2 descInx=79 vDescInx=79 vdtTop: 2 
 -- Store itemArgs: "magnitude := base.magnitude " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super fromPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: " "theIS: "magnitude := base.magnitude " 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs:  
 -- hArgOrg:super: fromPrimary 
 -- Store itemArgs: "magnitude := base.magnitude " 
 -- in base: var PrimaryUnit 0 
 -- DI:store: "base "
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L4
 L3:
 invokeVal  base 40 1
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=79 vDescInx=50 vdtTop: 2 
 -- $var:gen: in base: var PrimaryUnit 
 -- DI:gen: "in base: var PrimaryUnit " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- genclass:stmt: "magnitude := base.magnitude " 
 -- $Assign:gen: magnitude := base.magnitude 
 -- AssignmentStatement:gen: "magnitude := base.magnitude " 
 -- computeAdrG:superAdj: 0 "magnitude "
 -- computeAdrG: 1 :rec: "none " E: "magnitude "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: magnitude 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: magnitude >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "fromPrimary "on: 1 isValueObj: false 
 --  origin: Meter origin:isValueObj: true 
 rpushg fromPrimary$79 1
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:1:superAdj:0magnitude: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"magnitude":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude " ATd: "magnitude: var Float " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdrG:isLast:E:  "magnitude "
 -- AssignmentStatement:gen: 
 --  "magnitude := base.magnitude " right.label: "ObjectGenerator ""
 --  base.magnitude " 
 -- $ObjectGenerator:gen: base.magnitude >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "base.magnitude " 
 -- OG:before:super.gen: "base.magnitude "
 -- $Invocation:gen: base.magnitude >useRtnV:"True"superAdj: 0
 -- INV:gen: "base.magnitude " 
 -- isConstant: "Invocation ""base.magnitude "
 -- notConst: base in base: var PrimaryUnit 
 -- needorigin: "base.magnitude " 
 -- needOrigin:E: "magnitude "  E.ATd: "magnitude: var Float " Ex: 
 --  none rec: "base " E.ATd: "magnitude: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "magnitude " 
 -- doNeedOrigin:E: "magnitude " 
 -- computeAdrX:superAdj: 0 "base.magnitude " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "base " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: base 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: base >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: base >ATd.off:2:on:0:superAdj:0in base: var PrimaryUnit:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in base: var PrimaryUnit >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"base":rec:-
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "in base: var PrimaryUnit "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdrX:En: 2 pRec: "base " rec: "base " E: "magnitude " 
 --  A.E: "base "
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: magnitude >ATd.off:1:on:0:superAdj:0magnitude: var Float:Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:-
 -- $var:getAdr: magnitude: var Float >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdrX:isLast:E:  "magnitude "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 --  rec:  "base "E:  "magnitude "
 -- INV:gen:E.loadArgs "magnitude "
 -- $ObjectInvocation_Unary:loadArgs: magnitude >staticOff:0 magnitude: var Float superAdj:0
 -- $var:loadArgs: magnitude: var Float >E:"magnitude"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "magnitude " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "magnitude "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:invoke: magnitude >rec:"base" ATd:"var" isValueObj E:"magnitude" E.ATd:magnitude unique:"False"
 -- OI:invoke: "magnitude "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- origin:isValueObj "Unit "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- OI:invoke:B: "magnitude "E: "magnitude " rec: "base " useRtnV: 
 --  true "magnitude: var Float " 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: magnitude: var Float E: "magnitude">newOff:1 useRTNv: "True"
 -- DI:invoke: "magnitude: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base isNotRemote: false 
 -- isCompositeValueObj: false E: "magnitude ""
 --  magnitude: var Float " true 
 -- E.ATd.isValueObj: true rec: "base "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- OI:invoke:C: magnitude :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- rec: "magnitude "dstE: "magnitude "dstE.ATd: "
 --  magnitude: var Float " useRtn: false 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "base.magnitude "
 -- isArgOfAssignI2IwithUniValArg "magnitude := base.magnitude "arg: "
 --  base.magnitude "ObjectGenerator 
 -- arg.super.arg: "base "ObjectInvocation_Unary 
 -- arg.super.arg: "magnitude "ObjectInvocation_Unary 
 -- recx: "base "argx: "magnitude "
 -- checkInt2IntWithUnitArg:rec: "base "E: "magnitude "
 -- dstDI: "magnitude: var Float " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- Address:store:originIsVal: 
 fvstoreg  1 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 80 
 -- Items:GenClass: print descNo: 80 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 80 1 Meter 74
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=80 vDescInx=80 vdtTop: 2 
 -- Store itemArgs: ""Meter".print " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: " "theIS: ""Meter".print " 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs:  
 -- hArgOrg:super: print 
 -- Store itemArgs: ""Meter".print " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=80 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Meter".print " 
 -- $ObjectGenerator:gen: "Meter".print >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: ""Meter".print " 
 -- OG:before:super.gen: ""Meter".print "
 -- $Invocation:gen: "Meter".print >useRtnV:"False"superAdj: 0 descNo: 52
 -- INV:gen: ""Meter".print " 
 -- isConstant: "Invocation """Meter".print "
 -- needorigin: ""Meter".print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatEx: ""Meter" " rec: ""Meter" " E.ATd: 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeatE.ATd.desc: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])E.ATd.IT: 
 --  gogo: 
 --     "gogo\n".print
 --  for(1):to(length):repeat
 --     put(get[inx])
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""Meter" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""Meter" "E:  ""Meter" "
 -- INV:gen:E.loadArgs ""Meter" "
 -- $String::loadArgs: "Meter" 
 -- INV:gen:after:E.loadArgs ""Meter" "
 --  OIadr: 
 -- $String::invoke: "Meter" 
 pushText "Meter"
 -- IV:gen:checkTail: ""Meter".print "E: ""Meter" "tail: "print "
 --   not isLast: false 
 -- 
 -- $ObjectInvocation_Unary:loadArgs: print >staticOff:0  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- 
 -- $pattern:loadArgs:  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- ptn:loadArgs:E: "print " 
 -- args: " " 
 -- $ObjectInvocation_Unary:invoke: print >rec:""Meter"" ATd:"pattern" E:"print" E.ATd:print unique:"False"
 -- OI:invoke: "print "
 -- 
 -- OI:invoke:B: "print "E: "print " rec: ""Meter" " useRtnV: false 
 --  print: 
 --     gogo: 
 --        "gogo\n".print
 --     for(1):to(length):repeat
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- 
 -- $pattern:invoke:  \
 -- print:  \
 --    gogo:  \
 --       "gogo\n".print
 -- ptn:invoke: "print "E: "print "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: ""Meter" " 
 --  adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: print :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 81 
 -- Items:GenClass: symbol descNo: 81 isValue: false 
 -- Items:GenClass: symbol descNo: 63 isValue: false 
 -- Items:GenClass: symbol descNo: 21 isValue: false 

 CLASS symbol 81 1 Length 72
 -- vdtTableCopy: I:1:63 I:2:0
 -- vdtAdd: inx=2 descInx=81 vDescInx=81 vdtTop: 2 
 -- Store itemArgs: "T := "L" " 
 -- super symbol
 -- push:super.origin: 
 -- hArgOrg:super: symbol 
 -- Store itemArgs: "T := "L" " 
 allocEventQ
 -- vdtAdd: inx=1 descInx=81 vDescInx=63 vdtTop: 2 
 -- $Property:gen: %globals 
 -- $var:gen: out T: var StringLib.String 
 -- DI:gen: "out T: var StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out T: var StringLib.String "
 pushText ""
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- genclass:stmt: "T := "L" " 
 -- $Assign:gen: T := "L" 
 -- AssignmentStatement:gen: "T := "L" " 
 -- computeAdrG:superAdj: 0 "T "
 -- computeAdrG: 1 :rec: "none " E: "T "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: T 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: T >on:0 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: T >ATd.off:2:on:0:superAdj:0out T: var StringLib.String:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 T := "L" 
 -- BOBS:ATd: "out T: var StringLib.String "
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: out T: var StringLib.String >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"T":rec:-
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "T "
 -- AssignmentStatement:gen: 
 --  "T := "L" " right.label: "ObjectGenerator """L" " 
 -- $ObjectGenerator:gen: "L" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: ""L" " 
 -- OG:before:super.gen: ""L" "
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0
 -- INV:gen: ""L" " 
 -- isConstant: "Invocation """L" "
 -- needorigin: ""L" " 
 -- needOrigin:E: ""L" "  E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5Ex: ""L" " rec: ""L" " E.ATd: 
 --  String: Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5E.ATd.desc: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %publicE.ATd.IT: 
 --  %id "String pattern"
 --  %OSDvisibility disguised
 --  %basic 5
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %id "String pattern"
 --     %OSDvisibility disguised
 --     %basic 5
 -- after:needOrigin: ""L" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  ""L" "E:  ""L" "
 -- INV:gen:E.loadArgs ""L" "
 -- $String::loadArgs: "L" 
 -- INV:gen:after:E.loadArgs ""L" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""L" "
 -- $String::invoke: "L" 
 pushText "L"
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "T "dstE: "T "dstE.ATd: "out T: var StringLib.String " 
 --  useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 82 
 -- Items:GenClass: StringLib descNo: 82 isValue: false 
 -- Items:GenClass: StringLib descNo: 21 isValue: false 

 CLASS StringLib 82 1 LIB 33
 -- Store itemArgs: 
 --  %id "String module"
 --  %module LIB
 --  %public
 --  String: Value
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=82 vDescInx=82 vdtTop: 1 
 saveStringOrigin
 mvStack 
 -- $Property:gen: %id "String module" 
 -- $Property:gen: %module LIB 
 -- $Property:gen: %public 
 -- 
 -- $pattern:gen:  \
 -- String: Value \
 --    %id "String pattern" \
 --    %OSDvisibility disguised
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "String module" " 
 -- $Property:gen: %id "String module" 
 -- genclass:stmt: "%module LIB " 
 -- $Property:gen: %module LIB 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "StringLib "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 18 
 -- Items:GenClass: $18 descNo: 18 isValue: false 
 -- Items:GenClass: $18 descNo: 21 isValue: false 

 CLASS $18 18 1 loop 14
 -- Store itemArgs: "leave(loop) " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=18 vDescInx=18 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "leave(loop) " 
 -- $ObjectGenerator:gen: leave(loop) >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "leave(loop) " 
 -- OG:before:super.gen: "leave(loop) "
 -- $Invocation:gen: leave(loop) >useRtnV:"False"superAdj: 0 descNo: 19
 -- INV:gen: "leave(loop) " 
 -- isConstant: "Invocation ""leave(loop) "
 -- needorigin: "leave(loop) " 
 -- needOrigin:E: "leave(loop) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop) " rec: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(loop) " 
 -- doNeedOrigin:E: "leave(loop) " 
 -- computeAdrX:superAdj: 0 "leave(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: leave(loop) 
 -- $ObjectInvocation_KeyWord:loadOrigin: leave(loop) >on:5 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: leave(loop) >ATd.off:0 (isPtn):on:5:superAdj:0 \
 -- leave(V: var integer):  \
 --    %basic 103:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- leave(V: var integer):  \
 --    %basic 103 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "leave(loop) " ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: leave(loop) >staticOff:0  \
 -- leave(V: var integer):  \
 --    %basic 103 superAdj:0arg:loop
 -- 
 -- $pattern:loadArgs:  \
 -- leave(V: var integer):  \
 --    %basic 103 >E:"leave(loop)":descNo:19
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: leave(loop) >rec:"leave(loop)" ATd:"pattern" E:"leave(loop)" E.ATd:leave(V: var integer) unique:"False"
 -- OI:invoke: "leave(loop) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:B: "leave(loop) "E: "leave(loop) " rec: "leave(loop) "
 --   useRtnV: false 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- leave(V: var integer):  \
 --    %basic 103 E: "leave(loop)" useRTNv: "False"
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 
 --  useRtnV: false 
 break  1 2 14 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:C: leave(loop) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 83 
 -- Items:GenClass: Boolean descNo: 83 isValue: true 
 -- Items:GenClass: Boolean descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Boolean 83 0 BETA 2 isValueObj
 -- Store itemArgs: 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %public
 -- vdtAdd: inx=1 descInx=83 vDescInx=83 vdtTop: 1 
 mvStack 
 -- $Property:gen: %id "Boolean" 
 -- $Property:gen: %globals inSub 
 -- $Property:gen: %basic 4, 8 
 -- $Property:gen: %public 
 -- $var:gen: _thisBasicValue: var Universal 
 -- DI:gen: "_thisBasicValue: var Universal " DI:isConst: false 
 --  isBasicValue: true primNo: 1 
 -- DI:gen:primitiveType: _thisBasicValue 
 rtnAlloc 1
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%id "Boolean" " 
 -- $Property:gen: %id "Boolean" 
 -- genclass:stmt: "%globals inSub " 
 -- $Property:gen: %globals inSub 
 -- genclass:stmt: "%basic 4, 8 " 
 -- $Property:gen: %basic 4, 8 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "Boolean "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 23 
 -- Items:GenClass: True descNo: 23 isValue: false 
 -- Items:GenClass: True descNo: 21 isValue: false 

 CLASS True 23 0 BETA 2
 -- Store itemArgs: 
 --  %globals
 --  out B: var boolean
 --  B := 1
 --  
 allocEventQ
 -- vdtAdd: inx=1 descInx=23 vDescInx=23 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 -- $var:gen: out B: var boolean 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "B := 1 " 
 -- $Assign:gen: B := 1 
 -- AssignmentStatement:gen: "B := 1 " 
 -- computeAdrG:superAdj: 0 "B "
 -- computeAdrG: 1 :rec: "none " E: "B "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: B 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: B >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: B >ATd.off:1:on:0:superAdj:0out B: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out B: var boolean >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"B":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out B: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdrG:isLast:E:  "B "
 -- AssignmentStatement:gen: 
 --  "B := 1 " right.label: "ObjectGenerator ""1 " 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "B "dstE: "B "dstE.ATd: "out B: var boolean " useRtn: false 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "1 "
 -- isArgOfAssignI2IwithUniValArg "B := 1 "arg: "1 "ObjectGenerator 
 -- arg.super.arg: "1 "ConstLiteral 
 -- dstDI: "out B: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg True$23 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "True "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 24 
 -- Items:GenClass: repeat$24 descNo: 24 isValue: false 
 -- Items:GenClass: repeat$24 descNo: 21 isValue: false 

 CLASS repeat$24 24 1 for:to:repeat$30 30
 -- Store itemArgs: 
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 <> c2) :then 
 --     Beq := false
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=24 vDescInx=24 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "c1 := get[inx] " 
 -- $Assign:gen: c1 := get[inx] 
 -- AssignmentStatement:gen: "c1 := get[inx] " 
 -- computeAdrG:superAdj: 0 "c1 "
 -- computeAdrG: 1 :rec: "none " E: "c1 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c1 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: c1 >ATd.off:2:on:2:superAdj:0c1: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c1: var char >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c1":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 " ATd: "c1: var char " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdrG:isLast:E:  "c1 "
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- $ObjectGenerator:gen: get[inx] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- $Invocation:gen: get[inx] >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "get[inx] " 
 -- isConstant: "Invocation ""get[inx] "
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: get[inx] 
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: get[inx] >on:4 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 3 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[inx] >ATd.off:0 (isPtn):on:4:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx] " ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[inx] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[inx]":descNo:16
 -- ptn:loadArgs:E: "get[inx] " 
 -- args: "get[inx] " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$30$30
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: get[inx] >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[inx] "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx] "E: "get[inx] " rec: "get[inx] " useRtnV: 
 --  true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[inx]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:C: get[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "c1 "dstE: "c1 "dstE.ATd: "c1: var char " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx] "
 -- isArgOfAssignI2IwithUniValArg "c1 := get[inx] "arg: "get[inx] "
 --  ObjectGenerator 
 -- arg.super.arg: "get[inx] "ObjectInvocation_KeyWord 
 -- dstDI: "c1: var char " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "c2 := Veq.get[inx] " 
 -- $Assign:gen: c2 := Veq.get[inx] 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx] " 
 -- computeAdrG:superAdj: 0 "c2 "
 -- computeAdrG: 1 :rec: "none " E: "c2 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c2 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: c2 >ATd.off:3:on:2:superAdj:0c2: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c2: var char >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c2":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2 " ATd: "c2: var char " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdrG:isLast:E:  "c2 "
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx] " right.label: "ObjectGenerator ""
 --  Veq.get[inx] " 
 -- $ObjectGenerator:gen: Veq.get[inx] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "Veq.get[inx] " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- $Invocation:gen: Veq.get[inx] >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "Veq.get[inx] " 
 -- isConstant: "Invocation ""Veq.get[inx] "
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "Veq " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "Veq.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Veq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Veq >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: Veq >ATd.off:2:on:3:superAdj:0in Veq: var this(Value):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop) 
 -- BOBS:ATd: "in Veq: var this(Value) "
 -- String:vEq:  "Veq "off:  2 ATd: "in Veq: var this(Value) " 
 -- E.on: 3 
 -- beforeIsValueObj:E: "Veq " ATd: "in Veq: var this(Value) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[inx] >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --     inner(= )
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  false true 
 -- $ObjectInvocation_Unary:loadArgs: Veq >staticOff:0 in Veq: var this(Value) superAdj:0
 -- $var:loadArgs: in Veq: var this(Value) >E:"Veq"
 -- 
 -- $pattern:loadArgs:  \
 -- this:  \
 --    %basic 18 \
 --    in this: ref Object >E:"Veq":descNo:31
 -- computeAdrX:before:rec:: "Veq " 
 -- $ObjectInvocation_Unary:invoke: Veq >rec:"Veq" ATd:"var" isValueObj E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "Veq "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "Veq "E: "get[inx] " rec: "Veq " useRtnV: true "
 --  in Veq: var this(Value) " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: in Veq: var this(Value) E: "get[inx]">newOff:2 useRTNv: "True"
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""
 --  ObjectInvocation_KeyWord "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg repeat$24$24 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:C: Veq :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- checkInt2IntWithUnitArg:rec: "Veq "E: "get[inx] "
 -- arg:other 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[inx] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[inx]":descNo:16
 -- ptn:loadArgs:E: "get[inx] " 
 -- args: "get[inx] " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$30$30
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- $ObjectInvocation_KeyWord:invoke: get[inx] >rec:"Veq" ATd:"pattern" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[inx] "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "get[inx] "E: "get[inx] " rec: "Veq " useRtnV: true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[inx]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:C: get[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec: "c2 "dstE: "c2 "dstE.ATd: "c2: var char " useRtn: false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "Veq.get[inx] "
 -- isArgOfAssignI2IwithUniValArg "c2 := Veq.get[inx] "arg: "
 --  Veq.get[inx] "ObjectGenerator 
 -- arg.super.arg: "Veq "ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx] "ObjectInvocation_KeyWord 
 -- recx: "Veq "argx: "get[inx] "
 -- checkInt2IntWithUnitArg:rec: "Veq "E: "get[inx] "
 -- arg:other 
 -- dstDI: "c2: var char " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 3
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (c1 <> c2) :then  \
 --    Beq := false \
 --    leave(loop) >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- OG:before:super.gen: "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- 
 -- $Invocation:gen:  \
 -- if (c1 <> c2) :then  \
 --    Beq := false \
 --    leave(loop) >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- isConstant: "Invocation ""
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- needorigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  rec: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "E:  "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- INV:gen:E.loadArgs "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (c1 <> c2) :then  \
 --    Beq := false \
 --    leave(loop) 
 -- INV:gen:after:E.loadArgs "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (c1 <> c2) :then 
 --     Beq := false
 --     leave(loop) "
 -- 
 -- $IfThen:invoke:  \
 -- if (c1 <> c2) :then  \
 --    Beq := false \
 --    leave(loop) 
 -- 
 -- $IfThen:gen:  \
 -- if (c1 <> c2) :then  \
 --    Beq := false \
 --    leave(loop) 
 -- $ObjectGenerator:gen: (c1 <> c2) >OGid:"<>" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(c1 <> c2) " 
 -- OG:before:super.gen: "(c1 <> c2) "
 -- $Invocation:gen: (c1 <> c2) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(c1 <> c2) " 
 -- isConstant: "Invocation ""(c1 <> c2) "
 -- needorigin: "(c1 <> c2) " 
 -- needOrigin:E: "(c1 <> c2) "  E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  Ex: "(c1 <> c2) " rec: "(c1 <> c2) " E.ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 55
 --  in V: var char
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 <> c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 <> c2) " 
 -- doNeedOrigin:E: "(c1 <> c2) " 
 -- computeAdrX:superAdj: 0 "(c1 <> c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 <> c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (c1 <> c2) 
 -- $BracketedExp:loadOrigin: (c1 <> c2) 
 -- computeAdrG:superAdj: 0 "c1 <> c2 "
 -- computeAdrG: 1 :rec: "none " E: "c1 <> c2 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: c1 <> c2 
 -- $BinOp:loadOrigin: c1 <> c2 
 -- BinaryExp:loadOrigin:empty: "c1 <> c2 "superAdj: 0 
 -- $BinOp:getAdr: c1 <> c2 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 <> c2 " ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "c1 <> c2 "
 -- BE:loadOrigin:E: c1 <> c2 
 -- $BinOp:getAdr: c1 <> c2 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 <> c2 " ATd: 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "c1 <> c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 <> c2 "E:  "c1 <> c2 "
 -- INV:gen:E.loadArgs "c1 <> c2 "
 -- $BinOp:loadArgs: c1 <> c2 
 -- BinaryExp:loadArgs: "c1 <> c2 " superAdj: 0 
 -- $Invocation:gen: c1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c1 " 
 -- isConstant: "Invocation ""c1 "
 -- notConst: c1 c1: var char 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c1 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: c1 >ATd.off:2:on:2:superAdj:0c1: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c1: var char >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c1":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 " ATd: "c1: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- $ObjectInvocation_Unary:loadArgs: c1 >staticOff:0 c1: var char superAdj:0
 -- $var:loadArgs: c1: var char >E:"c1"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: c1 >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:c1 unique:"False"
 -- OI:invoke: "c1 "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1 "E: "c1 " rec: "c1 " useRtnV: true "
 --  c1: var char " 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: c1: var char E: "c1">newOff:2 useRTNv: "True"
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 -- isCompositeValueObj: false E: "c1 ""c1: var char " true 
 -- E.ATd.isValueObj: false rec: "c1 "
 pushg 2 loop$14
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:C: c1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- $pattern:loadArgs:  \
 -- <>  :  \
 --    %basic 55 \
 --    in V: var char
 -- ptn:loadArgs:E: "<> c2 " 
 -- args: "c2 " 
 -- E: "ObjectGenerator "c2 
 -- E.arg: "var "in V: var char 
 -- NonVirt: "<> c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> c2 " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: c2 >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "c2 " 
 -- OG:before:super.gen: "c2 "
 -- $Invocation:gen: c2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c2 " 
 -- isConstant: "Invocation ""c2 "
 -- notConst: c2 c2: var char 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c2 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 1 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: c2 >ATd.off:3:on:2:superAdj:0c2: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c2: var char >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c2":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2 " ATd: "c2: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- $ObjectInvocation_Unary:loadArgs: c2 >staticOff:0 c2: var char superAdj:0
 -- $var:loadArgs: c2: var char >E:"c2"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: c2 >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:c2 unique:"False"
 -- OI:invoke: "c2 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2 "E: "c2 " rec: "c2 " useRtnV: true "
 --  c2: var char " 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: c2: var char E: "c2">newOff:3 useRTNv: "True"
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 -- isCompositeValueObj: false E: "c2 ""c2: var char " true 
 -- E.ATd.isValueObj: false rec: "c2 "
 pushg 3 loop$14
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:C: c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "<> c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 <> c2 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 <> c2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: c1 <> c2 
 -- BinaryExp:invoke: "c1 "rec: "c1 <> c2 "
 -- M: "<> c2 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: <> c2 >rec:"c1" ATd:"pattern" E:"<> c2" E.ATd:<>   unique:"False"
 -- OI:invoke: "<> c2 "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "char "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "<> c2 "E: "<> c2 " rec: "c1 " useRtnV: true 
 --  <>  : 
 --     %basic 55
 --     in V: var char
 --     out B: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- 
 -- $pattern:invoke:  \
 -- <>  :  \
 --    %basic 55 \
 --    in V: var char
 -- ptn:invoke: "<>   "E: "<> c2 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "c1 "E: "<> c2 "
 -- arg:other 
 ne
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- OI:invoke:C: <> c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- 
 -- $ObjectGenerator:gen:  \
 -- Beq := false \
 --    leave(loop) >OGid:"$26" singular! staticOff=0 descNo=26 superAdj=0
 -- OG:gen: 
 --  Beq := false
 --     leave(loop)
 --  
 pushThis 
 -- before objTmpStack:add:  26   "$26 "
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 26 
 -- Items:GenClass: $26 descNo: 26 isValue: false 
 -- Items:GenClass: $26 descNo: 21 isValue: false 

 CLASS $26 26 1 repeat$24 24
 -- Store itemArgs: 
 --  Beq := false
 --  leave(loop)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=26 vDescInx=26 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := false " 
 -- $Assign:gen: Beq := false 
 -- AssignmentStatement:gen: "Beq := false " 
 -- computeAdrG:superAdj: 0 "Beq "
 -- computeAdrG: 1 :rec: "none " E: "Beq "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Beq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Beq >on:4 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$26 "on: 4 isValueObj: false 
 --  origin: repeat$24 origin:isValueObj: false 
 rpushg $26$26 1
 -- items:goOrigin:encOG: "repeat$24 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30 "on: 2 isValueObj: 
 --  false 
 --  origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: Beq >ATd.off:3:on:4:superAdj:0out Beq: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out Beq: var boolean >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Beq":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq " ATd: "out Beq: var boolean " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdrG:isLast:E:  "Beq "
 -- AssignmentStatement:gen: 
 --  "Beq := false " right.label: "ObjectGenerator ""false " 
 -- $ObjectGenerator:gen: false >OGid:"False" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "false " 
 -- OG:before:super.gen: "false "
 -- $Invocation:gen: false >useRtnV:"True"superAdj: 0 descNo: 27
 -- INV:gen: "false " 
 -- isConstant: "Invocation ""false "
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: false >staticOff:0  \
 -- False:  \
 --    %globals \
 --    out B: var boolean
 -- 
 -- $pattern:loadArgs:  \
 -- False:  \
 --    %globals \
 --    out B: var boolean
 -- ptn:loadArgs:E: "false " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- $ObjectInvocation_Unary:invoke: false >rec:"false" ATd:"pattern" E:"false" E.ATd:False unique:"False"
 -- OI:invoke: "false "
 -- 
 -- OI:invoke:B: "false "E: "false " rec: "false " useRtnV: true 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- 
 -- $pattern:invoke:  \
 -- False:  \
 --    %globals \
 --    out B: var boolean
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: false :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "Beq "dstE: "Beq "dstE.ATd: "out Beq: var boolean " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "false "
 -- isArgOfAssignI2IwithUniValArg "Beq := false "arg: "false "
 --  ObjectGenerator 
 -- arg.super.arg: "false "ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(loop) " 
 -- $ObjectGenerator:gen: leave(loop) >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "leave(loop) " 
 -- OG:before:super.gen: "leave(loop) "
 -- $Invocation:gen: leave(loop) >useRtnV:"False"superAdj: 0 descNo: 19
 -- INV:gen: "leave(loop) " 
 -- isConstant: "Invocation ""leave(loop) "
 -- needorigin: "leave(loop) " 
 -- needOrigin:E: "leave(loop) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(loop) " rec: "leave(loop) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(loop) " 
 -- doNeedOrigin:E: "leave(loop) " 
 -- computeAdrX:superAdj: 0 "leave(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: leave(loop) 
 -- $ObjectInvocation_KeyWord:loadOrigin: leave(loop) >on:7 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: leave(loop) >ATd.off:0 (isPtn):on:7:superAdj:0 \
 -- leave(V: var integer):  \
 --    %basic 103:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- leave(V: var integer):  \
 --    %basic 103 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(loop) " ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- computeAdrX:isLast:E:  "leave(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 --  rec:  "leave(loop) "E:  "leave(loop) "
 -- INV:gen:E.loadArgs "leave(loop) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: leave(loop) >staticOff:0  \
 -- leave(V: var integer):  \
 --    %basic 103 superAdj:0arg:loop
 -- 
 -- $pattern:loadArgs:  \
 -- leave(V: var integer):  \
 --    %basic 103 >E:"leave(loop)":descNo:19
 -- INV:gen:after:E.loadArgs "leave(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: leave(loop) >rec:"leave(loop)" ATd:"pattern" E:"leave(loop)" E.ATd:leave(V: var integer) unique:"False"
 -- OI:invoke: "leave(loop) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:B: "leave(loop) "E: "leave(loop) " rec: "leave(loop) "
 --   useRtnV: false 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- leave(V: var integer):  \
 --    %basic 103 E: "leave(loop)" useRTNv: "False"
 -- ptn:invoke: "leave(V: var integer) "E: "leave(loop) "ptnKind: 0 
 --  useRtnV: false 
 break  3 2 14 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:C: leave(loop) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 27 
 -- Items:GenClass: False descNo: 27 isValue: false 
 -- Items:GenClass: False descNo: 21 isValue: false 

 CLASS False 27 0 BETA 2
 -- Store itemArgs: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  
 allocEventQ
 -- vdtAdd: inx=1 descInx=27 vDescInx=27 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 -- $var:gen: out B: var boolean 
 -- DI:gen: "out B: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "B := 0 " 
 -- $Assign:gen: B := 0 
 -- AssignmentStatement:gen: "B := 0 " 
 -- computeAdrG:superAdj: 0 "B "
 -- computeAdrG: 1 :rec: "none " E: "B "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: B 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: B >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: B >ATd.off:1:on:0:superAdj:0out B: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out B: var boolean >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"B":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out B: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdrG:isLast:E:  "B "
 -- AssignmentStatement:gen: 
 --  "B := 0 " right.label: "ObjectGenerator ""0 " 
 -- $ObjectGenerator:gen: 0 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 " 
 -- OG:before:super.gen: "0 "
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "B "dstE: "B "dstE.ATd: "out B: var boolean " useRtn: false 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "0 "
 -- isArgOfAssignI2IwithUniValArg "B := 0 "arg: "0 "ObjectGenerator 
 -- arg.super.arg: "0 "ConstLiteral 
 -- dstDI: "out B: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg False$27 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "False "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 30 
 -- Items:GenClass: for:to:repeat$30 descNo: 30 isValue: false 
 -- Items:GenClass: for:to:repeat$30 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs: " " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "theIS: " " 
 -- super.sig:none:superAdj: 4 
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs:  \
 -- for(1):to(length):repeat \
 --    c1 := get[inx] \
 --    c2 := Veq.get[inx]
 -- 
 -- $pattern:loadArgs:  \
 -- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
 --    %OSDvisibility skipInternal \
 --    %globals inSub
 -- ptn:loadArgs:E: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- args: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 -- E: "ObjectGenerator "1 
 -- E: "ObjectGenerator "length 
 -- E: "ObjectGenerator "
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop) 
 -- E.arg: "var "first: var integer 
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 4
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- E.arg: "var "last: var integer 
 -- NonVirt: 
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then "ObjectInvocation_KeyWord " ActArg: "length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "length " 
 -- OG:before:super.gen: "length "
 -- $Invocation:gen: length >useRtnV:"True"superAdj: 4 descNo: 15
 -- INV:gen: "length " 
 -- isConstant: "Invocation ""length "
 -- needorigin: "length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: length 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: length >on:2 superAdj:4 isValueObj:"False"
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg loop$14 4
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- 
 -- $ObjectInvocation_Unary:getAdr: length >ATd.off:0 (isPtn):on:2:superAdj:4 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length " ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  rec:  "length "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:4
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length":descNo:15
 -- ptn:loadArgs:E: "length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: length >rec:"length" ATd:"pattern" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "length "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length "E: "length " rec: "length " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length" useRTNv: "True"
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "length ":isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- args:  "repeat:< object ""
 --  c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop) "for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs: " " 
 -- last: var integer 1 
 -- DI:store: "last "
 pushThis 
 storeg integer$5 2
 -- first: var integer 1 
 -- DI:store: "first "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=30 vDescInx=28 vdtTop: 2 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- $Property:gen: %globals inSub 
 -- $var:gen: inx: var integer 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: " " E: "
 --  for(1):to(length):repeat
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 <> c2) :then 
 --        Beq := false
 --        leave(loop)
 --   "
 -- vdtAdd: inx=2 descInx=30 vDescInx=24 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 84 
 -- Items:GenClass: <= descNo: 84 isValue: false 
 -- Items:GenClass: <= descNo: 58 isValue: false 
 -- Items:GenClass: <= descNo: 21 isValue: false 
 -- got:sub:vEq:  52  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 21 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OG:reAlloc: descNo: 0 0 
 --  %ID Object
 --     %basic 64
 --     %public
 --     ==  : 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- dataitem:qalloc: "Veq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 " " 
 -- dataitem:qalloc: "Beq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 " " 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 " " 

 CLASS <= 58 1 Value 4
 -- Store itemArgs: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  
 -- in Veq: var this(Value) 18 
 -- DI:store: "Veq "
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 L4:
 -- Store:Origin: 21 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=58 vDescInx=58 vdtTop: 1 
 mvStack 
 -- $Property:gen: %basic 52 
 -- $var:gen: in Veq: var this(Value) 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: out Beq: var boolean 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 52 " 
 -- $Property:gen: %basic 52 
 L2:
 -- pushReturn:  "<= "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- got:sub:vEq:  52  isValueObj:  false 4 
 -- OG:reAlloc: descNo: 0 5 
 --  loop: obj 
 --        -- "Hello"  <= "World" since H <= W
 --        -- "Qweabc" <= "Qwevwxy" since a <= e
 --        -- "Qweayc" <= "Qwexby"
 -- OG:reAlloc:String: 
 -- currentDcl:this: 
 -- reAllocatedOff: "Veq "2 
 -- dataitem:qalloc: "Beq "isValue: true  isPrimitive: true 
 --   isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- reAllocatedOff: "Beq "3 
 -- dataitem:qalloc: "loop "isValue: false  isPrimitive: false 
 --   isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- OG:Qalloc: 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"qDescno:  85 
 -- reAllocatedOff: "loop "4 

 CLASS <= 84 1 String 10
 -- vdtTableCopy: I:1:58
 -- Store itemArgs: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- Store:Origin: 5 
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: " "theIS: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs:  
 rShiftDown  1
 -- hArgOrg:super: <= 
 -- Store itemArgs: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 -- in Veq: var this(Value) 18 
 pushThis 
 rstoreg  Veq 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=84 vDescInx=58 vdtTop: 1 
 mvStack 
 -- $Property:gen: %basic 52 
 -- $var:gen: in Veq: var this(Value) 
 -- DI:gen: "in Veq: var this(Value) " DI:isConst: false 
 --  isBasicValue: false primNo: 18 
 -- DI:isConst: Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: out Beq: var boolean 
 -- DI:gen: "out Beq: var boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: Beq 
 -- 
 -- $obj:gen:  \
 -- loop: obj  \
 --    -- "Hello"  <= "World" since H <= W \
 --    -- "Qweabc" <= "Qwevwxy" since a <= e
 -- DI:gen: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"DI:isConst: true isBasicValue: false primNo: 0 
 -- DI:isConst: loop 
 -- DI:off: 4 this: 
 --  loop: obj 
 --     -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- -- "Hello"  <= "World" since H <= W \
 --    -- "Qweabc" <= "Qwevwxy" since a <= e \
 --    -- "Qweayc" <= "Qwexby"
 -- OG:gen: 
 --  -- "Hello"  <= "World" since H <= W
 --     -- "Qweabc" <= "Qwevwxy" since a <= e
 --     -- "Qweayc" <= "Qwexby"
 --     -- "Qwe"    <= "Qwerty"
 pushThis 
 -- before objTmpStack:add:  85   "loop "
 invoke loop 85 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "<= "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 85 
 -- Items:GenClass: loop descNo: 85 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 85 1 <= 84
 -- Store itemArgs: 
 --  -- "Hello"  <= "World" since H <= W
 --  -- "Qweabc" <= "Qwevwxy" since a <= e
 --  -- "Qweayc" <= "Qwexby"
 --  -- "Qwe"    <= "Qwerty"
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=85 vDescInx=85 vdtTop: 1 
 mvStack 
 -- $var:gen: L: var integer 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 -- $var:gen: L1: var integer 
 -- DI:gen: "L1: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L1 
 -- $var:gen: L2: var integer 
 -- DI:gen: "L2: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  L1 := length
 --  -- min length of this and V
 --  
 -- 
 -- $Assign:gen:  \
 -- L1 := length \
 -- -- min length of this and V 
 -- AssignmentStatement:gen: 
 --  L1 := length
 --  -- min length of this and V
 --  
 -- computeAdrG:superAdj: 0 "L1 "
 -- computeAdrG: 1 :rec: "none " E: "L1 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L1 >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L1 >ATd.off:3:on:0:superAdj:0L1: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L1: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L1":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrG:isLast:E:  "L1 "
 -- AssignmentStatement:gen: 
 --  
 --  L1 := length
 --  -- min length of this and V
 --  right.label: "ObjectGenerator "
 --  length
 --  -- min length of this and V
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- length \
 -- -- min length of this and V >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  length
 --  -- min length of this and V
 --  
 -- OG:before:super.gen: "length
 --  -- min length of this and V "
 -- 
 -- $Invocation:gen:  \
 -- length \
 -- -- min length of this and V >useRtnV:"True"superAdj: 0 descNo: 15
 -- INV:gen: 
 --  length
 --  -- min length of this and V
 --  
 -- isConstant: "Invocation ""length
 --  -- min length of this and V "
 -- needorigin: 
 --  length
 --  -- min length of this and V
 --  
 -- needOrigin:E: 
 --  length
 --  -- min length of this and V
 --   E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: 
 --  length
 --  -- min length of this and V
 --  rec: 
 --  length
 --  -- min length of this and V
 --  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 -- \
 --   out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length
 --  -- min length of this and V "
 --  originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: 
 --  length
 --  -- min length of this and V
 --  
 -- doNeedOrigin:E: 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:superAdj: 0 
 --  length
 --  -- min length of this and V
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: 
 --  length
 --  -- min length of this and V
 --  
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_Unary:pushThis:  \
 -- length \
 -- -- min length of this and V 
 pushThis 
 -- 
 -- $ObjectInvocation_Unary:loadOrigin:  \
 -- length \
 -- -- min length of this and V >on:2 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$84 1
 -- 
 -- $ObjectInvocation_Unary:getAdr:  \
 -- length \
 -- -- min length of this and V >ATd.off:0 (isPtn):on:2:superAdj:0 \
 -- length: 
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length
 --  -- min length of this and V " ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 -- computeAdrX:isLast:E:  "length
 --  -- min length of this and V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 --  rec:  "length
 --  -- min length of this and V "E:  "
 --  length
 --  -- min length of this and V "
 -- INV:gen:E.loadArgs "length
 --  -- min length of this and V "
 -- 
 -- $ObjectInvocation_Unary:loadArgs:  \
 -- length \
 -- -- min length of this and V >staticOff:0  \
 -- length: 
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length"
 -- ptn:loadArgs:E: 
 --  length
 --  -- min length of this and V
 --  
 -- args: "-- min length of this and V " 
 -- INV:gen:after:E.loadArgs "length
 --  -- min length of this and V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "
 --  length
 --  -- min length of this and V "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:- 
 -- 
 -- $ObjectInvocation_Unary:invoke:  \
 -- length \
 -- -- min length of this and V >rec:"length" \
 -- -- min length of this and V" ATd:"pattern" E:"length
 -- OI:invoke: "length
 --  -- min length of this and V "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:B: "length
 --  -- min length of this and V "E: "
 --  length
 --  -- min length of this and V " rec: "length
 --  -- min length of this and V " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length"
 -- ptn:invoke: "length "E: "length
 --  -- min length of this and V "
 --  ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: 
 --  length
 --  -- min length of this and V
 --  
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- OI:invoke:C: length
 --  -- min length of this and V :unit:  -none-  
 --   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length
 --  -- min length of this and V":rec:length
 --  -- min length of this and V 
 -- rec: "L1 "dstE: "L1 "dstE.ATd: "L1: var integer " useRtn: false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "length
 --  -- min length of this and V "
 -- isArgOfAssignI2IwithUniValArg "
 --  L1 := length
 --  -- min length of this and V "arg: "length
 --  -- min length of this and V "ObjectGenerator 
 -- arg.super.arg: "length
 --  -- min length of this and V "
 --  ObjectInvocation_Unary 
 -- dstDI: "L1: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$85 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "L2 := Veq.length " 
 -- $Assign:gen: L2 := Veq.length 
 -- AssignmentStatement:gen: "L2 := Veq.length " 
 -- computeAdrG:superAdj: 0 "L2 "
 -- computeAdrG: 1 :rec: "none " E: "L2 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L2 >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L2 >ATd.off:4:on:0:superAdj:0L2: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L2: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L2":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdrG:isLast:E:  "L2 "
 -- AssignmentStatement:gen: 
 --  "L2 := Veq.length " right.label: "ObjectGenerator ""Veq.length " 
 -- $ObjectGenerator:gen: Veq.length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "Veq.length " 
 -- OG:before:super.gen: "Veq.length "
 -- $Invocation:gen: Veq.length >useRtnV:"True"superAdj: 0 descNo: 15
 -- INV:gen: "Veq.length " 
 -- isConstant: "Invocation ""Veq.length "
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "Veq " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "Veq.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Veq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Veq >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- $ObjectInvocation_Unary:getAdr: Veq >ATd.off:2:on:1:superAdj:0in Veq: var this(Value):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  matchEq: 
 --        inx: var integer
 --        c1: var char
 --        c2: var char
 --        isEmpty: do 
 --           if (L1 = 0) :then 
 --              Beq := L1 <= L2
 --              leave(matchEq)
 --           if (L2 = 0) :then 
 --              Beq := false
 --              leave(matchEq)
 --        loop: do 
 --           inx := inx + 1
 --           c1 := get[inx]
 --           c2 := Veq.get[inx]
 --           if (c1 = c2) :then 
 --              if (inx < L) :then 
 -- \
 --                  restart(loop)
 --        doit: do 
 --           if (c1 = c2) :then 
 --              -- we have inx = LBeq := L1 <= L2
 --              leave(matchEq)
 --           :else 
 --              Beq := c1 < c2
 --              leave(matchEq)
 --     L: var integer
 --     L1: var integer
 --     L2: var integer
 --     L1 := length
 --     -- min length of this and V
 --     L2 := Veq.length
 --     if (L1 < L2) :then 
 --        L := L1
 --     :else 
 --        L := L2
 - \
 -- -     matchEq 
 -- BOBS:ATd: "in Veq: var this(Value) "
 -- String:vEq:  "Veq "off:  2 ATd: "in Veq: var this(Value) " 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Veq " ATd: "in Veq: var this(Value) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_Unary:getAdr: length >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "length " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "length " 
 --  false true 
 -- $ObjectInvocation_Unary:loadArgs: Veq >staticOff:0 in Veq: var this(Value) superAdj:0
 -- $var:loadArgs: in Veq: var this(Value) >E:"Veq"
 -- 
 -- $pattern:loadArgs:  \
 -- this:  \
 --    %basic 18 \
 --    in this: ref Object >E:"Veq":descNo:31
 -- computeAdrX:before:rec:: "Veq " 
 -- $ObjectInvocation_Unary:invoke: Veq >rec:"Veq" ATd:"var" isValueObj E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "Veq "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "Veq "E: "length " rec: "Veq " useRtnV: true "
 --  in Veq: var this(Value) " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: in Veq: var this(Value) E: "length">newOff:2 useRTNv: "True"
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "length ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$85 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: Veq :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- checkInt2IntWithUnitArg:rec: "Veq "E: "length "
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 --  rec:  "Veq "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length":descNo:15
 -- ptn:loadArgs:E: "length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- $ObjectInvocation_Unary:invoke: length >rec:"Veq" ATd:"pattern" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "length "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "length "E: "length " rec: "Veq " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length" useRTNv: "True"
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Veq " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec: "L2 "dstE: "L2 "dstE.ATd: "L2: var integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "Veq.length "
 -- isArgOfAssignI2IwithUniValArg "L2 := Veq.length "arg: "Veq.length "
 --  ObjectGenerator 
 -- arg.super.arg: "Veq "ObjectInvocation_Unary 
 -- arg.super.arg: "length "ObjectInvocation_Unary 
 -- recx: "Veq "argx: "length "
 -- checkInt2IntWithUnitArg:rec: "Veq "E: "length "
 -- dstDI: "L2: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$85 4
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (L1 < L2) :then  \
 --    L := L1 \
 -- :else 
 -- OG:gen: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- OG:before:super.gen: "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- 
 -- $Invocation:gen:  \
 -- if (L1 < L2) :then  \
 --    L := L1 \
 -- :else 
 -- INV:gen: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- isConstant: "Invocation ""
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- needorigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- needOrigin:E: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  rec: 
 --  if (L1 < L2) :then 
 --     L := L1
 -- \
 --   :else 
 --     L := L2
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "E:  "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- INV:gen:E.loadArgs "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- 
 -- $IfThenElse:loadArgs:  \
 -- if (L1 < L2) :then  \
 --    L := L1 \
 -- :else 
 -- INV:gen:after:E.loadArgs "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (L1 < L2) :then 
 --     L := L1
 --  :else 
 --     L := L2 "
 -- 
 -- $IfThenElse:invoke:  \
 -- if (L1 < L2) :then  \
 --    L := L1 \
 -- :else 
 -- 
 -- $IfThenElse:gen:  \
 -- if (L1 < L2) :then  \
 --    L := L1 \
 -- :else 
 -- $ObjectGenerator:gen: (L1 < L2) >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(L1 < L2) " 
 -- OG:before:super.gen: "(L1 < L2) "
 -- $Invocation:gen: (L1 < L2) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(L1 < L2) " 
 -- isConstant: "Invocation ""(L1 < L2) "
 -- needorigin: "(L1 < L2) " 
 -- needOrigin:E: "(L1 < L2) "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(L1 < L2) " rec: "(L1 < L2) " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(L1 < L2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 < L2) " 
 -- doNeedOrigin:E: "(L1 < L2) " 
 -- computeAdrX:superAdj: 0 "(L1 < L2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 < L2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (L1 < L2) 
 -- $BracketedExp:loadOrigin: (L1 < L2) 
 -- computeAdrG:superAdj: 0 "L1 < L2 "
 -- computeAdrG: 1 :rec: "none " E: "L1 < L2 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L1 < L2 
 -- $BinOp:loadOrigin: L1 < L2 
 -- BinaryExp:loadOrigin:empty: "L1 < L2 "superAdj: 0 
 -- $BinOp:getAdr: L1 < L2 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "L1 < L2 "
 -- BE:loadOrigin:E: L1 < L2 
 -- $BinOp:getAdr: L1 < L2 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L1 < L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L1 < L2 "E:  "L1 < L2 "
 -- INV:gen:E.loadArgs "L1 < L2 "
 -- $BinOp:loadArgs: L1 < L2 
 -- BinaryExp:loadArgs: "L1 < L2 " superAdj: 0 
 -- $Invocation:gen: L1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L1 " 
 -- isConstant: "Invocation ""L1 "
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L1 >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L1 >ATd.off:3:on:0:superAdj:0L1: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L1: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L1":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- $ObjectInvocation_Unary:loadArgs: L1 >staticOff:0 L1: var integer superAdj:0
 -- $var:loadArgs: L1: var integer >E:"L1"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: L1 >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:L1 unique:"False"
 -- OI:invoke: "L1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1 "E: "L1 " rec: "L1 " useRtnV: true "
 --  L1: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: L1: var integer E: "L1">newOff:3 useRTNv: "True"
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 -- isCompositeValueObj: false E: "L1 ""L1: var integer " true 
 -- E.ATd.isValueObj: false rec: "L1 "
 pushg 3 loop$85
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:C: L1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 < L2 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- $pattern:loadArgs:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var integer
 -- ptn:loadArgs:E: "< L2 " 
 -- args: "L2 " 
 -- E: "ObjectGenerator "L2 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "< L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L2 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: L2 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L2 " 
 -- OG:before:super.gen: "L2 "
 -- $Invocation:gen: L2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L2 " 
 -- isConstant: "Invocation ""L2 "
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L2 >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L2 >ATd.off:4:on:0:superAdj:0L2: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L2: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L2":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- $ObjectInvocation_Unary:loadArgs: L2 >staticOff:0 L2: var integer superAdj:0
 -- $var:loadArgs: L2: var integer >E:"L2"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: L2 >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:L2 unique:"False"
 -- OI:invoke: "L2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2 "E: "L2 " rec: "L2 " useRtnV: true "
 --  L2: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: L2: var integer E: "L2">newOff:4 useRTNv: "True"
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 -- isCompositeValueObj: false E: "L2 ""L2: var integer " true 
 -- E.ATd.isValueObj: false rec: "L2 "
 pushg 4 loop$85
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:C: L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L2 ":isBasicVal: true 
 -- case:B: L2 ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 < L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 < L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: L1 < L2 
 -- BinaryExp:invoke: "L1 "rec: "L1 < L2 "
 -- M: "< L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: < L2 >rec:"L1" ATd:"pattern" E:"< L2" E.ATd:<   unique:"False"
 -- OI:invoke: "< L2 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "< L2 "E: "< L2 " rec: "L1 " useRtnV: true 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- 
 -- $pattern:invoke:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var integer
 -- ptn:invoke: "<   "E: "< L2 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L1 "E: "< L2 "
 -- arg:other 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- OI:invoke:C: < L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: L := L1 >OGid:"$87" singular! staticOff=0 descNo=87 superAdj=0
 -- OG:gen: "L := L1 " 
 pushThis 
 -- before objTmpStack:add:  87   "$87 "
 invoke $87 87 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: L := L2 >OGid:"$88" singular! staticOff=0 descNo=88 superAdj=0
 -- OG:gen: "L := L2 " 
 pushThis 
 -- before objTmpStack:add:  88   "$88 "
 invoke $88 88 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: "matchEq " 
 -- $ObjectGenerator:gen: matchEq >OGid:"matchEq" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "matchEq " 
 -- OG:before:super.gen: "matchEq "
 -- $Invocation:gen: matchEq >useRtnV:"False"superAdj: 0 descNo: 89
 -- INV:gen: "matchEq " 
 -- isConstant: "Invocation ""matchEq "
 -- needorigin: "matchEq " 
 -- needOrigin:E: "matchEq "  E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var charEx: "matchEq " rec: "matchEq " E.ATd: 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var charE.ATd.desc: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do E.ATd.IT: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- doNeedOrigin:Ex: "matchEq "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "matchEq " 
 -- doNeedOrigin:E: "matchEq " 
 -- computeAdrX:superAdj: 0 "matchEq " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "matchEq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: matchEq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: matchEq >on:0 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- 
 -- $ObjectInvocation_Unary:getAdr: matchEq >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- matchEq:  \
 --    inx: var integer \
 --    c1: var char
 -- 
 -- $pattern:getAdr:  \
 -- matchEq:  \
 --    inx: var integer \
 --    c1: var char
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- computeAdrX:isLast:E:  "matchEq "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 --  rec:  "matchEq "E:  "matchEq "
 -- INV:gen:E.loadArgs "matchEq "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: matchEq >staticOff:0  \
 -- matchEq:  \
 --    inx: var integer \
 --    c1: var char
 -- 
 -- $pattern:loadArgs:  \
 -- matchEq:  \
 --    inx: var integer \
 --    c1: var char
 -- ptn:loadArgs:E: "matchEq " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "matchEq "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "matchEq "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- $ObjectInvocation_Unary:invoke: matchEq >rec:"matchEq" ATd:"pattern" E:"matchEq" E.ATd:matchEq unique:"False"
 -- OI:invoke: "matchEq "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- OI:invoke:B: "matchEq "E: "matchEq " rec: "matchEq " useRtnV: 
 --  false 
 --  matchEq: 
 --     inx: var integer
 --     c1: var char
 --     c2: var char
 -- OI:invoke:before:ATdx.invoke: pattern matchEq 
 -- 
 -- $pattern:invoke:  \
 -- matchEq:  \
 --    inx: var integer \
 --    c1: var char
 -- ptn:invoke: "matchEq "E: "matchEq "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "matchEq " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 invoke matchEq 89 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- OI:invoke:C: matchEq :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 L2:
 -- pushReturn:  "loop "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 87 
 -- Items:GenClass: $87 descNo: 87 isValue: false 
 -- Items:GenClass: $87 descNo: 21 isValue: false 

 CLASS $87 87 1 loop 85
 -- Store itemArgs: "L := L1 " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=87 vDescInx=87 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L1 " 
 -- $Assign:gen: L := L1 
 -- AssignmentStatement:gen: "L := L1 " 
 -- computeAdrG:superAdj: 0 "L "
 -- computeAdrG: 1 :rec: "none " E: "L "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$87 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $87$87 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:2:on:1:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrG:isLast:E:  "L "
 -- AssignmentStatement:gen: 
 --  "L := L1 " right.label: "ObjectGenerator ""L1 " 
 -- $ObjectGenerator:gen: L1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L1 " 
 -- OG:before:super.gen: "L1 "
 -- $Invocation:gen: L1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L1 " 
 -- isConstant: "Invocation ""L1 "
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L1 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$87 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $87$87 1
 -- $ObjectInvocation_Unary:getAdr: L1 >ATd.off:3:on:1:superAdj:0L1: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L1: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L1":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L1 " ATd: "L1: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- $ObjectInvocation_Unary:loadArgs: L1 >staticOff:0 L1: var integer superAdj:0
 -- $var:loadArgs: L1: var integer >E:"L1"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: L1 >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:L1 unique:"False"
 -- OI:invoke: "L1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1 "E: "L1 " rec: "L1 " useRtnV: true "
 --  L1: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: L1: var integer E: "L1">newOff:3 useRTNv: "True"
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 -- isCompositeValueObj: false E: "L1 ""L1: var integer " true 
 -- E.ATd.isValueObj: false rec: "L1 "
 pushg 3 loop$85
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:C: L1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- rec: "L "dstE: "L "dstE.ATd: "L: var integer " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "L1 "
 -- isArgOfAssignI2IwithUniValArg "L := L1 "arg: "L1 "
 --  ObjectGenerator 
 -- arg.super.arg: "L1 "ObjectInvocation_Unary 
 -- dstDI: "L: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$85 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 88 
 -- Items:GenClass: $88 descNo: 88 isValue: false 
 -- Items:GenClass: $88 descNo: 21 isValue: false 

 CLASS $88 88 1 loop 85
 -- Store itemArgs: "L := L2 " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=88 vDescInx=88 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L2 " 
 -- $Assign:gen: L := L2 
 -- AssignmentStatement:gen: "L := L2 " 
 -- computeAdrG:superAdj: 0 "L "
 -- computeAdrG: 1 :rec: "none " E: "L "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$88 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $88$88 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:2:on:1:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrG:isLast:E:  "L "
 -- AssignmentStatement:gen: 
 --  "L := L2 " right.label: "ObjectGenerator ""L2 " 
 -- $ObjectGenerator:gen: L2 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L2 " 
 -- OG:before:super.gen: "L2 "
 -- $Invocation:gen: L2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L2 " 
 -- isConstant: "Invocation ""L2 "
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L2 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$88 "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $88$88 1
 -- $ObjectInvocation_Unary:getAdr: L2 >ATd.off:4:on:1:superAdj:0L2: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L2: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L2":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L2 " ATd: "L2: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- $ObjectInvocation_Unary:loadArgs: L2 >staticOff:0 L2: var integer superAdj:0
 -- $var:loadArgs: L2: var integer >E:"L2"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: L2 >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:L2 unique:"False"
 -- OI:invoke: "L2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2 "E: "L2 " rec: "L2 " useRtnV: true "
 --  L2: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: L2: var integer E: "L2">newOff:4 useRTNv: "True"
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 -- isCompositeValueObj: false E: "L2 ""L2: var integer " true 
 -- E.ATd.isValueObj: false rec: "L2 "
 pushg 4 loop$85
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:C: L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- rec: "L "dstE: "L "dstE.ATd: "L: var integer " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "L2 "
 -- isArgOfAssignI2IwithUniValArg "L := L2 "arg: "L2 "
 --  ObjectGenerator 
 -- arg.super.arg: "L2 "ObjectInvocation_Unary 
 -- dstDI: "L: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$85 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 89 
 -- Items:GenClass: matchEq descNo: 89 isValue: false 
 -- Items:GenClass: matchEq descNo: 21 isValue: false 

 CLASS matchEq 89 1 loop 85
 -- Store itemArgs: 
 --  inx: var integer
 --  c1: var char
 --  c2: var char
 --  isEmpty: do 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=89 vDescInx=89 vdtTop: 1 
 mvStack 
 -- $var:gen: inx: var integer 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 -- $var:gen: c1: var char 
 -- DI:gen: "c1: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c1 
 -- $var:gen: c2: var char 
 -- DI:gen: "c2: var char " DI:isConst: false isBasicValue: true 
 --  primNo: 3 
 -- DI:gen:primitiveType: c2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  isEmpty: do 
 --     if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 -- 
 -- $do:gen:  \
 -- isEmpty: do  \
 --    if (L1 = 0) :then  \
 --       Beq := L1 <= L2
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (L1 = 0) :then  \
 --       Beq := L1 <= L2 \
 --       leave(matchEq)
 -- OG:gen: 
 --  if (L1 = 0) :then 
 --        Beq := L1 <= L2
 --        leave(matchEq)
 --     if (L2 = 0) :then 
 pushThis 
 -- before objTmpStack:add:  90   "isEmpty "
 invoke isEmpty 90 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: 
 --  loop: do 
 --     inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 -- 
 -- $do:gen:  \
 -- loop: do  \
 --    inx := inx + 1 \
 --    c1 := get[inx]
 -- 
 -- $ObjectGenerator:gen:  \
 -- inx := inx + 1 \
 --    c1 := get[inx] \
 --    c2 := Veq.get[inx]
 -- OG:gen: 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then 
 pushThis 
 -- before objTmpStack:add:  93   "loop "
 invoke loop 93 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: 
 --  doit: do 
 --     if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 -- 
 -- $do:gen:  \
 -- doit: do  \
 --    if (c1 = c2) :then  \
 --       -- we have inx = LBeq := L1 <= L2
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (c1 = c2) :then  \
 --       -- we have inx = LBeq := L1 <= L2 \
 --       leave(matchEq)
 -- OG:gen: 
 --  if (c1 = c2) :then 
 --        -- we have inx = LBeq := L1 <= L2
 --        leave(matchEq)
 --     :else 
 pushThis 
 -- before objTmpStack:add:  96   "doit "
 invoke doit 96 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "matchEq "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 90 
 -- Items:GenClass: isEmpty descNo: 90 isValue: false 
 -- Items:GenClass: isEmpty descNo: 21 isValue: false 

 CLASS isEmpty 90 1 matchEq 89
 -- Store itemArgs: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  if (L2 = 0) :then 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=90 vDescInx=90 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (L1 = 0) :then  \
 --    Beq := L1 <= L2 \
 --    leave(matchEq) >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- OG:before:super.gen: "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- 
 -- $Invocation:gen:  \
 -- if (L1 = 0) :then  \
 --    Beq := L1 <= L2 \
 --    leave(matchEq) >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- isConstant: "Invocation ""
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- needorigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  rec: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 --  E:  "if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (L1 = 0) :then  \
 --    Beq := L1 <= L2 \
 --    leave(matchEq) 
 -- INV:gen:after:E.loadArgs "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L1 = 0) :then 
 --     Beq := L1 <= L2
 --     leave(matchEq) "
 -- 
 -- $IfThen:invoke:  \
 -- if (L1 = 0) :then  \
 --    Beq := L1 <= L2 \
 --    leave(matchEq) 
 -- 
 -- $IfThen:gen:  \
 -- if (L1 = 0) :then  \
 --    Beq := L1 <= L2 \
 --    leave(matchEq) 
 -- $ObjectGenerator:gen: (L1 = 0) >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(L1 = 0) " 
 -- OG:before:super.gen: "(L1 = 0) "
 -- $Invocation:gen: (L1 = 0) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(L1 = 0) " 
 -- isConstant: "Invocation ""(L1 = 0) "
 -- needorigin: "(L1 = 0) " 
 -- needOrigin:E: "(L1 = 0) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(L1 = 0) " rec: "(L1 = 0) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(L1 = 0) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L1 = 0) " 
 -- doNeedOrigin:E: "(L1 = 0) " 
 -- computeAdrX:superAdj: 0 "(L1 = 0) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L1 = 0) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (L1 = 0) 
 -- $BracketedExp:loadOrigin: (L1 = 0) 
 -- computeAdrG:superAdj: 0 "L1 = 0 "
 -- computeAdrG: 1 :rec: "none " E: "L1 = 0 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L1 = 0 
 -- $BinOp:loadOrigin: L1 = 0 
 -- BinaryExp:loadOrigin:empty: "L1 = 0 "superAdj: 0 
 -- $BinOp:getAdr: L1 = 0 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1 = 0 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "L1 = 0 "
 -- BE:loadOrigin:E: L1 = 0 
 -- $BinOp:getAdr: L1 = 0 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1 = 0 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L1 = 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 = 0 "E:  "L1 = 0 "
 -- INV:gen:E.loadArgs "L1 = 0 "
 -- $BinOp:loadArgs: L1 = 0 
 -- BinaryExp:loadArgs: "L1 = 0 " superAdj: 0 
 -- $Invocation:gen: L1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L1 " 
 -- isConstant: "Invocation ""L1 "
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L1 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- $ObjectInvocation_Unary:getAdr: L1 >ATd.off:3:on:2:superAdj:0L1: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L1: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L1":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1 " ATd: "L1: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- $ObjectInvocation_Unary:loadArgs: L1 >staticOff:0 L1: var integer superAdj:0
 -- $var:loadArgs: L1: var integer >E:"L1"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: L1 >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:L1 unique:"False"
 -- OI:invoke: "L1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1 "E: "L1 " rec: "L1 " useRtnV: true "
 --  L1: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: L1: var integer E: "L1">newOff:3 useRTNv: "True"
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 -- isCompositeValueObj: false E: "L1 ""L1: var integer " true 
 -- E.ATd.isValueObj: false rec: "L1 "
 pushg 3 loop$85
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:C: L1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 = 0 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- $pattern:loadArgs:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:loadArgs:E: "= 0 " 
 -- args: "0 " 
 -- E: "ObjectGenerator "0 
 -- E.arg: "var "in Veq: var this(Value) 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- $ObjectGenerator:gen: 0 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 " 
 -- OG:before:super.gen: "0 "
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 = 0 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 = 0 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: L1 = 0 
 -- BinaryExp:invoke: "L1 "rec: "L1 = 0 "
 -- M: "= 0 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: = 0 >rec:"L1" ATd:"pattern" E:"= 0" E.ATd:=   unique:"False"
 -- OI:invoke: "= 0 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "= 0 "E: "= 0 " rec: "L1 " useRtnV: true 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- 
 -- $pattern:invoke:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0 " rec: "L1 ""Invocation "OGx: "integer " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- OI:invoke:C: = 0 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- 
 -- $ObjectGenerator:gen:  \
 -- Beq := L1 <= L2 \
 --    leave(matchEq) >OGid:"$91" singular! staticOff=0 descNo=91 superAdj=0
 -- OG:gen: 
 --  Beq := L1 <= L2
 --     leave(matchEq)
 --  
 pushThis 
 -- before objTmpStack:add:  91   "$91 "
 invoke $91 91 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (L2 = 0) :then  \
 --    Beq := false \
 --    leave(matchEq) >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- OG:before:super.gen: "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- 
 -- $Invocation:gen:  \
 -- if (L2 = 0) :then  \
 --    Beq := false \
 --    leave(matchEq) >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- isConstant: "Invocation ""
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- needorigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- needOrigin:E: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  rec: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "E:  "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (L2 = 0) :then  \
 --    Beq := false \
 --    leave(matchEq) 
 -- INV:gen:after:E.loadArgs "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (L2 = 0) :then 
 --     Beq := false
 --     leave(matchEq) "
 -- 
 -- $IfThen:invoke:  \
 -- if (L2 = 0) :then  \
 --    Beq := false \
 --    leave(matchEq) 
 -- 
 -- $IfThen:gen:  \
 -- if (L2 = 0) :then  \
 --    Beq := false \
 --    leave(matchEq) 
 -- $ObjectGenerator:gen: (L2 = 0) >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(L2 = 0) " 
 -- OG:before:super.gen: "(L2 = 0) "
 -- $Invocation:gen: (L2 = 0) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(L2 = 0) " 
 -- isConstant: "Invocation ""(L2 = 0) "
 -- needorigin: "(L2 = 0) " 
 -- needOrigin:E: "(L2 = 0) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(L2 = 0) " rec: "(L2 = 0) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(L2 = 0) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(L2 = 0) " 
 -- doNeedOrigin:E: "(L2 = 0) " 
 -- computeAdrX:superAdj: 0 "(L2 = 0) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(L2 = 0) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (L2 = 0) 
 -- $BracketedExp:loadOrigin: (L2 = 0) 
 -- computeAdrG:superAdj: 0 "L2 = 0 "
 -- computeAdrG: 1 :rec: "none " E: "L2 = 0 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L2 = 0 
 -- $BinOp:loadOrigin: L2 = 0 
 -- BinaryExp:loadOrigin:empty: "L2 = 0 "superAdj: 0 
 -- $BinOp:getAdr: L2 = 0 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2 = 0 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "L2 = 0 "
 -- BE:loadOrigin:E: L2 = 0 
 -- $BinOp:getAdr: L2 = 0 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2 = 0 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L2 = 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L2 = 0 "E:  "L2 = 0 "
 -- INV:gen:E.loadArgs "L2 = 0 "
 -- $BinOp:loadArgs: L2 = 0 
 -- BinaryExp:loadArgs: "L2 = 0 " superAdj: 0 
 -- $Invocation:gen: L2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L2 " 
 -- isConstant: "Invocation ""L2 "
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L2 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- $ObjectInvocation_Unary:getAdr: L2 >ATd.off:4:on:2:superAdj:0L2: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L2: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L2":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2 " ATd: "L2: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- $ObjectInvocation_Unary:loadArgs: L2 >staticOff:0 L2: var integer superAdj:0
 -- $var:loadArgs: L2: var integer >E:"L2"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: L2 >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:L2 unique:"False"
 -- OI:invoke: "L2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2 "E: "L2 " rec: "L2 " useRtnV: true "
 --  L2: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: L2: var integer E: "L2">newOff:4 useRTNv: "True"
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 -- isCompositeValueObj: false E: "L2 ""L2: var integer " true 
 -- E.ATd.isValueObj: false rec: "L2 "
 pushg 4 loop$85
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:C: L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L2 = 0 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- $pattern:loadArgs:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:loadArgs:E: "= 0 " 
 -- args: "0 " 
 -- E: "ObjectGenerator "0 
 -- E.arg: "var "in Veq: var this(Value) 
 -- NonVirt: "= 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0 " isCompositeValueObj: true 
 -- $ObjectGenerator:gen: 0 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 " 
 -- OG:before:super.gen: "0 "
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:after:E.loadArgs "L2 = 0 "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L2 = 0 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $BinOp:invoke: L2 = 0 
 -- BinaryExp:invoke: "L2 "rec: "L2 = 0 "
 -- M: "= 0 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $ObjectInvocation_Binary:invoke: = 0 >rec:"L2" ATd:"pattern" E:"= 0" E.ATd:=   unique:"False"
 -- OI:invoke: "= 0 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- origin:isValueObj "Value "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "= 0 "E: "= 0 " rec: "L2 " useRtnV: true 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- 
 -- $pattern:invoke:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:invoke: "=   "E: "= 0 "ptnKind: 1 useRtnV: true 
 -- E: "= 0 " rec: "L2 ""Invocation "OGx: "integer " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "L2: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- OI:invoke:C: = 0 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L7
 L6:
 -- 
 -- $ObjectGenerator:gen:  \
 -- Beq := false \
 --    leave(matchEq) >OGid:"$92" singular! staticOff=0 descNo=92 superAdj=0
 -- OG:gen: 
 --  Beq := false
 --     leave(matchEq)
 --  
 pushThis 
 -- before objTmpStack:add:  92   "$92 "
 invoke $92 92 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  "isEmpty "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 91 
 -- Items:GenClass: $91 descNo: 91 isValue: false 
 -- Items:GenClass: $91 descNo: 21 isValue: false 

 CLASS $91 91 1 isEmpty 90
 -- Store itemArgs: 
 --  Beq := L1 <= L2
 --  leave(matchEq)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=91 vDescInx=91 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := L1 <= L2 " 
 -- $Assign:gen: Beq := L1 <= L2 
 -- AssignmentStatement:gen: "Beq := L1 <= L2 " 
 -- computeAdrG:superAdj: 0 "Beq "
 -- computeAdrG: 1 :rec: "none " E: "Beq "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Beq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Beq >on:4 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- $ObjectInvocation_Unary:getAdr: Beq >ATd.off:3:on:4:superAdj:0out Beq: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out Beq: var boolean >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Beq":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq " ATd: "out Beq: var boolean " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdrG:isLast:E:  "Beq "
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2 " right.label: "ObjectGenerator ""L1 <= L2 " 
 -- $ObjectGenerator:gen: L1 <= L2 >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L1 <= L2 " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- $Invocation:gen: L1 <= L2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L1 <= L2 " 
 -- isConstant: "Invocation ""L1 <= L2 "
 -- needorigin: "L1 <= L2 " 
 -- needOrigin:E: "L1 <= L2 "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2 " rec: "L1 <= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2 " 
 -- doNeedOrigin:E: "L1 <= L2 " 
 -- computeAdrX:superAdj: 0 "L1 <= L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L1 <= L2 
 -- $BinOp:loadOrigin: L1 <= L2 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- $BinOp:getAdr: L1 <= L2 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 <= L2 " ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- $BinOp:loadArgs: L1 <= L2 
 -- BinaryExp:loadArgs: "L1 <= L2 " superAdj: 0 
 -- $Invocation:gen: L1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L1 " 
 -- isConstant: "Invocation ""L1 "
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L1 >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- $ObjectInvocation_Unary:getAdr: L1 >ATd.off:3:on:3:superAdj:0L1: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L1: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L1":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 " ATd: "L1: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- $ObjectInvocation_Unary:loadArgs: L1 >staticOff:0 L1: var integer superAdj:0
 -- $var:loadArgs: L1: var integer >E:"L1"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: L1 >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:L1 unique:"False"
 -- OI:invoke: "L1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1 "E: "L1 " rec: "L1 " useRtnV: true "
 --  L1: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: L1: var integer E: "L1">newOff:3 useRTNv: "True"
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 -- isCompositeValueObj: false E: "L1 ""L1: var integer " true 
 -- E.ATd.isValueObj: false rec: "L1 "
 pushg 3 loop$85
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:C: L1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 <= L2 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- $pattern:loadArgs:  \
 -- <=  :<  \
 --    %basic 52 \
 --    in Veq: var this(Value)
 -- ptn:loadArgs:E: "<= L2 " 
 -- args: "L2 " 
 -- E: "ObjectGenerator "L2 
 -- E.arg: "var "in Veq: var this(Value) 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- $ObjectGenerator:gen: L2 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L2 " 
 -- OG:before:super.gen: "L2 "
 -- $Invocation:gen: L2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L2 " 
 -- isConstant: "Invocation ""L2 "
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L2 >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$91 "on: 3 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $91$91 1
 -- items:goOrigin:encOG: "isEmpty "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- $ObjectInvocation_Unary:getAdr: L2 >ATd.off:4:on:3:superAdj:0L2: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L2: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L2":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L2 " ATd: "L2: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- $ObjectInvocation_Unary:loadArgs: L2 >staticOff:0 L2: var integer superAdj:0
 -- $var:loadArgs: L2: var integer >E:"L2"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: L2 >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:L2 unique:"False"
 -- OI:invoke: "L2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2 "E: "L2 " rec: "L2 " useRtnV: true "
 --  L2: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: L2: var integer E: "L2">newOff:4 useRTNv: "True"
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 -- isCompositeValueObj: false E: "L2 ""L2: var integer " true 
 -- E.ATd.isValueObj: false rec: "L2 "
 pushg 4 loop$85
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:C: L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: L1 <= L2 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: <= L2 >rec:"L1" ATd:"pattern" E:"<= L2" E.ATd:<=   unique:"False"
 -- OI:invoke: "<= L2 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "<= L2 "E: "<= L2 " rec: "L1 " useRtnV: true 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- 
 -- $pattern:invoke:  \
 -- <=  :<  \
 --    %basic 52 \
 --    in Veq: var this(Value)
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2 " rec: "L1 ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:C: <= L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "Beq "dstE: "Beq "dstE.ATd: "out Beq: var boolean " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "L1 <= L2 "
 -- isArgOfAssignI2IwithUniValArg "Beq := L1 <= L2 "arg: "L1 <= L2 "
 --  ObjectGenerator 
 -- arg.super.arg: "L1 <= L2 "BinOp 
 -- recx:BinaryExp:recx: "L1 <= L2 "
 -- M: "<= L2 "label: "ObjectInvocation_Binary "M.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- checkInt2IntWithUnitArg:rec: "L1 "E: "<= L2 "
 -- arg:other 
 -- M:arg: "L2 "ObjectGenerator false 
 -- dstDI: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq) " 
 -- $ObjectGenerator:gen: leave(matchEq) >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "leave(matchEq) " 
 -- OG:before:super.gen: "leave(matchEq) "
 -- $Invocation:gen: leave(matchEq) >useRtnV:"False"superAdj: 0 descNo: 19
 -- INV:gen: "leave(matchEq) " 
 -- isConstant: "Invocation ""leave(matchEq) "
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: leave(matchEq) 
 -- $ObjectInvocation_KeyWord:loadOrigin: leave(matchEq) >on:7 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: leave(matchEq) >ATd.off:0 (isPtn):on:7:superAdj:0 \
 -- leave(V: var integer):  \
 --    %basic 103:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- leave(V: var integer):  \
 --    %basic 103 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq) " ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: leave(matchEq) >staticOff:0  \
 -- leave(V: var integer):  \
 --    %basic 103 superAdj:0arg:matchEq
 -- 
 -- $pattern:loadArgs:  \
 -- leave(V: var integer):  \
 --    %basic 103 >E:"leave(matchEq)":descNo:19
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: leave(matchEq) >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:leave(V: var integer) unique:"False"
 -- OI:invoke: "leave(matchEq) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq) "E: "leave(matchEq) " rec: "
 --  leave(matchEq) " useRtnV: false 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- leave(V: var integer):  \
 --    %basic 103 E: "leave(matchEq)" useRTNv: "False"
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 89 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 92 
 -- Items:GenClass: $92 descNo: 92 isValue: false 
 -- Items:GenClass: $92 descNo: 21 isValue: false 

 CLASS $92 92 1 isEmpty 90
 -- Store itemArgs: 
 --  Beq := false
 --  leave(matchEq)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=92 vDescInx=92 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := false " 
 -- $Assign:gen: Beq := false 
 -- AssignmentStatement:gen: "Beq := false " 
 -- computeAdrG:superAdj: 0 "Beq "
 -- computeAdrG: 1 :rec: "none " E: "Beq "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Beq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Beq >on:4 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$92 "on: 4 isValueObj: false 
 --  origin: isEmpty origin:isValueObj: false 
 rpushg $92$92 1
 -- items:goOrigin:encOG: "isEmpty "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$90 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- $ObjectInvocation_Unary:getAdr: Beq >ATd.off:3:on:4:superAdj:0out Beq: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out Beq: var boolean >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Beq":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq " ATd: "out Beq: var boolean " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdrG:isLast:E:  "Beq "
 -- AssignmentStatement:gen: 
 --  "Beq := false " right.label: "ObjectGenerator ""false " 
 -- $ObjectGenerator:gen: false >OGid:"False" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "false " 
 -- OG:before:super.gen: "false "
 -- $Invocation:gen: false >useRtnV:"True"superAdj: 0 descNo: 27
 -- INV:gen: "false " 
 -- isConstant: "Invocation ""false "
 -- needorigin: "false " 
 -- needOrigin:E: "false "  E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  Ex: "false " rec: "false " E.ATd: 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  E.ATd.desc: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 --  E.ATd.IT: 
 --  %globals
 --  out B: var boolean
 --  B := 0
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- after:needOrigin: "false " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "false "E:  "false "
 -- INV:gen:E.loadArgs "false "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: false >staticOff:0  \
 -- False:  \
 --    %globals \
 --    out B: var boolean
 -- 
 -- $pattern:loadArgs:  \
 -- False:  \
 --    %globals \
 --    out B: var boolean
 -- ptn:loadArgs:E: "false " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "false "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false "
 -- $ObjectInvocation_Unary:invoke: false >rec:"false" ATd:"pattern" E:"false" E.ATd:False unique:"False"
 -- OI:invoke: "false "
 -- 
 -- OI:invoke:B: "false "E: "false " rec: "false " useRtnV: true 
 --  False: 
 --     %globals
 --     out B: var boolean
 --     B := 0
 --  
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- 
 -- $pattern:invoke:  \
 -- False:  \
 --    %globals \
 --    out B: var boolean
 -- ptn:invoke: "False "E: "false "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "false " 
 --  adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: false :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "Beq "dstE: "Beq "dstE.ATd: "out Beq: var boolean " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "false "
 -- isArgOfAssignI2IwithUniValArg "Beq := false "arg: "false "
 --  ObjectGenerator 
 -- arg.super.arg: "false "ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq) " 
 -- $ObjectGenerator:gen: leave(matchEq) >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "leave(matchEq) " 
 -- OG:before:super.gen: "leave(matchEq) "
 -- $Invocation:gen: leave(matchEq) >useRtnV:"False"superAdj: 0 descNo: 19
 -- INV:gen: "leave(matchEq) " 
 -- isConstant: "Invocation ""leave(matchEq) "
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: leave(matchEq) 
 -- $ObjectInvocation_KeyWord:loadOrigin: leave(matchEq) >on:7 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: leave(matchEq) >ATd.off:0 (isPtn):on:7:superAdj:0 \
 -- leave(V: var integer):  \
 --    %basic 103:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- leave(V: var integer):  \
 --    %basic 103 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq) " ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: leave(matchEq) >staticOff:0  \
 -- leave(V: var integer):  \
 --    %basic 103 superAdj:0arg:matchEq
 -- 
 -- $pattern:loadArgs:  \
 -- leave(V: var integer):  \
 --    %basic 103 >E:"leave(matchEq)":descNo:19
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: leave(matchEq) >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:leave(V: var integer) unique:"False"
 -- OI:invoke: "leave(matchEq) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq) "E: "leave(matchEq) " rec: "
 --  leave(matchEq) " useRtnV: false 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- leave(V: var integer):  \
 --    %basic 103 E: "leave(matchEq)" useRTNv: "False"
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 89 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 93 
 -- Items:GenClass: loop descNo: 93 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 93 1 matchEq 89
 -- Store itemArgs: 
 --  inx := inx + 1
 --  c1 := get[inx]
 --  c2 := Veq.get[inx]
 --  if (c1 = c2) :then 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=93 vDescInx=93 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inx := inx + 1 " 
 -- $Assign:gen: inx := inx + 1 
 -- AssignmentStatement:gen: "inx := inx + 1 " 
 -- computeAdrG:superAdj: 0 "inx "
 -- computeAdrG: 1 :rec: "none " E: "inx "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:2:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrG:isLast:E:  "inx "
 -- AssignmentStatement:gen: 
 --  "inx := inx + 1 " right.label: "ObjectGenerator ""inx + 1 " 
 -- $ObjectGenerator:gen: inx + 1 >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx + 1 " 
 -- OG:before:super.gen: "inx + 1 "
 -- $Invocation:gen: inx + 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx + 1 " 
 -- isConstant: "Invocation ""inx + 1 "
 -- needorigin: "inx + 1 " 
 -- needOrigin:E: "inx + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "inx + 1 " rec: "inx + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "inx + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inx + 1 " 
 -- doNeedOrigin:E: "inx + 1 " 
 -- computeAdrX:superAdj: 0 "inx + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: inx + 1 
 -- $BinOp:loadOrigin: inx + 1 
 -- BinaryExp:loadOrigin:empty: "inx + 1 "superAdj: 0 
 -- $BinOp:getAdr: inx + 1 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx + 1 " ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inx + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx + 1 "E:  "inx + 1 "
 -- INV:gen:E.loadArgs "inx + 1 "
 -- $BinOp:loadArgs: inx + 1 
 -- BinaryExp:loadArgs: "inx + 1 " superAdj: 0 
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:2:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:2 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 2 matchEq$89
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "inx + 1 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- $pattern:loadArgs:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:loadArgs:E: "+ 1 " 
 -- args: "1 " 
 -- E: "ObjectGenerator "1 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: inx + 1 
 -- BinaryExp:invoke: "inx "rec: "inx + 1 "
 -- M: "+ 1 "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: + 1 >rec:"inx" ATd:"pattern" E:"+ 1" E.ATd:+   unique:"False"
 -- OI:invoke: "+ 1 "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "+ 1 "E: "+ 1 " rec: "inx " useRtnV: true 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- 
 -- $pattern:invoke:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx "E: "+ 1 "
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- OI:invoke:C: + 1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "inx "dstE: "inx "dstE.ATd: "inx: var integer " useRtn: 
 --  false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "inx + 1 "
 -- isArgOfAssignI2IwithUniValArg "inx := inx + 1 "arg: "inx + 1 "
 --  ObjectGenerator 
 -- arg.super.arg: "inx + 1 "BinOp 
 -- recx:BinaryExp:recx: "inx + 1 "
 -- M: "+ 1 "label: "ObjectInvocation_Binary "M.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "inx "E: "+ 1 "
 -- arg:integer 
 -- M:arg: "1 "ObjectGenerator false 
 -- dstDI: "inx: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$89 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "c1 := get[inx] " 
 -- $Assign:gen: c1 := get[inx] 
 -- AssignmentStatement:gen: "c1 := get[inx] " 
 -- computeAdrG:superAdj: 0 "c1 "
 -- computeAdrG: 1 :rec: "none " E: "c1 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c1 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: c1 >ATd.off:3:on:1:superAdj:0c1: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c1: var char >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c1":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 " ATd: "c1: var char " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdrG:isLast:E:  "c1 "
 -- AssignmentStatement:gen: 
 --  "c1 := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- $ObjectGenerator:gen: get[inx] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- $Invocation:gen: get[inx] >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "get[inx] " 
 -- isConstant: "Invocation ""get[inx] "
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: get[inx] 
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: get[inx] >on:4 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 4 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- items:goOrigin:encOG: "matchEq "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- items:goOrigin:encOG: "<= "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg <=$84 1
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[inx] >ATd.off:0 (isPtn):on:4:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx] " ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[inx] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[inx]":descNo:16
 -- ptn:loadArgs:E: "get[inx] " 
 -- args: "get[inx] " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:2:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:2 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 2 matchEq$89
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: get[inx] >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[inx] "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx] "E: "get[inx] " rec: "get[inx] " useRtnV: 
 --  true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[inx]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:C: get[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "c1 "dstE: "c1 "dstE.ATd: "c1: var char " useRtn: false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx] "
 -- isArgOfAssignI2IwithUniValArg "c1 := get[inx] "arg: "get[inx] "
 --  ObjectGenerator 
 -- arg.super.arg: "get[inx] "ObjectInvocation_KeyWord 
 -- dstDI: "c1: var char " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$89 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "c2 := Veq.get[inx] " 
 -- $Assign:gen: c2 := Veq.get[inx] 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx] " 
 -- computeAdrG:superAdj: 0 "c2 "
 -- computeAdrG: 1 :rec: "none " E: "c2 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c2 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: c2 >ATd.off:4:on:1:superAdj:0c2: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c2: var char >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c2":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2 " ATd: "c2: var char " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdrG:isLast:E:  "c2 "
 -- AssignmentStatement:gen: 
 --  "c2 := Veq.get[inx] " right.label: "ObjectGenerator ""
 --  Veq.get[inx] " 
 -- $ObjectGenerator:gen: Veq.get[inx] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "Veq.get[inx] " 
 -- OG:before:super.gen: "Veq.get[inx] "
 -- $Invocation:gen: Veq.get[inx] >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "Veq.get[inx] " 
 -- isConstant: "Invocation ""Veq.get[inx] "
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "Veq " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "Veq.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Veq " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Veq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Veq >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- $ObjectInvocation_Unary:getAdr: Veq >ATd.off:2:on:3:superAdj:0in Veq: var this(Value):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  inx := inx + 1
 --     c1 := get[inx]
 --     c2 := Veq.get[inx]
 --     if (c1 = c2) :then 
 --        if (inx < L) :then 
 --           restart(loop) 
 -- BOBS:ATd: "in Veq: var this(Value) "
 -- String:vEq:  "Veq "off:  2 ATd: "in Veq: var this(Value) " 
 -- E.on: 3 
 -- beforeIsValueObj:E: "Veq " ATd: "in Veq: var this(Value) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[inx] >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  rec.ATd: "in Veq: var this(Value) " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "Veq " rec: "Veq " E: "get[inx] " 
 --  false true 
 -- $ObjectInvocation_Unary:loadArgs: Veq >staticOff:0 in Veq: var this(Value) superAdj:0
 -- $var:loadArgs: in Veq: var this(Value) >E:"Veq"
 -- 
 -- $pattern:loadArgs:  \
 -- this:  \
 --    %basic 18 \
 --    in this: ref Object >E:"Veq":descNo:31
 -- computeAdrX:before:rec:: "Veq " 
 -- $ObjectInvocation_Unary:invoke: Veq >rec:"Veq" ATd:"var" isValueObj E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "Veq "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "Veq "E: "get[inx] " rec: "Veq " useRtnV: true "
 --  in Veq: var this(Value) " 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: in Veq: var this(Value) E: "get[inx]">newOff:2 useRTNv: "True"
 -- DI:invoke: "in Veq: var this(Value) " 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq ",E: "get[inx] ""
 --  ObjectInvocation_KeyWord "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg loop$93 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:C: Veq :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "Veq " 
 -- checkInt2IntWithUnitArg:rec: "Veq "E: "get[inx] "
 -- arg:other 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 --  rec:  "Veq "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[inx] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[inx]":descNo:16
 -- ptn:loadArgs:E: "get[inx] " 
 -- args: "get[inx] " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:2:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:2 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 2 matchEq$89
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- $ObjectInvocation_KeyWord:invoke: get[inx] >rec:"Veq" ATd:"pattern" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[inx] "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "get[inx] "E: "get[inx] " rec: "Veq " useRtnV: true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[inx]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 2 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:C: get[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec: "c2 "dstE: "c2 "dstE.ATd: "c2: var char " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "Veq.get[inx] "
 -- isArgOfAssignI2IwithUniValArg "c2 := Veq.get[inx] "arg: "
 --  Veq.get[inx] "ObjectGenerator 
 -- arg.super.arg: "Veq "ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx] "ObjectInvocation_KeyWord 
 -- recx: "Veq "argx: "get[inx] "
 -- checkInt2IntWithUnitArg:rec: "Veq "E: "get[inx] "
 -- arg:other 
 -- dstDI: "c2: var char " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$89 4
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (c1 = c2) :then  \
 --    if (inx < L) :then  \
 --       restart(loop) >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- 
 -- $Invocation:gen:  \
 -- if (c1 = c2) :then  \
 --    if (inx < L) :then  \
 --       restart(loop) >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- isConstant: "Invocation ""
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  rec: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "E:  "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- INV:gen:E.loadArgs "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (c1 = c2) :then  \
 --    if (inx < L) :then  \
 --       restart(loop) 
 -- INV:gen:after:E.loadArgs "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (c1 = c2) :then 
 --     if (inx < L) :then 
 --        restart(loop) "
 -- 
 -- $IfThen:invoke:  \
 -- if (c1 = c2) :then  \
 --    if (inx < L) :then  \
 --       restart(loop) 
 -- 
 -- $IfThen:gen:  \
 -- if (c1 = c2) :then  \
 --    if (inx < L) :then  \
 --       restart(loop) 
 -- $ObjectGenerator:gen: (c1 = c2) >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(c1 = c2) " 
 -- OG:before:super.gen: "(c1 = c2) "
 -- $Invocation:gen: (c1 = c2) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(c1 = c2) " 
 -- isConstant: "Invocation ""(c1 = c2) "
 -- needorigin: "(c1 = c2) " 
 -- needOrigin:E: "(c1 = c2) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(c1 = c2) " rec: "(c1 = c2) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2) " 
 -- doNeedOrigin:E: "(c1 = c2) " 
 -- computeAdrX:superAdj: 0 "(c1 = c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (c1 = c2) 
 -- $BracketedExp:loadOrigin: (c1 = c2) 
 -- computeAdrG:superAdj: 0 "c1 = c2 "
 -- computeAdrG: 1 :rec: "none " E: "c1 = c2 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: c1 = c2 
 -- $BinOp:loadOrigin: c1 = c2 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- $BinOp:getAdr: c1 = c2 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "c1 = c2 "
 -- BE:loadOrigin:E: c1 = c2 
 -- $BinOp:getAdr: c1 = c2 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- $BinOp:loadArgs: c1 = c2 
 -- BinaryExp:loadArgs: "c1 = c2 " superAdj: 0 
 -- $Invocation:gen: c1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c1 " 
 -- isConstant: "Invocation ""c1 "
 -- notConst: c1 c1: var char 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c1 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: c1 >ATd.off:3:on:1:superAdj:0c1: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c1: var char >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c1":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 " ATd: "c1: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- $ObjectInvocation_Unary:loadArgs: c1 >staticOff:0 c1: var char superAdj:0
 -- $var:loadArgs: c1: var char >E:"c1"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: c1 >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:c1 unique:"False"
 -- OI:invoke: "c1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1 "E: "c1 " rec: "c1 " useRtnV: true "
 --  c1: var char " 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: c1: var char E: "c1">newOff:3 useRTNv: "True"
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 -- isCompositeValueObj: false E: "c1 ""c1: var char " true 
 -- E.ATd.isValueObj: false rec: "c1 "
 pushg 3 matchEq$89
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:C: c1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- $pattern:loadArgs:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:loadArgs:E: "= c2 " 
 -- args: "c2 " 
 -- E: "ObjectGenerator "c2 
 -- E.arg: "var "in Veq: var this(Value) 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- $ObjectGenerator:gen: c2 >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "c2 " 
 -- OG:before:super.gen: "c2 "
 -- $Invocation:gen: c2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c2 " 
 -- isConstant: "Invocation ""c2 "
 -- notConst: c2 c2: var char 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c2 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: c2 >ATd.off:4:on:1:superAdj:0c2: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c2: var char >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c2":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2 " ATd: "c2: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- $ObjectInvocation_Unary:loadArgs: c2 >staticOff:0 c2: var char superAdj:0
 -- $var:loadArgs: c2: var char >E:"c2"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: c2 >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:c2 unique:"False"
 -- OI:invoke: "c2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2 "E: "c2 " rec: "c2 " useRtnV: true "
 --  c2: var char " 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: c2: var char E: "c2">newOff:4 useRTNv: "True"
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 -- isCompositeValueObj: false E: "c2 ""c2: var char " true 
 -- E.ATd.isValueObj: false rec: "c2 "
 pushg 4 matchEq$89
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 5 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:C: c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: c1 = c2 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: = c2 >rec:"c1" ATd:"pattern" E:"= c2" E.ATd:=   unique:"False"
 -- OI:invoke: "= c2 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "Value "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "= c2 "E: "= c2 " rec: "c1 " useRtnV: true 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- 
 -- $pattern:invoke:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2 " rec: "c1 ""Invocation "OGx: "char " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:C: = c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (inx < L) :then  \
 --       restart(loop) >OGid:"$94" singular! staticOff=0 descNo=94 superAdj=0
 -- OG:gen: 
 --  if (inx < L) :then 
 --        restart(loop)
 --  
 pushThis 
 -- before objTmpStack:add:  94   "$94 "
 invoke $94 94 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 5 vTopMax: 5 rTop: -8 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  "loop "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 94 
 -- Items:GenClass: $94 descNo: 94 isValue: false 
 -- Items:GenClass: $94 descNo: 21 isValue: false 

 CLASS $94 94 1 loop 93
 -- Store itemArgs: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=94 vDescInx=94 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (inx < L) :then  \
 --    restart(loop) >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- OG:before:super.gen: "if (inx < L) :then 
 --     restart(loop) "
 -- 
 -- $Invocation:gen:  \
 -- if (inx < L) :then  \
 --    restart(loop) >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- isConstant: "Invocation ""if (inx < L) :then 
 --     restart(loop) "
 -- needorigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- needOrigin:E: 
 --  if (inx < L) :then 
 --     restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  rec: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (inx < L) :then 
 --     restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (inx < L) :then 
 --     restart(loop) "E:  "
 --  if (inx < L) :then 
 --     restart(loop) "
 -- INV:gen:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (inx < L) :then  \
 --    restart(loop) 
 -- INV:gen:after:E.loadArgs "if (inx < L) :then 
 --     restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (inx < L) :then 
 --     restart(loop) "
 -- 
 -- $IfThen:invoke:  \
 -- if (inx < L) :then  \
 --    restart(loop) 
 -- 
 -- $IfThen:gen:  \
 -- if (inx < L) :then  \
 --    restart(loop) 
 -- $ObjectGenerator:gen: (inx < L) >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(inx < L) " 
 -- OG:before:super.gen: "(inx < L) "
 -- $Invocation:gen: (inx < L) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(inx < L) " 
 -- isConstant: "Invocation ""(inx < L) "
 -- needorigin: "(inx < L) " 
 -- needOrigin:E: "(inx < L) "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(inx < L) " rec: "(inx < L) " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(inx < L) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(inx < L) " 
 -- doNeedOrigin:E: "(inx < L) " 
 -- computeAdrX:superAdj: 0 "(inx < L) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(inx < L) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (inx < L) 
 -- $BracketedExp:loadOrigin: (inx < L) 
 -- computeAdrG:superAdj: 0 "inx < L "
 -- computeAdrG: 1 :rec: "none " E: "inx < L "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: inx < L 
 -- $BinOp:loadOrigin: inx < L 
 -- BinaryExp:loadOrigin:empty: "inx < L "superAdj: 0 
 -- $BinOp:getAdr: inx < L 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx < L " ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "inx < L "
 -- BE:loadOrigin:E: inx < L 
 -- $BinOp:getAdr: inx < L 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx < L " ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "inx < L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "inx < L "E:  "inx < L "
 -- INV:gen:E.loadArgs "inx < L "
 -- $BinOp:loadArgs: inx < L 
 -- BinaryExp:loadArgs: "inx < L " superAdj: 0 
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$94 "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $94$94 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:2:on:2:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:2 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 2 matchEq$89
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "inx < L "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- $pattern:loadArgs:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var integer
 -- ptn:loadArgs:E: "< L " 
 -- args: "L " 
 -- E: "ObjectGenerator "L 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "< L " "ObjectInvocation_Binary " ActArg: "L "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: L >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L " 
 -- OG:before:super.gen: "L "
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 0
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$94 "on: 3 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg $94$94 1
 -- items:goOrigin:encOG: "loop "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg loop$93 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:2:on:3:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:0
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:2 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 2 loop$85
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx < L "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx < L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: inx < L 
 -- BinaryExp:invoke: "inx "rec: "inx < L "
 -- M: "< L "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: < L >rec:"inx" ATd:"pattern" E:"< L" E.ATd:<   unique:"False"
 -- OI:invoke: "< L "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "< L "E: "< L " rec: "inx " useRtnV: true 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- 
 -- $pattern:invoke:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var integer
 -- ptn:invoke: "<   "E: "< L "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx "E: "< L "
 -- arg:other 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- OI:invoke:C: < L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: restart(loop) >OGid:"$95" singular! staticOff=0 descNo=95 superAdj=0
 -- OG:gen: "restart(loop) " 
 pushThis 
 -- before objTmpStack:add:  95   "$95 "
 invoke $95 95 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 95 
 -- Items:GenClass: $95 descNo: 95 isValue: false 
 -- Items:GenClass: $95 descNo: 21 isValue: false 

 CLASS $95 95 1 $94 94
 -- Store itemArgs: "restart(loop) " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=95 vDescInx=95 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "restart(loop) " 
 -- $ObjectGenerator:gen: restart(loop) >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "restart(loop) " 
 -- OG:before:super.gen: "restart(loop) "
 -- $Invocation:gen: restart(loop) >useRtnV:"False"superAdj: 0 descNo: 61
 -- INV:gen: "restart(loop) " 
 -- isConstant: "Invocation ""restart(loop) "
 -- needorigin: "restart(loop) " 
 -- needOrigin:E: "restart(loop) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(loop) " rec: "restart(loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(loop) " 
 -- doNeedOrigin:E: "restart(loop) " 
 -- computeAdrX:superAdj: 0 "restart(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: restart(loop) 
 -- $ObjectInvocation_KeyWord:loadOrigin: restart(loop) >on:8 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: restart(loop) >ATd.off:0 (isPtn):on:8:superAdj:0 \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 8 
 -- beforeIsValueObj:E: "restart(loop) " ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdrX:isLast:E:  "restart(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 --  rec:  "restart(loop) "E:  "restart(loop) "
 -- INV:gen:E.loadArgs "restart(loop) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: restart(loop) >staticOff:0  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 superAdj:0arg:loop
 -- 
 -- $pattern:loadArgs:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 >E:"restart(loop)":descNo:61
 -- INV:gen:after:E.loadArgs "restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: restart(loop) >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:restart(V: var integer) unique:"False"
 -- OI:invoke: "restart(loop) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop) "E: "restart(loop) " rec: "
 --  restart(loop) " useRtnV: false 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 E: "restart(loop)" useRTNv: "False"
 -- ptn:invoke: "restart(V: var integer) "E: "restart(loop) "
 --  ptnKind: 0 useRtnV: false 
 break  2 1 93 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:C: restart(loop) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 96 
 -- Items:GenClass: doit descNo: 96 isValue: false 
 -- Items:GenClass: doit descNo: 21 isValue: false 

 CLASS doit 96 1 matchEq 89
 -- Store itemArgs: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=96 vDescInx=96 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (c1 = c2) :then  \
 --    -- we have inx = LBeq := L1 <= L2 \
 --    leave(matchEq)
 -- OG:gen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- OG:before:super.gen: "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- 
 -- $Invocation:gen:  \
 -- if (c1 = c2) :then  \
 --    -- we have inx = LBeq := L1 <= L2 \
 --    leave(matchEq)
 -- INV:gen: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- isConstant: "Invocation ""
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- needorigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- needOrigin:E: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else rec: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else E.ATd: 
 -- \
 --   if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "E:  "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- INV:gen:E.loadArgs "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- 
 -- $IfThenElse:loadArgs:  \
 -- if (c1 = c2) :then  \
 --    -- we have inx = LBeq := L1 <= L2 \
 --    leave(matchEq)
 -- INV:gen:after:E.loadArgs "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "
 --  if (c1 = c2) :then 
 --     -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  :else 
 --     Beq := c1 < c2
 --     leave(matchEq) "
 -- 
 -- $IfThenElse:invoke:  \
 -- if (c1 = c2) :then  \
 --    -- we have inx = LBeq := L1 <= L2 \
 --    leave(matchEq)
 -- 
 -- $IfThenElse:gen:  \
 -- if (c1 = c2) :then  \
 --    -- we have inx = LBeq := L1 <= L2 \
 --    leave(matchEq)
 -- $ObjectGenerator:gen: (c1 = c2) >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(c1 = c2) " 
 -- OG:before:super.gen: "(c1 = c2) "
 -- $Invocation:gen: (c1 = c2) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(c1 = c2) " 
 -- isConstant: "Invocation ""(c1 = c2) "
 -- needorigin: "(c1 = c2) " 
 -- needOrigin:E: "(c1 = c2) "  E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanEx: "(c1 = c2) " rec: "(c1 = c2) " E.ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var booleanE.ATd.desc: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 --  E.ATd.IT: 
 --  %basic 50
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  inner(= )
 -- \
 --   
 -- doNeedOrigin:Ex: "(c1 = c2) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(c1 = c2) " 
 -- doNeedOrigin:E: "(c1 = c2) " 
 -- computeAdrX:superAdj: 0 "(c1 = c2) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(c1 = c2) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (c1 = c2) 
 -- $BracketedExp:loadOrigin: (c1 = c2) 
 -- computeAdrG:superAdj: 0 "c1 = c2 "
 -- computeAdrG: 1 :rec: "none " E: "c1 = c2 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: c1 = c2 
 -- $BinOp:loadOrigin: c1 = c2 
 -- BinaryExp:loadOrigin:empty: "c1 = c2 "superAdj: 0 
 -- $BinOp:getAdr: c1 = c2 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "c1 = c2 "
 -- BE:loadOrigin:E: c1 = c2 
 -- $BinOp:getAdr: c1 = c2 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2 " ATd: 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "c1 = c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 = c2 "E:  "c1 = c2 "
 -- INV:gen:E.loadArgs "c1 = c2 "
 -- $BinOp:loadArgs: c1 = c2 
 -- BinaryExp:loadArgs: "c1 = c2 " superAdj: 0 
 -- $Invocation:gen: c1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c1 " 
 -- isConstant: "Invocation ""c1 "
 -- notConst: c1 c1: var char 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c1 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- $ObjectInvocation_Unary:getAdr: c1 >ATd.off:3:on:1:superAdj:0c1: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c1: var char >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c1":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 " ATd: "c1: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- $ObjectInvocation_Unary:loadArgs: c1 >staticOff:0 c1: var char superAdj:0
 -- $var:loadArgs: c1: var char >E:"c1"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: c1 >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:c1 unique:"False"
 -- OI:invoke: "c1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1 "E: "c1 " rec: "c1 " useRtnV: true "
 --  c1: var char " 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: c1: var char E: "c1">newOff:3 useRTNv: "True"
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 -- isCompositeValueObj: false E: "c1 ""c1: var char " true 
 -- E.ATd.isValueObj: false rec: "c1 "
 pushg 3 matchEq$89
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:C: c1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- $pattern:loadArgs:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:loadArgs:E: "= c2 " 
 -- args: "c2 " 
 -- E: "ObjectGenerator "c2 
 -- E.arg: "var "in Veq: var this(Value) 
 -- NonVirt: "= c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2 " isCompositeValueObj: true 
 -- $ObjectGenerator:gen: c2 >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "c2 " 
 -- OG:before:super.gen: "c2 "
 -- $Invocation:gen: c2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c2 " 
 -- isConstant: "Invocation ""c2 "
 -- notConst: c2 c2: var char 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c2 >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- $ObjectInvocation_Unary:getAdr: c2 >ATd.off:4:on:1:superAdj:0c2: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c2: var char >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c2":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2 " ATd: "c2: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- $ObjectInvocation_Unary:loadArgs: c2 >staticOff:0 c2: var char superAdj:0
 -- $var:loadArgs: c2: var char >E:"c2"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: c2 >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:c2 unique:"False"
 -- OI:invoke: "c2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2 "E: "c2 " rec: "c2 " useRtnV: true "
 --  c2: var char " 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: c2: var char E: "c2">newOff:4 useRTNv: "True"
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 -- isCompositeValueObj: false E: "c2 ""c2: var char " true 
 -- E.ATd.isValueObj: false rec: "c2 "
 pushg 4 matchEq$89
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:C: c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: c1 = c2 
 -- BinaryExp:invoke: "c1 "rec: "c1 = c2 "
 -- M: "= c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: = c2 >rec:"c1" ATd:"pattern" E:"= c2" E.ATd:=   unique:"False"
 -- OI:invoke: "= c2 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "Value "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "= c2 "E: "= c2 " rec: "c1 " useRtnV: true 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- 
 -- $pattern:invoke:  \
 -- =  :<  \
 --    %basic 50 \
 --    in Veq: var this(Value)
 -- ptn:invoke: "=   "E: "= c2 "ptnKind: 1 useRtnV: true 
 -- E: "= c2 " rec: "c1 ""Invocation "OGx: "char " 
 --  =  :< 
 --     %basic 50
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 -- rec.ATd: "c1: var char " 
 -- bobs: 3 OGx: "char " 
 -- 
 eq
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- OI:invoke:C: = c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- 
 -- $ObjectGenerator:gen:  \
 -- -- we have inx = LBeq := L1 <= L2 \
 --    leave(matchEq) >OGid:"$97" singular! staticOff=0 descNo=97 superAdj=0
 -- OG:gen: 
 --  -- we have inx = LBeq := L1 <= L2
 --     leave(matchEq)
 --  
 pushThis 
 -- before objTmpStack:add:  97   "$97 "
 invoke $97 97 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- 
 -- $ObjectGenerator:gen:  \
 -- Beq := c1 < c2 \
 --    leave(matchEq) >OGid:"$98" singular! staticOff=0 descNo=98 superAdj=0
 -- OG:gen: 
 --  Beq := c1 < c2
 --     leave(matchEq)
 --  
 pushThis 
 -- before objTmpStack:add:  98   "$98 "
 invoke $98 98 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  "doit "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 97 
 -- Items:GenClass: $97 descNo: 97 isValue: false 
 -- Items:GenClass: $97 descNo: 21 isValue: false 

 CLASS $97 97 1 doit 96
 -- Store itemArgs: 
 --  -- we have inx = LBeq := L1 <= L2
 --  leave(matchEq)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=97 vDescInx=97 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := L1 <= L2 " 
 -- $Assign:gen: Beq := L1 <= L2 
 -- AssignmentStatement:gen: "Beq := L1 <= L2 " 
 -- computeAdrG:superAdj: 0 "Beq "
 -- computeAdrG: 1 :rec: "none " E: "Beq "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Beq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Beq >on:4 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$97 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $97$97 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- $ObjectInvocation_Unary:getAdr: Beq >ATd.off:3:on:4:superAdj:0out Beq: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out Beq: var boolean >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Beq":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq " ATd: "out Beq: var boolean " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdrG:isLast:E:  "Beq "
 -- AssignmentStatement:gen: 
 --  "Beq := L1 <= L2 " right.label: "ObjectGenerator ""L1 <= L2 " 
 -- $ObjectGenerator:gen: L1 <= L2 >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L1 <= L2 " 
 -- OG:before:super.gen: "L1 <= L2 "
 -- $Invocation:gen: L1 <= L2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L1 <= L2 " 
 -- isConstant: "Invocation ""L1 <= L2 "
 -- needorigin: "L1 <= L2 " 
 -- needOrigin:E: "L1 <= L2 "  E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  Ex: "L1 <= L2 " rec: "L1 <= L2 " E.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  E.ATd.desc: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 --  E.ATd.IT: 
 --  %basic 52
 --  in Veq: var this(Value)
 --  out Beq: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "L1 <= L2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L1 <= L2 " 
 -- doNeedOrigin:E: "L1 <= L2 " 
 -- computeAdrX:superAdj: 0 "L1 <= L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 <= L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L1 <= L2 
 -- $BinOp:loadOrigin: L1 <= L2 
 -- BinaryExp:loadOrigin:empty: "L1 <= L2 "superAdj: 0 
 -- $BinOp:getAdr: L1 <= L2 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 <= L2 " ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L1 <= L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L1 <= L2 "E:  "L1 <= L2 "
 -- INV:gen:E.loadArgs "L1 <= L2 "
 -- $BinOp:loadArgs: L1 <= L2 
 -- BinaryExp:loadArgs: "L1 <= L2 " superAdj: 0 
 -- $Invocation:gen: L1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L1 " 
 -- isConstant: "Invocation ""L1 "
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1 " 
 -- needOrigin:E: "L1 "  E.ATd: "L1: var integer " Ex: "L1 " rec: "
 --  L1 " E.ATd: "L1: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L1 " 
 -- doNeedOrigin:E: "L1 " 
 -- computeAdrX:superAdj: 0 "L1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L1 >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$97 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $97$97 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- $ObjectInvocation_Unary:getAdr: L1 >ATd.off:3:on:3:superAdj:0L1: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L1: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L1":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 " ATd: "L1: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdrX:isLast:E:  "L1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 --  rec:  "L1 "E:  "L1 "
 -- INV:gen:E.loadArgs "L1 "
 -- $ObjectInvocation_Unary:loadArgs: L1 >staticOff:0 L1: var integer superAdj:0
 -- $var:loadArgs: L1: var integer >E:"L1"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: L1 >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:L1 unique:"False"
 -- OI:invoke: "L1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1 "E: "L1 " rec: "L1 " useRtnV: true "
 --  L1: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: L1: var integer E: "L1">newOff:3 useRTNv: "True"
 -- DI:invoke: "L1: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 isNotRemote: true 
 -- isCompositeValueObj: false E: "L1 ""L1: var integer " true 
 -- E.ATd.isValueObj: false rec: "L1 "
 pushg 3 loop$85
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:C: L1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 <= L2 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- $pattern:loadArgs:  \
 -- <=  :<  \
 --    %basic 52 \
 --    in Veq: var this(Value)
 -- ptn:loadArgs:E: "<= L2 " 
 -- args: "L2 " 
 -- E: "ObjectGenerator "L2 
 -- E.arg: "var "in Veq: var this(Value) 
 -- NonVirt: "<= L2 " "ObjectInvocation_Binary " ActArg: "L2 "
 --  isValue: false formalArg: "in Veq: var this(Value) " 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2 " isCompositeValueObj: true 
 -- $ObjectGenerator:gen: L2 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L2 " 
 -- OG:before:super.gen: "L2 "
 -- $Invocation:gen: L2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L2 " 
 -- isConstant: "Invocation ""L2 "
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2 " 
 -- needOrigin:E: "L2 "  E.ATd: "L2: var integer " Ex: "L2 " rec: "
 --  L2 " E.ATd: "L2: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L2 " 
 -- doNeedOrigin:E: "L2 " 
 -- computeAdrX:superAdj: 0 "L2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L2 >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$97 "on: 3 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $97$97 1
 -- items:goOrigin:encOG: "doit "on: 2 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 1 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- $ObjectInvocation_Unary:getAdr: L2 >ATd.off:4:on:3:superAdj:0L2: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L2: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L2":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L2 " ATd: "L2: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdrX:isLast:E:  "L2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 --  rec:  "L2 "E:  "L2 "
 -- INV:gen:E.loadArgs "L2 "
 -- $ObjectInvocation_Unary:loadArgs: L2 >staticOff:0 L2: var integer superAdj:0
 -- $var:loadArgs: L2: var integer >E:"L2"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: L2 >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:L2 unique:"False"
 -- OI:invoke: "L2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2 "E: "L2 " rec: "L2 " useRtnV: true "
 --  L2: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: L2: var integer E: "L2">newOff:4 useRTNv: "True"
 -- DI:invoke: "L2: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 isNotRemote: true 
 -- isCompositeValueObj: false E: "L2 ""L2: var integer " true 
 -- E.ATd.isValueObj: false rec: "L2 "
 pushg 4 loop$85
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:C: L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: L1 <= L2 
 -- BinaryExp:invoke: "L1 "rec: "L1 <= L2 "
 -- M: "<= L2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: <= L2 >rec:"L1" ATd:"pattern" E:"<= L2" E.ATd:<=   unique:"False"
 -- OI:invoke: "<= L2 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "<= L2 "E: "<= L2 " rec: "L1 " useRtnV: true 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- 
 -- $pattern:invoke:  \
 -- <=  :<  \
 --    %basic 52 \
 --    in Veq: var this(Value)
 -- ptn:invoke: "<=   "E: "<= L2 "ptnKind: 1 useRtnV: true 
 -- E: "<= L2 " rec: "L1 ""Invocation "OGx: "integer " 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- rec.ATd: "L1: var integer " 
 -- bobs: 1 OGx: "integer " 
 -- 
 le
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- OI:invoke:C: <= L2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "Beq "dstE: "Beq "dstE.ATd: "out Beq: var boolean " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "L1 <= L2 "
 -- isArgOfAssignI2IwithUniValArg "Beq := L1 <= L2 "arg: "L1 <= L2 "
 --  ObjectGenerator 
 -- arg.super.arg: "L1 <= L2 "BinOp 
 -- recx:BinaryExp:recx: "L1 <= L2 "
 -- M: "<= L2 "label: "ObjectInvocation_Binary "M.ATd: 
 --  <=  :< 
 --     %basic 52
 --     in Veq: var this(Value)
 --     out Beq: var boolean
 --  
 -- checkInt2IntWithUnitArg:rec: "L1 "E: "<= L2 "
 -- arg:other 
 -- M:arg: "L2 "ObjectGenerator false 
 -- dstDI: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq) " 
 -- $ObjectGenerator:gen: leave(matchEq) >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "leave(matchEq) " 
 -- OG:before:super.gen: "leave(matchEq) "
 -- $Invocation:gen: leave(matchEq) >useRtnV:"False"superAdj: 0 descNo: 19
 -- INV:gen: "leave(matchEq) " 
 -- isConstant: "Invocation ""leave(matchEq) "
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: leave(matchEq) 
 -- $ObjectInvocation_KeyWord:loadOrigin: leave(matchEq) >on:7 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: leave(matchEq) >ATd.off:0 (isPtn):on:7:superAdj:0 \
 -- leave(V: var integer):  \
 --    %basic 103:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- leave(V: var integer):  \
 --    %basic 103 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq) " ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: leave(matchEq) >staticOff:0  \
 -- leave(V: var integer):  \
 --    %basic 103 superAdj:0arg:matchEq
 -- 
 -- $pattern:loadArgs:  \
 -- leave(V: var integer):  \
 --    %basic 103 >E:"leave(matchEq)":descNo:19
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: leave(matchEq) >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:leave(V: var integer) unique:"False"
 -- OI:invoke: "leave(matchEq) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq) "E: "leave(matchEq) " rec: "
 --  leave(matchEq) " useRtnV: false 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- leave(V: var integer):  \
 --    %basic 103 E: "leave(matchEq)" useRTNv: "False"
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 89 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 98 
 -- Items:GenClass: $98 descNo: 98 isValue: false 
 -- Items:GenClass: $98 descNo: 21 isValue: false 

 CLASS $98 98 1 doit 96
 -- Store itemArgs: 
 --  Beq := c1 < c2
 --  leave(matchEq)
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=98 vDescInx=98 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := c1 < c2 " 
 -- $Assign:gen: Beq := c1 < c2 
 -- AssignmentStatement:gen: "Beq := c1 < c2 " 
 -- computeAdrG:superAdj: 0 "Beq "
 -- computeAdrG: 1 :rec: "none " E: "Beq "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Beq 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Beq >on:4 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$98 "on: 4 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $98$98 1
 -- items:goOrigin:encOG: "doit "on: 3 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- items:goOrigin:encOG: "matchEq "on: 2 isValueObj: false 
 --  origin: loop origin:isValueObj: false 
 rpushg matchEq$89 1
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: <= origin:isValueObj: false 
 rpushg loop$85 1
 -- $ObjectInvocation_Unary:getAdr: Beq >ATd.off:3:on:4:superAdj:0out Beq: var boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: out Beq: var boolean >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Beq":rec:-
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq " ATd: "out Beq: var boolean " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdrG:isLast:E:  "Beq "
 -- AssignmentStatement:gen: 
 --  "Beq := c1 < c2 " right.label: "ObjectGenerator ""c1 < c2 " 
 -- $ObjectGenerator:gen: c1 < c2 >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "c1 < c2 " 
 -- OG:before:super.gen: "c1 < c2 "
 -- $Invocation:gen: c1 < c2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c1 < c2 " 
 -- isConstant: "Invocation ""c1 < c2 "
 -- needorigin: "c1 < c2 " 
 -- needOrigin:E: "c1 < c2 "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  Ex: "c1 < c2 " rec: "c1 < c2 " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var char
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "c1 < c2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "c1 < c2 " 
 -- doNeedOrigin:E: "c1 < c2 " 
 -- computeAdrX:superAdj: 0 "c1 < c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 < c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: c1 < c2 
 -- $BinOp:loadOrigin: c1 < c2 
 -- BinaryExp:loadOrigin:empty: "c1 < c2 "superAdj: 0 
 -- $BinOp:getAdr: c1 < c2 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 < c2 " ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "c1 < c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "c1 < c2 "E:  "c1 < c2 "
 -- INV:gen:E.loadArgs "c1 < c2 "
 -- $BinOp:loadArgs: c1 < c2 
 -- BinaryExp:loadArgs: "c1 < c2 " superAdj: 0 
 -- $Invocation:gen: c1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c1 " 
 -- isConstant: "Invocation ""c1 "
 -- notConst: c1 c1: var char 
 -- needorigin: "c1 " 
 -- needOrigin:E: "c1 "  E.ATd: "c1: var char " Ex: "c1 " rec: "c1 " 
 --  E.ATd: "c1: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c1 " 
 -- doNeedOrigin:E: "c1 " 
 -- computeAdrX:superAdj: 0 "c1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c1 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c1 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$98 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $98$98 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- $ObjectInvocation_Unary:getAdr: c1 >ATd.off:3:on:2:superAdj:0c1: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c1: var char >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c1":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 " ATd: "c1: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdrX:isLast:E:  "c1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 --  rec:  "c1 "E:  "c1 "
 -- INV:gen:E.loadArgs "c1 "
 -- $ObjectInvocation_Unary:loadArgs: c1 >staticOff:0 c1: var char superAdj:0
 -- $var:loadArgs: c1: var char >E:"c1"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c1 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: c1 >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:c1 unique:"False"
 -- OI:invoke: "c1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1 "E: "c1 " rec: "c1 " useRtnV: true "
 --  c1: var char " 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: c1: var char E: "c1">newOff:3 useRTNv: "True"
 -- DI:invoke: "c1: var char " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 isNotRemote: true 
 -- isCompositeValueObj: false E: "c1 ""c1: var char " true 
 -- E.ATd.isValueObj: false rec: "c1 "
 pushg 3 matchEq$89
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:C: c1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- $pattern:loadArgs:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var char
 -- ptn:loadArgs:E: "< c2 " 
 -- args: "c2 " 
 -- E: "ObjectGenerator "c2 
 -- E.arg: "var "in V: var char 
 -- NonVirt: "< c2 " "ObjectInvocation_Binary " ActArg: "c2 "
 --  isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< c2 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: c2 >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "c2 " 
 -- OG:before:super.gen: "c2 "
 -- $Invocation:gen: c2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "c2 " 
 -- isConstant: "Invocation ""c2 "
 -- notConst: c2 c2: var char 
 -- needorigin: "c2 " 
 -- needOrigin:E: "c2 "  E.ATd: "c2: var char " Ex: "c2 " rec: "c2 " 
 --  E.ATd: "c2: var char " E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "c2 " 
 -- doNeedOrigin:E: "c2 " 
 -- computeAdrX:superAdj: 0 "c2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "c2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: c2 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: c2 >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$98 "on: 2 isValueObj: false 
 --  origin: doit origin:isValueObj: false 
 rpushg $98$98 1
 -- items:goOrigin:encOG: "doit "on: 1 isValueObj: false 
 --  origin: matchEq origin:isValueObj: false 
 rpushg doit$96 1
 -- $ObjectInvocation_Unary:getAdr: c2 >ATd.off:4:on:2:superAdj:0c2: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: c2: var char >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"c2":rec:-
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2 " ATd: "c2: var char " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdrX:isLast:E:  "c2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 --  rec:  "c2 "E:  "c2 "
 -- INV:gen:E.loadArgs "c2 "
 -- $ObjectInvocation_Unary:loadArgs: c2 >staticOff:0 c2: var char superAdj:0
 -- $var:loadArgs: c2: var char >E:"c2"
 -- 
 -- $pattern:loadArgs:  \
 -- char: value \
 --    %id "char" \
 --    %globals
 -- ptn:loadArgs:E: "c2 " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "c2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: c2 >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:c2 unique:"False"
 -- OI:invoke: "c2 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2 "E: "c2 " rec: "c2 " useRtnV: true "
 --  c2: var char " 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: c2: var char E: "c2">newOff:4 useRTNv: "True"
 -- DI:invoke: "c2: var char " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 isNotRemote: true 
 -- isCompositeValueObj: false E: "c2 ""c2: var char " true 
 -- E.ATd.isValueObj: false rec: "c2 "
 pushg 4 matchEq$89
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:C: c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "c2 ":isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "< c2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 < c2 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 < c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: c1 < c2 
 -- BinaryExp:invoke: "c1 "rec: "c1 < c2 "
 -- M: "< c2 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: < c2 >rec:"c1" ATd:"pattern" E:"< c2" E.ATd:<   unique:"False"
 -- OI:invoke: "< c2 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "char "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "< c2 "E: "< c2 " rec: "c1 " useRtnV: true 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- 
 -- $pattern:invoke:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var char
 -- ptn:invoke: "<   "E: "< c2 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "c1 "E: "< c2 "
 -- arg:other 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- OI:invoke:C: < c2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "Beq "dstE: "Beq "dstE.ATd: "out Beq: var boolean " useRtn: 
 --  false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "c1 < c2 "
 -- isArgOfAssignI2IwithUniValArg "Beq := c1 < c2 "arg: "c1 < c2 "
 --  ObjectGenerator 
 -- arg.super.arg: "c1 < c2 "BinOp 
 -- recx:BinaryExp:recx: "c1 < c2 "
 -- M: "< c2 "label: "ObjectInvocation_Binary "M.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var char
 --     out B: var boolean
 --  
 -- checkInt2IntWithUnitArg:rec: "c1 "E: "< c2 "
 -- arg:other 
 -- M:arg: "c2 "ObjectGenerator false 
 -- dstDI: "out Beq: var boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$84 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq) " 
 -- $ObjectGenerator:gen: leave(matchEq) >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "leave(matchEq) " 
 -- OG:before:super.gen: "leave(matchEq) "
 -- $Invocation:gen: leave(matchEq) >useRtnV:"False"superAdj: 0 descNo: 19
 -- INV:gen: "leave(matchEq) " 
 -- isConstant: "Invocation ""leave(matchEq) "
 -- needorigin: "leave(matchEq) " 
 -- needOrigin:E: "leave(matchEq) "  E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  Ex: "leave(matchEq) " rec: "leave(matchEq) " E.ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  E.ATd.desc: "%basic 103 " E.ATd.IT: "%basic 103 " 
 -- doNeedOrigin:Ex: "leave(matchEq) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "leave(matchEq) " 
 -- doNeedOrigin:E: "leave(matchEq) " 
 -- computeAdrX:superAdj: 0 "leave(matchEq) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "leave(matchEq) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: leave(matchEq) 
 -- $ObjectInvocation_KeyWord:loadOrigin: leave(matchEq) >on:7 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: leave(matchEq) >ATd.off:0 (isPtn):on:7:superAdj:0 \
 -- leave(V: var integer):  \
 --    %basic 103:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- leave(V: var integer):  \
 --    %basic 103 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq) " ATd: 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdrX:isLast:E:  "leave(matchEq) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 --  rec:  "leave(matchEq) "E:  "leave(matchEq) "
 -- INV:gen:E.loadArgs "leave(matchEq) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: leave(matchEq) >staticOff:0  \
 -- leave(V: var integer):  \
 --    %basic 103 superAdj:0arg:matchEq
 -- 
 -- $pattern:loadArgs:  \
 -- leave(V: var integer):  \
 --    %basic 103 >E:"leave(matchEq)":descNo:19
 -- INV:gen:after:E.loadArgs "leave(matchEq) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  leave(matchEq) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: leave(matchEq) >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:leave(V: var integer) unique:"False"
 -- OI:invoke: "leave(matchEq) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq) "E: "leave(matchEq) " rec: "
 --  leave(matchEq) " useRtnV: false 
 --  leave(V: var integer): 
 --     %basic 103
 --  
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- leave(V: var integer):  \
 --    %basic 103 E: "leave(matchEq)" useRTNv: "False"
 -- ptn:invoke: "leave(V: var integer) "E: "leave(matchEq) "ptnKind: 0 
 --  useRtnV: false 
 break  2 2 89 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 100 
 -- Items:GenClass: puttext descNo: 100 isValue: false 
 -- Items:GenClass: puttext descNo: 21 isValue: false 

 CLASS puttext 100 1 ConsoleIF 8
 -- Store itemArgs: "inner(puttext) " 
 -- T: var LIB.StringLib.String 5 
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=100 vDescInx=100 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(puttext) " 
 -- $ObjectGenerator:gen: inner(puttext) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(puttext) " 
 -- OG:before:super.gen: "inner(puttext) "
 -- $Invocation:gen: inner(puttext) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(puttext) " 
 -- isConstant: "Invocation ""inner(puttext) "
 -- needorigin: "inner(puttext) " 
 -- needOrigin:E: "inner(puttext) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(puttext) " rec: "inner(puttext) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(puttext) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(puttext) " 
 -- doNeedOrigin:E: "inner(puttext) " 
 -- computeAdrX:superAdj: 0 "inner(puttext) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(puttext) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(puttext) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(puttext) >on:2 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(puttext) >ATd.off:0 (isPtn):on:2:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(puttext) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- computeAdrX:isLast:E:  "inner(puttext) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 --  rec:  "inner(puttext) "E:  "inner(puttext) "
 -- INV:gen:E.loadArgs "inner(puttext) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(puttext) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:puttext
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(puttext)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(puttext) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(puttext) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(puttext) >rec:"inner(puttext)" ATd:"pattern" E:"inner(puttext)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(puttext) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:B: "inner(puttext) "E: "inner(puttext) " rec: "
 --  inner(puttext) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(puttext)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(puttext) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:C: inner(puttext) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 L2:
 -- pushReturn:  "puttext "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=100 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 101 
 -- Items:GenClass: putint descNo: 101 isValue: false 
 -- Items:GenClass: putint descNo: 21 isValue: false 

 CLASS putint 101 1 ConsoleIF 8
 -- Store itemArgs: "inner(putint) " 
 -- V: var Integer 1 
 -- DI:store: "V "
 pushThis 
 storeg integer$5 2
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=101 vDescInx=101 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(putint) " 
 -- $ObjectGenerator:gen: inner(putint) >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inner(putint) " 
 -- OG:before:super.gen: "inner(putint) "
 -- $Invocation:gen: inner(putint) >useRtnV:"False"superAdj: 0 descNo: 12
 -- INV:gen: "inner(putint) " 
 -- isConstant: "Invocation ""inner(putint) "
 -- needorigin: "inner(putint) " 
 -- needOrigin:E: "inner(putint) "  E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  Ex: "inner(putint) " rec: "inner(putint) " E.ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  E.ATd.desc: 
 --  %basic 101
 --  in inner: ref Object
 --  E.ATd.IT: 
 --  %basic 101
 --  in inner: ref Object
 --  
 -- doNeedOrigin:Ex: "inner(putint) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "inner(putint) " 
 -- doNeedOrigin:E: "inner(putint) " 
 -- computeAdrX:superAdj: 0 "inner(putint) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inner(putint) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: inner(putint) 
 -- $ObjectInvocation_KeyWord:loadOrigin: inner(putint) >on:2 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: inner(putint) >ATd.off:0 (isPtn):on:2:superAdj:0 \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(putint) " ATd: 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- computeAdrX:isLast:E:  "inner(putint) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 --  rec:  "inner(putint) "E:  "inner(putint) "
 -- INV:gen:E.loadArgs "inner(putint) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: inner(putint) >staticOff:0  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object superAdj:0arg:putint
 -- 
 -- $pattern:loadArgs:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object >E:"inner(putint)":descNo:12
 -- INV:gen:after:E.loadArgs "inner(putint) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  inner(putint) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: inner(putint) >rec:"inner(putint)" ATd:"pattern" E:"inner(putint)" E.ATd:inner unique:"False"
 -- OI:invoke: "inner(putint) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:B: "inner(putint) "E: "inner(putint) " rec: "
 --  inner(putint) " useRtnV: false 
 --  inner: 
 --     %basic 101
 --     in inner: ref Object
 --  
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- 
 -- $pattern:invoke:  \
 -- inner:  \
 --    %basic 101 \
 --    in inner: ref Object E: "inner(putint)" useRTNv: "False"
 -- ptn:invoke: "inner "E: "inner(putint) "ptnKind: 0 useRtnV: 
 --  false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:C: inner(putint) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 L2:
 -- pushReturn:  "putint "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=101 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 102 
 -- Items:GenClass: workspace descNo: 102 isValue: false 
 -- Items:GenClass: workspace descNo: 21 isValue: false 

 CLASS workspace 102 1 BETAworld 1
 -- Store itemArgs: 
 --  %id "workspace"
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
 --  %domain_boundary
 --  --AbstractEx
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=102 vDescInx=102 vdtTop: 1 
 mvStack 
 -- $Property:gen: %id "workspace" 
 -- $Property:gen: %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib 
 -- Module:genMI:  "tinyB "
 -- $Property:gen: %domain_boundary 
 -- 
 -- $ModuleItem:gen:  \
 -- --AbstractEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --AccessEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ApplyPred \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ArduinoEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ArmBasicSys \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ArmLed \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ArmMultiCore \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --CAStest \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --CAStestCore \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --CoroutineEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --CppEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --DumpObjEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Errors \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --FoolishUnitEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ForkGC \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --FuncVirtExVclass \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --FunctionalVirtEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Jurgen \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --LLVMex \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ListLiteralEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --LockTestCore \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MVRsystem \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MapEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --MiniVal \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --NewInner \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --NewSyntax \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --NoneEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ObjectAndValues \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ReadersSingleWriter \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --RemoteSuperVC \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Restrictions \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --SlideEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Sub1 \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --TST \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --TstBreak \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --UnitIssues \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --UnitKindEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --UnitTest \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ValueArray \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ValueConv \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ValueEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --ValueItemEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --VirtError \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --VirtualEx \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --Visibility \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --demo \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --embodyex \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --hello \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --qbetaCmp \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --test \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tiny \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyA \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyAA \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyAB \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyAC \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyB \
 --  
 -- ModuleItem:gen tinyB 
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyC \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyD \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyE \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyF \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyG \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyH \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyI \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyJ \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyP \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyQ \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyR \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyS \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyV \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyW \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyX \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyY \
 --  
 -- 
 -- $ModuleItem:gen:  \
 -- --tinyZ \
 --  
 -- 
 -- $obj:gen:  \
 -- tinyB: obj  \
 --    %visible LIB.Dimensions \
 --    F: var Float
 -- 
 -- $ObjectGenerator:gen:  \
 -- %visible LIB.Dimensions \
 --    F: var Float \
 --    I: var Integer
 -- OG:gen: 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeter
 pushThis 
 -- before objTmpStack:add:  103   "tinyB "
 invoke tinyB 103 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "workspace" " 
 -- $Property:gen: %id "workspace" 
 -- genclass:stmt: "
 --  %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib " 
 -- $Property:gen: %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib 
 -- genclass:stmt: "%domain_boundary " 
 -- $Property:gen: %domain_boundary 
 L2:
 -- pushReturn:  "workspace "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 103 
 -- Items:GenClass: tinyB descNo: 103 isValue: false 
 -- Items:GenClass: tinyB descNo: 21 isValue: false 

 CLASS tinyB 103 1 workspace 102
 -- Store itemArgs: 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=103 vDescInx=103 vdtTop: 1 
 mvStack 
 -- $Property:gen: %visible LIB.Dimensions 
 -- $var:gen: F: var Float 
 -- DI:gen: "F: var Float " DI:isConst: false isBasicValue: true 
 --  primNo: 9 
 -- DI:gen:primitiveType: F 
 -- $var:gen: I: var Integer 
 -- DI:gen: "I: var Integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: I 
 -- $var:gen: A: var Area.SquareMeter 
 -- DI:gen: "A: var Area.SquareMeter " DI:isConst: false 
 --  isBasicValue: false primNo: 0 
 -- DI:isConst: A 
 -- DI:off: 5 this: "A: var Area.SquareMeter " 
 --  
 -- $ObjectGenerator:gen: Area.SquareMeter >OGid:"SquareMeter" IS.isempty! staticOff=5 descNo=0 superAdj=0
 -- OG:gen: "Area.SquareMeter " 
 -- OG:before:super.gen: "Area.SquareMeter "
 -- $Invocation:gen: Area.SquareMeter >useRtnV:"False"superAdj: 0 descNo: 68
 -- INV:gen: "Area.SquareMeter " 
 -- isConstant: "Invocation ""Area.SquareMeter "
 -- needorigin: "Area.SquareMeter " 
 -- needOrigin:E: "SquareMeter "  E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterEx: "SquareMeter " rec: "Area " E.ATd: 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeterE.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: 
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- after:needOrigin: "SquareMeter " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Area "E:  "SquareMeter "
 -- INV:gen:E.loadArgs "SquareMeter "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: SquareMeter >staticOff:0  \
 -- SquareMeter: Unit \
 --    %unit "m2", 1 \
 --    %Public
 -- 
 -- $pattern:loadArgs:  \
 -- SquareMeter: Unit \
 --    %unit "m2", 1 \
 --    %Public
 -- ptn:loadArgs:E: "SquareMeter " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "SquareMeter "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "
 --  SquareMeter "
 -- $ObjectInvocation_Unary:invoke: SquareMeter >rec:"Area" ATd:"pattern" isValueObj E:"SquareMeter" E.ATd:SquareMeter unique:"False"
 -- OI:invoke: "SquareMeter "
 -- 
 -- OI:invoke:B: "SquareMeter "E: "SquareMeter " rec: "Area "
 --   useRtnV: false 
 --  SquareMeter: Unit
 --     %unit "m2", 1
 --     %Public
 --     thisUnit:: SquareMeter
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- 
 -- $pattern:invoke:  \
 -- SquareMeter: Unit \
 --    %unit "m2", 1 \
 --    %Public
 -- ptn:invoke: "SquareMeter "E: "SquareMeter "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 5 rec: "Area " 
 --  adr:none 
 invokeVal  SquareMeter 68 4
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: SquareMeter :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%visible LIB.Dimensions " 
 -- $Property:gen: %visible LIB.Dimensions 
 -- genclass:stmt: "F := 3 " 
 -- $Assign:gen: F := 3 
 -- AssignmentStatement:gen: "F := 3 " 
 -- computeAdrG:superAdj: 0 "F "
 -- computeAdrG: 1 :rec: "none " E: "F "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrG:isLast:E:  "F "
 -- AssignmentStatement:gen: 
 --  "F := 3 " right.label: "ObjectGenerator ""3 " 
 -- $ObjectGenerator:gen: 3 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "3 " 
 -- OG:before:super.gen: "3 "
 -- $Invocation:gen: 3 >useRtnV:"True"superAdj: 0
 -- INV:gen: "3 " 
 -- isConstant: "Invocation ""3 "
 -- needorigin: "3 " 
 -- needOrigin:E: "3 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "3 " rec: "3 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "3 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3 "E:  "3 "
 -- INV:gen:E.loadArgs "3 "
 -- $ConstLiteral:loadArgs: 3 
 -- INV:gen:after:E.loadArgs "3 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "3 "
 -- $ConstLiteral:invoke: 3 
 pushc 3
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "F "dstE: "F "dstE.ATd: "F: var Float " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "3 "
 -- isArgOfAssignI2IwithUniValArg "F := 3 "arg: "3 "ObjectGenerator 
 -- arg.super.arg: "3 "ConstLiteral 
 -- dstDI: "F: var Float " 
 i2f
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "I := 4.87 " 
 -- $Assign:gen: I := 4.87 
 -- AssignmentStatement:gen: "I := 4.87 " 
 -- computeAdrG:superAdj: 0 "I "
 -- computeAdrG: 1 :rec: "none " E: "I "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrG:isLast:E:  "I "
 -- AssignmentStatement:gen: 
 --  "I := 4.87 " right.label: "ObjectGenerator ""4.87 " 
 -- $ObjectGenerator:gen: 4.87 >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "4.87 " 
 -- OG:before:super.gen: "4.87 "
 -- $Invocation:gen: 4.87 >useRtnV:"True"superAdj: 0
 -- INV:gen: "4.87 " 
 -- isConstant: "Invocation ""4.87 "
 -- needorigin: "4.87 " 
 -- needOrigin:E: "4.87 "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "4.87 " rec: "4.87 " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "4.87 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "4.87 "E:  "4.87 "
 -- INV:gen:E.loadArgs "4.87 "
 -- $FloatLiteral:loadArgs: 4.87 
 -- INV:gen:after:E.loadArgs "4.87 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "4.87 "
 -- $FloatLiteral:invoke: 4.87 
 pushFloatConst 4.870000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "I "dstE: "I "dstE.ATd: "I: var Integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "4.87 "
 -- isArgOfAssignI2IwithUniValArg "I := 4.87 "arg: "4.87 "
 --  ObjectGenerator 
 -- arg.super.arg: "4.87 "FloatLiteral 
 -- dstDI: "I: var Integer " 
 f2i
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg tinyB$103 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "F := F * 12 " 
 -- $Assign:gen: F := F * 12 
 -- AssignmentStatement:gen: "F := F * 12 " 
 -- computeAdrG:superAdj: 0 "F "
 -- computeAdrG: 1 :rec: "none " E: "F "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrG:isLast:E:  "F "
 -- AssignmentStatement:gen: 
 --  "F := F * 12 " right.label: "ObjectGenerator ""F * 12 " 
 -- $ObjectGenerator:gen: F * 12 >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F * 12 " 
 -- OG:before:super.gen: "F * 12 "
 -- $Invocation:gen: F * 12 >useRtnV:"True"superAdj: 0
 -- INV:gen: "F * 12 " 
 -- isConstant: "Invocation ""F * 12 "
 -- needorigin: "F * 12 " 
 -- needOrigin:E: "F * 12 "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "F * 12 " rec: "F * 12 " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "F * 12 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "F * 12 " 
 -- doNeedOrigin:E: "F * 12 " 
 -- computeAdrX:superAdj: 0 "F * 12 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F * 12 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: F * 12 
 -- $BinOp:loadOrigin: F * 12 
 -- BinaryExp:loadOrigin:empty: "F * 12 "superAdj: 0 
 -- $BinOp:getAdr: F * 12 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "F * 12 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "F * 12 "E:  "F * 12 "
 -- INV:gen:E.loadArgs "F * 12 "
 -- $BinOp:loadArgs: F * 12 
 -- BinaryExp:loadArgs: "F * 12 " superAdj: 0 
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:loadArgs:E: "* 12 " 
 -- args: "12 " 
 -- E: "ObjectGenerator "12 
 -- E.arg: "var "in V: var float 
 -- NonVirt: "* 12 " "ObjectInvocation_Binary " ActArg: "12 "
 --  isValue: true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* 12 "
 -- $ObjectGenerator:gen: 12 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "12 " 
 -- OG:before:super.gen: "12 "
 -- $Invocation:gen: 12 >useRtnV:"True"superAdj: 0
 -- INV:gen: "12 " 
 -- isConstant: "Invocation ""12 "
 -- needorigin: "12 " 
 -- needOrigin:E: "12 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "12 " rec: "12 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "12 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12 "E:  "12 "
 -- INV:gen:E.loadArgs "12 "
 -- $ConstLiteral:loadArgs: 12 
 -- INV:gen:after:E.loadArgs "12 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "12 "
 -- $ConstLiteral:invoke: 12 
 pushc 12
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "12 ":isBasicVal: true 
 -- case:B: 12 ObjectGenerator 9 1 1 false true 
 -- convDone: false 
 i2f
 -- end:loadArgs:NonVirt: "* 12 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- INV:gen:after:E.loadArgs "F * 12 "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- IV:E.invoke:useRtnVal: true E: BinOp "F * 12 "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- $BinOp:invoke: F * 12 
 -- BinaryExp:invoke: "F "rec: "F * 12 "
 -- M: "* 12 "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- $ObjectInvocation_Binary:invoke: * 12 >rec:"F" ATd:"pattern" E:"* 12" E.ATd:*   unique:"False"
 -- OI:invoke: "* 12 "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- origin:isValueObj "float "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "* 12 "E: "* 12 " rec: "F " useRtnV: true 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:invoke: "*   "E: "* 12 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "F "E: "* 12 "
 -- arg:integer 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 12":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 12":rec:F 
 -- OI:invoke:C: * 12 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "F "dstE: "F "dstE.ATd: "F: var Float " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "F * 12 "
 -- isArgOfAssignI2IwithUniValArg "F := F * 12 "arg: "F * 12 "
 --  ObjectGenerator 
 -- arg.super.arg: "F * 12 "BinOp 
 -- recx:BinaryExp:recx: "F * 12 "
 -- M: "* 12 "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- checkInt2IntWithUnitArg:rec: "F "E: "* 12 "
 -- arg:integer 
 -- M:arg: "12 "ObjectGenerator false 
 -- dstDI: "F: var Float " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "F := F * I " 
 -- $Assign:gen: F := F * I 
 -- AssignmentStatement:gen: "F := F * I " 
 -- computeAdrG:superAdj: 0 "F "
 -- computeAdrG: 1 :rec: "none " E: "F "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrG:isLast:E:  "F "
 -- AssignmentStatement:gen: 
 --  "F := F * I " right.label: "ObjectGenerator ""F * I " 
 -- $ObjectGenerator:gen: F * I >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F * I " 
 -- OG:before:super.gen: "F * I "
 -- $Invocation:gen: F * I >useRtnV:"True"superAdj: 0
 -- INV:gen: "F * I " 
 -- isConstant: "Invocation ""F * I "
 -- needorigin: "F * I " 
 -- needOrigin:E: "F * I "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "F * I " rec: "F * I " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "F * I "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "F * I " 
 -- doNeedOrigin:E: "F * I " 
 -- computeAdrX:superAdj: 0 "F * I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F * I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: F * I 
 -- $BinOp:loadOrigin: F * I 
 -- BinaryExp:loadOrigin:empty: "F * I "superAdj: 0 
 -- $BinOp:getAdr: F * I 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "F * I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "F * I "E:  "F * I "
 -- INV:gen:E.loadArgs "F * I "
 -- $BinOp:loadArgs: F * I 
 -- BinaryExp:loadArgs: "F * I " superAdj: 0 
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:loadArgs:E: "* I " 
 -- args: "I " 
 -- E: "ObjectGenerator "I 
 -- E.arg: "var "in V: var float 
 -- NonVirt: "* I " "ObjectInvocation_Binary " ActArg: "I "isValue: 
 --  false formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* I "
 -- $ObjectGenerator:gen: I >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I " 
 -- OG:before:super.gen: "I "
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "I ":isBasicVal: true 
 -- case:B: I ObjectGenerator 9 0 1 false false 
 i2f
 -- end:loadArgs:NonVirt: "* I "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- INV:gen:after:E.loadArgs "F * I "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- IV:E.invoke:useRtnVal: true E: BinOp "F * I "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- $BinOp:invoke: F * I 
 -- BinaryExp:invoke: "F "rec: "F * I "
 -- M: "* I "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- $ObjectInvocation_Binary:invoke: * I >rec:"F" ATd:"pattern" E:"* I" E.ATd:*   unique:"False"
 -- OI:invoke: "* I "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- origin:isValueObj "float "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "* I "E: "* I " rec: "F " useRtnV: true 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:invoke: "*   "E: "* I "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "F "E: "* I "
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* I":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* I":rec:F 
 -- OI:invoke:C: * I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "F "dstE: "F "dstE.ATd: "F: var Float " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "F * I "
 -- isArgOfAssignI2IwithUniValArg "F := F * I "arg: "F * I "
 --  ObjectGenerator 
 -- arg.super.arg: "F * I "BinOp 
 -- recx:BinaryExp:recx: "F * I "
 -- M: "* I "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- checkInt2IntWithUnitArg:rec: "F "E: "* I "
 -- arg:other 
 -- M:arg: "I "ObjectGenerator false 
 -- dstDI: "F: var Float " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "F := 10 * F " 
 -- $Assign:gen: F := 10 * F 
 -- AssignmentStatement:gen: "F := 10 * F " 
 -- computeAdrG:superAdj: 0 "F "
 -- computeAdrG: 1 :rec: "none " E: "F "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrG:isLast:E:  "F "
 -- AssignmentStatement:gen: 
 --  "F := 10 * F " right.label: "ObjectGenerator ""10 * F " 
 -- $ObjectGenerator:gen: 10 * F >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "10 * F " 
 -- OG:before:super.gen: "10 * F "
 -- $Invocation:gen: 10 * F >useRtnV:"True"superAdj: 0
 -- INV:gen: "10 * F " 
 -- isConstant: "Invocation ""10 * F "
 -- needorigin: "10 * F " 
 -- needOrigin:E: "10 * F "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "10 * F " rec: "10 * F " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "10 * F "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "10 * F " 
 -- doNeedOrigin:E: "10 * F " 
 -- computeAdrX:superAdj: 0 "10 * F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "10 * F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: 10 * F 
 -- $BinOp:loadOrigin: 10 * F 
 -- BinaryExp:loadOrigin:empty: "10 * F "superAdj: 0 
 -- $BinOp:getAdr: 10 * F 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "10 * F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "10 * F "E:  "10 * F "
 -- INV:gen:E.loadArgs "10 * F "
 -- $BinOp:loadArgs: 10 * F 
 -- BinaryExp:loadArgs: "10 * F " superAdj: 0 
 -- $Invocation:gen: 10 >useRtnV:"True"superAdj: 0
 -- INV:gen: "10 " 
 -- isConstant: "Invocation ""10 "
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- $ConstLiteral:loadArgs: 10 
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 -- $ConstLiteral:invoke: 10 
 pushc 10
 -- INV:gen:end:off: 
 -- left:#I "10 * F "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:loadArgs:E: "* F " 
 -- args: "F " 
 -- E: "ObjectGenerator "F 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "* F " "ObjectInvocation_Binary " ActArg: "F "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* F " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: F >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F " 
 -- OG:before:super.gen: "F "
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "F ":isBasicVal: true 
 -- case:B: F ObjectGenerator 1 0 9 false false 
 f2i
 -- end:loadArgs:NonVirt: "* F "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "10 * F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "10 * F "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: 10 * F 
 -- BinaryExp:invoke: "10 "rec: "10 * F "
 -- M: "* F "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: * F >rec:"10" ATd:"pattern" E:"* F" E.ATd:*   unique:"False"
 -- OI:invoke: "* F "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:10 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:10 
 -- OI:invoke:B: "* F "E: "* F " rec: "10 " useRtnV: true 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:invoke: "*   "E: "* F "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "10 "E: "* F "
 -- arg:other 
 mult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* F":rec:10 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* F":rec:10 
 -- OI:invoke:C: * F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "F "dstE: "F "dstE.ATd: "F: var Float " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "10 * F "
 -- isArgOfAssignI2IwithUniValArg "F := 10 * F "arg: "10 * F "
 --  ObjectGenerator 
 -- arg.super.arg: "10 * F "BinOp 
 -- recx:BinaryExp:recx: "10 * F "
 -- M: "* F "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "10 "E: "* F "
 -- arg:other 
 -- M:arg: "F "ObjectGenerator false 
 -- dstDI: "F: var Float " 
 i2f
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -3 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "F := I * F " 
 -- $Assign:gen: F := I * F 
 -- AssignmentStatement:gen: "F := I * F " 
 -- computeAdrG:superAdj: 0 "F "
 -- computeAdrG: 1 :rec: "none " E: "F "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrG:isLast:E:  "F "
 -- AssignmentStatement:gen: 
 --  "F := I * F " right.label: "ObjectGenerator ""I * F " 
 -- $ObjectGenerator:gen: I * F >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I * F " 
 -- OG:before:super.gen: "I * F "
 -- $Invocation:gen: I * F >useRtnV:"True"superAdj: 0
 -- INV:gen: "I * F " 
 -- isConstant: "Invocation ""I * F "
 -- needorigin: "I * F " 
 -- needOrigin:E: "I * F "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "I * F " rec: "I * F " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "I * F "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "I * F " 
 -- doNeedOrigin:E: "I * F " 
 -- computeAdrX:superAdj: 0 "I * F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I * F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: I * F 
 -- $BinOp:loadOrigin: I * F 
 -- BinaryExp:loadOrigin:empty: "I * F "superAdj: 0 
 -- $BinOp:getAdr: I * F 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "I * F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "I * F "E:  "I * F "
 -- INV:gen:E.loadArgs "I * F "
 -- $BinOp:loadArgs: I * F 
 -- BinaryExp:loadArgs: "I * F " superAdj: 0 
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: -3 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "I * F "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:loadArgs:E: "* F " 
 -- args: "F " 
 -- E: "ObjectGenerator "F 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "* F " "ObjectInvocation_Binary " ActArg: "F "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* F " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: F >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F " 
 -- OG:before:super.gen: "F "
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "F ":isBasicVal: true 
 -- case:B: F ObjectGenerator 1 0 9 false false 
 f2i
 -- end:loadArgs:NonVirt: "* F "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- INV:gen:after:E.loadArgs "I * F "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- IV:E.invoke:useRtnVal: true E: BinOp "I * F "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $BinOp:invoke: I * F 
 -- BinaryExp:invoke: "I "rec: "I * F "
 -- M: "* F "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $ObjectInvocation_Binary:invoke: * F >rec:"I" ATd:"pattern" E:"* F" E.ATd:*   unique:"False"
 -- OI:invoke: "* F "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "* F "E: "* F " rec: "I " useRtnV: true 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:invoke: "*   "E: "* F "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "I "E: "* F "
 -- arg:other 
 mult
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:I 
 -- OI:invoke:C: * F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "F "dstE: "F "dstE.ATd: "F: var Float " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "I * F "
 -- isArgOfAssignI2IwithUniValArg "F := I * F "arg: "I * F "
 --  ObjectGenerator 
 -- arg.super.arg: "I * F "BinOp 
 -- recx:BinaryExp:recx: "I * F "
 -- M: "* F "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "I "E: "* F "
 -- arg:other 
 -- M:arg: "F "ObjectGenerator false 
 -- dstDI: "F: var Float " 
 i2f
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -3 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "F := I * I " 
 -- $Assign:gen: F := I * I 
 -- AssignmentStatement:gen: "F := I * I " 
 -- computeAdrG:superAdj: 0 "F "
 -- computeAdrG: 1 :rec: "none " E: "F "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrG:isLast:E:  "F "
 -- AssignmentStatement:gen: 
 --  "F := I * I " right.label: "ObjectGenerator ""I * I " 
 -- $ObjectGenerator:gen: I * I >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I * I " 
 -- OG:before:super.gen: "I * I "
 -- $Invocation:gen: I * I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I * I " 
 -- isConstant: "Invocation ""I * I "
 -- needorigin: "I * I " 
 -- needOrigin:E: "I * I "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "I * I " rec: "I * I " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "I * I "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "I * I " 
 -- doNeedOrigin:E: "I * I " 
 -- computeAdrX:superAdj: 0 "I * I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I * I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: I * I 
 -- $BinOp:loadOrigin: I * I 
 -- BinaryExp:loadOrigin:empty: "I * I "superAdj: 0 
 -- $BinOp:getAdr: I * I 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "I * I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "I * I "E:  "I * I "
 -- INV:gen:E.loadArgs "I * I "
 -- $BinOp:loadArgs: I * I 
 -- BinaryExp:loadArgs: "I * I " superAdj: 0 
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: -3 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -2 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "I * I "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:loadArgs:E: "* I " 
 -- args: "I " 
 -- E: "ObjectGenerator "I 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "* I " "ObjectInvocation_Binary " ActArg: "I "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* I " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: I >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I " 
 -- OG:before:super.gen: "I "
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "I ":isBasicVal: true 
 -- case:B: I ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "* I "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- INV:gen:after:E.loadArgs "I * I "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- IV:E.invoke:useRtnVal: true E: BinOp "I * I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $BinOp:invoke: I * I 
 -- BinaryExp:invoke: "I "rec: "I * I "
 -- M: "* I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $ObjectInvocation_Binary:invoke: * I >rec:"I" ATd:"pattern" E:"* I" E.ATd:*   unique:"False"
 -- OI:invoke: "* I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "* I "E: "* I " rec: "I " useRtnV: true 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:invoke: "*   "E: "* I "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "I "E: "* I "
 -- arg:other 
 mult
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* I":rec:I 
 -- OI:invoke:C: * I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "F "dstE: "F "dstE.ATd: "F: var Float " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "I * I "
 -- isArgOfAssignI2IwithUniValArg "F := I * I "arg: "I * I "
 --  ObjectGenerator 
 -- arg.super.arg: "I * I "BinOp 
 -- recx:BinaryExp:recx: "I * I "
 -- M: "* I "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "I "E: "* I "
 -- arg:other 
 -- M:arg: "I "ObjectGenerator false 
 -- dstDI: "F: var Float " 
 i2f
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "I := I * 11.11 " 
 -- $Assign:gen: I := I * 11.11 
 -- AssignmentStatement:gen: "I := I * 11.11 " 
 -- computeAdrG:superAdj: 0 "I "
 -- computeAdrG: 1 :rec: "none " E: "I "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrG:isLast:E:  "I "
 -- AssignmentStatement:gen: 
 --  "I := I * 11.11 " right.label: "ObjectGenerator ""I * 11.11 " 
 -- $ObjectGenerator:gen: I * 11.11 >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I * 11.11 " 
 -- OG:before:super.gen: "I * 11.11 "
 -- $Invocation:gen: I * 11.11 >useRtnV:"True"superAdj: 0
 -- INV:gen: "I * 11.11 " 
 -- isConstant: "Invocation ""I * 11.11 "
 -- needorigin: "I * 11.11 " 
 -- needOrigin:E: "I * 11.11 "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "I * 11.11 " rec: "I * 11.11 " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "I * 11.11 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "I * 11.11 " 
 -- doNeedOrigin:E: "I * 11.11 " 
 -- computeAdrX:superAdj: 0 "I * 11.11 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I * 11.11 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: I * 11.11 
 -- $BinOp:loadOrigin: I * 11.11 
 -- BinaryExp:loadOrigin:empty: "I * 11.11 "superAdj: 0 
 -- $BinOp:getAdr: I * 11.11 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "I * 11.11 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "I * 11.11 "E:  "I * 11.11 "
 -- INV:gen:E.loadArgs "I * 11.11 "
 -- $BinOp:loadArgs: I * 11.11 
 -- BinaryExp:loadArgs: "I * 11.11 " superAdj: 0 
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "I * 11.11 "
 -- left:#I2F 
 i2f
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:loadArgs:E: "* 11.11 " 
 -- args: "11.11 " 
 -- E: "ObjectGenerator "11.11 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "* 11.11 " "ObjectInvocation_Binary " ActArg: "11.11 "
 --  isValue: true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* 11.11 " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: 11.11 >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "11.11 " 
 -- OG:before:super.gen: "11.11 "
 -- $Invocation:gen: 11.11 >useRtnV:"True"superAdj: 0
 -- INV:gen: "11.11 " 
 -- isConstant: "Invocation ""11.11 "
 -- needorigin: "11.11 " 
 -- needOrigin:E: "11.11 "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "11.11 " rec: "11.11 " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "11.11 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "11.11 "E:  "11.11 "
 -- INV:gen:E.loadArgs "11.11 "
 -- $FloatLiteral:loadArgs: 11.11 
 -- INV:gen:after:E.loadArgs "11.11 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "11.11 "
 -- $FloatLiteral:invoke: 11.11 
 pushFloatConst 11.110000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "11.11 ":isBasicVal: true 
 -- case:B: 11.11 ObjectGenerator 1 9 9 false true 
 f2i
 -- end:loadArgs:NonVirt: "* 11.11 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- INV:gen:after:E.loadArgs "I * 11.11 "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- IV:E.invoke:useRtnVal: true E: BinOp "I * 11.11 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $BinOp:invoke: I * 11.11 
 -- BinaryExp:invoke: "I "rec: "I * 11.11 "
 -- M: "* 11.11 "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $ObjectInvocation_Binary:invoke: * 11.11 >rec:"I" ATd:"pattern" E:"* 11.11" E.ATd:*   unique:"False"
 -- OI:invoke: "* 11.11 "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "* 11.11 "E: "* 11.11 " rec: "I " useRtnV: true 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:invoke: "*   "E: "* 11.11 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "I "E: "* 11.11 "
 -- arg:float 
 mult
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 11.11":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 11.11":rec:I 
 -- OI:invoke:C: * 11.11 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "I "dstE: "I "dstE.ATd: "I: var Integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "I * 11.11 "
 -- isArgOfAssignI2IwithUniValArg "I := I * 11.11 "arg: "I * 11.11 "
 --  ObjectGenerator 
 -- arg.super.arg: "I * 11.11 "BinOp 
 -- recx:BinaryExp:recx: "I * 11.11 "
 -- M: "* 11.11 "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "I "E: "* 11.11 "
 -- arg:float 
 -- M:arg: "11.11 "ObjectGenerator false 
 -- dstDI: "I: var Integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg tinyB$103 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "I := I * F " 
 -- $Assign:gen: I := I * F 
 -- AssignmentStatement:gen: "I := I * F " 
 -- computeAdrG:superAdj: 0 "I "
 -- computeAdrG: 1 :rec: "none " E: "I "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrG:isLast:E:  "I "
 -- AssignmentStatement:gen: 
 --  "I := I * F " right.label: "ObjectGenerator ""I * F " 
 -- $ObjectGenerator:gen: I * F >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I * F " 
 -- OG:before:super.gen: "I * F "
 -- $Invocation:gen: I * F >useRtnV:"True"superAdj: 0
 -- INV:gen: "I * F " 
 -- isConstant: "Invocation ""I * F "
 -- needorigin: "I * F " 
 -- needOrigin:E: "I * F "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "I * F " rec: "I * F " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "I * F "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "I * F " 
 -- doNeedOrigin:E: "I * F " 
 -- computeAdrX:superAdj: 0 "I * F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I * F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: I * F 
 -- $BinOp:loadOrigin: I * F 
 -- BinaryExp:loadOrigin:empty: "I * F "superAdj: 0 
 -- $BinOp:getAdr: I * F 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "I * F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "I * F "E:  "I * F "
 -- INV:gen:E.loadArgs "I * F "
 -- $BinOp:loadArgs: I * F 
 -- BinaryExp:loadArgs: "I * F " superAdj: 0 
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -7 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -7 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "I * F "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:loadArgs:E: "* F " 
 -- args: "F " 
 -- E: "ObjectGenerator "F 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "* F " "ObjectInvocation_Binary " ActArg: "F "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* F " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: F >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F " 
 -- OG:before:super.gen: "F "
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "F ":isBasicVal: true 
 -- case:B: F ObjectGenerator 1 0 9 false false 
 f2i
 -- end:loadArgs:NonVirt: "* F "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- INV:gen:after:E.loadArgs "I * F "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- IV:E.invoke:useRtnVal: true E: BinOp "I * F "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $BinOp:invoke: I * F 
 -- BinaryExp:invoke: "I "rec: "I * F "
 -- M: "* F "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $ObjectInvocation_Binary:invoke: * F >rec:"I" ATd:"pattern" E:"* F" E.ATd:*   unique:"False"
 -- OI:invoke: "* F "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "* F "E: "* F " rec: "I " useRtnV: true 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:invoke: "*   "E: "* F "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "I "E: "* F "
 -- arg:other 
 mult
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:I 
 -- OI:invoke:C: * F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "I "dstE: "I "dstE.ATd: "I: var Integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "I * F "
 -- isArgOfAssignI2IwithUniValArg "I := I * F "arg: "I * F "
 --  ObjectGenerator 
 -- arg.super.arg: "I * F "BinOp 
 -- recx:BinaryExp:recx: "I * F "
 -- M: "* F "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "I "E: "* F "
 -- arg:other 
 -- M:arg: "F "ObjectGenerator false 
 -- dstDI: "I: var Integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg tinyB$103 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "I := 12.12 * F " 
 -- $Assign:gen: I := 12.12 * F 
 -- AssignmentStatement:gen: "I := 12.12 * F " 
 -- computeAdrG:superAdj: 0 "I "
 -- computeAdrG: 1 :rec: "none " E: "I "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrG:isLast:E:  "I "
 -- AssignmentStatement:gen: 
 --  "I := 12.12 * F " right.label: "ObjectGenerator ""12.12 * F " 
 -- $ObjectGenerator:gen: 12.12 * F >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "12.12 * F " 
 -- OG:before:super.gen: "12.12 * F "
 -- $Invocation:gen: 12.12 * F >useRtnV:"True"superAdj: 0
 -- INV:gen: "12.12 * F " 
 -- isConstant: "Invocation ""12.12 * F "
 -- needorigin: "12.12 * F " 
 -- needOrigin:E: "12.12 * F "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "12.12 * F " rec: "12.12 * F " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "12.12 * F "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "12.12 * F " 
 -- doNeedOrigin:E: "12.12 * F " 
 -- computeAdrX:superAdj: 0 "12.12 * F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "12.12 * F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: 12.12 * F 
 -- $BinOp:loadOrigin: 12.12 * F 
 -- BinaryExp:loadOrigin:empty: "12.12 * F "superAdj: 0 
 -- $BinOp:getAdr: 12.12 * F 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "12.12 * F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "12.12 * F "E:  "12.12 * F "
 -- INV:gen:E.loadArgs "12.12 * F "
 -- $BinOp:loadArgs: 12.12 * F 
 -- BinaryExp:loadArgs: "12.12 * F " superAdj: 0 
 -- $Invocation:gen: 12.12 >useRtnV:"True"superAdj: 0
 -- INV:gen: "12.12 " 
 -- isConstant: "Invocation ""12.12 "
 -- needorigin: "12.12 " 
 -- needOrigin:E: "12.12 "  E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatEx: "12.12 " rec: "12.12 " E.ATd: 
 --  float: Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var FloatE.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  Value
 --     %globals
 --     %basic 9
 --     _thisBasicValue: var Float
 -- after:needOrigin: "12.12 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "12.12 "E:  "12.12 "
 -- INV:gen:E.loadArgs "12.12 "
 -- $FloatLiteral:loadArgs: 12.12 
 -- INV:gen:after:E.loadArgs "12.12 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "12.12 "
 -- $FloatLiteral:invoke: 12.12 
 pushFloatConst 12.120000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:loadArgs:E: "* F " 
 -- args: "F " 
 -- E: "ObjectGenerator "F 
 -- E.arg: "var "in V: var float 
 -- NonVirt: "* F " "ObjectInvocation_Binary " ActArg: "F "isValue: 
 --  false formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* F "
 -- $ObjectGenerator:gen: F >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F " 
 -- OG:before:super.gen: "F "
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "F ":isBasicVal: true 
 -- case:B: F ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* F "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "12.12 * F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "12.12 * F "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: 12.12 * F 
 -- BinaryExp:invoke: "12.12 "rec: "12.12 * F "
 -- M: "* F "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: * F >rec:"12.12" ATd:"pattern" E:"* F" E.ATd:*   unique:"False"
 -- OI:invoke: "* F "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:12.12 
 -- origin:isValueObj "float "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:12.12 
 -- OI:invoke:B: "* F "E: "* F " rec: "12.12 " useRtnV: true 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:invoke: "*   "E: "* F "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "12.12 "E: "* F "
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* F":rec:12.12 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* F":rec:12.12 
 -- OI:invoke:C: * F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "I "dstE: "I "dstE.ATd: "I: var Integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "12.12 * F "
 -- isArgOfAssignI2IwithUniValArg "I := 12.12 * F "arg: "12.12 * F "
 --  ObjectGenerator 
 -- arg.super.arg: "12.12 * F "BinOp 
 -- recx:BinaryExp:recx: "12.12 * F "
 -- M: "* F "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- checkInt2IntWithUnitArg:rec: "12.12 "E: "* F "
 -- arg:other 
 -- M:arg: "F "ObjectGenerator false 
 -- dstDI: "I: var Integer " 
 f2i
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg tinyB$103 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "I := I * F " 
 -- $Assign:gen: I := I * F 
 -- AssignmentStatement:gen: "I := I * F " 
 -- computeAdrG:superAdj: 0 "I "
 -- computeAdrG: 1 :rec: "none " E: "I "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrG:isLast:E:  "I "
 -- AssignmentStatement:gen: 
 --  "I := I * F " right.label: "ObjectGenerator ""I * F " 
 -- $ObjectGenerator:gen: I * F >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I * F " 
 -- OG:before:super.gen: "I * F "
 -- $Invocation:gen: I * F >useRtnV:"True"superAdj: 0
 -- INV:gen: "I * F " 
 -- isConstant: "Invocation ""I * F "
 -- needorigin: "I * F " 
 -- needOrigin:E: "I * F "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "I * F " rec: "I * F " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "I * F "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "I * F " 
 -- doNeedOrigin:E: "I * F " 
 -- computeAdrX:superAdj: 0 "I * F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I * F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: I * F 
 -- $BinOp:loadOrigin: I * F 
 -- BinaryExp:loadOrigin:empty: "I * F "superAdj: 0 
 -- $BinOp:getAdr: I * F 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "I * F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "I * F "E:  "I * F "
 -- INV:gen:E.loadArgs "I * F "
 -- $BinOp:loadArgs: I * F 
 -- BinaryExp:loadArgs: "I * F " superAdj: 0 
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -8 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -8 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "I * F "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:loadArgs:E: "* F " 
 -- args: "F " 
 -- E: "ObjectGenerator "F 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "* F " "ObjectInvocation_Binary " ActArg: "F "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* F " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: F >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F " 
 -- OG:before:super.gen: "F "
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "F ":isBasicVal: true 
 -- case:B: F ObjectGenerator 1 0 9 false false 
 f2i
 -- end:loadArgs:NonVirt: "* F "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- INV:gen:after:E.loadArgs "I * F "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- IV:E.invoke:useRtnVal: true E: BinOp "I * F "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $BinOp:invoke: I * F 
 -- BinaryExp:invoke: "I "rec: "I * F "
 -- M: "* F "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- $ObjectInvocation_Binary:invoke: * F >rec:"I" ATd:"pattern" E:"* F" E.ATd:*   unique:"False"
 -- OI:invoke: "* F "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "* F "E: "* F " rec: "I " useRtnV: true 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:invoke: "*   "E: "* F "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "I "E: "* F "
 -- arg:other 
 mult
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:I 
 -- OI:invoke:C: * F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "I "dstE: "I "dstE.ATd: "I: var Integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "I * F "
 -- isArgOfAssignI2IwithUniValArg "I := I * F "arg: "I * F "
 --  ObjectGenerator 
 -- arg.super.arg: "I * F "BinOp 
 -- recx:BinaryExp:recx: "I * F "
 -- M: "* F "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "I "E: "* F "
 -- arg:other 
 -- M:arg: "F "ObjectGenerator false 
 -- dstDI: "I: var Integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg tinyB$103 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "I := F * F " 
 -- $Assign:gen: I := F * F 
 -- AssignmentStatement:gen: "I := F * F " 
 -- computeAdrG:superAdj: 0 "I "
 -- computeAdrG: 1 :rec: "none " E: "I "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrG:isLast:E:  "I "
 -- AssignmentStatement:gen: 
 --  "I := F * F " right.label: "ObjectGenerator ""F * F " 
 -- $ObjectGenerator:gen: F * F >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F * F " 
 -- OG:before:super.gen: "F * F "
 -- $Invocation:gen: F * F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F * F " 
 -- isConstant: "Invocation ""F * F "
 -- needorigin: "F * F " 
 -- needOrigin:E: "F * F "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "F * F " rec: "F * F " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "F * F "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "F * F " 
 -- doNeedOrigin:E: "F * F " 
 -- computeAdrX:superAdj: 0 "F * F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F * F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: F * F 
 -- $BinOp:loadOrigin: F * F 
 -- BinaryExp:loadOrigin:empty: "F * F "superAdj: 0 
 -- $BinOp:getAdr: F * F 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "F * F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "F * F "E:  "F * F "
 -- INV:gen:E.loadArgs "F * F "
 -- $BinOp:loadArgs: F * F 
 -- BinaryExp:loadArgs: "F * F " superAdj: 0 
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:loadArgs:E: "* F " 
 -- args: "F " 
 -- E: "ObjectGenerator "F 
 -- E.arg: "var "in V: var float 
 -- NonVirt: "* F " "ObjectInvocation_Binary " ActArg: "F "isValue: 
 --  false formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* F "
 -- $ObjectGenerator:gen: F >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F " 
 -- OG:before:super.gen: "F "
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "F ":isBasicVal: true 
 -- case:B: F ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* F "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- INV:gen:after:E.loadArgs "F * F "
 --  OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- IV:E.invoke:useRtnVal: true E: BinOp "F * F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- $BinOp:invoke: F * F 
 -- BinaryExp:invoke: "F "rec: "F * F "
 -- M: "* F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- $ObjectInvocation_Binary:invoke: * F >rec:"F" ATd:"pattern" E:"* F" E.ATd:*   unique:"False"
 -- OI:invoke: "* F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- origin:isValueObj "float "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "* F "E: "* F " rec: "F " useRtnV: true 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:invoke: "*   "E: "* F "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "F "E: "* F "
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* F":rec:F 
 -- OI:invoke:C: * F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "I "dstE: "I "dstE.ATd: "I: var Integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "F * F "
 -- isArgOfAssignI2IwithUniValArg "I := F * F "arg: "F * F "
 --  ObjectGenerator 
 -- arg.super.arg: "F * F "BinOp 
 -- recx:BinaryExp:recx: "F * F "
 -- M: "* F "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- checkInt2IntWithUnitArg:rec: "F "E: "* F "
 -- arg:other 
 -- M:arg: "F "ObjectGenerator false 
 -- dstDI: "I: var Integer " 
 f2i
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg tinyB$103 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "putint(I) " 
 -- $ObjectGenerator:gen: putint(I) >OGid:"putint" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "putint(I) " 
 -- OG:before:super.gen: "putint(I) "
 -- $Invocation:gen: putint(I) >useRtnV:"False"superAdj: 0 descNo: 105
 -- INV:gen: "putint(I) " 
 -- isConstant: "Invocation ""putint(I) "
 -- needorigin: "putint(I) " 
 -- needOrigin:E: "putint(I) "  E.ATd: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)Ex: "putint(I) " rec: "putint(I) " E.ATd: 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)E.ATd.desc: 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integerE.ATd.IT: 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 -- after:needOrigin: "putint(I) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "putint(I) "E:  "putint(I) "
 -- INV:gen:E.loadArgs "putint(I) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: putint(I) >staticOff:0  \
 -- putint:  \
 --    %globals \
 --    in V: var integer
 -- 
 -- $pattern:loadArgs:  \
 -- putint:  \
 --    %globals \
 --    in V: var integer
 -- ptn:loadArgs:E: "putint(I) " 
 -- args: "putint(I) " 
 -- E: "ObjectGenerator "I 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "putint(I) " "ObjectInvocation_KeyWord " ActArg: "I "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putint(I) " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: I >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "I " 
 -- OG:before:super.gen: "I "
 -- $Invocation:gen: I >useRtnV:"True"superAdj: 0
 -- INV:gen: "I " 
 -- isConstant: "Invocation ""I "
 -- notConst: I I: var Integer 
 -- needorigin: "I " 
 -- needOrigin:E: "I "  E.ATd: "I: var Integer " Ex: "I " rec: "I " 
 --  E.ATd: "I: var Integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "I " 
 -- doNeedOrigin:E: "I " 
 -- computeAdrX:superAdj: 0 "I " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "I " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: I 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: I >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: I >ATd.off:4:on:0:superAdj:0I: var Integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: I: var Integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"I":rec:-
 -- DI:OG: Integer 
 -- before:floatTest:  "I: var Integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- computeAdrX:isLast:E:  "I "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 --  rec:  "I "E:  "I "
 -- INV:gen:E.loadArgs "I "
 -- $ObjectInvocation_Unary:loadArgs: I >staticOff:0 I: var Integer superAdj:0
 -- $var:loadArgs: I: var Integer >E:"I"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "I " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "I "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "I "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:- 
 -- $ObjectInvocation_Unary:invoke: I >rec:"I" ATd:"var" isValueObj E:"I" E.ATd:I unique:"False"
 -- OI:invoke: "I "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:B: "I "E: "I " rec: "I " useRtnV: true "
 --  I: var Integer " 
 -- OI:invoke:before:ATdx.invoke: var I 
 -- $var:invoke: I: var Integer E: "I">newOff:4 useRTNv: "True"
 -- DI:invoke: "I: var Integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I isNotRemote: true 
 -- isCompositeValueObj: false E: "I ""I: var Integer " true 
 -- E.ATd.isValueObj: false rec: "I "
 pushg 4 tinyB$103
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -9 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -9 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- OI:invoke:C: I :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"I":rec:I 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "I ":isBasicVal: true 
 -- case:B: I ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "putint(I) "
 -- INV:gen:after:E.loadArgs "putint(I) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  putint(I) "
 -- $ObjectInvocation_KeyWord:invoke: putint(I) >rec:"putint(I)" ATd:"pattern" E:"putint(I)" E.ATd:putint unique:"False"
 -- OI:invoke: "putint(I) "
 -- 
 -- OI:invoke:B: "putint(I) "E: "putint(I) " rec: "putint(I) "
 --   useRtnV: false 
 --  putint: 
 --     %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 -- OI:invoke:before:ATdx.invoke: pattern putint 
 -- 
 -- $pattern:invoke:  \
 -- putint:  \
 --    %globals \
 --    in V: var integer
 -- ptn:invoke: "putint "E: "putint(I) "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putint(I) " 
 --  adr:none 
 invoke putint 105 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -10 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: putint(I) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: "newline " 
 -- $ObjectGenerator:gen: newline >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "newline " 
 -- OG:before:super.gen: "newline "
 -- $Invocation:gen: newline >useRtnV:"False"superAdj: 0 descNo: 115
 -- INV:gen: "newline " 
 -- isConstant: "Invocation ""newline "
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: newline >staticOff:0  \
 -- newline:  \
 --    %globals \
 --    put(10) superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- newline:  \
 --    %globals \
 --    put(10) >E:"newline":descNo:115
 -- ptn:loadArgs:E: "newline " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- $ObjectInvocation_Unary:invoke: newline >rec:"newline" ATd:"pattern" E:"newline" E.ATd:newline unique:"False"
 -- OI:invoke: "newline "
 -- 
 -- OI:invoke:B: "newline "E: "newline " rec: "newline " useRtnV: 
 --  false 
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- 
 -- $pattern:invoke:  \
 -- newline:  \
 --    %globals \
 --    put(10) E: "newline" useRTNv: "False"
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 115 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -11 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: newline :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: "putfloat(F) " 
 -- $ObjectGenerator:gen: putfloat(F) >OGid:"putFloat" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "putfloat(F) " 
 -- OG:before:super.gen: "putfloat(F) "
 -- $Invocation:gen: putfloat(F) >useRtnV:"False"superAdj: 0 descNo: 56
 -- INV:gen: "putfloat(F) " 
 -- isConstant: "Invocation ""putfloat(F) "
 -- needorigin: "putfloat(F) " 
 -- needOrigin:E: "putfloat(F) "  E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  Ex: "putfloat(F) " rec: "putfloat(F) " E.ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  E.ATd.desc: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 --  E.ATd.IT: 
 --  %basic 142
 --  in X: var Float
 --  out V: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "putfloat(F) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "putfloat(F) " 
 -- doNeedOrigin:E: "putfloat(F) " 
 -- computeAdrX:superAdj: 0 "putfloat(F) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "putfloat(F) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: putfloat(F) 
 -- $ObjectInvocation_KeyWord:loadOrigin: putfloat(F) >on:1 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: putfloat(F) >ATd.off:0 (isPtn):on:1:superAdj:0 \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- 
 -- $pattern:getAdr:  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "putfloat(F) " ATd: 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:- 
 -- computeAdrX:isLast:E:  "putfloat(F) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:- 
 --  rec:  "putfloat(F) "E:  "putfloat(F) "
 -- INV:gen:E.loadArgs "putfloat(F) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: putfloat(F) >staticOff:0  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- 
 -- $pattern:loadArgs:  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- ptn:loadArgs:E: "putfloat(F) " 
 -- args: "putfloat(F) " 
 -- E: "ObjectGenerator "F 
 -- E.arg: "var "in X: var Float 
 -- NonVirt: "putfloat(F) " "ObjectInvocation_KeyWord " ActArg: "F "
 --  isValue: false formalArg: "in X: var Float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putfloat(F) "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: F >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "F " 
 -- OG:before:super.gen: "F "
 -- $Invocation:gen: F >useRtnV:"True"superAdj: 0
 -- INV:gen: "F " 
 -- isConstant: "Invocation ""F "
 -- notConst: F F: var Float 
 -- needorigin: "F " 
 -- needOrigin:E: "F "  E.ATd: "F: var Float " Ex: "F " rec: "F " 
 --  E.ATd: "F: var Float " E.ATd.desc: 
 --  %globals
 --  %basic 9
 --  _thisBasicValue: var Float
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "F " 
 -- doNeedOrigin:E: "F " 
 -- computeAdrX:superAdj: 0 "F " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "F " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: F 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: F >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: F >ATd.off:2:on:0:superAdj:0F: var Float:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: F: var Float >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F":rec:-
 -- DI:OG: Float 
 -- before:floatTest:  "F: var Float "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- getAdr:isfloat:A:  F: var Float  A.isValue: true 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdrX:isLast:E:  "F "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 --  rec:  "F "E:  "F "
 -- INV:gen:E.loadArgs "F "
 -- $ObjectInvocation_Unary:loadArgs: F >staticOff:0 F: var Float superAdj:0
 -- $var:loadArgs: F: var Float >E:"F"
 -- 
 -- $pattern:loadArgs:  \
 -- float: Value \
 --    %globals \
 --    %basic 9
 -- ptn:loadArgs:E: "F " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "F "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "F "
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:invoke: F >rec:"F" ATd:"var" isValueObj E:"F" E.ATd:F unique:"False"
 -- OI:invoke: "F "
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F "E: "F " rec: "F " useRtnV: true "F: var Float " 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: F: var Float E: "F">newOff:2 useRTNv: "True"
 -- DI:invoke: "F: var Float " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F isNotRemote: true 
 -- isCompositeValueObj: false E: "F ""F: var Float " true 
 -- E.ATd.isValueObj: false rec: "F "
 fpushg 2 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:C: F :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- actualArg:isPtn: false formalArg:isPtn: "in X: var Float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "F ":isBasicVal: true 
 -- case:B: F ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putfloat(F) "
 -- INV:gen:after:E.loadArgs "putfloat(F) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  putfloat(F) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: putfloat(F) >rec:"putfloat(F)" ATd:"pattern" E:"putfloat(F)" E.ATd:putFloat unique:"False"
 -- OI:invoke: "putfloat(F) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:putfloat(F) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:putfloat(F) 
 -- OI:invoke:B: "putfloat(F) "E: "putfloat(F) " rec: "putfloat(F) "
 --   useRtnV: false 
 --  putFloat: 
 --     %basic 142
 --     in X: var Float
 --     out V: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- 
 -- $pattern:invoke:  \
 -- putFloat:  \
 --    %basic 142 \
 --    in X: var Float
 -- ptn:invoke: "putFloat "E: "putfloat(F) "ptnKind: 0 useRtnV: 
 --  false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "putfloat(F) " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:putfloat(F) 
 %printf_prim 142
 vpop
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -11 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:putfloat(F) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:putfloat(F) 
 -- OI:invoke:C: putfloat(F) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putfloat(F)":rec:putfloat(F) 
 -- genclass:stmt: "newline " 
 -- $ObjectGenerator:gen: newline >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "newline " 
 -- OG:before:super.gen: "newline "
 -- $Invocation:gen: newline >useRtnV:"False"superAdj: 0 descNo: 115
 -- INV:gen: "newline " 
 -- isConstant: "Invocation ""newline "
 -- needorigin: "newline " 
 -- needOrigin:E: "newline "  E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  Ex: "newline " rec: "newline " E.ATd: 
 --  newline: 
 --     %globals
 --     put(10)
 --  E.ATd.desc: 
 --  %globals
 --  put(10)
 --  E.ATd.IT: 
 --  %globals
 --  put(10)
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     put(10)
 --  
 -- after:needOrigin: "newline " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "newline "E:  "newline "
 -- INV:gen:E.loadArgs "newline "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: newline >staticOff:0  \
 -- newline:  \
 --    %globals \
 --    put(10) superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- newline:  \
 --    %globals \
 --    put(10) >E:"newline":descNo:115
 -- ptn:loadArgs:E: "newline " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "newline "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline "
 -- $ObjectInvocation_Unary:invoke: newline >rec:"newline" ATd:"pattern" E:"newline" E.ATd:newline unique:"False"
 -- OI:invoke: "newline "
 -- 
 -- OI:invoke:B: "newline "E: "newline " rec: "newline " useRtnV: 
 --  false 
 --  newline: 
 --     %globals
 --     put(10)
 --  
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- 
 -- $pattern:invoke:  \
 -- newline:  \
 --    %globals \
 --    put(10) E: "newline" useRTNv: "False"
 -- ptn:invoke: "newline "E: "newline "ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "newline " 
 --  adr:none 
 invoke newline 115 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 2 rTop: -12 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: newline :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: "A := 24"m2" " 
 -- $Assign:gen: A := 24"m2" 
 -- AssignmentStatement:gen: "A := 24"m2" " 
 -- computeAdrG:superAdj: 0 "A "
 -- computeAdrG: 1 :rec: "none " E: "A "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: A 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: A >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: A >ATd.off:5:on:0:superAdj:0A: var Area.SquareMeter:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: A: var Area.SquareMeter >newOff:5,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"A":rec:-
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter "ObjectGenerator 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdrG:isLast:E:  "A "
 -- AssignmentStatement:gen: 
 --  "A := 24"m2" " right.label: "ObjectGenerator ""24"m2" " 
 -- $ObjectGenerator:gen: 24"m2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "24"m2" " 
 -- OG:before:super.gen: "24"m2" "
 -- $Invocation:gen: 24"m2" >useRtnV:"True"superAdj: 0
 -- INV:gen: "24"m2" " 
 -- isConstant: "Invocation ""24"m2" "
 -- needorigin: "24"m2" " 
 -- needOrigin:E: "24"m2" "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "24"m2" " rec: "24"m2" " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "24"m2" " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "24"m2" "E:  "24"m2" "
 -- INV:gen:E.loadArgs "24"m2" "
 -- $ConstLiteral:loadArgs: 24"m2" 
 -- INV:gen:after:E.loadArgs "24"m2" "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "24"m2" "
 -- $ConstLiteral:invoke: 24"m2" 
 pushc 24
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "A "dstE: "A "dstE.ATd: "A: var Area.SquareMeter " useRtn: 
 --  false 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: true 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "24"m2" "
 -- isArgOfAssignI2IwithUniValArg "A := 24"m2" "arg: "24"m2" "
 --  ObjectGenerator 
 -- arg.super.arg: "24"m2" "ConstLiteral 
 -- dstDI: "A: var Area.SquareMeter " 
 i2f
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 5 address:storeg
 -- stack: vpop : vTop: 0 vTopMax: 2 rTop: -12 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "A := 3 * A " 
 -- $Assign:gen: A := 3 * A 
 -- AssignmentStatement:gen: "A := 3 * A " 
 -- computeAdrG:superAdj: 0 "A "
 -- computeAdrG: 1 :rec: "none " E: "A "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: A 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: A >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: A >ATd.off:5:on:0:superAdj:0A: var Area.SquareMeter:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: A: var Area.SquareMeter >newOff:5,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"A":rec:-
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter "ObjectGenerator 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdrG:isLast:E:  "A "
 -- AssignmentStatement:gen: 
 --  "A := 3 * A " right.label: "ObjectGenerator ""3 * A " 
 -- $ObjectGenerator:gen: 3 * A >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "3 * A " 
 -- OG:before:super.gen: "3 * A "
 -- $Invocation:gen: 3 * A >useRtnV:"True"superAdj: 0
 -- INV:gen: "3 * A " 
 -- isConstant: "Invocation ""3 * A "
 -- needorigin: "3 * A " 
 -- needOrigin:E: "3 * A "  E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  Ex: "3 * A " rec: "3 * A " E.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 66
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "3 * A "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "3 * A " 
 -- doNeedOrigin:E: "3 * A " 
 -- computeAdrX:superAdj: 0 "3 * A " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "3 * A " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: 3 * A 
 -- $BinOp:loadOrigin: 3 * A 
 -- BinaryExp:loadOrigin:empty: "3 * A "superAdj: 0 
 -- $BinOp:getAdr: 3 * A 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "3 * A "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "3 * A "E:  "3 * A "
 -- INV:gen:E.loadArgs "3 * A "
 -- $BinOp:loadArgs: 3 * A 
 -- BinaryExp:loadArgs: "3 * A " superAdj: 0 
 -- $Invocation:gen: 3 >useRtnV:"True"superAdj: 0
 -- INV:gen: "3 " 
 -- isConstant: "Invocation ""3 "
 -- needorigin: "3 " 
 -- needOrigin:E: "3 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "3 " rec: "3 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "3 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "3 "E:  "3 "
 -- INV:gen:E.loadArgs "3 "
 -- $ConstLiteral:loadArgs: 3 
 -- INV:gen:after:E.loadArgs "3 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "3 "
 -- $ConstLiteral:invoke: 3 
 pushc 3
 -- INV:gen:end:off: 
 -- left:#I "3 * A "
 -- left:#I2F 
 i2f
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:loadArgs:E: "* A " 
 -- args: "A " 
 -- E: "ObjectGenerator "A 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "* A " "ObjectInvocation_Binary " ActArg: "A "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "* A " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: A >OGid:"SquareMeter" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "A " 
 -- OG:before:super.gen: "A "
 -- $Invocation:gen: A >useRtnV:"True"superAdj: 0
 -- INV:gen: "A " 
 -- isConstant: "Invocation ""A "
 -- notConst: A A: var Area.SquareMeter 
 -- needorigin: "A " 
 -- needOrigin:E: "A "  E.ATd: "A: var Area.SquareMeter " Ex: "A " 
 --  rec: "A " E.ATd: "A: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A " 
 -- doNeedOrigin:E: "A " 
 -- computeAdrX:superAdj: 0 "A " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: A 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: A >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: A >ATd.off:5:on:0:superAdj:0A: var Area.SquareMeter:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: A: var Area.SquareMeter >newOff:5,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"A":rec:-
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter "ObjectGenerator 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdrX:isLast:E:  "A "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 --  rec:  "A "E:  "A "
 -- INV:gen:E.loadArgs "A "
 -- $ObjectInvocation_Unary:loadArgs: A >staticOff:0 A: var Area.SquareMeter superAdj:0
 -- $var:loadArgs: A: var Area.SquareMeter >E:"A"
 -- 
 -- $pattern:loadArgs:  \
 -- SquareMeter: Unit \
 --    %unit "m2", 1 \
 --    %Public
 -- ptn:loadArgs:E: "A " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "A "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A "
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- $ObjectInvocation_Unary:invoke: A >rec:"A" ATd:"var" isValueObj E:"A" E.ATd:A unique:"False"
 -- OI:invoke: "A "
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:B: "A "E: "A " rec: "A " useRtnV: true "
 --  A: var Area.SquareMeter " 
 -- OI:invoke:before:ATdx.invoke: var A 
 -- $var:invoke: A: var Area.SquareMeter E: "A">newOff:5 useRTNv: "True"
 -- DI:invoke: "A: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A ",E: "A ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- Address:loadAdr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 5 
 -- OI:invoke:V: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:C: A :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 --  :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: A 
 -- end:loadArgs:NonVirt: "* A "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "3 * A "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "3 * A "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: 3 * A 
 -- BinaryExp:invoke: "3 "rec: "3 * A "
 -- M: "* A "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: * A >rec:"3" ATd:"pattern" E:"* A" E.ATd:*   unique:"False"
 -- OI:invoke: "* A "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:3 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:3 
 -- OI:invoke:B: "* A "E: "* A " rec: "3 " useRtnV: true 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 66 \
 --    in V: var integer
 -- ptn:invoke: "*   "E: "* A "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "3 "E: "* A "
 -- arg:unit 
 -- rec:isInteger: 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* A":rec:3 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"* A":rec:3 
 -- OI:invoke:C: * A :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "A "dstE: "A "dstE.ATd: "A: var Area.SquareMeter " useRtn: 
 --  false 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: true 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "3 * A "
 -- isArgOfAssignI2IwithUniValArg "A := 3 * A "arg: "3 * A "
 --  ObjectGenerator 
 -- arg.super.arg: "3 * A "BinOp 
 -- recx:BinaryExp:recx: "3 * A "
 -- M: "* A "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 66
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "3 "E: "* A "
 -- arg:unit 
 -- rec:isInteger: 
 -- M:arg: "A "ObjectGenerator true 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 5 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 2 rTop: -12 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "A := A * 2 " 
 -- $Assign:gen: A := A * 2 
 -- AssignmentStatement:gen: "A := A * 2 " 
 -- computeAdrG:superAdj: 0 "A "
 -- computeAdrG: 1 :rec: "none " E: "A "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: A 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: A >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: A >ATd.off:5:on:0:superAdj:0A: var Area.SquareMeter:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: A: var Area.SquareMeter >newOff:5,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"A":rec:-
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter "ObjectGenerator 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdrG:isLast:E:  "A "
 -- AssignmentStatement:gen: 
 --  "A := A * 2 " right.label: "ObjectGenerator ""A * 2 " 
 -- $ObjectGenerator:gen: A * 2 >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "A * 2 " 
 -- OG:before:super.gen: "A * 2 "
 -- $Invocation:gen: A * 2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "A * 2 " 
 -- isConstant: "Invocation ""A * 2 "
 -- needorigin: "A * 2 " 
 -- needOrigin:E: "A * 2 "  E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  Ex: "A * 2 " rec: "A * 2 " E.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  E.ATd.desc: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 --  E.ATd.IT: 
 --  %basic 112
 --  in V: var float
 --  out R: var float
 -- \
 --   
 -- doNeedOrigin:Ex: "A * 2 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "A * 2 " 
 -- doNeedOrigin:E: "A * 2 " 
 -- computeAdrX:superAdj: 0 "A * 2 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A * 2 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: A * 2 
 -- $BinOp:loadOrigin: A * 2 
 -- BinaryExp:loadOrigin:empty: "A * 2 "superAdj: 0 
 -- $BinOp:getAdr: A * 2 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "A * 2 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "A * 2 "E:  "A * 2 "
 -- INV:gen:E.loadArgs "A * 2 "
 -- $BinOp:loadArgs: A * 2 
 -- BinaryExp:loadArgs: "A * 2 " superAdj: 0 
 -- $Invocation:gen: A >useRtnV:"True"superAdj: 0
 -- INV:gen: "A " 
 -- isConstant: "Invocation ""A "
 -- notConst: A A: var Area.SquareMeter 
 -- needorigin: "A " 
 -- needOrigin:E: "A "  E.ATd: "A: var Area.SquareMeter " Ex: "A " 
 --  rec: "A " E.ATd: "A: var Area.SquareMeter " E.ATd.desc: 
 --  %unit "m2", 1
 --  %Public
 --  thisUnit:: SquareMeter
 --  print:: E.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "A " 
 -- doNeedOrigin:E: "A " 
 -- computeAdrX:superAdj: 0 "A " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: A 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: A >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: A >ATd.off:5:on:0:superAdj:0A: var Area.SquareMeter:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: A: var Area.SquareMeter >newOff:5,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"A":rec:-
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter "ObjectGenerator 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdrX:isLast:E:  "A "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 --  rec:  "A "E:  "A "
 -- INV:gen:E.loadArgs "A "
 -- $ObjectInvocation_Unary:loadArgs: A >staticOff:0 A: var Area.SquareMeter superAdj:0
 -- $var:loadArgs: A: var Area.SquareMeter >E:"A"
 -- 
 -- $pattern:loadArgs:  \
 -- SquareMeter: Unit \
 --    %unit "m2", 1 \
 --    %Public
 -- ptn:loadArgs:E: "A " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "A "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "A "
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- $ObjectInvocation_Unary:invoke: A >rec:"A" ATd:"var" isValueObj E:"A" E.ATd:A unique:"False"
 -- OI:invoke: "A "
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:B: "A "E: "A " rec: "A " useRtnV: true "
 --  A: var Area.SquareMeter " 
 -- OI:invoke:before:ATdx.invoke: var A 
 -- $var:invoke: A: var Area.SquareMeter E: "A">newOff:5 useRTNv: "True"
 -- DI:invoke: "A: var Area.SquareMeter " 
 -- isValueObj:isAdr: false objSize: 2  rec "A ",E: "A ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- Address:loadAdr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 5 
 -- OI:invoke:V: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:C: A :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- 
 -- $pattern:loadArgs:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:loadArgs:E: "* 2 " 
 -- args: "2 " 
 -- E: "ObjectGenerator "2 
 -- E.arg: "var "in V: var float 
 -- NonVirt: "* 2 " "ObjectInvocation_Binary " ActArg: "2 "isValue: 
 --  true formalArg: "in V: var float " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* 2 "
 -- $ObjectGenerator:gen: 2 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "2 " 
 -- OG:before:super.gen: "2 "
 -- $Invocation:gen: 2 >useRtnV:"True"superAdj: 0
 -- INV:gen: "2 " 
 -- isConstant: "Invocation ""2 "
 -- needorigin: "2 " 
 -- needOrigin:E: "2 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "2 " rec: "2 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "2 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "2 "E:  "2 "
 -- INV:gen:E.loadArgs "2 "
 -- $ConstLiteral:loadArgs: 2 
 -- INV:gen:after:E.loadArgs "2 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "2 "
 -- $ConstLiteral:invoke: 2 
 pushc 2
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var float "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "2 ":isBasicVal: true 
 -- case:B: 2 ObjectGenerator 9 1 1 false true 
 -- convDone: false 
 i2f
 -- end:loadArgs:NonVirt: "* 2 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- INV:gen:after:E.loadArgs "A * 2 "
 --  OIadr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- IV:E.invoke:useRtnVal: true E: BinOp "A * 2 "
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- $BinOp:invoke: A * 2 
 -- BinaryExp:invoke: "A "rec: "A * 2 "
 -- M: "* 2 "
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- $ObjectInvocation_Binary:invoke: * 2 >rec:"A" ATd:"pattern" E:"* 2" E.ATd:*   unique:"False"
 -- OI:invoke: "* 2 "
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- origin:isValueObj "float "
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:B: "* 2 "E: "* 2 " rec: "A " useRtnV: true 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- 
 -- $pattern:invoke:  \
 -- *  :  \
 --    %basic 112 \
 --    in V: var float
 -- ptn:invoke: "*   "E: "* 2 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "A "E: "* 2 "
 -- arg:integer 
 fmult
 -- OI:invoke:V: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 2":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* 2":rec:A 
 -- OI:invoke:C: * 2 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "A "dstE: "A "dstE.ATd: "A: var Area.SquareMeter " useRtn: 
 --  false 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: true 
 --  right.super.isUnitValObj: false F: true I: false 
 -- right: "A * 2 "
 -- isArgOfAssignI2IwithUniValArg "A := A * 2 "arg: "A * 2 "
 --  ObjectGenerator 
 -- arg.super.arg: "A * 2 "BinOp 
 -- recx:BinaryExp:recx: "A * 2 "
 -- M: "* 2 "label: "ObjectInvocation_Binary "M.ATd: 
 --  *  : 
 --     %basic 112
 --     in V: var float
 --     out R: var float
 --  
 -- checkInt2IntWithUnitArg:rec: "A "E: "* 2 "
 -- arg:integer 
 -- M:arg: "2 "ObjectGenerator false 
 -- dstDI: "A: var Area.SquareMeter " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 5 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 2 rTop: -12 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "A.print " 
 -- $ObjectGenerator:gen: A.print >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "A.print " 
 -- OG:before:super.gen: "A.print "
 -- $Invocation:gen: A.print >useRtnV:"False"superAdj: 0 descNo: 70
 -- INV:gen: "A.print " 
 -- isConstant: "Invocation ""A.print "
 -- notConst: A A: var Area.SquareMeter 
 -- needorigin: "A.print " 
 -- needOrigin:E: "print "  E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  Ex: "print " rec: "A " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  E.ATd.desc: ""SquareMeter".print " E.ATd.IT: "
 --  "SquareMeter".print " 
 -- doNeedOrigin:Ex: "print "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- origin:isValueObj: "SquareMeter "
 -- after:needOrigin: "print " 
 -- doNeedOrigin:E: "print " 
 -- computeAdrX:superAdj: 0 "A.print " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "A " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: A 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: A >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: A >ATd.off:5:on:0:superAdj:0A: var Area.SquareMeter:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: A: var Area.SquareMeter >newOff:5,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"A":rec:-
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter "ObjectGenerator 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdrX:En: 2 pRec: "A " rec: "A " E: "print " 
 --  A.E: "A "
 --  
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- 
 -- $ObjectInvocation_Unary:getAdr: print >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- print::  \
 --    "SquareMeter".print:Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- print::  \
 --    "SquareMeter".print 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "A " rec: "A " E: "print " 
 --  rec.ATd: "A: var Area.SquareMeter " rec.ATD.OG.isValueObj: true 
 --  rec.ATd.origin: 
 --  %visible LIB.Dimensions
 --     F: var Float
 --     I: var Integer
 --     A: var Area.SquareMeter
 --  recA: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 --  pRecA: none 
 -- pRec: "A " rec: "A " E: "print " 
 --  false true 
 -- $ObjectInvocation_Unary:loadArgs: A >staticOff:0 A: var Area.SquareMeter superAdj:0
 -- $var:loadArgs: A: var Area.SquareMeter >E:"A"
 -- 
 -- $pattern:loadArgs:  \
 -- SquareMeter: Unit \
 --    %unit "m2", 1 \
 --    %Public
 -- ptn:loadArgs:E: "A " 
 -- args: " " 
 -- computeAdrX:before:rec:: "A " 
 -- $ObjectInvocation_Unary:invoke: A >rec:"A" ATd:"var" isValueObj E:"print" E.ATd:print unique:"False"
 -- OI:invoke: "A "
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:B: "A "E: "print " rec: "A " useRtnV: true "
 --  A: var Area.SquareMeter " 
 -- OI:invoke:before:ATdx.invoke: var A 
 -- $var:invoke: A: var Area.SquareMeter E: "print">newOff:5 useRTNv: "True"
 -- DI:invoke: "A: var Area.SquareMeter " 
 -- isValueObj:isAdr: true objSize: 2  rec "A ",E: "print ""
 --  ObjectInvocation_Unary "E.isCompositeValueObj: false 
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- Address:loadAdr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain "print " cmpAndSwap: false rec: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- OI:invoke:C: A :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "A " 
 -- checkInt2IntWithUnitArg:rec: "A "E: "print "
 -- computeAdrX:isLast:E:  "print "
 -- originIsValueObj: 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- rec = E: false 0 
 -- call:mkValueProxy false true 
 -- mkValueProxy:INV: "A.print " E: "print " rec: "A " E.ATd: 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- CreateProxyW:E: "print "E.ATd.origin.encOG:OGid "SquareMeter "
 --  origin:descNo: 68 "Area ""A.print " 
 --  rec.ATd: "A: var Area.SquareMeter "rec.ATd.newOff: 5 0 
 rdouble 0
 -- son: "A " 
 -- son: "print " 
 -- recOfE: "A "recOfE.ATd: "A: var Area.SquareMeter " 
 -- first: "Area "ObjectInvocation_Unary first.origin.encOG: "tinyB "
 -- $ObjectInvocation_Unary:loadOrigin: Area >on:0 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- IV:viaIncl:on: 0 "LIB.Dimensions " org: 
 --  %visible LIB.Dimensions
 --  F: var Float
 --  I: var Integer
 --  A: var Area.SquareMeter
 -- viaIncl:son:isFirst: true viaIncl<>none: false "LIB "
 -- items:goOrigin:encOG: "tinyB "on: 2 isValueObj: false 
 --  origin: workspace origin:isValueObj: false 
 rpushg tinyB$103 1
 -- items:goOrigin:encOG: "workspace "on: 1 isValueObj: false 
 --  origin: BETAworld origin:isValueObj: false 
 rpushg workspace$102 1
 rpushg LIB 3
 -- viaIncl:son:isFirst: false viaIncl<>none: false "Dimensions "
 rpushg Dimensions 4
 -- after:Ey.loadOrigin: 
 -- 
 -- $ObjectInvocation_Unary:getAdr: Area >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- --Area \
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $ModuleItem:getAdr:  \
 -- --Area \
 --  
 -- 
 -- $obj:getAdr:  \
 -- Area: obj Dimension \
 --    %dimension "A", "L*L" \
 --    %requires Length
 -- Adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rpushg EisNone 2
 -- after:A.loadAdr 
 mkValueProxy 68 4
 -- next: "SquareMeter "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 --  rec:  "A "E:  "print "
 -- INV:gen:E.loadArgs "print "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: print >staticOff:0  \
 -- print::  \
 --    "SquareMeter".print superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- print::  \
 --    "SquareMeter".print >E:"print":descNo:70
 -- ptn:loadArgs:E: "print " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "print "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print "
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- $ObjectInvocation_Unary:invoke: print >rec:"A" ATd:"pattern" E:"print" E.ATd:print unique:"False"
 -- OI:invoke: "print "
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- origin:isValueObj "SquareMeter "
 -- 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- OI:invoke:B: "print "E: "print " rec: "A " useRtnV: false 
 --  print:: 
 --     "SquareMeter".print
 --  
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- 
 -- $pattern:invoke:  \
 -- print::  \
 --    "SquareMeter".print E: "print" useRTNv: "False"
 -- ptn:invoke: "print "E: "print "ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 rec: "A " 
 --  
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- isDI 
 -- isStatic: true rec: "A "
 invoke print 70 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 2 rTop: -13 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- OI:invoke:X: adr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- OI:invoke:C: print :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 5 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 L2:
 -- pushReturn:  "tinyB "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:6 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 105 
 -- Items:GenClass: putint descNo: 105 isValue: false 
 -- Items:GenClass: putint descNo: 21 isValue: false 

 CLASS putint 105 0 BETA 2
 -- Store itemArgs: 
 --  %globals
 --  in V: var integer
 --  D: obj Indexed(20,#integer)
 --  L: var integer
 -- in V: var integer 1 
 -- DI:store: "V "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=105 vDescInx=105 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 -- $var:gen: in V: var integer 
 -- DI:gen: "in V: var integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: V 
 -- $obj:gen: D: obj Indexed(20,#integer) 
 -- DI:gen: "D: obj Indexed(20,#integer) " DI:isConst: true 
 --  isBasicValue: false primNo: 114 
 -- DI:isConst: D 
 -- DI:off: 2 this: "D: obj Indexed(20,#integer) " 
 --  
 -- $ObjectGenerator:gen: Indexed(20,#integer) >OGid:"D" IS.isempty! staticOff=2 descNo=0 superAdj=0
 -- OG:gen: "Indexed(20,#integer) " 
 -- OG:before:super.gen: "Indexed(20,#integer) "
 -- $Invocation:gen: Indexed(20,#integer) >useRtnV:"False"superAdj: 0 descNo: 106
 -- INV:gen: "Indexed(20,#integer) " 
 -- isConstant: "Invocation ""Indexed(20,#integer) "
 -- needorigin: "Indexed(20,#integer) " 
 -- needOrigin:E: "Indexed(20,#integer) "  E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicEx: "Indexed(20,#integer) " rec: "Indexed(20,#integer) " E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicE.ATd.desc: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var IntegerE.ATd.IT: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 -- after:needOrigin: "Indexed(20,#integer) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Indexed(20,#integer) "E:  "Indexed(20,#integer) "
 -- INV:gen:E.loadArgs "Indexed(20,#integer) "
 -- 
 -- $ObjectInvocation_Function:loadArgs: Indexed(20,#integer) >staticOff:0  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- 
 -- $pattern:loadArgs:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:loadArgs:E: "Indexed(20,#integer) " 
 -- args: "(20,#integer) " 
 -- E: "ObjectGenerator "20 
 -- E: "ObjectGenerator "#integer 
 -- E.arg: "var "in range: var Integer 
 -- NonVirt: "Indexed(20,#integer) " "ObjectInvocation_Function " 
 --  ActArg: "20 "isValue: true formalArg: "in range: var Integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(20,#integer) "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 20 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "20 " 
 -- OG:before:super.gen: "20 "
 -- $Invocation:gen: 20 >useRtnV:"True"superAdj: 0
 -- INV:gen: "20 " 
 -- isConstant: "Invocation ""20 "
 -- needorigin: "20 " 
 -- needOrigin:E: "20 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "20 " rec: "20 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "20 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "20 "E:  "20 "
 -- INV:gen:E.loadArgs "20 "
 -- $ConstLiteral:loadArgs: 20 
 -- INV:gen:after:E.loadArgs "20 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "20 "
 -- $ConstLiteral:invoke: 20 
 pushc 20
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in range: var Integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "20 ":isBasicVal: true 
 -- case:B: 20 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "Indexed(20,#integer) "
 -- INV:gen:after:E.loadArgs "Indexed(20,#integer) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "
 --  Indexed(20,#integer) "
 -- $ObjectInvocation_Function:invoke: Indexed(20,#integer) >rec:"Indexed(20,#integer)" ATd:"pattern" E:"Indexed(20,#integer)" E.ATd:Indexed unique:"False"
 -- OI:invoke: "Indexed(20,#integer) "
 -- 
 -- OI:invoke:B: "Indexed(20,#integer) "E: "Indexed(20,#integer) "
 --   rec: "Indexed(20,#integer) " useRtnV: false 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- 
 -- $pattern:invoke:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:invoke: "Indexed "E: "Indexed(20,#integer) "ptnKind: 0 
 --  useRtnV: false 
 pushThis 
 -- ObjTmpStack:add: "Indexed ": 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 pushc 1
 allocIndexed putint$105 106 1 0
 pushThis 
 rstoreg  putint$105 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: Indexed(20,#integer) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- $var:gen: L: var integer 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 -- $var:gen: isNeg: var Boolean 
 -- DI:gen: "isNeg: var Boolean " DI:isConst: false isBasicValue: 
 --  true primNo: 4 
 -- DI:gen:primitiveType: isNeg 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "isNeg := V < 0 " 
 -- $Assign:gen: isNeg := V < 0 
 -- AssignmentStatement:gen: "isNeg := V < 0 " 
 -- computeAdrG:superAdj: 0 "isNeg "
 -- computeAdrG: 1 :rec: "none " E: "isNeg "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: isNeg 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: isNeg >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: isNeg >ATd.off:4:on:0:superAdj:0isNeg: var Boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: isNeg: var Boolean >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isNeg":rec:-
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdrG:isLast:E:  "isNeg "
 -- AssignmentStatement:gen: 
 --  "isNeg := V < 0 " right.label: "ObjectGenerator ""V < 0 " 
 -- $ObjectGenerator:gen: V < 0 >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "V < 0 " 
 -- OG:before:super.gen: "V < 0 "
 -- $Invocation:gen: V < 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "V < 0 " 
 -- isConstant: "Invocation ""V < 0 "
 -- needorigin: "V < 0 " 
 -- needOrigin:E: "V < 0 "  E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "V < 0 " rec: "V < 0 " E.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 51
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "V < 0 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V < 0 " 
 -- doNeedOrigin:E: "V < 0 " 
 -- computeAdrX:superAdj: 0 "V < 0 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V < 0 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: V < 0 
 -- $BinOp:loadOrigin: V < 0 
 -- BinaryExp:loadOrigin:empty: "V < 0 "superAdj: 0 
 -- $BinOp:getAdr: V < 0 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "V < 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "V < 0 "E:  "V < 0 "
 -- INV:gen:E.loadArgs "V < 0 "
 -- $BinOp:loadArgs: V < 0 
 -- BinaryExp:loadArgs: "V < 0 " superAdj: 0 
 -- $Invocation:gen: V >useRtnV:"True"superAdj: 0
 -- INV:gen: "V " 
 -- isConstant: "Invocation ""V "
 -- notConst: V in V: var integer 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "in V: var integer " Ex: "V " rec: "
 --  V " E.ATd: "in V: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:1:on:0:superAdj:0in V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in V: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- $ObjectInvocation_Unary:loadArgs: V >staticOff:0 in V: var integer superAdj:0
 -- $var:loadArgs: in V: var integer >E:"V"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "V " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: V >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:V unique:"False"
 -- OI:invoke: "V "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V "E: "V " rec: "V " useRtnV: true "
 --  in V: var integer " 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: in V: var integer E: "V">newOff:1 useRTNv: "True"
 -- DI:invoke: "in V: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 -- isCompositeValueObj: false E: "V ""in V: var integer " true 
 -- E.ATd.isValueObj: false rec: "V "
 pushg 1 putint$105
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:C: V :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V < 0 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- $pattern:loadArgs:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var integer
 -- ptn:loadArgs:E: "< 0 " 
 -- args: "0 " 
 -- E: "ObjectGenerator "0 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "< 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< 0 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 0 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 " 
 -- OG:before:super.gen: "0 "
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "< 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V < 0 "
 --  OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V < 0 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: V < 0 
 -- BinaryExp:invoke: "V "rec: "V < 0 "
 -- M: "< 0 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: < 0 >rec:"V" ATd:"pattern" E:"< 0" E.ATd:<   unique:"False"
 -- OI:invoke: "< 0 "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "< 0 "E: "< 0 " rec: "V " useRtnV: true 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- 
 -- $pattern:invoke:  \
 -- <  :  \
 --    %basic 51 \
 --    in V: var integer
 -- ptn:invoke: "<   "E: "< 0 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V "E: "< 0 "
 -- arg:integer 
 lt
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< 0":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< 0":rec:V 
 -- OI:invoke:C: < 0 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "isNeg "dstE: "isNeg "dstE.ATd: "isNeg: var Boolean " 
 --  useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "V < 0 "
 -- isArgOfAssignI2IwithUniValArg "isNeg := V < 0 "arg: "V < 0 "
 --  ObjectGenerator 
 -- arg.super.arg: "V < 0 "BinOp 
 -- recx:BinaryExp:recx: "V < 0 "
 -- M: "< 0 "label: "ObjectInvocation_Binary "M.ATd: 
 --  <  : 
 --     %basic 51
 --     in V: var integer
 --     out B: var boolean
 --  
 -- checkInt2IntWithUnitArg:rec: "V "E: "< 0 "
 -- arg:integer 
 -- M:arg: "0 "ObjectGenerator false 
 -- dstDI: "isNeg: var Boolean " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$105 4
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (isNeg) :then  \
 --    V := 0 - V >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- OG:before:super.gen: "if (isNeg) :then 
 --     V := 0 - V "
 -- 
 -- $Invocation:gen:  \
 -- if (isNeg) :then  \
 --    V := 0 - V >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- isConstant: "Invocation ""if (isNeg) :then 
 --     V := 0 - V "
 -- needorigin: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- needOrigin:E: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  rec: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (isNeg) :then 
 --     V := 0 - V
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (isNeg) :then 
 --     V := 0 - V "E:  "
 --  if (isNeg) :then 
 --     V := 0 - V "
 -- INV:gen:E.loadArgs "if (isNeg) :then 
 --     V := 0 - V "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (isNeg) :then  \
 --    V := 0 - V 
 -- INV:gen:after:E.loadArgs "if (isNeg) :then 
 --     V := 0 - V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (isNeg) :then 
 --     V := 0 - V "
 -- 
 -- $IfThen:invoke:  \
 -- if (isNeg) :then  \
 --    V := 0 - V 
 -- 
 -- $IfThen:gen:  \
 -- if (isNeg) :then  \
 --    V := 0 - V 
 -- $ObjectGenerator:gen: (isNeg) >OGid:"Boolean" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(isNeg) " 
 -- OG:before:super.gen: "(isNeg) "
 -- $Invocation:gen: (isNeg) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(isNeg) " 
 -- isConstant: "Invocation ""(isNeg) "
 -- notConst: (isNeg) isNeg: var Boolean 
 -- needorigin: "(isNeg) " 
 -- needOrigin:E: "(isNeg) "  E.ATd: "isNeg: var Boolean " Ex: "
 --  (isNeg) " rec: "(isNeg) " E.ATd: "isNeg: var Boolean " E.ATd.desc: 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "(isNeg) " 
 -- doNeedOrigin:E: "(isNeg) " 
 -- computeAdrX:superAdj: 0 "(isNeg) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(isNeg) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (isNeg) 
 -- $BracketedExp:loadOrigin: (isNeg) 
 -- computeAdrG:superAdj: 0 "isNeg "
 -- computeAdrG: 1 :rec: "none " E: "isNeg "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: isNeg 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: isNeg >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: isNeg >ATd.off:4:on:0:superAdj:0isNeg: var Boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: isNeg: var Boolean >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isNeg":rec:-
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdrG:isLast:E:  "isNeg "
 -- BE:loadOrigin:E: isNeg 
 -- $ObjectInvocation_Unary:getAdr: isNeg >ATd.off:4:on:0:superAdj:0isNeg: var Boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: isNeg: var Boolean >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isNeg":rec:-
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdrX:isLast:E:  "isNeg "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 --  rec:  "isNeg "E:  "isNeg "
 -- INV:gen:E.loadArgs "isNeg "
 -- $ObjectInvocation_Unary:loadArgs: isNeg >staticOff:0 isNeg: var Boolean superAdj:0
 -- $var:loadArgs: isNeg: var Boolean >E:"isNeg"
 -- 
 -- $pattern:loadArgs:  \
 -- Boolean: value \
 --    %id "Boolean" \
 --    %globals inSub
 -- ptn:loadArgs:E: "isNeg " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "isNeg "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isNeg "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- $ObjectInvocation_Unary:invoke: isNeg >rec:"isNeg" ATd:"var" isValueObj E:"isNeg" E.ATd:isNeg unique:"False"
 -- OI:invoke: "isNeg "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:B: "isNeg "E: "isNeg " rec: "isNeg " useRtnV: true "
 --  isNeg: var Boolean " 
 -- OI:invoke:before:ATdx.invoke: var isNeg 
 -- $var:invoke: isNeg: var Boolean E: "isNeg">newOff:4 useRTNv: "True"
 -- DI:invoke: "isNeg: var Boolean " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg isNotRemote: true 
 -- isCompositeValueObj: false E: "isNeg ""isNeg: var Boolean " true 
 -- E.ATd.isValueObj: false rec: "isNeg "
 pushg 4 putint$105
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:C: isNeg :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: V := 0 - V >OGid:"$108" singular! staticOff=0 descNo=108 superAdj=0
 -- OG:gen: "V := 0 - V " 
 pushThis 
 -- before objTmpStack:add:  108   "$108 "
 invoke $108 108 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: 
 --  loop: do 
 --     L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 -- 
 -- $do:gen:  \
 -- loop: do  \
 --    L := L + 1 \
 --    D.put(V /% 10):at[L]
 -- 
 -- $ObjectGenerator:gen:  \
 -- L := L + 1 \
 --    D.put(V /% 10):at[L] \
 --    V := V // 10
 -- OG:gen: 
 --  L := L + 1
 --     D.put(V /% 10):at[L]
 --     V := V // 10
 --     if (V > 0) :then 
 pushThis 
 -- before objTmpStack:add:  116   "loop "
 invoke loop 116 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (isNeg) :then  \
 --    put('-') >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- OG:before:super.gen: "if (isNeg) :then 
 --     put('-') "
 -- 
 -- $Invocation:gen:  \
 -- if (isNeg) :then  \
 --    put('-') >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- isConstant: "Invocation ""if (isNeg) :then 
 --     put('-') "
 -- needorigin: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- needOrigin:E: 
 --  if (isNeg) :then 
 --     put('-')
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (isNeg) :then 
 --     put('-')
 --  rec: 
 --  if (isNeg) :then 
 --     put('-')
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (isNeg) :then 
 --     put('-')
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (isNeg) :then 
 --     put('-') "E:  "
 --  if (isNeg) :then 
 --     put('-') "
 -- INV:gen:E.loadArgs "if (isNeg) :then 
 --     put('-') "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (isNeg) :then  \
 --    put('-') 
 -- INV:gen:after:E.loadArgs "if (isNeg) :then 
 --     put('-') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (isNeg) :then 
 --     put('-') "
 -- 
 -- $IfThen:invoke:  \
 -- if (isNeg) :then  \
 --    put('-') 
 -- 
 -- $IfThen:gen:  \
 -- if (isNeg) :then  \
 --    put('-') 
 -- $ObjectGenerator:gen: (isNeg) >OGid:"Boolean" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(isNeg) " 
 -- OG:before:super.gen: "(isNeg) "
 -- $Invocation:gen: (isNeg) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(isNeg) " 
 -- isConstant: "Invocation ""(isNeg) "
 -- notConst: (isNeg) isNeg: var Boolean 
 -- needorigin: "(isNeg) " 
 -- needOrigin:E: "(isNeg) "  E.ATd: "isNeg: var Boolean " Ex: "
 --  (isNeg) " rec: "(isNeg) " E.ATd: "isNeg: var Boolean " E.ATd.desc: 
 --  %id "Boolean"
 --  %globals inSub
 --  %basic 4, 8
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "(isNeg) " 
 -- doNeedOrigin:E: "(isNeg) " 
 -- computeAdrX:superAdj: 0 "(isNeg) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(isNeg) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (isNeg) 
 -- $BracketedExp:loadOrigin: (isNeg) 
 -- computeAdrG:superAdj: 0 "isNeg "
 -- computeAdrG: 1 :rec: "none " E: "isNeg "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: isNeg 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: isNeg >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: isNeg >ATd.off:4:on:0:superAdj:0isNeg: var Boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: isNeg: var Boolean >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isNeg":rec:-
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdrG:isLast:E:  "isNeg "
 -- BE:loadOrigin:E: isNeg 
 -- $ObjectInvocation_Unary:getAdr: isNeg >ATd.off:4:on:0:superAdj:0isNeg: var Boolean:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: isNeg: var Boolean >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"isNeg":rec:-
 -- DI:OG: Boolean 
 -- before:floatTest:  "isNeg: var Boolean "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- computeAdrX:isLast:E:  "isNeg "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 --  rec:  "isNeg "E:  "isNeg "
 -- INV:gen:E.loadArgs "isNeg "
 -- $ObjectInvocation_Unary:loadArgs: isNeg >staticOff:0 isNeg: var Boolean superAdj:0
 -- $var:loadArgs: isNeg: var Boolean >E:"isNeg"
 -- 
 -- $pattern:loadArgs:  \
 -- Boolean: value \
 --    %id "Boolean" \
 --    %globals inSub
 -- ptn:loadArgs:E: "isNeg " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "isNeg "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "isNeg "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:- 
 -- $ObjectInvocation_Unary:invoke: isNeg >rec:"isNeg" ATd:"var" isValueObj E:"isNeg" E.ATd:isNeg unique:"False"
 -- OI:invoke: "isNeg "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:B: "isNeg "E: "isNeg " rec: "isNeg " useRtnV: true "
 --  isNeg: var Boolean " 
 -- OI:invoke:before:ATdx.invoke: var isNeg 
 -- $var:invoke: isNeg: var Boolean E: "isNeg">newOff:4 useRTNv: "True"
 -- DI:invoke: "isNeg: var Boolean " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg isNotRemote: true 
 -- isCompositeValueObj: false E: "isNeg ""isNeg: var Boolean " true 
 -- E.ATd.isValueObj: false rec: "isNeg "
 pushg 4 putint$105
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 -- OI:invoke:C: isNeg :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"isNeg":rec:isNeg 
 jmpFalse  L7
 L6:
 -- $ObjectGenerator:gen: put('-') >OGid:"$110" singular! staticOff=0 descNo=110 superAdj=0
 -- OG:gen: "put('-') " 
 pushThis 
 -- before objTmpStack:add:  110   "$110 "
 invoke $110 110 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -8 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- genclass:stmt: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- 
 -- $ObjectGenerator:gen:  \
 -- for(1):to(L):repeat \
 --    i: var integer \
 --    i := L + 1 - inx
 -- OG:gen: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 pushThis 
 -- before objTmpStack:add:  114   "for:to:repeat$114 "
 invoke for:to:repeat$114 114 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -9 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "putint "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 106 
 -- Items:GenClass: Indexed descNo: 106 isValue: false 
 -- Items:GenClass: Indexed descNo: 21 isValue: false 

 CLASS Indexed 106 0 BETA 2
 -- Store itemArgs: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- in range: var Integer 1 
 -- DI:store: "range "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=106 vDescInx=106 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 -- $Property:gen: %basic 114 
 -- $Property:gen: %public 
 -- $var:gen: in range: var Integer 
 -- DI:gen: "in range: var Integer " DI:isConst: false isBasicValue: 
 --  true primNo: 1 
 -- DI:gen:primitiveType: range 
 -- $pattern:gen: in elm:< Object 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "%basic 114 " 
 -- $Property:gen: %basic 114 
 -- genclass:stmt: "%public " 
 -- $Property:gen: %public 
 L2:
 -- pushReturn:  "Indexed "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 108 
 -- Items:GenClass: $108 descNo: 108 isValue: false 
 -- Items:GenClass: $108 descNo: 21 isValue: false 

 CLASS $108 108 1 putint 105
 -- Store itemArgs: "V := 0 - V " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=108 vDescInx=108 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "V := 0 - V " 
 -- $Assign:gen: V := 0 - V 
 -- AssignmentStatement:gen: "V := 0 - V " 
 -- computeAdrG:superAdj: 0 "V "
 -- computeAdrG: 1 :rec: "none " E: "V "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$108 "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg $108$108 1
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:1:on:1:superAdj:0in V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in V: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V " ATd: "in V: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrG:isLast:E:  "V "
 -- AssignmentStatement:gen: 
 --  "V := 0 - V " right.label: "ObjectGenerator ""0 - V " 
 -- $ObjectGenerator:gen: 0 - V >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 - V " 
 -- OG:before:super.gen: "0 - V "
 -- $Invocation:gen: 0 - V >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 - V " 
 -- isConstant: "Invocation ""0 - V "
 -- needorigin: "0 - V " 
 -- needOrigin:E: "0 - V "  E.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  Ex: "0 - V " rec: "0 - V " E.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "0 - V "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "0 - V " 
 -- doNeedOrigin:E: "0 - V " 
 -- computeAdrX:superAdj: 0 "0 - V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "0 - V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: 0 - V 
 -- $BinOp:loadOrigin: 0 - V 
 -- BinaryExp:loadOrigin:empty: "0 - V "superAdj: 0 
 -- $BinOp:getAdr: 0 - V 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "0 - V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "0 - V "E:  "0 - V "
 -- INV:gen:E.loadArgs "0 - V "
 -- $BinOp:loadArgs: 0 - V 
 -- BinaryExp:loadArgs: "0 - V " superAdj: 0 
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- left:#I "0 - V "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- 
 -- $pattern:loadArgs:  \
 -- -  :  \
 --    %basic 62 \
 --    in V: var integer
 -- ptn:loadArgs:E: "- V " 
 -- args: "V " 
 -- E: "ObjectGenerator "V 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "- V " "ObjectInvocation_Binary " ActArg: "V "isValue: 
 --  false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- V " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: V >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "V " 
 -- OG:before:super.gen: "V "
 -- $Invocation:gen: V >useRtnV:"True"superAdj: 0
 -- INV:gen: "V " 
 -- isConstant: "Invocation ""V "
 -- notConst: V in V: var integer 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "in V: var integer " Ex: "V " rec: "
 --  V " E.ATd: "in V: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "$108 "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg $108$108 1
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:1:on:1:superAdj:0in V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in V: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V " ATd: "in V: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- $ObjectInvocation_Unary:loadArgs: V >staticOff:0 in V: var integer superAdj:0
 -- $var:loadArgs: in V: var integer >E:"V"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "V " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: V >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:V unique:"False"
 -- OI:invoke: "V "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V "E: "V " rec: "V " useRtnV: true "
 --  in V: var integer " 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: in V: var integer E: "V">newOff:1 useRTNv: "True"
 -- DI:invoke: "in V: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 -- isCompositeValueObj: false E: "V ""in V: var integer " true 
 -- E.ATd.isValueObj: false rec: "V "
 pushg 1 putint$105
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:C: V :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "V ":isBasicVal: true 
 -- case:B: V ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "- V "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "0 - V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "0 - V "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: 0 - V 
 -- BinaryExp:invoke: "0 "rec: "0 - V "
 -- M: "- V "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: - V >rec:"0" ATd:"pattern" E:"- V" E.ATd:-   unique:"False"
 -- OI:invoke: "- V "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:0 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:0 
 -- OI:invoke:B: "- V "E: "- V " rec: "0 " useRtnV: true 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- 
 -- $pattern:invoke:  \
 -- -  :  \
 --    %basic 62 \
 --    in V: var integer
 -- ptn:invoke: "-   "E: "- V "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "0 "E: "- V "
 -- arg:other 
 minus
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- V":rec:0 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- V":rec:0 
 -- OI:invoke:C: - V :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "V "dstE: "V "dstE.ATd: "in V: var integer " useRtn: false 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "0 - V "
 -- isArgOfAssignI2IwithUniValArg "V := 0 - V "arg: "0 - V "
 --  ObjectGenerator 
 -- arg.super.arg: "0 - V "BinOp 
 -- recx:BinaryExp:recx: "0 - V "
 -- M: "- V "label: "ObjectInvocation_Binary "M.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "0 "E: "- V "
 -- arg:other 
 -- M:arg: "V "ObjectGenerator false 
 -- dstDI: "in V: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$105 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 116 
 -- Items:GenClass: loop descNo: 116 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 116 1 putint 105
 -- Store itemArgs: 
 --  L := L + 1
 --  D.put(V /% 10):at[L]
 --  V := V // 10
 --  if (V > 0) :then 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=116 vDescInx=116 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L + 1 " 
 -- $Assign:gen: L := L + 1 
 -- AssignmentStatement:gen: "L := L + 1 " 
 -- computeAdrG:superAdj: 0 "L "
 -- computeAdrG: 1 :rec: "none " E: "L "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:3:on:1:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrG:isLast:E:  "L "
 -- AssignmentStatement:gen: 
 --  "L := L + 1 " right.label: "ObjectGenerator ""L + 1 " 
 -- $ObjectGenerator:gen: L + 1 >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L + 1 " 
 -- OG:before:super.gen: "L + 1 "
 -- $Invocation:gen: L + 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "L + 1 " 
 -- isConstant: "Invocation ""L + 1 "
 -- needorigin: "L + 1 " 
 -- needOrigin:E: "L + 1 "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + 1 " rec: "L + 1 " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + 1 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + 1 " 
 -- doNeedOrigin:E: "L + 1 " 
 -- computeAdrX:superAdj: 0 "L + 1 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + 1 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L + 1 
 -- $BinOp:loadOrigin: L + 1 
 -- BinaryExp:loadOrigin:empty: "L + 1 "superAdj: 0 
 -- $BinOp:getAdr: L + 1 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L + 1 " ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L + 1 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + 1 "E:  "L + 1 "
 -- INV:gen:E.loadArgs "L + 1 "
 -- $BinOp:loadArgs: L + 1 
 -- BinaryExp:loadArgs: "L + 1 " superAdj: 0 
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 0
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:3:on:1:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:0
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:3 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 3 putint$105
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L + 1 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- $pattern:loadArgs:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:loadArgs:E: "+ 1 " 
 -- args: "1 " 
 -- E: "ObjectGenerator "1 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + 1 "
 --  OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: L + 1 
 -- BinaryExp:invoke: "L "rec: "L + 1 "
 -- M: "+ 1 "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: + 1 >rec:"L" ATd:"pattern" E:"+ 1" E.ATd:+   unique:"False"
 -- OI:invoke: "+ 1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ 1 "E: "+ 1 " rec: "L " useRtnV: true 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- 
 -- $pattern:invoke:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L "E: "+ 1 "
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:L 
 -- OI:invoke:C: + 1 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "L "dstE: "L "dstE.ATd: "L: var integer " useRtn: false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "L + 1 "
 -- isArgOfAssignI2IwithUniValArg "L := L + 1 "arg: "L + 1 "
 --  ObjectGenerator 
 -- arg.super.arg: "L + 1 "BinOp 
 -- recx:BinaryExp:recx: "L + 1 "
 -- M: "+ 1 "label: "ObjectInvocation_Binary "M.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "L "E: "+ 1 "
 -- arg:integer 
 -- M:arg: "1 "ObjectGenerator false 
 -- dstDI: "L: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$105 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "D.put(V /% 10):at[L] " 
 -- $ObjectGenerator:gen: D.put(V /% 10):at[L] >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "D.put(V /% 10):at[L] " 
 -- OG:before:super.gen: "D.put(V /% 10):at[L] "
 -- $Invocation:gen: D.put(V /% 10):at[L] >useRtnV:"False"superAdj: 0 descNo: 118
 -- INV:gen: "D.put(V /% 10):at[L] " 
 -- isConstant: "Invocation ""D.put(V /% 10):at[L] "
 -- needorigin: "D.put(V /% 10):at[L] " 
 -- needOrigin:E: "put(V /% 10):at[L] "  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(V /% 10):at[L] " rec: "D " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E.ATd.desc: "%basic 115 " E.ATd.IT: "%basic 115 " 
 -- doNeedOrigin:Ex: "put(V /% 10):at[L] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "put(V /% 10):at[L] " 
 -- doNeedOrigin:E: "put(V /% 10):at[L] " 
 -- computeAdrX:superAdj: 0 "D.put(V /% 10):at[L] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "D " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: D 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: D >on:1 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: D >ATd.off:2:on:1:superAdj:0D: obj Indexed(20,#integer):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $obj:getAdr: D: obj Indexed(20,#integer) >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"D":rec:-
 -- E.on: 1 
 -- beforeIsValueObj:E: "D " ATd: "D: obj Indexed(20,#integer) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "D " rec: "D " E: "put(V /% 10):at[L] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: put(V /% 10):at[L] >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "D " rec: "D " E: "
 --  put(V /% 10):at[L] " 
 --  rec.ATd: "D: obj Indexed(20,#integer) " rec.ATD.OG.isValueObj: 
 --  false 
 --  rec.ATd.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:- 
 --  pRecA: none 
 -- pRec: "D " rec: "D " E: "put(V /% 10):at[L] " 
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: D >staticOff:0 D: obj Indexed(20,#integer) superAdj:0
 -- $obj:loadArgs: D: obj Indexed(20,#integer) >E:"D"
 -- 
 -- $pattern:loadArgs:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:loadArgs:E: "D " 
 -- args: " " 
 -- computeAdrX:before:rec:: "D " 
 -- $ObjectInvocation_Unary:invoke: D >rec:"D" ATd:"obj" E:"put(V /% 10):at[L]" E.ATd:put(V: var integer):at[inx: var integer] unique:"False"
 -- OI:invoke: "D "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:B: "D "E: "put(V /% 10):at[L] " rec: "D " useRtnV: 
 --  true "D: obj Indexed(20,#integer) " 
 -- OI:invoke:before:ATdx.invoke: obj D 
 -- $obj:invoke: D: obj Indexed(20,#integer) E: "put(V /% 10):at[L]">newOff:2 useRTNv: "True"
 -- DI:invoke: "D: obj Indexed(20,#integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D isNotRemote: false 
 -- isCompositeValueObj: false E: "put(V /% 10):at[L] "
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  false 
 -- E.ATd.isValueObj: false rec: "D "
 rpushg loop$116 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:C: D :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "D " 
 -- checkInt2IntWithUnitArg:rec: "D "E: "put(V /% 10):at[L] "
 -- arg:other 
 -- computeAdrX:isLast:E:  "put(V /% 10):at[L] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 --  rec:  "D "E:  "put(V /% 10):at[L] "
 -- INV:gen:E.loadArgs "put(V /% 10):at[L] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put(V /% 10):at[L] >staticOff:0  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 superAdj:0arg:V /% 10arg:L
 -- 
 -- $pattern:loadArgs:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 >E:"put(V /% 10):at[L]":descNo:118
 -- ptn:loadArgs:E: "put(V /% 10):at[L] " 
 -- args: "put(V /% 10):at[L] " 
 -- E: "ObjectGenerator "V /% 10 
 -- E: "ObjectGenerator "L 
 -- E.arg: "var "V: var integer 
 -- NonVirt: "put(V /% 10):at[L] " "ObjectInvocation_KeyWord " 
 --  ActArg: "V /% 10 "isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(V /% 10):at[L] "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: V /% 10 >OGid:"/%" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "V /% 10 " 
 -- OG:before:super.gen: "V /% 10 "
 -- $Invocation:gen: V /% 10 >useRtnV:"True"superAdj: 0
 -- INV:gen: "V /% 10 " 
 -- isConstant: "Invocation ""V /% 10 "
 -- needorigin: "V /% 10 " 
 -- needOrigin:E: "V /% 10 "  E.ATd: 
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  Ex: "V /% 10 " rec: "V /% 10 " E.ATd: 
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 69
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 69
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "V /% 10 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V /% 10 " 
 -- doNeedOrigin:E: "V /% 10 " 
 -- computeAdrX:superAdj: 0 "V /% 10 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V /% 10 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: V /% 10 
 -- $BinOp:loadOrigin: V /% 10 
 -- BinaryExp:loadOrigin:empty: "V /% 10 "superAdj: 0 
 -- $BinOp:getAdr: V /% 10 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V /% 10 " ATd: 
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "V /% 10 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "V /% 10 "E:  "V /% 10 "
 -- INV:gen:E.loadArgs "V /% 10 "
 -- $BinOp:loadArgs: V /% 10 
 -- BinaryExp:loadArgs: "V /% 10 " superAdj: 0 
 -- $Invocation:gen: V >useRtnV:"True"superAdj: 0
 -- INV:gen: "V " 
 -- isConstant: "Invocation ""V "
 -- notConst: V in V: var integer 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "in V: var integer " Ex: "V " rec: "
 --  V " E.ATd: "in V: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:1:on:1:superAdj:0in V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in V: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V " ATd: "in V: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- $ObjectInvocation_Unary:loadArgs: V >staticOff:0 in V: var integer superAdj:0
 -- $var:loadArgs: in V: var integer >E:"V"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "V " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: V >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:V unique:"False"
 -- OI:invoke: "V "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V "E: "V " rec: "V " useRtnV: true "
 --  in V: var integer " 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: in V: var integer E: "V">newOff:1 useRTNv: "True"
 -- DI:invoke: "in V: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 -- isCompositeValueObj: false E: "V ""in V: var integer " true 
 -- E.ATd.isValueObj: false rec: "V "
 pushg 1 putint$105
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:C: V :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V /% 10 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- $pattern:loadArgs:  \
 -- /%  :  \
 --    %basic 69 \
 --    in V: var integer
 -- ptn:loadArgs:E: "/% 10 " 
 -- args: "10 " 
 -- E: "ObjectGenerator "10 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "/% 10 " "ObjectInvocation_Binary " ActArg: "10 "
 --  isValue: true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/% 10 " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: 10 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "10 " 
 -- OG:before:super.gen: "10 "
 -- $Invocation:gen: 10 >useRtnV:"True"superAdj: 0
 -- INV:gen: "10 " 
 -- isConstant: "Invocation ""10 "
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- $ConstLiteral:loadArgs: 10 
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 -- $ConstLiteral:invoke: 10 
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "10 ":isBasicVal: true 
 -- case:B: 10 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "/% 10 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V /% 10 "
 --  OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V /% 10 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: V /% 10 
 -- BinaryExp:invoke: "V "rec: "V /% 10 "
 -- M: "/% 10 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: /% 10 >rec:"V" ATd:"pattern" E:"/% 10" E.ATd:/%   unique:"False"
 -- OI:invoke: "/% 10 "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "/% 10 "E: "/% 10 " rec: "V " useRtnV: true 
 --  /%  : 
 --     %basic 69
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern /%   
 -- 
 -- $pattern:invoke:  \
 -- /%  :  \
 --    %basic 69 \
 --    in V: var integer
 -- ptn:invoke: "/%   "E: "/% 10 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V "E: "/% 10 "
 -- arg:integer 
 modd
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/% 10":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/% 10":rec:V 
 -- OI:invoke:C: /% 10 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "V /% 10 ":isBasicVal: true 
 -- case:B: V /% 10 ObjectGenerator 1 69 69 false false 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "put(V /% 10):at[L] "
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "put(V /% 10):at[L] " "ObjectInvocation_KeyWord " 
 --  ActArg: "L "isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(V /% 10):at[L] "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: L >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L " 
 -- OG:before:super.gen: "L "
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 0
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:3:on:1:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:0
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:3 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 3 putint$105
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(V /% 10):at[L] "
 -- INV:gen:after:E.loadArgs "put(V /% 10):at[L] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(V /% 10):at[L] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- $ObjectInvocation_KeyWord:invoke: put(V /% 10):at[L] >rec:"D" ATd:"pattern" E:"put(V /% 10):at[L]" E.ATd:put(V: var integer):at[inx: var integer] unique:"False"
 -- OI:invoke: "put(V /% 10):at[L] "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:B: "put(V /% 10):at[L] "E: "put(V /% 10):at[L] " rec: "
 --  D " useRtnV: false 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  put(V: var integer):at[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 E: "put(V /% 10):at[L]" useRTNv: "False"
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "
 --  put(V /% 10):at[L] "ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- OI:invoke:C: put(V /% 10):at[L] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(V /% 10):at[L]":rec:D 
 -- genclass:stmt: "V := V // 10 " 
 -- $Assign:gen: V := V // 10 
 -- AssignmentStatement:gen: "V := V // 10 " 
 -- computeAdrG:superAdj: 0 "V "
 -- computeAdrG: 1 :rec: "none " E: "V "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:1:on:1:superAdj:0in V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in V: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V " ATd: "in V: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrG:isLast:E:  "V "
 -- AssignmentStatement:gen: 
 --  "V := V // 10 " right.label: "ObjectGenerator ""V // 10 " 
 -- $ObjectGenerator:gen: V // 10 >OGid:"//" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "V // 10 " 
 -- OG:before:super.gen: "V // 10 "
 -- $Invocation:gen: V // 10 >useRtnV:"True"superAdj: 0
 -- INV:gen: "V // 10 " 
 -- isConstant: "Invocation ""V // 10 "
 -- needorigin: "V // 10 " 
 -- needOrigin:E: "V // 10 "  E.ATd: 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  Ex: "V // 10 " rec: "V // 10 " E.ATd: 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  E.ATd.desc: 
 --  %basic 68
 --  in V: var integer
 --  out B: var integer
 --  E.ATd.IT: 
 --  %basic 68
 --  in V: var integer
 --  out B: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "V // 10 "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "V // 10 " 
 -- doNeedOrigin:E: "V // 10 " 
 -- computeAdrX:superAdj: 0 "V // 10 " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V // 10 " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: V // 10 
 -- $BinOp:loadOrigin: V // 10 
 -- BinaryExp:loadOrigin:empty: "V // 10 "superAdj: 0 
 -- $BinOp:getAdr: V // 10 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V // 10 " ATd: 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "V // 10 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "V // 10 "E:  "V // 10 "
 -- INV:gen:E.loadArgs "V // 10 "
 -- $BinOp:loadArgs: V // 10 
 -- BinaryExp:loadArgs: "V // 10 " superAdj: 0 
 -- $Invocation:gen: V >useRtnV:"True"superAdj: 0
 -- INV:gen: "V " 
 -- isConstant: "Invocation ""V "
 -- notConst: V in V: var integer 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "in V: var integer " Ex: "V " rec: "
 --  V " E.ATd: "in V: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:1:on:1:superAdj:0in V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in V: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V " ATd: "in V: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- $ObjectInvocation_Unary:loadArgs: V >staticOff:0 in V: var integer superAdj:0
 -- $var:loadArgs: in V: var integer >E:"V"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "V " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: V >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:V unique:"False"
 -- OI:invoke: "V "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V "E: "V " rec: "V " useRtnV: true "
 --  in V: var integer " 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: in V: var integer E: "V">newOff:1 useRTNv: "True"
 -- DI:invoke: "in V: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 -- isCompositeValueObj: false E: "V ""in V: var integer " true 
 -- E.ATd.isValueObj: false rec: "V "
 pushg 1 putint$105
 -- stack: rpop : vTop: 1 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:C: V :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V // 10 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- $pattern:loadArgs:  \
 -- //  :  \
 --    %basic 68 \
 --    in V: var integer
 -- ptn:loadArgs:E: "// 10 " 
 -- args: "10 " 
 -- E: "ObjectGenerator "10 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "// 10 " "ObjectInvocation_Binary " ActArg: "10 "
 --  isValue: true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "// 10 " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: 10 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "10 " 
 -- OG:before:super.gen: "10 "
 -- $Invocation:gen: 10 >useRtnV:"True"superAdj: 0
 -- INV:gen: "10 " 
 -- isConstant: "Invocation ""10 "
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- $ConstLiteral:loadArgs: 10 
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 -- $ConstLiteral:invoke: 10 
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "10 ":isBasicVal: true 
 -- case:B: 10 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "// 10 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V // 10 "
 --  OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V // 10 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: V // 10 
 -- BinaryExp:invoke: "V "rec: "V // 10 "
 -- M: "// 10 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: // 10 >rec:"V" ATd:"pattern" E:"// 10" E.ATd://   unique:"False"
 -- OI:invoke: "// 10 "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "// 10 "E: "// 10 " rec: "V " useRtnV: true 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern //   
 -- 
 -- $pattern:invoke:  \
 -- //  :  \
 --    %basic 68 \
 --    in V: var integer
 -- ptn:invoke: "//   "E: "// 10 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V "E: "// 10 "
 -- arg:integer 
 idiv
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"// 10":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"// 10":rec:V 
 -- OI:invoke:C: // 10 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "V "dstE: "V "dstE.ATd: "in V: var integer " useRtn: false 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "V // 10 "
 -- isArgOfAssignI2IwithUniValArg "V := V // 10 "arg: "V // 10 "
 --  ObjectGenerator 
 -- arg.super.arg: "V // 10 "BinOp 
 -- recx:BinaryExp:recx: "V // 10 "
 -- M: "// 10 "label: "ObjectInvocation_Binary "M.ATd: 
 --  //  : 
 --     %basic 68
 --     in V: var integer
 --     out B: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "V "E: "// 10 "
 -- arg:integer 
 -- M:arg: "10 "ObjectGenerator false 
 -- dstDI: "in V: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg putint$105 1
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- if (V > 0) :then  \
 --    restart(loop) >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- OG:before:super.gen: "if (V > 0) :then 
 --     restart(loop) "
 -- 
 -- $Invocation:gen:  \
 -- if (V > 0) :then  \
 --    restart(loop) >useRtnV:"False"superAdj: 0
 -- INV:gen: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- isConstant: "Invocation ""if (V > 0) :then 
 --     restart(loop) "
 -- needorigin: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- needOrigin:E: 
 --  if (V > 0) :then 
 --     restart(loop)
 --   E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  Ex: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  rec: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  E.ATd: 
 --  if(cond: var boolean):then{thenPart:< object}: 
 --     %OSDvisibility skipInternal
 --     %basic 100
 -- \
 --      %globals inSub
 --  E.ATd.desc: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  E.ATd.IT: 
 --  %OSDvisibility skipInternal
 --  %basic 100
 --  %globals inSub
 --  
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %OSDvisibility skipInternal
 --     %basic 100
 --     %globals inSub
 --  
 -- after:needOrigin: 
 --  if (V > 0) :then 
 --     restart(loop)
 --  
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "if (V > 0) :then 
 --     restart(loop) "E:  "
 --  if (V > 0) :then 
 --     restart(loop) "
 -- INV:gen:E.loadArgs "if (V > 0) :then 
 --     restart(loop) "
 -- 
 -- $IfThen:loadArgs:  \
 -- if (V > 0) :then  \
 --    restart(loop) 
 -- INV:gen:after:E.loadArgs "if (V > 0) :then 
 --     restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "
 --  if (V > 0) :then 
 --     restart(loop) "
 -- 
 -- $IfThen:invoke:  \
 -- if (V > 0) :then  \
 --    restart(loop) 
 -- 
 -- $IfThen:gen:  \
 -- if (V > 0) :then  \
 --    restart(loop) 
 -- $ObjectGenerator:gen: (V > 0) >OGid:">" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "(V > 0) " 
 -- OG:before:super.gen: "(V > 0) "
 -- $Invocation:gen: (V > 0) >useRtnV:"True"superAdj: 0
 -- INV:gen: "(V > 0) " 
 -- isConstant: "Invocation ""(V > 0) "
 -- needorigin: "(V > 0) " 
 -- needOrigin:E: "(V > 0) "  E.ATd: 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  Ex: "(V > 0) " rec: "(V > 0) " E.ATd: 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  E.ATd.desc: 
 --  %basic 53
 --  in V: var integer
 --  out B: var boolean
 --  E.ATd.IT: 
 --  %basic 53
 --  in V: var integer
 --  out B: var boolean
 -- \
 --   
 -- doNeedOrigin:Ex: "(V > 0) "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "(V > 0) " 
 -- doNeedOrigin:E: "(V > 0) " 
 -- computeAdrX:superAdj: 0 "(V > 0) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "(V > 0) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: (V > 0) 
 -- $BracketedExp:loadOrigin: (V > 0) 
 -- computeAdrG:superAdj: 0 "V > 0 "
 -- computeAdrG: 1 :rec: "none " E: "V > 0 "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: V > 0 
 -- $BinOp:loadOrigin: V > 0 
 -- BinaryExp:loadOrigin:empty: "V > 0 "superAdj: 0 
 -- $BinOp:getAdr: V > 0 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V > 0 " ATd: 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- computeAdrG:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "V > 0 "
 -- BE:loadOrigin:E: V > 0 
 -- $BinOp:getAdr: V > 0 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V > 0 " ATd: 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "V > 0 "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "V > 0 "E:  "V > 0 "
 -- INV:gen:E.loadArgs "V > 0 "
 -- $BinOp:loadArgs: V > 0 
 -- BinaryExp:loadArgs: "V > 0 " superAdj: 0 
 -- $Invocation:gen: V >useRtnV:"True"superAdj: 0
 -- INV:gen: "V " 
 -- isConstant: "Invocation ""V "
 -- notConst: V in V: var integer 
 -- needorigin: "V " 
 -- needOrigin:E: "V "  E.ATd: "in V: var integer " Ex: "V " rec: "
 --  V " E.ATd: "in V: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "V " 
 -- doNeedOrigin:E: "V " 
 -- computeAdrX:superAdj: 0 "V " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "V " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop "on: 1 isValueObj: false 
 --  origin: putint origin:isValueObj: false 
 rpushg loop$116 1
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:1:on:1:superAdj:0in V: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: in V: var integer >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "in V: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V " ATd: "in V: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdrX:isLast:E:  "V "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 --  rec:  "V "E:  "V "
 -- INV:gen:E.loadArgs "V "
 -- $ObjectInvocation_Unary:loadArgs: V >staticOff:0 in V: var integer superAdj:0
 -- $var:loadArgs: in V: var integer >E:"V"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "V " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "V "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: V >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:V unique:"False"
 -- OI:invoke: "V "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V "E: "V " rec: "V " useRtnV: true "
 --  in V: var integer " 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: in V: var integer E: "V">newOff:1 useRTNv: "True"
 -- DI:invoke: "in V: var integer " 
 -- load: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V isNotRemote: true 
 -- isCompositeValueObj: false E: "V ""in V: var integer " true 
 -- E.ATd.isValueObj: false rec: "V "
 pushg 1 putint$105
 -- stack: rpop : vTop: 2 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:C: V :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- left:#I "V > 0 "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- $pattern:loadArgs:  \
 -- >  :  \
 --    %basic 53 \
 --    in V: var integer
 -- ptn:loadArgs:E: "> 0 " 
 -- args: "0 " 
 -- E: "ObjectGenerator "0 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "> 0 " "ObjectInvocation_Binary " ActArg: "0 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> 0 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 0 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "0 " 
 -- OG:before:super.gen: "0 "
 -- $Invocation:gen: 0 >useRtnV:"True"superAdj: 0
 -- INV:gen: "0 " 
 -- isConstant: "Invocation ""0 "
 -- needorigin: "0 " 
 -- needOrigin:E: "0 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "0 " rec: "0 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "0 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "0 "E:  "0 "
 -- INV:gen:E.loadArgs "0 "
 -- $ConstLiteral:loadArgs: 0 
 -- INV:gen:after:E.loadArgs "0 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0 "
 -- $ConstLiteral:invoke: 0 
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "0 ":isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "> 0 "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- INV:gen:after:E.loadArgs "V > 0 "
 --  OIadr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- IV:E.invoke:useRtnVal: true E: BinOp "V > 0 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $BinOp:invoke: V > 0 
 -- BinaryExp:invoke: "V "rec: "V > 0 "
 -- M: "> 0 "
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- $ObjectInvocation_Binary:invoke: > 0 >rec:"V" ATd:"pattern" E:"> 0" E.ATd:>   unique:"False"
 -- OI:invoke: "> 0 "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "> 0 "E: "> 0 " rec: "V " useRtnV: true 
 --  >  : 
 --     %basic 53
 --     in V: var integer
 --     out B: var boolean
 --  
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- 
 -- $pattern:invoke:  \
 -- >  :  \
 --    %basic 53 \
 --    in V: var integer
 -- ptn:invoke: ">   "E: "> 0 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "V "E: "> 0 "
 -- arg:integer 
 gt
 -- OI:invoke:V: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:V 
 -- OI:invoke:X: adr: 
 --  :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"> 0":rec:V 
 -- OI:invoke:C: > 0 :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: restart(loop) >OGid:"$121" singular! staticOff=0 descNo=121 superAdj=0
 -- OG:gen: "restart(loop) " 
 pushThis 
 -- before objTmpStack:add:  121   "$121 "
 invoke $121 121 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  "loop "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 121 
 -- Items:GenClass: $121 descNo: 121 isValue: false 
 -- Items:GenClass: $121 descNo: 21 isValue: false 

 CLASS $121 121 1 loop 116
 -- Store itemArgs: "restart(loop) " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=121 vDescInx=121 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "restart(loop) " 
 -- $ObjectGenerator:gen: restart(loop) >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "restart(loop) " 
 -- OG:before:super.gen: "restart(loop) "
 -- $Invocation:gen: restart(loop) >useRtnV:"False"superAdj: 0 descNo: 61
 -- INV:gen: "restart(loop) " 
 -- isConstant: "Invocation ""restart(loop) "
 -- needorigin: "restart(loop) " 
 -- needOrigin:E: "restart(loop) "  E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  Ex: "restart(loop) " rec: "restart(loop) " E.ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  E.ATd.desc: "%basic 102 " E.ATd.IT: "%basic 102 " 
 -- doNeedOrigin:Ex: "restart(loop) "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "restart(loop) " 
 -- doNeedOrigin:E: "restart(loop) " 
 -- computeAdrX:superAdj: 0 "restart(loop) " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "restart(loop) " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: restart(loop) 
 -- $ObjectInvocation_KeyWord:loadOrigin: restart(loop) >on:3 superAdj:0 isValueObj:"False"
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: restart(loop) >ATd.off:0 (isPtn):on:3:superAdj:0 \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "restart(loop) " ATd: 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdrX:isLast:E:  "restart(loop) "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 --  rec:  "restart(loop) "E:  "restart(loop) "
 -- INV:gen:E.loadArgs "restart(loop) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: restart(loop) >staticOff:0  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 superAdj:0arg:loop
 -- 
 -- $pattern:loadArgs:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 >E:"restart(loop)":descNo:61
 -- INV:gen:after:E.loadArgs "restart(loop) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  restart(loop) "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: restart(loop) >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:restart(V: var integer) unique:"False"
 -- OI:invoke: "restart(loop) "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop) "E: "restart(loop) " rec: "
 --  restart(loop) " useRtnV: false 
 --  restart(V: var integer):  -- odd parameter type!
 --     %basic 102
 --  
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- 
 -- $pattern:invoke:  \
 -- restart(V: var integer):  -- odd parameter type! \
 --    %basic 102 E: "restart(loop)" useRTNv: "False"
 -- ptn:invoke: "restart(V: var integer) "E: "restart(loop) "
 --  ptnKind: 0 useRtnV: false 
 break  1 1 116 0
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:C: restart(loop) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 110 
 -- Items:GenClass: $110 descNo: 110 isValue: false 
 -- Items:GenClass: $110 descNo: 21 isValue: false 

 CLASS $110 110 1 putint 105
 -- Store itemArgs: "put('-') " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=110 vDescInx=110 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "put('-') " 
 -- $ObjectGenerator:gen: put('-') >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "put('-') " 
 -- OG:before:super.gen: "put('-') "
 -- $Invocation:gen: put('-') >useRtnV:"False"superAdj: 0 descNo: 54
 -- INV:gen: "put('-') " 
 -- isConstant: "Invocation ""put('-') "
 -- needorigin: "put('-') " 
 -- needOrigin:E: "put('-') "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('-') " rec: "put('-') " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('-') " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('-') "E:  "put('-') "
 -- INV:gen:E.loadArgs "put('-') "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put('-') >staticOff:0  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- 
 -- $pattern:loadArgs:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:loadArgs:E: "put('-') " 
 -- args: "put('-') " 
 -- E: "ObjectGenerator "'-' 
 -- E.arg: "val "in ch: val char 
 -- NonVirt: "put('-') " "ObjectInvocation_KeyWord " ActArg: "'-' "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('-') " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: '-' >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "'-' " 
 -- OG:before:super.gen: "'-' "
 -- $Invocation:gen: '-' >useRtnV:"True"superAdj: 0
 -- INV:gen: "'-' " 
 -- isConstant: "Invocation ""'-' "
 -- needorigin: "'-' " 
 -- needOrigin:E: "'-' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "'-' " rec: "'-' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "'-' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'-' "E:  "'-' "
 -- INV:gen:E.loadArgs "'-' "
 -- $Char::loadArgs: '-' 
 -- INV:gen:after:E.loadArgs "'-' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'-' "
 -- $Char::invoke: '-' 
 pushc 45
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'-' ":isBasicVal: true 
 -- case:B: '-' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('-') "
 -- INV:gen:after:E.loadArgs "put('-') "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put('-') "
 -- $ObjectInvocation_KeyWord:invoke: put('-') >rec:"put('-')" ATd:"pattern" E:"put('-')" E.ATd:put unique:"False"
 -- OI:invoke: "put('-') "
 -- 
 -- OI:invoke:B: "put('-') "E: "put('-') " rec: "put('-') " useRtnV: 
 --  false 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- 
 -- $pattern:invoke:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:invoke: "put "E: "put('-') "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('-') :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 111 
 -- Items:GenClass: repeat$111 descNo: 111 isValue: false 
 -- Items:GenClass: repeat$111 descNo: 21 isValue: false 

 CLASS repeat$111 111 1 for:to:repeat$114 114
 -- Store itemArgs: 
 --  i: var integer
 --  i := L + 1 - inx
 --  put('0' + D.get[i])
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=111 vDescInx=111 vdtTop: 1 
 mvStack 
 -- $var:gen: i: var integer 
 -- DI:gen: "i: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: i 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "i := L + 1 - inx " 
 -- $Assign:gen: i := L + 1 - inx 
 -- AssignmentStatement:gen: "i := L + 1 - inx " 
 -- computeAdrG:superAdj: 0 "i "
 -- computeAdrG: 1 :rec: "none " E: "i "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: i 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: i >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: i >ATd.off:2:on:0:superAdj:0i: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: i: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"i":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdrG:isLast:E:  "i "
 -- AssignmentStatement:gen: 
 --  "i := L + 1 - inx " right.label: "ObjectGenerator ""
 --  L + 1 - inx " 
 -- $ObjectGenerator:gen: L + 1 - inx >OGid:"-" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L + 1 - inx " 
 -- OG:before:super.gen: "L + 1 - inx "
 -- $Invocation:gen: L + 1 - inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "L + 1 - inx " 
 -- isConstant: "Invocation ""L + 1 - inx "
 -- needorigin: "L + 1 - inx " 
 -- needOrigin:E: "L + 1 - inx "  E.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + 1 - inx " rec: "L + 1 - inx " E.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 62
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + 1 - inx "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + 1 - inx " 
 -- doNeedOrigin:E: "L + 1 - inx " 
 -- computeAdrX:superAdj: 0 "L + 1 - inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + 1 - inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L + 1 - inx 
 -- $BinOp:loadOrigin: L + 1 - inx 
 -- BinaryExp:loadOrigin:empty: "L + 1 - inx "superAdj: 0 
 -- $BinOp:getAdr: L + 1 - inx 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L + 1 - inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "L + 1 - inx "E:  "L + 1 - inx "
 -- INV:gen:E.loadArgs "L + 1 - inx "
 -- $BinOp:loadArgs: L + 1 - inx 
 -- BinaryExp:loadArgs: "L + 1 - inx " superAdj: 0 
 -- $BinOp:gen: L + 1 
 -- BinaryExp:gen: "L + 1 "
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 0
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$111 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$114 origin:isValueObj: false 
 rpushg repeat$111$111 1
 -- items:goOrigin:encOG: "for:to:repeat$114 "on: 1 isValueObj: 
 --  false 
 --  origin: putint origin:isValueObj: false 
 rpushg for:to:repeat$114$114 4
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:3:on:2:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:0
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:3 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 3 putint$105
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:gen:before:loadargs "L + 1 "
 -- A: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- $pattern:loadArgs:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:loadArgs:E: "+ 1 " 
 -- args: "1 " 
 -- E: "ObjectGenerator "1 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "+ 1 " "ObjectInvocation_Binary " ActArg: "1 "isValue: 
 --  true formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1 " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 0
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1 "
 -- $ObjectInvocation_Binary:invoke: + 1 >rec:"+ 1" ATd:"pattern" E:"+ 1" E.ATd:+   unique:"False"
 -- OI:invoke: "+ 1 "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:+ 1 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:+ 1 
 -- OI:invoke:B: "+ 1 "E: "+ 1 " rec: "+ 1 " useRtnV: true 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- 
 -- $pattern:invoke:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:invoke: "+   "E: "+ 1 "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "+ 1 "E: "+ 1 "
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 
 -- OI:invoke:C: + 1 :unit:  -none-   convFactor:  0.000000
 -- BinaryExp:gen:before:end "L + 1 "
 -- Madr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:+ 1 
 -- left:#I "L + 1 - inx "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- 
 -- $pattern:loadArgs:  \
 -- -  :  \
 --    %basic 62 \
 --    in V: var integer
 -- ptn:loadArgs:E: "- inx " 
 -- args: "inx " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "- inx " "ObjectInvocation_Binary " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- inx " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$111 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$114 origin:isValueObj: false 
 rpushg repeat$111$111 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$114$114
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "- inx "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "L + 1 - inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + 1 - inx "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: L + 1 - inx 
 -- BinaryExp:invoke: "L + 1 "rec: "L + 1 - inx "
 -- M: "- inx "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: - inx >rec:"L + 1" ATd:"pattern" E:"- inx" E.ATd:-   unique:"False"
 -- OI:invoke: "- inx "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:L + 1 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:L + 1 
 -- OI:invoke:B: "- inx "E: "- inx " rec: "L + 1 " useRtnV: true 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- 
 -- $pattern:invoke:  \
 -- -  :  \
 --    %basic 62 \
 --    in V: var integer
 -- ptn:invoke: "-   "E: "- inx "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L + 1 "E: "- inx "
 -- arg:other 
 minus
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- inx":rec:L + 1 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"- inx":rec:L + 1 
 -- OI:invoke:C: - inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "i "dstE: "i "dstE.ATd: "i: var integer " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "L + 1 - inx "
 -- isArgOfAssignI2IwithUniValArg "i := L + 1 - inx "arg: "
 --  L + 1 - inx "ObjectGenerator 
 -- arg.super.arg: "L + 1 - inx "BinOp 
 -- recx:BinaryExp:recx: "L + 1 - inx "
 -- M: "- inx "label: "ObjectInvocation_Binary "M.ATd: 
 --  -  : 
 --     %basic 62
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "L + 1 "E: "- inx "
 -- arg:other 
 -- M:arg: "inx "ObjectGenerator false 
 -- dstDI: "i: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg repeat$111$111 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "put('0' + D.get[i]) " 
 -- $ObjectGenerator:gen: put('0' + D.get[i]) >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "put('0' + D.get[i]) " 
 -- OG:before:super.gen: "put('0' + D.get[i]) "
 -- $Invocation:gen: put('0' + D.get[i]) >useRtnV:"False"superAdj: 0 descNo: 54
 -- INV:gen: "put('0' + D.get[i]) " 
 -- isConstant: "Invocation ""put('0' + D.get[i]) "
 -- needorigin: "put('0' + D.get[i]) " 
 -- needOrigin:E: "put('0' + D.get[i]) "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put('0' + D.get[i]) " rec: "put('0' + D.get[i]) " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put('0' + D.get[i]) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put('0' + D.get[i]) "E:  "put('0' + D.get[i]) "
 -- INV:gen:E.loadArgs "put('0' + D.get[i]) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put('0' + D.get[i]) >staticOff:0  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- 
 -- $pattern:loadArgs:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:loadArgs:E: "put('0' + D.get[i]) " 
 -- args: "put('0' + D.get[i]) " 
 -- E: "ObjectGenerator "'0' + D.get[i] 
 -- E.arg: "val "in ch: val char 
 -- NonVirt: "put('0' + D.get[i]) " "ObjectInvocation_KeyWord " 
 --  ActArg: "'0' + D.get[i] "isValue: false formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('0' + D.get[i]) "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: '0' + D.get[i] >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "'0' + D.get[i] " 
 -- OG:before:super.gen: "'0' + D.get[i] "
 -- $Invocation:gen: '0' + D.get[i] >useRtnV:"True"superAdj: 0
 -- INV:gen: "'0' + D.get[i] " 
 -- isConstant: "Invocation ""'0' + D.get[i] "
 -- needorigin: "'0' + D.get[i] " 
 -- needOrigin:E: "'0' + D.get[i] "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  Ex: "'0' + D.get[i] " rec: "'0' + D.get[i] " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var char
 --  out R: var char
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var char
 --  out R: var char
 -- \
 --   
 -- doNeedOrigin:Ex: "'0' + D.get[i] "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "'0' + D.get[i] " 
 -- doNeedOrigin:E: "'0' + D.get[i] " 
 -- computeAdrX:superAdj: 0 "'0' + D.get[i] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "'0' + D.get[i] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: '0' + D.get[i] 
 -- $BinOp:loadOrigin: '0' + D.get[i] 
 -- BinaryExp:loadOrigin:empty: "'0' + D.get[i] "superAdj: 0 
 -- $BinOp:getAdr: '0' + D.get[i] 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "'0' + D.get[i] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 --  rec:  "'0' + D.get[i] "E:  "'0' + D.get[i] "
 -- INV:gen:E.loadArgs "'0' + D.get[i] "
 -- $BinOp:loadArgs: '0' + D.get[i] 
 -- BinaryExp:loadArgs: "'0' + D.get[i] " superAdj: 0 
 -- $Invocation:gen: '0' >useRtnV:"True"superAdj: 0
 -- INV:gen: "'0' " 
 -- isConstant: "Invocation ""'0' "
 -- needorigin: "'0' " 
 -- needOrigin:E: "'0' "  E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16Ex: "'0' " rec: "'0' " E.ATd: 
 --  char: value
 --     %id "char"
 --     %globals
 --     %basic 3, 16E.ATd.desc: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %publicE.ATd.IT: 
 --  %id "char"
 --  %globals
 --  %basic 3, 16
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %id "char"
 --     %globals
 --     %basic 3, 16
 -- after:needOrigin: "'0' " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "'0' "E:  "'0' "
 -- INV:gen:E.loadArgs "'0' "
 -- $Char::loadArgs: '0' 
 -- INV:gen:after:E.loadArgs "'0' "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'0' "
 -- $Char::invoke: '0' 
 pushc 48
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- 
 -- $pattern:loadArgs:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var char
 -- ptn:loadArgs:E: "+ D.get[i] " 
 -- args: "D.get[i] " 
 -- E: "ObjectGenerator "D.get[i] 
 -- E.arg: "var "in V: var char 
 -- NonVirt: "+ D.get[i] " "ObjectInvocation_Binary " ActArg: "
 --  D.get[i] "isValue: false formalArg: "in V: var char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ D.get[i] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: D.get[i] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "D.get[i] " 
 -- OG:before:super.gen: "D.get[i] "
 -- $Invocation:gen: D.get[i] >useRtnV:"True"superAdj: 0 descNo: 112
 -- INV:gen: "D.get[i] " 
 -- isConstant: "Invocation ""D.get[i] "
 -- needorigin: "D.get[i] " 
 -- needOrigin:E: "get[i] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  Ex: "get[i] " rec: "D " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  E.ATd.desc: 
 --  %basic 116
 --  out V: var integer
 --  E.ATd.IT: 
 --  %basic 116
 --  out V: var integer
 --  
 -- doNeedOrigin:Ex: "get[i] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[i] " 
 -- doNeedOrigin:E: "get[i] " 
 -- computeAdrX:superAdj: 0 "D.get[i] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "D " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: D 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: D >on:2 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$111 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$114 origin:isValueObj: false 
 rpushg repeat$111$111 1
 -- items:goOrigin:encOG: "for:to:repeat$114 "on: 1 isValueObj: 
 --  false 
 --  origin: putint origin:isValueObj: false 
 rpushg for:to:repeat$114$114 4
 -- $ObjectInvocation_Unary:getAdr: D >ATd.off:2:on:2:superAdj:0D: obj Indexed(20,#integer):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $obj:getAdr: D: obj Indexed(20,#integer) >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"D":rec:-
 -- E.on: 2 
 -- beforeIsValueObj:E: "D " ATd: "D: obj Indexed(20,#integer) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "D " rec: "D " E: "get[i] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[i] >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 116 \
 --    out V: var integer:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 116 \
 --    out V: var integer 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "D " rec: "D " E: "get[i] " 
 --  rec.ATd: "D: obj Indexed(20,#integer) " rec.ATD.OG.isValueObj: 
 --  false 
 --  rec.ATd.origin: 
 --  %globals
 --     in V: var integer
 --     D: obj Indexed(20,#integer)
 --     L: var integer
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:- 
 --  pRecA: none 
 -- pRec: "D " rec: "D " E: "get[i] " 
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: D >staticOff:0 D: obj Indexed(20,#integer) superAdj:0
 -- $obj:loadArgs: D: obj Indexed(20,#integer) >E:"D"
 -- 
 -- $pattern:loadArgs:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:loadArgs:E: "D " 
 -- args: " " 
 -- computeAdrX:before:rec:: "D " 
 -- $ObjectInvocation_Unary:invoke: D >rec:"D" ATd:"obj" E:"get[i]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "D "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:B: "D "E: "get[i] " rec: "D " useRtnV: true "
 --  D: obj Indexed(20,#integer) " 
 -- OI:invoke:before:ATdx.invoke: obj D 
 -- $obj:invoke: D: obj Indexed(20,#integer) E: "get[i]">newOff:2 useRTNv: "True"
 -- DI:invoke: "D: obj Indexed(20,#integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D isNotRemote: false 
 -- isCompositeValueObj: false E: "get[i] "
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  false 
 -- E.ATd.isValueObj: false rec: "D "
 rpushg repeat$111$111 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:C: D :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "D " 
 -- checkInt2IntWithUnitArg:rec: "D "E: "get[i] "
 -- arg:other 
 -- computeAdrX:isLast:E:  "get[i] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 --  rec:  "D "E:  "get[i] "
 -- INV:gen:E.loadArgs "get[i] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[i] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 116 \
 --    out V: var integer superAdj:0arg:i
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 116 \
 --    out V: var integer >E:"get[i]":descNo:112
 -- ptn:loadArgs:E: "get[i] " 
 -- args: "get[i] " 
 -- E: "ObjectGenerator "i 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[i] " "ObjectInvocation_KeyWord " ActArg: "i "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[i] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: i >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "i " 
 -- OG:before:super.gen: "i "
 -- $Invocation:gen: i >useRtnV:"True"superAdj: 0
 -- INV:gen: "i " 
 -- isConstant: "Invocation ""i "
 -- notConst: i i: var integer 
 -- needorigin: "i " 
 -- needOrigin:E: "i "  E.ATd: "i: var integer " Ex: "i " rec: "i " 
 --  E.ATd: "i: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i " 
 -- doNeedOrigin:E: "i " 
 -- computeAdrX:superAdj: 0 "i " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: i 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: i >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: i >ATd.off:2:on:0:superAdj:0i: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: i: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"i":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- $ObjectInvocation_Unary:loadArgs: i >staticOff:0 i: var integer superAdj:0
 -- $var:loadArgs: i: var integer >E:"i"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "i " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- $ObjectInvocation_Unary:invoke: i >rec:"i" ATd:"var" isValueObj E:"i" E.ATd:i unique:"False"
 -- OI:invoke: "i "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "i "E: "i " rec: "i " useRtnV: true "
 --  i: var integer " 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- $var:invoke: i: var integer E: "i">newOff:2 useRTNv: "True"
 -- DI:invoke: "i: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 -- isCompositeValueObj: false E: "i ""i: var integer " true 
 -- E.ATd.isValueObj: false rec: "i "
 pushg 2 repeat$111$111
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:C: i :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[i] "
 -- INV:gen:after:E.loadArgs "get[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[i] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- $ObjectInvocation_KeyWord:invoke: get[i] >rec:"D" ATd:"pattern" E:"get[i]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[i] "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:B: "get[i] "E: "get[i] " rec: "D " useRtnV: true 
 --  get[inx: var integer]: 
 --     %basic 116
 --     out V: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 116 \
 --    out V: var integer E: "get[i]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[i] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 2 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- OI:invoke:C: get[i] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[i]":rec:D 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "D.get[i] ":isBasicVal: true 
 -- case:B: D.get[i] ObjectGenerator 3 116 116 false false 
 -- end:loadArgs:NonVirt: "+ D.get[i] "
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "'0' + D.get[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "'0' + D.get[i] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: '0' + D.get[i] 
 -- BinaryExp:invoke: "'0' "rec: "'0' + D.get[i] "
 -- M: "+ D.get[i] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: + D.get[i] >rec:"'0'" ATd:"pattern" E:"+ D.get[i]" E.ATd:+   unique:"False"
 -- OI:invoke: "+ D.get[i] "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:'0' 
 -- origin:isValueObj "char "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:'0' 
 -- OI:invoke:B: "+ D.get[i] "E: "+ D.get[i] " rec: "'0' " useRtnV: 
 --  true 
 --  +  : 
 --     %basic 61
 --     in V: var char
 --     out R: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- 
 -- $pattern:invoke:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var char
 -- ptn:invoke: "+   "E: "+ D.get[i] "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "'0' "E: "+ D.get[i] "
 -- arg:other 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ D.get[i]":rec:'0' 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ D.get[i]":rec:'0' 
 -- OI:invoke:C: + D.get[i] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "'0' + D.get[i] ":isBasicVal: true 
 -- case:B: '0' + D.get[i] ObjectGenerator 3 61 61 false false 
 -- end:loadArgs:NonVirt: "put('0' + D.get[i]) "
 -- INV:gen:after:E.loadArgs "put('0' + D.get[i]) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put('0' + D.get[i]) "
 -- $ObjectInvocation_KeyWord:invoke: put('0' + D.get[i]) >rec:"put('0' + D.get[i])" ATd:"pattern" E:"put('0' + D.get[i])" E.ATd:put unique:"False"
 -- OI:invoke: "put('0' + D.get[i]) "
 -- 
 -- OI:invoke:B: "put('0' + D.get[i]) "E: "put('0' + D.get[i]) "
 --   rec: "put('0' + D.get[i]) " useRtnV: false 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- 
 -- $pattern:invoke:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:invoke: "put "E: "put('0' + D.get[i]) "ptnKind: 0 useRtnV: 
 --  false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('0' + D.get[i]) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 114 
 -- Items:GenClass: for:to:repeat$114 descNo: 114 isValue: false 
 -- Items:GenClass: for:to:repeat$114 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$114 114 4 putint 105
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs: " " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "theIS: " " 
 -- super.sig:none:superAdj: 4 
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs:  \
 -- for(1):to(L):repeat \
 --    i: var integer \
 --    i := L + 1 - inx
 -- 
 -- $pattern:loadArgs:  \
 -- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
 --    %OSDvisibility skipInternal \
 --    %globals inSub
 -- ptn:loadArgs:E: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- args: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 -- E: "ObjectGenerator "1 
 -- E: "ObjectGenerator "L 
 -- E: "ObjectGenerator "
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i]) 
 -- E.arg: "var "first: var integer 
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 4
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- E.arg: "var "last: var integer 
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])"ObjectInvocation_KeyWord " ActArg: "L "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: L >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "L " 
 -- OG:before:super.gen: "L "
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 4
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 4 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:0 superAdj:4 isValueObj:"True"
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg putint$105 4
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:3:on:0:superAdj:4L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:4
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:3 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 3 putint$105
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- args:  "repeat:< object ""
 --  i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i]) "for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs: " " 
 -- last: var integer 1 
 -- DI:store: "last "
 pushThis 
 storeg integer$5 2
 -- first: var integer 1 
 -- DI:store: "first "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=114 vDescInx=28 vdtTop: 2 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- $Property:gen: %globals inSub 
 -- $var:gen: inx: var integer 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: " " E: "
 --  for(1):to(L):repeat
 --     i: var integer
 --     i := L + 1 - inx
 --     put('0' + D.get[i])
 --   "
 -- vdtAdd: inx=2 descInx=114 vDescInx=111 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 115 
 -- Items:GenClass: newline descNo: 115 isValue: false 
 -- Items:GenClass: newline descNo: 21 isValue: false 

 CLASS newline 115 0 BETA 2
 -- Store itemArgs: 
 --  %globals
 --  put(10)
 --  
 allocEventQ
 -- vdtAdd: inx=1 descInx=115 vDescInx=115 vdtTop: 1 
 mvStack 
 -- $Property:gen: %globals 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals " 
 -- $Property:gen: %globals 
 -- genclass:stmt: "put(10) " 
 -- $ObjectGenerator:gen: put(10) >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "put(10) " 
 -- OG:before:super.gen: "put(10) "
 -- $Invocation:gen: put(10) >useRtnV:"False"superAdj: 0 descNo: 54
 -- INV:gen: "put(10) " 
 -- isConstant: "Invocation ""put(10) "
 -- needorigin: "put(10) " 
 -- needOrigin:E: "put(10) "  E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  Ex: "put(10) " rec: "put(10) " E.ATd: 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  E.ATd.desc: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 --  E.ATd.IT: 
 --  %globals
 --  %basic 2
 --  in ch: val char
 -- \
 --   
 -- Ex:loadOrgin:no:loadOrigin:  
 --  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- after:needOrigin: "put(10) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "put(10) "E:  "put(10) "
 -- INV:gen:E.loadArgs "put(10) "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put(10) >staticOff:0  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- 
 -- $pattern:loadArgs:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:loadArgs:E: "put(10) " 
 -- args: "put(10) " 
 -- E: "ObjectGenerator "10 
 -- E.arg: "val "in ch: val char 
 -- NonVirt: "put(10) " "ObjectInvocation_KeyWord " ActArg: "10 "
 --  isValue: true formalArg: "in ch: val char " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(10) " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: 10 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "10 " 
 -- OG:before:super.gen: "10 "
 -- $Invocation:gen: 10 >useRtnV:"True"superAdj: 0
 -- INV:gen: "10 " 
 -- isConstant: "Invocation ""10 "
 -- needorigin: "10 " 
 -- needOrigin:E: "10 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "10 " rec: "10 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "10 " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "10 "E:  "10 "
 -- INV:gen:E.loadArgs "10 "
 -- $ConstLiteral:loadArgs: 10 
 -- INV:gen:after:E.loadArgs "10 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10 "
 -- $ConstLiteral:invoke: 10 
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in ch: val char "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "10 ":isBasicVal: true 
 -- case:B: 10 ObjectGenerator 3 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "put(10) "
 -- INV:gen:after:E.loadArgs "put(10) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(10) "
 -- $ObjectInvocation_KeyWord:invoke: put(10) >rec:"put(10)" ATd:"pattern" E:"put(10)" E.ATd:put unique:"False"
 -- OI:invoke: "put(10) "
 -- 
 -- OI:invoke:B: "put(10) "E: "put(10) " rec: "put(10) " useRtnV: 
 --  false 
 --  put:  -- to be eliminated
 --     %globals
 --     %basic 2
 --     in ch: val char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- 
 -- $pattern:invoke:  \
 -- put:  -- to be eliminated \
 --    %globals \
 --    %basic 2
 -- ptn:invoke: "put "E: "put(10) "ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(10) :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 L2:
 -- pushReturn:  "newline "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 122 
 -- Items:GenClass: + descNo: 122 isValue: false 
 -- Items:GenClass: + descNo: 21 isValue: false 

 CLASS + 122 1 String 10
 -- Store itemArgs: 
 --  in S: var String
 --  out V: var String
 --  L: var integer
 --  L := Length
 -- in S: var String 5 
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=122 vDescInx=122 vdtTop: 1 
 mvStack 
 -- $var:gen: in S: var String 
 -- DI:gen: "in S: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- $var:gen: out V: var String 
 -- DI:gen: "out V: var String " DI:isConst: false isBasicValue: 
 --  false primNo: 5 
 -- DI:StringVar "out V: var String "
 pushText ""
 pushThis 
 rstoreg  V 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- $var:gen: L: var integer 
 -- DI:gen: "L: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := Length " 
 -- $Assign:gen: L := Length 
 -- AssignmentStatement:gen: "L := Length " 
 -- computeAdrG:superAdj: 0 "L "
 -- computeAdrG: 1 :rec: "none " E: "L "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:0 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:4:on:0:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --     doplus: do 
 --        e: var integer
 --        i: var integer
 --        T: obj Indexed(L + S.length,Integer)
 --        for(1):to(L):repeat
 --           e := get[inx]
 --           T.put(e):at[inx]
 --        
 --        for(1):to(S.length):repeat
 --           e := S.get[inx]
 --           i := L + inx
 --           T.put(e):at[i]
 --        
 -- \
 --         V := T.asString
 --        -- V: obj Indexed(Length + S.length)
 --        -- V := T[1:length] + S.T[1:S.length] 
 -- $var:getAdr: L: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdrG:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrG:isLast:E:  "L "
 -- AssignmentStatement:gen: 
 --  "L := Length " right.label: "ObjectGenerator ""Length " 
 -- $ObjectGenerator:gen: Length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "Length " 
 -- OG:before:super.gen: "Length "
 -- $Invocation:gen: Length >useRtnV:"True"superAdj: 0 descNo: 15
 -- INV:gen: "Length " 
 -- isConstant: "Invocation ""Length "
 -- needorigin: "Length " 
 -- needOrigin:E: "Length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "Length " rec: "Length " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "Length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "Length " 
 -- doNeedOrigin:E: "Length " 
 -- computeAdrX:superAdj: 0 "Length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "Length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: Length 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: Length >on:1 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$122 1
 -- 
 -- $ObjectInvocation_Unary:getAdr: Length >ATd.off:0 (isPtn):on:1:superAdj:0 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --     doplus: do 
 --        e: var integer
 --        i: var integer
 --        T: obj Indexed(L + S.length,Integer)
 --        for(1):to(L):repeat
 --           e := get[inx]
 --           T.put(e):at[inx]
 --        
 --        for(1):to(S.length):repeat
 --           e := S.get[inx]
 --           i := L + inx
 --           T.put(e):at[i]
 --        
 -- \
 --         V := T.asString
 --        -- V: obj Indexed(Length + S.length)
 --        -- V := T[1:length] + S.T[1:S.length] 
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Length " ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- computeAdrX:isLast:E:  "Length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 --  rec:  "Length "E:  "Length "
 -- INV:gen:E.loadArgs "Length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: Length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"Length":descNo:15
 -- ptn:loadArgs:E: "Length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "Length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Length "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- $ObjectInvocation_Unary:invoke: Length >rec:"Length" ATd:"pattern" E:"Length" E.ATd:length unique:"False"
 -- OI:invoke: "Length "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:B: "Length "E: "Length " rec: "Length " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "Length" useRTNv: "True"
 -- ptn:invoke: "length "E: "Length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "Length " 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:C: Length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- rec: "L "dstE: "L "dstE.ATd: "L: var integer " useRtn: false 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "Length "
 -- isArgOfAssignI2IwithUniValArg "L := Length "arg: "Length "
 --  ObjectGenerator 
 -- arg.super.arg: "Length "ObjectInvocation_Unary 
 -- dstDI: "L: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg +$122 4
 -- assign:adr.store:B: 
 -- genclass:stmt: 
 --  doplus: do 
 --     e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 -- 
 -- $do:gen:  \
 -- doplus: do  \
 --    e: var integer \
 --    i: var integer
 -- 
 -- $ObjectGenerator:gen:  \
 -- e: var integer \
 --    i: var integer \
 --    T: obj Indexed(L + S.length,Integer)
 -- OG:gen: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 pushThis 
 -- before objTmpStack:add:  123   "doplus "
 invoke doplus 123 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "+ "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 123 
 -- Items:GenClass: doplus descNo: 123 isValue: false 
 -- Items:GenClass: doplus descNo: 21 isValue: false 

 CLASS doplus 123 1 + 122
 -- Store itemArgs: 
 --  e: var integer
 --  i: var integer
 --  T: obj Indexed(L + S.length,Integer)
 --  for(1):to(L):repeat
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=123 vDescInx=123 vdtTop: 1 
 mvStack 
 -- $var:gen: e: var integer 
 -- DI:gen: "e: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: e 
 -- $var:gen: i: var integer 
 -- DI:gen: "i: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: i 
 -- $obj:gen: T: obj Indexed(L + S.length,Integer) 
 -- DI:gen: "T: obj Indexed(L + S.length,Integer) " DI:isConst: true 
 --  isBasicValue: false primNo: 114 
 -- DI:isConst: T 
 -- DI:off: 4 this: "T: obj Indexed(L + S.length,Integer) " 
 --  
 -- $ObjectGenerator:gen: Indexed(L + S.length,Integer) >OGid:"T" IS.isempty! staticOff=4 descNo=0 superAdj=0
 -- OG:gen: "Indexed(L + S.length,Integer) " 
 -- OG:before:super.gen: "Indexed(L + S.length,Integer) "
 -- $Invocation:gen: Indexed(L + S.length,Integer) >useRtnV:"False"superAdj: 0 descNo: 106
 -- INV:gen: "Indexed(L + S.length,Integer) " 
 -- isConstant: "Invocation ""Indexed(L + S.length,Integer) "
 -- needorigin: "Indexed(L + S.length,Integer) " 
 -- needOrigin:E: "Indexed(L + S.length,Integer) "  E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicEx: "Indexed(L + S.length,Integer) " rec: "
 --  Indexed(L + S.length,Integer) " E.ATd: 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %publicE.ATd.desc: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var IntegerE.ATd.IT: 
 --  %globals
 --  %basic 114
 --  %public
 --  in range: var Integer
 -- Ex:loadOrgin:no:loadOrigin:  
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 -- after:needOrigin: "Indexed(L + S.length,Integer) " 
 -- IV:after:computeAdr:superAdj: 0 
 --  rec:  "Indexed(L + S.length,Integer) "E:  "
 --  Indexed(L + S.length,Integer) "
 -- INV:gen:E.loadArgs "Indexed(L + S.length,Integer) "
 -- 
 -- $ObjectInvocation_Function:loadArgs: Indexed(L + S.length,Integer) >staticOff:0  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- 
 -- $pattern:loadArgs:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:loadArgs:E: "Indexed(L + S.length,Integer) " 
 -- args: "(L + S.length,Integer) " 
 -- E: "ObjectGenerator "L + S.length 
 -- E: "ObjectGenerator "Integer 
 -- E.arg: "var "in range: var Integer 
 -- NonVirt: "Indexed(L + S.length,Integer) " "
 --  ObjectInvocation_Function " ActArg: "L + S.length "isValue: false formalArg: "
 --  in range: var Integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer) "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: L + S.length >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L + S.length " 
 -- OG:before:super.gen: "L + S.length "
 -- $Invocation:gen: L + S.length >useRtnV:"True"superAdj: 0
 -- INV:gen: "L + S.length " 
 -- isConstant: "Invocation ""L + S.length "
 -- needorigin: "L + S.length " 
 -- needOrigin:E: "L + S.length "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + S.length " rec: "L + S.length " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + S.length "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + S.length " 
 -- doNeedOrigin:E: "L + S.length " 
 -- computeAdrX:superAdj: 0 "L + S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + S.length " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L + S.length 
 -- $BinOp:loadOrigin: L + S.length 
 -- BinaryExp:loadOrigin:empty: "L + S.length "superAdj: 0 
 -- $BinOp:getAdr: L + S.length 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L + S.length " ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L + S.length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + S.length "E:  "L + S.length "
 -- INV:gen:E.loadArgs "L + S.length "
 -- $BinOp:loadArgs: L + S.length 
 -- BinaryExp:loadArgs: "L + S.length " superAdj: 0 
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 0
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:4:on:1:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:0
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:4 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 4 +$122
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L + S.length "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- $pattern:loadArgs:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:loadArgs:E: "+ S.length " 
 -- args: "S.length " 
 -- E: "ObjectGenerator "S.length 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "+ S.length " "ObjectInvocation_Binary " ActArg: "
 --  S.length "isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ S.length " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: S.length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "S.length " 
 -- OG:before:super.gen: "S.length "
 -- $Invocation:gen: S.length >useRtnV:"True"superAdj: 0 descNo: 15
 -- INV:gen: "S.length " 
 -- isConstant: "Invocation ""S.length "
 -- notConst: S in S: var String 
 -- needorigin: "S.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "S " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 0 "S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: S 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: S >on:1 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- $ObjectInvocation_Unary:getAdr: S >ATd.off:2:on:1:superAdj:0in S: var String:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --        e := get[inx]
 --        T.put(e):at[inx]
 --     
 --     for(1):to(S.length):repeat
 --        e := S.get[inx]
 --        i := L + inx
 --        T.put(e):at[i]
 --     
 --     V := T.asString
 --     -- V: obj Indexed(Length + S.length)
 --     -- V := T[1:length] + S.T[1:S.length] 
 -- BOBS:ATd: "in S: var String "
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: in S: var String >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:-
 -- E.on: 1 
 -- beforeIsValueObj:E: "S " ATd: "in S: var String " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_Unary:getAdr: length >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "length " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "length " 
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: S >staticOff:0 in S: var String superAdj:0
 -- $var:loadArgs: in S: var String >E:"S"
 -- 
 -- $pattern:loadArgs:  \
 -- String: Value \
 --    %id "String pattern" \
 --    %OSDvisibility disguised
 -- ptn:loadArgs:E: "S " 
 -- args: " " 
 -- computeAdrX:before:rec:: "S " 
 -- $ObjectInvocation_Unary:invoke: S >rec:"S" ATd:"var" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "S "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "S "E: "length " rec: "S " useRtnV: true "
 --  in S: var String " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: in S: var String E: "length">newOff:2 useRTNv: "True"
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$123 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: S :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "S " 
 -- checkInt2IntWithUnitArg:rec: "S "E: "length "
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:0
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length":descNo:15
 -- ptn:loadArgs:E: "length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- $ObjectInvocation_Unary:invoke: length >rec:"S" ATd:"pattern" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "length "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "length "E: "length " rec: "S " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length" useRTNv: "True"
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "+ S.length "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + S.length "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + S.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: L + S.length 
 -- BinaryExp:invoke: "L "rec: "L + S.length "
 -- M: "+ S.length "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: + S.length >rec:"L" ATd:"pattern" E:"+ S.length" E.ATd:+   unique:"False"
 -- OI:invoke: "+ S.length "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ S.length "E: "+ S.length " rec: "L " useRtnV: 
 --  true 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- 
 -- $pattern:invoke:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:invoke: "+   "E: "+ S.length "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L "E: "+ S.length "
 -- arg:other 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- OI:invoke:C: + S.length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "in range: var Integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L + S.length ":isBasicVal: true 
 -- case:B: L + S.length ObjectGenerator 1 61 61 false false 
 -- end:loadArgs:NonVirt: "Indexed(L + S.length,Integer) "
 -- INV:gen:after:E.loadArgs "Indexed(L + S.length,Integer) "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "
 --  Indexed(L + S.length,Integer) "
 -- $ObjectInvocation_Function:invoke: Indexed(L + S.length,Integer) >rec:"Indexed(L + S.length,Integer)" ATd:"pattern" E:"Indexed(L + S.length,Integer)" E.ATd:Indexed unique:"False"
 -- OI:invoke: "Indexed(L + S.length,Integer) "
 -- 
 -- OI:invoke:B: "Indexed(L + S.length,Integer) "E: "
 --  Indexed(L + S.length,Integer) " rec: "Indexed(L + S.length,Integer) " useRtnV: false 
 --  Indexed: 
 --     %globals
 --     %basic 114
 --     %public
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- 
 -- $pattern:invoke:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:invoke: "Indexed "E: "Indexed(L + S.length,Integer) "
 --  ptnKind: 0 useRtnV: false 
 pushThis 
 -- ObjTmpStack:add: "Indexed ": 
 --  %globals
 --     %basic 114
 --     %public
 --     in range: var Integer
 pushc 1
 allocIndexed doplus$123 106 1 0
 pushThis 
 rstoreg  doplus$123 4
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: Indexed(L + S.length,Integer) :unit:  -none-  
 --   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- for(1):to(L):repeat \
 --    e := get[inx] \
 --    T.put(e):at[inx]
 -- OG:gen: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 pushThis 
 -- before objTmpStack:add:  125   "for:to:repeat$125 "
 invoke for:to:repeat$125 125 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- 
 -- $ObjectGenerator:gen:  \
 -- for(1):to(S.length):repeat \
 --    e := S.get[inx] \
 --    i := L + inx
 -- OG:gen: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 pushThis 
 -- before objTmpStack:add:  127   "for:to:repeat$127 "
 invoke for:to:repeat$127 127 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- 
 -- $Assign:gen:  \
 -- V := T.asString \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length] 
 -- AssignmentStatement:gen: 
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrG:superAdj: 0 "V "
 -- computeAdrG: 1 :rec: "none " E: "V "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: V 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: V >on:1 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- $ObjectInvocation_Unary:getAdr: V >ATd.off:3:on:1:superAdj:0out V: var String:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --        e := get[inx]
 --        T.put(e):at[inx]
 --     
 --     for(1):to(S.length):repeat
 --        e := S.get[inx]
 --        i := L + inx
 --        T.put(e):at[i]
 --     
 --     V := T.asString
 --     -- V: obj Indexed(Length + S.length)
 --     -- V := T[1:length] + S.T[1:S.length] 
 -- BOBS:ATd: "out V: var String "
 -- $var:getAdr: out V: var String >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"V":rec:-
 -- E.on: 1 
 -- beforeIsValueObj:E: "V " ATd: "out V: var String " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrG:isLast:E:  "V "
 -- AssignmentStatement:gen: 
 --  
 --  V := T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  right.label: "ObjectGenerator "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- 
 -- $ObjectGenerator:gen:  \
 -- T.asString \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length] >OGid:"asString" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- OG:before:super.gen: "
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- 
 -- $Invocation:gen:  \
 -- T.asString \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length] >useRtnV:"True"superAdj: 0 descNo: 128
 -- INV:gen: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- isConstant: "Invocation ""
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- needorigin: 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- needOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --   E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  Ex: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  rec: "T " E.ATd: 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  E.ATd.desc: 
 --  %basic 118
 -- \
 --   out S: var LIB.StringLib.String
 --  E.ATd.IT: 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- doNeedOrigin:Ex: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "originIsValueObj: false origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- doNeedOrigin:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:superAdj: 0 
 --  T.asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: T 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: T >on:0 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: T >ATd.off:4:on:0:superAdj:0T: obj Indexed(L + S.length,Integer):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $obj:getAdr: T: obj Indexed(L + S.length,Integer) >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"T":rec:-
 -- E.on: 0 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_Unary:getAdr:  \
 -- asString \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length] >ATd.off:0 (isPtn):on:0:superAdj:0
 -- PING:String 0 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --        e := get[inx]
 --        T.put(e):at[inx]
 --     
 --     for(1):to(S.length):repeat
 --        e := S.get[inx]
 --        i := L + inx
 --        T.put(e):at[i]
 --     
 --     V := T.asString
 --     -- V: obj Indexed(Length + S.length)
 --     -- V := T[1:length] + S.T[1:S.length] 
 -- BOBS:ATd: "
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String "
 -- 
 -- $pattern:getAdr:  \
 -- asString:  \
 --    %basic 118 \
 --    out S: var LIB.StringLib.String 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: T >staticOff:0 T: obj Indexed(L + S.length,Integer) superAdj:0
 -- $obj:loadArgs: T: obj Indexed(L + S.length,Integer) >E:"T"
 -- 
 -- $pattern:loadArgs:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:loadArgs:E: "T " 
 -- args: " " 
 -- computeAdrX:before:rec:: "T " 
 -- 
 -- $ObjectInvocation_Unary:invoke: T >rec:"T" ATd:"obj" E:"asString" \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length]" E.ATd:asString unique:"False"
 -- OI:invoke: "T "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:B: "T "E: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] " rec: "T " useRtnV: true "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- 
 -- $obj:invoke: T: obj Indexed(L + S.length,Integer) E: "asString" \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length]">newOff:4 useRTNv: "True"
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T isNotRemote: false 
 -- isCompositeValueObj: false E: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  false 
 -- E.ATd.isValueObj: false rec: "T "
 rpushg doplus$123 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:C: T :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "T " 
 -- checkInt2IntWithUnitArg:rec: "T "E: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- computeAdrX:isLast:E:  "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 --  rec:  "T "E:  "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- INV:gen:E.loadArgs "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- 
 -- $ObjectInvocation_Unary:loadArgs:  \
 -- asString \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length] >staticOff:0 
 -- 
 -- $pattern:loadArgs:  \
 -- asString:  \
 --    %basic 118 \
 --    out S: var LIB.StringLib.String >E:"asString"
 -- ptn:loadArgs:E: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- args: 
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]
 --  
 -- INV:gen:after:E.loadArgs "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- 
 -- $ObjectInvocation_Unary:invoke:  \
 -- asString \
 -- -- V: obj Indexed(Length + S.length) \
 -- -- V := T[1:length] + S.T[1:S.length] >rec:"T" ATd:"pattern" E:"asString"
 -- OI:invoke: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:B: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "E: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] " rec: "T " useRtnV: true 
 --  asString: 
 --     %basic 118
 --     out S: var LIB.StringLib.String
 --  
 -- OI:invoke:before:ATdx.invoke: pattern asString 
 -- 
 -- $pattern:invoke:  \
 -- asString:  \
 --    %basic 118 \
 --    out S: var LIB.StringLib.String E: "asString"
 -- ptn:invoke: "asString "E: "
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] "ptnKind: 0 useRtnV: true 
 %asString 118
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- OI:invoke:C: 
 --  asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString
 --  -- V: obj Indexed(Length + S.length)
 --  -- V := T[1:length] + S.T[1:S.length]":rec:T 
 -- rec: "V "dstE: "V "dstE.ATd: "out V: var String " useRtn: false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -8 rTopMax: 0 V: 0 R: 
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "doplus "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 124 
 -- Items:GenClass: repeat$124 descNo: 124 isValue: false 
 -- Items:GenClass: repeat$124 descNo: 21 isValue: false 

 CLASS repeat$124 124 1 for:to:repeat$125 125
 -- Store itemArgs: 
 --  e := get[inx]
 --  T.put(e):at[inx]
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=124 vDescInx=124 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "e := get[inx] " 
 -- $Assign:gen: e := get[inx] 
 -- AssignmentStatement:gen: "e := get[inx] " 
 -- computeAdrG:superAdj: 0 "e "
 -- computeAdrG: 1 :rec: "none " E: "e "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: e 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: e >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$124 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$125 origin:isValueObj: false 
 rpushg repeat$124$124 1
 -- items:goOrigin:encOG: "for:to:repeat$125 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$125$125 4
 -- $ObjectInvocation_Unary:getAdr: e >ATd.off:2:on:2:superAdj:0e: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: e: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e " ATd: "e: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdrG:isLast:E:  "e "
 -- AssignmentStatement:gen: 
 --  "e := get[inx] " right.label: "ObjectGenerator ""get[inx] " 
 -- $ObjectGenerator:gen: get[inx] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "get[inx] " 
 -- OG:before:super.gen: "get[inx] "
 -- $Invocation:gen: get[inx] >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "get[inx] " 
 -- isConstant: "Invocation ""get[inx] "
 -- needorigin: "get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "get[inx] " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: get[inx] 
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: get[inx] >on:4 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$124 "on: 4 isValueObj: false 
 --  origin: for:to:repeat$125 origin:isValueObj: false 
 rpushg repeat$124$124 1
 -- items:goOrigin:encOG: "for:to:repeat$125 "on: 3 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$125$125 4
 -- items:goOrigin:encOG: "doplus "on: 2 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- items:goOrigin:encOG: "+ "on: 1 isValueObj: false 
 --  origin: String origin:isValueObj: false 
 rpushg +$122 1
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[inx] >ATd.off:0 (isPtn):on:4:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx] " ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  rec:  "get[inx] "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[inx] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[inx]":descNo:16
 -- ptn:loadArgs:E: "get[inx] " 
 -- args: "get[inx] " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$124 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$125 origin:isValueObj: false 
 rpushg repeat$124$124 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$125$125
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- $ObjectInvocation_KeyWord:invoke: get[inx] >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[inx] "
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx] "E: "get[inx] " rec: "get[inx] " useRtnV: 
 --  true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[inx]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:X: adr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:C: get[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "e "dstE: "e "dstE.ATd: "e: var integer " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx] "
 -- isArgOfAssignI2IwithUniValArg "e := get[inx] "arg: "get[inx] "
 --  ObjectGenerator 
 -- arg.super.arg: "get[inx] "ObjectInvocation_KeyWord 
 -- dstDI: "e: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$123 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.put(e):at[inx] " 
 -- $ObjectGenerator:gen: T.put(e):at[inx] >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "T.put(e):at[inx] " 
 -- OG:before:super.gen: "T.put(e):at[inx] "
 -- $Invocation:gen: T.put(e):at[inx] >useRtnV:"False"superAdj: 0 descNo: 118
 -- INV:gen: "T.put(e):at[inx] " 
 -- isConstant: "Invocation ""T.put(e):at[inx] "
 -- needorigin: "T.put(e):at[inx] " 
 -- needOrigin:E: "put(e):at[inx] "  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[inx] " rec: "T " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E.ATd.desc: "%basic 115 " E.ATd.IT: "%basic 115 " 
 -- doNeedOrigin:Ex: "put(e):at[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "put(e):at[inx] " 
 -- doNeedOrigin:E: "put(e):at[inx] " 
 -- computeAdrX:superAdj: 0 "T.put(e):at[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: T 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: T >on:2 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$124 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$125 origin:isValueObj: false 
 rpushg repeat$124$124 1
 -- items:goOrigin:encOG: "for:to:repeat$125 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$125$125 4
 -- $ObjectInvocation_Unary:getAdr: T >ATd.off:4:on:2:superAdj:0T: obj Indexed(L + S.length,Integer):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $obj:getAdr: T: obj Indexed(L + S.length,Integer) >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"T":rec:-
 -- E.on: 2 
 -- beforeIsValueObj:E: "T " ATd: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: "put(e):at[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: put(e):at[inx] >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115:Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: "
 --  put(e):at[inx] " 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: "put(e):at[inx] " 
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: T >staticOff:0 T: obj Indexed(L + S.length,Integer) superAdj:0
 -- $obj:loadArgs: T: obj Indexed(L + S.length,Integer) >E:"T"
 -- 
 -- $pattern:loadArgs:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:loadArgs:E: "T " 
 -- args: " " 
 -- computeAdrX:before:rec:: "T " 
 -- $ObjectInvocation_Unary:invoke: T >rec:"T" ATd:"obj" E:"put(e):at[inx]" E.ATd:put(V: var integer):at[inx: var integer] unique:"False"
 -- OI:invoke: "T "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:B: "T "E: "put(e):at[inx] " rec: "T " useRtnV: true "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: T: obj Indexed(L + S.length,Integer) E: "put(e):at[inx]">newOff:4 useRTNv: "True"
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T isNotRemote: false 
 -- isCompositeValueObj: false E: "put(e):at[inx] "
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  false 
 -- E.ATd.isValueObj: false rec: "T "
 rpushg repeat$124$124 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:C: T :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "T " 
 -- checkInt2IntWithUnitArg:rec: "T "E: "put(e):at[inx] "
 -- arg:other 
 -- computeAdrX:isLast:E:  "put(e):at[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 --  rec:  "T "E:  "put(e):at[inx] "
 -- INV:gen:E.loadArgs "put(e):at[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put(e):at[inx] >staticOff:0  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 superAdj:0arg:earg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 >E:"put(e):at[inx]":descNo:118
 -- ptn:loadArgs:E: "put(e):at[inx] " 
 -- args: "put(e):at[inx] " 
 -- E: "ObjectGenerator "e 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "V: var integer 
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: e >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "e " 
 -- OG:before:super.gen: "e "
 -- $Invocation:gen: e >useRtnV:"True"superAdj: 0
 -- INV:gen: "e " 
 -- isConstant: "Invocation ""e "
 -- notConst: e e: var integer 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "e: var integer " Ex: "e " rec: "e " 
 --  E.ATd: "e: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: e 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: e >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$124 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$125 origin:isValueObj: false 
 rpushg repeat$124$124 1
 -- items:goOrigin:encOG: "for:to:repeat$125 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$125$125 4
 -- $ObjectInvocation_Unary:getAdr: e >ATd.off:2:on:2:superAdj:0e: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: e: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e " ATd: "e: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- $ObjectInvocation_Unary:loadArgs: e >staticOff:0 e: var integer superAdj:0
 -- $var:loadArgs: e: var integer >E:"e"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "e " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- $ObjectInvocation_Unary:invoke: e >rec:"e" ATd:"var" isValueObj E:"e" E.ATd:e unique:"False"
 -- OI:invoke: "e "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:B: "e "E: "e " rec: "e " useRtnV: true "
 --  e: var integer " 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- $var:invoke: e: var integer E: "e">newOff:2 useRTNv: "True"
 -- DI:invoke: "e: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 -- isCompositeValueObj: false E: "e ""e: var integer " true 
 -- E.ATd.isValueObj: false rec: "e "
 pushg 2 doplus$123
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:C: e :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "put(e):at[inx] " "ObjectInvocation_KeyWord " ActArg: "
 --  inx "isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx] "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$124 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$125 origin:isValueObj: false 
 rpushg repeat$124$124 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$125$125
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx] "
 -- INV:gen:after:E.loadArgs "put(e):at[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(e):at[inx] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- $ObjectInvocation_KeyWord:invoke: put(e):at[inx] >rec:"T" ATd:"pattern" E:"put(e):at[inx]" E.ATd:put(V: var integer):at[inx: var integer] unique:"False"
 -- OI:invoke: "put(e):at[inx] "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:B: "put(e):at[inx] "E: "put(e):at[inx] " rec: "T "
 --   useRtnV: false 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  put(V: var integer):at[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 E: "put(e):at[inx]" useRTNv: "False"
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "
 --  put(e):at[inx] "ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:C: put(e):at[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 125 
 -- Items:GenClass: for:to:repeat$125 descNo: 125 isValue: false 
 -- Items:GenClass: for:to:repeat$125 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$125 125 4 doplus 123
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs: " " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "theIS: " " 
 -- super.sig:none:superAdj: 4 
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs:  \
 -- for(1):to(L):repeat \
 --    e := get[inx] \
 --    T.put(e):at[inx]
 -- 
 -- $pattern:loadArgs:  \
 -- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
 --    %OSDvisibility skipInternal \
 --    %globals inSub
 -- ptn:loadArgs:E: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- args: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  
 -- E: "ObjectGenerator "1 
 -- E: "ObjectGenerator "L 
 -- E: "ObjectGenerator "e := get[inx]
 --     T.put(e):at[inx] 
 -- E.arg: "var "first: var integer 
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 4
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- E.arg: "var "last: var integer 
 -- NonVirt: 
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --  "ObjectInvocation_KeyWord " ActArg: "L "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: L >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "L " 
 -- OG:before:super.gen: "L "
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 4
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 4 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:1 superAdj:4 isValueObj:"True"
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg doplus$123 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:4:on:1:superAdj:4L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:4
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:4 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 4 +$122
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- actualArg:isPtn: false formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "L ":isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- args:  "repeat:< object ""e := get[inx]
 --     T.put(e):at[inx] "
 --  for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs: " " 
 -- last: var integer 1 
 -- DI:store: "last "
 pushThis 
 storeg integer$5 2
 -- first: var integer 1 
 -- DI:store: "first "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=125 vDescInx=28 vdtTop: 2 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- $Property:gen: %globals inSub 
 -- $var:gen: inx: var integer 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: " " E: "
 --  for(1):to(L):repeat
 --     e := get[inx]
 --     T.put(e):at[inx]
 --   "
 -- vdtAdd: inx=2 descInx=125 vDescInx=124 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 126 
 -- Items:GenClass: repeat$126 descNo: 126 isValue: false 
 -- Items:GenClass: repeat$126 descNo: 21 isValue: false 

 CLASS repeat$126 126 1 for:to:repeat$127 127
 -- Store itemArgs: 
 --  e := S.get[inx]
 --  i := L + inx
 --  T.put(e):at[i]
 --  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=126 vDescInx=126 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "e := S.get[inx] " 
 -- $Assign:gen: e := S.get[inx] 
 -- AssignmentStatement:gen: "e := S.get[inx] " 
 -- computeAdrG:superAdj: 0 "e "
 -- computeAdrG: 1 :rec: "none " E: "e "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: e 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: e >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- items:goOrigin:encOG: "for:to:repeat$127 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$127$127 4
 -- $ObjectInvocation_Unary:getAdr: e >ATd.off:2:on:2:superAdj:0e: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: e: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e " ATd: "e: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdrG:isLast:E:  "e "
 -- AssignmentStatement:gen: 
 --  "e := S.get[inx] " right.label: "ObjectGenerator ""S.get[inx] " 
 -- $ObjectGenerator:gen: S.get[inx] >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "S.get[inx] " 
 -- OG:before:super.gen: "S.get[inx] "
 -- $Invocation:gen: S.get[inx] >useRtnV:"True"superAdj: 0 descNo: 16
 -- INV:gen: "S.get[inx] " 
 -- isConstant: "Invocation ""S.get[inx] "
 -- notConst: S in S: var String 
 -- needorigin: "S.get[inx] " 
 -- needOrigin:E: "get[inx] "  E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  Ex: "get[inx] " rec: "S " E.ATd: 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  E.ATd.desc: 
 --  %basic 117
 --  out ch: var char
 --  E.ATd.IT: 
 --  %basic 117
 --  out ch: var char
 --  
 -- doNeedOrigin:Ex: "get[inx] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "get[inx] " 
 -- doNeedOrigin:E: "get[inx] " 
 -- computeAdrX:superAdj: 0 "S.get[inx] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: S 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: S >on:3 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- items:goOrigin:encOG: "for:to:repeat$127 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$127$127 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- $ObjectInvocation_Unary:getAdr: S >ATd.off:2:on:3:superAdj:0in S: var String:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i] 
 -- BOBS:ATd: "in S: var String "
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: in S: var String >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"S":rec:-
 -- E.on: 3 
 -- beforeIsValueObj:E: "S " ATd: "in S: var String " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "get[inx] " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: get[inx] >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "get[inx] " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "get[inx] " 
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: S >staticOff:0 in S: var String superAdj:0
 -- $var:loadArgs: in S: var String >E:"S"
 -- 
 -- $pattern:loadArgs:  \
 -- String: Value \
 --    %id "String pattern" \
 --    %OSDvisibility disguised
 -- ptn:loadArgs:E: "S " 
 -- args: " " 
 -- computeAdrX:before:rec:: "S " 
 -- $ObjectInvocation_Unary:invoke: S >rec:"S" ATd:"var" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "S "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:B: "S "E: "get[inx] " rec: "S " useRtnV: true "
 --  in S: var String " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: in S: var String E: "get[inx]">newOff:2 useRTNv: "True"
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S isNotRemote: false 
 -- isCompositeValueObj: false E: "get[inx] "
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  false 
 -- E.ATd.isValueObj: false rec: "S "
 rpushg repeat$126$126 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:C: S :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "S " 
 -- checkInt2IntWithUnitArg:rec: "S "E: "get[inx] "
 -- arg:other 
 -- computeAdrX:isLast:E:  "get[inx] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 --  rec:  "S "E:  "get[inx] "
 -- INV:gen:E.loadArgs "get[inx] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: get[inx] >staticOff:0  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char superAdj:0arg:inx
 -- 
 -- $pattern:loadArgs:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char >E:"get[inx]":descNo:16
 -- ptn:loadArgs:E: "get[inx] " 
 -- args: "get[inx] " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "get[inx] " "ObjectInvocation_KeyWord " ActArg: "inx "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx] " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$127$127
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx] "
 -- INV:gen:after:E.loadArgs "get[inx] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx] "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- $ObjectInvocation_KeyWord:invoke: get[inx] >rec:"S" ATd:"pattern" E:"get[inx]" E.ATd:get[inx: var integer] unique:"False"
 -- OI:invoke: "get[inx] "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:B: "get[inx] "E: "get[inx] " rec: "S " useRtnV: true 
 --  get[inx: var integer]: 
 --     %basic 117
 --     out ch: var char
 --  
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- get[inx: var integer]:  \
 --    %basic 117 \
 --    out ch: var char E: "get[inx]" useRTNv: "True"
 -- ptn:invoke: "get[inx: var integer] "E: "get[inx] "ptnKind: 0 
 --  useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:C: get[inx] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- rec: "e "dstE: "e "dstE.ATd: "e: var integer " useRtn: false 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: false 
 -- right: "S.get[inx] "
 -- isArgOfAssignI2IwithUniValArg "e := S.get[inx] "arg: "S.get[inx] "
 --  ObjectGenerator 
 -- arg.super.arg: "S "ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx] "ObjectInvocation_KeyWord 
 -- recx: "S "argx: "get[inx] "
 -- checkInt2IntWithUnitArg:rec: "S "E: "get[inx] "
 -- arg:other 
 -- dstDI: "e: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$123 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "i := L + inx " 
 -- $Assign:gen: i := L + inx 
 -- AssignmentStatement:gen: "i := L + inx " 
 -- computeAdrG:superAdj: 0 "i "
 -- computeAdrG: 1 :rec: "none " E: "i "
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: i 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: i >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- items:goOrigin:encOG: "for:to:repeat$127 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$127$127 4
 -- $ObjectInvocation_Unary:getAdr: i >ATd.off:3:on:2:superAdj:0i: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: i: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"i":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "i " ATd: "i: var integer " 
 -- computeAdrG:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdrG:isLast:E:  "i "
 -- AssignmentStatement:gen: 
 --  "i := L + inx " right.label: "ObjectGenerator ""L + inx " 
 -- $ObjectGenerator:gen: L + inx >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "L + inx " 
 -- OG:before:super.gen: "L + inx "
 -- $Invocation:gen: L + inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "L + inx " 
 -- isConstant: "Invocation ""L + inx "
 -- needorigin: "L + inx " 
 -- needOrigin:E: "L + inx "  E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  Ex: "L + inx " rec: "L + inx " E.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  E.ATd.desc: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 --  E.ATd.IT: 
 --  %basic 61
 --  in V: var integer
 --  out R: var integer
 -- \
 --   
 -- doNeedOrigin:Ex: "L + inx "originIsValueObj: true 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "L + inx " 
 -- doNeedOrigin:E: "L + inx " 
 -- computeAdrX:superAdj: 0 "L + inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L + inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: L + inx 
 -- $BinOp:loadOrigin: L + inx 
 -- BinaryExp:loadOrigin:empty: "L + inx "superAdj: 0 
 -- $BinOp:getAdr: L + inx 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L + inx " ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- computeAdrX:isFirst: 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdrX:isLast:E:  "L + inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 --  rec:  "L + inx "E:  "L + inx "
 -- INV:gen:E.loadArgs "L + inx "
 -- $BinOp:loadArgs: L + inx 
 -- BinaryExp:loadArgs: "L + inx " superAdj: 0 
 -- $Invocation:gen: L >useRtnV:"True"superAdj: 0
 -- INV:gen: "L " 
 -- isConstant: "Invocation ""L "
 -- notConst: L L: var integer 
 -- needorigin: "L " 
 -- needOrigin:E: "L "  E.ATd: "L: var integer " Ex: "L " rec: "L " 
 --  E.ATd: "L: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "L " 
 -- doNeedOrigin:E: "L " 
 -- computeAdrX:superAdj: 0 "L " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "L " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: L 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: L >on:3 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 3 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- items:goOrigin:encOG: "for:to:repeat$127 "on: 2 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$127$127 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- $ObjectInvocation_Unary:getAdr: L >ATd.off:4:on:3:superAdj:0L: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: L: var integer >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"L":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L " ATd: "L: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdrX:isLast:E:  "L "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 --  rec:  "L "E:  "L "
 -- INV:gen:E.loadArgs "L "
 -- $ObjectInvocation_Unary:loadArgs: L >staticOff:0 L: var integer superAdj:0
 -- $var:loadArgs: L: var integer >E:"L"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "L " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "L "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: L >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:L unique:"False"
 -- OI:invoke: "L "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L "E: "L " rec: "L " useRtnV: true "
 --  L: var integer " 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: L: var integer E: "L">newOff:4 useRTNv: "True"
 -- DI:invoke: "L: var integer " 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L isNotRemote: true 
 -- isCompositeValueObj: false E: "L ""L: var integer " true 
 -- E.ATd.isValueObj: false rec: "L "
 pushg 4 +$122
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:C: L :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L + inx "
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- $pattern:loadArgs:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:loadArgs:E: "+ inx " 
 -- args: "inx " 
 -- E: "ObjectGenerator "inx 
 -- E.arg: "var "in V: var integer 
 -- NonVirt: "+ inx " "ObjectInvocation_Binary " ActArg: "inx "
 --  isValue: false formalArg: "in V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ inx " isCompositeValueObj: 
 --  false 
 -- $ObjectGenerator:gen: inx >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "inx " 
 -- OG:before:super.gen: "inx "
 -- $Invocation:gen: inx >useRtnV:"True"superAdj: 0
 -- INV:gen: "inx " 
 -- isConstant: "Invocation ""inx "
 -- notConst: inx inx: var integer 
 -- needorigin: "inx " 
 -- needOrigin:E: "inx "  E.ATd: "inx: var integer " Ex: "inx " rec: "
 --  inx " E.ATd: "inx: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "inx " 
 -- doNeedOrigin:E: "inx " 
 -- computeAdrX:superAdj: 0 "inx " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "inx " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: inx 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: inx >on:1 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 1 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- $ObjectInvocation_Unary:getAdr: inx >ATd.off:3:on:1:superAdj:0inx: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: inx: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inx":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx " ATd: "inx: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdrX:isLast:E:  "inx "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 --  rec:  "inx "E:  "inx "
 -- INV:gen:E.loadArgs "inx "
 -- $ObjectInvocation_Unary:loadArgs: inx >staticOff:0 inx: var integer superAdj:0
 -- $var:loadArgs: inx: var integer >E:"inx"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "inx " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "inx "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: inx >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:inx unique:"False"
 -- OI:invoke: "inx "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx "E: "inx " rec: "inx " useRtnV: true "
 --  inx: var integer " 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: inx: var integer E: "inx">newOff:3 useRTNv: "True"
 -- DI:invoke: "inx: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx isNotRemote: true 
 -- isCompositeValueObj: false E: "inx ""inx: var integer " true 
 -- E.ATd.isValueObj: false rec: "inx "
 pushg 3 for:to:repeat$127$127
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:C: inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- actualArg:isPtn: false formalArg:isPtn: "in V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "inx ":isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ inx "
 -- BinaryExp:loadArgs:end: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + inx "
 --  OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + inx "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: L + inx 
 -- BinaryExp:invoke: "L "rec: "L + inx "
 -- M: "+ inx "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: + inx >rec:"L" ATd:"pattern" E:"+ inx" E.ATd:+   unique:"False"
 -- OI:invoke: "+ inx "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ inx "E: "+ inx " rec: "L " useRtnV: true 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- 
 -- $pattern:invoke:  \
 -- +  :  \
 --    %basic 61 \
 --    in V: var integer
 -- ptn:invoke: "+   "E: "+ inx "ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L "E: "+ inx "
 -- arg:other 
 plus
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- OI:invoke:C: + inx :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- rec: "i "dstE: "i "dstE.ATd: "i: var integer " useRtn: false 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true 
 --  dstDI.OG.isUnitValObj: false 
 --  right.super.isUnitValObj: false F: false I: true 
 -- right: "L + inx "
 -- isArgOfAssignI2IwithUniValArg "i := L + inx "arg: "L + inx "
 --  ObjectGenerator 
 -- arg.super.arg: "L + inx "BinOp 
 -- recx:BinaryExp:recx: "L + inx "
 -- M: "+ inx "label: "ObjectInvocation_Binary "M.ATd: 
 --  +  : 
 --     %basic 61
 --     in V: var integer
 --     out R: var integer
 --  
 -- checkInt2IntWithUnitArg:rec: "L "E: "+ inx "
 -- arg:other 
 -- M:arg: "inx "ObjectGenerator false 
 -- dstDI: "i: var integer " 
 -- assign:adr.store:A: 
 -- store: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$123 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.put(e):at[i] " 
 -- $ObjectGenerator:gen: T.put(e):at[i] >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "T.put(e):at[i] " 
 -- OG:before:super.gen: "T.put(e):at[i] "
 -- $Invocation:gen: T.put(e):at[i] >useRtnV:"False"superAdj: 0 descNo: 118
 -- INV:gen: "T.put(e):at[i] " 
 -- isConstant: "Invocation ""T.put(e):at[i] "
 -- needorigin: "T.put(e):at[i] " 
 -- needOrigin:E: "put(e):at[i] "  E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  Ex: "put(e):at[i] " rec: "T " E.ATd: 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  E.ATd.desc: "%basic 115 " E.ATd.IT: "%basic 115 " 
 -- doNeedOrigin:Ex: "put(e):at[i] "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "put(e):at[i] " 
 -- doNeedOrigin:E: "put(e):at[i] " 
 -- computeAdrX:superAdj: 0 "T.put(e):at[i] " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "T " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: T 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: T >on:2 superAdj:0 isValueObj:"False"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- items:goOrigin:encOG: "for:to:repeat$127 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$127$127 4
 -- $ObjectInvocation_Unary:getAdr: T >ATd.off:4:on:2:superAdj:0T: obj Indexed(L + S.length,Integer):Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $obj:getAdr: T: obj Indexed(L + S.length,Integer) >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"T":rec:-
 -- E.on: 2 
 -- beforeIsValueObj:E: "T " ATd: "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  A.E: none 
 --  
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_KeyWord:getAdr: put(e):at[i] >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115:Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  rec.ATd: "T: obj Indexed(L + S.length,Integer) " 
 --  rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --  recA: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:- 
 --  pRecA: none 
 -- pRec: "T " rec: "T " E: "put(e):at[i] " 
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: T >staticOff:0 T: obj Indexed(L + S.length,Integer) superAdj:0
 -- $obj:loadArgs: T: obj Indexed(L + S.length,Integer) >E:"T"
 -- 
 -- $pattern:loadArgs:  \
 -- Indexed:  \
 --    %globals \
 --    %basic 114
 -- ptn:loadArgs:E: "T " 
 -- args: " " 
 -- computeAdrX:before:rec:: "T " 
 -- $ObjectInvocation_Unary:invoke: T >rec:"T" ATd:"obj" E:"put(e):at[i]" E.ATd:put(V: var integer):at[inx: var integer] unique:"False"
 -- OI:invoke: "T "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:B: "T "E: "put(e):at[i] " rec: "T " useRtnV: true "
 --  T: obj Indexed(L + S.length,Integer) " 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: T: obj Indexed(L + S.length,Integer) E: "put(e):at[i]">newOff:4 useRTNv: "True"
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer) " 
 -- >Object:unique: false 
 -- load: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T isNotRemote: false 
 -- isCompositeValueObj: false E: "put(e):at[i] "
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  false 
 -- E.ATd.isValueObj: false rec: "T "
 rpushg repeat$126$126 4
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:C: T :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "T " 
 -- checkInt2IntWithUnitArg:rec: "T "E: "put(e):at[i] "
 -- arg:other 
 -- computeAdrX:isLast:E:  "put(e):at[i] "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 --  rec:  "T "E:  "put(e):at[i] "
 -- INV:gen:E.loadArgs "put(e):at[i] "
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs: put(e):at[i] >staticOff:0  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 superAdj:0arg:earg:i
 -- 
 -- $pattern:loadArgs:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 >E:"put(e):at[i]":descNo:118
 -- ptn:loadArgs:E: "put(e):at[i] " 
 -- args: "put(e):at[i] " 
 -- E: "ObjectGenerator "e 
 -- E: "ObjectGenerator "i 
 -- E.arg: "var "V: var integer 
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "e "
 --  isValue: false formalArg: "V: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: e >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "e " 
 -- OG:before:super.gen: "e "
 -- $Invocation:gen: e >useRtnV:"True"superAdj: 0
 -- INV:gen: "e " 
 -- isConstant: "Invocation ""e "
 -- notConst: e e: var integer 
 -- needorigin: "e " 
 -- needOrigin:E: "e "  E.ATd: "e: var integer " Ex: "e " rec: "e " 
 --  E.ATd: "e: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "e " 
 -- doNeedOrigin:E: "e " 
 -- computeAdrX:superAdj: 0 "e " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "e " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: e 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: e >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- items:goOrigin:encOG: "for:to:repeat$127 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$127$127 4
 -- $ObjectInvocation_Unary:getAdr: e >ATd.off:2:on:2:superAdj:0e: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: e: var integer >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"e":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e " ATd: "e: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdrX:isLast:E:  "e "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 --  rec:  "e "E:  "e "
 -- INV:gen:E.loadArgs "e "
 -- $ObjectInvocation_Unary:loadArgs: e >staticOff:0 e: var integer superAdj:0
 -- $var:loadArgs: e: var integer >E:"e"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "e " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "e "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- $ObjectInvocation_Unary:invoke: e >rec:"e" ATd:"var" isValueObj E:"e" E.ATd:e unique:"False"
 -- OI:invoke: "e "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:B: "e "E: "e " rec: "e " useRtnV: true "
 --  e: var integer " 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- $var:invoke: e: var integer E: "e">newOff:2 useRTNv: "True"
 -- DI:invoke: "e: var integer " 
 -- load: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e isNotRemote: true 
 -- isCompositeValueObj: false E: "e ""e: var integer " true 
 -- E.ATd.isValueObj: false rec: "e "
 pushg 2 doplus$123
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:C: e :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- actualArg:isPtn: false formalArg:isPtn: "V: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "e ":isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- E.arg: "var "inx: var integer 
 -- NonVirt: "put(e):at[i] " "ObjectInvocation_KeyWord " ActArg: "i "
 --  isValue: false formalArg: "inx: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i] "
 --   isCompositeValueObj: false 
 -- $ObjectGenerator:gen: i >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0
 -- OG:gen: "i " 
 -- OG:before:super.gen: "i "
 -- $Invocation:gen: i >useRtnV:"True"superAdj: 0
 -- INV:gen: "i " 
 -- isConstant: "Invocation ""i "
 -- notConst: i i: var integer 
 -- needorigin: "i " 
 -- needOrigin:E: "i "  E.ATd: "i: var integer " Ex: "i " rec: "i " 
 --  E.ATd: "i: var integer " E.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: " " 
 -- needOrigin:dataItem:leave 
 -- after:needOrigin: "i " 
 -- doNeedOrigin:E: "i " 
 -- computeAdrX:superAdj: 0 "i " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "i " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: i 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: i >on:2 superAdj:0 isValueObj:"True"
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$126 "on: 2 isValueObj: false 
 --  origin: for:to:repeat$127 origin:isValueObj: false 
 rpushg repeat$126$126 1
 -- items:goOrigin:encOG: "for:to:repeat$127 "on: 1 isValueObj: 
 --  false 
 --  origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$127$127 4
 -- $ObjectInvocation_Unary:getAdr: i >ATd.off:3:on:2:superAdj:0i: var integer:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- $var:getAdr: i: var integer >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"i":rec:-
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer "ObjectGenerator 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "i " ATd: "i: var integer " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdrX:isLast:E:  "i "
 -- IV:after:computeAdr:superAdj: 0 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 --  rec:  "i "E:  "i "
 -- INV:gen:E.loadArgs "i "
 -- $ObjectInvocation_Unary:loadArgs: i >staticOff:0 i: var integer superAdj:0
 -- $var:loadArgs: i: var integer >E:"i"
 -- 
 -- $pattern:loadArgs:  \
 -- integer: value \
 --    %ID integer \
 --    %basic 1, 32
 -- ptn:loadArgs:E: "i " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "i "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i "
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- $ObjectInvocation_Unary:invoke: i >rec:"i" ATd:"var" isValueObj E:"i" E.ATd:i unique:"False"
 -- OI:invoke: "i "
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "i "E: "i " rec: "i " useRtnV: true "
 --  i: var integer " 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- $var:invoke: i: var integer E: "i">newOff:3 useRTNv: "True"
 -- DI:invoke: "i: var integer " 
 -- load: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i isNotRemote: true 
 -- isCompositeValueObj: false E: "i ""i: var integer " true 
 -- E.ATd.isValueObj: false rec: "i "
 pushg 3 doplus$123
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 5 vTopMax: 5 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:X: adr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:C: i :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- actualArg:isPtn: false formalArg:isPtn: "inx: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "i ":isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i] "
 -- INV:gen:after:E.loadArgs "put(e):at[i] "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "
 --  put(e):at[i] "
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- $ObjectInvocation_KeyWord:invoke: put(e):at[i] >rec:"T" ATd:"pattern" E:"put(e):at[i]" E.ATd:put(V: var integer):at[inx: var integer] unique:"False"
 -- OI:invoke: "put(e):at[i] "
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:B: "put(e):at[i] "E: "put(e):at[i] " rec: "T "
 --   useRtnV: false 
 --  put(V: var integer):at[inx: var integer]: 
 --     %basic 115
 --  
 -- OI:invoke:before:ATdx.invoke: pattern 
 --  put(V: var integer):at[inx: var integer] 
 -- 
 -- $pattern:invoke:  \
 -- put(V: var integer):at[inx: var integer]:  \
 --    %basic 115 E: "put(e):at[i]" useRTNv: "False"
 -- ptn:invoke: "put(V: var integer):at[inx: var integer] "E: "
 --  put(e):at[i] "ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 5 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 3 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:X: adr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:C: put(e):at[i] :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 127 
 -- Items:GenClass: for:to:repeat$127 descNo: 127 isValue: false 
 -- Items:GenClass: for:to:repeat$127 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$127 127 4 doplus 123
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs: " " 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "theIS: " " 
 -- super.sig:none:superAdj: 4 
 -- 
 -- $ObjectInvocation_KeyWord:loadArgs:  \
 -- for(1):to(S.length):repeat \
 --    e := S.get[inx] \
 --    i := L + inx
 -- 
 -- $pattern:loadArgs:  \
 -- for(first: var integer):to(last: var integer):repeat{repeat:< object}:  \
 --    %OSDvisibility skipInternal \
 --    %globals inSub
 -- ptn:loadArgs:E: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- args: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 -- E: "ObjectGenerator "1 
 -- E: "ObjectGenerator "S.length 
 -- E: "ObjectGenerator "
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i] 
 -- E.arg: "var "first: var integer 
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "1 "isValue: true formalArg: "
 --  first: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: 1 >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "1 " 
 -- OG:before:super.gen: "1 "
 -- $Invocation:gen: 1 >useRtnV:"True"superAdj: 4
 -- INV:gen: "1 " 
 -- isConstant: "Invocation ""1 "
 -- needorigin: "1 " 
 -- needOrigin:E: "1 "  E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsEx: "1 " rec: "1 " E.ATd: 
 --  integer: value
 --     %ID integer
 --     %basic 1, 32
 --     %globalsE.ATd.desc: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %publicE.ATd.IT: 
 --  %ID integer
 --  %basic 1, 32
 --  %globals
 --  %public
 -- Ex:loadOrgin:no:loadOrigin:  
 --  value
 --     %ID integer
 --     %basic 1, 32
 --     %globals
 -- after:needOrigin: "1 " 
 -- IV:after:computeAdr:superAdj: 4 
 --  rec:  "1 "E:  "1 "
 -- INV:gen:E.loadArgs "1 "
 -- $ConstLiteral:loadArgs: 1 
 -- INV:gen:after:E.loadArgs "1 "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1 "
 -- $ConstLiteral:invoke: 1 
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: OIadr: none 
 -- actualArg:isPtn: true formalArg:isPtn: "first: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "1 ":isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- E.arg: "var "last: var integer 
 -- NonVirt: 
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]"ObjectInvocation_KeyWord " ActArg: "S.length "isValue: false 
 --  formalArg: "last: var integer " 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --   formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   " isCompositeValueObj: false 
 -- $ObjectGenerator:gen: S.length >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4
 -- OG:gen: "S.length " 
 -- OG:before:super.gen: "S.length "
 -- $Invocation:gen: S.length >useRtnV:"True"superAdj: 4 descNo: 15
 -- INV:gen: "S.length " 
 -- isConstant: "Invocation ""S.length "
 -- notConst: S in S: var String 
 -- needorigin: "S.length " 
 -- needOrigin:E: "length "  E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  Ex: "length " rec: "S " E.ATd: 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  E.ATd.desc: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  E.ATd.IT: 
 --  out V: var integer
 --  V := get[0] -- actually an index error, accessing length
 --  
 -- doNeedOrigin:Ex: "length "originIsValueObj: false 
 --  origin.isPrimitive: false 
 -- KUK 
 -- after:needOrigin: "length " 
 -- doNeedOrigin:E: "length " 
 -- computeAdrX:superAdj: 4 "S.length " 
 -- computeAdrX:En: 1 pRec: none rec: none E: "S " 
 --  A.E: none 
 --  
 --  :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: S 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: S >on:1 superAdj:4 isValueObj:"False"
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg doplus$123 4
 -- items:goOrigin:encOG: "doplus "on: 1 isValueObj: false 
 --  origin: + origin:isValueObj: false 
 rpushg doplus$123 1
 -- $ObjectInvocation_Unary:getAdr: S >ATd.off:2:on:1:superAdj:4in S: var String:Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- PING:String 0 
 --  e: var integer
 --     i: var integer
 --     T: obj Indexed(L + S.length,Integer)
 --     for(1):to(L):repeat
 --        e := get[inx]
 --        T.put(e):at[inx]
 --     
 --     for(1):to(S.length):repeat
 --        e := S.get[inx]
 --        i := L + inx
 --        T.put(e):at[i]
 --     
 --     V := T.asString
 --     -- V: obj Indexed(Length + S.length)
 --     -- V := T[1:length] + S.T[1:S.length] 
 -- BOBS:ATd: "in S: var String "
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: in S: var String >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"S":rec:-
 -- E.on: 1 
 -- beforeIsValueObj:E: "S " ATd: "in S: var String " 
 -- computeAdrX:isFirst: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdrX:En: 2 pRec: "S " rec: "S " E: "length " 
 --  A.E: none 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- 
 -- $ObjectInvocation_Unary:getAdr: length >ATd.off:0 (isPtn):on:0:superAdj:0 \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length:Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:-
 -- 
 -- $pattern:getAdr:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- computeAdrX:loadRec: 2 pRec: "S " rec: "S " E: "length " 
 --  rec.ATd: "in S: var String " rec.ATD.OG.isValueObj: false 
 --  rec.ATd.origin: 
 --  in S: var String
 --     out V: var String
 --     L: var integer
 --     L := Length
 --  recA: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 --  pRecA: none 
 -- pRec: "S " rec: "S " E: "length " 
 --  false false 
 -- $ObjectInvocation_Unary:loadArgs: S >staticOff:0 in S: var String superAdj:4
 -- $var:loadArgs: in S: var String >E:"S"
 -- 
 -- $pattern:loadArgs:  \
 -- String: Value \
 --    %id "String pattern" \
 --    %OSDvisibility disguised
 -- ptn:loadArgs:E: "S " 
 -- args: " " 
 -- computeAdrX:before:rec:: "S " 
 -- $ObjectInvocation_Unary:invoke: S >rec:"S" ATd:"var" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "S "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "S "E: "length " rec: "S " useRtnV: true "
 --  in S: var String " 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: in S: var String E: "length">newOff:2 useRTNv: "True"
 -- DI:invoke: "in S: var String " 
 -- >Object:unique: false 
 -- Address:loadAdr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$123 2
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: S :unit:  -none-   convFactor:  0.000000
 -- computeAdrX:after:rec.invoke: "S " 
 -- checkInt2IntWithUnitArg:rec: "S "E: "length "
 -- computeAdrX:isLast:E:  "length "
 -- IV:after:computeAdr:superAdj: 4 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 --  rec:  "S "E:  "length "
 -- INV:gen:E.loadArgs "length "
 -- 
 -- $ObjectInvocation_Unary:loadArgs: length >staticOff:0  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length superAdj:4
 -- 
 -- $pattern:loadArgs:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length >E:"length":descNo:15
 -- ptn:loadArgs:E: "length " 
 -- args: " " 
 -- INV:gen:after:E.loadArgs "length "
 --  OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length "
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- $ObjectInvocation_Unary:invoke: length >rec:"S" ATd:"pattern" E:"length" E.ATd:length unique:"False"
 -- OI:invoke: "length "
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "length "E: "length " rec: "S " useRtnV: true 
 --  length: 
 --     out V: var integer
 --     V := get[0] -- actually an index error, accessing length
 --  
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- 
 -- $pattern:invoke:  \
 -- length:  \
 --    out V: var integer \
 --    V := get[0] -- actually an index error, accessing length E: "length" useRTNv: "True"
 -- ptn:invoke: "length "E: "length "ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 rec: "S " 
 --  
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: length :unit:  -none-   convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: OIadr: 
 --  :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- actualArg:isPtn: true formalArg:isPtn: "last: var integer "
 --  :isBasicVal: true :valueObj: true 
 --  :actArg: "S.length ":isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- args:  "repeat:< object ""
 --  e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i] "for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs: " " 
 -- last: var integer 1 
 -- DI:store: "last "
 pushThis 
 storeg integer$5 2
 -- first: var integer 1 
 -- DI:store: "first "
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=127 vDescInx=28 vdtTop: 2 
 -- $Property:gen: %OSDvisibility skipInternal 
 -- $Property:gen: %globals inSub 
 -- $var:gen: inx: var integer 
 -- DI:gen: "inx: var integer " DI:isConst: false isBasicValue: true 
 --  primNo: 1 
 -- DI:gen:primitiveType: inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: " " E: "
 --  for(1):to(S.length):repeat
 --     e := S.get[inx]
 --     i := L + inx
 --     T.put(e):at[i]
 --   "
 -- vdtAdd: inx=2 descInx=127 vDescInx=126 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 128 
 -- Items:GenClass: asString descNo: 128 isValue: false 
 -- Items:GenClass: asString descNo: 21 isValue: false 

 CLASS asString 128 1 Indexed 106
 -- Store itemArgs: 
 --  %basic 118
 --  out S: var LIB.StringLib.String
 --  
 -- Store:Origin: 114 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=128 vDescInx=128 vdtTop: 1 
 mvStack 
 -- $Property:gen: %basic 118 
 -- $var:gen: out S: var LIB.StringLib.String 
 -- DI:gen: "out S: var LIB.StringLib.String " DI:isConst: false 
 --  isBasicValue: false primNo: 5 
 -- DI:StringVar "out S: var LIB.StringLib.String "
 pushText ""
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 118 " 
 -- $Property:gen: %basic 118 
 L2:
 -- pushReturn:  "asString "
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:   : done: false 

 CLASS valProx 129 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 130 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 131 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 132 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=55 vDescInx=53 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=30 vDescInx=24 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=114 vDescInx=111 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=125 vDescInx=124 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=127 vDescInx=126 vdtTop: 2 

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 102 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 57 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 82 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Dimensions descInx:38 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 66 2 1
14:	rpop 
15:	pushthis 
16:	invoke 72 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class Dimension descInx:39 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 8
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class Unit descInx:40 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class PrimaryUnit#44 descInx:44 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgL#45 descInx:45 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgR#46 descInx:46 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultRes#47 descInx:47 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class float descInx:48 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class toPrimary descInx:49 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 40 1 0
13:	rpop 
14:	rtnAlloc 1
doE: 
16:	doEventQ 
17:	mvStack
18:	pushthis 
19:	innerP 2
21:	rpopThisObj
22:	setThisStack
23:	pushthis 
24:	rtn D


Class fromPrimary descInx:50 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 2 2 0
10:	jmp 20
13:	invokeVal 40 1 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	setThisStack
35:	pushthis 
36:	rtn D


Class print descInx:51 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushText 1
13:	invoke 52 0 0
19:	rpop 
20:	pushthis 
21:	innerP 2
23:	rpopThisObj
24:	pushc 58
26:	%prim put 2
28:	pushthis 
29:	rpushg 1
31:	fvpushg 1
33:	%prim printf 142
35:	vpop 
36:	setThisStack
37:	pushthis 
38:	rtn D


Class print descInx:52 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 55 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$53 descInx:53 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:54 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$55 descInx:55 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class putFloat descInx:56 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class _doIt descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 59 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 62 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:58 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 31 3 0
19:	rpop 
20:	tstOriginNone 
21:	rstore 1
23:	allocEventQ 0
25:	mvStack
allocE: 
26:	rtnAlloc 1
doE: 
28:	doEventQ 
29:	mvStack
30:	setThisStack
31:	pushthis 
32:	rtn D


Class $59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 57 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class symbol descInx:63 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	pushText 1
6:	pushthis 
7:	rstoreg 2
9:	rtnAlloc 1
doE: 
11:	doEventQ 
12:	mvStack
13:	pushthis 
14:	innerP 2
16:	rpopThisObj
17:	setThisStack
18:	pushthis 
19:	rtn D


Class gMult descInx:64 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 20
13:	invokeVal 40 3 0
19:	rpop 
20:	jmpFalse 32
23:	pushthis 
24:	vassign 2 2 0
29:	jmp 39
32:	invokeVal 40 1 0
38:	rpop 
39:	tstOriginNone 
40:	rstore 1
42:	allocEventQ 0
44:	mvStack
allocE: 
45:	invokeVal 40 5 0
51:	rpop 
52:	rtnAlloc 1
doE: 
54:	doEventQ 
55:	mvStack
56:	pushthis 
57:	pushthis 
58:	fpushg 2
60:	pushthis 
61:	fpushg 4
63:	fmult 
64:	fstoreg 6
66:	setThisStack
67:	pushthis 
68:	rtn D


Class Area descInx:66 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#67 descInx:67 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 68 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class SquareMeter descInx:68 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class print descInx:70 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class symbol descInx:71 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class Length descInx:72 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#73 descInx:73 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 74 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Meter descInx:74 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	mvStack
7:	rtnInner


Class toPrimary descInx:78 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 40 1 0
18:	rpop 
19:	rtnAlloc 1
21:	toSuper 49
doE: 
24:	mvStack
25:	pushthis 
26:	pushthis 
27:	rpushg 1
29:	fvpushg 1
31:	fstoreg 2
33:	rtnInner


Class fromPrimary descInx:79 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	jmpFalse 19
10:	pushthis 
11:	vassign 2 2 0
16:	jmp 26
19:	invokeVal 40 1 0
25:	rpop 
26:	tstOriginNone 
27:	rstore 1
29:	allocEventQ 0
allocE: 
31:	rtnAlloc 1
33:	toSuper 50
doE: 
36:	mvStack
37:	pushthis 
38:	rpushg 1
40:	pushthis 
41:	fpushg 2
43:	fvstoreg 1
45:	rtnInner


Class print descInx:80 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 51
doE: 
17:	mvStack
18:	pushText 14
20:	invoke 52 0 0
26:	rpop 
27:	rtnInner


Class symbol descInx:81 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class StringLib descInx:82 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:83 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	mvStack
allocE: 
2:	rtnAlloc 1
doE: 
4:	mvStack
5:	setThisStack
6:	pushthis 
7:	rtn D


Class <= descInx:84 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 85 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:85 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 87 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 88 0 0
71:	rpop 
72:	pushthis 
73:	invoke 89 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $87 descInx:87 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $88 descInx:88 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:89 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 90 0 0
18:	rpop 
19:	pushthis 
20:	invoke 93 0 0
26:	rpop 
27:	pushthis 
28:	invoke 96 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:90 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 91 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 92 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $91 descInx:91 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 89 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $92 descInx:92 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 89 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:93 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 94 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $94 descInx:94 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 95 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $95 descInx:95 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 93 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:96 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 97 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 98 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $97 descInx:97 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 89 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $98 descInx:98 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 89 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:100 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:101 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class workspace descInx:102 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 103 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class tinyB descInx:103 objSize:6 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invokeVal 68 4 0
13:	rpop 
14:	rtnAlloc 1
doE: 
16:	doEventQ 
17:	mvStack
18:	pushthis 
19:	pushc 3
21:	i2f
22:	fstoreg 2

24:	pushthis 
25:	pushFloatConst 4.870000
34:	f2i
35:	storeg 4

37:	pushthis 
38:	pushthis 
39:	fpushg 2
41:	pushc 12
43:	i2f
44:	fmult 
45:	fstoreg 2

47:	pushthis 
48:	pushthis 
49:	fpushg 2
51:	pushthis 
52:	pushg 4
54:	i2f
55:	fmult 
56:	fstoreg 2

58:	pushthis 
59:	pushc 10
61:	pushthis 
62:	fpushg 2
64:	f2i
65:	*
66:	i2f
67:	fstoreg 2

69:	pushthis 
70:	pushthis 
71:	pushg 4
73:	pushthis 
74:	fpushg 2
76:	f2i
77:	*
78:	i2f
79:	fstoreg 2

81:	pushthis 
82:	pushthis 
83:	pushg 4
85:	pushthis 
86:	pushg 4
88:	*
89:	i2f
90:	fstoreg 2

92:	pushthis 
93:	pushthis 
94:	pushg 4
96:	i2f
97:	pushFloatConst 11.110000
106:	f2i
107:	*
108:	storeg 4

110:	pushthis 
111:	pushthis 
112:	pushg 4
114:	pushthis 
115:	fpushg 2
117:	f2i
118:	*
119:	storeg 4

121:	pushthis 
122:	pushFloatConst 12.120000
131:	pushthis 
132:	fpushg 2
134:	fmult 
135:	f2i
136:	storeg 4

138:	pushthis 
139:	pushthis 
140:	pushg 4
142:	pushthis 
143:	fpushg 2
145:	f2i
146:	*
147:	storeg 4
149:	pushthis 

150:	pushthis 
151:	fpushg 2
153:	pushthis 
154:	fpushg 2
156:	fmult 
157:	f2i
158:	storeg 4

160:	pushthis 
161:	pushg 4
163:	invoke 105 0 0
169:	rpop 
170:	invoke 115 0 0
176:	rpop 
177:	pushthis 
178:	fpushg 2
180:	%prim printf 142
182:	vpop 
183:	invoke 115 0 0
189:	rpop 
190:	pushthis 
191:	pushc 24
193:	i2f
194:	fstoreg 5

196:	pushthis 
197:	pushc 3
199:	i2f
200:	pushthis 
201:	fpushg 5
203:	fmult 
204:	fstoreg 5

206:	pushthis 
207:	pushthis 
208:	fpushg 5
210:	pushc 2
212:	i2f
213:	fmult 
214:	fstoreg 5

216:	pushthis 
217:	rdouble 
218:	rpushg 1
220:	rpushg 1
222:	rpushg 3
224:	rpushg 4
226:	rpushg 2
228:	mkValueProxy 68 4 0 0
235:	invoke 70 0 0
241:	rpop 
242:	setThisStack
243:	pushthis 
244:	rtn D


Class putint descInx:105 objSize:4 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushc 20
9:	pushthis 
10:	pushc 1
12:	allocIndexed 106 1 0 
17:	pushthis 
18:	rstoreg 2
20:	rtnAlloc 1
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	pushthis 
26:	pushg 1
28:	pushc 0
30:	lt
31:	storeg 4
33:	pushthis 
34:	pushg 4
36:	jmpFalse 47
39:	pushthis 
40:	invoke 108 0 0
46:	rpop 
47:	pushthis 
48:	invoke 116 0 0
54:	rpop 
55:	pushthis 
56:	pushg 4
58:	jmpFalse 69
61:	pushthis 
62:	invoke 110 0 0
68:	rpop 
69:	pushthis 
70:	invoke 114 0 0
76:	rpop 
77:	setThisStack
78:	pushthis 
79:	rtn D


Class Indexed descInx:106 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class $108 descInx:108 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushc 0
16:	pushthis 
17:	rpushg 1
19:	pushg 1
21:	-
22:	storeg 1
24:	setThisStack
25:	pushthis 
26:	rtn D


Class $110 descInx:110 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushc 45
13:	%prim put 2
15:	setThisStack
16:	pushthis 
17:	rtn D


Class repeat$111 descInx:111 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 4
17:	pushg 3
19:	pushc 1
21:	+
22:	pushthis 
23:	rpushg 1
25:	pushg 3
27:	-
28:	storeg 2
30:	pushc 48
32:	pushthis 
33:	rpushg 1
35:	rpushg 4
37:	rpushg 2
39:	pushthis 
40:	pushg 2
42:	xpushg 1 0 1
46:	+
47:	%prim put 2
49:	setThisStack
50:	pushthis 
51:	rtn D


Class for:to:repeat$114 descInx:114 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	pushg 3
11:	pushthis 
12:	storeg 2
14:	pushthis 
15:	storeg 1
17:	allocEventQ 0
allocE: 
19:	rtnAlloc 1
21:	toSuper 28
doE: 
24:	mvStack
25:	rtnInner


Class newline descInx:115 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushc 10
10:	%prim put 2
12:	setThisStack
13:	pushthis 
14:	rtn D


Class loop descInx:116 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	pushc 1
21:	+
22:	storeg 3
24:	pushthis 
25:	rpushg 1
27:	rpushg 2
29:	pushthis 
30:	rpushg 1
32:	pushg 1
34:	pushc 10
36:	modd
37:	pushthis 
38:	rpushg 1
40:	pushg 3
42:	xstoreg 1 0 1 
46:	pushthis 
47:	rpushg 1
49:	pushthis 
50:	rpushg 1
52:	pushg 1
54:	pushc 10
56:	idiv
57:	storeg 1
59:	pushthis 
60:	rpushg 1
62:	pushg 1
64:	pushc 0
66:	gt 
67:	jmpFalse 78
70:	pushthis 
71:	invoke 121 0 0
77:	rpop 
78:	setThisStack
79:	pushthis 
80:	rtn D


Class $121 descInx:121 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 1 116 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class + descInx:122 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 123 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:123 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 106 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 125 0 0
48:	rpop 
49:	pushthis 
50:	invoke 127 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class repeat$124 descInx:124 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$125 descInx:125 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$126 descInx:126 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$127 descInx:127 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:128 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class valProx descInx:129 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:130 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:131 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:132 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

