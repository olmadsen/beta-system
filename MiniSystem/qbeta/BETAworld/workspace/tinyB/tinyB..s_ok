 -- QBETA
 -- OG:markForCodeGen:"%id "BETAworld" | %modules BETA, LIB, LIB.String | error ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%id "BETAworld" | %modules BETA, LIB, LIB.String | error:  |    %b ..." 
 -- items:markForCodeGen:"%id "BETAworld" | %modules BETA, LIB, LIB.String | er ..." 
 -- markItem:"%id "BETAworld"" Property
 -- markItem:"%modules BETA, LIB, LIB.String" Property
 -- OG:markForCodeGen:"%ID BETA | %OSDvisibility disguised | %public | universal: ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%ID BETA | %OSDvisibility disguised | %public | universal: Value |   ..." 
 -- items:markForCodeGen:"%ID BETA | %OSDvisibility disguised | %public | univers ..." 
 -- markItem:"%ID BETA" Property
 -- markItem:"%OSDvisibility disguised" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:"ascii" :descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:"nl: val 10 | cr: val 13 | newline: var char | isLetter:  |   ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"nl: val 10 | cr: val 13 | newline: var char | isLetter:  |    in ch: ..." 
 -- items:markForCodeGen:"nl: val 10 | cr: val 13 | newline: var char | isLetter: ..." 
 -- DataItem:markForCodeGen:"nl" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"10" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "10" 
 -- "10" true
 -- 
 -- OG:markSuper:"10" 
 -- Invocation:markForCodeGen:"10" 
 -- not ObjDesc: "10"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"cr" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"13" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "13" 
 -- "13" true
 -- 
 -- OG:markSuper:"13" 
 -- Invocation:markForCodeGen:"13" 
 -- not ObjDesc: "13"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"newline" :descNo:0 :OG.primNo:3 
 -- OG:markForCodeGen:"char" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "char" 
 -- "char" true
 -- 
 -- OG:markSuper:"char" 
 -- Invocation:markForCodeGen:"char" 
 -- ObjectInvocation:markForCodeGen:"char"  ATd:"char: value |    %id "char" |  ..." 
 -- Pattern:markForCodeGen:"char: value |    %id "char" |    %globals |    %basic ..." 
 -- OG:markForCodeGen:"value |    %id "char" |    %globals |    %basic 3, 16 |    % ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "value" 
 -- "value" true
 -- 
 -- OG:markSuper:"value" 
 -- Invocation:markForCodeGen:"value" 
 -- ObjectInvocation:markForCodeGen:"value"  ATd:"Value:  |    %ID Value |    % ..." 
 -- Pattern:markForCodeGen:"Value:  |    %ID Value |    %globals |    %basic 21 |   ..." 
 -- OG:markForCodeGen:"%ID Value | %globals | %basic 21 | %public | := :  |    %basic ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%ID Value | %globals | %basic 21 | %public | := :  |    %basic 8 |    in ..." 
 -- items:markForCodeGen:"%ID Value | %globals | %basic 21 | %public | := :  |    %ba ..." 
 -- markItem:"%ID Value" Property
 -- markItem:"%globals" Property
 -- markItem:"%basic 21" Property
 -- markItem:"%public" Property
 -- ComputeVariant:A:"Value" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%ID Value | %globals | %basic 21 | %public | := :  |    %basic 8 |     ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%ID Value | %globals | %basic 21 | %public | := :  |    %basic 8 |    in V: var Va ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"Value" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:1 IS.newDescNo:1 objSize:0 varNo:1 "%ID Value ..." 
 -- Items:Qalloc:objSize:0  newDescNo:1 "%ID Value | %globals | %basic 21 | %publ ..." 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- Pattern:Qalloc::=
 -- Items:Qalloc:END:objSize:0  newDescNo:1 "%ID Value | %globals | %basic 21 | % ..." 
 -- IS.newDescNo:1 IS.objSize:0 "%ID Value | %globals | %basic 21 | %public | := :  ..." 
 -- computeVariant:newDescNo:1  size: 0  IS:"%ID Value | %globals | %basic 21 | % ..." 
 -- ComputeVariant:B: "Value" 
 -- ObjTmpStack:add::genDone:false "Value" :"%ID Value | %globals | %basic 21 | % ..." 
 -- OG:markIS:"value |    %id "char" |    %globals |    %basic 3, 16 |    %public |   ..." 
 -- items:markForCodeGen:"%id "char" | %globals | %basic 3, 16 | %public | _thisBas ..." 
 -- markItem:"%id "char"" Property
 -- markItem:"%globals" Property
 -- markItem:"%basic 3, 16" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:"_thisBasicValue" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"Universal" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Universal" 
 -- "Universal" true
 -- 
 -- OG:markSuper:"Universal" 
 -- Invocation:markForCodeGen:"Universal" 
 -- ObjectInvocation:markForCodeGen:"Universal"  ATd:"universal: Value |    % ..." 
 -- Pattern:markForCodeGen:"universal: Value |    %ID universal |    %basic 1,  ..." 
 -- OG:markForCodeGen:"Value |    %ID universal |    %basic 1, 32 |    %globals |   ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Value" 
 -- "Value" true
 -- 
 -- OG:markSuper:"Value" 
 -- Invocation:markForCodeGen:"Value" 
 -- ObjectInvocation:markForCodeGen:"Value"  ATd:"Value:  |    %ID Value |    % ..." 
 -- Pattern:markForCodeGen:"Value:  |    %ID Value |    %globals |    %basic 21 |   ..." 
 -- OG:markIS:"Value |    %ID universal |    %basic 1, 32 |    %globals |    + :  |   ..." 
 -- items:markForCodeGen:"%ID universal | %basic 1, 32 | %globals | + :  |    %basi ..." 
 -- markItem:"%ID universal" Property
 -- markItem:"%basic 1, 32" Property
 -- markItem:"%globals" Property
 -- ComputeVariant:A:"universal" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"Value |    %ID universal |    %basic 1, 32 |    %globals |    + :  ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"Value" 
 -- ObjectInvocation:Qalloc:"Value" 
 -- name: "Value" 
 -- Arguments "" 
 -- OG:super: "Value:  |    %ID Value |    %globals |    %basic 21 |    %public |     ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "Value |    %ID universal |    %basic 1, 32 |    %globals |    + :  |       %basi ..." 
 -- super: "Value" 
 -- E: "Value" 
 -- OG:Qalloc:B:"universal" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:2 IS.newDescNo:2 objSize:0 varNo:1 "%ID unive ..." 
 -- Items:Qalloc:objSize:0  newDescNo:2 "%ID universal | %basic 1, 32 | %global ..." 
 -- Items:Qalloc:super:"Value" :super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:-
 -- Items:Qalloc:END:objSize:0  newDescNo:2 "%ID universal | %basic 1, 32 | %gl ..." 
 -- IS.newDescNo:2 IS.objSize:0 "%ID universal | %basic 1, 32 | %globals | + :  |   ..." 
 -- computeVariant:newDescNo:2  size: 0  IS:"%ID universal | %basic 1, 32 | %gl ..." 
 -- ComputeVariant:B: "universal" 
 -- ObjTmpStack:add::genDone:false "universal" :"Value |    %ID universal |     ..." 
 -- not ObjDesc: "Universal"  IS.isEmpty: true
 -- ComputeVariant:A:"char" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"value |    %id "char" |    %globals |    %basic 3, 16 |    %public ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"value" 
 -- ObjectInvocation:Qalloc:"value" 
 -- name: "value" 
 -- Arguments "" 
 -- OG:super: "Value:  |    %ID Value |    %globals |    %basic 21 |    %public |     ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "value |    %id "char" |    %globals |    %basic 3, 16 |    %public |    _thisBas ..." 
 -- super: "value" 
 -- E: "value" 
 -- OG:Qalloc:B:"char" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:3 IS.newDescNo:3 objSize:0 varNo:1 "%id "char ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:3 "%id "char" | %globals | %basic 3, 16 | % ..." 
 -- Items:Qalloc:super:"value" :super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:"_thisBasicValue" isValue:true isPrimitive:true isValOb ...true  ...true
 -- diSize:1 IT.qSize:1 
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:-
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<
 -- Pattern:Qalloc:<=
 -- Pattern:Qalloc:>
 -- Pattern:Qalloc:>=
 -- Pattern:Qalloc:<>
 -- Items:Qalloc:END:objSize:1  newDescNo:3 "%id "char" | %globals | %basic 3,  ..." 
 -- IS.newDescNo:3 IS.objSize:1 "%id "char" | %globals | %basic 3, 16 | %public | _ ..." 
 -- computeVariant:newDescNo:3  size: 1  IS:"%id "char" | %globals | %basic 3,  ..." 
 -- ComputeVariant:B: "char" 
 -- ObjTmpStack:add::genDone:false "char" :"value |    %id "char" |    %globals ..." 
 -- not ObjDesc: "char"  IS.isEmpty: true
 -- markItem:"newline := cr -- Windows/Linux???" ObjectGenerator
 -- OG:markForCodeGen:"newline := cr -- Windows/Linux???" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "newline := cr -- Windows/Linux???" 
 -- "newline" true
 -- ":= cr -- Windows/Linux???" true
 -- 
 -- OG:markSuper:"newline := cr -- Windows/Linux???" 
 -- Invocation:markForCodeGen:"newline := cr -- Windows/Linux???" 
 -- ObjectInvocation:markForCodeGen:"newline"  ATd:"newline: var char" 
 -- DataItem:markForCodeGen:"newline" :descNo:0 :OG.primNo:3 
 -- ObjectInvocation:markForCodeGen:":= cr -- Windows/Linux???"  ATd:":= :  ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- OG:markForCodeGen:"%basic 8 | in V: var Value" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%basic 8 | in V: var Value" 
 -- items:markForCodeGen:"%basic 8 | in V: var Value" 
 -- markItem:"%basic 8" Property
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:21 
 -- OG:markForCodeGen:"Value" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Value" 
 -- "Value" true
 -- 
 -- OG:markSuper:"Value" 
 -- Invocation:markForCodeGen:"Value" 
 -- ObjectInvocation:markForCodeGen:"Value"  ATd:"Value:  |    %ID Value |    % ..." 
 -- Pattern:markForCodeGen:"Value:  |    %ID Value |    %globals |    %basic 21 |   ..." 
 -- not ObjDesc: "Value"  IS.isEmpty: true
 -- ComputeVariant:A:":=" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%basic 8 | in V: var Value" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%basic 8 | in V: var Value" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:":=" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:4 IS.newDescNo:4 objSize:0 varNo:1 "%basic 8 |  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:4 "%basic 8 | in V: var Value" 
 -- Items:Qalloc:Super:C:objSize:2 originOff:1 
 -- dataitem:qalloc:"V" isValue:true isPrimitive:true isValObj: true isBasi ...false
 -- diSize:1 IT.qSize:3 
 -- Items:Qalloc:END:objSize:3  newDescNo:4 "%basic 8 | in V: var Value" 
 -- IS.newDescNo:4 IS.objSize:3 "%basic 8 | in V: var Value" 
 -- computeVariant:newDescNo:4  size: 3  IS:"%basic 8 | in V: var Value" 
 -- ComputeVariant:B: ":=" 
 -- ObjTmpStack:add::genDone:false ":= " :"%basic 8 | in V: var Value" 
 -- arg: "cr -- Windows/Linux???" 
 -- OG:markForCodeGen:"cr -- Windows/Linux???" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "cr -- Windows/Linux???" 
 -- "cr -- Windows/Linux???" true
 -- 
 -- not ObjDesc: "newline := cr -- Windows/Linux???"  IS.isEmpty: true
 -- ComputeVariant:A:"ascii" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"nl: val 10 | cr: val 13 | newline: var char | isLetter:  |    in c ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "nl: val 10 | cr: val 13 | newline: var char | isLetter:  |    in ch: var char |  ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"ascii" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:5 IS.newDescNo:5 objSize:0 varNo:1 "nl: val 1 ..." 
 -- Items:Qalloc:objSize:0  newDescNo:5 "nl: val 10 | cr: val 13 | newline: var ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"nl" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:2 
 -- dataitem:qalloc:"cr" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:3 
 -- dataitem:qalloc:"newline" isValue:true isPrimitive:true isValObj: true  ...true
 -- diSize:1 IT.qSize:4 
 -- Pattern:Qalloc:isLetter
 -- Pattern:Qalloc:B:isLetter
 -- Pattern:Qalloc:isDigit
 -- Pattern:Qalloc:B:isDigit
 -- OG:Qalloc:A:"newline := cr -- Windows/Linux???" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"newline := cr -- Windows/Linux???" 
 -- ObjectInvocation:Qalloc:"newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= cr -- Windows/Linux???" 
 -- name: ":=" 
 -- Arguments "cr -- Windows/Linux???" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "newline := cr -- Windows/Linux???" 
 -- super: "newline := cr -- Windows/Linux???" 
 -- E: ":= cr -- Windows/Linux???" 
 -- Items:Qalloc:END:objSize:4  newDescNo:5 "nl: val 10 | cr: val 13 | newline: ..." 
 -- IS.newDescNo:5 IS.objSize:4 "nl: val 10 | cr: val 13 | newline: var char | is ..." 
 -- computeVariant:newDescNo:5  size: 4  IS:"nl: val 10 | cr: val 13 | newline: ..." 
 -- ComputeVariant:B: "ascii" 
 -- ObjTmpStack:add::genDone:false "nl: val 10 | cr: val 13 | newline: var char ..." 
 -- ComputeVariant:A:"BETA" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%ID BETA | %OSDvisibility disguised | %public | universal: Value ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%ID BETA | %OSDvisibility disguised | %public | universal: Value |    %ID univ ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"BETA" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:6 IS.newDescNo:6 objSize:0 varNo:1 "%ID BETA |  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:6 "%ID BETA | %OSDvisibility disguised |  ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:universal
 -- Pattern:Qalloc:integer
 -- Pattern:Qalloc:Boolean
 -- Pattern:Qalloc:False
 -- Pattern:Qalloc:B:False
 -- Pattern:Qalloc:True
 -- Pattern:Qalloc:B:True
 -- Pattern:Qalloc:char
 -- Pattern:Qalloc:universalFloat
 -- Pattern:Qalloc:float
 -- Pattern:Qalloc:put
 -- Pattern:Qalloc:_iget
 -- Pattern:Qalloc:B:_iget
 -- Pattern:Qalloc:_kbhit
 -- Pattern:Qalloc:B:_kbhit
 -- Pattern:Qalloc:Object
 -- Pattern:Qalloc:Value
 -- Pattern:Qalloc:none
 -- Pattern:Qalloc:immutable
 -- Pattern:Qalloc:unique
 -- Pattern:Qalloc:B:unique
 -- Pattern:Qalloc:inner
 -- Pattern:Qalloc:@inner:
 -- Pattern:Qalloc:@this:
 -- Pattern:Qalloc:disable
 -- Pattern:Qalloc:enable
 -- Pattern:Qalloc:fork
 -- Pattern:Qalloc:sleep
 -- Pattern:Qalloc:core
 -- Pattern:Qalloc:B:core
 -- Pattern:Qalloc:thisCore
 -- Pattern:Qalloc:thisCoreId
 -- Pattern:Qalloc:inSub
 -- Pattern:Qalloc:method
 -- Pattern:Qalloc:B:method
 -- Pattern:Qalloc:disguised
 -- Pattern:Qalloc:B:disguised
 -- Pattern:Qalloc:SkipInternal
 -- Pattern:Qalloc:B:SkipInternal
 -- Pattern:Qalloc:Show
 -- Pattern:Qalloc:B:Show
 -- Pattern:Qalloc:Indexed
 -- Pattern:Qalloc:@if::then
 -- Pattern:Qalloc:@ifX::thenX
 -- Pattern:Qalloc:@restart:
 -- Pattern:Qalloc:@leave:
 -- Pattern:Qalloc:@if::then:else
 -- Pattern:Qalloc:B:@if::then:else
 -- Pattern:Qalloc:cycle
 -- Pattern:Qalloc:B:cycle
 -- Pattern:Qalloc:@for::to:do
 -- Pattern:Qalloc:B:@for::to:do
 -- Pattern:Qalloc:switch
 -- Pattern:Qalloc:B:switch
 -- Pattern:Qalloc:OLDswitch
 -- Pattern:Qalloc:B:OLDswitch
 -- Pattern:Qalloc:@xswitch:
 -- Pattern:Qalloc:B:@xswitch:
 -- dataitem:qalloc:"ascii" isValue:false isPrimitive:false isValObj: false  ...false
 -- DI:Qalloc:off:2 "ascii: obj  |    nl: val 10 |    cr: val 13 |    newline: va ..." 
 -- Pattern:Qalloc:newline
 -- Pattern:Qalloc:B:newline
 -- Pattern:Qalloc:putint
 -- Pattern:Qalloc:B:putint
 -- Pattern:Qalloc:exp
 -- Pattern:Qalloc:B:exp
 -- Pattern:Qalloc:sqrt
 -- Pattern:Qalloc:B:sqrt
 -- Pattern:Qalloc:log
 -- Pattern:Qalloc:putFloat
 -- Pattern:Qalloc:putFloatX
 -- Pattern:Qalloc:B:putFloatX
 -- ModuleItem:Qalloc: 
 -- Items:Qalloc:END:objSize:2  newDescNo:6 "%ID BETA | %OSDvisibility disgui ..." 
 -- IS.newDescNo:6 IS.objSize:2 "%ID BETA | %OSDvisibility disguised | %public |  ..." 
 -- computeVariant:newDescNo:6  size: 2  IS:"%ID BETA | %OSDvisibility disgui ..." 
 -- ComputeVariant:B: "BETA" 
 -- ObjTmpStack:add::genDone:false "%ID BETA | %OSDvisibility disguised | %publ ..." 
 -- OG:markForCodeGen:"%id "LIB" | %include BETA | x_dummy_LIB: var integer | " 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%id "LIB" | %include BETA | x_dummy_LIB: var integer | " 
 -- items:markForCodeGen:"%id "LIB" | %include BETA | x_dummy_LIB: var integer |  ..." 
 -- markItem:"%id "LIB"" Property
 -- markItem:"%include BETA" Property
 -- DataItem:markForCodeGen:"x_dummy_LIB" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- OG:markForCodeGen:"value |    %ID integer |    %basic 1, 32 |    %globals |     ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "value" 
 -- "value" true
 -- 
 -- OG:markSuper:"value" 
 -- Invocation:markForCodeGen:"value" 
 -- ObjectInvocation:markForCodeGen:"value"  ATd:"Value:  |    %ID Value |    % ..." 
 -- Pattern:markForCodeGen:"Value:  |    %ID Value |    %globals |    %basic 21 |   ..." 
 -- OG:markIS:"value |    %ID integer |    %basic 1, 32 |    %globals |    %public |  ..." 
 -- items:markForCodeGen:"%ID integer | %basic 1, 32 | %globals | %public | _thisBa ..." 
 -- markItem:"%ID integer" Property
 -- markItem:"%basic 1, 32" Property
 -- markItem:"%globals" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:"_thisBasicValue" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"Universal" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Universal" 
 -- "Universal" true
 -- 
 -- OG:markSuper:"Universal" 
 -- Invocation:markForCodeGen:"Universal" 
 -- ObjectInvocation:markForCodeGen:"Universal"  ATd:"universal: Value |    % ..." 
 -- Pattern:markForCodeGen:"universal: Value |    %ID universal |    %basic 1,  ..." 
 -- not ObjDesc: "Universal"  IS.isEmpty: true
 -- ComputeVariant:A:"integer" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"value |    %ID integer |    %basic 1, 32 |    %globals |    %publi ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"value" 
 -- ObjectInvocation:Qalloc:"value" 
 -- name: "value" 
 -- Arguments "" 
 -- OG:super: "Value:  |    %ID Value |    %globals |    %basic 21 |    %public |     ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "value |    %ID integer |    %basic 1, 32 |    %globals |    %public |    _thisBa ..." 
 -- super: "value" 
 -- E: "value" 
 -- OG:Qalloc:B:"integer" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:7 IS.newDescNo:7 objSize:0 varNo:1 "%ID integ ..." 
 -- Items:Qalloc:objSize:0  newDescNo:7 "%ID integer | %basic 1, 32 | %globals |  ..." 
 -- Items:Qalloc:super:"value" :super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:"_thisBasicValue" isValue:true isPrimitive:true isValOb ...true  ...true
 -- diSize:1 IT.qSize:1 
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:-
 -- Pattern:Qalloc:*
 -- Pattern:Qalloc:/
 -- Pattern:Qalloc://
 -- Pattern:Qalloc:/%
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<
 -- Pattern:Qalloc:<=
 -- Pattern:Qalloc:>
 -- Pattern:Qalloc:>=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:cmpAndSwap
 -- Items:Qalloc:END:objSize:1  newDescNo:7 "%ID integer | %basic 1, 32 | %glob ..." 
 -- IS.newDescNo:7 IS.objSize:1 "%ID integer | %basic 1, 32 | %globals | %public |  ..." 
 -- computeVariant:newDescNo:7  size: 1  IS:"%ID integer | %basic 1, 32 | %glob ..." 
 -- ComputeVariant:B: "integer" 
 -- ObjTmpStack:add::genDone:false "integer" :"value |    %ID integer |    %bas ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- OG:markForCodeGen:"%Public | Lock:  |    dummy: var integer |    %Public |    M ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%Public | Lock:  |    dummy: var integer |    %Public |    M: var in ..." 
 -- items:markForCodeGen:"%Public | Lock:  |    dummy: var integer |    %Public |   ..." 
 -- markItem:"%Public" Property
 -- DataItem:markForCodeGen:"keyboard" :descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:"%Public | readLine:  |    out M: ref LIB.String.String |   ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%Public | readLine:  |    out M: ref LIB.String.String |    inx: v ..." 
 -- items:markForCodeGen:"%Public | readLine:  |    out M: ref LIB.String.Strin ..." 
 -- markItem:"%Public" Property
 -- ComputeVariant:A:"keyboard" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%Public | readLine:  |    out M: ref LIB.String.String |    inx: ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%Public | readLine:  |    out M: ref LIB.String.String |    inx: var integer ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"keyboard" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:8 IS.newDescNo:8 objSize:0 varNo:1 "%Public | r ..." 
 -- Items:Qalloc:objSize:0  newDescNo:8 "%Public | readLine:  |    out M: ref L ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:readLine
 -- Pattern:Qalloc:B:readLine
 -- Items:Qalloc:END:objSize:1  newDescNo:8 "%Public | readLine:  |    out M: r ..." 
 -- IS.newDescNo:8 IS.objSize:1 "%Public | readLine:  |    out M: ref LIB.Strin ..." 
 -- computeVariant:newDescNo:8  size: 1  IS:"%Public | readLine:  |    out M: r ..." 
 -- ComputeVariant:B: "keyboard" 
 -- ObjTmpStack:add::genDone:false "%Public | readLine:  |    out M: ref LIB.St ..." 
 -- DataItem:markForCodeGen:"screen" :descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:"L: obj Lock | %Public | init:  |    L.get |    L.init |    L.f ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"L: obj Lock | %Public | init:  |    L.get |    L.init |    L.free | disp ..." 
 -- items:markForCodeGen:"L: obj Lock | %Public | init:  |    L.get |    L.init |     ..." 
 -- DataItem:markForCodeGen:"L" :descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:"Lock" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "Lock" 
 -- "Lock" false
 -- 
 -- OG:markSuper:"Lock" 
 -- Invocation:markForCodeGen:"Lock" 
 -- ObjectInvocation:markForCodeGen:"Lock"  ATd:"Lock:  |    dummy: var integ ..." 
 -- Pattern:markForCodeGen:"Lock:  |    dummy: var integer |    %Public |    M: v ..." 
 -- OG:markForCodeGen:"dummy: var integer | %Public | M: var integer | init:  |     ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"dummy: var integer | %Public | M: var integer | init:  |    M := 0 | g ..." 
 -- items:markForCodeGen:"dummy: var integer | %Public | M: var integer | init:  |  ..." 
 -- DataItem:markForCodeGen:"dummy" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- markItem:"%Public" Property
 -- DataItem:markForCodeGen:"M" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- ComputeVariant:A:"Lock" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"dummy: var integer | %Public | M: var integer | init:  |    M := 0 ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "dummy: var integer | %Public | M: var integer | init:  |    M := 0 | get:  |    re ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"Lock" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:9 IS.newDescNo:9 objSize:0 varNo:1 "dummy: va ..." 
 -- Items:Qalloc:objSize:0  newDescNo:9 "dummy: var integer | %Public | M: var  ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"dummy" isValue:true isPrimitive:true isValObj: true is ...true
 -- diSize:1 IT.qSize:2 
 -- dataitem:qalloc:"M" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:3 
 -- Pattern:Qalloc:init
 -- Pattern:Qalloc:B:init
 -- Pattern:Qalloc:get
 -- Pattern:Qalloc:B:get
 -- Pattern:Qalloc:free
 -- Pattern:Qalloc:B:free
 -- Items:Qalloc:END:objSize:3  newDescNo:9 "dummy: var integer | %Public | M:  ..." 
 -- IS.newDescNo:9 IS.objSize:3 "dummy: var integer | %Public | M: var integer |  ..." 
 -- computeVariant:newDescNo:9  size: 3  IS:"dummy: var integer | %Public | M:  ..." 
 -- ComputeVariant:B: "Lock" 
 -- ObjTmpStack:add::genDone:false "Lock" :"dummy: var integer | %Public | M: v ..." 
 -- not ObjDesc: "Lock"  IS.isEmpty: true
 -- markItem:"%Public" Property
 -- ComputeVariant:A:"screen" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"L: obj Lock | %Public | init:  |    L.get |    L.init |    L.free | di ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "L: obj Lock | %Public | init:  |    L.get |    L.init |    L.free | display:  |    L ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"screen" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:10 IS.newDescNo:10 objSize:0 varNo:1 "L: obj  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:10 "L: obj Lock | %Public | init:  |    L.g ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"L" isValue:false isPrimitive:false isValObj: false isB ...false
 -- DI:Qalloc:off:2 "L: obj Lock" 
 -- Pattern:Qalloc:init
 -- Pattern:Qalloc:B:init
 -- Pattern:Qalloc:display
 -- Pattern:Qalloc:B:display
 -- Items:Qalloc:END:objSize:2  newDescNo:10 "L: obj Lock | %Public | init:  |    ..." 
 -- IS.newDescNo:10 IS.objSize:2 "L: obj Lock | %Public | init:  |    L.get |    L. ..." 
 -- computeVariant:newDescNo:10  size: 2  IS:"L: obj Lock | %Public | init:  |    ..." 
 -- ComputeVariant:B: "screen" 
 -- ObjTmpStack:add::genDone:false "L: obj Lock | %Public | init:  |    L.get |     ..." 
 -- ComputeVariant:A:"BasicIO" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%Public | Lock:  |    dummy: var integer |    %Public |    M: var  ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%Public | Lock:  |    dummy: var integer |    %Public |    M: var integer |    i ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"BasicIO" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:11 IS.newDescNo:11 objSize:0 varNo:1 "%Public ..." 
 -- Items:Qalloc:objSize:0  newDescNo:11 "%Public | Lock:  |    dummy: var inte ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:Lock
 -- Pattern:Qalloc:B:Lock
 -- dataitem:qalloc:"keyboard" isValue:false isPrimitive:false isValObj: false  ...false
 -- DI:Qalloc:off:2 "keyboard: obj  |    %Public |    readLine:  |       out M: r ..." 
 -- dataitem:qalloc:"screen" isValue:false isPrimitive:false isValObj: false  ...false
 -- DI:Qalloc:off:3 "screen: obj  |    L: obj Lock |    %Public |    init:  |       ..." 
 -- Items:Qalloc:END:objSize:3  newDescNo:11 "%Public | Lock:  |    dummy: var  ..." 
 -- IS.newDescNo:11 IS.objSize:3 "%Public | Lock:  |    dummy: var integer |    % ..." 
 -- computeVariant:newDescNo:11  size: 3  IS:"%Public | Lock:  |    dummy: var  ..." 
 -- ComputeVariant:B: "BasicIO" 
 -- ObjTmpStack:add::genDone:false "%Public | Lock:  |    dummy: var integer |    ..." 
 -- OG:markForCodeGen:"%id "String module" | %public | String:  |    %id "String  ..."" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%id "String module" | %public | String:  |    %id "String pattern" ..." 
 -- items:markForCodeGen:"%id "String module" | %public | String:  |    %id "Stri ..."" 
 -- markItem:"%id "String module"" Property
 -- markItem:"%public" Property
 -- Items:markString%id "String module" | %public | String:  |    %id "String pat ..."
 -- Pattern:markForCodeGen:"String:  |    %id "String pattern" |    %OSDvisibil ..." 
 -- OG:markForCodeGen:"%id "String pattern" | %OSDvisibility disguised | %basic ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%id "String pattern" | %OSDvisibility disguised | %basic 5 | %immu ..." 
 -- items:markForCodeGen:"%id "String pattern" | %OSDvisibility disguised | %ba ..." 
 -- markItem:"%id "String pattern"" Property
 -- markItem:"%OSDvisibility disguised" Property
 -- markItem:"%basic 5" Property
 -- markItem:"%immutable" Property
 -- markItem:"%public" Property
 -- ComputeVariant:A:"String" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%id "String pattern" | %OSDvisibility disguised | %basic 5 | %im ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%id "String pattern" | %OSDvisibility disguised | %basic 5 | %immutable | %pub ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"String" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:12 IS.newDescNo:12 objSize:0 varNo:1 "%id "St ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:12 "%id "String pattern" | %OSDvisibili ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:length
 -- Pattern:Qalloc:B:length
 -- Pattern:Qalloc:@get:
 -- Pattern:Qalloc:+
 -- Pattern:Qalloc:B:+
 -- Pattern:Qalloc:asLowerCase
 -- Pattern:Qalloc:B:asLowerCase
 -- Pattern:Qalloc:scan
 -- Pattern:Qalloc:B:scan
 -- Pattern:Qalloc:print
 -- Pattern:Qalloc:B:print
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:B:=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:B:<>
 -- Pattern:Qalloc:<=
 -- Pattern:Qalloc:B:<=
 -- Items:Qalloc:END:objSize:1  newDescNo:12 "%id "String pattern" | %OSDvisi ..." 
 -- IS.newDescNo:12 IS.objSize:1 "%id "String pattern" | %OSDvisibility disgu ..." 
 -- computeVariant:newDescNo:12  size: 1  IS:"%id "String pattern" | %OSDvisi ..." 
 -- ComputeVariant:B: "String" 
 -- ObjTmpStack:add::genDone:false "String" :"%id "String pattern" | %OSDvisi ..." 
 -- ComputeVariant:A:"String" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%id "String module" | %public | String:  |    %id "String patter ..."" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%id "String module" | %public | String:  |    %id "String pattern" |    %OSDvi ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"String" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:13 IS.newDescNo:13 objSize:0 varNo:1 "%id "St ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:13 "%id "String module" | %public | Strin ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:String
 -- Pattern:Qalloc:C
 -- Pattern:Qalloc:B:C
 -- Pattern:Qalloc:I2S
 -- Pattern:Qalloc:B:I2S
 -- Items:Qalloc:END:objSize:1  newDescNo:13 "%id "String module" | %public | S ..." 
 -- IS.newDescNo:13 IS.objSize:1 "%id "String module" | %public | String:  |    % ..." 
 -- computeVariant:newDescNo:13  size: 1  IS:"%id "String module" | %public | S ..." 
 -- ComputeVariant:B: "String" 
 -- ObjTmpStack:add::genDone:false "%id "String module" | %public | String:  |    ..." 
 -- ComputeVariant:A:"LIB" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%id "LIB" | %include BETA | x_dummy_LIB: var integer | " 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%id "LIB" | %include BETA | x_dummy_LIB: var integer | " 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"LIB" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:14 IS.newDescNo:14 objSize:0 varNo:1 "%id "LI ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:14 "%id "LIB" | %include BETA | x_dummy_L ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"x_dummy_LIB" isValue:true isPrimitive:true isValObj: true  ...true
 -- diSize:1 IT.qSize:2 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:BasicIO
 -- Module:alloc:off:3 BasicIO: obj  |    %Public |    Lock:  |       dummy: var  ...
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:String
 -- Module:alloc:off:4 String: obj  |    %id "String module" |    %public |    St ...
 -- ModuleItem:Qalloc: 
 -- Items:Qalloc:END:objSize:4  newDescNo:14 "%id "LIB" | %include BETA | x_dum ..." 
 -- IS.newDescNo:14 IS.objSize:4 "%id "LIB" | %include BETA | x_dummy_LIB: var  ..." 
 -- computeVariant:newDescNo:14  size: 4  IS:"%id "LIB" | %include BETA | x_dum ..." 
 -- ComputeVariant:B: "LIB" 
 -- ObjTmpStack:add::genDone:false "%id "LIB" | %include BETA | x_dummy_LIB: va ..." 
 -- OG:markForCodeGen:"%id "workspace" | %include BETA, LIB, LIB.BasicIO | %dom ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%id "workspace" | %include BETA, LIB, LIB.BasicIO | %domain_boun ..." 
 -- items:markForCodeGen:"%id "workspace" | %include BETA, LIB, LIB.BasicIO | % ..." 
 -- markItem:"%id "workspace"" Property
 -- markItem:"%include BETA, LIB, LIB.BasicIO" Property
 -- markItem:"%domain_boundary" Property
 -- OG:markForCodeGen:"%include String | Y: var integer | chxxx: var char | chxxx ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%include String | Y: var integer | chxxx: var char | chxxx := 'a' |  ..." 
 -- items:markForCodeGen:"%include String | Y: var integer | chxxx: var char | ch ..." 
 -- markItem:"%include String" Property
 -- DataItem:markForCodeGen:"Y" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"chxxx" :descNo:0 :OG.primNo:3 
 -- OG:markForCodeGen:"char" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "char" 
 -- "char" true
 -- 
 -- OG:markSuper:"char" 
 -- Invocation:markForCodeGen:"char" 
 -- ObjectInvocation:markForCodeGen:"char"  ATd:"char: value |    %id "char" |  ..." 
 -- Pattern:markForCodeGen:"char: value |    %id "char" |    %globals |    %basic ..." 
 -- not ObjDesc: "char"  IS.isEmpty: true
 -- markItem:"chxxx := 'a'" ObjectGenerator
 -- OG:markForCodeGen:"chxxx := 'a'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "chxxx := 'a'" 
 -- "chxxx" true
 -- ":= 'a'" true
 -- 
 -- OG:markSuper:"chxxx := 'a'" 
 -- Invocation:markForCodeGen:"chxxx := 'a'" 
 -- ObjectInvocation:markForCodeGen:"chxxx"  ATd:"chxxx: var char" 
 -- DataItem:markForCodeGen:"chxxx" :descNo:0 :OG.primNo:3 
 -- ObjectInvocation:markForCodeGen:":= 'a'"  ATd:":= :  |    %basic 8 |    in  ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "'a'" 
 -- OG:markForCodeGen:"'a'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "'a'" 
 -- "'a'" true
 -- 
 -- OG:markSuper:"'a'" 
 -- Invocation:markForCodeGen:"'a'" 
 -- not ObjDesc: "'a'"  IS.isEmpty: true
 -- not ObjDesc: "chxxx := 'a'"  IS.isEmpty: true
 -- markItem:"loop" ObjectGenerator
 -- OG:markForCodeGen:"loop" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "loop" 
 -- "loop" false
 -- 
 -- OG:markSuper:"loop" 
 -- Invocation:markForCodeGen:"loop" 
 -- ObjectInvocation:markForCodeGen:"loop"  ATd:"loop:  |    switch(chxxx) |    ..." 
 -- Pattern:markForCodeGen:"loop:  |    switch(chxxx) |       case('a') |         ..." 
 -- OG:markForCodeGen:"switch(chxxx) |    case('a') |       "Got  a: ".print |    ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"switch(chxxx) |    case('a') |       "Got  a: ".print |    "else:" ..." 
 -- items:markForCodeGen:"switch(chxxx) |    case('a') |       "Got  a: ".print ..." 
 -- markItem:"switch(chxxx) |    case('a') |       "Got  a: ".print |    "else:". ..." O ...
 -- OG:markForCodeGen:"switch(chxxx) |    case('a') |       "Got  a: ".print |    ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "switch(chxxx)" 
 -- "switch(chxxx)" false
 -- 
 -- OG:markSuper:"switch(chxxx)" 
 -- Invocation:markForCodeGen:"switch(chxxx)" 
 -- ObjectInvocation:markForCodeGen:"switch(chxxx)"  ATd:"switch:  |    in V: ..." 
 -- Pattern:markForCodeGen:"switch:  |    in V: var integer |    %public |    cas ..." 
 -- OG:markForCodeGen:"in V: var integer | %public | case:  |    in x: ref Indexe ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"in V: var integer | %public | case:  |    in x: ref Indexed(1,#Int ..." 
 -- items:markForCodeGen:"in V: var integer | %public | case:  |    in x: ref Ind ..." 
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- markItem:"%public" Property
 -- markItem:"@inner switch" ObjectGenerator
 -- ComputeVariant:A:"switch" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"in V: var integer | %public | case:  |    in x: ref Indexed(1,#I ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "in V: var integer | %public | case:  |    in x: ref Indexed(1,#Integer) |    @ ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"switch" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:15 IS.newDescNo:15 objSize:0 varNo:1 "in V: v ..." 
 -- Items:Qalloc:objSize:0  newDescNo:15 "in V: var integer | %public | case:  |  ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"V" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:2 
 -- Pattern:Qalloc:case
 -- Pattern:Qalloc:B:case
 -- OG:Qalloc:A:"@inner switch" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@inner switch" 
 -- ObjectInvocation:Qalloc:"@inner switch" 
 -- name: "@inner" 
 -- Arguments "@inner switch" 
 -- OG:Qalloc:SuperAlloc:"@inner:  |    %basic 101 |    in inner: ref Object" 
 -- OG:Qalloc:A:"%basic 101 | in inner: ref Object" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%basic 101 | in inner: ref Object" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@inner:" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:16 IS.newDescNo:16 objSize:0 varNo:1 "%basic  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:16 "%basic 101 | in inner: ref Object" 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"inner" isValue:false isPrimitive:true isValObj: false  ...false
 -- DI:Qalloc:off:2 "in inner: ref Object" 
 -- Items:Qalloc:END:objSize:2  newDescNo:16 "%basic 101 | in inner: ref Obje ..." 
 -- IS.newDescNo:16 IS.objSize:2 "%basic 101 | in inner: ref Object" 
 -- OG:super: "@inner:  |    %basic 101 |    in inner: ref Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@inner switch" 
 -- super: "@inner switch" 
 -- E: "@inner switch" 
 -- Items:Qalloc:END:objSize:2  newDescNo:15 "in V: var integer | %public | cas ..." 
 -- IS.newDescNo:15 IS.objSize:2 "in V: var integer | %public | case:  |    in x: ..." 
 -- computeVariant:newDescNo:15  size: 2  IS:"in V: var integer | %public | cas ..." 
 -- ComputeVariant:B: "switch" 
 -- ObjTmpStack:add::genDone:false "switch" :"in V: var integer | %public | cas ..." 
 -- arg: "chxxx" 
 -- OG:markForCodeGen:"chxxx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "chxxx" 
 -- "chxxx" true
 -- 
 -- OG:markIS:"switch(chxxx) |    case('a') |       "Got  a: ".print |    "else:" ..." 
 -- items:markForCodeGen:"case('a') |    "Got  a: ".print | "else:".print | @if a ..." 
 -- markItem:"case('a') |    "Got  a: ".print" ObjectGenerator
 -- OG:markForCodeGen:"case('a') |    "Got  a: ".print" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "case('a')" 
 -- "case('a')" false
 -- 
 -- OG:markSuper:"case('a')" 
 -- Invocation:markForCodeGen:"case('a')" 
 -- ObjectInvocation:markForCodeGen:"case('a')"  ATd:"case:  |    in x: ref I ..." 
 -- Pattern:markForCodeGen:"case:  |    in x: ref Indexed(1,#Integer) |    @for ..." 
 -- OG:markForCodeGen:"in x: ref Indexed(1,#Integer) | @for 1 :to x.length  | : ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"in x: ref Indexed(1,#Integer) | @for 1 :to x.length  | :do  |    @ ..." 
 -- items:markForCodeGen:"in x: ref Indexed(1,#Integer) | @for 1 :to x.length ..." 
 -- DataItem:markForCodeGen:"x" :descNo:0 :OG.primNo:114 
 -- markItem:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |      ..." O ...
 -- OG:markForCodeGen:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :t ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |       @inner  ..." 
 -- "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |       @inner  ..." false
 -- 
 -- OG:markSuper:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |  ..." 
 -- Invocation:markForCodeGen:"@for 1 :to x.length  | :do  |    @if (V = x.@get ..." 
 -- ObjectInvocation:markForCodeGen:"@for 1 :to x.length  | :do  |    @if (V =  ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@for:  |    %globals inSub |    in for: var integer ..." 
 -- OG:markForCodeGen:"%globals inSub | in for: var integer | in to: var intege ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%globals inSub | in for: var integer | in to: var integer | in do: ..." 
 -- items:markForCodeGen:"%globals inSub | in for: var integer | in to: var int ..." 
 -- markItem:"%globals inSub" Property
 -- DataItem:markForCodeGen:"for" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"to" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- Pattern:markForCodeGen:"in do:< Object" 
 -- OG:markForCodeGen:"Object" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Object" 
 -- "Object" true
 -- 
 -- not ObjDesc: "Object"  IS.isEmpty: true
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:"inx" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- markItem:"%private" Property
 -- markItem:"inx := for" ObjectGenerator
 -- OG:markForCodeGen:"inx := for" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "inx := for" 
 -- "inx" true
 -- ":= for" true
 -- 
 -- OG:markSuper:"inx := for" 
 -- Invocation:markForCodeGen:"inx := for" 
 -- ObjectInvocation:markForCodeGen:"inx"  ATd:"inx: var integer" 
 -- DataItem:markForCodeGen:"inx" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= for"  ATd:":= :  |    %basic 8 |    in  ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "for" 
 -- OG:markForCodeGen:"for" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "for" 
 -- "for" true
 -- 
 -- not ObjDesc: "inx := for"  IS.isEmpty: true
 -- markItem:"doIt" ObjectGenerator
 -- OG:markForCodeGen:"doIt" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "doIt" 
 -- "doIt" false
 -- 
 -- OG:markSuper:"doIt" 
 -- Invocation:markForCodeGen:"doIt" 
 -- ObjectInvocation:markForCodeGen:"doIt"  ATd:"doIt:  |    loop: obj  |       ..." 
 -- Pattern:markForCodeGen:"doIt:  |    loop: obj  |       @if inx <= to :then  ..." 
 -- OG:markForCodeGen:"loop: obj  |    @if inx <= to :then  |       do |       in ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"loop: obj  |    @if inx <= to :then  |       do |       inx := inx ..." 
 -- items:markForCodeGen:"loop: obj  |    @if inx <= to :then  |       do |       ..." 
 -- DataItem:markForCodeGen:"loop" :descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:"@if inx <= to :then  |    do |    inx := inx + 1 |    @res ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loo ..." 
 -- items:markForCodeGen:"@if inx <= to :then  |    do |    inx := inx + 1 |    @ ..." 
 -- markItem:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop ..." O ...
 -- OG:markForCodeGen:"@if inx <= to :then  |    do |    inx := inx + 1 |    @res ..." 
 -- isObjectDesc:false isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" 
 -- "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" true
 -- 
 -- OG:markSuper:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart  ..." 
 -- Invocation:markForCodeGen:"@if inx <= to :then  |    do |    inx := inx + 1 ..." 
 -- ObjectInvocation:markForCodeGen:"@if inx <= to :then  |    do |    inx := i ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@if:  |    %globals inSub |    %basic 100 |    in if: ..." 
 -- OG:markForCodeGen:"%globals inSub | %basic 100 | in if: var boolean | in then ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%globals inSub | %basic 100 | in if: var boolean | in then:< Objec ..." 
 -- items:markForCodeGen:"%globals inSub | %basic 100 | in if: var boolean | in t ..." 
 -- markItem:"%globals inSub" Property
 -- markItem:"%basic 100" Property
 -- DataItem:markForCodeGen:"if" :descNo:0 :OG.primNo:4 
 -- OG:markForCodeGen:"boolean" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "boolean" 
 -- "boolean" true
 -- 
 -- OG:markSuper:"boolean" 
 -- Invocation:markForCodeGen:"boolean" 
 -- ObjectInvocation:markForCodeGen:"boolean"  ATd:"Boolean: value |    %glob ..." 
 -- Pattern:markForCodeGen:"Boolean: value |    %globals inSub |    %basic 4, 8 ..." 
 -- OG:markForCodeGen:"value |    %globals inSub |    %basic 4, 8 |    %public |    ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "value" 
 -- "value" true
 -- 
 -- OG:markSuper:"value" 
 -- Invocation:markForCodeGen:"value" 
 -- ObjectInvocation:markForCodeGen:"value"  ATd:"Value:  |    %ID Value |    % ..." 
 -- Pattern:markForCodeGen:"Value:  |    %ID Value |    %globals |    %basic 21 |   ..." 
 -- OG:markIS:"value |    %globals inSub |    %basic 4, 8 |    %public |    _thisBa ..." 
 -- items:markForCodeGen:"%globals inSub | %basic 4, 8 | %public | _thisBasicValu ..." 
 -- markItem:"%globals inSub" Property
 -- markItem:"%basic 4, 8" Property
 -- markItem:"%public" Property
 -- DataItem:markForCodeGen:"_thisBasicValue" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"Universal" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Universal" 
 -- "Universal" true
 -- 
 -- OG:markSuper:"Universal" 
 -- Invocation:markForCodeGen:"Universal" 
 -- ObjectInvocation:markForCodeGen:"Universal"  ATd:"universal: Value |    % ..." 
 -- Pattern:markForCodeGen:"universal: Value |    %ID universal |    %basic 1,  ..." 
 -- not ObjDesc: "Universal"  IS.isEmpty: true
 -- ComputeVariant:A:"Boolean" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:Value
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"value |    %globals inSub |    %basic 4, 8 |    %public |    _this ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"value" 
 -- ObjectInvocation:Qalloc:"value" 
 -- name: "value" 
 -- Arguments "" 
 -- OG:super: "Value:  |    %ID Value |    %globals |    %basic 21 |    %public |     ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "value |    %globals inSub |    %basic 4, 8 |    %public |    _thisBasicValue:  ..." 
 -- super: "value" 
 -- E: "value" 
 -- OG:Qalloc:B:"Boolean" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:17 IS.newDescNo:17 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:17 "%globals inSub | %basic 4, 8 | %publi ..." 
 -- Items:Qalloc:super:"value" :super:size:0 :noGlobalsInSuper:true
 -- Items:Qalloc:super:B:objSize:0 originOff:0 
 -- dataitem:qalloc:"_thisBasicValue" isValue:true isPrimitive:true isValOb ...true  ...true
 -- diSize:1 IT.qSize:1 
 -- Pattern:Qalloc:&&
 -- Pattern:Qalloc:||
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:not
 -- Items:Qalloc:END:objSize:1  newDescNo:17 "%globals inSub | %basic 4, 8 | %p ..." 
 -- IS.newDescNo:17 IS.objSize:1 "%globals inSub | %basic 4, 8 | %public | _thisB ..." 
 -- computeVariant:newDescNo:17  size: 1  IS:"%globals inSub | %basic 4, 8 | %p ..." 
 -- ComputeVariant:B: "Boolean" 
 -- ObjTmpStack:add::genDone:false "Boolean" :"value |    %globals inSub |    % ..." 
 -- not ObjDesc: "boolean"  IS.isEmpty: true
 -- Pattern:markForCodeGen:"in then:< Object" 
 -- OG:markForCodeGen:"Object" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Object" 
 -- "Object" true
 -- 
 -- not ObjDesc: "Object"  IS.isEmpty: true
 -- ComputeVariant:A:"@if::then" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%globals inSub | %basic 100 | in if: var boolean | in then:< Obj ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:SuperAlloc:"Object:  |    %ID Object |    %basic 64 |    %public |    ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%globals inSub | %basic 100 | in if: var boolean | in then:< Object" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@if::then" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:18 IS.newDescNo:18 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:18 "%globals inSub | %basic 100 | in if:  ..." 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:"if" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:1 
 -- Pattern:Qalloc:then
 -- Pattern:Qalloc:B:then
 -- (OG.super.desc).newDescNo = 0
 -- OG:Qalloc:A:"%ID Object | %basic 64 | %public | := :  |    %basic 8 |    in V: va ..." 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%ID Object | %basic 64 | %public | := :  |    %basic 8 |    in V: var Value | :- : ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"Object" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:19 IS.newDescNo:19 objSize:0 varNo:1 "%ID Obj ..." 
 -- Items:Qalloc:objSize:0  newDescNo:19 "%ID Object | %basic 64 | %public | := : ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc::=
 -- Pattern:Qalloc::-
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:suspend
 -- Pattern:Qalloc:attach
 -- Pattern:Qalloc:resume
 -- Pattern:Qalloc:onResume
 -- Pattern:Qalloc:onSuspend
 -- Pattern:Qalloc:dumpObj
 -- OG:Qalloc:A:"@inner Object" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@inner Object" 
 -- ObjectInvocation:Qalloc:"@inner Object" 
 -- name: "@inner" 
 -- Arguments "@inner Object" 
 -- OG:super: "@inner:  |    %basic 101 |    in inner: ref Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@inner Object" 
 -- super: "@inner Object" 
 -- E: "@inner Object" 
 -- Items:Qalloc:END:objSize:1  newDescNo:19 "%ID Object | %basic 64 | %public |  ..." 
 -- IS.newDescNo:19 IS.objSize:1 "%ID Object | %basic 64 | %public | := :  |    %ba ..." 
 -- Pattern:qalloc:super:descNo:19 in then:< Object
 -- Items:Qalloc:END:objSize:1  newDescNo:18 "%globals inSub | %basic 100 | in  ..." 
 -- IS.newDescNo:18 IS.objSize:1 "%globals inSub | %basic 100 | in if: var bool ..." 
 -- computeVariant:newDescNo:18  size: 1  IS:"%globals inSub | %basic 100 | in  ..." 
 -- ComputeVariant:B: "@if::then" 
 -- ObjTmpStack:add::genDone:false "" :"%globals inSub | %basic 100 | in if: va ..." 
 -- arg: "inx <= to" 
 -- OG:markForCodeGen:"inx <= to" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "inx <= to" 
 -- "inx" true
 -- "<= to" true
 -- 
 -- OG:markSuper:"inx <= to" 
 -- Invocation:markForCodeGen:"inx <= to" 
 -- ObjectInvocation:markForCodeGen:"inx"  ATd:"inx: var integer" 
 -- DataItem:markForCodeGen:"inx" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:"<= to"  ATd:"<= :  |    %basic 52 |    in  ..." 
 -- Pattern:markForCodeGen:"<= :  |    %basic 52 |    in V: var integer |    out  ..." 
 -- arg: "to" 
 -- OG:markForCodeGen:"to" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "to" 
 -- "to" true
 -- 
 -- not ObjDesc: "inx <= to"  IS.isEmpty: true
 -- arg: "do | inx := inx + 1 | @restart loop" 
 -- OG:markForCodeGen:"do | inx := inx + 1 | @restart loop" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"do | inx := inx + 1 | @restart loop" 
 -- items:markForCodeGen:"do | inx := inx + 1 | @restart loop" 
 -- markItem:"do" ObjectGenerator
 -- OG:markForCodeGen:"do" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "do" 
 -- "do" false
 -- 
 -- OG:markSuper:"do" 
 -- Invocation:markForCodeGen:"do" 
 -- ObjectInvocation:markForCodeGen:"do"  ATd:"in do:< Object" 
 -- Pattern:markForCodeGen:"in do:< Object" 
 -- not ObjDesc: "do"  IS.isEmpty: true
 -- markItem:"inx := inx + 1" ObjectGenerator
 -- OG:markForCodeGen:"inx := inx + 1" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "inx := inx + 1" 
 -- "inx" true
 -- ":= inx + 1" true
 -- 
 -- OG:markSuper:"inx := inx + 1" 
 -- Invocation:markForCodeGen:"inx := inx + 1" 
 -- ObjectInvocation:markForCodeGen:"inx"  ATd:"inx: var integer" 
 -- DataItem:markForCodeGen:"inx" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= inx + 1"  ATd:":= :  |    %basic 8 |    ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "inx + 1" 
 -- OG:markForCodeGen:"inx + 1" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "inx + 1" 
 -- "inx" true
 -- "+ 1" true
 -- 
 -- OG:markSuper:"inx + 1" 
 -- Invocation:markForCodeGen:"inx + 1" 
 -- ObjectInvocation:markForCodeGen:"inx"  ATd:"inx: var integer" 
 -- DataItem:markForCodeGen:"inx" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:"+ 1"  ATd:"+ :  |    %basic 61 |    in V:  ..." 
 -- Pattern:markForCodeGen:"+ :  |    %basic 61 |    in V: var integer |    out R ..." 
 -- arg: "1" 
 -- OG:markForCodeGen:"1" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "1" 
 -- "1" true
 -- 
 -- OG:markSuper:"1" 
 -- Invocation:markForCodeGen:"1" 
 -- not ObjDesc: "1"  IS.isEmpty: true
 -- not ObjDesc: "inx + 1"  IS.isEmpty: true
 -- not ObjDesc: "inx := inx + 1"  IS.isEmpty: true
 -- markItem:"@restart loop" ObjectGenerator
 -- ComputeVariant:A:"#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"do | inx := inx + 1 | @restart loop" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "do | inx := inx + 1 | @restart loop" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:20 IS.newDescNo:20 objSize:0 varNo:1 "do | inx  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:20 "do | inx := inx + 1 | @restart loop" 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:"do" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"do" 
 -- ObjectInvocation:Qalloc:"do" 
 -- name: "do" 
 -- Arguments "" 
 -- OG:super: "in do:< Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "do" 
 -- super: "do" 
 -- E: "do" 
 -- OG:Qalloc:A:"inx := inx + 1" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"inx := inx + 1" 
 -- ObjectInvocation:Qalloc:"inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= inx + 1" 
 -- name: ":=" 
 -- Arguments "inx + 1" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "inx := inx + 1" 
 -- super: "inx := inx + 1" 
 -- E: ":= inx + 1" 
 -- OG:Qalloc:A:"@restart loop" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@restart loop" 
 -- ObjectInvocation:Qalloc:"@restart loop" 
 -- name: "@restart" 
 -- Arguments "@restart loop" 
 -- OG:Qalloc:SuperAlloc:"@restart:  |    %basic 102 |    in restart: var integ ..." 
 -- OG:Qalloc:A:"%basic 102 | in restart: var integer" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%basic 102 | in restart: var integer" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@restart:" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:21 IS.newDescNo:21 objSize:0 varNo:1 "%basic  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:21 "%basic 102 | in restart: var intege ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"restart" isValue:true isPrimitive:true isValObj: true  ...true
 -- diSize:1 IT.qSize:2 
 -- Items:Qalloc:END:objSize:2  newDescNo:21 "%basic 102 | in restart: var in ..." 
 -- IS.newDescNo:21 IS.objSize:2 "%basic 102 | in restart: var integer" 
 -- OG:super: "@restart:  |    %basic 102 |    in restart: var integer" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@restart loop" 
 -- super: "@restart loop" 
 -- E: "@restart loop" 
 -- Items:Qalloc:END:objSize:1  newDescNo:20 "do | inx := inx + 1 | @restart lo ..." 
 -- IS.newDescNo:20 IS.objSize:1 "do | inx := inx + 1 | @restart loop" 
 -- computeVariant:newDescNo:20  size: 1  IS:"do | inx := inx + 1 | @restart lo ..." 
 -- ComputeVariant:B: "#S#20" 
 -- ObjTmpStack:add::genDone:false "do | inx := inx + 1 | @restart loop" 
 -- not ObjDesc: "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart  ..."   ...true
 -- ComputeVariant:A:"loop" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart l ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"loop" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:22 IS.newDescNo:22 objSize:0 varNo:1 "@if inx ..." 
 -- Items:Qalloc:objSize:0  newDescNo:22 "@if inx <= to :then  |    do |    inx ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart l ..." 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@if inx <= to :then  |    do |    inx := inx + 1 |    @res ..." 
 -- ObjectInvocation:Qalloc:"@if inx <= to :then  |    do |    inx := inx + 1 |   ..." 
 -- name: "@if::then" 
 -- Arguments "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loo ..." 
 -- OG:super: "@if:  |    %globals inSub |    %basic 100 |    in if: var boolean |  ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: true
 -- "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" 
 -- super: "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" 
 -- E: "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" 
 -- Items:Qalloc:END:objSize:1  newDescNo:22 "@if inx <= to :then  |    do |    ..." 
 -- IS.newDescNo:22 IS.objSize:1 "@if inx <= to :then  |    do |    inx := inx  ..." 
 -- computeVariant:newDescNo:22  size: 1  IS:"@if inx <= to :then  |    do |    ..." 
 -- ComputeVariant:B: "loop" 
 -- ObjTmpStack:add::genDone:false "@if inx <= to :then  |    do |    inx := in ..." 
 -- ComputeVariant:A:"doIt" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"loop: obj  |    @if inx <= to :then  |       do |       inx := i ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "loop: obj  |    @if inx <= to :then  |       do |       inx := inx + 1 |       ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"doIt" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:23 IS.newDescNo:23 objSize:0 varNo:1 "loop: o ..." 
 -- Items:Qalloc:objSize:0  newDescNo:23 "loop: obj  |    @if inx <= to :then ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"loop" isValue:false isPrimitive:false isValObj: false  ...false
 -- DI:Qalloc:off:2 "loop: obj  |    @if inx <= to :then  |       do |       inx  ..." 
 -- Items:Qalloc:END:objSize:2  newDescNo:23 "loop: obj  |    @if inx <= to : ..." 
 -- IS.newDescNo:23 IS.objSize:2 "loop: obj  |    @if inx <= to :then  |        ..." 
 -- computeVariant:newDescNo:23  size: 2  IS:"loop: obj  |    @if inx <= to : ..." 
 -- ComputeVariant:B: "doIt" 
 -- ObjTmpStack:add::genDone:false "doIt" :"loop: obj  |    @if inx <= to :th ..." 
 -- not ObjDesc: "doIt"  IS.isEmpty: true
 -- markItem:"@inner for" ObjectGenerator
 -- ComputeVariant:A:"@for::to:do" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%globals inSub | in for: var integer | in to: var integer | in d ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%globals inSub | in for: var integer | in to: var integer | in do:< Object | % ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@for::to:do" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:24 IS.newDescNo:24 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:24 "%globals inSub | in for: var intege ..." 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:"for" isValue:true isPrimitive:true isValObj: true isBa ...true
 -- diSize:1 IT.qSize:1 
 -- dataitem:qalloc:"to" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:2 
 -- Pattern:Qalloc:do
 -- Pattern:Qalloc:B:do
 -- dataitem:qalloc:"inx" isValue:true isPrimitive:true isValObj: true isBa ...true
 -- diSize:1 IT.qSize:3 
 -- Pattern:Qalloc:doIt
 -- Pattern:Qalloc:B:doIt
 -- OG:Qalloc:A:"inx := for" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"inx := for" 
 -- ObjectInvocation:Qalloc:"inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= for" 
 -- name: ":=" 
 -- Arguments "for" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "inx := for" 
 -- super: "inx := for" 
 -- E: ":= for" 
 -- OG:Qalloc:A:"doIt" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"doIt" 
 -- ObjectInvocation:Qalloc:"doIt" 
 -- name: "doIt" 
 -- Arguments "" 
 -- OG:super: "doIt:  |    loop: obj  |       @if inx <= to :then  |          do |  ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "doIt" 
 -- super: "doIt" 
 -- E: "doIt" 
 -- OG:Qalloc:A:"@inner for" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@inner for" 
 -- ObjectInvocation:Qalloc:"@inner for" 
 -- name: "@inner" 
 -- Arguments "@inner for" 
 -- OG:super: "@inner:  |    %basic 101 |    in inner: ref Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@inner for" 
 -- super: "@inner for" 
 -- E: "@inner for" 
 -- Items:Qalloc:END:objSize:3  newDescNo:24 "%globals inSub | in for: var in ..." 
 -- IS.newDescNo:24 IS.objSize:3 "%globals inSub | in for: var integer | in to: ..." 
 -- computeVariant:newDescNo:24  size: 3  IS:"%globals inSub | in for: var in ..." 
 -- ComputeVariant:B: "@for::to:do" 
 -- ObjTmpStack:add::genDone:false "" :"%globals inSub | in for: var integer |  ..." 
 -- arg: "1" 
 -- OG:markForCodeGen:"1" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "1" 
 -- "1" true
 -- 
 -- OG:markSuper:"1" 
 -- Invocation:markForCodeGen:"1" 
 -- not ObjDesc: "1"  IS.isEmpty: true
 -- arg: "x.length" 
 -- OG:markForCodeGen:"x.length" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "x.length" 
 -- "x" true
 -- "length" false
 -- 
 -- OG:markSuper:"x.length" 
 -- Invocation:markForCodeGen:"x.length" 
 -- ObjectInvocation:markForCodeGen:"x"  ATd:"in x: ref Indexed(1,#Integer) ..." 
 -- DataItem:markForCodeGen:"x" :descNo:0 :OG.primNo:114 
 -- ObjectInvocation:markForCodeGen:"length"  ATd:"length:  |    out res: var ..." 
 -- Pattern:markForCodeGen:"length:  |    out res: var integer |    res := @get ..." 
 -- OG:markForCodeGen:"out res: var integer | res := @get 0" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"out res: var integer | res := @get 0" 
 -- items:markForCodeGen:"out res: var integer | res := @get 0" 
 -- DataItem:markForCodeGen:"res" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- markItem:"res := @get 0" ObjectGenerator
 -- OG:markForCodeGen:"res := @get 0" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "res := @get 0" 
 -- "res" true
 -- ":= @get 0" true
 -- 
 -- OG:markSuper:"res := @get 0" 
 -- Invocation:markForCodeGen:"res := @get 0" 
 -- ObjectInvocation:markForCodeGen:"res"  ATd:"out res: var integer" 
 -- DataItem:markForCodeGen:"res" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= @get 0"  ATd:":= :  |    %basic 8 |     ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "@get 0" 
 -- not ObjDesc: "res := @get 0"  IS.isEmpty: true
 -- ComputeVariant:A:"length" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"out res: var integer | res := @get 0" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "out res: var integer | res := @get 0" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"length" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:25 IS.newDescNo:25 objSize:0 varNo:1 "out res ..." 
 -- Items:Qalloc:objSize:0  newDescNo:25 "out res: var integer | res := @get  ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"res" isValue:true isPrimitive:true isValObj: true isBa ...true
 -- diSize:1 IT.qSize:2 
 -- OG:Qalloc:A:"res := @get 0" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"res := @get 0" 
 -- ObjectInvocation:Qalloc:"res" 
 -- name: "res" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= @get 0" 
 -- name: ":=" 
 -- Arguments "@get 0" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "res := @get 0" 
 -- super: "res := @get 0" 
 -- E: ":= @get 0" 
 -- Items:Qalloc:END:objSize:2  newDescNo:25 "out res: var integer | res := @ ..." 
 -- IS.newDescNo:25 IS.objSize:2 "out res: var integer | res := @get 0" 
 -- computeVariant:newDescNo:25  size: 2  IS:"out res: var integer | res := @ ..." 
 -- ComputeVariant:B: "length" 
 -- ObjTmpStack:add::genDone:false "length" :"out res: var integer | res := @ ..." 
 -- not ObjDesc: "x.length"  IS.isEmpty: true
 -- arg: "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- OG:markForCodeGen:"@if (V = x.@get inx) :then  |    @inner case |    @leave ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- items:markForCodeGen:"@if (V = x.@get inx) :then  |    @inner case |    @le ..." 
 -- markItem:"@if (V = x.@get inx) :then  |    @inner case |    @leave switch" O ...
 -- OG:markForCodeGen:"@if (V = x.@get inx) :then  |    @inner case |    @leave ..." 
 -- isObjectDesc:false isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" true
 -- 
 -- OG:markSuper:"@if (V = x.@get inx) :then  |    @inner case |    @leave swit ..." 
 -- Invocation:markForCodeGen:"@if (V = x.@get inx) :then  |    @inner case |   ..." 
 -- ObjectInvocation:markForCodeGen:"@if (V = x.@get inx) :then  |    @inner  ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@if:  |    %globals inSub |    %basic 100 |    in if: ..." 
 -- arg: "(V = x.@get inx)" 
 -- OG:markForCodeGen:"(V = x.@get inx)" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "(V = x.@get inx)" 
 -- "(V = x.@get inx)" true
 -- 
 -- OG:markSuper:"(V = x.@get inx)" 
 -- Invocation:markForCodeGen:"(V = x.@get inx)" 
 -- Invocation:markForCodeGen:"V = x.@get inx" 
 -- ObjectInvocation:markForCodeGen:"V"  ATd:"in V: var integer" 
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:"= x.@get inx"  ATd:"= :  |    %basic 50 |  ..." 
 -- Pattern:markForCodeGen:"= :  |    %basic 50 |    in V: var integer |    out B ..." 
 -- arg: "x.@get inx" 
 -- not ObjDesc: "(V = x.@get inx)"  IS.isEmpty: true
 -- arg: "@inner case | @leave switch" 
 -- OG:markForCodeGen:"@inner case | @leave switch" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"@inner case | @leave switch" 
 -- items:markForCodeGen:"@inner case | @leave switch" 
 -- markItem:"@inner case" ObjectGenerator
 -- markItem:"@leave switch" ObjectGenerator
 -- ComputeVariant:A:"#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@inner case | @leave switch" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@inner case | @leave switch" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:26 IS.newDescNo:26 objSize:0 varNo:1 "@inner  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:26 "@inner case | @leave switch" 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:"@inner case" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@inner case" 
 -- ObjectInvocation:Qalloc:"@inner case" 
 -- name: "@inner" 
 -- Arguments "@inner case" 
 -- OG:super: "@inner:  |    %basic 101 |    in inner: ref Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@inner case" 
 -- super: "@inner case" 
 -- E: "@inner case" 
 -- OG:Qalloc:A:"@leave switch" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@leave switch" 
 -- ObjectInvocation:Qalloc:"@leave switch" 
 -- name: "@leave" 
 -- Arguments "@leave switch" 
 -- OG:Qalloc:SuperAlloc:"@leave:  |    %basic 103 |    in leave: var integer" 
 -- OG:Qalloc:A:"%basic 103 | in leave: var integer" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%basic 103 | in leave: var integer" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@leave:" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:27 IS.newDescNo:27 objSize:0 varNo:1 "%basic  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:27 "%basic 103 | in leave: var integer" 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"leave" isValue:true isPrimitive:true isValObj: true is ...true
 -- diSize:1 IT.qSize:2 
 -- Items:Qalloc:END:objSize:2  newDescNo:27 "%basic 103 | in leave: var inte ..." 
 -- IS.newDescNo:27 IS.objSize:2 "%basic 103 | in leave: var integer" 
 -- OG:super: "@leave:  |    %basic 103 |    in leave: var integer" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@leave switch" 
 -- super: "@leave switch" 
 -- E: "@leave switch" 
 -- Items:Qalloc:END:objSize:1  newDescNo:26 "@inner case | @leave switch" 
 -- IS.newDescNo:26 IS.objSize:1 "@inner case | @leave switch" 
 -- computeVariant:newDescNo:26  size: 1  IS:"@inner case | @leave switch" 
 -- ComputeVariant:B: "#S#26" 
 -- ObjTmpStack:add::genDone:false "@inner case | @leave switch" 
 -- not ObjDesc: "@if (V = x.@get inx) :then  |    @inner case |    @leave swit ..."   ...true
 -- ComputeVariant:A:"do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:do
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- OG:Qalloc:A:"Object" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"Object" 
 -- ObjectInvocation:Qalloc:"Object" 
 -- name: "Object" 
 -- Arguments "" 
 -- OG:super: "Object:  |    %ID Object |    %basic 64 |    %public |    := :  |      ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "Object" 
 -- super: "Object" 
 -- E: "Object" 
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@if (V = x.@get inx) :then  |    @inner case |    @leave switc ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"do#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:28 IS.newDescNo:28 objSize:0 varNo:1 "@if (V  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:28 "@if (V = x.@get inx) :then  |    @i ..." 
 -- Items:Qalloc:super:"" :super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- OG:Qalloc:A:"@if (V = x.@get inx) :then  |    @inner case |    @leave switc ..." 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@if (V = x.@get inx) :then  |    @inner case |    @leave ..." 
 -- ObjectInvocation:Qalloc:"@if (V = x.@get inx) :then  |    @inner case |     ..." 
 -- name: "@if::then" 
 -- Arguments "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- OG:super: "@if:  |    %globals inSub |    %basic 100 |    in if: var boolean |  ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: true
 -- "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- super: "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- E: "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- Items:Qalloc:END:objSize:1  newDescNo:28 "@if (V = x.@get inx) :then  |   ..." 
 -- IS.newDescNo:28 IS.objSize:1 "@if (V = x.@get inx) :then  |    @inner cas ..." 
 -- computeVariant:newDescNo:28  size: 1  IS:"@if (V = x.@get inx) :then  |   ..." 
 -- ComputeVariant:B: "do#S#28" 
 -- ObjTmpStack:add::genDone:false "@if (V = x.@get inx) :then  |    @inner c ..." 
 -- OG:markIS:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |     ..." 
 -- items:markForCodeGen:"" 
 -- ComputeVariant:A:"@for::to:do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |   ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :t ..." 
 -- ObjectInvocation:Qalloc:"@for 1 :to x.length  | :do  |    @if (V = x.@get i ..." 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to x.length :do  |    @if (V = x.@get inx) :then  |      ..." 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |       @inner  ..." 
 -- super: "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |        ..." 
 -- E: "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |       @inn ..." 
 -- OG:Qalloc:B:"@for::to:do#S#0" newDescNo:0 objSize:3 
 -- OG:isObjectDesc:NewDescNo:29 IS.newDescNo:29 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:0  newDescNo:29 "" 
 -- Items:Qalloc:super:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) : ..." : ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:29 "" 
 -- IS.newDescNo:29 IS.objSize:3 "" 
 -- computeVariant:newDescNo:29  size: 3  IS:"" 
 -- ComputeVariant:B: "@for::to:do#S#29" 
 -- ObjTmpStack:add::genDone:false "@for 1 :to x.length  | :do  |    @if (V = x ..." 
 -- ComputeVariant:A:"case" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"in x: ref Indexed(1,#Integer) | @for 1 :to x.length  | :do  |    ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "in x: ref Indexed(1,#Integer) | @for 1 :to x.length  | :do  |    @if (V = x. ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"case" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:30 IS.newDescNo:30 objSize:0 varNo:1 "in x: r ..." 
 -- Items:Qalloc:objSize:0  newDescNo:30 "in x: ref Indexed(1,#Integer) | @fo ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"x" isValue:false isPrimitive:true isValObj: false isBa ...false
 -- DI:Qalloc:off:2 "in x: ref Indexed(1,#Integer)" 
 -- OG:Qalloc:A:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |   ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :t ..." 
 -- ObjectInvocation:Qalloc:"@for 1 :to x.length  | :do  |    @if (V = x.@get i ..." 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to x.length :do  |    @if (V = x.@get inx) :then  |      ..." 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |       @inner  ..." 
 -- super: "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |        ..." 
 -- E: "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |       @inn ..." 
 -- OG:Qalloc:B:"@for::to:do#S#29" newDescNo:29 objSize:3 
 -- OG:isObjectDesc:NewDescNo:31 IS.newDescNo:31 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:4  newDescNo:31 "" 
 -- Items:Qalloc:super:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) : ..." : ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:31 "" 
 -- IS.newDescNo:31 IS.objSize:3 "" 
 -- Items:Qalloc:END:objSize:2  newDescNo:30 "in x: ref Indexed(1,#Integer) ..." 
 -- IS.newDescNo:30 IS.objSize:2 "in x: ref Indexed(1,#Integer) | @for 1 :to  ..." 
 -- computeVariant:newDescNo:30  size: 2  IS:"in x: ref Indexed(1,#Integer) ..." 
 -- ComputeVariant:B: "case" 
 -- ObjTmpStack:add::genDone:false "case" :"in x: ref Indexed(1,#Integer) | @ ..." 
 -- arg: "'a'" 
 -- OG:markForCodeGen:"'a'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "'a'" 
 -- "'a'" true
 -- 
 -- OG:markSuper:"'a'" 
 -- Invocation:markForCodeGen:"'a'" 
 -- not ObjDesc: "'a'"  IS.isEmpty: true
 -- OG:markIS:"case('a') |    "Got  a: ".print" 
 -- items:markForCodeGen:""Got  a: ".print" 
 -- markItem:""Got  a: ".print" ObjectGenerator
 -- OG:markForCodeGen:""Got  a: ".print" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- ""Got  a: ".print" 
 -- ""Got  a: "" true
 -- "print" false
 -- 
 -- OG:markSuper:""Got  a: ".print" 
 -- Invocation:markForCodeGen:""Got  a: ".print" 
 -- ObjectInvocation:markForCodeGen:"print"  ATd:"print:  |    @for 1 :to len ..." 
 -- Pattern:markForCodeGen:"print:  |    @for 1 :to length  |    :do  |       put ..." 
 -- OG:markForCodeGen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- items:markForCodeGen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- markItem:"@for 1 :to length  | :do  |    put(@get inx)" ObjectGenerator ...
 -- OG:markForCodeGen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- isObjectDesc:true isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "@for 1 :to length  | :do  |    put(@get inx)" 
 -- "@for 1 :to length  | :do  |    put(@get inx)" false
 -- 
 -- OG:markSuper:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- Invocation:markForCodeGen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- ObjectInvocation:markForCodeGen:"@for 1 :to length  | :do  |    put(@get in ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@for:  |    %globals inSub |    in for: var integer ..." 
 -- arg: "1" 
 -- OG:markForCodeGen:"1" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "1" 
 -- "1" true
 -- 
 -- OG:markSuper:"1" 
 -- Invocation:markForCodeGen:"1" 
 -- not ObjDesc: "1"  IS.isEmpty: true
 -- arg: "length" 
 -- OG:markForCodeGen:"length" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "length" 
 -- "length" false
 -- 
 -- OG:markSuper:"length" 
 -- Invocation:markForCodeGen:"length" 
 -- ObjectInvocation:markForCodeGen:"length"  ATd:"length:  |    out V: var i ..." 
 -- Pattern:markForCodeGen:"length:  |    out V: var integer |    V := @get 0" 
 -- OG:markForCodeGen:"out V: var integer | V := @get 0" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"out V: var integer | V := @get 0" 
 -- items:markForCodeGen:"out V: var integer | V := @get 0" 
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- markItem:"V := @get 0" ObjectGenerator
 -- OG:markForCodeGen:"V := @get 0" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "V := @get 0" 
 -- "V" true
 -- ":= @get 0" true
 -- 
 -- OG:markSuper:"V := @get 0" 
 -- Invocation:markForCodeGen:"V := @get 0" 
 -- ObjectInvocation:markForCodeGen:"V"  ATd:"out V: var integer" 
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= @get 0"  ATd:":= :  |    %basic 8 |     ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "@get 0" 
 -- not ObjDesc: "V := @get 0"  IS.isEmpty: true
 -- ComputeVariant:A:"length" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"out V: var integer | V := @get 0" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "out V: var integer | V := @get 0" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"length" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:32 IS.newDescNo:32 objSize:0 varNo:1 "out V:  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:32 "out V: var integer | V := @get 0" 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"V" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:2 
 -- OG:Qalloc:A:"V := @get 0" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"V := @get 0" 
 -- ObjectInvocation:Qalloc:"V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= @get 0" 
 -- name: ":=" 
 -- Arguments "@get 0" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "V := @get 0" 
 -- super: "V := @get 0" 
 -- E: ":= @get 0" 
 -- Items:Qalloc:END:objSize:2  newDescNo:32 "out V: var integer | V := @get  ..." 
 -- IS.newDescNo:32 IS.objSize:2 "out V: var integer | V := @get 0" 
 -- computeVariant:newDescNo:32  size: 2  IS:"out V: var integer | V := @get  ..." 
 -- ComputeVariant:B: "length" 
 -- ObjTmpStack:add::genDone:false "length" :"out V: var integer | V := @get  ..." 
 -- not ObjDesc: "length"  IS.isEmpty: true
 -- arg: "put(@get inx)" 
 -- OG:markForCodeGen:"put(@get inx)" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"put(@get inx)" 
 -- items:markForCodeGen:"put(@get inx)" 
 -- markItem:"put(@get inx)" ObjectGenerator
 -- OG:markForCodeGen:"put(@get inx)" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "put(@get inx)" 
 -- "put(@get inx)" true
 -- 
 -- OG:markSuper:"put(@get inx)" 
 -- Invocation:markForCodeGen:"put(@get inx)" 
 -- ObjectInvocation:markForCodeGen:"put(@get inx)"  ATd:"put:  |    %globals ..." 
 -- Pattern:markForCodeGen:"put:  |    %globals |    %basic 2 |    in ch: val cha ..." 
 -- OG:markForCodeGen:"%globals | %basic 2 | in ch: val char" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%globals | %basic 2 | in ch: val char" 
 -- items:markForCodeGen:"%globals | %basic 2 | in ch: val char" 
 -- markItem:"%globals" Property
 -- markItem:"%basic 2" Property
 -- DataItem:markForCodeGen:"ch" :descNo:0 :OG.primNo:3 
 -- OG:markForCodeGen:"char" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "char" 
 -- "char" true
 -- 
 -- OG:markSuper:"char" 
 -- Invocation:markForCodeGen:"char" 
 -- ObjectInvocation:markForCodeGen:"char"  ATd:"char: value |    %id "char" |  ..." 
 -- Pattern:markForCodeGen:"char: value |    %id "char" |    %globals |    %basic ..." 
 -- not ObjDesc: "char"  IS.isEmpty: true
 -- ComputeVariant:A:"put" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%globals | %basic 2 | in ch: val char" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%globals | %basic 2 | in ch: val char" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"put" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:33 IS.newDescNo:33 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:33 "%globals | %basic 2 | in ch: val char ..." 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:"ch" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:1 
 -- Items:Qalloc:END:objSize:1  newDescNo:33 "%globals | %basic 2 | in ch: val  ..." 
 -- IS.newDescNo:33 IS.objSize:1 "%globals | %basic 2 | in ch: val char" 
 -- computeVariant:newDescNo:33  size: 1  IS:"%globals | %basic 2 | in ch: val  ..." 
 -- ComputeVariant:B: "put" 
 -- ObjTmpStack:add::genDone:false "put" :"%globals | %basic 2 | in ch: val cha ..." 
 -- arg: "@get inx" 
 -- not ObjDesc: "put(@get inx)"  IS.isEmpty: true
 -- ComputeVariant:A:"do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"put(@get inx)" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "put(@get inx)" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"do#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:34 IS.newDescNo:34 objSize:0 varNo:1 "put(@ge ..." 
 -- Items:Qalloc:objSize:0  newDescNo:34 "put(@get inx)" 
 -- Items:Qalloc:super:"" :super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- OG:Qalloc:A:"put(@get inx)" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"put(@get inx)" 
 -- ObjectInvocation:Qalloc:"put(@get inx)" 
 -- name: "put" 
 -- Arguments "(@get inx)" 
 -- OG:super: "put:  |    %globals |    %basic 2 |    in ch: val char" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "put(@get inx)" 
 -- super: "put(@get inx)" 
 -- E: "put(@get inx)" 
 -- Items:Qalloc:END:objSize:1  newDescNo:34 "put(@get inx)" 
 -- IS.newDescNo:34 IS.objSize:1 "put(@get inx)" 
 -- computeVariant:newDescNo:34  size: 1  IS:"put(@get inx)" 
 -- ComputeVariant:B: "do#S#34" 
 -- ObjTmpStack:add::genDone:false "put(@get inx)" 
 -- OG:markIS:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- items:markForCodeGen:"" 
 -- ComputeVariant:A:"@for::to:do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- ObjectInvocation:Qalloc:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to length :do  |    put(@get inx)" 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to length  | :do  |    put(@get inx)" 
 -- super: "@for 1 :to length  | :do  |    put(@get inx)" 
 -- E: "@for 1 :to length  | :do  |    put(@get inx)" 
 -- OG:Qalloc:B:"@for::to:do#S#0" newDescNo:0 objSize:3 
 -- OG:isObjectDesc:NewDescNo:35 IS.newDescNo:35 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:0  newDescNo:35 "" 
 -- Items:Qalloc:super:"@for 1 :to length  | :do  |    put(@get inx)" :supe ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:35 "" 
 -- IS.newDescNo:35 IS.objSize:3 "" 
 -- computeVariant:newDescNo:35  size: 3  IS:"" 
 -- ComputeVariant:B: "@for::to:do#S#35" 
 -- ObjTmpStack:add::genDone:false "@for 1 :to length  | :do  |    put(@get inx ..." 
 -- ComputeVariant:A:"print" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to length  | :do  |    put(@get inx)" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"print" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:36 IS.newDescNo:36 objSize:0 varNo:1 "@for 1  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:36 "@for 1 :to length  | :do  |    put(@g ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- ObjectInvocation:Qalloc:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to length :do  |    put(@get inx)" 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to length  | :do  |    put(@get inx)" 
 -- super: "@for 1 :to length  | :do  |    put(@get inx)" 
 -- E: "@for 1 :to length  | :do  |    put(@get inx)" 
 -- OG:Qalloc:B:"@for::to:do#S#35" newDescNo:35 objSize:3 
 -- OG:isObjectDesc:NewDescNo:37 IS.newDescNo:37 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:4  newDescNo:37 "" 
 -- Items:Qalloc:super:"@for 1 :to length  | :do  |    put(@get inx)" :supe ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:37 "" 
 -- IS.newDescNo:37 IS.objSize:3 "" 
 -- Items:Qalloc:END:objSize:1  newDescNo:36 "@for 1 :to length  | :do  |    pu ..." 
 -- IS.newDescNo:36 IS.objSize:1 "@for 1 :to length  | :do  |    put(@get inx)" 
 -- computeVariant:newDescNo:36  size: 1  IS:"@for 1 :to length  | :do  |    pu ..." 
 -- ComputeVariant:B: "print" 
 -- ObjTmpStack:add::genDone:false "print" :"@for 1 :to length  | :do  |    put ..." 
 -- not ObjDesc: ""Got  a: ".print"  IS.isEmpty: true
 -- ComputeVariant:A:"case#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:case
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"case('a') |    "Got  a: ".print" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"case('a')" 
 -- ObjectInvocation:Qalloc:"case('a')" 
 -- name: "case" 
 -- Arguments "('a')" 
 -- OG:super: "case:  |    in x: ref Indexed(1,#Integer) |    @for 1 :to x.leng ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "case('a') |    "Got  a: ".print" 
 -- super: "case('a')" 
 -- E: "case('a')" 
 -- OG:Qalloc:B:"case#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:38 IS.newDescNo:38 objSize:0 varNo:1 ""Got  a ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:38 ""Got  a: ".print" 
 -- Items:Qalloc:super:"case('a')" :super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- OG:Qalloc:A:""Got  a: ".print" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:""Got  a: ".print" 
 -- ObjectInvocation:Qalloc:"print" 
 -- name: "print" 
 -- Arguments "" 
 -- OG:super: "print:  |    @for 1 :to length  |    :do  |       put(@get inx)" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- ""Got  a: ".print" 
 -- super: ""Got  a: ".print" 
 -- E: "print" 
 -- Items:Qalloc:END:objSize:2  newDescNo:38 ""Got  a: ".print" 
 -- IS.newDescNo:38 IS.objSize:2 ""Got  a: ".print" 
 -- computeVariant:newDescNo:38  size: 2  IS:""Got  a: ".print" 
 -- ComputeVariant:B: "case#S#38" 
 -- ObjTmpStack:add::genDone:false "case('a') |    "Got  a: ".print" 
 -- markItem:""else:".print" ObjectGenerator
 -- OG:markForCodeGen:""else:".print" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- ""else:".print" 
 -- ""else:"" true
 -- "print" false
 -- 
 -- OG:markSuper:""else:".print" 
 -- Invocation:markForCodeGen:""else:".print" 
 -- ObjectInvocation:markForCodeGen:"print"  ATd:"print:  |    @for 1 :to len ..." 
 -- Pattern:markForCodeGen:"print:  |    @for 1 :to length  |    :do  |       put ..." 
 -- not ObjDesc: ""else:".print"  IS.isEmpty: true
 -- markItem:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart  ..." O ...
 -- OG:markForCodeGen:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |     ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  | :el ..." 
 -- "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  | :el ..." false
 -- 
 -- OG:markSuper:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @rest ..." 
 -- Invocation:markForCodeGen:"@if ascii.isLetter(chxxx) :then  |    chxxx := ..." 
 -- ObjectInvocation:markForCodeGen:"@if ascii.isLetter(chxxx) :then  |    ch ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@if:  |    %globals inSub --,OSDvisibility[disgui ..." 
 -- OG:markForCodeGen:"%globals inSub --,OSDvisibility[disguised]] |  | --Decla ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%globals inSub --,OSDvisibility[disguised]] |  | --Declaration o ..." 
 -- items:markForCodeGen:"%globals inSub --,OSDvisibility[disguised]] |  | --De ..." 
 -- markItem:"%globals inSub --,OSDvisibility[disguised]] |  | --Declaration of ..." P ...
 -- DataItem:markForCodeGen:"if" :descNo:0 :OG.primNo:4 
 -- OG:markForCodeGen:"Boolean" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Boolean" 
 -- "Boolean" true
 -- 
 -- OG:markSuper:"Boolean" 
 -- Invocation:markForCodeGen:"Boolean" 
 -- ObjectInvocation:markForCodeGen:"Boolean"  ATd:"Boolean: value |    %glob ..." 
 -- Pattern:markForCodeGen:"Boolean: value |    %globals inSub |    %basic 4, 8 ..." 
 -- not ObjDesc: "Boolean"  IS.isEmpty: true
 -- Pattern:markForCodeGen:"in then:< Object" 
 -- OG:markForCodeGen:"Object" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Object" 
 -- "Object" true
 -- 
 -- not ObjDesc: "Object"  IS.isEmpty: true
 -- Pattern:markForCodeGen:"in else:< Object" 
 -- OG:markForCodeGen:"Object" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Object" 
 -- "Object" true
 -- 
 -- not ObjDesc: "Object"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"if_L" :descNo:0 :OG.primNo:0 
 -- OG:markForCodeGen:"@ifX if :thenX  |    then |    @leave if_L -- problem wh ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"@ifX if :thenX  |    then |    @leave if_L -- problem when @if i ..." 
 -- items:markForCodeGen:"@ifX if :thenX  |    then |    @leave if_L -- problem ..." 
 -- markItem:"@ifX if :thenX  |    then |    @leave if_L -- problem when @if if ..." O ...
 -- OG:markForCodeGen:"@ifX if :thenX  |    then |    @leave if_L -- problem wh ..." 
 -- isObjectDesc:false isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "@ifX if :thenX  |    then |    @leave if_L -- problem when @if if :then .. ..." 
 -- "@ifX if :thenX  |    then |    @leave if_L" true
 -- 
 -- OG:markSuper:"@ifX if :thenX  |    then |    @leave if_L -- problem when @i ..." 
 -- Invocation:markForCodeGen:"@ifX if :thenX  |    then |    @leave if_L -- pr ..." 
 -- ObjectInvocation:markForCodeGen:"@ifX if :thenX  |    then |    @leave if_L ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@ifX:  |    %globals inSub |    %basic 100 |    in if ..." 
 -- OG:markForCodeGen:"%globals inSub | %basic 100 | in ifX: var boolean | in the ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%globals inSub | %basic 100 | in ifX: var boolean | in thenX:< Obj ..." 
 -- items:markForCodeGen:"%globals inSub | %basic 100 | in ifX: var boolean | in  ..." 
 -- markItem:"%globals inSub" Property
 -- markItem:"%basic 100" Property
 -- DataItem:markForCodeGen:"ifX" :descNo:0 :OG.primNo:4 
 -- OG:markForCodeGen:"boolean" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "boolean" 
 -- "boolean" true
 -- 
 -- OG:markSuper:"boolean" 
 -- Invocation:markForCodeGen:"boolean" 
 -- ObjectInvocation:markForCodeGen:"boolean"  ATd:"Boolean: value |    %glob ..." 
 -- Pattern:markForCodeGen:"Boolean: value |    %globals inSub |    %basic 4, 8 ..." 
 -- not ObjDesc: "boolean"  IS.isEmpty: true
 -- Pattern:markForCodeGen:"in thenX:< Object" 
 -- OG:markForCodeGen:"Object" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Object" 
 -- "Object" true
 -- 
 -- not ObjDesc: "Object"  IS.isEmpty: true
 -- ComputeVariant:A:"@ifX::thenX" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%globals inSub | %basic 100 | in ifX: var boolean | in thenX:< O ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%globals inSub | %basic 100 | in ifX: var boolean | in thenX:< Object" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@ifX::thenX" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:39 IS.newDescNo:39 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:39 "%globals inSub | %basic 100 | in ifX: ..." 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:"ifX" isValue:true isPrimitive:true isValObj: true isBa ...true
 -- diSize:1 IT.qSize:1 
 -- Pattern:Qalloc:thenX
 -- Pattern:Qalloc:B:thenX
 -- Items:Qalloc:END:objSize:1  newDescNo:39 "%globals inSub | %basic 100 | in  ..." 
 -- IS.newDescNo:39 IS.objSize:1 "%globals inSub | %basic 100 | in ifX: var boo ..." 
 -- computeVariant:newDescNo:39  size: 1  IS:"%globals inSub | %basic 100 | in  ..." 
 -- ComputeVariant:B: "@ifX::thenX" 
 -- ObjTmpStack:add::genDone:false "" :"%globals inSub | %basic 100 | in ifX: v ..." 
 -- arg: "if" 
 -- OG:markForCodeGen:"if" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "if" 
 -- "if" true
 -- 
 -- arg: "then | @leave if_L" 
 -- OG:markForCodeGen:"then | @leave if_L" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"then | @leave if_L" 
 -- items:markForCodeGen:"then | @leave if_L" 
 -- markItem:"then" ObjectGenerator
 -- OG:markForCodeGen:"then" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "then" 
 -- "then" false
 -- 
 -- OG:markSuper:"then" 
 -- Invocation:markForCodeGen:"then" 
 -- ObjectInvocation:markForCodeGen:"then"  ATd:"in then:< Object" 
 -- Pattern:markForCodeGen:"in then:< Object" 
 -- not ObjDesc: "then"  IS.isEmpty: true
 -- markItem:"@leave if_L" ObjectGenerator
 -- ComputeVariant:A:"#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"then | @leave if_L" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "then | @leave if_L" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:40 IS.newDescNo:40 objSize:0 varNo:1 "then | @l ..." 
 -- Items:Qalloc:objSize:0  newDescNo:40 "then | @leave if_L" 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:"then" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"then" 
 -- ObjectInvocation:Qalloc:"then" 
 -- name: "then" 
 -- Arguments "" 
 -- OG:super: "in then:< Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "then" 
 -- super: "then" 
 -- E: "then" 
 -- OG:Qalloc:A:"@leave if_L" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@leave if_L" 
 -- ObjectInvocation:Qalloc:"@leave if_L" 
 -- name: "@leave" 
 -- Arguments "@leave if_L" 
 -- OG:super: "@leave:  |    %basic 103 |    in leave: var integer" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@leave if_L" 
 -- super: "@leave if_L" 
 -- E: "@leave if_L" 
 -- Items:Qalloc:END:objSize:1  newDescNo:40 "then | @leave if_L" 
 -- IS.newDescNo:40 IS.objSize:1 "then | @leave if_L" 
 -- computeVariant:newDescNo:40  size: 1  IS:"then | @leave if_L" 
 -- ComputeVariant:B: "#S#40" 
 -- ObjTmpStack:add::genDone:false "then | @leave if_L" 
 -- not ObjDesc: "@ifX if :thenX  |    then |    @leave if_L -- problem when @i ..."   ...true
 -- markItem:"else" ObjectGenerator
 -- OG:markForCodeGen:"else" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "else" 
 -- "else" false
 -- 
 -- OG:markSuper:"else" 
 -- Invocation:markForCodeGen:"else" 
 -- ObjectInvocation:markForCodeGen:"else"  ATd:"in else:< Object" 
 -- Pattern:markForCodeGen:"in else:< Object" 
 -- not ObjDesc: "else"  IS.isEmpty: true
 -- ComputeVariant:A:"if_L" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@ifX if :thenX  |    then |    @leave if_L -- problem when @if ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@ifX if :thenX  |    then |    @leave if_L -- problem when @if if :then .. ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"if_L" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:41 IS.newDescNo:41 objSize:0 varNo:1 "@ifX if ..." 
 -- Items:Qalloc:objSize:0  newDescNo:41 "@ifX if :thenX  |    then |    @leave ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:"@ifX if :thenX  |    then |    @leave if_L -- problem when @if ..." 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@ifX if :thenX  |    then |    @leave if_L -- problem wh ..." 
 -- ObjectInvocation:Qalloc:"@ifX if :thenX  |    then |    @leave if_L" 
 -- name: "@ifX::thenX" 
 -- Arguments "@ifX if :thenX  |    then |    @leave if_L" 
 -- OG:super: "@ifX:  |    %globals inSub |    %basic 100 |    in ifX: var boolea ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: true
 -- "@ifX if :thenX  |    then |    @leave if_L -- problem when @if if :then .. ..." 
 -- super: "@ifX if :thenX  |    then |    @leave if_L -- problem when @if if : ..." 
 -- E: "@ifX if :thenX  |    then |    @leave if_L" 
 -- OG:Qalloc:A:"else" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"else" 
 -- ObjectInvocation:Qalloc:"else" 
 -- name: "else" 
 -- Arguments "" 
 -- OG:super: "in else:< Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "else" 
 -- super: "else" 
 -- E: "else" 
 -- Items:Qalloc:END:objSize:1  newDescNo:41 "@ifX if :thenX  |    then |    @l ..." 
 -- IS.newDescNo:41 IS.objSize:1 "@ifX if :thenX  |    then |    @leave if_L -- ..." 
 -- computeVariant:newDescNo:41  size: 1  IS:"@ifX if :thenX  |    then |    @l ..." 
 -- ComputeVariant:B: "if_L" 
 -- ObjTmpStack:add::genDone:false "@ifX if :thenX  |    then |    @leave if_L  ..." 
 -- ComputeVariant:A:"@if::then:else" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%globals inSub --,OSDvisibility[disguised]] |  | --Declaration ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%globals inSub --,OSDvisibility[disguised]] |  | --Declaration of if then  ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@if::then:else" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:42 IS.newDescNo:42 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:42 "%globals inSub --,OSDvisibility[d ..." 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:"if" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:1 
 -- Pattern:Qalloc:then
 -- Pattern:Qalloc:B:then
 -- Pattern:Qalloc:else
 -- Pattern:Qalloc:B:else
 -- dataitem:qalloc:"if_L" isValue:false isPrimitive:false isValObj: false  ...false
 -- DI:Qalloc:off:2 "if_L: obj  |    @ifX if :thenX  |       then |       @leave  ..." 
 -- Items:Qalloc:END:objSize:2  newDescNo:42 "%globals inSub --,OSDvisibili ..." 
 -- IS.newDescNo:42 IS.objSize:2 "%globals inSub --,OSDvisibility[disguised ..." 
 -- computeVariant:newDescNo:42  size: 2  IS:"%globals inSub --,OSDvisibili ..." 
 -- ComputeVariant:B: "@if::then:else" 
 -- ObjTmpStack:add::genDone:false "" :"%globals inSub --,OSDvisibility[dis ..." 
 -- arg: "ascii.isLetter(chxxx)" 
 -- OG:markForCodeGen:"ascii.isLetter(chxxx)" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "ascii.isLetter(chxxx)" 
 -- "ascii" false
 -- "isLetter(chxxx)" false
 -- 
 -- OG:markSuper:"ascii.isLetter(chxxx)" 
 -- Invocation:markForCodeGen:"ascii.isLetter(chxxx)" 
 -- ObjectInvocation:markForCodeGen:"ascii"  ATd:"ascii: obj  |    nl: val 10 ..." 
 -- DataItem:markForCodeGen:"ascii" :descNo:5 :OG.primNo:0 
 -- ObjectInvocation:markForCodeGen:"isLetter(chxxx)"  ATd:"isLetter:  |    i ..." 
 -- Pattern:markForCodeGen:"isLetter:  |    in ch: var char |    out B: var Boo ..." 
 -- OG:markForCodeGen:"in ch: var char | out B: var Boolean | B := ((('a' <= ch ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"in ch: var char | out B: var Boolean | B := ((('a' <= ch) && (ch ..." 
 -- items:markForCodeGen:"in ch: var char | out B: var Boolean | B := ((('a' <= ..." 
 -- DataItem:markForCodeGen:"ch" :descNo:0 :OG.primNo:3 
 -- OG:markForCodeGen:"char" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "char" 
 -- "char" true
 -- 
 -- OG:markSuper:"char" 
 -- Invocation:markForCodeGen:"char" 
 -- ObjectInvocation:markForCodeGen:"char"  ATd:"char: value |    %id "char" |  ..." 
 -- Pattern:markForCodeGen:"char: value |    %id "char" |    %globals |    %basic ..." 
 -- not ObjDesc: "char"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"B" :descNo:0 :OG.primNo:4 
 -- OG:markForCodeGen:"Boolean" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Boolean" 
 -- "Boolean" true
 -- 
 -- OG:markSuper:"Boolean" 
 -- Invocation:markForCodeGen:"Boolean" 
 -- ObjectInvocation:markForCodeGen:"Boolean"  ATd:"Boolean: value |    %glob ..." 
 -- Pattern:markForCodeGen:"Boolean: value |    %globals inSub |    %basic 4, 8 ..." 
 -- not ObjDesc: "Boolean"  IS.isEmpty: true
 -- markItem:"B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <=  ..." O ...
 -- OG:markForCodeGen:"B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) & ..." 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" 
 -- "B" true
 -- ":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" true
 -- 
 -- OG:markSuper:"B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch ..." 
 -- Invocation:markForCodeGen:"B := ((('a' <= ch) && (ch <= 'z')) || (('A'  ..." 
 -- ObjectInvocation:markForCodeGen:"B"  ATd:"out B: var Boolean" 
 -- DataItem:markForCodeGen:"B" :descNo:0 :OG.primNo:4 
 -- ObjectInvocation:markForCodeGen:":= ((('a' <= ch) && (ch <= 'z')) || (( ..."   ...": ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" 
 -- OG:markForCodeGen:"((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch ..." 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" 
 -- "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" true
 -- 
 -- OG:markSuper:"((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= ' ..." 
 -- Invocation:markForCodeGen:"((('a' <= ch) && (ch <= 'z')) || (('A' <= ch ..." 
 -- Invocation:markForCodeGen:"(('a' <= ch) && (ch <= 'z')) || (('A' <= ch) ..." 
 -- Invocation:markForCodeGen:"('a' <= ch) && (ch <= 'z')" 
 -- Invocation:markForCodeGen:"'a' <= ch" 
 -- ObjectInvocation:markForCodeGen:"<= ch"  ATd:"<= :  |    %basic 52 |    in  ..." 
 -- Pattern:markForCodeGen:"<= :  |    %basic 52 |    in V: var char |    out B:  ..." 
 -- arg: "ch" 
 -- OG:markForCodeGen:"ch" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "ch" 
 -- "ch" true
 -- 
 -- ObjectInvocation:markForCodeGen:"&& (ch <= 'z')"  ATd:"&& :  |    %basic  ..." 
 -- Pattern:markForCodeGen:"&& :  |    %basic 70 |    in B: var boolean |    out  ..." 
 -- arg: "(ch <= 'z')" 
 -- OG:markForCodeGen:"(ch <= 'z')" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "(ch <= 'z')" 
 -- "(ch <= 'z')" true
 -- 
 -- OG:markSuper:"(ch <= 'z')" 
 -- Invocation:markForCodeGen:"(ch <= 'z')" 
 -- Invocation:markForCodeGen:"ch <= 'z'" 
 -- ObjectInvocation:markForCodeGen:"ch"  ATd:"in ch: var char" 
 -- DataItem:markForCodeGen:"ch" :descNo:0 :OG.primNo:3 
 -- ObjectInvocation:markForCodeGen:"<= 'z'"  ATd:"<= :  |    %basic 52 |    in ..." 
 -- Pattern:markForCodeGen:"<= :  |    %basic 52 |    in V: var char |    out B:  ..." 
 -- arg: "'z'" 
 -- OG:markForCodeGen:"'z'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "'z'" 
 -- "'z'" true
 -- 
 -- OG:markSuper:"'z'" 
 -- Invocation:markForCodeGen:"'z'" 
 -- not ObjDesc: "'z'"  IS.isEmpty: true
 -- not ObjDesc: "(ch <= 'z')"  IS.isEmpty: true
 -- ObjectInvocation:markForCodeGen:"|| (('A' <= ch) && (ch <= 'Z'))"  ATd: ..."| ..." 
 -- Pattern:markForCodeGen:"|| :  |    %basic 63 |    in B: var boolean |    out  ..." 
 -- arg: "(('A' <= ch) && (ch <= 'Z'))" 
 -- OG:markForCodeGen:"(('A' <= ch) && (ch <= 'Z'))" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "(('A' <= ch) && (ch <= 'Z'))" 
 -- "(('A' <= ch) && (ch <= 'Z'))" true
 -- 
 -- OG:markSuper:"(('A' <= ch) && (ch <= 'Z'))" 
 -- Invocation:markForCodeGen:"(('A' <= ch) && (ch <= 'Z'))" 
 -- Invocation:markForCodeGen:"('A' <= ch) && (ch <= 'Z')" 
 -- Invocation:markForCodeGen:"'A' <= ch" 
 -- ObjectInvocation:markForCodeGen:"<= ch"  ATd:"<= :  |    %basic 52 |    in  ..." 
 -- Pattern:markForCodeGen:"<= :  |    %basic 52 |    in V: var char |    out B:  ..." 
 -- arg: "ch" 
 -- OG:markForCodeGen:"ch" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "ch" 
 -- "ch" true
 -- 
 -- ObjectInvocation:markForCodeGen:"&& (ch <= 'Z')"  ATd:"&& :  |    %basic  ..." 
 -- Pattern:markForCodeGen:"&& :  |    %basic 70 |    in B: var boolean |    out  ..." 
 -- arg: "(ch <= 'Z')" 
 -- OG:markForCodeGen:"(ch <= 'Z')" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "(ch <= 'Z')" 
 -- "(ch <= 'Z')" true
 -- 
 -- OG:markSuper:"(ch <= 'Z')" 
 -- Invocation:markForCodeGen:"(ch <= 'Z')" 
 -- Invocation:markForCodeGen:"ch <= 'Z'" 
 -- ObjectInvocation:markForCodeGen:"ch"  ATd:"in ch: var char" 
 -- DataItem:markForCodeGen:"ch" :descNo:0 :OG.primNo:3 
 -- ObjectInvocation:markForCodeGen:"<= 'Z'"  ATd:"<= :  |    %basic 52 |    in ..." 
 -- Pattern:markForCodeGen:"<= :  |    %basic 52 |    in V: var char |    out B:  ..." 
 -- arg: "'Z'" 
 -- OG:markForCodeGen:"'Z'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "'Z'" 
 -- "'Z'" true
 -- 
 -- OG:markSuper:"'Z'" 
 -- Invocation:markForCodeGen:"'Z'" 
 -- not ObjDesc: "'Z'"  IS.isEmpty: true
 -- not ObjDesc: "(ch <= 'Z')"  IS.isEmpty: true
 -- not ObjDesc: "(('A' <= ch) && (ch <= 'Z'))"  IS.isEmpty: true
 -- not ObjDesc: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= ' ..."   ...true
 -- not ObjDesc: "B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch ..."   ...true
 -- ComputeVariant:A:"isLetter" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"in ch: var char | out B: var Boolean | B := ((('a' <= ch) && ( ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "in ch: var char | out B: var Boolean | B := ((('a' <= ch) && (ch <= 'z'))  ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"isLetter" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:43 IS.newDescNo:43 objSize:0 varNo:1 "in ch:  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:43 "in ch: var char | out B: var Boolea ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"ch" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:2 
 -- dataitem:qalloc:"B" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:3 
 -- OG:Qalloc:A:"B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch  ..." 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) & ..." 
 -- ObjectInvocation:Qalloc:"B" 
 -- name: "B" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= c ..." 
 -- name: ":=" 
 -- Arguments "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z') ..." 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" 
 -- super: "B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z ..." 
 -- E: ":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" 
 -- Items:Qalloc:END:objSize:3  newDescNo:43 "in ch: var char | out B: var Bo ..." 
 -- IS.newDescNo:43 IS.objSize:3 "in ch: var char | out B: var Boolean | B := ( ..." 
 -- computeVariant:newDescNo:43  size: 3  IS:"in ch: var char | out B: var Bo ..." 
 -- ComputeVariant:B: "isLetter" 
 -- ObjTmpStack:add::genDone:false "isLetter" :"in ch: var char | out B: var  ..." 
 -- arg: "chxxx" 
 -- OG:markForCodeGen:"chxxx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "chxxx" 
 -- "chxxx" true
 -- 
 -- not ObjDesc: "ascii.isLetter(chxxx)"  IS.isEmpty: true
 -- arg: "chxxx := '!' | @restart loop" 
 -- OG:markForCodeGen:"chxxx := '!' | @restart loop" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"chxxx := '!' | @restart loop" 
 -- items:markForCodeGen:"chxxx := '!' | @restart loop" 
 -- markItem:"chxxx := '!'" ObjectGenerator
 -- OG:markForCodeGen:"chxxx := '!'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "chxxx := '!'" 
 -- "chxxx" true
 -- ":= '!'" true
 -- 
 -- OG:markSuper:"chxxx := '!'" 
 -- Invocation:markForCodeGen:"chxxx := '!'" 
 -- ObjectInvocation:markForCodeGen:"chxxx"  ATd:"chxxx: var char" 
 -- DataItem:markForCodeGen:"chxxx" :descNo:0 :OG.primNo:3 
 -- ObjectInvocation:markForCodeGen:":= '!'"  ATd:":= :  |    %basic 8 |    in  ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "'!'" 
 -- OG:markForCodeGen:"'!'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "'!'" 
 -- "'!'" true
 -- 
 -- OG:markSuper:"'!'" 
 -- Invocation:markForCodeGen:"'!'" 
 -- not ObjDesc: "'!'"  IS.isEmpty: true
 -- not ObjDesc: "chxxx := '!'"  IS.isEmpty: true
 -- markItem:"@restart loop" ObjectGenerator
 -- ComputeVariant:A:"then#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:then
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- OG:Qalloc:A:"Object" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"Object" 
 -- ObjectInvocation:Qalloc:"Object" 
 -- name: "Object" 
 -- Arguments "" 
 -- OG:super: "Object:  |    %ID Object |    %basic 64 |    %public |    := :  |      ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "Object" 
 -- super: "Object" 
 -- E: "Object" 
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"chxxx := '!' | @restart loop" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "chxxx := '!' | @restart loop" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"then#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:44 IS.newDescNo:44 objSize:0 varNo:1 "chxxx : ..." 
 -- Items:Qalloc:objSize:0  newDescNo:44 "chxxx := '!' | @restart loop" 
 -- Items:Qalloc:super:"" :super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- OG:Qalloc:A:"chxxx := '!'" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"chxxx := '!'" 
 -- ObjectInvocation:Qalloc:"chxxx" 
 -- name: "chxxx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= '!'" 
 -- name: ":=" 
 -- Arguments "'!'" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "chxxx := '!'" 
 -- super: "chxxx := '!'" 
 -- E: ":= '!'" 
 -- OG:Qalloc:A:"@restart loop" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@restart loop" 
 -- ObjectInvocation:Qalloc:"@restart loop" 
 -- name: "@restart" 
 -- Arguments "@restart loop" 
 -- OG:super: "@restart:  |    %basic 102 |    in restart: var integer" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@restart loop" 
 -- super: "@restart loop" 
 -- E: "@restart loop" 
 -- Items:Qalloc:END:objSize:1  newDescNo:44 "chxxx := '!' | @restart loop" 
 -- IS.newDescNo:44 IS.objSize:1 "chxxx := '!' | @restart loop" 
 -- computeVariant:newDescNo:44  size: 1  IS:"chxxx := '!' | @restart loop" 
 -- ComputeVariant:B: "then#S#44" 
 -- ObjTmpStack:add::genDone:false "chxxx := '!' | @restart loop" 
 -- arg: ""bingo: {C(chxxx)}".print | @leave loop" 
 -- OG:markForCodeGen:""bingo: {C(chxxx)}".print | @leave loop" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:""bingo: {C(chxxx)}".print | @leave loop" 
 -- items:markForCodeGen:""bingo: {C(chxxx)}".print | @leave loop" 
 -- markItem:""bingo: {C(chxxx)}".print" ObjectGenerator
 -- OG:markForCodeGen:""bingo: {C(chxxx)}".print" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- ""bingo: {C(chxxx)}".print" 
 -- ""bingo: {C(chxxx)}"" true
 -- "print" false
 -- 
 -- OG:markSuper:""bingo: {C(chxxx)}".print" 
 -- Invocation:markForCodeGen:""bingo: {C(chxxx)}".print" 
 -- Invocation:markForCodeGen:"C(chxxx)" 
 -- ObjectInvocation:markForCodeGen:"C(chxxx)"  ATd:"C:  |    in ch: var char ..." 
 -- Pattern:markForCodeGen:"C:  |    in ch: var char |    out S: ref LIB.String ..." 
 -- OG:markForCodeGen:"in ch: var char | out S: ref LIB.String.String | D: obj  ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"in ch: var char | out S: ref LIB.String.String | D: obj Indexed( ..." 
 -- items:markForCodeGen:"in ch: var char | out S: ref LIB.String.String | D: o ..." 
 -- DataItem:markForCodeGen:"ch" :descNo:0 :OG.primNo:3 
 -- OG:markForCodeGen:"char" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "char" 
 -- "char" true
 -- 
 -- OG:markSuper:"char" 
 -- Invocation:markForCodeGen:"char" 
 -- ObjectInvocation:markForCodeGen:"char"  ATd:"char: value |    %id "char" |  ..." 
 -- Pattern:markForCodeGen:"char: value |    %id "char" |    %globals |    %basic ..." 
 -- not ObjDesc: "char"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"S" :descNo:0 :OG.primNo:5 
 -- OG:markForCodeGen:"LIB.String.String" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "LIB.String.String" 
 -- "LIB" false
 -- "String" false
 -- "String" true
 -- 
 -- OG:markSuper:"LIB.String.String" 
 -- Invocation:markForCodeGen:"LIB.String.String" 
 -- ObjectInvocation:markForCodeGen:"LIB"  ATd:"" 
 -- ObjectInvocation:markForCodeGen:"String"  ATd:"" 
 -- ObjectInvocation:markForCodeGen:"String"  ATd:"String:  |    %id "String  ..."" 
 -- Pattern:markForCodeGen:"String:  |    %id "String pattern" |    %OSDvisibil ..." 
 -- not ObjDesc: "LIB.String.String"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"D" :descNo:0 :OG.primNo:114 
 -- markItem:"D.@put ch :at 1" ObjectGenerator
 -- markItem:"S := D.asString" ObjectGenerator
 -- OG:markForCodeGen:"S := D.asString" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "S := D.asString" 
 -- "S" true
 -- ":= D.asString" true
 -- 
 -- OG:markSuper:"S := D.asString" 
 -- Invocation:markForCodeGen:"S := D.asString" 
 -- ObjectInvocation:markForCodeGen:"S"  ATd:"out S: ref LIB.String.String" 
 -- DataItem:markForCodeGen:"S" :descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen:":= D.asString"  ATd:":= :  |    %basic 8 ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- OG:markForCodeGen:"%basic 8 | in V: var Value" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%basic 8 | in V: var Value" 
 -- items:markForCodeGen:"%basic 8 | in V: var Value" 
 -- markItem:"%basic 8" Property
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:21 
 -- OG:markForCodeGen:"Value" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "Value" 
 -- "Value" true
 -- 
 -- OG:markSuper:"Value" 
 -- Invocation:markForCodeGen:"Value" 
 -- ObjectInvocation:markForCodeGen:"Value"  ATd:"Value:  |    %ID Value |    % ..." 
 -- Pattern:markForCodeGen:"Value:  |    %ID Value |    %globals |    %basic 21 |   ..." 
 -- not ObjDesc: "Value"  IS.isEmpty: true
 -- ComputeVariant:A:":=" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%basic 8 | in V: var Value" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%basic 8 | in V: var Value" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:":=" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:45 IS.newDescNo:45 objSize:0 varNo:1 "%basic  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:45 "%basic 8 | in V: var Value" 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"V" isValue:true isPrimitive:true isValObj: true isBasi ...false
 -- diSize:1 IT.qSize:2 
 -- Items:Qalloc:END:objSize:2  newDescNo:45 "%basic 8 | in V: var Value" 
 -- IS.newDescNo:45 IS.objSize:2 "%basic 8 | in V: var Value" 
 -- computeVariant:newDescNo:45  size: 2  IS:"%basic 8 | in V: var Value" 
 -- ComputeVariant:B: ":=" 
 -- ObjTmpStack:add::genDone:false ":= " :"%basic 8 | in V: var Value" 
 -- arg: "D.asString" 
 -- not ObjDesc: "S := D.asString"  IS.isEmpty: true
 -- ComputeVariant:A:"C" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"in ch: var char | out S: ref LIB.String.String | D: obj Indexe ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "in ch: var char | out S: ref LIB.String.String | D: obj Indexed(1,char) | D. ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"C" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:46 IS.newDescNo:46 objSize:0 varNo:1 "in ch:  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:46 "in ch: var char | out S: ref LIB.St ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"ch" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:2 
 -- dataitem:qalloc:"S" isValue:false isPrimitive:true isValObj: false isBa ...false
 -- DI:Qalloc:off:3 "out S: ref LIB.String.String" 
 -- dataitem:qalloc:"D" isValue:false isPrimitive:true isValObj: false isBa ...false
 -- DI:Qalloc:off:4 "D: obj Indexed(1,char)" 
 -- OG:Qalloc:A:"D.@put ch :at 1" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"D.@put ch :at 1" 
 -- ObjectInvocation:Qalloc:"D" 
 -- name: "D" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:"@put ch :at 1" 
 -- name: "@put::at" 
 -- Arguments "@put ch :at 1" 
 -- OG:Qalloc:SuperAlloc:"@put:  |    %basic 115 |    in put: ref elm |    in at: ..." 
 -- OG:Qalloc:A:"%basic 115 | in put: ref elm | in at: var integer" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%basic 115 | in put: ref elm | in at: var integer" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"@put::at" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:47 IS.newDescNo:47 objSize:0 varNo:1 "%basic  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:47 "%basic 115 | in put: ref elm | in at: ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"put" isValue:false isPrimitive:false isValObj: false i ...false
 -- DI:Qalloc:off:2 "in put: ref elm" 
 -- dataitem:qalloc:"at" isValue:true isPrimitive:true isValObj: true isBas ...true
 -- diSize:1 IT.qSize:3 
 -- Items:Qalloc:END:objSize:3  newDescNo:47 "%basic 115 | in put: ref elm | in ..." 
 -- IS.newDescNo:47 IS.objSize:3 "%basic 115 | in put: ref elm | in at: var int ..." 
 -- OG:super: "@put:  |    %basic 115 |    in put: ref elm |    in at: var intege ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "D.@put ch :at 1" 
 -- super: "D.@put ch :at 1" 
 -- E: "@put ch :at 1" 
 -- OG:Qalloc:A:"S := D.asString" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"S := D.asString" 
 -- ObjectInvocation:Qalloc:"S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= D.asString" 
 -- name: ":=" 
 -- Arguments "D.asString" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "S := D.asString" 
 -- super: "S := D.asString" 
 -- E: ":= D.asString" 
 -- Items:Qalloc:END:objSize:4  newDescNo:46 "in ch: var char | out S: ref LI ..." 
 -- IS.newDescNo:46 IS.objSize:4 "in ch: var char | out S: ref LIB.String.Str ..." 
 -- computeVariant:newDescNo:46  size: 4  IS:"in ch: var char | out S: ref LI ..." 
 -- ComputeVariant:B: "C" 
 -- ObjTmpStack:add::genDone:false "C" :"in ch: var char | out S: ref LIB.Str ..." 
 -- arg: "chxxx" 
 -- OG:markForCodeGen:"chxxx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "chxxx" 
 -- "chxxx" true
 -- 
 -- ObjectInvocation:markForCodeGen:"print"  ATd:"print:  |    @for 1 :to len ..." 
 -- Pattern:markForCodeGen:"print:  |    @for 1 :to length  |    :do  |       put ..." 
 -- not ObjDesc: ""bingo: {C(chxxx)}".print"  IS.isEmpty: true
 -- markItem:"@leave loop" ObjectGenerator
 -- ComputeVariant:A:"else#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:else
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- OG:Qalloc:A:"Object" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"Object" 
 -- ObjectInvocation:Qalloc:"Object" 
 -- name: "Object" 
 -- Arguments "" 
 -- OG:super: "Object:  |    %ID Object |    %basic 64 |    %public |    := :  |      ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "Object" 
 -- super: "Object" 
 -- E: "Object" 
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:""bingo: {C(chxxx)}".print | @leave loop" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- ""bingo: {C(chxxx)}".print | @leave loop" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"else#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:48 IS.newDescNo:48 objSize:0 varNo:1 ""bingo: ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:48 ""bingo: {C(chxxx)}".print | @leave  ..." 
 -- Items:Qalloc:super:"" :super:size:1 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:1 originOff:1 
 -- OG:Qalloc:A:""bingo: {C(chxxx)}".print" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:""bingo: {C(chxxx)}".print" 
 -- Invocation:Qalloc:"C(chxxx)" 
 -- ObjectInvocation:Qalloc:"C(chxxx)" 
 -- name: "C" 
 -- Arguments "(chxxx)" 
 -- ObjectInvocation:Qalloc:"print" 
 -- name: "print" 
 -- Arguments "" 
 -- OG:super: "print:  |    @for 1 :to length  |    :do  |       put(@get inx)" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- ""bingo: {C(chxxx)}".print" 
 -- super: ""bingo: {C(chxxx)}".print" 
 -- E: "print" 
 -- OG:Qalloc:A:"@leave loop" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@leave loop" 
 -- ObjectInvocation:Qalloc:"@leave loop" 
 -- name: "@leave" 
 -- Arguments "@leave loop" 
 -- OG:super: "@leave:  |    %basic 103 |    in leave: var integer" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@leave loop" 
 -- super: "@leave loop" 
 -- E: "@leave loop" 
 -- Items:Qalloc:END:objSize:1  newDescNo:48 ""bingo: {C(chxxx)}".print | @le ..." 
 -- IS.newDescNo:48 IS.objSize:1 ""bingo: {C(chxxx)}".print | @leave loop" 
 -- computeVariant:newDescNo:48  size: 1  IS:""bingo: {C(chxxx)}".print | @le ..." 
 -- ComputeVariant:B: "else#S#48" 
 -- ObjTmpStack:add::genDone:false ""bingo: {C(chxxx)}".print | @leave loop" 
 -- OG:markIS:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart ..." 
 -- items:markForCodeGen:"" 
 -- ComputeVariant:A:"@if::then:else#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@if::then:else
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @resta ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |     ..." 
 -- ObjectInvocation:Qalloc:"@if ascii.isLetter(chxxx) :then  |    chxxx := ' ..." 
 -- name: "@if::then:else" 
 -- Arguments "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart ..." 
 -- OG:super: "@if:  |    %globals inSub --,OSDvisibility[disguised]] |     |     ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  | :el ..." 
 -- super: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart lo ..." 
 -- E: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  |  ..." 
 -- OG:Qalloc:B:"@if::then:else#S#0" newDescNo:0 objSize:2 
 -- OG:isObjectDesc:NewDescNo:49 IS.newDescNo:49 objSize:2 varNo:1 "" 
 -- Items:Qalloc:objSize:0  newDescNo:49 "" 
 -- Items:Qalloc:super:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    ..." : ...2 : ...true
 -- Items:Qalloc:super:B:objSize:3 originOff:3 
 -- Items:Qalloc:END:objSize:3  newDescNo:49 "" 
 -- IS.newDescNo:49 IS.objSize:2 "" 
 -- computeVariant:newDescNo:49  size: 2  IS:"" 
 -- ComputeVariant:B: "@if::then:else#S#49" 
 -- ObjTmpStack:add::genDone:false "@if ascii.isLetter(chxxx) :then  |    chx ..." 
 -- ComputeVariant:A:"switch#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:switch
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"switch(chxxx) |    case('a') |       "Got  a: ".print |    "else ..."" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"switch(chxxx)" 
 -- ObjectInvocation:Qalloc:"switch(chxxx)" 
 -- name: "switch" 
 -- Arguments "(chxxx)" 
 -- OG:super: "switch:  |    in V: var integer |    %public |    case:  |       in  ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "switch(chxxx) |    case('a') |       "Got  a: ".print |    "else:".print |     ..." 
 -- super: "switch(chxxx)" 
 -- E: "switch(chxxx)" 
 -- OG:Qalloc:B:"switch#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:50 IS.newDescNo:50 objSize:0 varNo:1 "case('a ..." 
 -- Items:Qalloc:objSize:0  newDescNo:50 "case('a') |    "Got  a: ".print | "el ..."" 
 -- Items:Qalloc:super:"switch(chxxx)" :super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:3 originOff:3 
 -- OG:Qalloc:A:"case('a') |    "Got  a: ".print" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"case('a')" 
 -- ObjectInvocation:Qalloc:"case('a')" 
 -- name: "case" 
 -- Arguments "('a')" 
 -- OG:super: "case:  |    in x: ref Indexed(1,#Integer) |    @for 1 :to x.leng ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "case('a') |    "Got  a: ".print" 
 -- super: "case('a')" 
 -- E: "case('a')" 
 -- OG:Qalloc:B:"case#S#38" newDescNo:38 objSize:2 
 -- OG:isObjectDesc:NewDescNo:51 IS.newDescNo:51 objSize:2 varNo:1 ""Got  a ..."" 
 -- Items:Qalloc:objSize:2  newDescNo:51 ""Got  a: ".print" 
 -- Items:Qalloc:super:"case('a')" :super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- OG:Qalloc:A:""Got  a: ".print" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:""Got  a: ".print" 
 -- ObjectInvocation:Qalloc:"print" 
 -- name: "print" 
 -- Arguments "" 
 -- OG:super: "print:  |    @for 1 :to length  |    :do  |       put(@get inx)" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- ""Got  a: ".print" 
 -- super: ""Got  a: ".print" 
 -- E: "print" 
 -- Items:Qalloc:END:objSize:2  newDescNo:51 ""Got  a: ".print" 
 -- IS.newDescNo:51 IS.objSize:2 ""Got  a: ".print" 
 -- OG:Qalloc:A:""else:".print" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:""else:".print" 
 -- ObjectInvocation:Qalloc:"print" 
 -- name: "print" 
 -- Arguments "" 
 -- OG:super: "print:  |    @for 1 :to length  |    :do  |       put(@get inx)" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- ""else:".print" 
 -- super: ""else:".print" 
 -- E: "print" 
 -- OG:Qalloc:A:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @resta ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |     ..." 
 -- ObjectInvocation:Qalloc:"@if ascii.isLetter(chxxx) :then  |    chxxx := ' ..." 
 -- name: "@if::then:else" 
 -- Arguments "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart ..." 
 -- OG:super: "@if:  |    %globals inSub --,OSDvisibility[disguised]] |     |     ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  | :el ..." 
 -- super: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart lo ..." 
 -- E: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  |  ..." 
 -- OG:Qalloc:B:"@if::then:else#S#49" newDescNo:49 objSize:2 
 -- OG:isObjectDesc:NewDescNo:52 IS.newDescNo:52 objSize:2 varNo:1 "" 
 -- Items:Qalloc:objSize:3  newDescNo:52 "" 
 -- Items:Qalloc:super:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    ..." : ...2 : ...true
 -- Items:Qalloc:super:B:objSize:3 originOff:3 
 -- Items:Qalloc:END:objSize:3  newDescNo:52 "" 
 -- IS.newDescNo:52 IS.objSize:2 "" 
 -- Items:Qalloc:END:objSize:3  newDescNo:50 "case('a') |    "Got  a: ".print ..." 
 -- IS.newDescNo:50 IS.objSize:3 "case('a') |    "Got  a: ".print | "else:".pri ..." 
 -- computeVariant:newDescNo:50  size: 3  IS:"case('a') |    "Got  a: ".print ..." 
 -- ComputeVariant:B: "switch#S#50" 
 -- ObjTmpStack:add::genDone:false "switch(chxxx) |    case('a') |       "Got   ..."" 
 -- markItem:"chxxx := '?'" ObjectGenerator
 -- OG:markForCodeGen:"chxxx := '?'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "chxxx := '?'" 
 -- "chxxx" true
 -- ":= '?'" true
 -- 
 -- OG:markSuper:"chxxx := '?'" 
 -- Invocation:markForCodeGen:"chxxx := '?'" 
 -- ObjectInvocation:markForCodeGen:"chxxx"  ATd:"chxxx: var char" 
 -- DataItem:markForCodeGen:"chxxx" :descNo:0 :OG.primNo:3 
 -- ObjectInvocation:markForCodeGen:":= '?'"  ATd:":= :  |    %basic 8 |    in  ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "'?'" 
 -- OG:markForCodeGen:"'?'" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "'?'" 
 -- "'?'" true
 -- 
 -- OG:markSuper:"'?'" 
 -- Invocation:markForCodeGen:"'?'" 
 -- not ObjDesc: "'?'"  IS.isEmpty: true
 -- not ObjDesc: "chxxx := '?'"  IS.isEmpty: true
 -- markItem:"@restart loop" ObjectGenerator
 -- ComputeVariant:A:"loop" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"switch(chxxx) |    case('a') |       "Got  a: ".print |    "else ..."" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "switch(chxxx) |    case('a') |       "Got  a: ".print |    "else:".print |     ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"loop" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:53 IS.newDescNo:53 objSize:0 varNo:1 "switch( ..." 
 -- Items:Qalloc:objSize:0  newDescNo:53 "switch(chxxx) |    case('a') |        ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- OG:Qalloc:A:"switch(chxxx) |    case('a') |       "Got  a: ".print |    "else ..."" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"switch(chxxx)" 
 -- ObjectInvocation:Qalloc:"switch(chxxx)" 
 -- name: "switch" 
 -- Arguments "(chxxx)" 
 -- OG:super: "switch:  |    in V: var integer |    %public |    case:  |       in  ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "switch(chxxx) |    case('a') |       "Got  a: ".print |    "else:".print |     ..." 
 -- super: "switch(chxxx)" 
 -- E: "switch(chxxx)" 
 -- OG:Qalloc:B:"switch#S#50" newDescNo:50 objSize:3 
 -- OG:isObjectDesc:NewDescNo:54 IS.newDescNo:54 objSize:3 varNo:1 "case('a ..." 
 -- Items:Qalloc:objSize:3  newDescNo:54 "case('a') |    "Got  a: ".print | "el ..."" 
 -- Items:Qalloc:super:"switch(chxxx)" :super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:3 originOff:3 
 -- OG:Qalloc:A:"case('a') |    "Got  a: ".print" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"case('a')" 
 -- ObjectInvocation:Qalloc:"case('a')" 
 -- name: "case" 
 -- Arguments "('a')" 
 -- OG:super: "case:  |    in x: ref Indexed(1,#Integer) |    @for 1 :to x.leng ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "case('a') |    "Got  a: ".print" 
 -- super: "case('a')" 
 -- E: "case('a')" 
 -- OG:Qalloc:B:"case#S#51" newDescNo:51 objSize:2 
 -- OG:isObjectDesc:NewDescNo:55 IS.newDescNo:55 objSize:2 varNo:1 ""Got  a ..."" 
 -- Items:Qalloc:objSize:2  newDescNo:55 ""Got  a: ".print" 
 -- Items:Qalloc:super:"case('a')" :super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:1 
 -- OG:Qalloc:A:""Got  a: ".print" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:""Got  a: ".print" 
 -- ObjectInvocation:Qalloc:"print" 
 -- name: "print" 
 -- Arguments "" 
 -- OG:super: "print:  |    @for 1 :to length  |    :do  |       put(@get inx)" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- ""Got  a: ".print" 
 -- super: ""Got  a: ".print" 
 -- E: "print" 
 -- Items:Qalloc:END:objSize:2  newDescNo:55 ""Got  a: ".print" 
 -- IS.newDescNo:55 IS.objSize:2 ""Got  a: ".print" 
 -- OG:Qalloc:A:""else:".print" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:""else:".print" 
 -- ObjectInvocation:Qalloc:"print" 
 -- name: "print" 
 -- Arguments "" 
 -- OG:super: "print:  |    @for 1 :to length  |    :do  |       put(@get inx)" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- ""else:".print" 
 -- super: ""else:".print" 
 -- E: "print" 
 -- OG:Qalloc:A:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @resta ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |     ..." 
 -- ObjectInvocation:Qalloc:"@if ascii.isLetter(chxxx) :then  |    chxxx := ' ..." 
 -- name: "@if::then:else" 
 -- Arguments "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart ..." 
 -- OG:super: "@if:  |    %globals inSub --,OSDvisibility[disguised]] |     |     ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  | :el ..." 
 -- super: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart lo ..." 
 -- E: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart loop  |  ..." 
 -- OG:Qalloc:B:"@if::then:else#S#52" newDescNo:52 objSize:2 
 -- OG:isObjectDesc:NewDescNo:56 IS.newDescNo:56 objSize:2 varNo:1 "" 
 -- Items:Qalloc:objSize:3  newDescNo:56 "" 
 -- Items:Qalloc:super:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    ..." : ...2 : ...true
 -- Items:Qalloc:super:B:objSize:3 originOff:3 
 -- Items:Qalloc:END:objSize:3  newDescNo:56 "" 
 -- IS.newDescNo:56 IS.objSize:2 "" 
 -- Items:Qalloc:END:objSize:3  newDescNo:54 "case('a') |    "Got  a: ".print ..." 
 -- IS.newDescNo:54 IS.objSize:3 "case('a') |    "Got  a: ".print | "else:".pri ..." 
 -- OG:Qalloc:A:"chxxx := '?'" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"chxxx := '?'" 
 -- ObjectInvocation:Qalloc:"chxxx" 
 -- name: "chxxx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= '?'" 
 -- name: ":=" 
 -- Arguments "'?'" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "chxxx := '?'" 
 -- super: "chxxx := '?'" 
 -- E: ":= '?'" 
 -- OG:Qalloc:A:"@restart loop" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@restart loop" 
 -- ObjectInvocation:Qalloc:"@restart loop" 
 -- name: "@restart" 
 -- Arguments "@restart loop" 
 -- OG:super: "@restart:  |    %basic 102 |    in restart: var integer" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@restart loop" 
 -- super: "@restart loop" 
 -- E: "@restart loop" 
 -- Items:Qalloc:END:objSize:1  newDescNo:53 "switch(chxxx) |    case('a') |    ..." 
 -- IS.newDescNo:53 IS.objSize:1 "switch(chxxx) |    case('a') |       "Got  a: ..."" 
 -- computeVariant:newDescNo:53  size: 1  IS:"switch(chxxx) |    case('a') |    ..." 
 -- ComputeVariant:B: "loop" 
 -- ObjTmpStack:add::genDone:false "loop" :"switch(chxxx) |    case('a') |      ..." 
 -- not ObjDesc: "loop"  IS.isEmpty: true
 -- markItem:"put(chxxx)" ObjectGenerator
 -- OG:markForCodeGen:"put(chxxx)" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "put(chxxx)" 
 -- "put(chxxx)" true
 -- 
 -- OG:markSuper:"put(chxxx)" 
 -- Invocation:markForCodeGen:"put(chxxx)" 
 -- ObjectInvocation:markForCodeGen:"put(chxxx)"  ATd:"put:  |    %globals |    ..." 
 -- Pattern:markForCodeGen:"put:  |    %globals |    %basic 2 |    in ch: val cha ..." 
 -- arg: "chxxx" 
 -- OG:markForCodeGen:"chxxx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "chxxx" 
 -- "chxxx" true
 -- 
 -- not ObjDesc: "put(chxxx)"  IS.isEmpty: true
 -- markItem:"newline" ObjectGenerator
 -- OG:markForCodeGen:"newline" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "newline" 
 -- "newline" false
 -- 
 -- OG:markSuper:"newline" 
 -- Invocation:markForCodeGen:"newline" 
 -- ObjectInvocation:markForCodeGen:"newline"  ATd:"newline:  |    %globals |   ..." 
 -- Pattern:markForCodeGen:"newline:  |    %globals |    put(10)" 
 -- OG:markForCodeGen:"%globals | put(10)" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"%globals | put(10)" 
 -- items:markForCodeGen:"%globals | put(10)" 
 -- markItem:"%globals" Property
 -- markItem:"put(10)" ObjectGenerator
 -- OG:markForCodeGen:"put(10)" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "put(10)" 
 -- "put(10)" true
 -- 
 -- OG:markSuper:"put(10)" 
 -- Invocation:markForCodeGen:"put(10)" 
 -- ObjectInvocation:markForCodeGen:"put(10)"  ATd:"put:  |    %globals |    %b ..." 
 -- Pattern:markForCodeGen:"put:  |    %globals |    %basic 2 |    in ch: val cha ..." 
 -- arg: "10" 
 -- OG:markForCodeGen:"10" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "10" 
 -- "10" true
 -- 
 -- OG:markSuper:"10" 
 -- Invocation:markForCodeGen:"10" 
 -- not ObjDesc: "10"  IS.isEmpty: true
 -- not ObjDesc: "put(10)"  IS.isEmpty: true
 -- ComputeVariant:A:"newline" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%globals | put(10)" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%globals | put(10)" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"newline" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:57 IS.newDescNo:57 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:57 "%globals | put(10)" 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- OG:Qalloc:A:"put(10)" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"put(10)" 
 -- ObjectInvocation:Qalloc:"put(10)" 
 -- name: "put" 
 -- Arguments "(10)" 
 -- OG:super: "put:  |    %globals |    %basic 2 |    in ch: val char" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "put(10)" 
 -- super: "put(10)" 
 -- E: "put(10)" 
 -- Items:Qalloc:END:objSize:0  newDescNo:57 "%globals | put(10)" 
 -- IS.newDescNo:57 IS.objSize:0 "%globals | put(10)" 
 -- computeVariant:newDescNo:57  size: 0  IS:"%globals | put(10)" 
 -- ComputeVariant:B: "newline" 
 -- ObjTmpStack:add::genDone:false "newline" :"%globals | put(10)" 
 -- not ObjDesc: "newline"  IS.isEmpty: true
 -- ComputeVariant:A:"tinyB" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%include String | Y: var integer | chxxx: var char | chxxx := 'a ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%include String | Y: var integer | chxxx: var char | chxxx := 'a' | loop:  |     ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"tinyB" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:58 IS.newDescNo:58 objSize:0 varNo:1 "%includ ..." 
 -- Items:Qalloc:objSize:0  newDescNo:58 "%include String | Y: var integer | ch ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"Y" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:2 
 -- dataitem:qalloc:"chxxx" isValue:true isPrimitive:true isValObj: true is ...true
 -- diSize:1 IT.qSize:3 
 -- OG:Qalloc:A:"chxxx := 'a'" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"chxxx := 'a'" 
 -- ObjectInvocation:Qalloc:"chxxx" 
 -- name: "chxxx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= 'a'" 
 -- name: ":=" 
 -- Arguments "'a'" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "chxxx := 'a'" 
 -- super: "chxxx := 'a'" 
 -- E: ":= 'a'" 
 -- Pattern:Qalloc:loop
 -- Pattern:Qalloc:B:loop
 -- OG:Qalloc:A:"loop" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"loop" 
 -- ObjectInvocation:Qalloc:"loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- OG:super: "loop:  |    switch(chxxx) |       case('a') |          "Got  a: ". ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "loop" 
 -- super: "loop" 
 -- E: "loop" 
 -- OG:Qalloc:A:"put(chxxx)" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"put(chxxx)" 
 -- ObjectInvocation:Qalloc:"put(chxxx)" 
 -- name: "put" 
 -- Arguments "(chxxx)" 
 -- OG:super: "put:  |    %globals |    %basic 2 |    in ch: val char" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "put(chxxx)" 
 -- super: "put(chxxx)" 
 -- E: "put(chxxx)" 
 -- OG:Qalloc:A:"newline" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"newline" 
 -- ObjectInvocation:Qalloc:"newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- OG:super: "newline:  |    %globals |    put(10)" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "newline" 
 -- super: "newline" 
 -- E: "newline" 
 -- Items:Qalloc:END:objSize:3  newDescNo:58 "%include String | Y: var intege ..." 
 -- IS.newDescNo:58 IS.objSize:3 "%include String | Y: var integer | chxxx: var ..." 
 -- computeVariant:newDescNo:58  size: 3  IS:"%include String | Y: var intege ..." 
 -- ComputeVariant:B: "tinyB" 
 -- ObjTmpStack:add::genDone:false "%include String | Y: var integer | chxxx: v ..." 
 -- ComputeVariant:A:"workspace" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%id "workspace" | %include BETA, LIB, LIB.BasicIO | %domain_bo ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%id "workspace" | %include BETA, LIB, LIB.BasicIO | %domain_boundary | " 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"workspace" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:59 IS.newDescNo:59 objSize:0 varNo:1 "%id "wo ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:59 "%id "workspace" | %include BETA, LI ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:tinyB
 -- Module:alloc:off:2 tinyB: obj  |    %include String |    Y: var integer |     ...
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- Items:Qalloc:END:objSize:2  newDescNo:59 "%id "workspace" | %include BETA ..." 
 -- IS.newDescNo:59 IS.objSize:2 "%id "workspace" | %include BETA, LIB, LIB.B ..." 
 -- computeVariant:newDescNo:59  size: 2  IS:"%id "workspace" | %include BETA ..." 
 -- ComputeVariant:B: "workspace" 
 -- ObjTmpStack:add::genDone:false "%id "workspace" | %include BETA, LIB, LIB ..." 
 -- ComputeVariant:A:"BETAworld" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%id "BETAworld" | %modules BETA, LIB, LIB.String | error:  |     ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%id "BETAworld" | %modules BETA, LIB, LIB.String | error:  |    %basic 999 | " 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"BETAworld" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:60 IS.newDescNo:60 objSize:0 varNo:1 "%id "BE ..."" 
 -- Items:Qalloc:objSize:0  newDescNo:60 "%id "BETAworld" | %modules BETA, LI ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- Pattern:Qalloc:error
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:BETA
 -- Module:alloc:off:2 BETA: obj  |    %ID BETA |    %OSDvisibility disguised |   ...
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:LIB
 -- Module:alloc:off:3 LIB: obj  |    %id "LIB" |    %include BETA |    x_dummy_L ...
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc: 
 -- ModuleItem:Qalloc:B:
 -- Qalloc:module:workspace
 -- Module:alloc:off:4 workspace: obj  |    %id "workspace" |    %include BETA, ...
 -- Items:Qalloc:END:objSize:4  newDescNo:60 "%id "BETAworld" | %modules BETA ..." 
 -- IS.newDescNo:60 IS.objSize:4 "%id "BETAworld" | %modules BETA, LIB, LIB.S ..." 
 -- computeVariant:newDescNo:60  size: 4  IS:"%id "BETAworld" | %modules BETA ..." 
 -- ComputeVariant:B: "BETAworld" 
 -- ObjTmpStack:add::genDone:false "%id "BETAworld" | %modules BETA, LIB, LIB ..." 
 -- ComputeVariant:A:"Object" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%ID Object | %basic 64 | %public | := :  |    %basic 8 |    in V: va ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%ID Object | %basic 64 | %public | := :  |    %basic 8 |    in V: var Value | :- : ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"Object" newDescNo:19 objSize:1 
 -- OG:isObjectDesc:NewDescNo:61 IS.newDescNo:61 objSize:1 varNo:1 "%ID Obj ..." 
 -- Items:Qalloc:objSize:1  newDescNo:61 "%ID Object | %basic 64 | %public | := : ..." 
 -- Items:Qalloc:Super:C:objSize:2 originOff:2 
 -- Pattern:Qalloc::=
 -- Pattern:Qalloc::-
 -- Pattern:Qalloc:=
 -- Pattern:Qalloc:<>
 -- Pattern:Qalloc:suspend
 -- Pattern:Qalloc:attach
 -- Pattern:Qalloc:resume
 -- Pattern:Qalloc:onResume
 -- Pattern:Qalloc:onSuspend
 -- Pattern:Qalloc:dumpObj
 -- OG:Qalloc:A:"@inner Object" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"@inner Object" 
 -- ObjectInvocation:Qalloc:"@inner Object" 
 -- name: "@inner" 
 -- Arguments "@inner Object" 
 -- OG:super: "@inner:  |    %basic 101 |    in inner: ref Object" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "@inner Object" 
 -- super: "@inner Object" 
 -- E: "@inner Object" 
 -- Items:Qalloc:END:objSize:2  newDescNo:61 "%ID Object | %basic 64 | %public |  ..." 
 -- IS.newDescNo:61 IS.objSize:2 "%ID Object | %basic 64 | %public | := :  |    %ba ..." 
 -- computeVariant:newDescNo:61  size: 2  IS:"%ID Object | %basic 64 | %public |  ..." 
 -- ComputeVariant:B: "Object" 
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:1 :top:1 
 -- GenClass:Value:varNo = 1 
 -- genClass:super:Value
 -- "" 
 -- GenClass:Object:varNo = 1 
 -- GenClass:Object:true -> var.genDone

class Object 61 2 6
 -- Store itemArgs
 tstOriginIsNone 
 rstore 2 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "Object"
 innerA  1
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%ID Object" 
 -- $Property:gen: "%ID Object"
 -- genclass:Qgen:stmt:"%basic 64" 
 -- $Property:gen: "%basic 64"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 -- genclass:Qgen:stmt:"@inner Object" 
 -- $ObjectGenerator:gen:"@inner:#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"" superDescNo:16 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 16 top: 0 "@inner Object"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@inner Object
 -- isConstant: Invocation @inner Object
 -- Invocation @inner Object
 -- needorigin:"@inner Object" 
 -- needOrigin:E:"@inner Object"  E.ATd:"@inner:  |    %basic 101 |    in inner ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@inner Object" 
 -- computeAdr:1 :rec:"none"  E:"@inner Object" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@inner Object"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@inner Object"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@inner Object"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@inner Object" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@inner Object" E: "@inner Object" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner Object"
 -- $pattern:loadArgs:E:"@inner Object":descNo:16:top:0 "@inner:  |    %basic ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner Object" :Adr:off:0 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner Object" "@inner Object"
 -- >top:0 descNo:16 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@inner Object" 
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- inner:hasArgs:@inner Object
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner Object:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner Object" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"Object" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- GenClass:Value:true -> var.genDone

class Value 1 0 6
 -- Store itemArgs
 -- $Signature:gen: "Value"
DO:
 L1:
 -- genclass:Qgen:stmt:"%ID Value" 
 -- $Property:gen: "%ID Value"
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 21" 
 -- $Property:gen: "%basic 21"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"Value" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:0 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:2 :top:1 
 -- GenClass:universal:varNo = 1 
 -- GenClass:universal:true -> var.genDone

class universal 2 0 6
 -- Store itemArgs
 -- $Signature:gen: "universal"
DO:
 L1:
 -- genclass:Qgen:stmt:"%ID universal" 
 -- $Property:gen: "%ID universal"
 -- genclass:Qgen:stmt:"%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 L2:
 -- OG:pushReturn:"universal" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:0 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:3 :top:1 
 -- GenClass:char:varNo = 1 
 -- GenClass:char:true -> var.genDone

class char 3 0 6
 -- Store itemArgs
 -- $Signature:gen: "char"
 -- $var:gen: "_thisBasicValue: var Universal"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:universal:OGqual.isBasicValue:true:OGqual.isValueObj:true
DO:
 L1:
 -- genclass:Qgen:stmt:"%id "char"" 
 -- $Property:gen: "%id "char""
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 3, 16" 
 -- $Property:gen: "%basic 3, 16"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"char" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:4 :top:1 
 -- GenClass::=:varNo = 1 
 -- GenClass::=:true -> var.genDone

class := 4 1 1
 -- Store itemArgs
 pushThis 
 storeg 3 V
 tstOriginIsNone 
 rstore 1 origin
 -- origin.valueOff:store:2 
 store 2 originOff
 allocEventQ
 mvStack 
 -- $Signature:gen: ":= "
 -- $var:gen: "in V: var Value"
 -- DI:isConst:false:isBasicValue:false:primNo:21 
 -- OGqual:Value:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- inArg:in V: var Value
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%basic 8" 
 -- $Property:gen: "%basic 8"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:":=" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:-2 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:5 :top:1 
 -- GenClass:ascii:varNo = 1 
 -- GenClass:ascii:true -> var.genDone

class ascii 5 1 6
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $val:gen: "nl: val 10"
 -- DI:isConst:true:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $ObjectGenerator:gen:"nl"IS.isempty! staticOff: 0 descNo: 0 top:0 | super ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "10"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral10
 -- isConstant: Invocation 10
 -- Invocation 10
 -- needorigin:"10" 
 -- needOrigin:E:"10"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "10" E: "10" isValueAssign: false
 -- $ConstLiteral:loadArgs: "10"
 -- invoke:after:loadArgsOf:"10" 
 -- $ConstLiteral:invoke: "10"
 pushc 10
 -- invoke:after:E.invoke:"10" 
 -- dataItem:store:basicValue:off:1  NewOff:2 
 pushThis 
 storeg 2 nl
 -- $val:gen: "cr: val 13"
 -- DI:isConst:true:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $ObjectGenerator:gen:"cr"IS.isempty! staticOff: 0 descNo: 0 top:0 | super ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "13"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral13
 -- isConstant: Invocation 13
 -- Invocation 13
 -- needorigin:"13" 
 -- needOrigin:E:"13"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "13" E: "13" isValueAssign: false
 -- $ConstLiteral:loadArgs: "13"
 -- invoke:after:loadArgsOf:"13" 
 -- $ConstLiteral:invoke: "13"
 pushc 13
 -- invoke:after:E.invoke:"13" 
 -- dataItem:store:basicValue:off:2  NewOff:3 
 pushThis 
 storeg 3 cr
 -- $var:gen: "newline: var char"
 -- DI:isConst:false:isBasicValue:true:primNo:3 
 -- OGqual:char:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"newline := cr -- Windows/Linux???" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "newline := cr -- Windows/Linux???"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarynewline
 -- ObjectInvocation_Binary:= cr -- Windows/Linux???
 -- isConstant: Invocation newline := cr -- Windows/Linux???
 -- Invocation newline
 -- not const: newlinenewline: var char
 -- needorigin:"newline := cr -- Windows/Linux???" 
 -- needOrigin:E:":= cr -- Windows/Linux???"  E.ATd:":= :  |    %basic 8 |    i ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "newline := cr -- Windows/Linux???" 
 -- computeAdr:1 :rec:"none"  E:"newline" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "newline"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "newline"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "newline"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "newline: var ch ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...n ...
 -- value_prim:false
 -- char
 -- before:floatTest: "newline: var char" ObjectGenerator
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ne ..."
 -- After:U*U::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"newline"  E:":= cr -- Windows/Linux???"  A.E:"newlin ..." 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ne ..."
 -- computeAdr:isAssign:rec: "newline"  E:":= cr -- Windows/Linux???" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ne ..."
 -- computeAdr:isLast:E: ":= cr -- Windows/Linux???" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "newline" E: ":= cr -- Windows/Linux???" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:4 ":= cr -- Windows/Linux?? ..."
 -- $pattern:loadArgs:E:":= cr -- Windows/Linux???":descNo:4:top:1 ":= :  |   ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= cr -- Windows/Linux???" 
 -- ActArg: "cr -- Windows/Linux???" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= cr -- Windows/Linux???" 
 -- $ObjectGenerator:gen:"cr#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "cr -- Windows/Linux???"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarycr -- Windows/Linux???
 -- isConstant: Invocation cr -- Windows/Linux???
 -- Invocation cr -- Windows/Linux???
 -- const literal: 13 ConstLiteral
 pushc 13
 -- loadArgs:after:Qgen:":= cr -- Windows/Linux???" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= cr -- Windows/Linux???" 
 -- invoke:after:loadArgsOf:":= cr -- Windows/Linux???" :Adr:off:4 sz:0 isF ...
 -- $ObjectInvocation_Binary:invoke: rec:"newline" ":= cr -- Windows/Linux? ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= cr -- Windows/Linux???" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "newline" from: ":= cr -- Windows/Linux???" 
 -- assign:dstDI :"newline: var char" isUnitValueObj: false
 -- assign:arg: "cr -- Windows/Linux???" lab:"ObjectGenerator" UnitValObj : ...false  ...false
 --  float: false DataItem:false arg.super:cr -- Windows/Linux???
 --  arg.super.ATd:"Invocation" "cr: val 13" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "val" 
 -- assign:simple value: 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ne ..."
 -- store::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 4 address:storeg
 -- OI:invoke::= cr -- Windows/Linux???:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= cr -- Windows/Linux???" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:0 vTopMax:1 rTop:3 rTopMax:3
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:6 :top:1 
 -- GenClass:BETA:varNo = 1 
 -- GenClass:BETA:true -> var.genDone

class BETA 6 1 60
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $obj:gen: "ascii: obj  |    nl: val 10 |    cr: val 13 |    newline: var char ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"ascii"singular! staticOff: 2 descNo: 5 top:1 | supe ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 5  "ascii" 
 invoke ascii 5 2 1
 rpop
 -- $ModuleItem:gen: ""
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%ID BETA" 
 -- $Property:gen: "%ID BETA"
 -- genclass:Qgen:stmt:"%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:7 :top:1 
 -- GenClass:integer:varNo = 1 
 -- GenClass:integer:true -> var.genDone

class integer 7 0 6
 -- Store itemArgs
 -- $Signature:gen: "integer"
 -- $var:gen: "_thisBasicValue: var Universal"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:universal:OGqual.isBasicValue:true:OGqual.isValueObj:true
DO:
 L1:
 -- genclass:Qgen:stmt:"%ID integer" 
 -- $Property:gen: "%ID integer"
 -- genclass:Qgen:stmt:"%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"integer" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:8 :top:1 
 -- GenClass:keyboard:varNo = 1 
 -- GenClass:keyboard:true -> var.genDone

class keyboard 8 1 11
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:9 :top:1 
 -- GenClass:Lock:varNo = 1 
 -- GenClass:Lock:true -> var.genDone

class Lock 9 1 11
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "Lock"
 -- $var:gen: "dummy: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "M: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"Lock" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:10 :top:1 
 -- GenClass:screen:varNo = 1 
 -- GenClass:screen:true -> var.genDone

class screen 10 1 11
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $obj:gen: "L: obj Lock"
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:Lock:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"L"IS.isempty! staticOff: 2 descNo: 0 top:0 | superA ...
 -- OG:gen:super:"Lock" superDescNo:9 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 9 top: 1 "Lock"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryLock
 -- isConstant: Invocation Lock
 -- Invocation Lock
 -- needorigin:"Lock" 
 -- needOrigin:E:"Lock"  E.ATd:"Lock:  |    dummy: var integer |    %Public |     ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "Lock" 
 -- computeAdr:1 :rec:"none"  E:"Lock" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "Lock"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "Lock"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:screen:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 screen:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "Lock"
 -- $pattern:getAdr: "Lock:  |    dummy: var integer |    %Public |    M: var int ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"Lo ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "Lock" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "Lock" E: "Lock" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Lock"
 -- $pattern:loadArgs:E:"Lock":descNo:9:top:1 "Lock:  |    dummy: var integer ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"Lock" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"Lock" "Lock"
 -- >top:1 descNo:9 
 -- E.ATd: "Lock" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"Lock" 
 -- $pattern:invoke: "Lock:  |    dummy: var integer |    %Public |    M: var int ..."
 -- Pattern:invoke:descNo:9  top:1  rec:"Lock" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"Lock:  |    dummy: var intege ..." 
 -- rec=E:true:rec:"Lock" 
 -- kuk:obj:rec.ATd:"Lock:  |    dummy: var integer |    %Public |    M: var inte ..." 
 invoke Lock 9 2 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"Lock" 
 rpop
 -- OI:invoke:Lock:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Lock" 
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:11 :top:1 
 -- GenClass:BasicIO:varNo = 1 
 -- GenClass:BasicIO:true -> var.genDone

class BasicIO 11 1 14
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $obj:gen: "keyboard: obj  |    %Public |    readLine:  |       out M: ref LIB ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"keyboard"singular! staticOff: 2 descNo: 8 top:1 | s ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 8  "keyboard" 
 invoke keyboard 8 2 1
 rpop
 -- $obj:gen: "screen: obj  |    L: obj Lock |    %Public |    init:  |       L.get ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"screen"singular! staticOff: 3 descNo: 10 top:1 | su ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 10  "screen" 
 invoke screen 10 3 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%Public" 
 -- $Property:gen: "%Public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:12 :top:1 
 -- GenClass:String:varNo = 1 
 -- GenClass:String:true -> var.genDone

class String 12 1 13
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "String"
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%id "String pattern"" 
 -- $Property:gen: "%id "String pattern""
 -- genclass:Qgen:stmt:"%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"
 -- genclass:Qgen:stmt:"%basic 5" 
 -- $Property:gen: "%basic 5"
 -- genclass:Qgen:stmt:"%immutable" 
 -- $Property:gen: "%immutable"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"String" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:1  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:13 :top:1 
 -- GenClass:String:varNo = 1 
 -- GenClass:String:true -> var.genDone

class String 13 1 14
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 saveStringOrigin
 mvStack 
 -- $pattern:gen: "String:  |    %id "String pattern" |    %OSDvisibility disgu ..."
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%id "String module"" 
 -- $Property:gen: "%id "String module""
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:14 :top:1 
 -- GenClass:LIB:varNo = 1 
 -- GenClass:LIB:true -> var.genDone

class LIB 14 1 60
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $var:gen: "x_dummy_LIB: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- ModuleItem:gen BasicIO
 -- $obj:gen: "BasicIO: obj  |    %Public |    Lock:  |       dummy: var integer |  ..."
 -- $ObjectGenerator:gen:"BasicIO"singular! staticOff: 3 descNo: 11 top:1 | s ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 11  "BasicIO" 
 invoke BasicIO 11 3 1
 rpop
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- ModuleItem:gen String
 -- $obj:gen: "String: obj  |    %id "String module" |    %public |    String:  |   ..."
 -- $ObjectGenerator:gen:"String"singular! staticOff: 4 descNo: 13 top:1 | su ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 13  "String" 
 invoke String 13 4 1
 rpop
 -- $ModuleItem:gen: ""
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%id "LIB"" 
 -- $Property:gen: "%id "LIB""
 -- genclass:Qgen:stmt:"%include BETA" 
 -- $Property:gen: "%include BETA"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:15 :top:1 
 -- GenClass:switch:varNo = 1 
 -- GenClass:switch:true -> var.genDone

class switch 15 1 6
 -- Store itemArgs
 pushThis 
 storeg 2 V
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "switch"
 -- $var:gen: "in V: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 innerA  1
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 -- genclass:Qgen:stmt:"@inner switch" 
 -- $ObjectGenerator:gen:"@inner:#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"" superDescNo:16 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 16 top: 0 "@inner switch"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@inner switch
 -- isConstant: Invocation @inner switch
 -- Invocation @inner switch
 -- needorigin:"@inner switch" 
 -- needOrigin:E:"@inner switch"  E.ATd:"@inner:  |    %basic 101 |    in inner ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@inner switch" 
 -- computeAdr:1 :rec:"none"  E:"@inner switch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@inner switch"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@inner switch"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@inner switch"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@inner switch" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@inner switch" E: "@inner switch" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner switch"
 -- $pattern:loadArgs:E:"@inner switch":descNo:16:top:0 "@inner:  |    %basic ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner switch" :Adr:off:0 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner switch" "@inner switch"
 -- >top:0 descNo:16 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@inner switch" 
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- inner:hasArgs:@inner switch
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 pushThis 
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner switch:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner switch" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"switch" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:17 :top:1 
 -- GenClass:Boolean:varNo = 1 
 -- GenClass:Boolean:true -> var.genDone

class Boolean 17 0 6
 -- Store itemArgs
 -- $Signature:gen: "Boolean"
 -- $var:gen: "_thisBasicValue: var Universal"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:universal:OGqual.isBasicValue:true:OGqual.isValueObj:true
DO:
 L1:
 -- genclass:Qgen:stmt:"%globals inSub" 
 -- $Property:gen: "%globals inSub"
 -- genclass:Qgen:stmt:"%basic 4, 8" 
 -- $Property:gen: "%basic 4, 8"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 -- OG:pushReturn:"Boolean" 
 rtnV
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:18 :top:1 
 -- GenClass:@if::then:varNo = 1 
 -- GenClass:@if::then:true -> var.genDone

class @if::then 18 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 if
 allocEventQ
 mvStack 
 -- $Signature:gen: ""
 -- $var:gen: "in if: var boolean"
 -- DI:isConst:false:isBasicValue:true:primNo:4 
 -- OGqual:Boolean:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in then:< Object"
 -- vdt:d1 61 
 -- vdtAdd: inx=1 descInx=18 vDescInx=61
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals inSub" 
 -- $Property:gen: "%globals inSub"
 -- genclass:Qgen:stmt:"%basic 100" 
 -- $Property:gen: "%basic 100"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"@if::then" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:20 :top:1 
 -- GenClass:#S#20:varNo = 1 
 -- GenClass:#S#20:true -> var.genDone

class #S#20 20 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"do" 
 -- $ObjectGenerator:gen:"do#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:"do" superDescNo:0 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 1 "do"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarydo
 -- isConstant: Invocation do
 -- Invocation do
 -- needorigin:"do" 
 -- needOrigin:E:"do"  E.ATd:"in do:< Object" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "do" 
 -- computeAdr:1 :rec:"none"  E:"do" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "do"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "do"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:3 
 -- goOrigin:#S#20:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#20:origin
 -- goOrigin:on:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:on:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:on:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "do"
 -- $pattern:getAdr: "in do:< Object"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"do ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "do" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "do" E: "do" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "do"
 -- $pattern:loadArgs:E:"do":descNo:0:top:1 "in do:< Object"
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"do" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ ...
 -- $ObjectInvocation_Unary:invoke: rec:"do" "do"
 -- >top:1 descNo:0 
 -- E.ATd: "do" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"do" 
 -- $pattern:invoke: "in do:< Object"
 -- Pattern:invoke:descNo:0  top:1  rec:"do" 
 sendv 1 0 do
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"do" 
 rpop
 -- OI:invoke:do:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"do" 
 -- genclass:Qgen:stmt:"inx := inx + 1" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "inx := inx + 1"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- ObjectInvocation_Binary:= inx + 1
 -- isConstant: Invocation inx := inx + 1
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx := inx + 1" 
 -- needOrigin:E:":= inx + 1"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx := inx + 1" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:3 
 -- goOrigin:#S#20:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#20:origin
 -- goOrigin:on:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:on:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:on:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"inx"  E:":= inx + 1"  A.E:"inx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- computeAdr:isAssign:rec: "inx"  E:":= inx + 1" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- computeAdr:isLast:E: ":= inx + 1" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: ":= inx + 1" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= inx + 1"
 -- $pattern:loadArgs:E:":= inx + 1":descNo:4:top:1 ":= :  |    %basic 8 |    i ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= inx + 1" 
 -- ActArg: "inx + 1" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= inx + 1" 
 -- $ObjectGenerator:gen:"+#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:gen:super:"+  | --%basic 61]] | " superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "inx + 1"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- ObjectInvocation_Binary+ 1
 -- isConstant: Invocation inx + 1
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx + 1" 
 -- needOrigin:E:"+ 1"  E.ATd:"+ :  |    %basic 61 |    in V: var integer |    ou ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx + 1" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:3 
 -- goOrigin:#S#20:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#20:origin
 -- goOrigin:on:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:on:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:on:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"inx"  E:"+ 1"  A.E:"inx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- E:notAssign:+ 1
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ 1"
 -- $pattern:getAdr: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ 1" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "+ 1" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ 1"
 -- $pattern:loadArgs:E:"+ 1":descNo:0:top:0 "+ :  |    %basic 61 |    in V: va ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ 1" 
 -- ActArg: "1" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "+ 1" 
 -- loadArgs:not:*: formalArgOf:"+ 1"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "1"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral1
 -- isConstant: Invocation 1
 -- Invocation 1
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"+ 1" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"+ 1" 
 -- invoke:after:loadArgsOf:"+ 1" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" "+ 1"
 -- >top:0 descNo:0 
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"+ 1" 
 -- $pattern:invoke: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- bodyC:
 plus
 -- OI:invoke:+ 1:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"+ 1" 
 -- loadArgs:after:Qgen:":= inx + 1" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= inx + 1" 
 -- invoke:after:loadArgsOf:":= inx + 1" :Adr:off:3 sz:0 isF:F isUN:F sprAd ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" ":= inx + 1"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= inx + 1" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "inx" from: ":= inx + 1" 
 -- assign:dstDI :"inx: var integer" isUnitValueObj: false
 -- assign:arg: "inx + 1" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:inx + 1
 --  arg.super.ATd:"Invocation" "+ :  |    %basic 61 |    in V: var integer |     ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 3 address:storeg
 -- OI:invoke::= inx + 1:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= inx + 1" 
 -- genclass:Qgen:stmt:"@restart loop" 
 -- $ObjectGenerator:gen:"@restart:#S#0"IS.isempty! staticOff: 0 descNo: 0  ...
 -- OG:gen:super:"" superDescNo:21 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 21 top: 0 "@restart loop"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@restart loop
 -- isConstant: Invocation @restart loop
 -- Invocation @restart loop
 -- needorigin:"@restart loop" 
 -- needOrigin:E:"@restart loop"  E.ATd:"@restart:  |    %basic 102 |    in res ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@restart loop" 
 -- computeAdr:1 :rec:"none"  E:"@restart loop" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@restart loop"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@restart loop"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@restart loop"
 -- $pattern:getAdr: "@restart:  |    %basic 102 |    in restart: var integer"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@r ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@restart loop" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@restart loop" E: "@restart loop" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@restart loop"
 -- $pattern:loadArgs:E:"@restart loop":descNo:21:top:0 "@restart:  |    %bas ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@restart loop" :Adr:off:0 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@restart loop" "@restart loop"
 -- >top:0 descNo:21 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@restart loop" 
 -- $pattern:invoke: "@restart:  |    %basic 102 |    in restart: var integer"
 break 1 1 22
 -- OI:invoke:@restart loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@restart loop" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:1 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:22 :top:1 
 -- GenClass:loop:varNo = 1 
 -- GenClass:loop:true -> var.genDone

class loop 22 1 23
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@if inx <= to :then  |    do |    inx := inx + 1 |    @re ..." 
 -- $ObjectGenerator:gen:"@if::then#S#0"IS.isempty! staticOff: 0 descNo: 0  ...
 -- OG:gen:super:"" superDescNo:18 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 18 top: 1 "@if inx <= to :then  |    do |    inx : ..."
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@if inx <= to :then  |    do |    inx := inx + 1 |    ...
 -- isConstant: Invocation @if inx <= to :then  |    do |    inx := inx + 1 |     ...
 -- Invocation @if inx <= to :then  |    do |    inx := inx + 1 |    @restart loo ...
 -- needorigin:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart lo ..." 
 -- needOrigin:E:"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart  ..."   ..."@ ..." 
 -- LoadOrign:no:loadOrigin: "%globals inSub | %basic 100 | in if: var boolean |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" E ..."@ ..." i ...false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@if inx <= to :then  |    ..."
 -- $pattern:loadArgs:E:"@if inx <= to :then  |    do |    inx := inx + 1 |    @r ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@if inx <= to :then  |    do |    inx := inx + 1 |   ..." 
 -- $ObjectInvocation_KeyWord:invoke: rec:"@if inx <= to :then  |    do |    in ..."
 -- >top:1 descNo:18 
 -- HEST"@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop" 
 -- $pattern:invoke: "@if:  |    %globals inSub |    %basic 100 |    in if: var b ..."
 -- $ObjectGenerator:gen:"<=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:"<= " superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "inx <= to"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- ObjectInvocation_Binary<= to
 -- isConstant: Invocation inx <= to
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx <= to" 
 -- needOrigin:E:"<= to"  E.ATd:"<= :  |    %basic 52 |    in V: var integer |    ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx <= to" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:on:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"inx"  E:"<= to"  A.E:"inx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- E:notAssign:<= to
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= to"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var integer |    out B: var ..."
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "<= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "<= to" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "<= to" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "<= to"
 -- $pattern:loadArgs:E:"<= to":descNo:0:top:0 "<= :  |    %basic 52 |    in V: ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"<= to" 
 -- ActArg: "to" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "<= to" 
 -- loadArgs:not:*: formalArgOf:"<= to"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"to#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "to"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryto
 -- isConstant: Invocation to
 -- Invocation to
 -- not const: toin to: var integer
 -- needorigin:"to" 
 -- needOrigin:E:"to"  E.ATd:"in to: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "to" 
 -- computeAdr:1 :rec:"none"  E:"to" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "to"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "to"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:on:1 
 -- goOrigin:doIt:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doIt:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "to"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in to: var inte ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "in to: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"to ..."
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "to" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "to" E: "to" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "to"
 -- $var:loadArgs: "in to: var integer"
 -- DataItem:loadArgs:empty: "in to: var integer" 
 -- invoke:after:loadArgsOf:"to" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ ...
 -- $ObjectInvocation_Unary:invoke: rec:"to" "to"
 -- E.ATd: "to" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"to" 
 -- $var:invoke: newOff:2 "in to: var integer"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:to:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"to" 
 -- loadArgs:after:Qgen:"<= to" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"to" :isBasicVal:true
 -- toObjectGenerator
 -- end:loadArgs:NonVirt:"<= to" 
 -- invoke:after:loadArgsOf:"<= to" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" "<= to"
 -- >top:0 descNo:0 
 -- E.ATd: "<= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"<= to" 
 -- $pattern:invoke: "<= :  |    %basic 52 |    in V: var integer |    out B: var ..."
 -- bodyC:
 le
 -- OI:invoke:<= to:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"<= to" 
 jmpFalse L3
 -- $ObjectGenerator:gen:"#S#20"singular! staticOff: 0 descNo: 20 top:1 | sup ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 20  "#S#20" 
 invoke #S#20 20 0 1
 rpop
 L3:
 -- OI:invoke:@if inx <= to :then  |    do |    inx := inx + 1 |    @restart loop ...: ...-none-  ...0.000000
 -- invoke:after:E.invoke:"@if inx <= to :then  |    do |    inx := inx + 1 |     ..." 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:23 :top:1 
 -- GenClass:doIt:varNo = 1 
 -- GenClass:doIt:true -> var.genDone

class doIt 23 1 24
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "doIt"
 -- $obj:gen: "loop: obj  |    @if inx <= to :then  |       do |       inx := inx ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"loop"singular! staticOff: 2 descNo: 22 top:1 | supe ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 22  "loop" 
 invoke loop 22 2 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"doIt" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:24 :top:1 
 -- GenClass:@for::to:do:varNo = 1 
 -- GenClass:@for::to:do:true -> var.genDone

class @for::to:do 24 0 6
 -- Store itemArgs
 pushThis 
 storeg 2 to
 pushThis 
 storeg 1 for
 allocEventQ
 mvStack 
 -- $Signature:gen: ""
 -- $var:gen: "in for: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "in to: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in do:< Object"
 -- vdt:d1 61 
 -- vdtAdd: inx=1 descInx=24 vDescInx=61
 -- $var:gen: "inx: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 innerA  2
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals inSub" 
 -- $Property:gen: "%globals inSub"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 -- genclass:Qgen:stmt:"%private" 
 -- $Property:gen: "%private"
 -- genclass:Qgen:stmt:"inx := for" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "inx := for"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- ObjectInvocation_Binary:= for
 -- isConstant: Invocation inx := for
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx := for" 
 -- needOrigin:E:":= for"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx := for" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "inx"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"inx"  E:":= for"  A.E:"inx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- computeAdr:isAssign:rec: "inx"  E:":= for" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- computeAdr:isLast:E: ":= for" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: ":= for" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= for"
 -- $pattern:loadArgs:E:":= for":descNo:4:top:1 ":= :  |    %basic 8 |    in V: ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= for" 
 -- ActArg: "for" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= for" 
 -- $ObjectGenerator:gen:"for#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "for"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryfor
 -- isConstant: Invocation for
 -- Invocation for
 -- not const: forin for: var integer
 -- needorigin:"for" 
 -- needOrigin:E:"for"  E.ATd:"in for: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "for" 
 -- computeAdr:1 :rec:"none"  E:"for" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "for"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "for"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "for"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "in for: var int ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "in for: var integer" ObjectGenerator
 -- :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"fo ..."
 -- After:U*U::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "for" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "for" E: "for" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "for"
 -- $var:loadArgs: "in for: var integer"
 -- DataItem:loadArgs:empty: "in for: var integer" 
 -- invoke:after:loadArgsOf:"for" :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Unary:invoke: rec:"for" "for"
 -- E.ATd: "for" unique: false
 -- adr::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"for" 
 -- $var:invoke: newOff:1 "in for: var integer"
 -- load::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 1 
 -- OI:invoke:for:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"for" 
 -- loadArgs:after:Qgen:":= for" 
 -- vAssign:fArg:"in V: var Value" 
 -- end:loadArgs:NonVirt:":= for" 
 -- invoke:after:loadArgsOf:":= for" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Binary:invoke: rec:"inx" ":= for"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= for" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "inx" from: ":= for" 
 -- assign:dstDI :"inx: var integer" isUnitValueObj: false
 -- assign:arg: "for" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:for
 --  arg.super.ATd:"Invocation" "in for: var integer" 
 --  arg.super.ATd.isDataItem:true arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "var" 
 -- assign:simple value: 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 3 address:storeg
 -- OI:invoke::= for:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= for" 
 -- genclass:Qgen:stmt:"doIt" 
 -- $ObjectGenerator:gen:"doIt#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:gen:super:"doIt" superDescNo:23 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 23 top: 1 "doIt"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnarydoIt
 -- isConstant: Invocation doIt
 -- Invocation doIt
 -- needorigin:"doIt" 
 -- needOrigin:E:"doIt"  E.ATd:"doIt:  |    loop: obj  |       @if inx <= to :t ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "doIt" 
 -- computeAdr:1 :rec:"none"  E:"doIt" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "doIt"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "doIt"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "doIt"
 -- $pattern:getAdr: "doIt:  |    loop: obj  |       @if inx <= to :then  |       ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"do ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "doIt" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "doIt" E: "doIt" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "doIt"
 -- $pattern:loadArgs:E:"doIt":descNo:23:top:1 "doIt:  |    loop: obj  |        ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"doIt" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"doIt" "doIt"
 -- >top:1 descNo:23 
 -- E.ATd: "doIt" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"doIt" 
 -- $pattern:invoke: "doIt:  |    loop: obj  |       @if inx <= to :then  |       ..."
 -- Pattern:invoke:descNo:23  top:1  rec:"doIt" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"doIt:  |    loop: obj  |        ..." 
 -- rec=E:true:rec:"doIt" 
 -- kuk:pattern:rec.ATd:"doIt:  |    loop: obj  |       @if inx <= to :then  |    ..." 
 invoke doIt 23 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"doIt" 
 rpop
 -- OI:invoke:doIt:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"doIt" 
 -- genclass:Qgen:stmt:"@inner for" 
 -- $ObjectGenerator:gen:"@inner:#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"" superDescNo:16 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 16 top: 0 "@inner for"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@inner for
 -- isConstant: Invocation @inner for
 -- Invocation @inner for
 -- needorigin:"@inner for" 
 -- needOrigin:E:"@inner for"  E.ATd:"@inner:  |    %basic 101 |    in inner: r ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@inner for" 
 -- computeAdr:1 :rec:"none"  E:"@inner for" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@inner for"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@inner for"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@inner for"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@inner for" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@inner for" E: "@inner for" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner for"
 -- $pattern:loadArgs:E:"@inner for":descNo:16:top:0 "@inner:  |    %basic 10 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner for" :Adr:off:0 sz:0 isF:F isUN:F sprAd ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner for" "@inner for"
 -- >top:0 descNo:16 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@inner for" 
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- inner:hasArgs:@inner for
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:@inner for:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner for" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"@for::to:do" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:-3 vTopMax:0 rTop:5 rTopMax:5
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:25 :top:1 
 -- GenClass:length:varNo = 1 
 -- GenClass:length:true -> var.genDone

class length 25 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "length"
 -- $var:gen: "out res: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"res := @get 0" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "res := @get 0"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryres
 -- ObjectInvocation_Binary:= @get 0
 -- isConstant: Invocation res := @get 0
 -- Invocation res
 -- not const: resout res: var integer
 -- needorigin:"res := @get 0" 
 -- needOrigin:E:":= @get 0"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "res := @get 0" 
 -- computeAdr:1 :rec:"none"  E:"res" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "res"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "res"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "res"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "out res: var in ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...o ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "out res: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"re ..."
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"res"  E:":= @get 0"  A.E:"res" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"re ..."
 -- computeAdr:isAssign:rec: "res"  E:":= @get 0" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"re ..."
 -- computeAdr:isLast:E: ":= @get 0" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "res" E: ":= @get 0" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= @get 0"
 -- $pattern:loadArgs:E:":= @get 0":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= @get 0" 
 -- ActArg: "@get 0" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= @get 0" 
 -- $ObjectGenerator:gen:"@get:#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "@get 0"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@get 0
 -- isConstant: Invocation @get 0
 -- Invocation @get 0
 -- needorigin:"@get 0" 
 -- needOrigin:E:"@get 0"  E.ATd:"@get:  |    %basic 116 |    in get: var integ ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@get 0" 
 -- computeAdr:1 :rec:"none"  E:"@get 0" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@get 0"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@get 0"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:length:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 length:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@get 0"
 -- $pattern:getAdr: "@get:  |    %basic 116 |    in get: var integer |    out V: ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@g ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@get 0" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@get 0" E: "@get 0" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get 0"
 -- $pattern:loadArgs:E:"@get 0":descNo:0:top:0 "@get:  |    %basic 116 |    in ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get 0" 
 -- ActArg: "0" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@get 0" 
 -- loadArgs:not:*: formalArgOf:"@get 0"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "0"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral0
 -- isConstant: Invocation 0
 -- Invocation 0
 -- needorigin:"0" 
 -- needOrigin:E:"0"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "0" E: "0" isValueAssign: false
 -- $ConstLiteral:loadArgs: "0"
 -- invoke:after:loadArgsOf:"0" 
 -- $ConstLiteral:invoke: "0"
 pushc 0
 -- invoke:after:E.invoke:"0" 
 -- loadArgs:after:Qgen:"@get 0" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"0" :isBasicVal:true
 -- 0ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"@get 0" 
 -- invoke:after:loadArgsOf:"@get 0" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@get 0" "@get 0"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@get 0" 
 -- $pattern:invoke: "@get:  |    %basic 116 |    in get: var integer |    out V: ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get 0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get 0" 
 -- loadArgs:after:Qgen:":= @get 0" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= @get 0" 
 -- invoke:after:loadArgsOf:":= @get 0" :Adr:off:2 sz:0 isF:F isUN:F sprAdj ...
 -- $ObjectInvocation_Binary:invoke: rec:"res" ":= @get 0"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= @get 0" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "res" from: ":= @get 0" 
 -- assign:dstDI :"out res: var integer" isUnitValueObj: false
 -- assign:arg: "@get 0" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:@get 0
 --  arg.super.ATd:"Invocation" "@get:  |    %basic 116 |    in get: var intege ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"re ..."
 -- store::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 2 address:storeg
 -- OI:invoke::= @get 0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= @get 0" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"length" 
 setThisStack 
 pushThis 
 -- $var:invoke: newOff:2 "out res: var integer"
 -- >:E=none
 pushg 2 res
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:1 vTopMax:2 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:26 :top:1 
 -- GenClass:#S#26:varNo = 1 
 -- GenClass:#S#26:true -> var.genDone

class #S#26 26 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@inner case" 
 -- $ObjectGenerator:gen:"@inner:#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"" superDescNo:16 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 16 top: 0 "@inner case"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@inner case
 -- isConstant: Invocation @inner case
 -- Invocation @inner case
 -- needorigin:"@inner case" 
 -- needOrigin:E:"@inner case"  E.ATd:"@inner:  |    %basic 101 |    in inner:  ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@inner case" 
 -- computeAdr:1 :rec:"none"  E:"@inner case" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@inner case"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:5 "@inner case"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:5 "@inner case"
 -- $pattern:getAdr: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@inner case" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@inner case" E: "@inner case" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@inner case"
 -- $pattern:loadArgs:E:"@inner case":descNo:16:top:0 "@inner:  |    %basic 1 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@inner case" :Adr:off:0 sz:0 isF:F isUN:F sprA ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@inner case" "@inner case"
 -- >top:0 descNo:16 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@inner case" 
 -- $pattern:invoke: "@inner:  |    %basic 101 |    in inner: ref Object"
 -- inner:hasArgs:@inner case
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@i ..."
 pushThis 
 -- goOrigin:on:3 
 -- goOrigin:#S#26:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#26:origin
 -- goOrigin:on:2 
 -- goOrigin:Skip:ifThen
 -- goOrigin:on:2 
 -- goOrigin:do#S#28:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#28:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#31:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#31:origin
 innerP  1
 rpopThisObj 
 -- OI:invoke:@inner case:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@inner case" 
 -- genclass:Qgen:stmt:"@leave switch" 
 -- $ObjectGenerator:gen:"@leave:#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"" superDescNo:27 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 27 top: 0 "@leave switch"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@leave switch
 -- isConstant: Invocation @leave switch
 -- Invocation @leave switch
 -- needorigin:"@leave switch" 
 -- needOrigin:E:"@leave switch"  E.ATd:"@leave:  |    %basic 103 |    in leave ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@leave switch" 
 -- computeAdr:1 :rec:"none"  E:"@leave switch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@leave switch"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:5 "@leave switch"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:5 "@leave switch"
 -- $pattern:getAdr: "@leave:  |    %basic 103 |    in leave: var integer"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@l ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@leave switch" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@leave switch" E: "@leave switch" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@leave switch"
 -- $pattern:loadArgs:E:"@leave switch":descNo:27:top:0 "@leave:  |    %basic ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@leave switch" :Adr:off:0 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@leave switch" "@leave switch"
 -- >top:0 descNo:27 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@leave switch" 
 -- $pattern:invoke: "@leave:  |    %basic 103 |    in leave: var integer"
 break 4 2 15
 -- OI:invoke:@leave switch:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@leave switch" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:28 :top:1 
 -- GenClass:do#S#28:varNo = 1 
 -- GenClass:do#S#28:true -> var.genDone

class do#S#28 28 1 31
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@if (V = x.@get inx) :then  |    @inner case |    @leav ..." 
 -- $ObjectGenerator:gen:"@if::then#S#0"IS.isempty! staticOff: 0 descNo: 0  ...
 -- OG:gen:super:"" superDescNo:18 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 18 top: 1 "@if (V = x.@get inx) :then  |    @inn ..."
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@if (V = x.@get inx) :then  |    @inner case |    @ ...
 -- isConstant: Invocation @if (V = x.@get inx) :then  |    @inner case |    @l ...
 -- Invocation @if (V = x.@get inx) :then  |    @inner case |    @leave switch
 -- needorigin:"@if (V = x.@get inx) :then  |    @inner case |    @leave switch ..." 
 -- needOrigin:E:"@if (V = x.@get inx) :then  |    @inner case |    @leave swit ..."   ..."@ ..." 
 -- LoadOrign:no:loadOrigin: "%globals inSub | %basic 100 | in if: var boolean |  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" E ..."@ ..." i ...false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@if (V = x.@get inx) :t ..."
 -- $pattern:loadArgs:E:"@if (V = x.@get inx) :then  |    @inner case |    @lea ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@if (V = x.@get inx) :then  |    @inner case |     ..." 
 -- $ObjectInvocation_KeyWord:invoke: rec:"@if (V = x.@get inx) :then  |    @ ..."
 -- >top:1 descNo:18 
 -- HEST"@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- $pattern:invoke: "@if:  |    %globals inSub |    %basic 100 |    in if: var b ..."
 -- $ObjectGenerator:gen:"=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "(V = x.@get inx)"
 -- Invocation:qgen:superAdj: 0 
 -- BracketedExp(V = x.@get inx)
 -- isConstant: Invocation (V = x.@get inx)
 -- Invocation (V = x.@get inx)
 -- needorigin:"(V = x.@get inx)" 
 -- needOrigin:E:"(V = x.@get inx)"  E.ATd:"= :  |    %basic 50 |    in V: var  ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "(V = x.@get inx)" 
 -- computeAdr:1 :rec:"none"  E:"(V = x.@get inx)" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "(V = x.@get inx)"
 -- $BracketedExp:loadOrigin: "(V = x.@get inx)"
 -- computeAdr: "V = x.@get inx" 
 -- computeAdr:1 :rec:"none"  E:"V" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "V"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "V"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:3 
 -- goOrigin:do#S#28:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#28:origin
 -- goOrigin:on:2 
 -- goOrigin:@for::to:do#S#31:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#31:origin
 -- goOrigin:on:1 
 -- goOrigin:case:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 case:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "V"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in V: var integ ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "in V: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"V" ...
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"V"  E:"= x.@get inx"  A.E:"V" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"V" ...
 -- E:notAssign:= x.@get inx
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "= x.@get inx"
 -- $pattern:getAdr: "= :  |    %basic 50 |    in V: var integer |    out B: var  ..."
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"V" ...
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "V"
 -- $var:loadArgs: "in V: var integer"
 -- DataItem:loadArgs:empty: "in V: var integer" 
 -- $ObjectInvocation_Unary:invoke: rec:"V" "V"
 -- E.ATd: "= " unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"V" 
 -- $var:invoke: newOff:2 "in V: var integer"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:V:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "= x.@get inx" 
 -- BE:loadOrigin:E: = x.@get inx
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "= x.@get inx"
 -- $pattern:getAdr: "= :  |    %basic 50 |    in V: var integer |    out B: var  ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"=  ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "= x.@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "V" E: "= x.@get inx" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "= x.@get inx"
 -- $pattern:loadArgs:E:"= x.@get inx":descNo:0:top:0 "= :  |    %basic 50 |    ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"= x.@get inx" 
 -- ActArg: "x.@get inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "= x.@get inx" 
 -- loadArgs:not:*: formalArgOf:"= x.@get inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"@get:#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "x.@get inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryx
 -- ObjectInvocation_KeyWord@get inx
 -- isConstant: Invocation x.@get inx
 -- Invocation x
 -- not const: xin x: ref Indexed(1,#Integer)
 -- needorigin:"x.@get inx" 
 -- needOrigin:E:"@get inx"  E.ATd:"@get:  |    %basic 116 |    in get: var int ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "x.@get inx" 
 -- computeAdr:1 :rec:"none"  E:"x" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "x"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "x"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#28:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#28:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#31:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#31:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "x"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in x: ref Inde ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"x"  E:"@get inx" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:@get inx
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@get inx"
 -- $pattern:getAdr: "@get:  |    %basic 116 |    in get: var integer |    out V: ..."
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@g ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "x"
 -- $ref:loadArgs: "in x: ref Indexed(1,#Integer)"
 -- DataItem:loadArgs:empty: "in x: ref Indexed(1,#Integer)" 
 -- $ObjectInvocation_Unary:invoke: rec:"x" "x"
 -- E.ATd: "" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"x" 
 -- $ref:invoke: newOff:2 "in x: ref Indexed(1,#Integer)"
 -- >Object:unique:false
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F: ...
 rpushg 2 
 -- OI:invoke:x:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "x" E: "@get inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get inx"
 -- $pattern:loadArgs:E:"@get inx":descNo:0:top:0 "@get:  |    %basic 116 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get inx" 
 -- ActArg: "inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@get inx" 
 -- loadArgs:not:*: formalArgOf:"@get inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"inx#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- isConstant: Invocation inx
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:do#S#28:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#28:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- invoke:after:loadArgsOf:"inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@get inx" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectGenerator
 -- end:loadArgs:NonVirt:"@get inx" 
 -- invoke:after:loadArgsOf:"@get inx" :Adr:off:2 sz:0 isF:F isUN:F sprAdj: ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"x" "@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@get inx" 
 -- $pattern:invoke: "@get:  |    %basic 116 |    in get: var integer |    out V: ..."
 -- #Integer
 -- primitive
 xpushg inx 1 0 1
 -- OI:invoke:@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get inx" 
 -- loadArgs:after:Qgen:"= x.@get inx" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"x.@get inx" :isBasicVal:true
 -- x.@get inxObjectGenerator
 -- end:loadArgs:NonVirt:"= x.@get inx" 
 -- invoke:after:loadArgsOf:"= x.@get inx" :Adr:off:0 sz:0 isF:F isUN:F spr ...
 -- $ObjectInvocation_Binary:invoke: rec:"V" "= x.@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "= " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"= x.@get inx" 
 -- $pattern:invoke: "= :  |    %basic 50 |    in V: var integer |    out B: var  ..."
 -- bodyC:
 eq
 -- OI:invoke:= x.@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"= x.@get inx" 
 jmpFalse L3
 -- $ObjectGenerator:gen:"#S#26"singular! staticOff: 0 descNo: 26 top:1 | sup ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 26  "#S#26" 
 invoke #S#26 26 0 1
 rpop
 L3:
 -- OI:invoke:@if (V = x.@get inx) :then  |    @inner case |    @leave switch: ...-none-  ...0.000000
 -- invoke:after:E.invoke:"@if (V = x.@get inx) :then  |    @inner case |    @l ..." 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:1 rTop:3 rTopMax:3
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:31 :top:1 
 -- GenClass:@for::to:do#S#31:varNo = 1 
 -- GenClass:@for::to:do#S#31:true -> var.genDone

class @for::to:do#S#31 31 4 30
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super @for::to:do
 -- vdt:b
 --  1:61 2:0 3:0 4:0
 -- vdt:c:innerInx: 2  descNo: 31  superDesc.descNo:31 
 -- vdtAdd: inx=2 descInx=31 vDescInx=31
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@for 1 :to x.length  | :d ..."
 -- $pattern:loadArgs:E:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx)  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :th ..." 
 -- ActArg: "1" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to x.length  | :do  |    @if (V  ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to x.length  | :do  |    @if (V = x.@g ..."   ...false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: "1"
 -- Invocation:qgen:superAdj: 4 
 -- ConstLiteral1
 -- isConstant: Invocation 1
 -- Invocation 1
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:4 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx)  ..." 
 -- formalArg:isPtn:"in for: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) ..." 
 -- loadArgs:NonVirt:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :th ..." 
 -- ActArg: "x.length" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to x.length  | :do  |    @if (V  ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to x.length  | :do  |    @if (V = x.@g ..."   ...false
 -- $ObjectGenerator:gen:"length#S#0"IS.isempty! staticOff: 0 descNo: 0 top ...
 -- OG:gen:super:"length" superDescNo:25 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: descNo: 25 top: 1 "x.length"
 -- Invocation:qgen:superAdj: 4 
 -- ObjectInvocation_Unaryx
 -- ObjectInvocation_Unarylength
 -- isConstant: Invocation x.length
 -- Invocation x
 -- not const: xin x: ref Indexed(1,#Integer)
 -- needorigin:"x.length" 
 -- needOrigin:E:"length"  E.ATd:"length:  |    out res: var integer |    res : ..." 
 -- IV:FISK:superAdj:4 
 -- computeAdr: "x.length" 
 -- computeAdr:1 :rec:"none"  E:"x" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "x"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "x"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:0 "x"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in x: ref Inde ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"x"  E:"length" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:length
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "length"
 -- $pattern:getAdr: "length:  |    out res: var integer |    res := @get 0"
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"le ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "x"
 -- $ref:loadArgs: "in x: ref Indexed(1,#Integer)"
 -- DataItem:loadArgs:empty: "in x: ref Indexed(1,#Integer)" 
 -- $ObjectInvocation_Unary:invoke: rec:"x" "x"
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"x" 
 -- $ref:invoke: newOff:2 "in x: ref Indexed(1,#Integer)"
 -- >Object:unique:false
 -- loadAdr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal ...
 rpushg 2 
 -- OI:invoke:x:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "length" 
 -- IV:after:computeAdr:superAdj:4 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "x" E: "length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "length"
 -- $pattern:loadArgs:E:"length":descNo:25:top:1 "length:  |    out res: var  ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"length" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"x" "length"
 -- >top:1 descNo:25 
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"length" 
 -- $pattern:invoke: "length:  |    out res: var integer |    res := @get 0"
 -- Pattern:invoke:descNo:25  top:1  rec:"x" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out res: var int ..." 
 -- rec=E:false:rec:"x" 
 -- kuk:pattern:rec.ATd:"in x: ref Indexed(1,#Integer)" 
 invoke length 25 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:false"x" 
 -- OI:invoke:length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"length" 
 -- loadArgs:after:Qgen:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx)  ..." 
 -- formalArg:isPtn:"in to: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"x.length" :isBasicVal:true
 -- x.lengthObjectGenerator
 -- end:loadArgs:NonVirt:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) ..." 
 -- "in do:< Object" 
 -- "@if (V = x.@get inx) :then  |    @inner case |    @leave switch" 
 -- vdt:Q: "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :then  |        ..." 
 -- formalArg: "in do:< Object" actualArg: "@if (V = x.@get inx) :then  |     ..." 
 -- 1  (actualArg.desc).newDescno: 28  (OGx.desc).newDescNo: 31  stubDescNo ...0 
 toSuper 24
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:1 vTopMax:1 rTop:0 rTopMax:0
 -- Handle VB: "" E: "@for 1 :to x.length  | :do  |    @if (V = x.@get inx) :th ..." 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:30 :top:1 
 -- GenClass:case:varNo = 1 
 -- GenClass:case:true -> var.genDone

class case 30 1 15
 -- Store itemArgs
 pushThis 
 rstoreg 2 x
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "case"
 -- $ref:gen: "in x: ref Indexed(1,#Integer)"
 -- DI:isConst:false:isBasicValue:false:primNo:114 
 -- OGqual:Indexed:OGqual.isBasicValue:false:OGqual.isValueObj:false
 innerA  1
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@for 1 :to x.length  | :do  |    @if (V = x.@get inx) : ..." 
 -- $ObjectGenerator:gen:"@for::to:do#S#31"IS.isempty! staticOff: 0 descNo: ...
 -- OG:gen:super:"" superDescNo:24 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 31  "@for::to:do#S#31" 
 invoke @for::to:do#S#31 31 0 1
 rpop
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"case" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:-1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:32 :top:1 
 -- GenClass:length:varNo = 1 
 -- GenClass:length:true -> var.genDone

class length 32 1 12
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "length"
 -- $var:gen: "out V: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"V := @get 0" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "V := @get 0"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryV
 -- ObjectInvocation_Binary:= @get 0
 -- isConstant: Invocation V := @get 0
 -- Invocation V
 -- not const: Vout V: var integer
 -- needorigin:"V := @get 0" 
 -- needOrigin:E:":= @get 0"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "V := @get 0" 
 -- computeAdr:1 :rec:"none"  E:"V" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "V"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "V"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "V"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "out V: var inte ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...o ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "out V: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"V" ...
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"V"  E:":= @get 0"  A.E:"V" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"V" ...
 -- computeAdr:isAssign:rec: "V"  E:":= @get 0" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"V" ...
 -- computeAdr:isLast:E: ":= @get 0" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "V" E: ":= @get 0" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= @get 0"
 -- $pattern:loadArgs:E:":= @get 0":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= @get 0" 
 -- ActArg: "@get 0" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= @get 0" 
 -- $ObjectGenerator:gen:"@get:#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "@get 0"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@get 0
 -- isConstant: Invocation @get 0
 -- Invocation @get 0
 -- needorigin:"@get 0" 
 -- needOrigin:E:"@get 0"  E.ATd:"@get:  |    %basic 117 |    in get: var integ ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@get 0" 
 -- computeAdr:1 :rec:"none"  E:"@get 0" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@get 0"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:1 "@get 0"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:length:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 length:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:1 "@get 0"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@g ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@get 0" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@get 0" E: "@get 0" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get 0"
 -- $pattern:loadArgs:E:"@get 0":descNo:0:top:0 "@get:  |    %basic 117 |    in ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get 0" 
 -- ActArg: "0" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@get 0" 
 -- loadArgs:not:*: formalArgOf:"@get 0"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "0"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral0
 -- isConstant: Invocation 0
 -- Invocation 0
 -- needorigin:"0" 
 -- needOrigin:E:"0"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "0" E: "0" isValueAssign: false
 -- $ConstLiteral:loadArgs: "0"
 -- invoke:after:loadArgsOf:"0" 
 -- $ConstLiteral:invoke: "0"
 pushc 0
 -- invoke:after:E.invoke:"0" 
 -- loadArgs:after:Qgen:"@get 0" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"0" :isBasicVal:true
 -- 0ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"@get 0" 
 -- invoke:after:loadArgsOf:"@get 0" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@get 0" "@get 0"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@get 0" 
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get 0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get 0" 
 -- loadArgs:after:Qgen:":= @get 0" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= @get 0" 
 -- invoke:after:loadArgsOf:":= @get 0" :Adr:off:2 sz:0 isF:F isUN:F sprAdj ...
 -- $ObjectInvocation_Binary:invoke: rec:"V" ":= @get 0"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= @get 0" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "V" from: ":= @get 0" 
 -- assign:dstDI :"out V: var integer" isUnitValueObj: false
 -- assign:arg: "@get 0" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:@get 0
 --  arg.super.ATd:"Invocation" "@get:  |    %basic 117 |    in get: var intege ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"V" ...
 -- store::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 2 address:storeg
 -- OI:invoke::= @get 0:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= @get 0" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"length" 
 setThisStack 
 pushThis 
 -- $var:invoke: newOff:2 "out V: var integer"
 -- >:E=none
 pushg 2 V
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:1 vTopMax:2 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:33 :top:1 
 -- GenClass:put:varNo = 1 
 -- GenClass:put:true -> var.genDone

class put 33 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 ch
 allocEventQ
 mvStack 
 -- $Signature:gen: "put"
 -- $val:gen: "in ch: val char"
 -- DI:isConst:true:isBasicValue:true:primNo:3 
 -- OGqual:char:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 2" 
 -- $Property:gen: "%basic 2"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"put" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:34 :top:1 
 -- GenClass:do#S#34:varNo = 1 
 -- GenClass:do#S#34:true -> var.genDone

class do#S#34 34 1 37
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"put(@get inx)" 
 -- $ObjectGenerator:gen:"put#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:gen:super:"put" superDescNo:33 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 33 top: 1 "put(@get inx)"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Functionput(@get inx)
 -- isConstant: Invocation put(@get inx)
 -- Invocation put(@get inx)
 -- needorigin:"put(@get inx)" 
 -- needOrigin:E:"put(@get inx)"  E.ATd:"put:  |    %globals |    %basic 2 |    i ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 2 | in ch: val char" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "put(@get inx)" E: "put(@get inx)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "put(@get inx)"
 -- $pattern:loadArgs:E:"put(@get inx)":descNo:33:top:1 "put:  |    %globals |  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"put(@get inx)" 
 -- ActArg: "@get inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "put(@get inx)" 
 -- loadArgs:not:*: formalArgOf:"put(@get inx)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"@get:#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "@get inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@get inx
 -- isConstant: Invocation @get inx
 -- Invocation @get inx
 -- needorigin:"@get inx" 
 -- needOrigin:E:"@get inx"  E.ATd:"@get:  |    %basic 117 |    in get: var int ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@get inx" 
 -- computeAdr:1 :rec:"none"  E:"@get inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@get inx"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:3 "@get inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:3 
 -- goOrigin:do#S#34:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#34:origin
 -- goOrigin:on:2 
 -- goOrigin:@for::to:do#S#37:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#37:origin
 -- goOrigin:on:1 
 -- goOrigin:print:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 print:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:3 "@get inx"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@g ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@get inx" E: "@get inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get inx"
 -- $pattern:loadArgs:E:"@get inx":descNo:0:top:0 "@get:  |    %basic 117 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get inx" 
 -- ActArg: "inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@get inx" 
 -- loadArgs:not:*: formalArgOf:"@get inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"inx#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- isConstant: Invocation inx
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:do#S#34:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 do#S#34:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- invoke:after:loadArgsOf:"inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@get inx" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectGenerator
 -- end:loadArgs:NonVirt:"@get inx" 
 -- invoke:after:loadArgsOf:"@get inx" :Adr:off:0 sz:0 isF:F isUN:F sprAdj: ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@get inx" "@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@get inx" 
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get inx" 
 -- loadArgs:after:Qgen:"put(@get inx)" 
 -- formalArg:isPtn:"in ch: val char" :isBasicVal:true:valueObj:true
 -- :actArg:"@get inx" :isBasicVal:true
 -- @get inxObjectGenerator
 -- end:loadArgs:NonVirt:"put(@get inx)" 
 -- invoke:after:loadArgsOf:"put(@get inx)" 
 -- $ObjectInvocation_Function:invoke: rec:"put(@get inx)" "put(@get inx)"
 -- >top:1 descNo:33 
 -- HEST"put(@get inx)" 
 -- $pattern:invoke: "put:  |    %globals |    %basic 2 |    in ch: val char"
 %put 2
 -- OI:invoke:put(@get inx):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"put(@get inx)" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:1 vTopMax:1 rTop:2 rTopMax:2
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:37 :top:1 
 -- GenClass:@for::to:do#S#37:varNo = 1 
 -- GenClass:@for::to:do#S#37:true -> var.genDone

class @for::to:do#S#37 37 4 36
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super @for::to:do
 -- vdt:b
 --  1:61 2:0 3:0 4:0
 -- vdt:c:innerInx: 2  descNo: 37  superDesc.descNo:37 
 -- vdtAdd: inx=2 descInx=37 vDescInx=37
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@for 1 :to length  | :do  ..."
 -- $pattern:loadArgs:E:"@for 1 :to length  | :do  |    put(@get inx)":descNo:2 ...
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- ActArg: "1" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to length  | :do  |    put(@get  ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to length  | :do  |    put(@get inx)"   ...false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: "1"
 -- Invocation:qgen:superAdj: 4 
 -- ConstLiteral1
 -- isConstant: Invocation 1
 -- Invocation 1
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:4 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- formalArg:isPtn:"in for: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- ActArg: "length" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to length  | :do  |    put(@get  ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to length  | :do  |    put(@get inx)"   ...false
 -- $ObjectGenerator:gen:"length#S#0"IS.isempty! staticOff: 0 descNo: 0 top ...
 -- OG:gen:super:"length" superDescNo:32 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: descNo: 32 top: 1 "length"
 -- Invocation:qgen:superAdj: 4 
 -- ObjectInvocation_Unarylength
 -- isConstant: Invocation length
 -- Invocation length
 -- needorigin:"length" 
 -- needOrigin:E:"length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- IV:FISK:superAdj:4 
 -- computeAdr: "length" 
 -- computeAdr:1 :rec:"none"  E:"length" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "length"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "length"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- goOrigin:on:1 
 -- goOrigin:print:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 print:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:1 "length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E:"le ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue ...
 -- computeAdr:isLast:E: "length" 
 -- IV:after:computeAdr:superAdj:4 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 is ...
 -- rec: "length" E: "length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "length"
 -- $pattern:loadArgs:E:"length":descNo:32:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"length" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4  ...
 -- $ObjectInvocation_Unary:invoke: rec:"length" "length"
 -- >top:1 descNo:32 
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"length" 
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:32  top:1  rec:"length" 
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:true:rec:"length" 
 -- kuk:pattern:rec.ATd:"length:  |    out V: var integer |    V := @get 0" 
 invoke length 32 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:true"length" 
 -- OI:invoke:length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"length" 
 -- loadArgs:after:Qgen:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- formalArg:isPtn:"in to: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"length" :isBasicVal:true
 -- lengthObjectGenerator
 -- end:loadArgs:NonVirt:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- "in do:< Object" 
 -- "put(@get inx)" 
 -- vdt:Q: "@for 1 :to length  | :do  |    put(@get inx)" 
 -- formalArg: "in do:< Object" actualArg: "put(@get inx)" 
 -- 1  (actualArg.desc).newDescno: 34  (OGx.desc).newDescNo: 37  stubDescNo ...0 
 toSuper 24
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:1 vTopMax:1 rTop:0 rTopMax:0
 -- Handle VB: "" E: "@for 1 :to length  | :do  |    put(@get inx)" 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:36 :top:1 
 -- GenClass:print:varNo = 1 
 -- GenClass:print:true -> var.genDone

class print 36 1 12
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "print"
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@for 1 :to length  | :do  |    put(@get inx)" 
 -- $ObjectGenerator:gen:"@for::to:do#S#37"IS.isempty! staticOff: 0 descNo: ...
 -- OG:gen:super:"" superDescNo:24 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 37  "@for::to:do#S#37" 
 invoke @for::to:do#S#37 37 0 1
 rpop
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"print" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:55 :top:1 
 -- GenClass:case#S#55:varNo = 1 
 -- GenClass:case#S#55:true -> var.genDone

class case#S#55 55 1 54
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 -- super case
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 55  superDesc.descNo:55 
 -- vdtAdd: inx=1 descInx=55 vDescInx=55
 -- computeAdr: "case('a')" 
 -- computeAdr:1 :rec:"none"  E:"case('a')" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:1 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Function:pushThis: "case('a')"
 pushThis 
 -- $ObjectInvocation_Function:loadOrigin::on:0 "case('a')"
 -- AdjustOrigin:originOff: 1
 rpushg 1 origin
 -- addOG
 -- $ObjectInvocation_Function:getAdr::superAdj:1:on:0 "case('a')"
 -- $pattern:getAdr: "case:  |    in x: ref Indexed(1,#Integer) |    @for 1 :to ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:1 isUQ:F isValue:F orgIsVal:F:E:"ca ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:1 isUQ:F isValue ...
 -- computeAdr:isLast:E: "case('a')" 
 -- genClass:after:ComputeAdr:"case('a')" :Adr:off:0 sz:0 isF:F isUN:F sprA ...
 -- Super:sig none
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "case('a')"
 -- $pattern:loadArgs:E:"case('a')":descNo:30:top:1 "case:  |    in x: ref In ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"case('a')" 
 -- ActArg: "'a'" isValue: true
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:false
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 1  "case('a')" 
 -- loadArgs:not:*: formalArgOf:"case('a')"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"char#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 1 
 -- $Invocation:gen: "'a'"
 -- Invocation:qgen:superAdj: 1 
 -- Char:'a'
 -- isConstant: Invocation 'a'
 -- Invocation 'a'
 -- needorigin:"'a'" 
 -- needOrigin:E:"'a'"  E.ATd:"char: value |    %id "char" |    %globals |    %ba ..." 
 -- LoadOrign:no:loadOrigin: "value |    %id "char" |    %globals |    %basic 3,  ..." 
 -- IV:after:computeAdr:superAdj:1 
 -- rec: "'a'" E: "'a'" isValueAssign: false
 -- $Char::loadArgs: "'a'"
 -- invoke:after:loadArgsOf:"'a'" 
 -- $Char::invoke: "'a'"
 pushc 97
 -- invoke:after:E.invoke:"'a'" 
 -- loadArgs:after:Qgen:"case('a')" 
 -- formalArg:isPtn:"in x: ref Indexed(1,#Integer)" :isBasicVal:false:value ...false
 -- :actArg:"'a'" :isBasicVal:true
 -- 'a'ObjectGenerator
 -- formalarg is indexed:in x: ref Indexed(1,#Integer)
 -- 'a' ObjectGenerator
 pushc 1
 mkVindexed 
 -- end:loadArgs:NonVirt:"case('a')" 
 toSuper 30
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""Got  a: ".print" 
 -- $ObjectGenerator:gen:"print#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"print" superDescNo:36 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 36 top: 1 ""Got  a: ".print"
 -- Invocation:qgen:superAdj: 0 
 -- String:"Got  a: "
 -- ObjectInvocation_Unaryprint
 -- isConstant: Invocation "Got  a: ".print
 -- Invocation "Got  a: "
 -- needorigin:""Got  a: ".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: ""Got  a: ".print" 
 -- computeAdr:1 :rec:"none"  E:""Got  a: "" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $String::pushThis: ""Got  a: ""
 -- $String::loadOrigin: ""Got  a: ""
 -- StringObj:loadOrigin:"Got  a: "
 -- $String::getAdr: ""Got  a: ""
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:""Got  a: ""  E:"print"  A.E:""Got  a: "" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:""G ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:""G ...
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $String::loadArgs: ""Got  a: ""
 -- $String::invoke: ""Got  a: ""
 -- Pattern:markForCodeGen:"+ :  |    in S: ref String |    out V: ref String |   ..." 
 -- OG:markForCodeGen:"in S: ref String | out V: ref String | L: var integer | L  ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"in S: ref String | out V: ref String | L: var integer | L := Lengt ..." 
 -- items:markForCodeGen:"in S: ref String | out V: ref String | L: var integer ..." 
 -- DataItem:markForCodeGen:"S" :descNo:0 :OG.primNo:5 
 -- OG:markForCodeGen:"String" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "String" 
 -- "String" true
 -- 
 -- OG:markSuper:"String" 
 -- Invocation:markForCodeGen:"String" 
 -- ObjectInvocation:markForCodeGen:"String"  ATd:"String:  |    %id "String  ..."" 
 -- Pattern:markForCodeGen:"String:  |    %id "String pattern" |    %OSDvisibil ..." 
 -- not ObjDesc: "String"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:5 
 -- OG:markForCodeGen:"String" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "String" 
 -- "String" true
 -- 
 -- OG:markSuper:"String" 
 -- Invocation:markForCodeGen:"String" 
 -- ObjectInvocation:markForCodeGen:"String"  ATd:"String:  |    %id "String  ..."" 
 -- Pattern:markForCodeGen:"String:  |    %id "String pattern" |    %OSDvisibil ..." 
 -- not ObjDesc: "String"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"L" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- markItem:"L := Length" ObjectGenerator
 -- OG:markForCodeGen:"L := Length" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "L := Length" 
 -- "L" true
 -- ":= Length" true
 -- 
 -- OG:markSuper:"L := Length" 
 -- Invocation:markForCodeGen:"L := Length" 
 -- ObjectInvocation:markForCodeGen:"L"  ATd:"L: var integer" 
 -- DataItem:markForCodeGen:"L" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= Length"  ATd:":= :  |    %basic 8 |     ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "Length" 
 -- OG:markForCodeGen:"Length" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "Length" 
 -- "Length" false
 -- 
 -- OG:markSuper:"Length" 
 -- Invocation:markForCodeGen:"Length" 
 -- ObjectInvocation:markForCodeGen:"Length"  ATd:"length:  |    out V: var i ..." 
 -- Pattern:markForCodeGen:"length:  |    out V: var integer |    V := @get 0" 
 -- not ObjDesc: "Length"  IS.isEmpty: true
 -- not ObjDesc: "L := Length"  IS.isEmpty: true
 -- markItem:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:leng ..." O ...
 -- OG:markForCodeGen:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := ..." 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:length] + S.T ..." 
 -- "doplus" false
 -- 
 -- OG:markSuper:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1: ..." 
 -- Invocation:markForCodeGen:"doplus | -- V: obj Indexed(Length + S.length) |  ..." 
 -- ObjectInvocation:markForCodeGen:"doplus"  ATd:"doplus:  |    e: var integ ..." 
 -- Pattern:markForCodeGen:"doplus:  |    e: var integer |    i: var integer |    ..." 
 -- OG:markForCodeGen:"e: var integer | i: var integer | T: obj Indexed(L + S.l ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"e: var integer | i: var integer | T: obj Indexed(L + S.length,In ..." 
 -- items:markForCodeGen:"e: var integer | i: var integer | T: obj Indexed(L +  ..." 
 -- DataItem:markForCodeGen:"e" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"i" :descNo:0 :OG.primNo:1 
 -- OG:markForCodeGen:"integer" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "integer" 
 -- "integer" true
 -- 
 -- OG:markSuper:"integer" 
 -- Invocation:markForCodeGen:"integer" 
 -- ObjectInvocation:markForCodeGen:"integer"  ATd:"integer: value |    %ID i ..." 
 -- Pattern:markForCodeGen:"integer: value |    %ID integer |    %basic 1, 32 |   ..." 
 -- not ObjDesc: "integer"  IS.isEmpty: true
 -- DataItem:markForCodeGen:"T" :descNo:0 :OG.primNo:114 
 -- markItem:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" O ...
 -- OG:markForCodeGen:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at  ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" false
 -- 
 -- OG:markSuper:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- Invocation:markForCodeGen:"@for 1 :to L  | :do  |    e := @get inx |    T.@pu ..." 
 -- ObjectInvocation:markForCodeGen:"@for 1 :to L  | :do  |    e := @get inx |    ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@for:  |    %globals inSub |    in for: var integer ..." 
 -- arg: "1" 
 -- OG:markForCodeGen:"1" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "1" 
 -- "1" true
 -- 
 -- OG:markSuper:"1" 
 -- Invocation:markForCodeGen:"1" 
 -- not ObjDesc: "1"  IS.isEmpty: true
 -- arg: "L" 
 -- OG:markForCodeGen:"L" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "L" 
 -- "L" true
 -- 
 -- arg: "e := @get inx | T.@put e :at inx" 
 -- OG:markForCodeGen:"e := @get inx | T.@put e :at inx" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"e := @get inx | T.@put e :at inx" 
 -- items:markForCodeGen:"e := @get inx | T.@put e :at inx" 
 -- markItem:"e := @get inx" ObjectGenerator
 -- OG:markForCodeGen:"e := @get inx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "e := @get inx" 
 -- "e" true
 -- ":= @get inx" true
 -- 
 -- OG:markSuper:"e := @get inx" 
 -- Invocation:markForCodeGen:"e := @get inx" 
 -- ObjectInvocation:markForCodeGen:"e"  ATd:"e: var integer" 
 -- DataItem:markForCodeGen:"e" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= @get inx"  ATd:":= :  |    %basic 8 |   ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "@get inx" 
 -- not ObjDesc: "e := @get inx"  IS.isEmpty: true
 -- markItem:"T.@put e :at inx" ObjectGenerator
 -- ComputeVariant:A:"do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"e := @get inx | T.@put e :at inx" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "e := @get inx | T.@put e :at inx" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"do#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:62 IS.newDescNo:62 objSize:0 varNo:1 "e := @g ..." 
 -- Items:Qalloc:objSize:0  newDescNo:62 "e := @get inx | T.@put e :at inx" 
 -- Items:Qalloc:super:"" :super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:2 
 -- OG:Qalloc:A:"e := @get inx" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"e := @get inx" 
 -- ObjectInvocation:Qalloc:"e" 
 -- name: "e" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= @get inx" 
 -- name: ":=" 
 -- Arguments "@get inx" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "e := @get inx" 
 -- super: "e := @get inx" 
 -- E: ":= @get inx" 
 -- OG:Qalloc:A:"T.@put e :at inx" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"T.@put e :at inx" 
 -- ObjectInvocation:Qalloc:"T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:"@put e :at inx" 
 -- name: "@put::at" 
 -- Arguments "@put e :at inx" 
 -- OG:super: "@put:  |    %basic 115 |    in put: ref elm |    in at: var intege ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "T.@put e :at inx" 
 -- super: "T.@put e :at inx" 
 -- E: "@put e :at inx" 
 -- Items:Qalloc:END:objSize:2  newDescNo:62 "e := @get inx | T.@put e :at in ..." 
 -- IS.newDescNo:62 IS.objSize:2 "e := @get inx | T.@put e :at inx" 
 -- computeVariant:newDescNo:62  size: 2  IS:"e := @get inx | T.@put e :at in ..." 
 -- ComputeVariant:B: "do#S#62" 
 -- ObjTmpStack:add::genDone:false "e := @get inx | T.@put e :at inx" 
 -- OG:markIS:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- items:markForCodeGen:"" 
 -- ComputeVariant:A:"@for::to:do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at  ..." 
 -- ObjectInvocation:Qalloc:"@for 1 :to L  | :do  |    e := @get inx |    T.@put  ..." 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to L :do  |    e := @get inx |    T.@put e :at inx" 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- super: "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- E: "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- OG:Qalloc:B:"@for::to:do#S#0" newDescNo:0 objSize:3 
 -- OG:isObjectDesc:NewDescNo:63 IS.newDescNo:63 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:0  newDescNo:63 "" 
 -- Items:Qalloc:super:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at ..." : ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:63 "" 
 -- IS.newDescNo:63 IS.objSize:3 "" 
 -- computeVariant:newDescNo:63  size: 3  IS:"" 
 -- ComputeVariant:B: "@for::to:do#S#63" 
 -- ObjTmpStack:add::genDone:false "@for 1 :to L  | :do  |    e := @get inx |     ..." 
 -- markItem:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |  ..." O ...
 -- OG:markForCodeGen:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := ..." 
 -- isObjectDesc:true isObjectDescX:true hasItems:false
 --  super.hasVirtualArgs:true
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    T.@put ..." 
 -- "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    T.@put ..." false
 -- 
 -- OG:markSuper:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L +  ..." 
 -- Invocation:markForCodeGen:"@for 1 :to S.length  | :do  |    e := S.@get inx ..." 
 -- ObjectInvocation:markForCodeGen:"@for 1 :to S.length  | :do  |    e := S.@g ..."   ..."@ ..." 
 -- Pattern:markForCodeGen:"@for:  |    %globals inSub |    in for: var integer ..." 
 -- arg: "1" 
 -- OG:markForCodeGen:"1" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "1" 
 -- "1" true
 -- 
 -- OG:markSuper:"1" 
 -- Invocation:markForCodeGen:"1" 
 -- not ObjDesc: "1"  IS.isEmpty: true
 -- arg: "S.length" 
 -- OG:markForCodeGen:"S.length" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "S.length" 
 -- "S" true
 -- "length" false
 -- 
 -- OG:markSuper:"S.length" 
 -- Invocation:markForCodeGen:"S.length" 
 -- ObjectInvocation:markForCodeGen:"S"  ATd:"in S: ref String" 
 -- DataItem:markForCodeGen:"S" :descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen:"length"  ATd:"length:  |    out V: var i ..." 
 -- Pattern:markForCodeGen:"length:  |    out V: var integer |    V := @get 0" 
 -- not ObjDesc: "S.length"  IS.isEmpty: true
 -- arg: "e := S.@get inx | i := L + inx | T.@put e :at i" 
 -- OG:markForCodeGen:"e := S.@get inx | i := L + inx | T.@put e :at i" 
 -- isObjectDesc:true isObjectDescX:true hasItems:true
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:false
 --  (super.last).isPrimitive:false
 -- "" 
 -- "" false
 -- 
 -- OG:markIS:"e := S.@get inx | i := L + inx | T.@put e :at i" 
 -- items:markForCodeGen:"e := S.@get inx | i := L + inx | T.@put e :at i" 
 -- markItem:"e := S.@get inx" ObjectGenerator
 -- OG:markForCodeGen:"e := S.@get inx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "e := S.@get inx" 
 -- "e" true
 -- ":= S.@get inx" true
 -- 
 -- OG:markSuper:"e := S.@get inx" 
 -- Invocation:markForCodeGen:"e := S.@get inx" 
 -- ObjectInvocation:markForCodeGen:"e"  ATd:"e: var integer" 
 -- DataItem:markForCodeGen:"e" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= S.@get inx"  ATd:":= :  |    %basic 8 ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "S.@get inx" 
 -- not ObjDesc: "e := S.@get inx"  IS.isEmpty: true
 -- markItem:"i := L + inx" ObjectGenerator
 -- OG:markForCodeGen:"i := L + inx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "i := L + inx" 
 -- "i" true
 -- ":= L + inx" true
 -- 
 -- OG:markSuper:"i := L + inx" 
 -- Invocation:markForCodeGen:"i := L + inx" 
 -- ObjectInvocation:markForCodeGen:"i"  ATd:"i: var integer" 
 -- DataItem:markForCodeGen:"i" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:":= L + inx"  ATd:":= :  |    %basic 8 |    ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "L + inx" 
 -- OG:markForCodeGen:"L + inx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "L + inx" 
 -- "L" true
 -- "+ inx" true
 -- 
 -- OG:markSuper:"L + inx" 
 -- Invocation:markForCodeGen:"L + inx" 
 -- ObjectInvocation:markForCodeGen:"L"  ATd:"L: var integer" 
 -- DataItem:markForCodeGen:"L" :descNo:0 :OG.primNo:1 
 -- ObjectInvocation:markForCodeGen:"+ inx"  ATd:"+ :  |    %basic 61 |    in V ..." 
 -- Pattern:markForCodeGen:"+ :  |    %basic 61 |    in V: var integer |    out R ..." 
 -- arg: "inx" 
 -- OG:markForCodeGen:"inx" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "inx" 
 -- "inx" true
 -- 
 -- not ObjDesc: "L + inx"  IS.isEmpty: true
 -- not ObjDesc: "i := L + inx"  IS.isEmpty: true
 -- markItem:"T.@put e :at i" ObjectGenerator
 -- ComputeVariant:A:"do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"e := S.@get inx | i := L + inx | T.@put e :at i" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "e := S.@get inx | i := L + inx | T.@put e :at i" 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"do#S#0" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:64 IS.newDescNo:64 objSize:0 varNo:1 "e := S. ..." 
 -- Items:Qalloc:objSize:0  newDescNo:64 "e := S.@get inx | i := L + inx | T.@p ..." 
 -- Items:Qalloc:super:"" :super:size:2 :noGlobalsInSuper:false
 -- Items:Qalloc:super:B:objSize:2 originOff:2 
 -- OG:Qalloc:A:"e := S.@get inx" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"e := S.@get inx" 
 -- ObjectInvocation:Qalloc:"e" 
 -- name: "e" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= S.@get inx" 
 -- name: ":=" 
 -- Arguments "S.@get inx" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "e := S.@get inx" 
 -- super: "e := S.@get inx" 
 -- E: ":= S.@get inx" 
 -- OG:Qalloc:A:"i := L + inx" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"i := L + inx" 
 -- ObjectInvocation:Qalloc:"i" 
 -- name: "i" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= L + inx" 
 -- name: ":=" 
 -- Arguments "L + inx" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "i := L + inx" 
 -- super: "i := L + inx" 
 -- E: ":= L + inx" 
 -- OG:Qalloc:A:"T.@put e :at i" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"T.@put e :at i" 
 -- ObjectInvocation:Qalloc:"T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:"@put e :at i" 
 -- name: "@put::at" 
 -- Arguments "@put e :at i" 
 -- OG:super: "@put:  |    %basic 115 |    in put: ref elm |    in at: var intege ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "T.@put e :at i" 
 -- super: "T.@put e :at i" 
 -- E: "@put e :at i" 
 -- Items:Qalloc:END:objSize:2  newDescNo:64 "e := S.@get inx | i := L + inx |  ..." 
 -- IS.newDescNo:64 IS.objSize:2 "e := S.@get inx | i := L + inx | T.@put e :at ..." 
 -- computeVariant:newDescNo:64  size: 2  IS:"e := S.@get inx | i := L + inx |  ..." 
 -- ComputeVariant:B: "do#S#64" 
 -- ObjTmpStack:add::genDone:false "e := S.@get inx | i := L + inx | T.@put e : ..." 
 -- OG:markIS:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx ..." 
 -- items:markForCodeGen:"" 
 -- ComputeVariant:A:"@for::to:do#S#0" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- PropagateToSuper:@for::to:do
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + i ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := ..." 
 -- ObjectInvocation:Qalloc:"@for 1 :to S.length  | :do  |    e := S.@get inx |   ..." 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to S.length :do  |    e := S.@get inx |    i := L + inx |  ..." 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    T.@put ..." 
 -- super: "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    ..." 
 -- E: "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    T.@ ..." 
 -- OG:Qalloc:B:"@for::to:do#S#0" newDescNo:0 objSize:3 
 -- OG:isObjectDesc:NewDescNo:65 IS.newDescNo:65 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:0  newDescNo:65 "" 
 -- Items:Qalloc:super:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i : ..." : ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:65 "" 
 -- IS.newDescNo:65 IS.objSize:3 "" 
 -- computeVariant:newDescNo:65  size: 3  IS:"" 
 -- ComputeVariant:B: "@for::to:do#S#65" 
 -- ObjTmpStack:add::genDone:false "@for 1 :to S.length  | :do  |    e := S.@ge ..." 
 -- markItem:"V := T.asString" ObjectGenerator
 -- OG:markForCodeGen:"V := T.asString" 
 -- isObjectDesc:false isObjectDescX:false hasItems:false
 --  super.hasVirtualArgs:false
 --  super.isPrimitive:true
 --  (super.last).isPrimitive:true
 -- "V := T.asString" 
 -- "V" true
 -- ":= T.asString" true
 -- 
 -- OG:markSuper:"V := T.asString" 
 -- Invocation:markForCodeGen:"V := T.asString" 
 -- ObjectInvocation:markForCodeGen:"V"  ATd:"out V: ref String" 
 -- DataItem:markForCodeGen:"V" :descNo:0 :OG.primNo:5 
 -- ObjectInvocation:markForCodeGen:":= T.asString"  ATd:":= :  |    %basic 8 ..." 
 -- Pattern:markForCodeGen:":= :  |    %basic 8 |    in V: var Value" 
 -- arg: "T.asString" 
 -- not ObjDesc: "V := T.asString"  IS.isEmpty: true
 -- ComputeVariant:A:"doplus" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"e: var integer | i: var integer | T: obj Indexed(L + S.length, ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "e: var integer | i: var integer | T: obj Indexed(L + S.length,Integer) | @fo ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"doplus" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:66 IS.newDescNo:66 objSize:0 varNo:1 "e: var  ..." 
 -- Items:Qalloc:objSize:0  newDescNo:66 "e: var integer | i: var integer | T:  ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"e" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:2 
 -- dataitem:qalloc:"i" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:3 
 -- dataitem:qalloc:"T" isValue:false isPrimitive:true isValObj: false isBa ...false
 -- DI:Qalloc:off:4 "T: obj Indexed(L + S.length,Integer)" 
 -- OG:Qalloc:A:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at  ..." 
 -- ObjectInvocation:Qalloc:"@for 1 :to L  | :do  |    e := @get inx |    T.@put  ..." 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to L :do  |    e := @get inx |    T.@put e :at inx" 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- super: "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- E: "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- OG:Qalloc:B:"@for::to:do#S#63" newDescNo:63 objSize:3 
 -- OG:isObjectDesc:NewDescNo:67 IS.newDescNo:67 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:4  newDescNo:67 "" 
 -- Items:Qalloc:super:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at ..." : ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:67 "" 
 -- IS.newDescNo:67 IS.objSize:3 "" 
 -- OG:Qalloc:A:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + i ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i := ..." 
 -- ObjectInvocation:Qalloc:"@for 1 :to S.length  | :do  |    e := S.@get inx |   ..." 
 -- name: "@for::to:do" 
 -- Arguments "@for 1 :to S.length :do  |    e := S.@get inx |    i := L + inx |  ..." 
 -- OG:super: "@for:  |    %globals inSub |    in for: var integer |    in to: va ..." 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    T.@put ..." 
 -- super: "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    ..." 
 -- E: "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    T.@ ..." 
 -- OG:Qalloc:B:"@for::to:do#S#65" newDescNo:65 objSize:3 
 -- OG:isObjectDesc:NewDescNo:68 IS.newDescNo:68 objSize:3 varNo:1 "" 
 -- Items:Qalloc:objSize:4  newDescNo:68 "" 
 -- Items:Qalloc:super:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i : ..." : ...3 : ...true
 -- Items:Qalloc:super:B:objSize:4 originOff:4 
 -- Items:Qalloc:END:objSize:4  newDescNo:68 "" 
 -- IS.newDescNo:68 IS.objSize:3 "" 
 -- OG:Qalloc:A:"V := T.asString" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"V := T.asString" 
 -- ObjectInvocation:Qalloc:"V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= T.asString" 
 -- name: ":=" 
 -- Arguments "T.asString" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "V := T.asString" 
 -- super: "V := T.asString" 
 -- E: ":= T.asString" 
 -- Items:Qalloc:END:objSize:4  newDescNo:66 "e: var integer | i: var integer ..." 
 -- IS.newDescNo:66 IS.objSize:4 "e: var integer | i: var integer | T: obj Inde ..." 
 -- computeVariant:newDescNo:66  size: 4  IS:"e: var integer | i: var integer ..." 
 -- ComputeVariant:B: "doplus" 
 -- ObjTmpStack:add::genDone:false "doplus" :"e: var integer | i: var integer ..." 
 -- not ObjDesc: "doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1: ..."   ...true
 -- ComputeVariant:A:"+" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"in S: ref String | out V: ref String | L: var integer | L := Len ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "in S: ref String | out V: ref String | L: var integer | L := Length | doplus:  ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"+" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:69 IS.newDescNo:69 objSize:0 varNo:1 "in S: r ..." 
 -- Items:Qalloc:objSize:0  newDescNo:69 "in S: ref String | out V: ref Strin ..." 
 -- Items:Qalloc:Super:C:objSize:1 originOff:1 
 -- dataitem:qalloc:"S" isValue:false isPrimitive:true isValObj: false isBa ...false
 -- DI:Qalloc:off:2 "in S: ref String" 
 -- dataitem:qalloc:"V" isValue:false isPrimitive:true isValObj: false isBa ...false
 -- DI:Qalloc:off:3 "out V: ref String" 
 -- dataitem:qalloc:"L" isValue:true isPrimitive:true isValObj: true isBasi ...true
 -- diSize:1 IT.qSize:4 
 -- OG:Qalloc:A:"L := Length" 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"L := Length" 
 -- ObjectInvocation:Qalloc:"L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc:":= Length" 
 -- name: ":=" 
 -- Arguments "Length" 
 -- OG:super: ":= :  |    %basic 8 |    in V: var Value" 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "L := Length" 
 -- super: "L := Length" 
 -- E: ":= Length" 
 -- Pattern:Qalloc:doplus
 -- Pattern:Qalloc:B:doplus
 -- OG:Qalloc:A:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:l ..." 
 -- varNo:1 :allocDone:
 -- Invocation:Qalloc:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := ..." 
 -- ObjectInvocation:Qalloc:"doplus" 
 -- name: "doplus" 
 -- Arguments "" 
 -- OG:super: "doplus:  |    e: var integer |    i: var integer |    T: obj Index ..." 
 -- OG:Qalloc:isObjectDesc: false isObjectDescX: false
 -- "doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:length] + S.T ..." 
 -- super: "doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:length ..." 
 -- E: "doplus" 
 -- Items:Qalloc:END:objSize:4  newDescNo:69 "in S: ref String | out V: ref S ..." 
 -- IS.newDescNo:69 IS.objSize:4 "in S: ref String | out V: ref String | L: var ..." 
 -- computeVariant:newDescNo:69  size: 4  IS:"in S: ref String | out V: ref S ..." 
 -- ComputeVariant:B: "+" 
 -- ObjTmpStack:add::genDone:false "+ " :"in S: ref String | out V: ref Strin ..." 
 pushText Got  a: 
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: ""Got  a: "" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:36:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Unary:invoke: rec:""Got  a: "" "print"
 -- >top:1 descNo:36 
 -- E.ATd: "print" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"print" 
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:36  top:1  rec:""Got  a: "" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 36  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""Got  a: "" 
 -- kuk:obj:rec.ATd:"String:  |    %id "String pattern" |    %OSDvisibility dis ..." 
 invoke print 36 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""Got  a: "" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 L2:
 rtnInner
 end OSDV:0 objSize:2 isIndexed:0  vTop:2 vTopMax:2 rTop:0 rTopMax:1
 -- Handle VB: ""Got  a: ".print" E: "case('a')" 
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:39 :top:1 
 -- GenClass:@ifX::thenX:varNo = 1 
 -- GenClass:@ifX::thenX:true -> var.genDone

class @ifX::thenX 39 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 ifX
 allocEventQ
 mvStack 
 -- $Signature:gen: ""
 -- $var:gen: "in ifX: var boolean"
 -- DI:isConst:false:isBasicValue:true:primNo:4 
 -- OGqual:Boolean:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in thenX:< Object"
 -- vdt:d1 61 
 -- vdtAdd: inx=1 descInx=39 vDescInx=61
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals inSub" 
 -- $Property:gen: "%globals inSub"
 -- genclass:Qgen:stmt:"%basic 100" 
 -- $Property:gen: "%basic 100"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"@ifX::thenX" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:40 :top:1 
 -- GenClass:#S#40:varNo = 1 
 -- GenClass:#S#40:true -> var.genDone

class #S#40 40 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"then" 
 -- $ObjectGenerator:gen:"then#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:gen:super:"then" superDescNo:0 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 1 "then"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarythen
 -- isConstant: Invocation then
 -- Invocation then
 -- needorigin:"then" 
 -- needOrigin:E:"then"  E.ATd:"in then:< Object" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "then" 
 -- computeAdr:1 :rec:"none"  E:"then" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "then"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "then"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:#S#40:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 #S#40:origin
 -- goOrigin:on:1 
 -- goOrigin:Skip:ifThen
 -- goOrigin:on:1 
 -- goOrigin:if_L:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 if_L:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "then"
 -- $pattern:getAdr: "in then:< Object"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"th ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "then" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "then" E: "then" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "then"
 -- $pattern:loadArgs:E:"then":descNo:0:top:1 "in then:< Object"
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"then" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"then" "then"
 -- >top:1 descNo:0 
 -- E.ATd: "then" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"then" 
 -- $pattern:invoke: "in then:< Object"
 -- Pattern:invoke:descNo:0  top:1  rec:"then" 
 sendv 1 0 then
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"then" 
 rpop
 -- OI:invoke:then:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"then" 
 -- genclass:Qgen:stmt:"@leave if_L" 
 -- $ObjectGenerator:gen:"@leave:#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"" superDescNo:27 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 27 top: 0 "@leave if_L"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@leave if_L
 -- isConstant: Invocation @leave if_L
 -- Invocation @leave if_L
 -- needorigin:"@leave if_L" 
 -- needOrigin:E:"@leave if_L"  E.ATd:"@leave:  |    %basic 103 |    in leave:  ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@leave if_L" 
 -- computeAdr:1 :rec:"none"  E:"@leave if_L" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@leave if_L"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:3 "@leave if_L"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:3 "@leave if_L"
 -- $pattern:getAdr: "@leave:  |    %basic 103 |    in leave: var integer"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@l ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@leave if_L" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@leave if_L" E: "@leave if_L" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@leave if_L"
 -- $pattern:loadArgs:E:"@leave if_L":descNo:27:top:0 "@leave:  |    %basic 1 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@leave if_L" :Adr:off:0 sz:0 isF:F isUN:F sprA ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@leave if_L" "@leave if_L"
 -- >top:0 descNo:27 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@leave if_L" 
 -- $pattern:invoke: "@leave:  |    %basic 103 |    in leave: var integer"
 break 1 2 41
 -- OI:invoke:@leave if_L:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@leave if_L" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:41 :top:1 
 -- GenClass:if_L:varNo = 1 
 -- GenClass:if_L:true -> var.genDone

class if_L 41 1 42
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@ifX if :thenX  |    then |    @leave if_L -- problem w ..." 
 -- $ObjectGenerator:gen:"@ifX::thenX#S#0"IS.isempty! staticOff: 0 descNo:  ...
 -- OG:gen:super:"" superDescNo:39 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 39 top: 1 "@ifX if :thenX  |    then |    @leave i ..."
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@ifX if :thenX  |    then |    @leave if_L
 -- isConstant: Invocation @ifX if :thenX  |    then |    @leave if_L -- proble ...
 -- Invocation @ifX if :thenX  |    then |    @leave if_L
 -- needorigin:"@ifX if :thenX  |    then |    @leave if_L -- problem when @if  ..." 
 -- needOrigin:E:"@ifX if :thenX  |    then |    @leave if_L"  E.ATd:"@ifX: ..." 
 -- LoadOrign:no:loadOrigin: "%globals inSub | %basic 100 | in ifX: var boolean ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "@ifX if :thenX  |    then |    @leave if_L" E: "@ifX if :thenX  |   ..." i ...false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@ifX if :thenX  |    then ..."
 -- $pattern:loadArgs:E:"@ifX if :thenX  |    then |    @leave if_L":descNo:39: ...
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@ifX if :thenX  |    then |    @leave if_L" 
 -- $ObjectInvocation_KeyWord:invoke: rec:"@ifX if :thenX  |    then |    @leav ..."
 -- >top:1 descNo:39 
 -- HEST"@ifX if :thenX  |    then |    @leave if_L" 
 -- $pattern:invoke: "@ifX:  |    %globals inSub |    %basic 100 |    in ifX: var ..."
 -- $ObjectGenerator:gen:"if#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "if"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryif
 -- isConstant: Invocation if
 -- Invocation if
 -- not const: ifin if: var Boolean
 -- needorigin:"if" 
 -- needOrigin:E:"if"  E.ATd:"in if: var Boolean" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "if" 
 -- computeAdr:1 :rec:"none"  E:"if" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "if"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "if"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:if_L:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 if_L:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "if"
 -- $var:getAdr:,newOff:1,isValue:"True",A.isValue:"False" "in if: var Bool ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- Boolean
 -- before:floatTest: "in if: var Boolean" ObjectGenerator
 -- :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"if ..."
 -- After:U*U::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "if" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "if" E: "if" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "if"
 -- $var:loadArgs: "in if: var Boolean"
 -- DataItem:loadArgs:empty: "in if: var Boolean" 
 -- invoke:after:loadArgsOf:"if" :Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ ...
 -- $ObjectInvocation_Unary:invoke: rec:"if" "if"
 -- E.ATd: "if" unique: false
 -- adr::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"if" 
 -- $var:invoke: newOff:1 "in if: var Boolean"
 -- load::Adr:off:1 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 1 
 -- OI:invoke:if:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"if" 
 jmpFalse L3
 -- $ObjectGenerator:gen:"#S#40"singular! staticOff: 0 descNo: 40 top:1 | sup ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 40  "#S#40" 
 invoke #S#40 40 0 1
 rpop
 L3:
 -- OI:invoke:@ifX if :thenX  |    then |    @leave if_L:unit: -none- convF ...0.000000
 -- invoke:after:E.invoke:"@ifX if :thenX  |    then |    @leave if_L" 
 -- genclass:Qgen:stmt:"else" 
 -- $ObjectGenerator:gen:"else#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:gen:super:"else" superDescNo:0 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 1 "else"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryelse
 -- isConstant: Invocation else
 -- Invocation else
 -- needorigin:"else" 
 -- needOrigin:E:"else"  E.ATd:"in else:< Object" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "else" 
 -- computeAdr:1 :rec:"none"  E:"else" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "else"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "else"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:if_L:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 if_L:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "else"
 -- $pattern:getAdr: "in else:< Object"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"el ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "else" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "else" E: "else" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "else"
 -- $pattern:loadArgs:E:"else":descNo:0:top:1 "in else:< Object"
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"else" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"else" "else"
 -- >top:1 descNo:0 
 -- E.ATd: "else" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"else" 
 -- $pattern:invoke: "in else:< Object"
 -- Pattern:invoke:descNo:0  top:1  rec:"else" 
 sendv 2 0 else
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"else" 
 rpop
 -- OI:invoke:else:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"else" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:42 :top:1 
 -- GenClass:@if::then:else:varNo = 1 
 -- GenClass:@if::then:else:true -> var.genDone

class @if::then:else 42 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 if
 allocEventQ
 mvStack 
 -- $Signature:gen: ""
 -- $var:gen: "in if: var Boolean"
 -- DI:isConst:false:isBasicValue:true:primNo:4 
 -- OGqual:Boolean:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in then:< Object"
 -- vdt:d1 61 
 -- vdtAdd: inx=1 descInx=42 vDescInx=61
 -- $pattern:gen: "in else:< Object"
 -- vdt:d2 61 
 -- vdtAdd: inx=2 descInx=42 vDescInx=61
 -- $obj:gen: "if_L: obj  |    @ifX if :thenX  |       then |       @leave if_L - ..."
 -- DI:isConst:true:isBasicValue:false:primNo:0 
 -- OGqual:none:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"if_L"singular! staticOff: 2 descNo: 41 top:1 | supe ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 41  "if_L" 
 invoke if_L 41 2 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals inSub --,OSDvisibility[disguised]] |  | --Decl ..." 
 -- $Property:gen: "%globals inSub --,OSDvisibility[disguised]] |  | --Declarat ..."
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"@if::then:else" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:43 :top:1 
 -- GenClass:isLetter:varNo = 1 
 -- GenClass:isLetter:true -> var.genDone

class isLetter 43 1 5
 -- Store itemArgs
 pushThis 
 storeg 2 ch
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "isLetter"
 -- $var:gen: "in ch: var char"
 -- DI:isConst:false:isBasicValue:true:primNo:3 
 -- OGqual:char:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "out B: var Boolean"
 -- DI:isConst:false:isBasicValue:true:primNo:4 
 -- OGqual:Boolean:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch)  ..." 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "B := ((('a' <= ch) && (ch <= 'z')) | ..."
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryB
 -- ObjectInvocation_Binary:= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) ...
 -- isConstant: Invocation B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= c ...
 -- Invocation B
 -- not const: Bout B: var Boolean
 -- needorigin:"B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch < ..." 
 -- needOrigin:E:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch < ..."   ...": ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch  ..." 
 -- computeAdr:1 :rec:"none"  E:"B" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "B"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "B"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "B"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "out B: var Bool ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...o ...
 -- value_prim:false
 -- Boolean
 -- before:floatTest: "out B: var Boolean" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"B" ...
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"B"  E:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <=  ..."   ..."B ..." 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"B" ...
 -- computeAdr:isAssign:rec: "B"  E:":= ((('a' <= ch) && (ch <= 'z')) || (( ..." 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"B" ...
 -- computeAdr:isLast:E: ":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch)  ..." 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "B" E: ":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= ..." i ...true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= ((('a' <= ch) && (ch  ..."
 -- $pattern:loadArgs:E:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) & ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && ( ..." 
 -- ActArg: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z'))) ..." i ...false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= ((('a' <= ch) && (ch <= 'z')) || (( ..." 
 -- $ObjectGenerator:gen:"||#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch  ..."
 -- Invocation:qgen:superAdj: 0 
 -- BracketedExp((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z' ...
 -- isConstant: Invocation ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && ...
 -- Invocation ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z') ...
 -- needorigin:"((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z' ..." 
 -- needOrigin:E:"((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= ' ..."   ..."| ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z ..." 
 -- computeAdr:1 :rec:"none"  E:"((('a' <= ch) && (ch <= 'z')) || (('A' <=  ..." 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch)  ..."
 -- $BracketedExp:loadOrigin: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch ..."
 -- computeAdr: "(('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z' ..." 
 -- computeAdr:1 :rec:"none"  E:"(('a' <= ch) && (ch <= 'z'))" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "(('a' <= ch) && (ch <= 'z'))"
 -- $BracketedExp:loadOrigin: "(('a' <= ch) && (ch <= 'z'))"
 -- computeAdr: "('a' <= ch) && (ch <= 'z')" 
 -- computeAdr:1 :rec:"none"  E:"('a' <= ch)" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "('a' <= ch)"
 -- $BracketedExp:loadOrigin: "('a' <= ch)"
 -- computeAdr: "'a' <= ch" 
 -- computeAdr:1 :rec:"none"  E:"'a'" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $Char::pushThis: "'a'"
 -- $Char::loadOrigin: "'a'"
 -- $Char::getAdr: "'a'"
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"'a'"  E:"<= ch"  A.E:"'a'" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"'a ..."
 -- E:notAssign:<= ch
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= ch"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"'a ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $Char::loadArgs: "'a'"
 -- $Char::invoke: "'a'"
 pushc 97
 -- computeAdr:isLast:E: "<= ch" 
 -- BE:loadOrigin:E: <= ch
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= ch"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"<= ch"  E:"&& (ch <= 'z')"  A.E:"<= ch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- E:notAssign:&& (ch <= 'z')
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "&& (ch <= 'z')"
 -- $pattern:getAdr: "&& :  |    %basic 70 |    in B: var boolean |    out R: var ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "<= ch"
 -- $pattern:loadArgs:E:"<= ch":descNo:0:top:0 "<= :  |    %basic 52 |    in V: ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"<= ch" 
 -- ActArg: "ch" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "<= ch" 
 -- loadArgs:not:*: formalArgOf:"<= ch"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"ch#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "ch"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarych
 -- isConstant: Invocation ch
 -- Invocation ch
 -- not const: chin ch: var char
 -- needorigin:"ch" 
 -- needOrigin:E:"ch"  E.ATd:"in ch: var char" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "ch" 
 -- computeAdr:1 :rec:"none"  E:"ch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "ch"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "ch"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "ch"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in ch: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- char
 -- before:floatTest: "in ch: var char" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "ch" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "ch" E: "ch" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "ch"
 -- $var:loadArgs: "in ch: var char"
 -- DataItem:loadArgs:empty: "in ch: var char" 
 -- invoke:after:loadArgsOf:"ch" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ ...
 -- $ObjectInvocation_Unary:invoke: rec:"ch" "ch"
 -- E.ATd: "ch" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"ch" 
 -- $var:invoke: newOff:2 "in ch: var char"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:ch:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"ch" 
 -- loadArgs:after:Qgen:"<= ch" 
 -- formalArg:isPtn:"in V: var char" :isBasicVal:true:valueObj:true
 -- :actArg:"ch" :isBasicVal:true
 -- chObjectGenerator
 -- end:loadArgs:NonVirt:"<= ch" 
 -- $ObjectInvocation_Binary:invoke: rec:"'a'" "<= ch"
 -- >top:0 descNo:0 
 -- E.ATd: "&& " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"<= ch" 
 -- $pattern:invoke: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- bodyC:
 le
 -- OI:invoke:<= ch:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "&& (ch <= 'z')" 
 -- BE:loadOrigin:E: && (ch <= 'z')
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "&& (ch <= 'z')"
 -- $pattern:getAdr: "&& :  |    %basic 70 |    in B: var boolean |    out R: var ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"&& ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"&& (ch <= 'z')"  E:"|| (('A' <= ch) && (ch <= 'Z'))"   ..."& ..." 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"&& ..."
 -- E:notAssign:|| (('A' <= ch) && (ch <= 'Z'))
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "|| (('A' <= ch) && (c ..."
 -- $pattern:getAdr: "|| :  |    %basic 63 |    in B: var boolean |    out R: var ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"&& ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "&& (ch <= 'z')"
 -- $pattern:loadArgs:E:"&& (ch <= 'z')":descNo:0:top:0 "&& :  |    %basic 70 ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"&& (ch <= 'z')" 
 -- ActArg: "(ch <= 'z')" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "&& (ch <= 'z')" 
 -- loadArgs:not:*: formalArgOf:"&& (ch <= 'z')"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"<=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "(ch <= 'z')"
 -- Invocation:qgen:superAdj: 0 
 -- BracketedExp(ch <= 'z')
 -- isConstant: Invocation (ch <= 'z')
 -- Invocation (ch <= 'z')
 -- needorigin:"(ch <= 'z')" 
 -- needOrigin:E:"(ch <= 'z')"  E.ATd:"<= :  |    %basic 52 |    in V: var char ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "(ch <= 'z')" 
 -- computeAdr:1 :rec:"none"  E:"(ch <= 'z')" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "(ch <= 'z')"
 -- $BracketedExp:loadOrigin: "(ch <= 'z')"
 -- computeAdr: "ch <= 'z'" 
 -- computeAdr:1 :rec:"none"  E:"ch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "ch"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "ch"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "ch"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in ch: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- char
 -- before:floatTest: "in ch: var char" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"ch"  E:"<= 'z'"  A.E:"ch" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- E:notAssign:<= 'z'
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= 'z'"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "ch"
 -- $var:loadArgs: "in ch: var char"
 -- DataItem:loadArgs:empty: "in ch: var char" 
 -- $ObjectInvocation_Unary:invoke: rec:"ch" "ch"
 -- E.ATd: "<= " unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"ch" 
 -- $var:invoke: newOff:2 "in ch: var char"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:ch:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "<= 'z'" 
 -- BE:loadOrigin:E: <= 'z'
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= 'z'"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "<= 'z'" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "ch" E: "<= 'z'" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "<= 'z'"
 -- $pattern:loadArgs:E:"<= 'z'":descNo:0:top:0 "<= :  |    %basic 52 |    in V ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"<= 'z'" 
 -- ActArg: "'z'" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "<= 'z'" 
 -- loadArgs:not:*: formalArgOf:"<= 'z'"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"char#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "'z'"
 -- Invocation:qgen:superAdj: 0 
 -- Char:'z'
 -- isConstant: Invocation 'z'
 -- Invocation 'z'
 -- needorigin:"'z'" 
 -- needOrigin:E:"'z'"  E.ATd:"char: value |    %id "char" |    %globals |    %ba ..." 
 -- LoadOrign:no:loadOrigin: "value |    %id "char" |    %globals |    %basic 3,  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "'z'" E: "'z'" isValueAssign: false
 -- $Char::loadArgs: "'z'"
 -- invoke:after:loadArgsOf:"'z'" 
 -- $Char::invoke: "'z'"
 pushc 122
 -- invoke:after:E.invoke:"'z'" 
 -- loadArgs:after:Qgen:"<= 'z'" 
 -- formalArg:isPtn:"in V: var char" :isBasicVal:true:valueObj:true
 -- :actArg:"'z'" :isBasicVal:true
 -- 'z'ObjectGenerator
 -- end:loadArgs:NonVirt:"<= 'z'" 
 -- invoke:after:loadArgsOf:"<= 'z'" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Binary:invoke: rec:"ch" "<= 'z'"
 -- >top:0 descNo:0 
 -- E.ATd: "<= " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"<= 'z'" 
 -- $pattern:invoke: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- bodyC:
 le
 -- OI:invoke:<= 'z':unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"<= 'z'" 
 -- loadArgs:after:Qgen:"&& (ch <= 'z')" 
 -- formalArg:isPtn:"in B: var boolean" :isBasicVal:true:valueObj:true
 -- :actArg:"(ch <= 'z')" :isBasicVal:true
 -- (ch <= 'z')ObjectGenerator
 -- end:loadArgs:NonVirt:"&& (ch <= 'z')" 
 -- $ObjectInvocation_Binary:invoke: rec:"<= ch" "&& (ch <= 'z')"
 -- >top:0 descNo:0 
 -- E.ATd: "|| " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"&& (ch <= 'z')" 
 -- $pattern:invoke: "&& :  |    %basic 70 |    in B: var boolean |    out R: var ..."
 -- bodyC:
 andd
 -- OI:invoke:&& (ch <= 'z'):unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "|| (('A' <= ch) && (ch <= 'Z'))" 
 -- BE:loadOrigin:E: || (('A' <= ch) && (ch <= 'Z'))
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "|| (('A' <= ch) && (c ..."
 -- $pattern:getAdr: "|| :  |    %basic 63 |    in B: var boolean |    out R: var ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"|| ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "|| (('A' <= ch) && (ch <= 'Z'))" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "&& (ch <= 'z')" E: "|| (('A' <= ch) && (ch <= 'Z'))" isValueAssig ...false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "|| (('A' <= ch) && (ch < ..."
 -- $pattern:loadArgs:E:"|| (('A' <= ch) && (ch <= 'Z'))":descNo:0:top:0 "| ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"|| (('A' <= ch) && (ch <= 'Z'))" 
 -- ActArg: "(('A' <= ch) && (ch <= 'Z'))" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "|| (('A' <= ch) && (ch <= 'Z'))" 
 -- loadArgs:not:*: formalArgOf:"|| (('A' <= ch) && (ch <= 'Z'))"  isCompos ...false
 -- $ObjectGenerator:gen:"&&#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "(('A' <= ch) && (ch <= 'Z'))"
 -- Invocation:qgen:superAdj: 0 
 -- BracketedExp(('A' <= ch) && (ch <= 'Z'))
 -- isConstant: Invocation (('A' <= ch) && (ch <= 'Z'))
 -- Invocation (('A' <= ch) && (ch <= 'Z'))
 -- needorigin:"(('A' <= ch) && (ch <= 'Z'))" 
 -- needOrigin:E:"(('A' <= ch) && (ch <= 'Z'))"  E.ATd:"&& :  |    %basic 70 |  ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "(('A' <= ch) && (ch <= 'Z'))" 
 -- computeAdr:1 :rec:"none"  E:"(('A' <= ch) && (ch <= 'Z'))" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "(('A' <= ch) && (ch <= 'Z'))"
 -- $BracketedExp:loadOrigin: "(('A' <= ch) && (ch <= 'Z'))"
 -- computeAdr: "('A' <= ch) && (ch <= 'Z')" 
 -- computeAdr:1 :rec:"none"  E:"('A' <= ch)" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "('A' <= ch)"
 -- $BracketedExp:loadOrigin: "('A' <= ch)"
 -- computeAdr: "'A' <= ch" 
 -- computeAdr:1 :rec:"none"  E:"'A'" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $Char::pushThis: "'A'"
 -- $Char::loadOrigin: "'A'"
 -- $Char::getAdr: "'A'"
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"'A'"  E:"<= ch"  A.E:"'A'" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"'A ..."
 -- E:notAssign:<= ch
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= ch"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"'A ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $Char::loadArgs: "'A'"
 -- $Char::invoke: "'A'"
 pushc 65
 -- computeAdr:isLast:E: "<= ch" 
 -- BE:loadOrigin:E: <= ch
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= ch"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"<= ch"  E:"&& (ch <= 'Z')"  A.E:"<= ch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- E:notAssign:&& (ch <= 'Z')
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "&& (ch <= 'Z')"
 -- $pattern:getAdr: "&& :  |    %basic 70 |    in B: var boolean |    out R: var ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "<= ch"
 -- $pattern:loadArgs:E:"<= ch":descNo:0:top:0 "<= :  |    %basic 52 |    in V: ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"<= ch" 
 -- ActArg: "ch" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "<= ch" 
 -- loadArgs:not:*: formalArgOf:"<= ch"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"ch#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "ch"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarych
 -- isConstant: Invocation ch
 -- Invocation ch
 -- not const: chin ch: var char
 -- needorigin:"ch" 
 -- needOrigin:E:"ch"  E.ATd:"in ch: var char" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "ch" 
 -- computeAdr:1 :rec:"none"  E:"ch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "ch"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "ch"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "ch"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in ch: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- char
 -- before:floatTest: "in ch: var char" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "ch" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "ch" E: "ch" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "ch"
 -- $var:loadArgs: "in ch: var char"
 -- DataItem:loadArgs:empty: "in ch: var char" 
 -- invoke:after:loadArgsOf:"ch" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ ...
 -- $ObjectInvocation_Unary:invoke: rec:"ch" "ch"
 -- E.ATd: "ch" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"ch" 
 -- $var:invoke: newOff:2 "in ch: var char"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:ch:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"ch" 
 -- loadArgs:after:Qgen:"<= ch" 
 -- formalArg:isPtn:"in V: var char" :isBasicVal:true:valueObj:true
 -- :actArg:"ch" :isBasicVal:true
 -- chObjectGenerator
 -- end:loadArgs:NonVirt:"<= ch" 
 -- $ObjectInvocation_Binary:invoke: rec:"'A'" "<= ch"
 -- >top:0 descNo:0 
 -- E.ATd: "&& " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"<= ch" 
 -- $pattern:invoke: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- bodyC:
 le
 -- OI:invoke:<= ch:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "&& (ch <= 'Z')" 
 -- BE:loadOrigin:E: && (ch <= 'Z')
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "&& (ch <= 'Z')"
 -- $pattern:getAdr: "&& :  |    %basic 70 |    in B: var boolean |    out R: var ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"&& ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "&& (ch <= 'Z')" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "<= ch" E: "&& (ch <= 'Z')" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "&& (ch <= 'Z')"
 -- $pattern:loadArgs:E:"&& (ch <= 'Z')":descNo:0:top:0 "&& :  |    %basic 70 ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"&& (ch <= 'Z')" 
 -- ActArg: "(ch <= 'Z')" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "&& (ch <= 'Z')" 
 -- loadArgs:not:*: formalArgOf:"&& (ch <= 'Z')"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"<=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "(ch <= 'Z')"
 -- Invocation:qgen:superAdj: 0 
 -- BracketedExp(ch <= 'Z')
 -- isConstant: Invocation (ch <= 'Z')
 -- Invocation (ch <= 'Z')
 -- needorigin:"(ch <= 'Z')" 
 -- needOrigin:E:"(ch <= 'Z')"  E.ATd:"<= :  |    %basic 52 |    in V: var char ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "(ch <= 'Z')" 
 -- computeAdr:1 :rec:"none"  E:"(ch <= 'Z')" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $BracketedExp:pushThis: "(ch <= 'Z')"
 -- $BracketedExp:loadOrigin: "(ch <= 'Z')"
 -- computeAdr: "ch <= 'Z'" 
 -- computeAdr:1 :rec:"none"  E:"ch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "ch"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "ch"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "ch"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in ch: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- char
 -- before:floatTest: "in ch: var char" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"ch"  E:"<= 'Z'"  A.E:"ch" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- E:notAssign:<= 'Z'
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= 'Z'"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "ch"
 -- $var:loadArgs: "in ch: var char"
 -- DataItem:loadArgs:empty: "in ch: var char" 
 -- $ObjectInvocation_Unary:invoke: rec:"ch" "ch"
 -- E.ATd: "<= " unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"ch" 
 -- $var:invoke: newOff:2 "in ch: var char"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:ch:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "<= 'Z'" 
 -- BE:loadOrigin:E: <= 'Z'
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "<= 'Z'"
 -- $pattern:getAdr: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"<= ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "<= 'Z'" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "ch" E: "<= 'Z'" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "<= 'Z'"
 -- $pattern:loadArgs:E:"<= 'Z'":descNo:0:top:0 "<= :  |    %basic 52 |    in V ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"<= 'Z'" 
 -- ActArg: "'Z'" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "<= 'Z'" 
 -- loadArgs:not:*: formalArgOf:"<= 'Z'"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"char#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "'Z'"
 -- Invocation:qgen:superAdj: 0 
 -- Char:'Z'
 -- isConstant: Invocation 'Z'
 -- Invocation 'Z'
 -- needorigin:"'Z'" 
 -- needOrigin:E:"'Z'"  E.ATd:"char: value |    %id "char" |    %globals |    %ba ..." 
 -- LoadOrign:no:loadOrigin: "value |    %id "char" |    %globals |    %basic 3,  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "'Z'" E: "'Z'" isValueAssign: false
 -- $Char::loadArgs: "'Z'"
 -- invoke:after:loadArgsOf:"'Z'" 
 -- $Char::invoke: "'Z'"
 pushc 90
 -- invoke:after:E.invoke:"'Z'" 
 -- loadArgs:after:Qgen:"<= 'Z'" 
 -- formalArg:isPtn:"in V: var char" :isBasicVal:true:valueObj:true
 -- :actArg:"'Z'" :isBasicVal:true
 -- 'Z'ObjectGenerator
 -- end:loadArgs:NonVirt:"<= 'Z'" 
 -- invoke:after:loadArgsOf:"<= 'Z'" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Binary:invoke: rec:"ch" "<= 'Z'"
 -- >top:0 descNo:0 
 -- E.ATd: "<= " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"<= 'Z'" 
 -- $pattern:invoke: "<= :  |    %basic 52 |    in V: var char |    out B: var bo ..."
 -- bodyC:
 le
 -- OI:invoke:<= 'Z':unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"<= 'Z'" 
 -- loadArgs:after:Qgen:"&& (ch <= 'Z')" 
 -- formalArg:isPtn:"in B: var boolean" :isBasicVal:true:valueObj:true
 -- :actArg:"(ch <= 'Z')" :isBasicVal:true
 -- (ch <= 'Z')ObjectGenerator
 -- end:loadArgs:NonVirt:"&& (ch <= 'Z')" 
 -- invoke:after:loadArgsOf:"&& (ch <= 'Z')" :Adr:off:0 sz:0 isF:F isUN:F s ...
 -- $ObjectInvocation_Binary:invoke: rec:"<= ch" "&& (ch <= 'Z')"
 -- >top:0 descNo:0 
 -- E.ATd: "&& " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"&& (ch <= 'Z')" 
 -- $pattern:invoke: "&& :  |    %basic 70 |    in B: var boolean |    out R: var ..."
 -- bodyC:
 andd
 -- OI:invoke:&& (ch <= 'Z'):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"&& (ch <= 'Z')" 
 -- loadArgs:after:Qgen:"|| (('A' <= ch) && (ch <= 'Z'))" 
 -- formalArg:isPtn:"in B: var boolean" :isBasicVal:true:valueObj:true
 -- :actArg:"(('A' <= ch) && (ch <= 'Z'))" :isBasicVal:true
 -- (('A' <= ch) && (ch <= 'Z'))ObjectGenerator
 -- end:loadArgs:NonVirt:"|| (('A' <= ch) && (ch <= 'Z'))" 
 -- invoke:after:loadArgsOf:"|| (('A' <= ch) && (ch <= 'Z'))" :Adr:off:0 sz ...
 -- $ObjectInvocation_Binary:invoke: rec:"&& (ch <= 'z')" "|| (('A' <= ch)  ..."
 -- >top:0 descNo:0 
 -- E.ATd: "|| " unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"|| (('A' <= ch) && (ch <= 'Z'))" 
 -- $pattern:invoke: "|| :  |    %basic 63 |    in B: var boolean |    out R: var ..."
 -- bodyC:
 orr
 -- OI:invoke:|| (('A' <= ch) && (ch <= 'Z')):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"|| (('A' <= ch) && (ch <= 'Z'))" 
 -- loadArgs:after:Qgen:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) & ..." 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch)  ..." 
 -- invoke:after:loadArgsOf:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= c ..." : ...
 -- $ObjectInvocation_Binary:invoke: rec:"B" ":= ((('a' <= ch) && (ch <= 'z ..."
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "B" from: ":= ((('a' <= ch) && (ch <= 'z')) || (( ..." 
 -- assign:dstDI :"out B: var Boolean" isUnitValueObj: false
 -- assign:arg: "((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z ..." l ..."O ..." U ...false  ...false
 --  float: false DataItem:false arg.super:((('a' <= ch) && (ch <= 'z')) || ...
 --  arg.super.ATd:"Invocation" "|| :  |    %basic 63 |    in B: var boolean |    ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"B" ...
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 3 address:storeg
 -- OI:invoke::= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z ...: ...-none-  ...0.000000
 -- invoke:after:E.invoke:":= ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) ..." 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"isLetter" 
 setThisStack 
 pushThis 
 -- $var:invoke: newOff:3 "out B: var Boolean"
 -- >:E=none
 pushg 3 B
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:-5 vTopMax:0 rTop:6 rTopMax:6
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:44 :top:1 
 -- GenClass:then#S#44:varNo = 1 
 -- GenClass:then#S#44:true -> var.genDone

class then#S#44 44 1 56
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"chxxx := '!'" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "chxxx := '!'"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarychxxx
 -- ObjectInvocation_Binary:= '!'
 -- isConstant: Invocation chxxx := '!'
 -- Invocation chxxx
 -- not const: chxxxchxxx: var char
 -- needorigin:"chxxx := '!'" 
 -- needOrigin:E:":= '!'"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "chxxx := '!'" 
 -- computeAdr:1 :rec:"none"  E:"chxxx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "chxxx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:4 "chxxx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:4 
 -- goOrigin:then#S#44:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 then#S#44:origin
 -- goOrigin:on:3 
 -- goOrigin:@if::then:else#S#56:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 @if::then:else#S#56:origin
 -- goOrigin:on:2 
 -- goOrigin:switch#S#54:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 switch#S#54:origin
 -- goOrigin:on:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:4 "chxxx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "chxxx: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...c ...
 -- value_prim:false
 -- char
 -- before:floatTest: "chxxx: var char" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"chxxx"  E:":= '!'"  A.E:"chxxx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- computeAdr:isAssign:rec: "chxxx"  E:":= '!'" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- computeAdr:isLast:E: ":= '!'" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "chxxx" E: ":= '!'" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= '!'"
 -- $pattern:loadArgs:E:":= '!'":descNo:4:top:1 ":= :  |    %basic 8 |    in V: ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= '!'" 
 -- ActArg: "'!'" isValue: true
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= '!'" 
 -- $ObjectGenerator:gen:"char#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "'!'"
 -- Invocation:qgen:superAdj: 0 
 -- Char:'!'
 -- isConstant: Invocation '!'
 -- Invocation '!'
 -- needorigin:"'!'" 
 -- needOrigin:E:"'!'"  E.ATd:"char: value |    %id "char" |    %globals |    %ba ..." 
 -- LoadOrign:no:loadOrigin: "value |    %id "char" |    %globals |    %basic 3,  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "'!'" E: "'!'" isValueAssign: false
 -- $Char::loadArgs: "'!'"
 -- invoke:after:loadArgsOf:"'!'" 
 -- $Char::invoke: "'!'"
 pushc 33
 -- invoke:after:E.invoke:"'!'" 
 -- loadArgs:after:Qgen:":= '!'" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= '!'" 
 -- invoke:after:loadArgsOf:":= '!'" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Binary:invoke: rec:"chxxx" ":= '!'"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= '!'" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "chxxx" from: ":= '!'" 
 -- assign:dstDI :"chxxx: var char" isUnitValueObj: false
 -- assign:arg: "'!'" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:'!'
 --  arg.super.ATd:"Invocation" "char: value |    %id "char" |    %globals |    % ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 3 address:storeg
 -- OI:invoke::= '!':unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= '!'" 
 -- genclass:Qgen:stmt:"@restart loop" 
 -- $ObjectGenerator:gen:"@restart:#S#0"IS.isempty! staticOff: 0 descNo: 0  ...
 -- OG:gen:super:"" superDescNo:21 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 21 top: 0 "@restart loop"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@restart loop
 -- isConstant: Invocation @restart loop
 -- Invocation @restart loop
 -- needorigin:"@restart loop" 
 -- needOrigin:E:"@restart loop"  E.ATd:"@restart:  |    %basic 102 |    in res ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@restart loop" 
 -- computeAdr:1 :rec:"none"  E:"@restart loop" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@restart loop"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:5 "@restart loop"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:5 "@restart loop"
 -- $pattern:getAdr: "@restart:  |    %basic 102 |    in restart: var integer"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@r ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@restart loop" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@restart loop" E: "@restart loop" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@restart loop"
 -- $pattern:loadArgs:E:"@restart loop":descNo:21:top:0 "@restart:  |    %bas ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@restart loop" :Adr:off:0 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@restart loop" "@restart loop"
 -- >top:0 descNo:21 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@restart loop" 
 -- $pattern:invoke: "@restart:  |    %basic 102 |    in restart: var integer"
 break 3 1 53
 -- OI:invoke:@restart loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@restart loop" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:1 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:45 :top:1 
 -- GenClass::=:varNo = 1 
 -- GenClass::=:true -> var.genDone

class := 45 1 61
 -- Store itemArgs
 pushThis 
 storeg 2 V
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: ":= "
 -- $var:gen: "in V: var Value"
 -- DI:isConst:false:isBasicValue:false:primNo:21 
 -- OGqual:Value:OGqual.isBasicValue:false:OGqual.isValueObj:true
 -- inArg:in V: var Value
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%basic 8" 
 -- $Property:gen: "%basic 8"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:":=" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:46 :top:1 
 -- GenClass:C:varNo = 1 
 -- GenClass:C:true -> var.genDone

class C 46 1 13
 -- Store itemArgs
 pushThis 
 storeg 2 ch
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "C"
 -- $var:gen: "in ch: var char"
 -- DI:isConst:false:isBasicValue:true:primNo:3 
 -- OGqual:char:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $ref:gen: "out S: ref LIB.String.String"
 -- DI:isConst:false:isBasicValue:false:primNo:5 
 -- OGqual:String:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $obj:gen: "D: obj Indexed(1,char)"
 -- DI:isConst:true:isBasicValue:false:primNo:114 
 -- OGqual:Indexed:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"D"IS.isempty! staticOff: 4 descNo: 0 top:0 | superA ...
 -- OG:gen:super:"Indexed" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "Indexed(1,char)"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_FunctionIndexed(1,char)
 -- isConstant: Invocation Indexed(1,char)
 -- Invocation Indexed(1,char)
 -- needorigin:"Indexed(1,char)" 
 -- needOrigin:E:"Indexed(1,char)"  E.ATd:"Indexed:  |    %globals |    %basic  ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 114 | %public | in range: var Int ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Indexed(1,char)" E: "Indexed(1,char)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "Indexed(1,char)"
 -- $pattern:loadArgs:E:"Indexed(1,char)":descNo:0:top:0 "Indexed:  |    %glo ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"Indexed(1,char)" 
 -- ActArg: "1" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "Indexed(1,char)" 
 -- loadArgs:not:*: formalArgOf:"Indexed(1,char)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "1"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral1
 -- isConstant: Invocation 1
 -- Invocation 1
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"Indexed(1,char)" 
 -- formalArg:isPtn:"in range: var Integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"Indexed(1,char)" 
 -- invoke:after:loadArgsOf:"Indexed(1,char)" 
 -- $ObjectInvocation_Function:invoke: rec:"Indexed(1,char)" "Indexed(1,cha ..."
 -- >top:0 descNo:0 
 -- HEST"Indexed(1,char)" 
 -- $pattern:invoke: "Indexed:  |    %globals |    %basic 114 |    %public |    in  ..."
 pushThis 
 -- ComputeVariant:A:"Indexed" 
 -- checkIfTopIsNew:A:topVarExists:false isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is new:top: 1 var.thisVarNo:1 
 -- OG:Qalloc:A:"%globals | %basic 114 | %public | in range: var Integer | in elm:< ..." 
 -- varNo:1 :allocDone:false
 -- Invocation:Qalloc:"" 
 -- OG:Qalloc:isObjectDesc: true isObjectDescX: true
 -- "%globals | %basic 114 | %public | in range: var Integer | in elm:< Object | leng ..." 
 -- super: "" 
 -- E: "" 
 -- OG:Qalloc:B:"Indexed" newDescNo:0 objSize:0 
 -- OG:isObjectDesc:NewDescNo:70 IS.newDescNo:70 objSize:0 varNo:1 "%global ..." 
 -- Items:Qalloc:objSize:0  newDescNo:70 "%globals | %basic 114 | %public | in ra ..." 
 -- Items:Qalloc:Super:C:objSize:0 originOff:0 
 -- dataitem:qalloc:"range" isValue:true isPrimitive:true isValObj: true is ...true
 -- diSize:1 IT.qSize:1 
 -- Pattern:Qalloc:elm
 -- Pattern:Qalloc:B:elm
 -- Pattern:Qalloc:length
 -- Pattern:Qalloc:B:length
 -- Pattern:Qalloc:@put::at
 -- Pattern:Qalloc:@get:
 -- Pattern:Qalloc:asString
 -- Items:Qalloc:END:objSize:1  newDescNo:70 "%globals | %basic 114 | %public | i ..." 
 -- IS.newDescNo:70 IS.objSize:1 "%globals | %basic 114 | %public | in range: var ..." 
 -- computeVariant:newDescNo:70  size: 1  IS:"%globals | %basic 114 | %public | i ..." 
 -- ComputeVariant:B: "Indexed" 
 -- ObjTmpStack:add::genDone:false "Indexed" :"%globals | %basic 114 | %public |  ..." 
 pushc 1
 allocIndexed StaticRep 70 1 0
 pushThis 
 rstoreg 4 indexed
 -- OI:invoke:Indexed(1,char):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Indexed(1,char)" 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"D.@put ch :at 1" 
 -- $ObjectGenerator:gen:"@put::at#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:gen:super:"" superDescNo:47 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 47 top: 0 "D.@put ch :at 1"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryD
 -- ObjectInvocation_KeyWord@put ch :at 1
 -- isConstant: Invocation D.@put ch :at 1
 -- Invocation D
 -- Invocation @put ch :at 1
 -- needorigin:"D.@put ch :at 1" 
 -- needOrigin:E:"@put ch :at 1"  E.ATd:"@put:  |    %basic 115 |    in put: re ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "D.@put ch :at 1" 
 -- computeAdr:1 :rec:"none"  E:"D" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "D"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "D"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "D"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "D: obj Indexed ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...D ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"D"  E:"@put ch :at 1" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:@put ch :at 1
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@put ch :at 1"
 -- $pattern:getAdr: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@p ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "D"
 -- $obj:loadArgs: "D: obj Indexed(1,char)"
 -- DataItem:loadArgs:empty: "D: obj Indexed(1,char)" 
 -- $ObjectInvocation_Unary:invoke: rec:"D" "D"
 -- E.ATd: "" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"D" 
 -- $obj:invoke: newOff:4 "D: obj Indexed(1,char)"
 -- >Object:unique:false
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F: ...
 rpushg 4 
 -- OI:invoke:D:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@put ch :at 1" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "D" E: "@put ch :at 1" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@put ch :at 1"
 -- $pattern:loadArgs:E:"@put ch :at 1":descNo:47:top:0 "@put:  |    %basic 1 ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@put ch :at 1" 
 -- ActArg: "ch" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:false
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@put ch :at 1" 
 -- loadArgs:not:*: formalArgOf:"@put ch :at 1"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"ch#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "ch"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarych
 -- isConstant: Invocation ch
 -- Invocation ch
 -- not const: chin ch: var char
 -- needorigin:"ch" 
 -- needOrigin:E:"ch"  E.ATd:"in ch: var char" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "ch" 
 -- computeAdr:1 :rec:"none"  E:"ch" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "ch"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "ch"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "ch"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "in ch: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- char
 -- before:floatTest: "in ch: var char" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "ch" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "ch" E: "ch" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "ch"
 -- $var:loadArgs: "in ch: var char"
 -- DataItem:loadArgs:empty: "in ch: var char" 
 -- invoke:after:loadArgsOf:"ch" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ ...
 -- $ObjectInvocation_Unary:invoke: rec:"ch" "ch"
 -- E.ATd: "ch" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"ch" 
 -- $var:invoke: newOff:2 "in ch: var char"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:ch:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"ch" 
 -- loadArgs:after:Qgen:"@put ch :at 1" 
 -- formalArg:isPtn:"in put: ref elm" :isBasicVal:false:valueObj:false
 -- :actArg:"ch" :isBasicVal:true
 -- chObjectGenerator
 -- end:loadArgs:NonVirt:"@put ch :at 1" 
 -- loadArgs:NonVirt:"@put ch :at 1" 
 -- ActArg: "1" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@put ch :at 1" 
 -- loadArgs:not:*: formalArgOf:"@put ch :at 1"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "1"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral1
 -- isConstant: Invocation 1
 -- Invocation 1
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@put ch :at 1" 
 -- formalArg:isPtn:"in at: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"@put ch :at 1" 
 -- invoke:after:loadArgsOf:"@put ch :at 1" :Adr:off:4 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"D" "@put ch :at 1"
 -- >top:0 descNo:47 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@put ch :at 1" 
 -- $pattern:invoke: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- char
 -- primitive
 xstoreg inx 1 0 1
1 inx
 -- OI:invoke:@put ch :at 1:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@put ch :at 1" 
 -- genclass:Qgen:stmt:"S := D.asString" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:45 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 45 top: 1 "S := D.asString"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryS
 -- ObjectInvocation_Binary:= D.asString
 -- isConstant: Invocation S := D.asString
 -- Invocation S
 -- not const: Sout S: ref LIB.String.String
 -- needorigin:"S := D.asString" 
 -- needOrigin:E:":= D.asString"  E.ATd:":= :  |    %basic 8 |    in V: var Val ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "S := D.asString" 
 -- computeAdr:1 :rec:"none"  E:"S" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "S"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "S"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "out S: ref LIB ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...o ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"S"  E:":= D.asString" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- computeAdr:isAssign:rec: "S"  E:":= D.asString" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- computeAdr:isLast:E: ":= D.asString" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "S" E: ":= D.asString" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= D.asString"
 -- $pattern:loadArgs:E:":= D.asString":descNo:45:top:1 ":= :  |    %basic 8 |  ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= D.asString" 
 -- ActArg: "D.asString" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= D.asString" 
 -- $ObjectGenerator:gen:"asString#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:gen:super:"asString" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "D.asString"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryD
 -- ObjectInvocation_UnaryasString
 -- isConstant: Invocation D.asString
 -- Invocation D
 -- Invocation asString
 -- needorigin:"D.asString" 
 -- needOrigin:E:"asString"  E.ATd:"asString:  |    %basic 118 |    out S: ref  ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "D.asString" 
 -- computeAdr:1 :rec:"none"  E:"D" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "D"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "D"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "D"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "D: obj Indexed ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...D ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"D"  E:"asString" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:asString
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "asString"
 -- $pattern:getAdr: "asString:  |    %basic 118 |    out S: ref Object"
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"as ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "D"
 -- $obj:loadArgs: "D: obj Indexed(1,char)"
 -- DataItem:loadArgs:empty: "D: obj Indexed(1,char)" 
 -- $ObjectInvocation_Unary:invoke: rec:"D" "D"
 -- E.ATd: "asString" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"D" 
 -- $obj:invoke: newOff:4 "D: obj Indexed(1,char)"
 -- >Object:unique:false
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F: ...
 rpushg 4 
 -- OI:invoke:D:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "asString" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "D" E: "asString" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "asString"
 -- $pattern:loadArgs:E:"asString":descNo:0:top:0 "asString:  |    %basic 118 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"asString" :Adr:off:4 sz:0 isF:F isUN:F sprAdj: ...
 -- $ObjectInvocation_Unary:invoke: rec:"D" "asString"
 -- >top:0 descNo:0 
 -- E.ATd: "asString" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"asString" 
 -- $pattern:invoke: "asString:  |    %basic 118 |    out S: ref Object"
 %asString 118
 -- OI:invoke:asString:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"asString" 
 -- loadArgs:after:Qgen:":= D.asString" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= D.asString" 
 -- invoke:after:loadArgsOf:":= D.asString" :Adr:off:3 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_Binary:invoke: rec:"S" ":= D.asString"
 -- >top:1 descNo:45 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST":= D.asString" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "S" from: ":= D.asString" 
 -- assign:dstDI :"out S: ref LIB.String.String" isUnitValueObj: false
 -- assign:arg: "D.asString" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:D.asString
 --  arg.super.ATd:"Invocation" "asString:  |    %basic 118 |    out S: ref Obj ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "S" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 3 
 -- OI:invoke::= D.asString:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= D.asString" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"C" 
 setThisStack 
 pushThis 
 -- $ref:invoke: newOff:3 "out S: ref LIB.String.String"
 -- >Object:unique:false
 -- >adr=none
 rpushg 3 S
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:0 vTopMax:2 rTop:3 rTopMax:4
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:48 :top:1 
 -- GenClass:else#S#48:varNo = 1 
 -- GenClass:else#S#48:true -> var.genDone

class else#S#48 48 1 56
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:""bingo: {C(chxxx)}".print" 
 -- $ObjectGenerator:gen:"print#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"print" superDescNo:36 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 36 top: 1 ""bingo: {C(chxxx)}".print"
 -- Invocation:qgen:superAdj: 0 
 -- String:"bingo: {C(chxxx)}"
 -- ObjectInvocation_Unaryprint
 -- isConstant: Invocation "bingo: {C(chxxx)}".print
 -- Invocation "bingo: {C(chxxx)}"
 -- needorigin:""bingo: {C(chxxx)}".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: ""bingo: {C(chxxx)}".print" 
 -- computeAdr:1 :rec:"none"  E:""bingo: {C(chxxx)}"" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $String::pushThis: ""bingo: {C(chxxx)}""
 -- $String::loadOrigin: ""bingo: {C(chxxx)}""
 -- StringObj:loadOrigin:"bingo: {C(chxxx)}"
 -- $String::getAdr: ""bingo: {C(chxxx)}""
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:""bingo: {C(chxxx)}""  E:"print"  A.E:""bingo: {C(chx ..."" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:""b ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:""b ...
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $String::loadArgs: ""bingo: {C(chxxx)}""
 -- $String::invoke: ""bingo: {C(chxxx)}""
 -- Pattern:markForCodeGen:"+ :  |    in S: ref String |    out V: ref String |   ..." 
 pushText bingo: 
 -- $Invocation:gen: descNo: 46 top: 1 "C(chxxx)"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_FunctionC(chxxx)
 -- isConstant: Invocation C(chxxx)
 -- Invocation C(chxxx)
 -- needorigin:"C(chxxx)" 
 -- needOrigin:E:"C(chxxx)"  E.ATd:"C:  |    in ch: var char |    out S: ref LI ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "C(chxxx)" 
 -- computeAdr:1 :rec:"none"  E:"C(chxxx)" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Function:pushThis: "C(chxxx)"
 pushThis 
 -- $ObjectInvocation_Function:loadOrigin::on:4 "C(chxxx)"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:4 
 -- goOrigin:else#S#48:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 else#S#48:origin
 -- goOrigin:on:3 
 -- goOrigin:@if::then:else#S#56:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 @if::then:else#S#56:origin
 -- goOrigin:on:2 
 -- goOrigin:switch#S#54:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 switch#S#54:origin
 -- goOrigin:on:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- viaIncl:on:0 String org:"%include String | Y: var integer | chxxx: var char ..." 
 -- goInclude:furtherInclude
 -- viaIncl:on:0 LIB org:"%include String | Y: var integer | chxxx: var char | ch ..." 
 -- goInclude:endOfIncludeChain
 -- goOrigin:on:2 
 -- goOrigin:tinyB:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 tinyB:origin
 -- goOrigin:on:1 
 -- goOrigin:workspace:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 workspace:origin
 -- include:pushOff:3 
 rpushg 3 LIB
 -- include:pushOff:4 
 rpushg 4 String
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:4 "C(chxxx)"
 -- $pattern:getAdr: "C:  |    in ch: var char |    out S: ref LIB.String.Strin ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"C( ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "C(chxxx)" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "C(chxxx)" E: "C(chxxx)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "C(chxxx)"
 -- $pattern:loadArgs:E:"C(chxxx)":descNo:46:top:1 "C:  |    in ch: var char |  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"C(chxxx)" 
 -- ActArg: "chxxx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "C(chxxx)" 
 -- loadArgs:not:*: formalArgOf:"C(chxxx)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"chxxx#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "chxxx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarychxxx
 -- isConstant: Invocation chxxx
 -- Invocation chxxx
 -- not const: chxxxchxxx: var char
 -- needorigin:"chxxx" 
 -- needOrigin:E:"chxxx"  E.ATd:"chxxx: var char" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "chxxx" 
 -- computeAdr:1 :rec:"none"  E:"chxxx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "chxxx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:4 "chxxx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:4 
 -- goOrigin:else#S#48:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 else#S#48:origin
 -- goOrigin:on:3 
 -- goOrigin:@if::then:else#S#56:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 @if::then:else#S#56:origin
 -- goOrigin:on:2 
 -- goOrigin:switch#S#54:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 switch#S#54:origin
 -- goOrigin:on:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:4 "chxxx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "chxxx: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...c ...
 -- value_prim:false
 -- char
 -- before:floatTest: "chxxx: var char" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "chxxx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "chxxx" E: "chxxx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "chxxx"
 -- $var:loadArgs: "chxxx: var char"
 -- DataItem:loadArgs:empty: "chxxx: var char" 
 -- invoke:after:loadArgsOf:"chxxx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Unary:invoke: rec:"chxxx" "chxxx"
 -- E.ATd: "chxxx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"chxxx" 
 -- $var:invoke: newOff:3 "chxxx: var char"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:chxxx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"chxxx" 
 -- loadArgs:after:Qgen:"C(chxxx)" 
 -- formalArg:isPtn:"in ch: var char" :isBasicVal:true:valueObj:true
 -- :actArg:"chxxx" :isBasicVal:true
 -- chxxxObjectGenerator
 -- end:loadArgs:NonVirt:"C(chxxx)" 
 -- invoke:after:loadArgsOf:"C(chxxx)" :Adr:off:0 sz:0 isF:F isUN:F sprAdj: ...
 -- $ObjectInvocation_Function:invoke: rec:"C(chxxx)" "C(chxxx)"
 -- >top:1 descNo:46 
 -- E.ATd: "C" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"C(chxxx)" 
 -- $pattern:invoke: "C:  |    in ch: var char |    out S: ref LIB.String.Strin ..."
 -- Pattern:invoke:descNo:46  top:1  rec:"C(chxxx)" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"C:  |    in ch: var char |    o ..." 
 -- rec=E:true:rec:"C(chxxx)" 
 -- kuk:obj:rec.ATd:"C:  |    in ch: var char |    out S: ref LIB.String.String ..." 
 invoke C 46 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:false:rec=E:true"C(chxxx)" 
 -- OI:invoke:C(chxxx):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"C(chxxx)" 
 invoke + 69 0 1
 pushText 
 invoke + 69 0 1
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: ""bingo: {C(chxxx)}"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:36:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Unary:invoke: rec:""bingo: {C(chxxx)}"" "print"
 -- >top:1 descNo:36 
 -- E.ATd: "print" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"print" 
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:36  top:1  rec:""bingo: {C(chxxx)}"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 36  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""bingo: {C(chxxx)}"" 
 -- kuk:obj:rec.ATd:"String:  |    %id "String pattern" |    %OSDvisibility dis ..." 
 invoke print 36 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""bingo: {C(chxx ..."" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"@leave loop" 
 -- $ObjectGenerator:gen:"@leave:#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"" superDescNo:27 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 27 top: 0 "@leave loop"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@leave loop
 -- isConstant: Invocation @leave loop
 -- Invocation @leave loop
 -- needorigin:"@leave loop" 
 -- needOrigin:E:"@leave loop"  E.ATd:"@leave:  |    %basic 103 |    in leave:  ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@leave loop" 
 -- computeAdr:1 :rec:"none"  E:"@leave loop" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@leave loop"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:5 "@leave loop"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:5 "@leave loop"
 -- $pattern:getAdr: "@leave:  |    %basic 103 |    in leave: var integer"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@l ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@leave loop" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@leave loop" E: "@leave loop" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@leave loop"
 -- $pattern:loadArgs:E:"@leave loop":descNo:27:top:0 "@leave:  |    %basic 1 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@leave loop" :Adr:off:0 sz:0 isF:F isUN:F sprA ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@leave loop" "@leave loop"
 -- >top:0 descNo:27 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@leave loop" 
 -- $pattern:invoke: "@leave:  |    %basic 103 |    in leave: var integer"
 break 3 2 53
 -- OI:invoke:@leave loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@leave loop" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:3 rTopMax:3
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:56 :top:1 
 -- GenClass:@if::then:else#S#56:varNo = 1 
 -- GenClass:@if::then:else#S#56:true -> var.genDone

class @if::then:else#S#56 56 3 54
 -- Store itemArgs
 tstOriginIsNone 
 rstore 3 origin
 -- super @if::then:else
 -- vdt:b
 --  1:61 2:61 3:0 4:0
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@if ascii.isLetter(chxx ..."
 -- $pattern:loadArgs:E:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |   ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @ ..." 
 -- ActArg: "ascii.isLetter(chxxx)" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 3  "@if ascii.isLetter(chxxx) :then  |     ..." 
 -- loadArgs:not:*: formalArgOf:"@if ascii.isLetter(chxxx) :then  |    chxxx  ..."   ...false
 -- $ObjectGenerator:gen:"isLetter#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:gen:super:"isLetter" superDescNo:43 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 3 
 -- $Invocation:gen: descNo: 43 top: 1 "ascii.isLetter(chxxx)"
 -- Invocation:qgen:superAdj: 3 
 -- ObjectInvocation_Unaryascii
 -- ObjectInvocation_FunctionisLetter(chxxx)
 -- isConstant: Invocation ascii.isLetter(chxxx)
 -- Invocation ascii
 -- Invocation isLetter(chxxx)
 -- needorigin:"ascii.isLetter(chxxx)" 
 -- needOrigin:E:"isLetter(chxxx)"  E.ATd:"isLetter:  |    in ch: var char |    ..." 
 -- IV:FISK:superAdj:3 
 -- computeAdr: "ascii.isLetter(chxxx)" 
 -- computeAdr:1 :rec:"none"  E:"ascii" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "ascii"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "ascii"
 -- AdjustOrigin:originOff: 3
 rpushg 3 origin
 -- goOrigin:on:3 
 -- goOrigin:switch#S#54:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 switch#S#54:origin
 -- goOrigin:on:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:on:1 
 -- goOrigin:tinyB:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 tinyB:origin
 -- viaIncl:on:0 BETA org:"%id "workspace" | %include BETA, LIB, LIB.BasicIO |  ..." 
 -- goInclude:endOfIncludeChain
 -- goOrigin:on:1 
 -- goOrigin:workspace:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 workspace:origin
 -- include:pushOff:2 
 rpushg 2 BETA
 -- $ObjectInvocation_Unary:getAdr::superAdj:3:on:3 "ascii"
 -- $obj:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "ascii: obj  |    ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E: ...  ...a ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"ascii"  E:"isLetter(chxxx)" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:isLetter(chxxx)
 -- $ObjectInvocation_Function:getAdr::superAdj:0:on:0 "isLetter(chxxx)"
 -- $pattern:getAdr: "isLetter:  |    in ch: var char |    out B: var Boolean |   ..."
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"is ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "ascii"
 -- $obj:loadArgs: "ascii: obj  |    nl: val 10 |    cr: val 13 |    newline: var ..."
 -- DataItem:loadArgs:empty: "ascii: obj  |    nl: val 10 |    cr: val 13 |    ne ..." 
 -- $ObjectInvocation_Unary:invoke: rec:"ascii" "ascii"
 -- E.ATd: "isLetter" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"ascii" 
 -- $obj:invoke: newOff:2 "ascii: obj  |    nl: val 10 |    cr: val 13 |    newli ..."
 -- >Object:unique:false
 -- loadAdr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal ...
 rpushg 2 
 -- OI:invoke:ascii:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "isLetter(chxxx)" 
 -- IV:after:computeAdr:superAdj:3 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "ascii" E: "isLetter(chxxx)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "isLetter(chxxx)"
 -- $pattern:loadArgs:E:"isLetter(chxxx)":descNo:43:top:1 "isLetter:  |    in ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"isLetter(chxxx)" 
 -- ActArg: "chxxx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 3  "isLetter(chxxx)" 
 -- loadArgs:not:*: formalArgOf:"isLetter(chxxx)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"chxxx#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 3 
 -- $Invocation:gen: "chxxx"
 -- Invocation:qgen:superAdj: 3 
 -- ObjectInvocation_Unarychxxx
 -- isConstant: Invocation chxxx
 -- Invocation chxxx
 -- not const: chxxxchxxx: var char
 -- needorigin:"chxxx" 
 -- needOrigin:E:"chxxx"  E.ATd:"chxxx: var char" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:3 
 -- computeAdr: "chxxx" 
 -- computeAdr:1 :rec:"none"  E:"chxxx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "chxxx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "chxxx"
 -- AdjustOrigin:originOff: 3
 rpushg 3 origin
 -- goOrigin:on:2 
 -- goOrigin:switch#S#54:encOG.IS.newOriginOff:3 :newOriginOff:3 
 rpushg 3 switch#S#54:origin
 -- goOrigin:on:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:3:on:2 "chxxx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "chxxx: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E: ...  ...c ...
 -- value_prim:false
 -- char
 -- before:floatTest: "chxxx: var char" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "chxxx" 
 -- IV:after:computeAdr:superAdj:3 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "chxxx" E: "chxxx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "chxxx"
 -- $var:loadArgs: "chxxx: var char"
 -- DataItem:loadArgs:empty: "chxxx: var char" 
 -- invoke:after:loadArgsOf:"chxxx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Unary:invoke: rec:"chxxx" "chxxx"
 -- E.ATd: "chxxx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"chxxx" 
 -- $var:invoke: newOff:3 "chxxx: var char"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:chxxx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"chxxx" 
 -- loadArgs:after:Qgen:"isLetter(chxxx)" 
 -- formalArg:isPtn:"in ch: var char" :isBasicVal:true:valueObj:true
 -- :actArg:"chxxx" :isBasicVal:true
 -- chxxxObjectGenerator
 -- end:loadArgs:NonVirt:"isLetter(chxxx)" 
 -- invoke:after:loadArgsOf:"isLetter(chxxx)" :Adr:off:2 sz:0 isF:F isUN:F  ...
 -- $ObjectInvocation_Function:invoke: rec:"ascii" "isLetter(chxxx)"
 -- >top:1 descNo:43 
 -- E.ATd: "isLetter" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"isLetter(chxxx)" 
 -- $pattern:invoke: "isLetter:  |    in ch: var char |    out B: var Boolean |   ..."
 -- Pattern:invoke:descNo:43  top:1  rec:"ascii" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:true:"isLetter:  |    in ch: var cha ..." 
 -- rec=E:false:rec:"ascii" 
 -- kuk:obj:rec.ATd:"ascii: obj  |    nl: val 10 |    cr: val 13 |    newline: va ..." 
 invoke isLetter 43 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:false"ascii" 
 -- OI:invoke:isLetter(chxxx):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"isLetter(chxxx)" 
 -- loadArgs:after:Qgen:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |   ..." 
 -- formalArg:isPtn:"in if: var Boolean" :isBasicVal:true:valueObj:true
 -- :actArg:"ascii.isLetter(chxxx)" :isBasicVal:true
 -- ascii.isLetter(chxxx)ObjectGenerator
 -- end:loadArgs:NonVirt:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |  ..." 
 -- "in then:< Object" 
 -- "chxxx := '!' | @restart loop" 
 -- vdt:Q: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart lo ..." 
 -- formalArg: "in then:< Object" actualArg: "chxxx := '!' | @restart loop" 
 -- 1  (actualArg.desc).newDescno: 44  (OGx.desc).newDescNo: 56  stubDescNo ...0 
 -- "in else:< Object" 
 -- ""bingo: {C(chxxx)}".print | @leave loop" 
 -- vdt:Q: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @restart lo ..." 
 -- formalArg: "in else:< Object" actualArg: ""bingo: {C(chxxx)}".print | @le ..." 
 -- 2  (actualArg.desc).newDescno: 48  (OGx.desc).newDescNo: 56  stubDescNo ...0 
 toSuper 42
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:1 rTopMax:1
 -- Handle VB: "" E: "@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    @ ..." 
 -- Virtual
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:54 :top:1 
 -- GenClass:switch#S#54:varNo = 1 
 -- GenClass:switch#S#54:true -> var.genDone

class switch#S#54 54 3 53
 -- Store itemArgs
 tstOriginIsNone 
 rstore 3 origin
 -- super switch
 -- vdt:b
 --  1:0 2:0 3:0 4:0
 -- vdt:c:innerInx: 1  descNo: 54  superDesc.descNo:54 
 -- vdtAdd: inx=1 descInx=54 vDescInx=54
 -- computeAdr: "switch(chxxx)" 
 -- computeAdr:1 :rec:"none"  E:"switch(chxxx)" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Function:pushThis: "switch(chxxx)"
 pushThis 
 -- $ObjectInvocation_Function:loadOrigin::on:2 "switch(chxxx)"
 -- AdjustOrigin:originOff: 3
 rpushg 3 origin
 -- goOrigin:on:2 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- goOrigin:on:1 
 -- goOrigin:tinyB:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 tinyB:origin
 -- viaIncl:on:0 BETA org:"%id "workspace" | %include BETA, LIB, LIB.BasicIO |  ..." 
 -- goInclude:endOfIncludeChain
 -- goOrigin:on:1 
 -- goOrigin:workspace:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 workspace:origin
 -- include:pushOff:2 
 rpushg 2 BETA
 -- addOG
 -- $ObjectInvocation_Function:getAdr::superAdj:3:on:2 "switch(chxxx)"
 -- $pattern:getAdr: "switch:  |    in V: var integer |    %public |    case:  |    ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E:"sw ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue ...
 -- computeAdr:isLast:E: "switch(chxxx)" 
 -- genClass:after:ComputeAdr:"switch(chxxx)" :Adr:off:0 sz:0 isF:F isUN:F  ...
 -- Super:sig none
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "switch(chxxx)"
 -- $pattern:loadArgs:E:"switch(chxxx)":descNo:15:top:1 "switch:  |    in V:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"switch(chxxx)" 
 -- ActArg: "chxxx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 3  "switch(chxxx)" 
 -- loadArgs:not:*: formalArgOf:"switch(chxxx)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"chxxx#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 3 
 -- $Invocation:gen: "chxxx"
 -- Invocation:qgen:superAdj: 3 
 -- ObjectInvocation_Unarychxxx
 -- isConstant: Invocation chxxx
 -- Invocation chxxx
 -- not const: chxxxchxxx: var char
 -- needorigin:"chxxx" 
 -- needOrigin:E:"chxxx"  E.ATd:"chxxx: var char" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:3 
 -- computeAdr: "chxxx" 
 -- computeAdr:1 :rec:"none"  E:"chxxx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "chxxx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "chxxx"
 -- AdjustOrigin:originOff: 3
 rpushg 3 origin
 -- goOrigin:on:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:3:on:1 "chxxx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "chxxx: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:3 isUQ:F isValue:F orgIsVal:F:E: ...  ...c ...
 -- value_prim:false
 -- char
 -- before:floatTest: "chxxx: var char" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "chxxx" 
 -- IV:after:computeAdr:superAdj:3 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "chxxx" E: "chxxx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "chxxx"
 -- $var:loadArgs: "chxxx: var char"
 -- DataItem:loadArgs:empty: "chxxx: var char" 
 -- invoke:after:loadArgsOf:"chxxx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Unary:invoke: rec:"chxxx" "chxxx"
 -- E.ATd: "chxxx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"chxxx" 
 -- $var:invoke: newOff:3 "chxxx: var char"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:chxxx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"chxxx" 
 -- loadArgs:after:Qgen:"switch(chxxx)" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"chxxx" :isBasicVal:true
 -- chxxxObjectGenerator
 -- end:loadArgs:NonVirt:"switch(chxxx)" 
 toSuper 15
 rtnInner
DO:
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"case('a') |    "Got  a: ".print" 
 -- $ObjectGenerator:gen:"case#S#55"singular! staticOff: 0 descNo: 55 top:1 ...
 -- OG:gen:super:"case" superDescNo:30 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 55  "case#S#55" 
 invoke case#S#55 55 0 1
 rpop
 -- genclass:Qgen:stmt:""else:".print" 
 -- $ObjectGenerator:gen:"print#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"print" superDescNo:36 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 36 top: 1 ""else:".print"
 -- Invocation:qgen:superAdj: 0 
 -- String:"else:"
 -- ObjectInvocation_Unaryprint
 -- isConstant: Invocation "else:".print
 -- Invocation "else:"
 -- needorigin:""else:".print" 
 -- needOrigin:E:"print"  E.ATd:"print:  |    @for 1 :to length  |    :do  |      ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: ""else:".print" 
 -- computeAdr:1 :rec:"none"  E:""else:"" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $String::pushThis: ""else:""
 -- $String::loadOrigin: ""else:""
 -- StringObj:loadOrigin:"else:"
 -- $String::getAdr: ""else:""
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:""else:""  E:"print"  A.E:""else:"" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:""e ...
 -- E:notAssign:print
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "print"
 -- $pattern:getAdr: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:""e ...
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $String::loadArgs: ""else:""
 -- $String::invoke: ""else:""
 -- Pattern:markForCodeGen:"+ :  |    in S: ref String |    out V: ref String |   ..." 
 pushText else:
 -- computeAdr:isLast:E: "print" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: ""else:"" E: "print" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "print"
 -- $pattern:loadArgs:E:"print":descNo:36:top:1 "print:  |    @for 1 :to leng ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"print" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Unary:invoke: rec:""else:"" "print"
 -- >top:1 descNo:36 
 -- E.ATd: "print" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"print" 
 -- $pattern:invoke: "print:  |    @for 1 :to length  |    :do  |       put(@get  ..."
 -- Pattern:invoke:descNo:36  top:1  rec:""else:"" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- rec:module or pattern:"print"  descno: 36  top: 1 "@for 1 :to length  | : ..." 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"print:  |    @for 1 :to lengt ..." 
 -- rec=E:false:rec:""else:"" 
 -- kuk:obj:rec.ATd:"String:  |    %id "String pattern" |    %OSDvisibility dis ..." 
 invoke print 36 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:false""else:"" 
 rpop
 -- OI:invoke:print:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"print" 
 -- genclass:Qgen:stmt:"@if ascii.isLetter(chxxx) :then  |    chxxx := '!' |    ..." 
 -- $ObjectGenerator:gen:"@if::then:else#S#56"IS.isempty! staticOff: 0 desc ...
 -- OG:gen:super:"" superDescNo:42 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 56  "@if::then:else#S#56" 
 invoke @if::then:else#S#56 56 0 1
 rpop
 L2:
 rtnInner
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:0 rTop:1 rTopMax:2
 -- Handle VB: "case('a') |    "Got  a: ".print | "else:".print | @if ascii.isLet ..." E ..."s ..." 
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:53 :top:1 
 -- GenClass:loop:varNo = 1 
 -- GenClass:loop:true -> var.genDone

class loop 53 1 58
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "loop"
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"switch(chxxx) |    case('a') |       "Got  a: ".print |   ..." 
 -- $ObjectGenerator:gen:"switch#S#54"singular! staticOff: 0 descNo: 54 top ...
 -- OG:gen:super:"switch" superDescNo:15 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 54  "switch#S#54" 
 invoke switch#S#54 54 0 1
 rpop
 -- genclass:Qgen:stmt:"chxxx := '?'" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "chxxx := '?'"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarychxxx
 -- ObjectInvocation_Binary:= '?'
 -- isConstant: Invocation chxxx := '?'
 -- Invocation chxxx
 -- not const: chxxxchxxx: var char
 -- needorigin:"chxxx := '?'" 
 -- needOrigin:E:":= '?'"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "chxxx := '?'" 
 -- computeAdr:1 :rec:"none"  E:"chxxx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "chxxx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "chxxx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:loop:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 loop:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "chxxx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "chxxx: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...c ...
 -- value_prim:false
 -- char
 -- before:floatTest: "chxxx: var char" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"chxxx"  E:":= '?'"  A.E:"chxxx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- computeAdr:isAssign:rec: "chxxx"  E:":= '?'" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- computeAdr:isLast:E: ":= '?'" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "chxxx" E: ":= '?'" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= '?'"
 -- $pattern:loadArgs:E:":= '?'":descNo:4:top:1 ":= :  |    %basic 8 |    in V: ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= '?'" 
 -- ActArg: "'?'" isValue: true
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= '?'" 
 -- $ObjectGenerator:gen:"char#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "'?'"
 -- Invocation:qgen:superAdj: 0 
 -- Char:'?'
 -- isConstant: Invocation '?'
 -- Invocation '?'
 -- needorigin:"'?'" 
 -- needOrigin:E:"'?'"  E.ATd:"char: value |    %id "char" |    %globals |    %ba ..." 
 -- LoadOrign:no:loadOrigin: "value |    %id "char" |    %globals |    %basic 3,  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "'?'" E: "'?'" isValueAssign: false
 -- $Char::loadArgs: "'?'"
 -- invoke:after:loadArgsOf:"'?'" 
 -- $Char::invoke: "'?'"
 pushc 63
 -- invoke:after:E.invoke:"'?'" 
 -- loadArgs:after:Qgen:":= '?'" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= '?'" 
 -- invoke:after:loadArgsOf:":= '?'" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Binary:invoke: rec:"chxxx" ":= '?'"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= '?'" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "chxxx" from: ":= '?'" 
 -- assign:dstDI :"chxxx: var char" isUnitValueObj: false
 -- assign:arg: "'?'" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:'?'
 --  arg.super.ATd:"Invocation" "char: value |    %id "char" |    %globals |    % ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 3 address:storeg
 -- OI:invoke::= '?':unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= '?'" 
 -- genclass:Qgen:stmt:"@restart loop" 
 -- $ObjectGenerator:gen:"@restart:#S#0"IS.isempty! staticOff: 0 descNo: 0  ...
 -- OG:gen:super:"" superDescNo:21 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 21 top: 0 "@restart loop"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@restart loop
 -- isConstant: Invocation @restart loop
 -- Invocation @restart loop
 -- needorigin:"@restart loop" 
 -- needOrigin:E:"@restart loop"  E.ATd:"@restart:  |    %basic 102 |    in res ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@restart loop" 
 -- computeAdr:1 :rec:"none"  E:"@restart loop" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@restart loop"
 -- $ObjectInvocation_KeyWord:loadOrigin::on:2 "@restart loop"
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:2 "@restart loop"
 -- $pattern:getAdr: "@restart:  |    %basic 102 |    in restart: var integer"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@r ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@restart loop" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@restart loop" E: "@restart loop" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@restart loop"
 -- $pattern:loadArgs:E:"@restart loop":descNo:21:top:0 "@restart:  |    %bas ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"@restart loop" :Adr:off:0 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@restart loop" "@restart loop"
 -- >top:0 descNo:21 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@restart loop" 
 -- $pattern:invoke: "@restart:  |    %basic 102 |    in restart: var integer"
 jmp L1
 -- OI:invoke:@restart loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@restart loop" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"loop" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:1 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:57 :top:1 
 -- GenClass:newline:varNo = 1 
 -- GenClass:newline:true -> var.genDone

class newline 57 0 6
 -- Store itemArgs
 allocEventQ
 mvStack 
 -- $Signature:gen: "newline"
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"put(10)" 
 -- $ObjectGenerator:gen:"put#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:gen:super:"put" superDescNo:33 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 33 top: 1 "put(10)"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Functionput(10)
 -- isConstant: Invocation put(10)
 -- Invocation put(10)
 -- needorigin:"put(10)" 
 -- needOrigin:E:"put(10)"  E.ATd:"put:  |    %globals |    %basic 2 |    in ch:  ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 2 | in ch: val char" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "put(10)" E: "put(10)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "put(10)"
 -- $pattern:loadArgs:E:"put(10)":descNo:33:top:1 "put:  |    %globals |    %ba ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"put(10)" 
 -- ActArg: "10" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "put(10)" 
 -- loadArgs:not:*: formalArgOf:"put(10)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "10"
 -- Invocation:qgen:superAdj: 0 
 -- ConstLiteral10
 -- isConstant: Invocation 10
 -- Invocation 10
 -- needorigin:"10" 
 -- needOrigin:E:"10"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "10" E: "10" isValueAssign: false
 -- $ConstLiteral:loadArgs: "10"
 -- invoke:after:loadArgsOf:"10" 
 -- $ConstLiteral:invoke: "10"
 pushc 10
 -- invoke:after:E.invoke:"10" 
 -- loadArgs:after:Qgen:"put(10)" 
 -- formalArg:isPtn:"in ch: val char" :isBasicVal:true:valueObj:true
 -- :actArg:"10" :isBasicVal:true
 -- 10ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"put(10)" 
 -- invoke:after:loadArgsOf:"put(10)" 
 -- $ObjectInvocation_Function:invoke: rec:"put(10)" "put(10)"
 -- >top:1 descNo:33 
 -- HEST"put(10)" 
 -- $pattern:invoke: "put:  |    %globals |    %basic 2 |    in ch: val char"
 %put 2
 -- OI:invoke:put(10):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"put(10)" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"newline" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:0 isIndexed:0  vTop:1 vTopMax:1 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:58 :top:1 
 -- GenClass:tinyB:varNo = 1 
 -- GenClass:tinyB:true -> var.genDone

class tinyB 58 1 59
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $var:gen: "Y: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "chxxx: var char"
 -- DI:isConst:false:isBasicValue:true:primNo:3 
 -- OGqual:char:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%include String" 
 -- $Property:gen: "%include String"
 -- genclass:Qgen:stmt:"chxxx := 'a'" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "chxxx := 'a'"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarychxxx
 -- ObjectInvocation_Binary:= 'a'
 -- isConstant: Invocation chxxx := 'a'
 -- Invocation chxxx
 -- not const: chxxxchxxx: var char
 -- needorigin:"chxxx := 'a'" 
 -- needOrigin:E:":= 'a'"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "chxxx := 'a'" 
 -- computeAdr:1 :rec:"none"  E:"chxxx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "chxxx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "chxxx"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "chxxx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "chxxx: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...c ...
 -- value_prim:false
 -- char
 -- before:floatTest: "chxxx: var char" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"chxxx"  E:":= 'a'"  A.E:"chxxx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- computeAdr:isAssign:rec: "chxxx"  E:":= 'a'" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- computeAdr:isLast:E: ":= 'a'" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "chxxx" E: ":= 'a'" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= 'a'"
 -- $pattern:loadArgs:E:":= 'a'":descNo:4:top:1 ":= :  |    %basic 8 |    in V: ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= 'a'" 
 -- ActArg: "'a'" isValue: true
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= 'a'" 
 -- $ObjectGenerator:gen:"char#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "'a'"
 -- Invocation:qgen:superAdj: 0 
 -- Char:'a'
 -- isConstant: Invocation 'a'
 -- Invocation 'a'
 -- needorigin:"'a'" 
 -- needOrigin:E:"'a'"  E.ATd:"char: value |    %id "char" |    %globals |    %ba ..." 
 -- LoadOrign:no:loadOrigin: "value |    %id "char" |    %globals |    %basic 3,  ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "'a'" E: "'a'" isValueAssign: false
 -- $Char::loadArgs: "'a'"
 -- invoke:after:loadArgsOf:"'a'" 
 -- $Char::invoke: "'a'"
 pushc 97
 -- invoke:after:E.invoke:"'a'" 
 -- loadArgs:after:Qgen:":= 'a'" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= 'a'" 
 -- invoke:after:loadArgsOf:":= 'a'" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Binary:invoke: rec:"chxxx" ":= 'a'"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= 'a'" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "chxxx" from: ":= 'a'" 
 -- assign:dstDI :"chxxx: var char" isUnitValueObj: false
 -- assign:arg: "'a'" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:'a'
 --  arg.super.ATd:"Invocation" "char: value |    %id "char" |    %globals |    % ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 3 address:storeg
 -- OI:invoke::= 'a':unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= 'a'" 
 -- genclass:Qgen:stmt:"loop" 
 -- $ObjectGenerator:gen:"loop#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 ...
 -- OG:gen:super:"loop" superDescNo:53 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 53 top: 1 "loop"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryloop
 -- isConstant: Invocation loop
 -- Invocation loop
 -- needorigin:"loop" 
 -- needOrigin:E:"loop"  E.ATd:"loop:  |    switch(chxxx) |       case('a') |     ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "loop" 
 -- computeAdr:1 :rec:"none"  E:"loop" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "loop"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "loop"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "loop"
 -- $pattern:getAdr: "loop:  |    switch(chxxx) |       case('a') |          "Got ...
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"lo ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "loop" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "loop" E: "loop" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "loop"
 -- $pattern:loadArgs:E:"loop":descNo:53:top:1 "loop:  |    switch(chxxx) |     ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"loop" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- $ObjectInvocation_Unary:invoke: rec:"loop" "loop"
 -- >top:1 descNo:53 
 -- E.ATd: "loop" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"loop" 
 -- $pattern:invoke: "loop:  |    switch(chxxx) |       case('a') |          "Got ...
 -- Pattern:invoke:descNo:53  top:1  rec:"loop" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"loop:  |    switch(chxxx) |     ..." 
 -- rec=E:true:rec:"loop" 
 -- kuk:obj:rec.ATd:"loop:  |    switch(chxxx) |       case('a') |          "Got  ..."" 
 invoke loop 53 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"loop" 
 rpop
 -- OI:invoke:loop:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"loop" 
 -- genclass:Qgen:stmt:"put(chxxx)" 
 -- $ObjectGenerator:gen:"put#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:gen:super:"put" superDescNo:33 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 33 top: 1 "put(chxxx)"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Functionput(chxxx)
 -- isConstant: Invocation put(chxxx)
 -- Invocation put(chxxx)
 -- needorigin:"put(chxxx)" 
 -- needOrigin:E:"put(chxxx)"  E.ATd:"put:  |    %globals |    %basic 2 |    in c ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 2 | in ch: val char" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "put(chxxx)" E: "put(chxxx)" isValueAssign: false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "put(chxxx)"
 -- $pattern:loadArgs:E:"put(chxxx)":descNo:33:top:1 "put:  |    %globals |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"put(chxxx)" 
 -- ActArg: "chxxx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "put(chxxx)" 
 -- loadArgs:not:*: formalArgOf:"put(chxxx)"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"chxxx#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "chxxx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarychxxx
 -- isConstant: Invocation chxxx
 -- Invocation chxxx
 -- not const: chxxxchxxx: var char
 -- needorigin:"chxxx" 
 -- needOrigin:E:"chxxx"  E.ATd:"chxxx: var char" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "chxxx" 
 -- computeAdr:1 :rec:"none"  E:"chxxx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "chxxx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "chxxx"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "chxxx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "chxxx: var char ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...c ...
 -- value_prim:false
 -- char
 -- before:floatTest: "chxxx: var char" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"ch ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "chxxx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "chxxx" E: "chxxx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "chxxx"
 -- $var:loadArgs: "chxxx: var char"
 -- DataItem:loadArgs:empty: "chxxx: var char" 
 -- invoke:after:loadArgsOf:"chxxx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Unary:invoke: rec:"chxxx" "chxxx"
 -- E.ATd: "chxxx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"chxxx" 
 -- $var:invoke: newOff:3 "chxxx: var char"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:chxxx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"chxxx" 
 -- loadArgs:after:Qgen:"put(chxxx)" 
 -- formalArg:isPtn:"in ch: val char" :isBasicVal:true:valueObj:true
 -- :actArg:"chxxx" :isBasicVal:true
 -- chxxxObjectGenerator
 -- end:loadArgs:NonVirt:"put(chxxx)" 
 -- invoke:after:loadArgsOf:"put(chxxx)" 
 -- $ObjectInvocation_Function:invoke: rec:"put(chxxx)" "put(chxxx)"
 -- >top:1 descNo:33 
 -- HEST"put(chxxx)" 
 -- $pattern:invoke: "put:  |    %globals |    %basic 2 |    in ch: val char"
 %put 2
 -- OI:invoke:put(chxxx):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"put(chxxx)" 
 -- genclass:Qgen:stmt:"newline" 
 -- $ObjectGenerator:gen:"newline#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:gen:super:"newline" superDescNo:57 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 57 top: 1 "newline"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarynewline
 -- isConstant: Invocation newline
 -- Invocation newline
 -- needorigin:"newline" 
 -- needOrigin:E:"newline"  E.ATd:"newline:  |    %globals |    put(10)" 
 -- LoadOrign:no:loadOrigin: "%globals | put(10)" 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "newline" E: "newline" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "newline"
 -- $pattern:loadArgs:E:"newline":descNo:57:top:1 "newline:  |    %globals |    ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"newline" 
 -- $ObjectInvocation_Unary:invoke: rec:"newline" "newline"
 -- >top:1 descNo:57 
 -- HEST"newline" 
 -- $pattern:invoke: "newline:  |    %globals |    put(10)"
 -- Pattern:invoke:descNo:57  top:1  rec:"newline" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"newline:  |    %globals |    pu ..." 
 -- rec=E:true:rec:"newline" 
 -- kuk:obj:rec.ATd:"newline:  |    %globals |    put(10)" 
 invoke newline 57 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"newline" 
 rpop
 -- OI:invoke:newline:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"newline" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:3 isIndexed:0  vTop:0 vTopMax:1 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:59 :top:1 
 -- GenClass:workspace:varNo = 1 
 -- GenClass:workspace:true -> var.genDone

class workspace 59 1 60
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- ModuleItem:gen tinyB
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- $obj:gen: "tinyB: obj  |    %include String |    Y: var integer |    chxxx: v ..."
 -- $ObjectGenerator:gen:"tinyB"singular! staticOff: 2 descNo: 58 top:1 | sup ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 58  "tinyB" 
 invoke tinyB 58 2 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%id "workspace"" 
 -- $Property:gen: "%id "workspace""
 -- genclass:Qgen:stmt:"%include BETA, LIB, LIB.BasicIO" 
 -- $Property:gen: "%include BETA, LIB, LIB.BasicIO"
 -- genclass:Qgen:stmt:"%domain_boundary" 
 -- $Property:gen: "%domain_boundary"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:60 :top:1 
 -- GenClass:BETAworld:varNo = 1 
 -- GenClass:BETAworld:true -> var.genDone

class BETAworld 60 1 0
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 pushThis 
 saveBETAworld
 mvStack 
 -- $ModuleItem:gen: ""
 -- ModuleItem:gen BETA
 -- $obj:gen: "BETA: obj  |    %ID BETA |    %OSDvisibility disguised |    %publi ..."
 -- $ObjectGenerator:gen:"BETA"singular! staticOff: 2 descNo: 6 top:1 | super ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 6  "BETA" 
 invoke BETA 6 2 1
 rpop
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- ModuleItem:gen LIB
 -- $obj:gen: "LIB: obj  |    %id "LIB" |    %include BETA |    x_dummy_LIB: var  ..."
 -- $ObjectGenerator:gen:"LIB"singular! staticOff: 3 descNo: 14 top:1 | super ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 14  "LIB" 
 invoke LIB 14 3 1
 rpop
 -- $ModuleItem:gen: ""
 -- $ModuleItem:gen: ""
 -- ModuleItem:gen workspace
 -- $obj:gen: "workspace: obj  |    %id "workspace" |    %include BETA, LIB, LI ..."
 -- $ObjectGenerator:gen:"workspace"singular! staticOff: 4 descNo: 59 top:1 ...
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 59  "workspace" 
 invoke workspace 59 4 1
 rpop
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%id "BETAworld"" 
 -- $Property:gen: "%id "BETAworld""
 -- genclass:Qgen:stmt:"%modules BETA, LIB, LIB.String" 
 -- $Property:gen: "%modules BETA, LIB, LIB.String"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:0 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:62 :top:1 
 -- GenClass:do#S#62:varNo = 1 
 -- GenClass:do#S#62:true -> var.genDone

class do#S#62 62 2 67
 -- Store itemArgs
 tstOriginIsNone 
 rstore 2 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"e := @get inx" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "e := @get inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarye
 -- ObjectInvocation_Binary:= @get inx
 -- isConstant: Invocation e := @get inx
 -- Invocation e
 -- not const: ee: var integer
 -- needorigin:"e := @get inx" 
 -- needOrigin:E:":= @get inx"  E.ATd:":= :  |    %basic 8 |    in V: var Value ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "e := @get inx" 
 -- computeAdr:1 :rec:"none"  E:"e" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#62:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#62:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#67:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#67:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "e: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"e"  E:":= @get inx"  A.E:"e" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- computeAdr:isAssign:rec: "e"  E:":= @get inx" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- computeAdr:isLast:E: ":= @get inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "e" E: ":= @get inx" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= @get inx"
 -- $pattern:loadArgs:E:":= @get inx":descNo:4:top:1 ":= :  |    %basic 8 |     ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= @get inx" 
 -- ActArg: "@get inx" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= @get inx" 
 -- $ObjectGenerator:gen:"@get:#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "@get inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_KeyWord@get inx
 -- isConstant: Invocation @get inx
 -- Invocation @get inx
 -- needorigin:"@get inx" 
 -- needOrigin:E:"@get inx"  E.ATd:"@get:  |    %basic 117 |    in get: var int ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "@get inx" 
 -- computeAdr:1 :rec:"none"  E:"@get inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_KeyWord:pushThis: "@get inx"
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin::on:4 "@get inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:4 
 -- goOrigin:do#S#62:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#62:origin
 -- goOrigin:on:3 
 -- goOrigin:@for::to:do#S#67:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#67:origin
 -- goOrigin:on:2 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- goOrigin:on:1 
 -- goOrigin:+:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 +:origin
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:4 "@get inx"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@g ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "@get inx" E: "@get inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get inx"
 -- $pattern:loadArgs:E:"@get inx":descNo:0:top:0 "@get:  |    %basic 117 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get inx" 
 -- ActArg: "inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@get inx" 
 -- loadArgs:not:*: formalArgOf:"@get inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"inx#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- isConstant: Invocation inx
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:do#S#62:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#62:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- invoke:after:loadArgsOf:"inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@get inx" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectGenerator
 -- end:loadArgs:NonVirt:"@get inx" 
 -- invoke:after:loadArgsOf:"@get inx" :Adr:off:0 sz:0 isF:F isUN:F sprAdj: ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"@get inx" "@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@get inx" 
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get inx" 
 -- loadArgs:after:Qgen:":= @get inx" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= @get inx" 
 -- invoke:after:loadArgsOf:":= @get inx" :Adr:off:2 sz:0 isF:F isUN:F sprA ...
 -- $ObjectInvocation_Binary:invoke: rec:"e" ":= @get inx"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= @get inx" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "e" from: ":= @get inx" 
 -- assign:dstDI :"e: var integer" isUnitValueObj: false
 -- assign:arg: "@get inx" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:@get inx
 --  arg.super.ATd:"Invocation" "@get:  |    %basic 117 |    in get: var intege ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- store::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 2 address:storeg
 -- OI:invoke::= @get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= @get inx" 
 -- genclass:Qgen:stmt:"T.@put e :at inx" 
 -- $ObjectGenerator:gen:"@put::at#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:gen:super:"" superDescNo:47 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 47 top: 0 "T.@put e :at inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryT
 -- ObjectInvocation_KeyWord@put e :at inx
 -- isConstant: Invocation T.@put e :at inx
 -- Invocation T
 -- Invocation @put e :at inx
 -- needorigin:"T.@put e :at inx" 
 -- needOrigin:E:"@put e :at inx"  E.ATd:"@put:  |    %basic 115 |    in put: r ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "T.@put e :at inx" 
 -- computeAdr:1 :rec:"none"  E:"T" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "T"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#62:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#62:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#67:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#67:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "T"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "T: obj Indexed ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...T ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"T"  E:"@put e :at inx" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:@put e :at inx
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@put e :at inx"
 -- $pattern:getAdr: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@p ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "T"
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)"
 -- DataItem:loadArgs:empty: "T: obj Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Unary:invoke: rec:"T" "T"
 -- E.ATd: "" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"T" 
 -- $obj:invoke: newOff:4 "T: obj Indexed(L + S.length,Integer)"
 -- >Object:unique:false
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F: ...
 rpushg 4 
 -- OI:invoke:T:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@put e :at inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "T" E: "@put e :at inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@put e :at inx"
 -- $pattern:loadArgs:E:"@put e :at inx":descNo:47:top:0 "@put:  |    %basic  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@put e :at inx" 
 -- ActArg: "e" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:false
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@put e :at inx" 
 -- loadArgs:not:*: formalArgOf:"@put e :at inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"e#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "e"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarye
 -- isConstant: Invocation e
 -- Invocation e
 -- not const: ee: var integer
 -- needorigin:"e" 
 -- needOrigin:E:"e"  E.ATd:"e: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "e" 
 -- computeAdr:1 :rec:"none"  E:"e" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#62:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#62:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#67:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#67:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "e: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "e" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "e" E: "e" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "e"
 -- $var:loadArgs: "e: var integer"
 -- DataItem:loadArgs:empty: "e: var integer" 
 -- invoke:after:loadArgsOf:"e" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ: ...
 -- $ObjectInvocation_Unary:invoke: rec:"e" "e"
 -- E.ATd: "e" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"e" 
 -- $var:invoke: newOff:2 "e: var integer"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:e:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"e" 
 -- loadArgs:after:Qgen:"@put e :at inx" 
 -- formalArg:isPtn:"in put: ref elm" :isBasicVal:false:valueObj:false
 -- :actArg:"e" :isBasicVal:true
 -- eObjectGenerator
 -- end:loadArgs:NonVirt:"@put e :at inx" 
 -- loadArgs:NonVirt:"@put e :at inx" 
 -- ActArg: "inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@put e :at inx" 
 -- loadArgs:not:*: formalArgOf:"@put e :at inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"inx#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- isConstant: Invocation inx
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:do#S#62:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#62:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- invoke:after:loadArgsOf:"inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@put e :at inx" 
 -- formalArg:isPtn:"in at: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectGenerator
 -- end:loadArgs:NonVirt:"@put e :at inx" 
 -- invoke:after:loadArgsOf:"@put e :at inx" :Adr:off:4 sz:0 isF:F isUN:F s ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"T" "@put e :at inx"
 -- >top:0 descNo:47 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@put e :at inx" 
 -- $pattern:invoke: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- Integer
 -- primitive
 xstoreg inx 1 0 1
1 inx
 -- OI:invoke:@put e :at inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@put e :at inx" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-2 vTopMax:1 rTop:6 rTopMax:6
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:67 :top:1 
 -- GenClass:@for::to:do#S#67:varNo = 1 
 -- GenClass:@for::to:do#S#67:true -> var.genDone

class @for::to:do#S#67 67 4 66
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super @for::to:do
 -- vdt:b
 --  1:61 2:0 3:0 4:0
 -- vdt:c:innerInx: 2  descNo: 67  superDesc.descNo:67 
 -- vdtAdd: inx=2 descInx=67 vDescInx=67
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@for 1 :to L  | :do  |    e ..."
 -- $pattern:loadArgs:E:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :a ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at i ..." 
 -- ActArg: "1" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to L  | :do  |    e := @get inx |  ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to L  | :do  |    e := @get inx |    T.@ ..."   ...false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: "1"
 -- Invocation:qgen:superAdj: 4 
 -- ConstLiteral1
 -- isConstant: Invocation 1
 -- Invocation 1
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:4 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :a ..." 
 -- formalArg:isPtn:"in for: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e : ..." 
 -- loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at i ..." 
 -- ActArg: "L" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to L  | :do  |    e := @get inx |  ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to L  | :do  |    e := @get inx |    T.@ ..."   ...false
 -- $ObjectGenerator:gen:"L#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: "L"
 -- Invocation:qgen:superAdj: 4 
 -- ObjectInvocation_UnaryL
 -- isConstant: Invocation L
 -- Invocation L
 -- not const: LL: var integer
 -- needorigin:"L" 
 -- needOrigin:E:"L"  E.ATd:"L: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:4 
 -- computeAdr: "L" 
 -- computeAdr:1 :rec:"none"  E:"L" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "L"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- goOrigin:on:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:1 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E: ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "L: var integer" ObjectGenerator
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- After:U*U::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "L" 
 -- IV:after:computeAdr:superAdj:4 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "L" E: "L" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $var:loadArgs: "L: var integer"
 -- DataItem:loadArgs:empty: "L: var integer" 
 -- invoke:after:loadArgsOf:"L" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ: ...
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "L" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"L" 
 -- $var:invoke: newOff:4 "L: var integer"
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 4 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"L" 
 -- loadArgs:after:Qgen:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :a ..." 
 -- formalArg:isPtn:"in to: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"L" :isBasicVal:true
 -- LObjectGenerator
 -- end:loadArgs:NonVirt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e : ..." 
 -- "in do:< Object" 
 -- "e := @get inx | T.@put e :at inx" 
 -- vdt:Q: "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at inx" 
 -- formalArg: "in do:< Object" actualArg: "e := @get inx | T.@put e :at inx" 
 -- 1  (actualArg.desc).newDescno: 62  (OGx.desc).newDescNo: 67  stubDescNo ...0 
 toSuper 24
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:1 vTopMax:1 rTop:0 rTopMax:0
 -- Handle VB: "" E: "@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at i ..." 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:64 :top:1 
 -- GenClass:do#S#64:varNo = 1 
 -- GenClass:do#S#64:true -> var.genDone

class do#S#64 64 2 68
 -- Store itemArgs
 tstOriginIsNone 
 rstore 2 origin
 allocEventQ
 mvStack 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"e := S.@get inx" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "e := S.@get inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarye
 -- ObjectInvocation_Binary:= S.@get inx
 -- isConstant: Invocation e := S.@get inx
 -- Invocation e
 -- not const: ee: var integer
 -- needorigin:"e := S.@get inx" 
 -- needOrigin:E:":= S.@get inx"  E.ATd:":= :  |    %basic 8 |    in V: var Val ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "e := S.@get inx" 
 -- computeAdr:1 :rec:"none"  E:"e" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#68:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#68:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "e: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"e"  E:":= S.@get inx"  A.E:"e" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- computeAdr:isAssign:rec: "e"  E:":= S.@get inx" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- computeAdr:isLast:E: ":= S.@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "e" E: ":= S.@get inx" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:2 ":= S.@get inx"
 -- $pattern:loadArgs:E:":= S.@get inx":descNo:4:top:1 ":= :  |    %basic 8 |   ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= S.@get inx" 
 -- ActArg: "S.@get inx" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= S.@get inx" 
 -- $ObjectGenerator:gen:"@get:#S#0"IS.isempty! staticOff: 0 descNo: 0 top: ...
 -- OG:gen:super:"" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "S.@get inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryS
 -- ObjectInvocation_KeyWord@get inx
 -- isConstant: Invocation S.@get inx
 -- Invocation S
 -- not const: Sin S: ref String
 -- needorigin:"S.@get inx" 
 -- needOrigin:E:"@get inx"  E.ATd:"@get:  |    %basic 117 |    in get: var int ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "S.@get inx" 
 -- computeAdr:1 :rec:"none"  E:"S" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "S"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:3 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- goOrigin:on:2 
 -- goOrigin:@for::to:do#S#68:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#68:origin
 -- goOrigin:on:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "S"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in S: ref Stri ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"S"  E:"@get inx" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:@get inx
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@get inx"
 -- $pattern:getAdr: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@g ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "S"
 -- $ref:loadArgs: "in S: ref String"
 -- DataItem:loadArgs:empty: "in S: ref String" 
 -- $ObjectInvocation_Unary:invoke: rec:"S" "S"
 -- E.ATd: "" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"S" 
 -- $ref:invoke: newOff:2 "in S: ref String"
 -- >Object:unique:false
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F: ...
 rpushg 2 
 -- OI:invoke:S:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@get inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "S" E: "@get inx" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@get inx"
 -- $pattern:loadArgs:E:"@get inx":descNo:0:top:0 "@get:  |    %basic 117 |     ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@get inx" 
 -- ActArg: "inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@get inx" 
 -- loadArgs:not:*: formalArgOf:"@get inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"inx#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- isConstant: Invocation inx
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- invoke:after:loadArgsOf:"inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"@get inx" 
 -- formalArg:isPtn:"in get: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectGenerator
 -- end:loadArgs:NonVirt:"@get inx" 
 -- invoke:after:loadArgsOf:"@get inx" :Adr:off:2 sz:0 isF:F isUN:F sprAdj: ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"S" "@get inx"
 -- >top:0 descNo:0 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@get inx" 
 -- $pattern:invoke: "@get:  |    %basic 117 |    in get: var integer |    out ch ..."
 xpushg inx 1 0 1
 -- OI:invoke:@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@get inx" 
 -- loadArgs:after:Qgen:":= S.@get inx" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= S.@get inx" 
 -- invoke:after:loadArgsOf:":= S.@get inx" :Adr:off:2 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_Binary:invoke: rec:"e" ":= S.@get inx"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= S.@get inx" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "e" from: ":= S.@get inx" 
 -- assign:dstDI :"e: var integer" isUnitValueObj: false
 -- assign:arg: "S.@get inx" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:S.@get inx
 --  arg.super.ATd:"Invocation" "@get:  |    %basic 117 |    in get: var intege ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- store::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 2 address:storeg
 -- OI:invoke::= S.@get inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= S.@get inx" 
 -- genclass:Qgen:stmt:"i := L + inx" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "i := L + inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryi
 -- ObjectInvocation_Binary:= L + inx
 -- isConstant: Invocation i := L + inx
 -- Invocation i
 -- not const: ii: var integer
 -- needorigin:"i := L + inx" 
 -- needOrigin:E:":= L + inx"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "i := L + inx" 
 -- computeAdr:1 :rec:"none"  E:"i" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "i"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "i"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#68:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#68:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "i"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "i: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "i: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"i" ...
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"i"  E:":= L + inx"  A.E:"i" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"i" ...
 -- computeAdr:isAssign:rec: "i"  E:":= L + inx" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"i" ...
 -- computeAdr:isLast:E: ":= L + inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "i" E: ":= L + inx" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= L + inx"
 -- $pattern:loadArgs:E:":= L + inx":descNo:4:top:1 ":= :  |    %basic 8 |    i ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= L + inx" 
 -- ActArg: "L + inx" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= L + inx" 
 -- $ObjectGenerator:gen:"+#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:gen:super:"+  | --%basic 61]] | " superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "L + inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryL
 -- ObjectInvocation_Binary+ inx
 -- isConstant: Invocation L + inx
 -- Invocation L
 -- not const: LL: var integer
 -- needorigin:"L + inx" 
 -- needOrigin:E:"+ inx"  E.ATd:"+ :  |    %basic 61 |    in V: var integer |     ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "L + inx" 
 -- computeAdr:1 :rec:"none"  E:"L" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:3 "L"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:3 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- goOrigin:on:2 
 -- goOrigin:@for::to:do#S#68:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#68:origin
 -- goOrigin:on:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:3 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "L: var integer" ObjectGenerator
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- After:U*U::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"L"  E:"+ inx"  A.E:"L" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- E:notAssign:+ inx
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ inx"
 -- $pattern:getAdr: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $var:loadArgs: "L: var integer"
 -- DataItem:loadArgs:empty: "L: var integer" 
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"L" 
 -- $var:invoke: newOff:4 "L: var integer"
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 4 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "L" E: "+ inx" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ inx"
 -- $pattern:loadArgs:E:"+ inx":descNo:0:top:0 "+ :  |    %basic 61 |    in V:  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ inx" 
 -- ActArg: "inx" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "+ inx" 
 -- loadArgs:not:*: formalArgOf:"+ inx"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"inx#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 |  ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "inx"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryinx
 -- isConstant: Invocation inx
 -- Invocation inx
 -- not const: inxinx: var integer
 -- needorigin:"inx" 
 -- needOrigin:E:"inx"  E.ATd:"inx: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "inx" 
 -- computeAdr:1 :rec:"none"  E:"inx" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "inx"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "inx"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "inx"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "inx: var intege ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "inx: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"in ..."
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "inx" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "inx" E: "inx" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "inx"
 -- $var:loadArgs: "inx: var integer"
 -- DataItem:loadArgs:empty: "inx: var integer" 
 -- invoke:after:loadArgsOf:"inx" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isU ...
 -- $ObjectInvocation_Unary:invoke: rec:"inx" "inx"
 -- E.ATd: "inx" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"inx" 
 -- $var:invoke: newOff:3 "inx: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"inx" 
 -- loadArgs:after:Qgen:"+ inx" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"inx" :isBasicVal:true
 -- inxObjectGenerator
 -- end:loadArgs:NonVirt:"+ inx" 
 -- invoke:after:loadArgsOf:"+ inx" :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 i ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" "+ inx"
 -- >top:0 descNo:0 
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"+ inx" 
 -- $pattern:invoke: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- bodyC:
 plus
 -- OI:invoke:+ inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"+ inx" 
 -- loadArgs:after:Qgen:":= L + inx" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= L + inx" 
 -- invoke:after:loadArgsOf:":= L + inx" :Adr:off:3 sz:0 isF:F isUN:F sprAd ...
 -- $ObjectInvocation_Binary:invoke: rec:"i" ":= L + inx"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= L + inx" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "i" from: ":= L + inx" 
 -- assign:dstDI :"i: var integer" isUnitValueObj: false
 -- assign:arg: "L + inx" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:L + inx
 --  arg.super.ATd:"Invocation" "+ :  |    %basic 61 |    in V: var integer |     ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"i" ...
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 3 address:storeg
 -- OI:invoke::= L + inx:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= L + inx" 
 -- genclass:Qgen:stmt:"T.@put e :at i" 
 -- $ObjectGenerator:gen:"@put::at#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:gen:super:"" superDescNo:47 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 47 top: 0 "T.@put e :at i"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryT
 -- ObjectInvocation_KeyWord@put e :at i
 -- isConstant: Invocation T.@put e :at i
 -- Invocation T
 -- Invocation @put e :at i
 -- needorigin:"T.@put e :at i" 
 -- needOrigin:E:"@put e :at i"  E.ATd:"@put:  |    %basic 115 |    in put: ref ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "T.@put e :at i" 
 -- computeAdr:1 :rec:"none"  E:"T" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "T"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#68:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#68:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "T"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "T: obj Indexed ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...T ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"T"  E:"@put e :at i" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:@put e :at i
 -- $ObjectInvocation_KeyWord:getAdr::superAdj:0:on:0 "@put e :at i"
 -- $pattern:getAdr: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"@p ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "T"
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)"
 -- DataItem:loadArgs:empty: "T: obj Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Unary:invoke: rec:"T" "T"
 -- E.ATd: "" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"T" 
 -- $obj:invoke: newOff:4 "T: obj Indexed(L + S.length,Integer)"
 -- >Object:unique:false
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F: ...
 rpushg 4 
 -- OI:invoke:T:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "@put e :at i" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "T" E: "@put e :at i" isValueAssign: false
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@put e :at i"
 -- $pattern:loadArgs:E:"@put e :at i":descNo:47:top:0 "@put:  |    %basic 11 ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@put e :at i" 
 -- ActArg: "e" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:false
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@put e :at i" 
 -- loadArgs:not:*: formalArgOf:"@put e :at i"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"e#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "e"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarye
 -- isConstant: Invocation e
 -- Invocation e
 -- not const: ee: var integer
 -- needorigin:"e" 
 -- needOrigin:E:"e"  E.ATd:"e: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "e" 
 -- computeAdr:1 :rec:"none"  E:"e" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "e"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "e"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#68:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#68:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "e"
 -- $var:getAdr:,newOff:2,isValue:"True",A.isValue:"False" "e: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...e ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "e: var integer" ObjectGenerator
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"e" ...
 -- After:U*U::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "e" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "e" E: "e" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "e"
 -- $var:loadArgs: "e: var integer"
 -- DataItem:loadArgs:empty: "e: var integer" 
 -- invoke:after:loadArgsOf:"e" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ: ...
 -- $ObjectInvocation_Unary:invoke: rec:"e" "e"
 -- E.ATd: "e" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"e" 
 -- $var:invoke: newOff:2 "e: var integer"
 -- load::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 2 
 -- OI:invoke:e:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"e" 
 -- loadArgs:after:Qgen:"@put e :at i" 
 -- formalArg:isPtn:"in put: ref elm" :isBasicVal:false:valueObj:false
 -- :actArg:"e" :isBasicVal:true
 -- eObjectGenerator
 -- end:loadArgs:NonVirt:"@put e :at i" 
 -- loadArgs:NonVirt:"@put e :at i" 
 -- ActArg: "i" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "@put e :at i" 
 -- loadArgs:not:*: formalArgOf:"@put e :at i"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"i#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: "i"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unaryi
 -- isConstant: Invocation i
 -- Invocation i
 -- not const: ii: var integer
 -- needorigin:"i" 
 -- needOrigin:E:"i"  E.ATd:"i: var integer" 
 -- needOrigin:datItem:leave
 -- IV:FISK:superAdj:0 
 -- computeAdr: "i" 
 -- computeAdr:1 :rec:"none"  E:"i" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "i"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:2 "i"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:2 
 -- goOrigin:do#S#64:encOG.IS.newOriginOff:2 :newOriginOff:2 
 rpushg 2 do#S#64:origin
 -- goOrigin:on:1 
 -- goOrigin:@for::to:do#S#68:encOG.IS.newOriginOff:4 :newOriginOff:4 
 rpushg 4 @for::to:do#S#68:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:2 "i"
 -- $var:getAdr:,newOff:3,isValue:"True",A.isValue:"False" "i: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "i: var integer" ObjectGenerator
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"i" ...
 -- After:U*U::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "i" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "i" E: "i" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "i"
 -- $var:loadArgs: "i: var integer"
 -- DataItem:loadArgs:empty: "i: var integer" 
 -- invoke:after:loadArgsOf:"i" :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ: ...
 -- $ObjectInvocation_Unary:invoke: rec:"i" "i"
 -- E.ATd: "i" unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"i" 
 -- $var:invoke: newOff:3 "i: var integer"
 -- load::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 3 
 -- OI:invoke:i:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"i" 
 -- loadArgs:after:Qgen:"@put e :at i" 
 -- formalArg:isPtn:"in at: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"i" :isBasicVal:true
 -- iObjectGenerator
 -- end:loadArgs:NonVirt:"@put e :at i" 
 -- invoke:after:loadArgsOf:"@put e :at i" :Adr:off:4 sz:0 isF:F isUN:F spr ...
 -- $ObjectInvocation_KeyWord:invoke: rec:"T" "@put e :at i"
 -- >top:0 descNo:47 
 -- E.ATd: "" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"@put e :at i" 
 -- $pattern:invoke: "@put:  |    %basic 115 |    in put: ref elm |    in at: var ..."
 -- Integer
 -- primitive
 xstoreg inx 1 0 1
1 inx
 -- OI:invoke:@put e :at i:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"@put e :at i" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"none" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:2 isIndexed:0  vTop:-4 vTopMax:1 rTop:9 rTopMax:9
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:68 :top:1 
 -- GenClass:@for::to:do#S#68:varNo = 1 
 -- GenClass:@for::to:do#S#68:true -> var.genDone

class @for::to:do#S#68 68 4 66
 -- Store itemArgs
 tstOriginIsNone 
 rstore 4 origin
 -- super @for::to:do
 -- vdt:b
 --  1:61 2:0 3:0 4:0
 -- vdt:c:innerInx: 2  descNo: 68  superDesc.descNo:68 
 -- vdtAdd: inx=2 descInx=68 vDescInx=68
 -- Super:sig none
 -- $ObjectInvocation_KeyWord:loadArgs:staticOff:0 "@for 1 :to S.length  | :d ..."
 -- $pattern:loadArgs:E:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i  ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i :=  ..." 
 -- ActArg: "1" isValue: true
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to S.length  | :do  |    e := S. ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to S.length  | :do  |    e := S.@get i ..."   ...false
 -- $ObjectGenerator:gen:"integer#S#0"IS.isempty! staticOff: 0 descNo: 0 to ...
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: "1"
 -- Invocation:qgen:superAdj: 4 
 -- ConstLiteral1
 -- isConstant: Invocation 1
 -- Invocation 1
 -- needorigin:"1" 
 -- needOrigin:E:"1"  E.ATd:"integer: value |    %ID integer |    %basic 1, 32 |  ..." 
 -- LoadOrign:no:loadOrigin: "value |    %ID integer |    %basic 1, 32 |    %glob ..." 
 -- IV:after:computeAdr:superAdj:4 
 -- rec: "1" E: "1" isValueAssign: false
 -- $ConstLiteral:loadArgs: "1"
 -- invoke:after:loadArgsOf:"1" 
 -- $ConstLiteral:invoke: "1"
 pushc 1
 -- invoke:after:E.invoke:"1" 
 -- loadArgs:after:Qgen:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i  ..." 
 -- formalArg:isPtn:"in for: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"1" :isBasicVal:true
 -- 1ObjectGenerator
 -- convDone:false
 -- end:loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i ..." 
 -- loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i :=  ..." 
 -- ActArg: "S.length" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 4  "@for 1 :to S.length  | :do  |    e := S. ..." 
 -- loadArgs:not:*: formalArgOf:"@for 1 :to S.length  | :do  |    e := S.@get i ..."   ...false
 -- $ObjectGenerator:gen:"length#S#0"IS.isempty! staticOff: 0 descNo: 0 top ...
 -- OG:gen:super:"length" superDescNo:32 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 4 
 -- $Invocation:gen: descNo: 32 top: 1 "S.length"
 -- Invocation:qgen:superAdj: 4 
 -- ObjectInvocation_UnaryS
 -- ObjectInvocation_Unarylength
 -- isConstant: Invocation S.length
 -- Invocation S
 -- not const: Sin S: ref String
 -- needorigin:"S.length" 
 -- needOrigin:E:"length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- IV:FISK:superAdj:4 
 -- computeAdr: "S.length" 
 -- computeAdr:1 :rec:"none"  E:"S" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "S"
 -- AdjustOrigin:originOff: 4
 rpushg 4 origin
 -- goOrigin:on:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:4:on:1 "S"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in S: ref Stri ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:4 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"S"  E:"length" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:length
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"le ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "S"
 -- $ref:loadArgs: "in S: ref String"
 -- DataItem:loadArgs:empty: "in S: ref String" 
 -- $ObjectInvocation_Unary:invoke: rec:"S" "S"
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"S" 
 -- $ref:invoke: newOff:2 "in S: ref String"
 -- >Object:unique:false
 -- loadAdr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal ...
 rpushg 2 
 -- OI:invoke:S:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "length" 
 -- IV:after:computeAdr:superAdj:4 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "S" E: "length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "length"
 -- $pattern:loadArgs:E:"length":descNo:32:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"length" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"S" "length"
 -- >top:1 descNo:32 
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"length" 
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:32  top:1  rec:"S" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:false:rec:"S" 
 -- kuk:pattern:rec.ATd:"in S: ref String" 
 invoke length 32 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:false"S" 
 -- OI:invoke:length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"length" 
 -- loadArgs:after:Qgen:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i  ..." 
 -- formalArg:isPtn:"in to: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"S.length" :isBasicVal:true
 -- S.lengthObjectGenerator
 -- end:loadArgs:NonVirt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i ..." 
 -- "in do:< Object" 
 -- "e := S.@get inx | i := L + inx | T.@put e :at i" 
 -- vdt:Q: "@for 1 :to S.length  | :do  |    e := S.@get inx |    i := L + inx |    ..." 
 -- formalArg: "in do:< Object" actualArg: "e := S.@get inx | i := L + inx | T. ..." 
 -- 1  (actualArg.desc).newDescno: 64  (OGx.desc).newDescNo: 68  stubDescNo ...0 
 toSuper 24
 rtnInner
DO:
 mvStack 
 L1:
 L2:
 rtnInner
 end OSDV:0 objSize:4 isIndexed:0  vTop:1 vTopMax:1 rTop:0 rTopMax:0
 -- Handle VB: "" E: "@for 1 :to S.length  | :do  |    e := S.@get inx |    i :=  ..." 
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:66 :top:1 
 -- GenClass:doplus:varNo = 1 
 -- GenClass:doplus:true -> var.genDone

class doplus 66 1 69
 -- Store itemArgs
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "doplus"
 -- $var:gen: "e: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $var:gen: "i: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $obj:gen: "T: obj Indexed(L + S.length,Integer)"
 -- DI:isConst:true:isBasicValue:false:primNo:114 
 -- OGqual:Indexed:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ObjectGenerator:gen:"T"IS.isempty! staticOff: 4 descNo: 0 top:0 | superA ...
 -- OG:gen:super:"Indexed" superDescNo:70 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 70 top: 1 "Indexed(L + S.length,Integer)"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_FunctionIndexed(L + S.length,Integer)
 -- isConstant: Invocation Indexed(L + S.length,Integer)
 -- Invocation Indexed(L + S.length,Integer)
 -- needorigin:"Indexed(L + S.length,Integer)" 
 -- needOrigin:E:"Indexed(L + S.length,Integer)"  E.ATd:"Indexed:  |    %glob ..." 
 -- LoadOrign:no:loadOrigin: "%globals | %basic 114 | %public | in range: var Int ..." 
 -- IV:after:computeAdr:superAdj:0 
 -- rec: "Indexed(L + S.length,Integer)" E: "Indexed(L + S.length,Integer)" i ...false
 -- $ObjectInvocation_Function:loadArgs:staticOff:0 "Indexed(L + S.length,I ..."
 -- $pattern:loadArgs:E:"Indexed(L + S.length,Integer)":descNo:70:top:1 "In ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"Indexed(L + S.length,Integer)" 
 -- ActArg: "L + S.length" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "Indexed(L + S.length,Integer)" 
 -- loadArgs:not:*: formalArgOf:"Indexed(L + S.length,Integer)"  isComposit ...false
 -- $ObjectGenerator:gen:"+#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | su ...
 -- OG:gen:super:"+  | --%basic 61]] | " superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "L + S.length"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryL
 -- ObjectInvocation_Binary+ S.length
 -- isConstant: Invocation L + S.length
 -- Invocation L
 -- not const: LL: var integer
 -- needorigin:"L + S.length" 
 -- needOrigin:E:"+ S.length"  E.ATd:"+ :  |    %basic 61 |    in V: var intege ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "L + S.length" 
 -- computeAdr:1 :rec:"none"  E:"L" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "L"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "L: var integer" ObjectGenerator
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- After:U*U::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"L"  E:"+ S.length"  A.E:"L" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- E:notAssign:+ S.length
 -- $ObjectInvocation_Binary:getAdr::superAdj:0:on:0 "+ S.length"
 -- $pattern:getAdr: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "L"
 -- $var:loadArgs: "L: var integer"
 -- DataItem:loadArgs:empty: "L: var integer" 
 -- $ObjectInvocation_Unary:invoke: rec:"L" "L"
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"L" 
 -- $var:invoke: newOff:4 "L: var integer"
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F: ...
 -- isFloat:B: false
 pushg 4 
 -- OI:invoke:L:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "+ S.length" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "L" E: "+ S.length" isValueAssign: false
 -- $ObjectInvocation_Binary:loadArgs:staticOff:0 "+ S.length"
 -- $pattern:loadArgs:E:"+ S.length":descNo:0:top:0 "+ :  |    %basic 61 |    i ..."
 -- isValueAssign: false
 -- loadArgs:NonVirt:"+ S.length" 
 -- ActArg: "S.length" isValue: false
 -- formalArg.OG.isBasicValue:true formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:false
 -- loadArgs:not::assign:superAdj: 0  "+ S.length" 
 -- loadArgs:not:*: formalArgOf:"+ S.length"  isCompositeValueObj:false
 -- $ObjectGenerator:gen:"length#S#0"IS.isempty! staticOff: 0 descNo: 0 top ...
 -- OG:gen:super:"length" superDescNo:32 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 32 top: 1 "S.length"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryS
 -- ObjectInvocation_Unarylength
 -- isConstant: Invocation S.length
 -- Invocation S
 -- not const: Sin S: ref String
 -- needorigin:"S.length" 
 -- needOrigin:E:"length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "S.length" 
 -- computeAdr:1 :rec:"none"  E:"S" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "S"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "S"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "S"
 -- $ref:getAdr:,newOff:2,isValue:"False",A.isValue:"False" "in S: ref Stri ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...i ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"S"  E:"length" 
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:length
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"le ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "S"
 -- $ref:loadArgs: "in S: ref String"
 -- DataItem:loadArgs:empty: "in S: ref String" 
 -- $ObjectInvocation_Unary:invoke: rec:"S" "S"
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"S" 
 -- $ref:invoke: newOff:2 "in S: ref String"
 -- >Object:unique:false
 -- loadAdr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal ...
 rpushg 2 
 -- OI:invoke:S:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "length" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "S" E: "length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "length"
 -- $pattern:loadArgs:E:"length":descNo:32:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"length" :Adr:off:2 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"S" "length"
 -- >top:1 descNo:32 
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:2 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"length" 
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:32  top:1  rec:"S" 
 -- ComputeVariantX
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- <>var
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:false:rec:"S" 
 -- kuk:pattern:rec.ATd:"in S: ref String" 
 invoke length 32 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:false"S" 
 -- OI:invoke:length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"length" 
 -- loadArgs:after:Qgen:"+ S.length" 
 -- formalArg:isPtn:"in V: var integer" :isBasicVal:true:valueObj:true
 -- :actArg:"S.length" :isBasicVal:true
 -- S.lengthObjectGenerator
 -- end:loadArgs:NonVirt:"+ S.length" 
 -- invoke:after:loadArgsOf:"+ S.length" :Adr:off:4 sz:0 isF:F isUN:F sprAd ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" "+ S.length"
 -- >top:0 descNo:0 
 -- E.ATd: "+  | --%basic 61]] | " unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST"+ S.length" 
 -- $pattern:invoke: "+ :  |    %basic 61 |    in V: var integer |    out R: var  ..."
 -- bodyC:
 plus
 -- OI:invoke:+ S.length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"+ S.length" 
 -- loadArgs:after:Qgen:"Indexed(L + S.length,Integer)" 
 -- formalArg:isPtn:"in range: var Integer" :isBasicVal:true:valueObj:true
 -- :actArg:"L + S.length" :isBasicVal:true
 -- L + S.lengthObjectGenerator
 -- end:loadArgs:NonVirt:"Indexed(L + S.length,Integer)" 
 -- invoke:after:loadArgsOf:"Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Function:invoke: rec:"Indexed(L + S.length,Integer)"  ...
 -- >top:1 descNo:70 
 -- HEST"Indexed(L + S.length,Integer)" 
 -- $pattern:invoke: "Indexed:  |    %globals |    %basic 114 |    %public |    in  ..."
 pushThis 
 -- ComputeVariant:A:"Indexed" 
 -- checkIfTopIsNew:A:topVarExists:true isEmpty: false
 -- checkIfTopIsNew:ISNEW
 -- PropagateToSuper:A:
 -- PropagateToSuper:B:
 -- super.ATd is none
 -- var is not new:
 -- ComputeVariant:B: "Indexed" 
 -- ObjTmpStack:add::genDone:false "Indexed" :"%globals | %basic 114 | %public |  ..." 
 pushc 1
 allocIndexed StaticRep 70 1 0
 pushThis 
 rstoreg 4 indexed
 -- OI:invoke:Indexed(L + S.length,Integer):unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Indexed(L + S.length,Integer)" 
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"@for 1 :to L  | :do  |    e := @get inx |    T.@put e :at ..." 
 -- $ObjectGenerator:gen:"@for::to:do#S#67"IS.isempty! staticOff: 0 descNo: ...
 -- OG:gen:super:"" superDescNo:24 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 67  "@for::to:do#S#67" 
 invoke @for::to:do#S#67 67 0 1
 rpop
 -- genclass:Qgen:stmt:"@for 1 :to S.length  | :do  |    e := S.@get inx |    i : ..." 
 -- $ObjectGenerator:gen:"@for::to:do#S#68"IS.isempty! staticOff: 0 descNo: ...
 -- OG:gen:super:"" superDescNo:24 super.OG.top:1 
 -- OG:Qgen:IS is not empty:
 pushThis 
 -- before objTmpStack:add: 68  "@for::to:do#S#68" 
 invoke @for::to:do#S#68 68 0 1
 rpop
 -- genclass:Qgen:stmt:"V := T.asString" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:45 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 45 top: 1 "V := T.asString"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryV
 -- ObjectInvocation_Binary:= T.asString
 -- isConstant: Invocation V := T.asString
 -- Invocation V
 -- not const: Vout V: ref String
 -- needorigin:"V := T.asString" 
 -- needOrigin:E:":= T.asString"  E.ATd:":= :  |    %basic 8 |    in V: var Val ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "V := T.asString" 
 -- computeAdr:1 :rec:"none"  E:"V" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "V"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "V"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:doplus:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 doplus:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "V"
 -- $ref:getAdr:,newOff:3,isValue:"False",A.isValue:"False" "out V: ref Str ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...o ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"V"  E:":= T.asString" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- computeAdr:isAssign:rec: "V"  E:":= T.asString" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- computeAdr:isLast:E: ":= T.asString" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "V" E: ":= T.asString" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:3 ":= T.asString"
 -- $pattern:loadArgs:E:":= T.asString":descNo:45:top:1 ":= :  |    %basic 8 |  ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= T.asString" 
 -- ActArg: "T.asString" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= T.asString" 
 -- $ObjectGenerator:gen:"asString#S#0"IS.isempty! staticOff: 0 descNo: 0 t ...
 -- OG:gen:super:"asString" superDescNo:0 super.OG.top:0 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 0 top: 0 "T.asString"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryT
 -- ObjectInvocation_UnaryasString
 -- isConstant: Invocation T.asString
 -- Invocation T
 -- Invocation asString
 -- needorigin:"T.asString" 
 -- needOrigin:E:"asString"  E.ATd:"asString:  |    %basic 118 |    out S: ref  ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "T.asString" 
 -- computeAdr:1 :rec:"none"  E:"T" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "T"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "T"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "T"
 -- $obj:getAdr:,newOff:4,isValue:"False",A.isValue:"False" "T: obj Indexed ..."
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...T ...
 -- value_prim:false
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"T"  E:"asString" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- E:notAssign:asString
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "asString"
 -- $pattern:getAdr: "asString:  |    %basic 118 |    out S: ref Object"
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"as ..."
 -- ptn.isUnitValueObj:false isFloat:E:false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "T"
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)"
 -- DataItem:loadArgs:empty: "T: obj Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Unary:invoke: rec:"T" "T"
 -- E.ATd: "asString" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"T" 
 -- $obj:invoke: newOff:4 "T: obj Indexed(L + S.length,Integer)"
 -- >Object:unique:false
 -- load::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F: ...
 rpushg 4 
 -- OI:invoke:T:unit: -none- convFactor: 0.000000
 -- computeAdr:isLast:E: "asString" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "T" E: "asString" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "asString"
 -- $pattern:loadArgs:E:"asString":descNo:0:top:0 "asString:  |    %basic 118 ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"asString" :Adr:off:4 sz:0 isF:F isUN:F sprAdj: ...
 -- $ObjectInvocation_Unary:invoke: rec:"T" "asString"
 -- >top:0 descNo:0 
 -- E.ATd: "asString" unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"asString" 
 -- $pattern:invoke: "asString:  |    %basic 118 |    out S: ref Object"
 %asString 118
 -- OI:invoke:asString:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"asString" 
 -- loadArgs:after:Qgen:":= T.asString" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= T.asString" 
 -- invoke:after:loadArgsOf:":= T.asString" :Adr:off:3 sz:0 isF:F isUN:F sp ...
 -- $ObjectInvocation_Binary:invoke: rec:"V" ":= T.asString"
 -- >top:1 descNo:45 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST":= T.asString" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "V" from: ":= T.asString" 
 -- assign:dstDI :"out V: ref String" isUnitValueObj: false
 -- assign:arg: "T.asString" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:T.asString
 --  arg.super.ATd:"Invocation" "asString:  |    %basic 118 |    out S: ref Obj ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:reference: "V" 
 -- :Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- store::Adr:off:3 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F ...
 -- isValue:false isAdr:false descNo: 0 
 rswap
 rstoreg 3 
 -- OI:invoke::= T.asString:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= T.asString" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"doplus" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:0 vTopMax:0 rTop:2 rTopMax:3
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:69 :top:1 
 -- GenClass:+:varNo = 1 
 -- GenClass:+:true -> var.genDone

class + 69 1 12
 -- Store itemArgs
 pushThis 
 rstoreg 2 S
 tstOriginIsNone 
 rstore 1 origin
 allocEventQ
 mvStack 
 -- $Signature:gen: "+ "
 -- $ref:gen: "in S: ref String"
 -- DI:isConst:false:isBasicValue:false:primNo:5 
 -- OGqual:String:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $ref:gen: "out V: ref String"
 -- DI:isConst:false:isBasicValue:false:primNo:5 
 -- OGqual:String:OGqual.isBasicValue:false:OGqual.isValueObj:false
 -- $var:gen: "L: var integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 rtnEventQ 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"L := Length" 
 -- $ObjectGenerator:gen:":=#S#0"IS.isempty! staticOff: 0 descNo: 0 top:0 | s ...
 -- OG:gen:super:":= " superDescNo:4 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 4 top: 1 "L := Length"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryL
 -- ObjectInvocation_Binary:= Length
 -- isConstant: Invocation L := Length
 -- Invocation L
 -- not const: LL: var integer
 -- needorigin:"L := Length" 
 -- needOrigin:E:":= Length"  E.ATd:":= :  |    %basic 8 |    in V: var Value" 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "L := Length" 
 -- computeAdr:1 :rec:"none"  E:"L" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "L"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "L"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "L"
 -- $var:getAdr:,newOff:4,isValue:"True",A.isValue:"False" "L: var integer" ...
 --  A::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E: ...  ...L ...
 -- value_prim:false
 -- integer
 -- before:floatTest: "L: var integer" ObjectGenerator
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- After:U*U::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsV ...
 -- computeAdr:isFirst::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:2 :rec:"L"  E:":= Length"  A.E:"L" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- computeAdr:isAssign:rec: "L"  E:":= Length" 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- computeAdr:isLast:E: ":= Length" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "L" E: ":= Length" isValueAssign: true
 -- $ObjectInvocation_Binary:loadArgs:staticOff:4 ":= Length"
 -- $pattern:loadArgs:E:":= Length":descNo:4:top:1 ":= :  |    %basic 8 |    in ..."
 -- isValueAssign: true
 -- loadArgs:NonVirt:":= Length" 
 -- ActArg: "Length" isValue: false
 -- formalArg.OG.isBasicValue:false formalArg.OG.isValueObj:true
 --  formalArg.OG.isNonBasicValueObj:true
 -- loadArgs:isPrim:assign,fmult: 8 ":= Length" 
 -- $ObjectGenerator:gen:"length#S#0"IS.isempty! staticOff: 0 descNo: 0 top ...
 -- OG:gen:super:"length" superDescNo:32 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 32 top: 1 "Length"
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_UnaryLength
 -- isConstant: Invocation Length
 -- Invocation Length
 -- needorigin:"Length" 
 -- needOrigin:E:"Length"  E.ATd:"length:  |    out V: var integer |    V := @g ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "Length" 
 -- computeAdr:1 :rec:"none"  E:"Length" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "Length"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:1 "Length"
 -- AdjustOrigin:originOff: 0
 -- goOrigin:on:1 
 -- goOrigin:+:encOG.IS.newOriginOff:1 :newOriginOff:1 
 rpushg 1 +:origin
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:1 "Length"
 -- $pattern:getAdr: "length:  |    out V: var integer |    V := @get 0"
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"Le ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "Length" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "Length" E: "Length" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "Length"
 -- $pattern:loadArgs:E:"Length":descNo:32:top:1 "length:  |    out V: var in ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"Length" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"Length" "Length"
 -- >top:1 descNo:32 
 -- E.ATd: "length" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"Length" 
 -- $pattern:invoke: "length:  |    out V: var integer |    V := @get 0"
 -- Pattern:invoke:descNo:32  top:1  rec:"Length" 
 -- ptn:invoke::isValObj:false:rtnValObj:true:"length:  |    out V: var integ ..." 
 -- rec=E:true:rec:"Length" 
 -- kuk:pattern:rec.ATd:"length:  |    out V: var integer |    V := @get 0" 
 invoke length 32 0 0
 -- useRtnVal:true:isVal:false:rtnValObj:true:rec=E:true"Length" 
 -- OI:invoke:Length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"Length" 
 -- loadArgs:after:Qgen:":= Length" 
 -- vAssign:fArg:"in V: var Value" 
 -- BINGO
 -- aaaa: in V: var Value
 -- end:loadArgs:NonVirt:":= Length" 
 -- invoke:after:loadArgsOf:":= Length" :Adr:off:4 sz:0 isF:F isUN:F sprAdj ...
 -- $ObjectInvocation_Binary:invoke: rec:"L" ":= Length"
 -- >top:1 descNo:4 
 -- E.ATd: ":= " unique: false
 -- adr::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E ...
 -- HEST":= Length" 
 -- $pattern:invoke: ":= :  |    %basic 8 |    in V: var Value"
 -- AssignPtn:invoke:rec: "L" from: ":= Length" 
 -- assign:dstDI :"L: var integer" isUnitValueObj: false
 -- assign:arg: "Length" lab:"ObjectGenerator" UnitValObj :false ptn: false
 --  float: false DataItem:false arg.super:Length
 --  arg.super.ATd:"Invocation" "length:  |    out V: var integer |    V := @ge ..." 
 --  arg.super.ATd.isDataItem:false arg.super.ATd.isFloat:false
 --  arg.super.ATd.label: "pattern" 
 -- assign:simple value: 
 -- :Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F:E:"L" ...
 -- store::Adr:off:4 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:T orgIsVal:F ...
 -- isValue:true isAdr:false descNo: 0 
 -- isFloat:D: false
 storeg 4 address:storeg
 -- OI:invoke::= Length:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:":= Length" 
 -- genclass:Qgen:stmt:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V : ..." 
 -- $ObjectGenerator:gen:"doplus#S#0"IS.isempty! staticOff: 0 descNo: 0 top ...
 -- OG:gen:super:"doplus" superDescNo:66 super.OG.top:1 
 -- OG:Qgen:IS.isEmpty! isCompositeValueObj: falsesuperAdj: 0 
 -- $Invocation:gen: descNo: 66 top: 1 "doplus | -- V: obj Indexed(Length + S ..."
 -- Invocation:qgen:superAdj: 0 
 -- ObjectInvocation_Unarydoplus
 -- isConstant: Invocation doplus | -- V: obj Indexed(Length + S.length) |  | --  ...
 -- Invocation doplus
 -- needorigin:"doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:le ..." 
 -- needOrigin:E:"doplus"  E.ATd:"doplus:  |    e: var integer |    i: var inte ..." 
 -- IV:FISK:superAdj:0 
 -- computeAdr: "doplus | -- V: obj Indexed(Length + S.length) |  | -- V := T[1:l ..." 
 -- computeAdr:1 :rec:"none"  E:"doplus" 
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"no ..."
 -- $ObjectInvocation_Unary:pushThis: "doplus"
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin::on:0 "doplus"
 -- AdjustOrigin:originOff: 0
 -- $ObjectInvocation_Unary:getAdr::superAdj:0:on:0 "doplus"
 -- $pattern:getAdr: "doplus:  |    e: var integer |    i: var integer |    T: ob ..."
 -- :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E:"do ..."
 -- computeAdr:isFirst::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue ...
 -- computeAdr:isLast:E: "doplus" 
 -- IV:after:computeAdr:superAdj:0 :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 is ...
 -- rec: "doplus" E: "doplus" isValueAssign: false
 -- $ObjectInvocation_Unary:loadArgs:staticOff:0 "doplus"
 -- $pattern:loadArgs:E:"doplus":descNo:66:top:1 "doplus:  |    e: var intege ..."
 -- isValueAssign: false
 -- invoke:after:loadArgsOf:"doplus" :Adr:off:0 sz:0 isF:F isUN:F sprAdj:0  ...
 -- $ObjectInvocation_Unary:invoke: rec:"doplus" "doplus"
 -- >top:1 descNo:66 
 -- E.ATd: "doplus" unique: false
 -- adr::Adr:off:0 sz:0 isF:F isUN:F sprAdj:0 isUQ:F isValue:F orgIsVal:F:E ...
 -- HEST"doplus" 
 -- $pattern:invoke: "doplus:  |    e: var integer |    i: var integer |    T: ob ..."
 -- Pattern:invoke:descNo:66  top:1  rec:"doplus" 
 -- ptn:invoke::isValObj:false:rtnValObj:false:"doplus:  |    e: var integer |  ..." 
 -- rec=E:true:rec:"doplus" 
 -- kuk:pattern:rec.ATd:"doplus:  |    e: var integer |    i: var integer |    T: ..." 
 invoke doplus 66 0 0
 -- useRtnVal:false:isVal:false:rtnValObj:false:rec=E:true"doplus" 
 rpop
 -- OI:invoke:doplus:unit: -none- convFactor: 0.000000
 -- invoke:after:E.invoke:"doplus" 
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"+" 
 setThisStack 
 pushThis 
 -- $ref:invoke: newOff:3 "out V: ref String"
 -- >Object:unique:false
 -- >adr=none
 rpushg 3 V
 rtn(D)
 end OSDV:0 objSize:4 isIndexed:0  vTop:-1 vTopMax:0 rTop:1 rTopMax:1
 -- objTmpStack:next:  : done:false :var.genDone: false
 -- objTmpStack:next:genClass:70 :top:1 
 -- GenClass:Indexed:varNo = 1 
 -- GenClass:Indexed:true -> var.genDone

class Indexed 70 0 6
 -- Store itemArgs
 pushThis 
 storeg 1 range
 allocEventQ
 mvStack 
 -- $Signature:gen: "Indexed"
 -- $var:gen: "in range: var Integer"
 -- DI:isConst:false:isBasicValue:true:primNo:1 
 -- OGqual:integer:OGqual.isBasicValue:true:OGqual.isValueObj:true
 -- $pattern:gen: "in elm:< Object"
 -- vdt:d1 61 
 -- vdtAdd: inx=1 descInx=70 vDescInx=61
 rtnEventQ 0
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:Qgen:stmt:"%globals" 
 -- $Property:gen: "%globals"
 -- genclass:Qgen:stmt:"%basic 114" 
 -- $Property:gen: "%basic 114"
 -- genclass:Qgen:stmt:"%public" 
 -- $Property:gen: "%public"
 L2:
 rtnEventQ 0
 -- OG:pushReturn:"Indexed" 
 setThisStack 
 pushThis 
 rtn(D)
 end OSDV:0 objSize:1 isIndexed:1  vTop:-1 vTopMax:0 rTop:2 rTopMax:2
 -- Virtual
 -- objTmpStack:next:  : done:false :var.genDone: true

class main 71 0 0
 pushThis 
 invoke BETAworld 60 0 1
 stop
 end OSDV:0 objSize:2 isIndexed:0  vTop:0 vTopMax:0 rTop:1 rTopMax:1

class EventProcessor 72 0 0
 stop
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0

class ThreadStub 73 0 0
DO:
 call(D)ThreadStub
 stop
 end OSDV:0 objSize:1 isIndexed:0  vTop:0 vTopMax:0 rTop:0 rTopMax:0
 -- vdtAdd: inx=1 descInx=31 vDescInx=28
 -- vdtAdd: inx=1 descInx=37 vDescInx=34
 -- vdtAdd: inx=1 descInx=56 vDescInx=44
 -- vdtAdd: inx=2 descInx=56 vDescInx=48
 -- vdtAdd: inx=1 descInx=67 vDescInx=62
 -- vdtAdd: inx=1 descInx=68 vDescInx=64

Class Value descInx: 1 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class universal descInx: 2 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class char descInx: 3 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class := descInx: 4 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	storeg 3
4:	tstOriginNone 
5:	rstore 1
7:	store 2
9:	allocEventQ 1
11:	mvStack
12:	rtnEventQ 0
doE: 
14:	doEventQ 
15:	mvStack
16:	rtnEventQ 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class ascii descInx: 5 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	rtnEventQ 1
doE: 
19:	doEventQ 
20:	mvStack
21:	pushthis 
22:	pushc 13
24:	storeg 4
26:	rtnEventQ 0
28:	setThisStack
29:	pushthis 
30:	rtn D


Class BETA descInx: 6 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 5 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class integer descInx: 7 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class keyboard descInx: 8 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class Lock descInx: 9 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class screen descInx: 10 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	rpushg 1
10:	invoke 9 2 0
16:	rpop 
17:	rtnEventQ 0
doE: 
19:	doEventQ 
20:	mvStack
21:	rtnEventQ 0
23:	setThisStack
24:	pushthis 
25:	rtn D


Class BasicIO descInx: 11 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 8 2 1
14:	rpop 
15:	pushthis 
16:	invoke 10 3 1
22:	rpop 
23:	rtnEventQ 0
doE: 
25:	doEventQ 
26:	mvStack
27:	rtnEventQ 0
29:	setThisStack
30:	pushthis 
31:	rtn D


Class String descInx: 12 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class String descInx: 13 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
8:	rtnEventQ 0
doE: 
10:	doEventQ 
11:	mvStack
12:	rtnEventQ 0
14:	setThisStack
15:	pushthis 
16:	rtn D


Class LIB descInx: 14 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 11 3 1
14:	rpop 
15:	pushthis 
16:	invoke 13 4 1
22:	rpop 
23:	rtnEventQ 0
doE: 
25:	doEventQ 
26:	mvStack
27:	rtnEventQ 0
29:	setThisStack
30:	pushthis 
31:	rtn D


Class switch descInx: 15 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	innera 1
12:	rtnEventQ 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 1
19:	rpopThisObj
20:	rtnEventQ 0
22:	setThisStack
23:	pushthis 
24:	rtn D


Class Boolean descInx: 17 originOff: 0 visibility: 0
allocE:
doE: 
1:	rtnV
2:	rtn D


Class @if::then descInx: 18 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class #S#20 descInx: 20 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	sendv 1 0
21:	rpop 
22:	pushthis 
23:	rpushg 1
25:	rpushg 1
27:	rpushg 1
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 3
38:	pushc 1
40:	+
41:	storeg 3
43:	break 1 1 22
49:	rtnEventQ 0
51:	setThisStack
52:	pushthis 
53:	rtn D


Class loop descInx: 22 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	pushg 2
25:	le
26:	jmpFalse 37
29:	pushthis 
30:	invoke 20 0 1
36:	rpop 
37:	rtnEventQ 0
39:	setThisStack
40:	pushthis 
41:	rtn D


Class doIt descInx: 23 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 22 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class @for::to:do descInx: 24 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 1
9:	mvStack
10:	innera 2
12:	rtnEventQ 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	pushthis 
18:	pushg 1
20:	storeg 3
22:	pushthis 
23:	invoke 23 0 0
29:	rpop 
30:	pushthis 
31:	innerP 2
33:	rpopThisObj
34:	rtnEventQ 0
36:	setThisStack
37:	pushthis 
38:	rtn D


Class length descInx: 25 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	rtnEventQ 0
25:	setThisStack
26:	pushthis 
27:	pushg 2
29:	rtn D


Class #S#26 descInx: 26 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	innerP 1
20:	rpopThisObj
21:	break 4 2 15
27:	rtnEventQ 0
29:	setThisStack
30:	pushthis 
31:	rtn D


Class do#S#28 descInx: 28 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushg 2
20:	pushthis 
21:	rpushg 1
23:	rpushg 4
25:	rpushg 2
27:	pushthis 
28:	rpushg 1
30:	pushg 3
32:	xpushg 1 0 1
36:	eq 
37:	jmpFalse 48
40:	pushthis 
41:	invoke 26 0 1
47:	rpop 
48:	rtnEventQ 0
50:	setThisStack
51:	pushthis 
52:	rtn D


Class case descInx: 30 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	innera 1
12:	rtnEventQ 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	invoke 31 0 1
23:	rpop 
24:	rtnEventQ 0
26:	setThisStack
27:	pushthis 
28:	rtn D


Class @for::to:do#S#31 descInx: 31 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 2
11:	invoke 25 0 0
17:	toSuper 24
enterE: 
20:	rtnInner
doE: 
21:	mvStack
22:	rtnInner


Class length descInx: 32 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	rtnEventQ 0
25:	setThisStack
26:	pushthis 
27:	pushg 2
29:	rtn D


Class put descInx: 33 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class do#S#34 descInx: 34 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	rtnEventQ 0
31:	setThisStack
32:	pushthis 
33:	rtn D


Class print descInx: 36 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 37 0 1
18:	rpop 
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class @for::to:do#S#37 descInx: 37 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 32 0 0
17:	toSuper 24
enterE: 
20:	rtnInner
doE: 
21:	mvStack
22:	rtnInner


Class @ifX::thenX descInx: 39 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class #S#40 descInx: 40 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	sendv 1 0
19:	rpop 
20:	break 1 2 41
26:	rtnEventQ 0
28:	setThisStack
29:	pushthis 
30:	rtn D


Class if_L descInx: 41 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 1
16:	jmpFalse 27
19:	pushthis 
20:	invoke 40 0 1
26:	rpop 
27:	pushthis 
28:	rpushg 1
30:	sendv 2 0
33:	rpop 
34:	rtnEventQ 0
36:	setThisStack
37:	pushthis 
38:	rtn D


Class @if::then:else descInx: 42 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 41 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class isLetter descInx: 43 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushc 97
17:	pushthis 
18:	pushg 2
20:	le
21:	pushthis 
22:	pushg 2
24:	pushc 122
26:	le
27:	andd
28:	pushc 65
30:	pushthis 
31:	pushg 2
33:	le
34:	pushthis 
35:	pushg 2
37:	pushc 90
39:	le
40:	andd
41:	orr
42:	storeg 3
44:	rtnEventQ 0
46:	setThisStack
47:	pushthis 
48:	pushg 3
50:	rtn D


Class then#S#44 descInx: 44 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 3
16:	rpushg 3
18:	rpushg 1
20:	pushc 33
22:	storeg 3
24:	break 3 1 53
30:	rtnEventQ 0
32:	setThisStack
33:	pushthis 
34:	rtn D


Class := descInx: 45 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 0
doE: 
12:	doEventQ 
13:	mvStack
14:	rtnEventQ 0
16:	setThisStack
17:	pushthis 
18:	rtn D


Class C descInx: 46 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	pushc 1
12:	pushthis 
13:	pushc 1
15:	allocIndexed 70 1 0 
20:	pushthis 
21:	rstoreg 4
23:	rtnEventQ 1
doE: 
25:	doEventQ 
26:	mvStack
27:	pushthis 
28:	rpushg 4
30:	pushthis 
31:	pushg 2
33:	pushc 1
35:	xstoreg 1 0 1 
39:	pushthis 
40:	pushthis 
41:	rpushg 4
43:	%prim asString 118
45:	rswap 
46:	rstoreg 3
48:	rtnEventQ 0
50:	setThisStack
51:	pushthis 
52:	rpushg 3
54:	rtn D


Class else#S#48 descInx: 48 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushText 1
13:	pushthis 
14:	rpushg 1
16:	rpushg 3
18:	rpushg 3
20:	rpushg 1
22:	rpushg 1
24:	rpushg 1
26:	rpushg 3
28:	rpushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 3
35:	rpushg 3
37:	rpushg 1
39:	pushg 3
41:	invoke 46 0 0
47:	invoke 69 0 1
53:	pushText 9
55:	invoke 69 0 1
61:	invoke 36 0 0
67:	rpop 
68:	break 3 2 53
74:	rtnEventQ 0
76:	setThisStack
77:	pushthis 
78:	rtn D


Class loop descInx: 53 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 54 0 1
18:	rpop 
19:	pushthis 
20:	rpushg 1
22:	pushc 63
24:	storeg 3
26:	jmp 11
29:	rtnEventQ 0
31:	setThisStack
32:	pushthis 
33:	rtn D


Class switch#S#54 descInx: 54 originOff: 3 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 1
9:	rpushg 1
11:	rpushg 1
13:	rpushg 2
15:	pushthis 
16:	rpushg 3
18:	rpushg 1
20:	pushg 3
22:	toSuper 15
enterE: 
25:	rtnInner
doE: 
26:	mvStack
27:	pushthis 
28:	invoke 55 0 1
34:	rpop 
35:	pushText 5
37:	invoke 36 0 0
43:	rpop 
44:	pushthis 
45:	invoke 56 0 1
51:	rpop 
52:	rtnInner


Class case#S#55 descInx: 55 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	pushc 97
9:	pushc 1
11:	mkVindexed 
12:	toSuper 30
enterE: 
15:	rtnInner
doE: 
16:	mvStack
17:	pushText 5
19:	invoke 36 0 0
25:	rpop 
26:	rtnInner


Class @if::then:else#S#56 descInx: 56 originOff: 3 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 3
4:	pushthis 
5:	rpushg 3
7:	rpushg 3
9:	rpushg 1
11:	rpushg 1
13:	rpushg 1
15:	rpushg 2
17:	rpushg 2
19:	pushthis 
20:	rpushg 3
22:	rpushg 3
24:	rpushg 1
26:	pushg 3
28:	invoke 43 0 0
34:	toSuper 42
enterE: 
37:	rtnInner
doE: 
38:	mvStack
39:	rtnInner


Class newline descInx: 57 originOff: 0 visibility: 0
allocE:
1:	allocEventQ 1
3:	mvStack
4:	rtnEventQ 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushc 10
10:	%prim put 2
12:	rtnEventQ 0
14:	setThisStack
15:	pushthis 
16:	rtn D


Class tinyB descInx: 58 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushc 97
14:	storeg 3
16:	pushthis 
17:	invoke 53 0 0
23:	rpop 
24:	pushthis 
25:	pushg 3
27:	%prim put 2
29:	invoke 57 0 0
35:	rpop 
36:	rtnEventQ 0
38:	setThisStack
39:	pushthis 
40:	rtn D


Class workspace descInx: 59 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	invoke 58 2 1
14:	rpop 
15:	rtnEventQ 0
doE: 
17:	doEventQ 
18:	mvStack
19:	rtnEventQ 0
21:	setThisStack
22:	pushthis 
23:	rtn D


Class BETAworld descInx: 60 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
9:	pushthis 
10:	invoke 6 2 1
16:	rpop 
17:	pushthis 
18:	invoke 14 3 1
24:	rpop 
25:	pushthis 
26:	invoke 59 4 1
32:	rpop 
33:	rtnEventQ 0
doE: 
35:	doEventQ 
36:	mvStack
37:	rtnEventQ 0
39:	setThisStack
40:	pushthis 
41:	rtn D


Class Object descInx: 61 originOff: 2 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 2
4:	allocEventQ 1
6:	mvStack
7:	innera 1
9:	rtnEventQ 1
doE: 
11:	doEventQ 
12:	mvStack
13:	pushthis 
14:	innerP 1
16:	rpopThisObj
17:	rtnEventQ 0
19:	setThisStack
20:	pushthis 
21:	rtn D


Class do#S#62 descInx: 62 originOff: 2 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 2
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 2
14:	rpushg 4
16:	pushthis 
17:	rpushg 2
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 2
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 2
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 2
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 2
53:	pushg 3
55:	xstoreg 1 0 1 
59:	rtnEventQ 0
61:	setThisStack
62:	pushthis 
63:	rtn D


Class do#S#64 descInx: 64 originOff: 2 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 2
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 2
14:	rpushg 4
16:	pushthis 
17:	rpushg 2
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 2
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 2
39:	rpushg 4
41:	pushthis 
42:	rpushg 2
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 2
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 2
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 2
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 2
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	rtnEventQ 0
85:	setThisStack
86:	pushthis 
87:	rtn D


Class doplus descInx: 66 originOff: 1 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 32 0 0
23:	+
24:	pushthis 
25:	pushc 1
27:	allocIndexed 70 1 0 
32:	pushthis 
33:	rstoreg 4
35:	rtnEventQ 1
doE: 
37:	doEventQ 
38:	mvStack
39:	pushthis 
40:	invoke 67 0 1
46:	rpop 
47:	pushthis 
48:	invoke 68 0 1
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	pushthis 
59:	rpushg 4
61:	%prim asString 118
63:	rswap 
64:	rstoreg 3
66:	rtnEventQ 0
68:	setThisStack
69:	pushthis 
70:	rtn D


Class @for::to:do#S#67 descInx: 67 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	toSuper 24
enterE: 
16:	rtnInner
doE: 
17:	mvStack
18:	rtnInner


Class @for::to:do#S#68 descInx: 68 originOff: 4 visibility: 0
allocE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 32 0 0
19:	toSuper 24
enterE: 
22:	rtnInner
doE: 
23:	mvStack
24:	rtnInner


Class + descInx: 69 originOff: 1 visibility: 0
allocE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 1
9:	mvStack
10:	rtnEventQ 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	rpushg 1
18:	invoke 32 0 0
24:	storeg 4
26:	pushthis 
27:	invoke 66 0 0
33:	rpop 
34:	rtnEventQ 0
36:	setThisStack
37:	pushthis 
38:	rpushg 3
40:	rtn D


Class Indexed descInx: 70 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
7:	rtnEventQ 0
doE: 
9:	doEventQ 
10:	mvStack
11:	rtnEventQ 0
13:	setThisStack
14:	pushthis 
15:	rtn D


Class main descInx: 71 originOff: 0 visibility: 0
allocE:
1:	pushthis 
2:	invoke 60 0 1
8:	stop 


Class EventProcessor descInx: 72 originOff: 0 visibility: 0
allocE:
1:	stop 


Class ThreadStub descInx: 73 originOff: 0 visibility: 0
allocE:
doE: 
1:	call D
3:	stop 

